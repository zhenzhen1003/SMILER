protected static String METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) return "" ; <END> while ( VAR_1 . METHOD_2 ( VAR_2 ) . length > INT_1 ) { VAR_1 = VAR_1 . substring ( 0 , VAR_1 . length ( ) - 1 ) ; } return VAR_1 ; } 
public TYPE_1 ( final String VAR_2 , final String text ) { this . VAR_2 = VAR_2 ; <START> this . text = text . VAR_3 ( STRING_1 , STRING_2 ) ; <END> } 
public void METHOD_1 ( Throwable VAR_1 ) { if ( VAR_1 instanceof IOException ) { Utils . VAR_2 ( VAR_3 , VAR_4 ) ; <START> } <END> } 
<START> public TYPE_2 ( final String VAR_2 , final String text , final TYPE_1 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . text = text ; this . VAR_4 = null ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( ) { new TYPE_1 ( METHOD_2 ( ) , VAR_1 ) { @Override public void METHOD_3 ( ) { <START> TYPE_2 . METHOD_4 ( METHOD_2 ( ) , R . string . VAR_2 , TYPE_2 . VAR_3 ) . METHOD_5 ( ) ; <END> } @Override public void METHOD_6 ( TYPE_3 result ) { TYPE_2 . METHOD_4 ( METHOD_2 ( ) , R . string . VAR_4 , TYPE_2 . VAR_3 ) . METHOD_5 ( ) ; } } . execute ( ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { if ( ! VAR_1 ) <START> VAR_2 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_1 . METHOD_2 ( STRING_1 , VAR_2 . METHOD_3 ( ) . toString ( ) ) ; <START> VAR_1 . METHOD_2 ( STRING_2 , VAR_2 . METHOD_3 ( ) . toString ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 event ) { if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) != null ) { VAR_2 . METHOD_3 ( true ) ; VAR_1 . METHOD_4 ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( TYPE_3 . METHOD_5 ( ) ) ; VAR_3 . METHOD_6 ( new TYPE_4 ( ) { @Override public void run ( ) { VAR_2 . METHOD_3 ( false ) ; } <START> } , ( long ) Math . VAR_4 ( FLOAT_1 * TYPE_5 . VAR_6 ) ) ; <END> } } 
private boolean METHOD_1 ( ) { if ( cache . VAR_1 != context . VAR_2 . METHOD_2 ( ) ) { cache . VAR_3 = false ; cache . VAR_1 = context . VAR_2 . METHOD_2 ( ) ; } Boolean VAR_4 = ( Boolean ) METHOD_3 ( STRING_1 ) ; if ( VAR_4 == null ? false : VAR_4 && cache . VAR_3 ) { return true ; } <START> return false ; <END> } 
private TYPE_2 ( List < String > VAR_2 , TYPE_1 VAR_3 ) { this . VAR_4 = VAR_2 ; <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; } 
public Integer METHOD_1 ( ) throws Throwable { String VAR_1 = TYPE_1 . getInstance ( ) . METHOD_2 ( ) < 2 ? TYPE_2 : TYPE_2 . METHOD_3 ( STRING_1 , STRING_2 ) ; String VAR_2 = TYPE_3 . parse ( VAR_1 ) . METHOD_4 ( ) . query ( data . toString ( ) ) . build ( ) . toString ( ) ; <START> Log . d ( TYPE_5 . VAR_4 , STRING_3 + VAR_2 ) ; <END> return TYPE_4 . get ( VAR_2 ) . METHOD_5 ( STRING_4 , VAR_5 ) . METHOD_6 ( ) ; } 
public Object METHOD_1 ( TYPE_1 [ ] VAR_1 ) throws TYPE_2 { result . clear ( ) ; try { if ( VAR_1 . length == 1 && VAR_2 != null && VAR_1 [ 0 ] != null ) { String VAR_3 = ( ( TYPE_3 ) VAR_2 ) . METHOD_2 ( VAR_1 [ 0 ] . get ( ) ) ; result . set ( VAR_4 . METHOD_3 ( VAR_3 ) ) ; } <START> } catch ( Exception ex ) { <END> LOG . error ( ex ) ; } return result ; } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { TYPE_3 VAR_1 = TYPE_7 . VAR_3 ; TYPE_3 [ ] VAR_4 = new TYPE_3 [ ] { VAR_1 } ; TYPE_4 VAR_5 = new TYPE_4 ( TYPE_5 . class . METHOD_2 ( VAR_6 ) . METHOD_3 ( ) ) ; try { VAR_5 . METHOD_4 ( VAR_4 ) ; <START> METHOD_5 ( STRING_1 ) ; <END> } catch ( TYPE_6 VAR_7 ) { } } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { TYPE_3 VAR_1 = TYPE_7 . VAR_3 ; TYPE_3 VAR_4 = TYPE_7 . VAR_3 ; TYPE_3 [ ] VAR_5 = new TYPE_3 [ ] { VAR_1 , VAR_4 } ; TYPE_4 VAR_6 = new TYPE_4 ( TYPE_5 . class . METHOD_2 ( VAR_7 ) . METHOD_3 ( ) ) ; try { <START> VAR_6 . METHOD_4 ( VAR_5 ) ; <END> METHOD_5 ( STRING_1 ) ; } catch ( TYPE_6 VAR_8 ) { } } 
public boolean METHOD_1 ( ) { METHOD_2 ( ) ; VAR_1 . METHOD_3 ( ) ; <START> return false ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> return VAR_1 . get ( 0 ) ; } else { return null ; } } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { <END> assert VAR_3 != null : STRING_1 ; return new TYPE_1 ( VAR_3 . METHOD_2 ( VAR_1 , VAR_2 ) ) ; } 
<START> public void METHOD_1 ( ) throws TYPE_1 , IOException { <END> TYPE_2 VAR_1 = TYPE_4 . VAR_3 ; TYPE_2 VAR_4 = TYPE_4 . VAR_3 ; TYPE_2 [ ] VAR_5 = new TYPE_2 [ ] { VAR_1 , VAR_4 } ; TYPE_3 VAR_6 = new TYPE_3 ( ) ; VAR_6 . METHOD_2 ( VAR_5 ) ; } 
<START> public void METHOD_1 ( ) throws TYPE_1 , IOException { <END> TYPE_2 VAR_1 = TYPE_4 . VAR_3 ; TYPE_2 [ ] VAR_4 = new TYPE_2 [ ] { VAR_1 } ; TYPE_3 VAR_5 = new TYPE_3 ( ) ; VAR_5 . METHOD_2 ( VAR_4 ) ; } 
public void METHOD_1 ( ) throws TYPE_1 , IOException { TYPE_2 VAR_1 = TYPE_4 . VAR_3 ; TYPE_2 VAR_4 = TYPE_4 . VAR_3 ; TYPE_2 [ ] VAR_5 = new TYPE_2 [ ] { VAR_1 , VAR_4 } ; TYPE_3 VAR_6 = new TYPE_3 ( ) ; VAR_6 . METHOD_2 ( VAR_5 ) ; <START> VAR_6 . close ( ) ; <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) { <END> new TYPE_2 ( VAR_3 ) { @Override public void METHOD_5 ( TYPE_3 VAR_4 ) { METHOD_6 ( VAR_1 , VAR_4 ) ; } @Override public void METHOD_7 ( Throwable VAR_5 ) { Log . VAR_6 ( TAG , STRING_1 , VAR_5 ) ; METHOD_8 ( ) ; } } . execute ( ) ; } else { METHOD_6 ( VAR_1 , VAR_7 ) ; } } 
<START> public TYPE_5 . TYPE_6 . TYPE_9 METHOD_1 ( ) { <END> TYPE_2 client = context . VAR_2 ( ) . METHOD_2 ( TYPE_7 . TYPE_8 . METHOD_3 ( ) ) ; try { return client . query ( TYPE_7 . TYPE_8 . METHOD_3 ( ) , null , STRING_1 , new String [ ] { Integer . toString ( TYPE_7 . VAR_4 ) , Integer . toString ( TYPE_7 . VAR_5 ) } , STRING_2 ) ; } catch ( TYPE_4 e ) { throw new RuntimeException ( e ) ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> return new TYPE_1 ( VAR_1 . METHOD_2 ( STRING_1 , "" ) . METHOD_3 ( STRING_2 , STRING_3 ) , this ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 event ) { try { return super . METHOD_1 ( event ) ; } catch ( RuntimeException e ) { <START> return true ; <END> } } 
public int getType ( ) { if ( VAR_1 . startsWith ( STRING_1 ) ) { return VAR_2 ; } else if ( VAR_1 . startsWith ( STRING_2 ) ) { return VAR_3 ; } else if ( info . startsWith ( STRING_3 ) ) { return VAR_3 ; } else { <START> throw new RuntimeException ( STRING_4 ) ; <END> } } 
protected void run ( Date VAR_1 ) { try { TYPE_1 . METHOD_1 ( METHOD_2 ( ) ) ; <START> } catch ( Exception e ) { <END> Log . d ( STRING_1 , STRING_2 , e ) ; } } 
private void METHOD_1 ( ) { boolean VAR_1 = TYPE_1 . METHOD_2 ( VAR_2 ) ; TYPE_2 VAR_3 = ( TYPE_2 ) VAR_4 . METHOD_3 ( R . id . VAR_5 ) ; <START> if ( ! VAR_1 ) { <END> VAR_3 . setText ( R . string . VAR_6 ) ; } else { VAR_3 . setText ( R . string . VAR_7 ) ; } METHOD_4 ( ) ; TYPE_3 . METHOD_5 ( VAR_4 ) ; } 
public static boolean METHOD_1 ( Context ctx ) { TYPE_1 VAR_1 = ( TYPE_1 ) ctx . VAR_2 ( Context . VAR_3 ) ; TYPE_2 VAR_4 = VAR_1 . METHOD_2 ( ) ; boolean VAR_5 = VAR_4 != null && VAR_4 . METHOD_3 ( ) ; <START> return VAR_5 ; <END> } 
public void METHOD_1 ( Throwable VAR_1 ) { if ( Utils . VAR_2 ( VAR_1 , TYPE_1 . class ) && TYPE_2 . getInstance ( ) . METHOD_2 ( ) < 2 ) { TYPE_2 . getInstance ( ) . METHOD_3 ( true ) ; <START> TYPE_3 . METHOD_4 ( ) ; <END> METHOD_5 ( ) ; return ; } throw new RuntimeException ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 uri ) { if ( VAR_1 == null ) { return null ; } for ( String VAR_2 : VAR_3 ) { if ( uri . VAR_4 ( ) . startsWith ( VAR_2 ) ) { TYPE_3 VAR_5 = next . VAR_6 ( uri . VAR_4 ( ) . substring ( <START> TYPE_5 . TYPE_6 . length ( ) ) ) ; <END> if ( VAR_5 == null ) { return null ; } return new TYPE_1 ( VAR_5 , VAR_1 ) ; } } return next . VAR_6 ( uri ) ; } 
public String METHOD_1 ( String url ) throws TYPE_1 { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( url ) ; switch ( VAR_1 ) { <START> case VAR_2 : return STRING_1 ; <END> case VAR_3 : return STRING_2 ; case VAR_4 : return STRING_3 ; } return STRING_1 ; } 
private static boolean METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( ) . equals ( TYPE_1 . TYPE_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { if ( METHOD_2 ( ) ) { <START> return properties ; <END> } else { return null ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_2 ( text ) ; VAR_1 . METHOD_2 ( VAR_4 ) ; VAR_1 . METHOD_3 ( VAR_5 , VAR_2 ) ; <START> if ( METHOD_4 ( ) ) { <END> VAR_1 . METHOD_3 ( properties , VAR_2 ) ; } VAR_1 . METHOD_2 ( VAR_6 ) ; VAR_1 . METHOD_2 ( description ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_2 ( text ) ; VAR_1 . METHOD_2 ( VAR_4 ) ; VAR_1 . METHOD_3 ( VAR_5 , VAR_2 ) ; <START> VAR_1 . METHOD_2 ( VAR_6 ) ; <END> VAR_1 . METHOD_2 ( description ) ; } 
public boolean METHOD_1 ( ) { if ( METHOD_2 ( ) ) { return properties . VAR_1 ( ) ; } else { throw new TYPE_1 ( STRING_1 ) ; } <START> } <END> 
public int METHOD_1 ( ) { if ( METHOD_2 ( ) ) { return R . VAR_1 . VAR_2 ; } else if ( METHOD_3 ( ) ) { return R . VAR_1 . VAR_3 ; <START> } else { <END> return R . VAR_1 . VAR_4 ; } } 
public TYPE_1 METHOD_1 ( int VAR_1 , TYPE_2 VAR_2 , TYPE_3 result ) { try { <START> if ( result . VAR_3 ( STRING_1 ) != null ) { <END> TYPE_3 VAR_4 = ( TYPE_3 ) result . VAR_3 ( STRING_1 ) . get ( 0 ) ; TYPE_1 VAR_5 = METHOD_2 ( VAR_4 . METHOD_3 ( STRING_2 ) ) ; return VAR_5 ; } return null ; } catch ( TYPE_4 e ) { Log . VAR_6 ( TAG , e ) ; return null ; } } 
public boolean METHOD_1 ( ) { <START> return true ; <END> } 
public TYPE_1 ( String VAR_2 , String info ) { <START> super ( info ) ; <END> this . VAR_2 = VAR_2 ; this . info = info ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( model . VAR_2 ( ) == null ) { <END> return ; } VAR_3 . METHOD_2 ( VAR_1 ) ; } 
private void METHOD_1 ( boolean VAR_1 ) { if ( ! TYPE_1 . METHOD_2 ( ) || VAR_1 == VAR_2 ) { return ; } <START> if ( VAR_1 ) { <END> TYPE_2 VAR_3 = TYPE_3 . METHOD_3 ( METHOD_4 ( ) , R . VAR_3 . VAR_4 ) ; VAR_5 . METHOD_5 ( VAR_3 ) ; VAR_2 = true ; } else { TYPE_2 VAR_3 = TYPE_3 . METHOD_3 ( METHOD_4 ( ) , R . VAR_3 . VAR_6 ) ; VAR_5 . METHOD_5 ( VAR_3 ) ; VAR_2 = false ; } } 
private void METHOD_1 ( boolean VAR_1 ) { <START> if ( ! TYPE_1 . METHOD_2 ( ) ) { <END> return ; } if ( VAR_1 && ! VAR_2 ) { TYPE_2 VAR_3 = TYPE_3 . METHOD_3 ( METHOD_4 ( ) , R . VAR_3 . VAR_4 ) ; VAR_5 . METHOD_5 ( VAR_3 ) ; VAR_2 = true ; } else if ( ! VAR_1 && VAR_2 ) { TYPE_2 VAR_3 = TYPE_3 . METHOD_3 ( METHOD_4 ( ) , R . VAR_3 . VAR_6 ) ; VAR_5 . METHOD_5 ( VAR_3 ) ; VAR_2 = false ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = ( TYPE_2 ) METHOD_2 ( ) . METHOD_3 ( ) ; model = new TYPE_3 ( ) ; if ( TYPE_4 . METHOD_4 ( ) ) { VAR_3 = new TYPE_5 ( ) ; } else { VAR_3 = new TYPE_6 ( ) ; } <START> VAR_4 = new TYPE_7 ( METHOD_2 ( ) ) ; <END> } 
public TYPE_2 ( boolean VAR_2 , TYPE_1 VAR_3 , int VAR_4 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; this . VAR_3 = VAR_3 ; } 
public boolean METHOD_1 ( ) { <START> return ! ( VAR_1 . equals ( "" ) && VAR_2 . equals ( "" ) & VAR_3 . equals ( "" ) ) ; <END> } 
private void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 ) { VAR_2 . METHOD_2 ( VAR_3 ) ; VAR_2 . METHOD_3 ( ) ; <START> } else { <END> VAR_2 . METHOD_4 ( VAR_3 , VAR_4 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 entry ) { TYPE_3 VAR_2 = new TYPE_3 ( ) ; <START> if ( VAR_3 . size ( ) > 0 ) { <END> VAR_3 . add ( VAR_3 . size ( ) - 1 , VAR_2 ) ; } else { VAR_3 . add ( VAR_2 ) ; } VAR_2 . METHOD_2 ( ) . add ( new TYPE_4 ( VAR_1 , entry ) ) ; VAR_4 . METHOD_3 ( ) ; } 
public int METHOD_1 ( ) { TYPE_1 res = VAR_1 . METHOD_2 ( ) ; <START> return ( int ) ( res . VAR_2 ( R . VAR_3 . VAR_4 ) <END> / res . VAR_5 ( ) . VAR_6 ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> TYPE_1 VAR_2 = super . METHOD_1 ( VAR_1 ) ; VAR_2 . METHOD_2 ( ) . METHOD_3 ( new TYPE_3 ( TYPE_4 . VAR_4 ) ) ; return VAR_2 ; } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { <START> METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_1 , null , VAR_2 ) ; <END> } } 
public TYPE_1 < TYPE_2 > METHOD_1 ( int i , TYPE_3 VAR_1 ) { TYPE_4 VAR_2 = new TYPE_4 ( VAR_3 . METHOD_2 ( ) , null ) ; String VAR_4 = TYPE_4 . TYPE_8 . METHOD_3 ( VAR_2 , TYPE_4 . TYPE_8 . VAR_5 ) ; String [ ] VAR_6 = TYPE_4 . TYPE_8 . METHOD_4 ( VAR_2 ) ; return new TYPE_6 ( <START> VAR_3 . METHOD_5 ( ) , <END> TYPE_7 . parse ( TYPE_4 . TYPE_8 . METHOD_6 ( ) . toString ( ) ) , null , VAR_4 , VAR_6 , null ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_1 ( <START> TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) , <END> VAR_1 , METHOD_4 ( ) , METHOD_5 ( ) , METHOD_6 ( VAR_1 ) ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , int VAR_3 ) { <START> METHOD_1 ( METHOD_2 ( VAR_1 ) , VAR_1 . getString ( VAR_2 ) , VAR_3 ) ; <END> } 
<START> public static void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <END> METHOD_1 ( METHOD_2 ( VAR_1 ) , VAR_1 . getString ( VAR_2 ) , TYPE_2 . VAR_4 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( STRING_1 , TYPE_3 . VAR_3 ) ; VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( STRING_2 ) ) ; } return VAR_1 ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> TYPE_2 . getInstance ( ) . METHOD_2 ( this ) ; <END> TYPE_3 . METHOD_3 ( this ) ; METHOD_4 ( TYPE_2 . getInstance ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; METHOD_7 ( ) ; if ( METHOD_8 ( ) != null ) { METHOD_8 ( ) . METHOD_9 ( true ) ; } METHOD_10 ( this ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_2 . METHOD_1 ( ) ? TYPE_3 . VAR_6 : TYPE_3 . VAR_7 ) ; <START> version = VAR_8 ; <END> } 
public static boolean METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( ) ) { <START> return TYPE_1 . METHOD_3 ( ) ; <END> } boolean VAR_1 = METHOD_4 ( ) ; TYPE_1 . METHOD_5 ( VAR_1 ) ; return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 , TYPE_2 VAR_2 ) { VAR_3 . METHOD_2 ( VAR_2 ) ; boolean VAR_4 = VAR_5 . METHOD_3 ( ) > 0 ; VAR_6 . METHOD_4 ( VAR_4 ? View . VAR_7 : View . VAR_8 ) ; <START> if ( ! METHOD_5 ( ) ) { <END> return ; } METHOD_6 ( ) . METHOD_7 ( ) ; } 
public void METHOD_1 ( ) { VAR_1 = false ; METHOD_2 ( ) . METHOD_3 ( ) ; <START> METHOD_2 ( ) . METHOD_3 ( ) ; <END> ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_4 ( ) . METHOD_5 ( false ) ; METHOD_6 ( false ) ; ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_7 ( ) . METHOD_8 ( true ) ; VAR_2 . METHOD_9 ( View . VAR_3 ) ; METHOD_10 ( METHOD_2 ( ) ) ; METHOD_11 ( VAR_4 ) ; } 
public void METHOD_1 ( Map < TYPE_1 , TYPE_2 > result ) { if ( ! METHOD_2 ( ) ) { return ; } <START> if ( result . size ( ) > 0 ) { <END> VAR_1 . METHOD_3 ( View . VAR_2 ) ; VAR_3 = ( TYPE_2 ) result . values ( ) . METHOD_4 ( ) [ 0 ] ; METHOD_5 ( ) ; } else { METHOD_6 ( ) ; } } 
public void METHOD_1 ( TYPE_1 . view . TYPE_2 VAR_2 ) { METHOD_2 ( ) ; VAR_3 . METHOD_3 ( false ) ; <START> super . METHOD_1 ( VAR_2 ) ; <END> } 
<START> public boolean METHOD_1 ( ) throws InterruptedException { <END> if ( ! VAR_1 . METHOD_1 ( TYPE_1 . VAR_3 , TYPE_1 . VAR_4 ) ) { throw new InterruptedException ( STRING_1 ) ; } return VAR_1 . METHOD_1 ( TYPE_1 . VAR_3 , TYPE_1 . VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , ANNOTATION_1 TYPE_2 location ) { if ( METHOD_2 ( ) . METHOD_3 ( VAR_3 ) == null ) { TYPE_3 VAR_4 = VAR_5 . METHOD_4 ( ) <START> ? TYPE_4 . METHOD_5 ( VAR_1 , VAR_2 ) <END> : TYPE_5 . METHOD_5 ( VAR_1 , VAR_2 , location ) ; VAR_4 . METHOD_6 ( METHOD_2 ( ) , VAR_3 ) ; } } 
public Object METHOD_1 ( TYPE_1 [ ] VAR_1 ) throws TYPE_2 { result . clear ( ) ; if ( VAR_1 . length == 1 && VAR_2 != null && VAR_1 [ 0 ] != null ) { <START> String VAR_3 = ( ( TYPE_3 ) VAR_2 ) . METHOD_2 ( VAR_1 [ 0 ] . get ( ) ) ; <END> result . set ( TYPE_4 . METHOD_3 ( VAR_3 ) ) ; } return result ; } 
<START> public synchronized TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( this ) ; } return VAR_1 ; } 
private TYPE_4 . TYPE_5 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_4 . TYPE_5 VAR_2 ; <START> VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) <END> . create ( TYPE_4 . TYPE_5 . class ) ; return VAR_2 ; } 
private TYPE_6 . TYPE_7 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_6 . TYPE_7 VAR_2 ; <START> VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 , <END> String . format ( TYPE_8 . VAR_4 , TYPE_4 . METHOD_3 ( ) , TYPE_5 . getInstance ( ) . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) ) ) . create ( TYPE_6 . TYPE_7 . class ) ; return VAR_2 ; } 
public static boolean METHOD_1 ( ) { <START> return ! METHOD_2 ( R . string . VAR_1 , false ) ; <END> } 
public static float METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = METHOD_2 ( ) . VAR_2 ; <END> } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( new TYPE_2 ( STRING_1 ) ) ; <END> } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , int i ) { <END> VAR_1 . METHOD_2 ( VAR_2 , 0 ) ; VAR_1 . METHOD_2 ( VAR_3 , 0 ) ; } 
public void METHOD_1 ( ) { new TYPE_1 ( ) { @Override public void METHOD_2 ( Throwable VAR_1 ) { <START> TYPE_2 . e ( STRING_1 + VAR_1 . getMessage ( ) ) ; <END> } @Override public void METHOD_3 ( TYPE_3 result ) { if ( result . VAR_2 ( ) ) { TYPE_2 . i ( STRING_2 ) ; VAR_3 . METHOD_4 ( new TYPE_4 ( result . VAR_4 ( ) ) , true ) ; } else { TYPE_2 . i ( STRING_3 ) ; METHOD_5 ( ) ; } } } . execute ( ) ; } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; bind ( ) ; <START> TYPE_1 . METHOD_3 ( VAR_1 ) ; <END> TYPE_1 . METHOD_3 ( VAR_2 ) ; TYPE_1 . METHOD_3 ( VAR_3 ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { if ( VAR_2 . isEmpty ( ) ) { <START> VAR_3 = VAR_1 ; <END> return ; } for ( TYPE_1 page : VAR_2 ) { page . VAR_4 ( VAR_1 ) ; TYPE_2 . instance ( ) . METHOD_2 ( page ) ; } } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 . size ( ) == 0 ) { <END> return VAR_2 ; } for ( TYPE_1 page : VAR_1 ) { if ( ! page . VAR_3 ( ) ) { return false ; } } return true ; } 
public TYPE_2 ( ANNOTATION_1 TYPE_1 row ) { super ( row . key ( ) , row ) ; <START> VAR_2 = null ; <END> } 
public < T extends TYPE_1 > void METHOD_1 ( Class < T > type , List < TYPE_1 > VAR_1 ) { Iterator < TYPE_1 > iterator = VAR_1 . iterator ( ) ; while ( iterator . hasNext ( ) ) { TYPE_1 VAR_2 = iterator . next ( ) ; if ( type . VAR_3 ( VAR_2 ) ) { <START> VAR_1 . remove ( VAR_2 ) ; <END> } } } 
public void request ( ANNOTATION_1 Context context , int VAR_1 , final TYPE_3 . TYPE_4 VAR_2 ) { <START> VAR_2 . METHOD_1 ( this , new TYPE_2 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> return new TYPE_1 ( TYPE_3 . TYPE_4 . METHOD_2 ( ) <END> ? VAR_1 . METHOD_3 ( STRING_1 , "" ) : VAR_1 . METHOD_3 ( STRING_2 , "" ) , this ) ; } 
ANNOTATION_1 public TYPE_1 METHOD_1 ( ANNOTATION_2 TYPE_2 VAR_1 ) { <START> VAR_2 . setText ( VAR_1 ) ; <END> return this ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; VAR_1 . METHOD_3 ( true ) ; VAR_2 . METHOD_4 ( model . VAR_3 ( ) ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; <START> if ( METHOD_8 ( ) . METHOD_9 ( ) != null ) { <END> METHOD_8 ( ) . METHOD_9 ( ) . METHOD_10 ( ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; VAR_1 . METHOD_3 ( true ) ; VAR_2 . METHOD_4 ( model . VAR_3 ( ) ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; if <START> ( METHOD_8 ( ) <END> != null && METHOD_9 ( ) != null ) { METHOD_9 ( ) . METHOD_10 ( ) ; } } 
<START> public static boolean METHOD_1 ( ) { <END> List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; return ! VAR_1 . isEmpty ( ) && ! VAR_1 . get ( 0 ) . METHOD_3 ( ) . isEmpty ( ) ; } 
public void <START> METHOD_1 ( TYPE_1 <END> VAR_1 , TYPE_2 VAR_2 ) { VAR_2 . METHOD_2 ( R . VAR_1 . VAR_3 , VAR_1 ) ; VAR_4 . METHOD_3 ( new TYPE_3 ( ) { @Override public void run ( ) { METHOD_4 ( ) ; } } ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null ) { <START> VAR_1 . METHOD_3 ( ) . METHOD_4 ( View . VAR_2 ) ; <END> } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <START> VAR_2 = <END> VAR_1 ; if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( this ) ; VAR_2 . METHOD_3 ( this ) ; VAR_2 . METHOD_4 ( this ) ; VAR_2 . METHOD_5 ( this ) ; } } 
private static TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException { try { Class . VAR_2 ( STRING_1 ) . METHOD_2 ( ) ; TYPE_2 VAR_3 = TYPE_3 . METHOD_3 ( STRING_2 + VAR_1 ) ; return new TYPE_1 ( VAR_3 ) ; } catch ( Exception e ) { <START> throw ( IOException ) new IOException ( e . getMessage ( ) ) . METHOD_4 ( e ) ; <END> } } 
private static TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException { try { Class . VAR_2 ( STRING_1 ) . METHOD_2 ( ) ; TYPE_2 VAR_3 = TYPE_3 . METHOD_3 ( STRING_2 + VAR_1 ) ; return new TYPE_1 ( VAR_3 ) ; } catch ( Exception e ) { <START> throw new IOException ( e . toString ( ) ) ; <END> } } 
<START> ANNOTATION_1 ( R . id . VAR_1 ) protected void METHOD_1 ( View v ) { <END> if ( VAR_2 != null ) { VAR_2 . METHOD_1 ( ) ; } } 
public final < T > TYPE_1 < T > create ( ANNOTATION_1 TYPE_2 VAR_1 , ANNOTATION_1 TYPE_3 < T > VAR_2 ) { Class < ? > VAR_3 = VAR_2 . METHOD_1 ( ) ; Set < TYPE_4 > VAR_4 = METHOD_2 ( VAR_3 ) ; if ( ! VAR_4 . isEmpty ( ) ) { METHOD_3 ( VAR_4 , true ) ; return new TYPE_5 < > ( VAR_1 . METHOD_4 ( TYPE_6 . class ) , VAR_1 . METHOD_5 ( this , VAR_2 ) , VAR_4 ) ; } <START> return null ; <END> } 
@Override ANNOTATION_1 public T read ( TYPE_1 in ) throws IOException { <START> TYPE_2 VAR_1 = VAR_2 . read ( in ) ; T VAR_3 = VAR_4 . METHOD_1 ( VAR_1 ) ; <END> return METHOD_2 ( VAR_3 , VAR_5 ) ? VAR_3 : null ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 < ? > call ) { if ( call == null ) { return ; } call . VAR_1 ( ) ; <START> call = null ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( STRING_1 , VAR_2 ) ; <START> VAR_1 . METHOD_3 ( STRING_2 , TYPE_2 . METHOD_4 ( VAR_3 ) ) ; <END> VAR_1 . METHOD_2 ( STRING_3 , METHOD_5 ( ) ) ; VAR_1 . METHOD_3 ( VAR_4 , VAR_5 . METHOD_6 ( ) ) ; } 
private TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 , double VAR_2 , double VAR_3 ) { TYPE_2 location = new <START> TYPE_2 ( VAR_1 ) ; <END> location . VAR_4 ( VAR_2 ) ; location . VAR_5 ( VAR_3 ) ; return new TYPE_1 ( location ) ; } 
private void METHOD_1 ( ANNOTATION_1 TYPE_1 < TYPE_2 > call , ANNOTATION_1 TYPE_3 VAR_1 ) { METHOD_2 ( VAR_1 ) . METHOD_3 ( METHOD_4 ( call ) ) ; METHOD_2 ( VAR_1 , <START> METHOD_5 ( ) ) . METHOD_6 ( METHOD_4 ( call ) , <END> METHOD_7 ( Throwable . VAR_2 ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 < TYPE_2 > call , ANNOTATION_1 Response < TYPE_2 > response ) { if ( response . VAR_1 ( ) ) { if ( response . VAR_2 ( ) == null ) { <START> VAR_3 . METHOD_2 ( call , new TYPE_3 ( STRING_1 ) ) ; <END> } VAR_3 . METHOD_3 ( call , response . VAR_2 ( ) ) ; } else { VAR_3 . METHOD_2 ( call , TYPE_4 . METHOD_4 ( response , VAR_4 . METHOD_5 ( ) ) ) ; } } 
public View METHOD_1 ( Context context , TYPE_1 VAR_1 , TYPE_2 parent ) { <START> return ( ( TYPE_3 ) context . VAR_2 ( Context . VAR_3 ) ) <END> . METHOD_2 ( VAR_4 . R . VAR_5 . VAR_6 , parent , false ) ; } 
@Override protected TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( this ) ; <END> return VAR_1 ; } 
ANNOTATION_1 public void METHOD_1 ( ANNOTATION_2 ( VAR_1 = { VAR_2 , VAR_3 } ) int VAR_4 , ANNOTATION_3 TYPE_1 VAR_5 ) { METHOD_2 ( VAR_4 , TYPE_3 . VAR_7 , VAR_5 , TYPE_4 . VAR_9 ) ; VAR_10 = new TYPE_2 ( ctx ( ) ) ; <START> METHOD_3 ( VAR_10 ) ; <END> } 
ANNOTATION_1 <START> @Override public <END> TYPE_1 type ( ) { return TYPE_1 . VAR_1 ; } 
public TYPE_2 ( Context context ) { super ( context ) ; <START> METHOD_1 ( METHOD_2 ( ) , R . VAR_2 . VAR_3 , <END> this ) ; TYPE_1 . bind ( this ) ; } 
private String METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ) { return TYPE_1 . METHOD_4 ( METHOD_5 ( ) , new TYPE_2 ( VAR_2 ) . METHOD_6 ( ) ) ; } <START> else <END> if ( VAR_3 != null ) { return VAR_3 . METHOD_7 ( ) ; } return null ; } 
protected void METHOD_1 ( TYPE_1 [ ] VAR_1 , int i , TYPE_2 type ) throws TYPE_3 { TYPE_2 VAR_2 = ( ( TYPE_4 ) VAR_1 [ i ] ) . METHOD_2 ( ) ; if ( VAR_2 != type ) { throw new <START> TYPE_3 ( 0 , <END> STRING_1 + type . getClass ( ) . METHOD_3 ( ) + STRING_2 + METHOD_4 ( ) + STRING_3 + VAR_1 [ i ] . METHOD_5 ( ) + STRING_4 ) ; } } 
<START> ANNOTATION_1 <END> public void METHOD_1 ( ANNOTATION_2 String VAR_1 , int id ) { VAR_2 . put ( VAR_1 , id ) ; } 
public int METHOD_1 ( ANNOTATION_1 String VAR_1 ) { Integer id = VAR_2 . get ( VAR_1 ) ; return <START> id != null ? id : 0 ; <END> } 
public static <START> HashMap < String , <END> Integer > METHOD_1 ( ) { TYPE_1 < HashMap < String , Integer > > type = new TYPE_1 < HashMap < String , Integer > > ( ) { } ; return TYPE_2 . METHOD_2 ( type , getString ( R . string . VAR_1 , STRING_1 ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <START> METHOD_1 ( VAR_2 . METHOD_2 ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 , int VAR_2 ) { if ( VAR_1 instanceof TYPE_2 ) { ( ( TYPE_2 ) <START> VAR_1 ) . METHOD_2 ( VAR_3 . METHOD_3 ( ) . get ( VAR_2 ) ) ; <END> } } 
private TYPE_1 METHOD_1 ( ANNOTATION_1 Context context , ANNOTATION_2 Throwable VAR_1 ) { if ( VAR_1 != null && ! METHOD_2 ( context , VAR_1 ) ) { if ( context instanceof TYPE_2 ) { return TYPE_1 . VAR_2 ; } <START> else { <END> return TYPE_1 . VAR_3 ; } } return TYPE_1 . VAR_4 ; } 
public TYPE_2 ( TYPE_1 VAR_2 , Date VAR_3 , int VAR_4 , Map < Long , Boolean > VAR_5 , int VAR_6 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 != null ? new Date ( VAR_3 . METHOD_1 ( ) ) : null ; <END> this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; } 
@Override protected void METHOD_1 ( int VAR_1 ) { if ( VAR_1 == 0 ) { METHOD_2 ( new TYPE_1 ( ) ) ; METHOD_2 ( new TYPE_2 ( ) ) ; } METHOD_2 ( new TYPE_3 ( ) ) ; METHOD_2 ( new TYPE_4 ( ) ) ; if ( VAR_1 == 0 ) { METHOD_2 ( new TYPE_5 ( ) ) ; } METHOD_2 ( new TYPE_6 ( ) ) ; if ( VAR_1 == 0 ) { METHOD_2 ( new TYPE_7 ( ) ) ; } <START> METHOD_2 ( new TYPE_8 ( ) ) ; <END> } 
@Override public void error ( ANNOTATION_1 Throwable VAR_1 ) { <START> if ( VAR_1 instanceof TYPE_3 . TYPE_4 ) { METHOD_1 ( new TYPE_2 ( ) ) ; } <END> METHOD_2 ( VAR_2 ) ; } 
public TYPE_1 < TYPE_2 < TYPE_3 > > request ( ANNOTATION_1 TYPE_4 VAR_1 , ANNOTATION_1 TYPE_5 VAR_2 , ANNOTATION_1 TYPE_6 VAR_3 ) { <START> List < TYPE_5 > VAR_4 = new ArrayList < > ( ) ; VAR_4 . add ( VAR_2 ) ; <END> return request ( VAR_1 , VAR_5 . METHOD_1 ( VAR_1 ) , VAR_4 , VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 , TYPE_3 format ) { TYPE_1 VAR_3 = null ; try { VAR_3 = TYPE_4 . parse ( VAR_1 , VAR_2 , format ) ; } catch ( IOException VAR_4 ) { log . error ( STRING_1 , VAR_4 . getMessage ( ) ) ; System . VAR_5 ( 1 ) ; } catch ( TYPE_5 VAR_6 ) { log . error ( STRING_2 , VAR_6 . getMessage ( ) ) ; System . VAR_5 ( 1 ) ; <START> return null ; <END> } return VAR_3 ; } 
@Override public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { VAR_3 = VAR_1 ; <START> VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; <END> VAR_1 . METHOD_4 ( ) . METHOD_5 ( R . VAR_2 . VAR_4 , VAR_2 ) ; return true ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_1 , VAR_4 , VAR_5 ) ; <START> VAR_1 . close ( ) ; <END> } 
<START> @Override public <END> void METHOD_1 ( ) { VAR_1 . METHOD_2 ( null ) ; VAR_2 . METHOD_3 ( ) ; VAR_2 = null ; super . METHOD_1 ( ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; } 
static < TYPE_1 extends TYPE_2 , TYPE_3 extends TYPE_4 < TYPE_1 > > TYPE_1 METHOD_1 ( TYPE_5 < TYPE_3 , TYPE_6 > VAR_1 , TYPE_7 parser , TYPE_6 VAR_2 ) throws IOException { TYPE_3 state = VAR_1 . parse ( parser , VAR_2 ) ; String error = <START> state . VAR_3 ( ) ; <END> if ( error != null ) { throw new TYPE_8 ( parser . VAR_4 ( ) , error ) ; } return state . VAR_5 ( ) ; } 
double <START> METHOD_1 ( double <END> VAR_1 ) { return VAR_2 . METHOD_2 ( VAR_1 ) / TYPE_1 . VAR_4 ; } 
TYPE_5 ( int size ) { VAR_2 = new TYPE_1 ( TYPE_2 . METHOD_1 ( ) , TYPE_3 . METHOD_1 ( ) , VAR_3 ) ; list = new ArrayList < > ( ) ; VAR_4 = new TYPE_4 ( TYPE_2 . METHOD_1 ( ) , TYPE_3 . METHOD_1 ( ) , VAR_3 ) ; <START> this . size = size ; <END> } 
public TYPE_1 ( String host ) { VAR_2 = STRING_1 + host ; <START> String VAR_3 = STRING_2 + host ; <END> VAR_4 = VAR_2 + STRING_3 ; VAR_5 = VAR_3 + STRING_3 ; entity = VAR_2 + STRING_4 ; VAR_6 = entity + STRING_5 ; value = VAR_2 + STRING_6 ; VAR_7 = VAR_2 + STRING_7 ; VAR_8 = VAR_2 + STRING_8 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = <START> TYPE_3 . METHOD_1 ( VAR_2 ) ; <END> this . VAR_3 = TYPE_3 . METHOD_1 ( VAR_3 ) ; } 
public void METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_1 ( ) ) { return ; } <START> TYPE_1 . getInstance ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_2 . METHOD_5 ( TYPE_3 . VAR_2 ) ) ; <END> METHOD_6 ( ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; if ( ! METHOD_2 ( ) ) { return ; } if ( VAR_1 ) { VAR_2 . METHOD_3 ( ) ; <START> VAR_3 . METHOD_4 ( ) ; <END> } else { VAR_2 . METHOD_5 ( ) ; } } 
public static <START> TYPE_7 . TYPE_9 < ? extends TYPE_7 . TYPE_8 > METHOD_1 ( <END> String VAR_1 , Collection < String > VAR_2 , TYPE_3 VAR_3 , int VAR_4 , Date VAR_5 ) { Map < String , Class < ? extends TYPE_4 > > VAR_6 = METHOD_2 ( VAR_2 ) ; TYPE_5 < String > VAR_7 = TYPE_5 . METHOD_3 ( VAR_6 . keySet ( ) ) ; return new TYPE_6 ( METHOD_4 ( VAR_1 , VAR_6 , VAR_4 ) , VAR_3 , VAR_5 , VAR_4 , VAR_7 ) ; } 
public TYPE_2 ( Context ctx , TYPE_1 VAR_2 ) { <START> this ( ctx , <END> VAR_2 , 0 ) ; } 
private TYPE_1 METHOD_1 ( String name , int id ) { TYPE_1 VAR_1 = <START> METHOD_2 ( TYPE_1 . class ) ; <END> when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( id ) ; when ( VAR_1 . METHOD_5 ( ) ) . METHOD_4 ( name ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { VAR_1 = VAR_2 . stream ( ) . METHOD_2 ( ( String VAR_3 ) - > VAR_4 . METHOD_3 ( VAR_3 ) . stream ( ) ) . map ( p - > new TYPE_1 ( p . VAR_3 ( ) , p . VAR_5 ( ) ) ) <START> . collect ( ImmutableList . VAR_6 ( ) ) ; <END> } 
private int METHOD_1 ( char [ ] s , int VAR_1 ) { if ( VAR_1 > 5 && <START> TYPE_1 . startsWith ( s , <END> VAR_1 , STRING_1 ) ) return TYPE_1 . METHOD_2 ( s , 0 , VAR_1 , 3 ) ; return VAR_1 ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , int position ) { String VAR_2 = TYPE_2 . getInstance ( ) . METHOD_2 ( VAR_3 . get ( position ) ) ; <START> VAR_1 . VAR_2 . setText ( String . format ( METHOD_3 ( ) . getString ( R . string . VAR_4 ) , String . valueOf ( position + 1 ) , VAR_2 == null ? VAR_3 . get ( position ) : VAR_2 ) ) ; <END> } 
public void METHOD_1 ( int VAR_1 , int VAR_2 , TYPE_1 data ) { super . METHOD_1 ( VAR_1 , VAR_2 , data ) ; if ( VAR_1 == VAR_3 ) { if ( VAR_2 == TYPE_2 . VAR_5 ) { int position = data . VAR_6 ( VAR_7 , 0 ) ; METHOD_2 ( position ) ; if ( VAR_8 . METHOD_3 ( ) . METHOD_4 ( ) . size ( ) == 1 ) { <START> VAR_9 . METHOD_5 ( query , <END> query != null && query . length ( ) > 1 ) ; } } } } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_2 ) ; <END> super . METHOD_1 ( VAR_1 ) ; METHOD_3 ( ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 container , int position , ANNOTATION_1 Object object ) { View view = ( ( View ) object ) ; container . VAR_1 ( view ) ; <START> view . VAR_2 ( - 1 ) ; <END> } 
public TYPE_1 build ( String source , TYPE_2 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_3 == null ) { return new TYPE_1 . TYPE_6 ( VAR_4 , source , VAR_1 , VAR_2 ) ; } else { <START> TYPE_4 VAR_5 = <END> VAR_3 . METHOD_1 ( source ) ; return new TYPE_1 . TYPE_7 ( VAR_4 , VAR_5 , source , VAR_1 , VAR_2 ) ; } } 
public final boolean METHOD_1 ( ) throws IOException { if ( input . VAR_1 ( ) ) { String VAR_2 = TYPE_1 . METHOD_2 ( VAR_3 . toString ( ) ) ; if ( VAR_2 != null ) <START> VAR_3 . METHOD_3 ( ) . append ( VAR_2 ) ; <END> return true ; } else { return false ; } } 
public void METHOD_1 ( int VAR_1 ) { <START> new TYPE_1 ( ) . METHOD_2 ( ( ) - > { <END> VAR_2 . METHOD_3 ( VAR_1 ) ; if ( VAR_1 == VAR_3 ) { new TYPE_1 ( ) . METHOD_2 ( ( ) - > { METHOD_4 ( VAR_4 ) ; VAR_2 . METHOD_3 ( VAR_5 ) ; } , VAR_6 ) ; } } , VAR_7 ) ; } 
public TYPE_1 < String > METHOD_1 ( TYPE_2 message ) { long VAR_1 = 0 ; String VAR_2 ; try { <START> VAR_2 = new String ( message . VAR_3 ( ) , STRING_1 ) ; <END> } catch ( TYPE_3 e ) { log . error ( STRING_2 , e ) ; VAR_2 = new String ( message . VAR_3 ( ) ) ; } return new TYPE_1 < String > ( VAR_2 , System . currentTimeMillis ( ) ) ; } 
public static void METHOD_1 ( Map < String , String > VAR_1 , String VAR_2 , String uri ) { if ( ! VAR_1 . containsKey ( VAR_2 ) ) { VAR_1 . put ( VAR_2 , uri ) ; } else { final String VAR_3 = VAR_1 . get ( VAR_2 ) ; if ( ! VAR_3 . equals ( uri ) ) { <START> log . warn ( STRING_1 , <END> VAR_2 , VAR_3 , uri ) ; } } } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ( TYPE_1 . METHOD_3 ( ) <START> && TYPE_1 . METHOD_4 ( ) >= VAR_2 ) ? <END> VAR_3 : VAR_4 ) ; } 
TYPE_2 ( ) { TYPE_1 . Builder builder = new TYPE_1 . Builder ( ) ; builder . add ( STRING_1 , STRING_2 ) ; builder . add ( STRING_3 , STRING_2 ) ; <START> builder . add ( STRING_4 , STRING_5 ) ; builder . add ( STRING_6 , STRING_5 ) ; <END> VAR_2 = builder . build ( ) ; } 
private void METHOD_1 ( TYPE_1 out ) throws IOException { TYPE_2 VAR_1 = new TYPE_2 ( ) ; try ( TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 ) ) { VAR_3 . METHOD_2 ( VAR_2 ) ; } byte [ ] VAR_4 = VAR_1 . METHOD_3 ( ) ; <START> out . VAR_5 ( VAR_4 . length ) ; <END> out . write ( VAR_4 ) ; } 
static Iterator < TYPE_1 > METHOD_1 ( Iterator < String > iterator ) throws IOException { TYPE_2 VAR_1 = new TYPE_3 ( TYPE_4 . METHOD_2 ( ) ) ; while ( iterator . hasNext ( ) ) { VAR_1 . add ( new TYPE_5 ( iterator . next ( ) ) ) ; } TYPE_6 < Object > VAR_2 = METHOD_3 ( VAR_1 ) ; return VAR_2 == null ? TYPE_7 . METHOD_4 ( ) : <START> Collections . VAR_3 ( new <END> TYPE_1 ( VAR_2 ) ) . iterator ( ) ; } 
public <START> static String <END> METHOD_1 ( int count ) { return TYPE_1 . METHOD_2 ( count ) ; } 
private TYPE_1 <START> METHOD_1 ( TYPE_1 <END> item , TYPE_1 VAR_1 , String VAR_2 ) { if ( VAR_1 == null ) { if ( VAR_2 . equals ( item . VAR_3 ( ) ) ) { return item ; } return null ; } else { return VAR_1 ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> TYPE_1 event = this . VAR_2 . parse ( VAR_1 , false ) ; <END> return this . METHOD_1 ( event ) ; } 
public static TYPE_1 METHOD_1 ( final String VAR_1 ) throws IOException { final File VAR_2 = new File ( VAR_1 ) ; <START> if ( ! VAR_2 . exists ( ) ) { <END> throw new TYPE_2 ( VAR_2 . toString ( ) ) ; } final TYPE_1 properties = new TYPE_1 ( ) ; final TYPE_3 is = new TYPE_4 ( VAR_2 ) ; try { properties . VAR_3 ( is ) ; } finally { if ( is != null ) { is . close ( ) ; } } return properties ; } 
public TYPE_2 ( int VAR_2 ) { this . VAR_3 = new TYPE_1 < > ( VAR_2 , <START> true ) ; <END> } 
TYPE_3 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; String VAR_3 = <START> System . getProperty ( STRING_1 ) ; <END> VAR_4 = Boolean . VAR_5 . toString ( ) . equals ( VAR_3 ) ; id = TYPE_2 . METHOD_1 ( ) . toString ( ) . METHOD_2 ( STRING_2 , "" ) ; } 
private int METHOD_1 ( final int VAR_1 ) { <START> if ( VAR_1 < 0 || VAR_1 >= text . length ) { <END> return 0 ; } return text [ VAR_1 ] ; } 
void <START> METHOD_1 ( StringBuilder <END> VAR_1 ) { METHOD_2 ( VAR_1 , VAR_2 ) ; } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> super . METHOD_2 ( VAR_1 ) ; } 
<START> public synchronized boolean METHOD_1 ( final long VAR_1 ) { <END> this . VAR_2 . METHOD_2 ( ( int ) ( INT_1 < < INT_2 | VAR_1 ) ) ; TYPE_1 VAR_3 = this . METHOD_3 ( VAR_1 ) ; boolean VAR_4 = VAR_3 . METHOD_4 ( ) ; if ( VAR_4 ) { VAR_3 . METHOD_5 ( ) ; } return VAR_4 ; } 
<START> public double METHOD_1 ( ) { <END> return VAR_1 ; } 
public int METHOD_1 ( String VAR_1 ) { VAR_2 = VAR_3 . METHOD_2 ( STRING_1 + VAR_1 + STRING_2 ) ; if ( VAR_2 == null ) return - 1 ; else { try { while ( VAR_2 . next ( ) ) { return VAR_2 . getInt ( STRING_3 ) ; } } catch ( TYPE_1 e ) { <START> new IllegalStateException ( STRING_4 + e ) ; <END> } } return - 1 ; } 
public List < Thread > METHOD_1 ( ) { try { METHOD_2 ( ) ; } catch ( TYPE_1 e ) { <START> new IllegalStateException ( STRING_1 + e ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( double VAR_1 ) { <START> this . VAR_2 = <END> VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; VAR_3 = new TYPE_2 ( METHOD_2 ( ) ) ; VAR_3 . METHOD_4 ( ) ; VAR_3 . METHOD_5 ( ) ; VAR_4 = new TYPE_3 ( VAR_2 , ( ( TYPE_4 ) METHOD_2 ( ) ) . METHOD_6 ( ) ) ; METHOD_7 ( VAR_4 ) ; METHOD_8 ( ) . METHOD_9 ( 0 , null , this ) ; <START> METHOD_10 ( ) . METHOD_11 ( TYPE_5 . VAR_6 ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 , String [ ] VAR_2 ) { <END> String VAR_3 = STRING_1 ; String [ ] VAR_4 = new String [ ] { VAR_1 } ; return query ( VAR_3 , VAR_4 , VAR_2 ) ; } 
<START> public TYPE_1 METHOD_1 ( String query , String [ ] VAR_1 ) { <END> String VAR_2 = VAR_3 + STRING_1 ; String [ ] VAR_4 = new String [ ] { STRING_2 + query + STRING_2 } ; return query ( VAR_2 , VAR_4 , VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , View view , int position , long id ) { <START> Log . i ( STRING_1 , <END> STRING_2 ) ; super . METHOD_1 ( VAR_1 , view , position , id ) ; TYPE_2 item = ( TYPE_2 ) METHOD_2 ( ) . METHOD_3 ( position ) ; VAR_2 . METHOD_4 ( item ) ; VAR_3 . METHOD_5 ( TYPE_4 . TYPE_3 . VAR_6 ) ; } 
protected boolean METHOD_1 ( String token , TYPE_1 VAR_1 ) { try { TYPE_2 response = client . VAR_2 ( token , VAR_1 . METHOD_2 ( ) ) ; if ( response . getStatus ( ) == INT_1 ) { return true ; } } catch ( Exception e ) { LOG . warn ( String . format ( STRING_1 , VAR_1 . METHOD_2 ( ) ) ) ; <START> return false ; <END> } return false ; } 
public boolean METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( METHOD_2 ( ) , TYPE_2 . getInstance ( ) ) ; <END> return true ; } 
<START> public void METHOD_1 ( ByteBuffer VAR_1 ) { <END> VAR_1 . put ( data , 0 , METHOD_2 ( ) ) ; } 
private void METHOD_1 ( ) { view . VAR_1 ( new TYPE_1 ( ) { @Override public void METHOD_2 ( TYPE_2 e ) { int index = TYPE_3 . getInstance ( ) . METHOD_3 ( view ) ; TYPE_3 . getInstance ( ) . remove ( index ) ; view . VAR_2 ( ) ; view . VAR_3 ( ) ; TYPE_3 . getInstance ( ) . METHOD_4 ( 0 ) ; } <START> } ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 , TYPE_4 { TYPE_5 b = METHOD_2 ( VAR_1 ) ; if ( b == null || b . VAR_3 ( ) == null ) { return ; } for ( TYPE_1 VAR_4 : b . VAR_3 ( ) ) { TYPE_6 p = ( TYPE_6 ) METHOD_3 ( VAR_4 ) ; <START> if ( p . VAR_5 ( ) . equals ( VAR_2 ) ) { <END> METHOD_1 ( p ) ; return ; } } } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , String VAR_4 ) { super ( VAR_2 , <START> TYPE_3 . VAR_6 ) ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 , TYPE_3 . class ) ; TYPE_6 . TYPE_7 VAR_3 = ( TYPE_6 . TYPE_7 ) VAR_1 ; if ( VAR_3 . getType ( ) == TYPE_6 . TYPE_7 . Type . VAR_4 && VAR_3 . METHOD_3 ( ) ) { <START> TYPE_5 VAR_5 = ( TYPE_5 ) this ; VAR_5 . METHOD_4 ( ) ; <END> } METHOD_5 ( VAR_3 ) ; } 
public void METHOD_1 ( ) { throw new TYPE_2 . TYPE_3 ( STRING_1 + STRING_2 + <START> this . getClass ( ) <END> + STRING_3 + STRING_4 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( TYPE_2 . class ) ; assertTrue ( VAR_1 . METHOD_3 ( VAR_2 ) ) ; TYPE_1 VAR_3 = TYPE_3 . METHOD_4 ( VAR_2 , TYPE_1 . class ) ; <START> assertTrue ( VAR_1 . equals ( VAR_3 ) ) ; <END> } 
public TYPE_1 ( ) { <START> url = STRING_1 ; <END> } 
public void METHOD_1 ( int VAR_1 ) { String VAR_2 = TYPE_1 . METHOD_2 ( context , VAR_1 ) ; <START> TYPE_2 VAR_3 = new TYPE_3 ( ) ; <END> VAR_4 = VAR_3 . METHOD_3 ( VAR_2 ) ; } 
public void METHOD_1 ( float x , float y ) { <START> if ( VAR_1 . x < x && VAR_1 . y < y ) { <END> offset . x = x ; offset . y = y ; } } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; VAR_3 = new HashMap < String , List < Double > > ( ) ; } 
public static TYPE_1 METHOD_1 ( ArrayList < TYPE_1 > position , String VAR_1 ) { <START> for ( TYPE_1 VAR_2 : position ) { <END> if ( VAR_2 . METHOD_2 ( ) . equals ( VAR_1 ) ) { position . remove ( VAR_2 ) ; return VAR_2 ; } } return null ; } 
public static int METHOD_1 ( ArrayList < TYPE_1 > position , String VAR_1 ) { int VAR_2 = 0 ; for ( TYPE_1 VAR_3 : position ) { if ( VAR_3 . METHOD_2 ( ) . equals ( VAR_1 ) ) { <START> VAR_2 += VAR_3 . METHOD_3 ( ) ; <END> } } return VAR_2 ; } 
public TYPE_4 ( String name ) { <START> this . VAR_2 = name ; <END> VAR_3 = new HashMap < String , TYPE_1 > ( ) ; VAR_4 = new TYPE_2 ( this ) ; VAR_5 = new TYPE_3 ( this ) ; } 
public TYPE_2 ( String name , double VAR_2 ) { <START> super ( ) ; <END> this . name = name ; this . VAR_2 = VAR_2 ; this . VAR_3 = new ArrayList < TYPE_1 > ( ) ; this . VAR_4 = new ArrayList < TYPE_1 > ( ) ; } 
public TYPE_2 ( TYPE_1 m ) { <START> super ( ) ; <END> this . VAR_2 = m ; VAR_3 = new HashMap < String , List < Double > > ( ) ; } 
public TYPE_2 ( String VAR_2 , double VAR_3 ) { <START> super ( ) ; <END> this . name = name ; this . VAR_3 = VAR_3 ; this . position = new ArrayList < TYPE_1 > ( ) ; this . VAR_4 = new ArrayList < TYPE_1 > ( ) ; } 
public static boolean METHOD_1 ( ArrayList < TYPE_1 > VAR_1 , TYPE_1 VAR_2 ) { for ( TYPE_1 VAR_3 : VAR_1 ) { if <START> ( ( ( VAR_3 instanceof TYPE_2 ) && ( VAR_2 instanceof TYPE_2 ) ) || ( ( VAR_3 instanceof TYPE_3 ) && ( VAR_2 instanceof TYPE_3 ) ) ) { <END> if ( VAR_3 . METHOD_2 ( ) . equals ( VAR_2 . METHOD_2 ( ) ) ) { return true ; } } } return false ; } 
public TYPE_3 ( String name , double VAR_2 ) { <START> super ( ) ; <END> this . name = name ; this . VAR_2 = VAR_2 ; this . position = new ArrayList < TYPE_1 > ( ) ; this . VAR_3 = new ArrayList < TYPE_2 > ( ) ; } 
public <START> TYPE_2 ( String <END> VAR_2 , int VAR_3 , double VAR_4 , TYPE_1 VAR_5 ) { VAR_6 = VAR_2 ; size = VAR_3 ; VAR_7 = VAR_4 ; VAR_8 = VAR_5 ; } 
<START> public void <END> METHOD_1 ( HashMap < String , ArrayList < TYPE_1 > > VAR_1 ) { this . VAR_1 = VAR_1 ; } 
public TYPE_2 ( TYPE_1 m ) { super ( ) ; <START> this . m = VAR_2 ; <END> VAR_3 = new HashMap < String , List < Double > > ( ) ; } 
public boolean equals ( Object obj ) { if ( null == obj || ! ( obj instanceof TYPE_1 ) ) return false ; TYPE_1 o = ( TYPE_1 ) obj ; return <START> VAR_1 . equals ( o . VAR_1 ) <END> && VAR_2 . equals ( o . VAR_2 ) ; } 
public void METHOD_1 ( View v ) { <START> if ( VAR_1 == v ) { <END> } else if ( VAR_2 == v ) { } else if ( VAR_3 == v ) { } else if ( VAR_4 == v ) { } } 
public TYPE_1 get ( ANNOTATION_1 ( STRING_1 ) TYPE_2 id ) throws TYPE_3 , TYPE_4 { if ( ! VAR_1 . METHOD_1 ( context , TYPE_8 . VAR_3 , id ) ) { throw new TYPE_5 ( STRING_2 ) ; } org . VAR_4 . cluster . data . TYPE_1 VAR_5 = VAR_6 . METHOD_2 ( id ) ; if ( VAR_5 == null ) { throw new TYPE_6 ( STRING_3 ) ; } TYPE_1 VAR_7 = <START> TYPE_7 . METHOD_3 ( VAR_5 ) ; <END> VAR_7 . METHOD_4 ( METHOD_5 ( ) ) ; return VAR_7 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; <START> VAR_2 = false ; <END> } 
public static TYPE_1 . Builder METHOD_1 ( ) { if <START> ( ! METHOD_2 ( ) ) <END> { return METHOD_3 ( ) ; } else { return METHOD_4 ( ) ; } } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 action , boolean VAR_3 ) { super ( VAR_2 , action ) ; this . VAR_3 = VAR_3 ; <START> if ( ! action . equals ( TYPE_2 . VAR_4 ) && <END> ! action . equals ( TYPE_2 . VAR_5 ) && ! action . equals ( TYPE_2 . VAR_6 ) ) { throw new IllegalArgumentException ( STRING_1 + STRING_2 ) ; } } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 action , TYPE_3 VAR_3 ) { super ( VAR_2 , action , VAR_3 ) ; if ( action != TYPE_2 . VAR_4 && action != TYPE_2 . VAR_5 <START> && action <END> != TYPE_2 . VAR_6 && action != TYPE_2 . VAR_7 ) throw new IllegalArgumentException ( STRING_1 + STRING_2 ) ; } 
public static boolean METHOD_1 ( ) { return <START> Boolean . VAR_1 ( System . VAR_2 ( STRING_1 ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; VAR_1 = METHOD_2 ( ) ; <START> TYPE_2 = TYPE_1 . METHOD_3 ( ) ? STRING_1 : STRING_2 ; TYPE_3 = TYPE_1 . METHOD_3 ( ) ? STRING_3 : STRING_4 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; switch ( action ) { <START> case VAR_2 : VAR_3 = TYPE_3 . TYPE_2 ; break ; case VAR_6 : VAR_3 = TYPE_3 . TYPE_5 ; break ; case VAR_8 : VAR_3 = TYPE_3 . TYPE_4 ; break ; <END> default : throw new IllegalArgumentException ( STRING_1 ) ; } } 
public static void METHOD_1 ( ByteBuffer buf , TYPE_1 VAR_1 ) { int start = buf . position ( ) ; int VAR_2 = buf . VAR_3 ( ) ; <START> while ( buf . VAR_4 ( ) > VAR_5 ) { <END> short VAR_6 = buf . VAR_7 ( ) ; short VAR_8 = METHOD_2 ( buf . VAR_7 ( ) ) ; buf . VAR_3 ( VAR_2 ) ; VAR_1 . METHOD_3 ( buf , VAR_8 ) ; buf . position ( start ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == null ) { return null ; } <END> return METHOD_2 ( VAR_2 , VAR_1 ) ; } 
public static String METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) return null ; try { return VAR_1 . METHOD_2 ( CHAR_1 , CHAR_2 ) . METHOD_3 ( ) ; <START> } catch ( IllegalArgumentException ex ) { <END> return null ; } } 
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING_1 ) . append ( VAR_1 ) . append ( STRING_2 ) . append ( VAR_2 . METHOD_1 ( ) ) . <START> append ( STRING_3 ) ; <END> return sb . toString ( ) ; } 
public void METHOD_1 ( Context context ) { if ( ! VAR_1 ) { return ; } if ( VAR_2 == null ) { if ( TYPE_1 . isEmpty ( VAR_3 ) ) { VAR_3 = STRING_1 ; } VAR_2 = TYPE_2 . METHOD_2 ( context , "" , VAR_3 , true ) ; return ; } if ( VAR_2 . METHOD_3 ( ) ) { return ; } <START> <END> VAR_2 . METHOD_2 ( ) ; } 
public byte [ ] METHOD_1 ( ) throws TYPE_1 { TYPE_2 . e ( VAR_1 ) ; if ( VAR_1 == null ) <START> { <END> return super . METHOD_1 ( ) ; } return VAR_1 . METHOD_2 ( ) ; } 
void METHOD_1 ( ) { for ( int i = 0 ; i < VAR_1 ; i ++ ) <START> for ( int j = 0 ; j < VAR_1 ; j ++ ) VAR_2 [ i ] [ j ] . METHOD_2 ( new TYPE_1 ( VAR_3 ) ) ; <END> field . VAR_4 ( ) ; } 
public boolean METHOD_1 ( ) { boolean VAR_1 = false ; if ( METHOD_2 ( ) ) VAR_1 = true ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { for ( int j = 0 ; j < ( VAR_2 - 1 ) ; j ++ ) { int VAR_3 = j + 1 ; VAR_1 = METHOD_3 ( i , VAR_3 , i , j , VAR_1 ) ; } } if <START> ( METHOD_2 ( ) ) VAR_1 = true ; <END> return VAR_1 ; } 
public boolean METHOD_1 ( ) { boolean VAR_1 = false ; if <START> ( METHOD_2 ( ) ) VAR_1 = true ; <END> for ( int i = 0 ; i < VAR_2 ; i ++ ) { for ( int j = VAR_2 - 1 ; j > 0 ; j -- ) { int VAR_3 = j - 1 ; VAR_1 = METHOD_3 ( i , VAR_3 , i , j , VAR_1 ) ; } } if ( METHOD_2 ( ) ) VAR_1 = true ; return VAR_1 ; } 
public void METHOD_1 ( ) { <START> for ( int i = 0 ; i < VAR_1 ; i ++ ) for ( int j = 0 ; j < VAR_2 ; j ++ ) { VAR_3 [ i ] [ j ] = ( int ) ( Math . VAR_4 ( ) * 2 ) == 0 ? ( byte ) 1 : ( byte ) 0 ; } <END> } 
<START> private short METHOD_1 ( short x ) { <END> if ( x == - 1 ) return ( short ) ( VAR_1 - 1 ) ; if ( x == VAR_1 ) return ( short ) 0 ; return x ; } 
private byte METHOD_1 ( byte VAR_1 , byte VAR_2 ) { if ( VAR_1 == 0 ) { <START> if ( VAR_2 == 3 ) return ( byte ) 1 ; else return ( byte ) 0 ; <END> } else { if ( VAR_2 == 2 || VAR_2 == 3 ) return ( byte ) 1 ; else return ( byte ) 0 ; } } 
public void METHOD_1 ( int VAR_1 ) { <START> if ( ( this . VAR_1 > INT_1 && this . VAR_1 < VAR_1 ) || ( this . VAR_1 < INT_2 && this . VAR_1 > VAR_1 ) ) return ; else this . VAR_1 = VAR_1 ; <END> } 
public void METHOD_1 ( ) { this . VAR_1 . METHOD_2 ( VAR_2 ) ; this . VAR_1 . METHOD_2 ( VAR_3 ) ; this . VAR_1 . METHOD_2 ( VAR_4 ) ; this . parent . VAR_5 ( ) ; <START> <END> this . VAR_1 = null ; this . VAR_6 = null ; this . parent = null ; } 
public void METHOD_1 ( ) { <START> this . METHOD_2 ( null ) ; <END> this . VAR_1 = null ; } 
public void METHOD_1 ( ) { VAR_1 . VAR_2 . METHOD_2 ( this ) ; VAR_1 . VAR_2 . METHOD_3 ( this ) ; VAR_1 . VAR_2 . METHOD_4 ( this ) ; <START> this . METHOD_5 ( null ) ; <END> this . VAR_3 = null ; this . VAR_1 = null ; } 
public void METHOD_1 ( ) { <START> this . METHOD_2 ( null ) ; <END> this . VAR_1 = null ; } 
public void METHOD_1 ( ) { VAR_1 . VAR_2 . METHOD_2 ( this ) ; VAR_1 . VAR_2 . METHOD_3 ( this ) ; VAR_1 . VAR_2 . METHOD_4 ( this ) ; <START> this . METHOD_5 ( null ) ; <END> this . VAR_3 = null ; this . VAR_4 = null ; this . VAR_5 = null ; this . status = null ; this . VAR_1 = null ; } 
<START> public void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( null ) ; VAR_1 = null ; super . METHOD_1 ( ) ; } 
public synchronized void METHOD_1 ( ) { String path = METHOD_2 ( VAR_1 ) ; File file = new File ( path ) ; <START> if ( file . exists ( ) ) { <END> try { file . VAR_2 ( ) ; } catch ( TYPE_1 ex ) { } } } 
public void METHOD_1 ( final TYPE_1 task ) { VAR_1 . execute ( new TYPE_1 ( ) { public void run ( ) { <START> System . out . println ( STRING_1 ) ; <END> task . run ( ) ; System . out . println ( STRING_2 ) ; } } ) ; } 
private void METHOD_1 ( String VAR_1 , boolean result ) { <START> String VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <END> if ( result ) { VAR_3 . METHOD_3 ( VAR_2 ) ; } if ( VAR_2 != null ) { VAR_3 . METHOD_4 ( VAR_2 ) ; } VAR_3 . METHOD_5 ( VAR_2 ) ; } 
public void METHOD_1 ( ) { try { TYPE_1 t = new TYPE_1 ( ) ; <START> t . run ( ) ; <END> METHOD_2 ( STRING_1 ) ; } catch ( TYPE_2 e ) { } } 
<START> public synchronized int METHOD_1 ( TYPE_1 uri , String VAR_1 , String [ ] VAR_2 ) { <END> TYPE_2 args = new TYPE_2 ( uri , VAR_1 , VAR_2 ) ; synchronized ( VAR_3 ) { TYPE_3 db = VAR_4 . METHOD_2 ( ) ; int count = db . VAR_5 ( args . table , args . VAR_6 , args . args ) ; if ( count > 0 ) METHOD_3 ( uri ) ; return count ; } } 
<START> public synchronized int update ( TYPE_1 uri , TYPE_2 values , String VAR_1 , String [ ] VAR_2 ) { <END> TYPE_3 args = new TYPE_3 ( uri , VAR_1 , VAR_2 ) ; synchronized ( VAR_3 ) { TYPE_4 db = VAR_4 . METHOD_1 ( ) ; int count = db . update ( args . table , values , args . VAR_5 , args . args ) ; if ( count > 0 ) METHOD_2 ( uri ) ; return count ; } } 
public void METHOD_1 ( Context context , TYPE_1 VAR_1 ) { VAR_2 = context ; if ( TYPE_2 . equals ( VAR_1 . METHOD_2 ( ) ) ) { TYPE_3 VAR_3 = VAR_1 . METHOD_3 ( ) ; byte [ ] VAR_4 = ( byte [ ] ) VAR_1 . METHOD_4 ( STRING_1 ) ; TYPE_4 message = METHOD_5 ( context , VAR_3 , VAR_4 ) ; if ( message . getStatus ( ) < TYPE_6 . VAR_6 ) TYPE_5 . METHOD_6 ( context , <START> true , message . VAR_7 ) ; <END> } } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == null ) { return false ; } String VAR_2 ; try { VAR_2 = VAR_1 . METHOD_3 ( VAR_3 ) ; <START> return STRING_1 . equalsIgnoreCase ( VAR_2 ) ; <END> } catch ( Exception e ) { return false ; } } 
VAR_1 ( ) { TYPE_1 VAR_2 = ( TYPE_1 ) VAR_3 . METHOD_1 ( Context . VAR_4 ) ; boolean VAR_5 = VAR_2 . METHOD_2 ( ) ; <START> METHOD_3 ( VAR_5 ) ; <END> } 
public static void METHOD_1 ( String command ) { String [ ] args = { STRING_1 , STRING_2 , command } ; try { <START> TYPE_2 . VAR_2 . METHOD_2 ( STRING_1 , args ) ; <END> } catch ( TYPE_1 e ) { throw new RuntimeException ( e ) ; } } 
public boolean METHOD_1 ( ) { TYPE_1 config = METHOD_2 ( ) . METHOD_3 ( ) ; <START> return METHOD_4 ( ) || config . VAR_1 == TYPE_1 . VAR_2 <END> || config . VAR_3 == TYPE_1 . VAR_4 ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { for ( TYPE_2 VAR_2 : METHOD_2 ( ) ) { try { VAR_1 . run ( METHOD_3 ( VAR_2 ) ) ; <START> } catch ( Exception e ) { <END> throw new Exception ( STRING_1 + VAR_2 . getName ( ) , e ) ; } } } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { for ( TYPE_2 VAR_2 : METHOD_2 ( ) ) { for ( TYPE_2 VAR_3 : METHOD_2 ( ) ) { try { VAR_1 . run ( METHOD_3 ( VAR_2 ) , METHOD_3 ( VAR_3 ) ) ; <START> } catch ( Exception e ) { <END> throw new Exception ( STRING_1 + VAR_2 . getName ( ) + STRING_2 + VAR_3 . getName ( ) , e ) ; } } } } 
public TYPE_2 ( TYPE_1 VAR_2 , int VAR_3 , boolean VAR_4 ) { super ( VAR_2 ) ; VAR_5 = VAR_3 ; VAR_6 = VAR_4 ; <START> METHOD_1 ( METHOD_2 ( ) | SWT . VAR_7 ) ; <END> } 
<START> private String METHOD_1 ( int VAR_1 ) { <END> switch ( VAR_1 ) { case TYPE_1 . VAR_3 : return STRING_1 ; case TYPE_1 . VAR_4 : return STRING_2 ; case TYPE_1 . VAR_5 : return STRING_3 ; case TYPE_1 . VAR_6 : return STRING_4 ; } throw new IllegalArgumentException ( STRING_5 + VAR_1 ) ; } 
<START> private int METHOD_1 ( String s ) { <END> if ( s . equals ( STRING_1 ) ) { return TYPE_1 . VAR_2 ; } if ( s . equals ( STRING_2 ) ) { return TYPE_1 . VAR_3 ; } if ( s . equals ( STRING_3 ) ) { return TYPE_1 . VAR_4 ; } if ( s . equals ( STRING_4 ) ) { return TYPE_1 . VAR_5 ; } throw new IllegalArgumentException ( STRING_5 + s + STRING_6 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 url = new TYPE_1 ( STRING_1 ) ; try { url . VAR_1 ( ) ; METHOD_2 ( ) ; <START> } catch ( Exception VAR_2 ) { } <END> } 
protected void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 TYPE_2 e ) { <START> if ( VAR_2 . length == 1 ) { <END> VAR_2 [ 0 ] . METHOD_2 ( VAR_3 , e ) ; return ; } for ( TYPE_3 VAR_4 : VAR_2 ) { if ( VAR_4 . METHOD_2 ( VAR_3 , e ) ) { return ; } } } 
public String METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> } 
<START> List < TYPE_1 > METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 ) { <END> List < TYPE_1 > result = TYPE_3 . METHOD_2 ( ) ; for ( TYPE_4 element : VAR_1 . METHOD_3 ( ) ) { List < TYPE_1 > values = METHOD_1 ( element ) ; if ( values != null && ! values . isEmpty ( ) ) { result . addAll ( values ) ; } } return result ; } 
public static void METHOD_1 ( ) { boolean VAR_1 ; synchronized ( VAR_2 ) { VAR_1 = VAR_3 ; VAR_3 = false ; } if ( VAR_1 ) { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; } TYPE_1 . METHOD_2 ( ) . METHOD_1 ( ) ; <START> VAR_4 = <END> true ; } 
public int METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , int VAR_3 ) { <START> VAR_4 = VAR_1 != null ? VAR_1 . METHOD_2 ( STRING_1 , 0 ) : 0 ; <END> if ( VAR_4 != 0 ) { Log . v ( TAG , STRING_2 + VAR_3 + STRING_3 + VAR_4 + STRING_4 + METHOD_3 ( VAR_4 ) ) ; } TYPE_2 msg = VAR_5 . METHOD_4 ( ) ; msg . VAR_6 = VAR_3 ; msg . obj = VAR_1 ; VAR_5 . METHOD_5 ( msg ) ; return TYPE_3 . VAR_8 ; } 
<START> public void METHOD_1 ( ) { <END> VAR_1 . start ( ) ; VAR_2 = new TYPE_1 ( new TYPE_2 ( VAR_1 . METHOD_2 ( ) ) { @Override public void METHOD_3 ( TYPE_3 msg ) { switch ( msg . VAR_3 ) { case VAR_4 : METHOD_4 ( ) ; break ; case VAR_5 : METHOD_5 ( false ) ; break ; default : super . METHOD_3 ( msg ) ; } } } ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || <START> ! getClass ( ) . METHOD_1 ( o . getClass ( ) ) ) return <END> false ; TYPE_1 that = ( TYPE_1 ) o ; if ( ! VAR_1 . equals ( that . VAR_1 ) ) return false ; if ( ! VAR_2 . equals ( that . VAR_2 ) ) return false ; return true ; } 
public boolean filter ( String filter , boolean VAR_1 , TYPE_1 VAR_2 ) { return METHOD_1 ( filter , VAR_2 ) || METHOD_2 ( filter , VAR_1 , <START> VAR_2 ) . size ( ) > 0 ; <END> } 
<START> private static File [ ] METHOD_1 ( String path ) { <END> List < File > result = METHOD_2 ( path , null , false ) ; return result . VAR_1 ( new File [ result . size ( ) ] ) ; } 
protected TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 ) throws IOException { <START> final File VAR_2 = METHOD_2 ( VAR_1 ) ; <END> TYPE_2 VAR_3 = METHOD_3 ( ) ; VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) ; TYPE_3 VAR_4 = TYPE_3 . METHOD_6 ( VAR_5 ) ; return METHOD_7 ( VAR_2 , VAR_4 ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 != null && VAR_2 != null ) { TYPE_2 config = VAR_3 . METHOD_2 ( ) ; TYPE_3 VAR_4 = config . VAR_5 ( ) ; <START> config . VAR_6 ( null ) ; <END> List < TYPE_1 > VAR_7 = VAR_1 . METHOD_3 ( VAR_2 , METHOD_4 ( ) , config ) ; config . VAR_6 ( VAR_4 ) ; return VAR_7 ; } return Collections . VAR_8 ( ) ; } 
TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( VAR_1 . METHOD_1 ( ) , <END> TYPE_3 . METHOD_2 ( ) . getName ( VAR_2 , VAR_3 ) ) ; } 
<START> public boolean equals ( Object obj ) { <END> return obj instanceof TYPE_1 && ( ( TYPE_1 ) obj ) . VAR_1 . equals ( VAR_1 ) && ( ( TYPE_1 ) obj ) . VAR_2 . equals ( VAR_2 ) ; } 
public TYPE_1 call ( ) { long VAR_1 = System . VAR_2 ( ) ; <START> TYPE_1 VAR_3 = METHOD_1 ( name , VAR_4 , VAR_5 ) ; <END> VAR_6 += System . VAR_2 ( ) - VAR_1 ; VAR_7 += VAR_5 . METHOD_2 ( ) . size ( ) ; VAR_8 += VAR_5 . METHOD_3 ( ) . size ( ) ; return VAR_3 ; } 
public void METHOD_1 ( ) throws Exception { <START> Class <END> VAR_1 = Class . VAR_2 ( STRING_1 + STRING_2 ) ; VAR_1 . METHOD_2 ( ) ; VAR_1 = Class . VAR_2 ( STRING_1 + STRING_3 ) ; VAR_1 . METHOD_2 ( ) ; VAR_1 = Class . VAR_2 ( STRING_1 + STRING_4 ) ; VAR_1 . METHOD_2 ( ) ; } 
public boolean METHOD_1 ( ) { File VAR_1 = METHOD_2 ( ) ; <START> return VAR_1 != null && TYPE_1 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) == null ; <END> } 
private String METHOD_1 ( ANNOTATION_1 File VAR_1 ) throws IOException { assert VAR_1 . METHOD_2 ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( TYPE_1 VAR_2 : new TYPE_2 ( VAR_1 ) . METHOD_3 ( ) ) { String <START> VAR_3 = <END> VAR_2 . METHOD_4 ( ) ; sb . append ( VAR_3 ) ; sb . append ( STRING_1 ) ; sb . append ( TYPE_3 . VAR_5 ) ; } return sb . toString ( ) ; } 
public void METHOD_1 ( ANNOTATION_1 String VAR_1 ) { <START> TYPE_1 < String > VAR_2 = <END> TYPE_1 . of ( TYPE_2 . VAR_4 , TYPE_2 . VAR_5 ) ; METHOD_2 ( VAR_2 . contains ( VAR_1 ) , STRING_1 , VAR_1 ) ; VAR_6 = VAR_1 ; } 
<START> private TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 , <END> ANNOTATION_1 TYPE_2 VAR_2 ) { if ( VAR_1 == VAR_2 ) { return new TYPE_1 ( ) ; } TYPE_2 VAR_3 = VAR_2 . METHOD_2 ( ) ; assert VAR_3 != null ; return METHOD_1 ( VAR_1 , VAR_3 ) . append ( VAR_2 . getName ( ) ) . append ( CHAR_1 ) ; } 
private void METHOD_1 ( ) { if ( ! VAR_1 ) { TYPE_1 . METHOD_2 ( VAR_2 ) ; TYPE_2 . getInstance ( VAR_2 ) . METHOD_3 ( ) ; } else { long VAR_3 = VAR_4 ; <START> if ( VAR_3 < 0 ) { <END> VAR_3 = System . currentTimeMillis ( ) ; } TYPE_2 . getInstance ( VAR_2 ) . METHOD_4 ( VAR_3 ) ; } VAR_1 = VAR_5 ; VAR_4 = VAR_6 ; } 
private void METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_1 { TYPE_2 in = new TYPE_2 ( new File ( VAR_2 ) ) ; String VAR_3 = "" ; while ( in . hasNext ( ) ) { VAR_3 += in . VAR_4 ( ) + STRING_1 ; } VAR_1 = TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 , "" ) ; <START> VAR_3 = TYPE_3 . METHOD_2 ( VAR_3 , STRING_1 , "" ) ; <END> assertEquals ( VAR_1 , VAR_3 ) ; } 
public void <START> METHOD_1 ( <END> Set < TYPE_1 > VAR_1 ) { VAR_2 = VAR_1 ; } 
public Set < String > METHOD_1 ( ) { TYPE_1 < String > VAR_1 = new TYPE_1 < String > ( ) ; if ( METHOD_2 ( ) ) { VAR_1 . add ( VAR_2 ) ; <START> VAR_1 . addAll ( super . METHOD_1 ( ) ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( int x , int y , int VAR_1 , int VAR_2 ) { TYPE_1 VAR_3 = METHOD_2 ( ) ; super . METHOD_1 ( x , y , VAR_1 , VAR_2 ) ; TYPE_1 VAR_4 = METHOD_2 ( ) ; synchronized ( VAR_5 ) { if ( VAR_6 != null && ! VAR_4 . equals ( VAR_3 ) ) { <START> VAR_6 . METHOD_3 ( VAR_1 , <END> ( VAR_7 < VAR_1 ) ? 1 : VAR_2 ) ; VAR_7 = VAR_1 ; } } } 
<START> ArrayList < TYPE_1 > <END> METHOD_1 ( String name ) { ArrayList < TYPE_1 > result = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_1 value : METHOD_2 ( ) ) { if ( value . VAR_1 ( ) . getName ( ) . equals ( name ) ) { result . add ( value ) ; } } return result ; } 
public TYPE_1 METHOD_1 ( ) { String name = VAR_1 . METHOD_2 ( ) ; <START> if ( name . length ( ) == 0 || name . equals ( TYPE_2 . METHOD_3 ( VAR_2 , null ) ) ) { <END> return VAR_1 ; } else if ( VAR_3 . METHOD_4 ( ) ) { return VAR_3 ; } else if ( VAR_4 . METHOD_4 ( ) ) { return VAR_4 ; } else { return VAR_5 ; } } 
public void METHOD_1 ( ) { if ( METHOD_2 ( ) == null ) { return ; } List < ? extends TYPE_1 > VAR_1 = METHOD_3 ( ) ; if ( VAR_1 . contains ( VAR_2 ) ) { METHOD_4 ( VAR_2 ) ; } else if <START> ( VAR_1 . size ( ) > 0 ) { <END> METHOD_4 ( VAR_1 . get ( 0 ) ) ; } } 
private static void METHOD_1 ( TYPE_1 ... VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { VAR_2 . METHOD_2 ( true ) ; <START> VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; <END> VAR_2 . METHOD_3 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; } } 
public List < String > METHOD_1 ( ) { <START> List < String > values = new ArrayList < String > ( 2 ) ; <END> values . add ( STRING_1 ) ; values . add ( STRING_2 ) ; return values ; } 
<START> public final void METHOD_1 ( TYPE_1 VAR_1 ) <END> throws TYPE_2 { if ( ! ( VAR_1 instanceof TYPE_3 ) ) { throw new TYPE_2 ( STRING_1 + VAR_1 + STRING_2 + TYPE_3 . class . getName ( ) + STRING_3 ) ; } VAR_2 = ( ( TYPE_3 ) VAR_1 ) . config ; } 
public TYPE_4 ( ANNOTATION_1 TYPE_1 info , ANNOTATION_1 TYPE_2 VAR_2 , ANNOTATION_1 TYPE_3 ... VAR_3 ) { super ( info , VAR_2 ) ; this . VAR_3 = Arrays . asList ( VAR_3 ) ; <START> assert this . VAR_3 . size ( ) >= 1 ; <END> } 
<START> public Collection < TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
public int METHOD_1 ( final TYPE_1 VAR_1 , View view ) { if <START> ( view == VAR_1 ) { <END> return 0 ; } else { int VAR_2 = view . VAR_3 ( ) ; if ( TYPE_1 . class . METHOD_2 ( view . VAR_4 ( ) . getClass ( ) ) ) { VAR_2 += METHOD_1 ( VAR_1 , ( TYPE_1 ) view . VAR_4 ( ) ) ; } else { Log . i ( STRING_1 , STRING_2 ) ; } return VAR_2 ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_1 . VAR_2 ; TYPE_2 VAR_3 = null ; <START> try { VAR_3 = new TYPE_2 ( getClass ( ) . METHOD_2 ( STRING_1 ) . METHOD_3 ( ) ) ; VAR_1 = ( TYPE_1 ) VAR_3 . METHOD_4 ( ) ; } finally { try { if ( null != VAR_3 ) { VAR_3 . close ( ) ; } } catch ( Exception e ) { } } <END> } 
protected void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_3 = <START> ( TYPE_2 ) TYPE_2 . METHOD_2 ( this ) ; <END> VAR_4 = METHOD_3 ( R . id . VAR_5 ) ; TYPE_3 VAR_6 = ( TYPE_3 ) METHOD_3 ( R . id . VAR_7 ) ; if ( VAR_6 != null ) { VAR_6 . METHOD_4 ( this ) ; } } 
<START> public void METHOD_1 ( final View view ) { <END> final View VAR_1 = VAR_2 . METHOD_2 ( view ) ; final boolean VAR_3 = VAR_2 . METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_1 , 0 ) ; METHOD_5 ( VAR_1 , VAR_3 ) ; } 
public void METHOD_1 ( ) { Collection < Integer > c = Arrays . asList ( 1 , 2 , 3 , 4 ) ; try { c . VAR_1 ( VAR_2 ) ; METHOD_2 ( ) ; } catch ( TYPE_1 VAR_3 ) { } <START> try { c . VAR_1 ( VAR_4 ) ; } catch ( Exception e ) { METHOD_2 ( ) ; } <END> } 
public void METHOD_1 ( ) { METHOD_2 ( INT_1 , INT_2 ) ; METHOD_2 ( INT_2 , INT_1 ) ; METHOD_2 ( INT_3 , INT_1 ) ; METHOD_2 ( INT_4 , INT_5 ) ; METHOD_2 ( Long . VAR_1 , INT_4 ) ; METHOD_2 ( Long . VAR_1 , - INT_4 ) ; METHOD_2 ( Long . VAR_2 , <START> - INT_4 ) ; <END> METHOD_2 ( Long . VAR_2 , - INT_4 ) ; } 
protected void METHOD_1 ( ) { <START> VAR_1 . add ( VAR_2 ) ; <END> } 
private void METHOD_1 ( String VAR_1 , byte [ ] VAR_2 ) { try ( TYPE_1 VAR_3 = <START> METHOD_2 ( ) . METHOD_3 ( VAR_1 , <END> Context . VAR_4 ) ) { VAR_3 . write ( VAR_2 ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING_1 + VAR_1 , e ) ; } } 
public void METHOD_1 ( ) { VAR_1 . set ( true ) ; <START> VAR_2 = new TYPE_1 ( INT_1 , 0 , ( byte [ ] ) null ) ; <END> synchronized ( VAR_3 ) { VAR_3 . METHOD_2 ( ) ; } VAR_4 = null ; VAR_5 = null ; VAR_6 = null ; VAR_7 = null ; } 
private void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 TYPE_2 VAR_2 ) { VAR_3 |= VAR_1 . METHOD_2 ( ) ; if ( VAR_3 == TYPE_1 . VAR_4 ) { <START> synchronized ( this ) { VAR_2 . METHOD_3 ( ) ; } <END> } } 
public void METHOD_1 ( ) throws Exception { <START> int VAR_1 <END> = METHOD_2 ( ) ; TYPE_1 VAR_2 = ( TYPE_1 ) METHOD_3 ( ) . METHOD_4 ( Context . VAR_3 ) ; if ( ! VAR_2 . METHOD_5 ( ) ) { return ; } TYPE_2 VAR_4 = TYPE_2 . METHOD_6 ( ) ; VAR_4 . METHOD_7 ( STRING_1 , null , STRING_2 , null , null ) ; TYPE_3 . METHOD_8 ( INT_1 ) ; int VAR_5 = METHOD_2 ( ) ; assertTrue ( STRING_3 + STRING_4 + STRING_5 , VAR_1 == VAR_5 ) ; } 
<START> public int METHOD_1 ( ) { <END> return name . VAR_1 ( ) ^ VAR_2 . METHOD_1 ( ) ; } 
private void METHOD_1 ( String config ) { if ( VAR_1 ) TYPE_1 . d ( TAG , STRING_1 + config + STRING_2 ) ; TYPE_2 . set ( VAR_2 , config ) ; <START> return ; <END> } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( ! VAR_1 . METHOD_2 ( ) ) { <START> METHOD_3 ( false ) ; <END> } TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , VAR_4 , VAR_5 ) ; METHOD_4 ( VAR_2 ) ; METHOD_5 ( ) ; } 
<START> private <END> String METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( STRING_1 ) ; TYPE_2 VAR_3 = VAR_2 . matcher ( VAR_1 ) ; if ( VAR_3 . METHOD_3 ( ) ) { return VAR_3 . group ( ) ; } else { throw new IllegalArgumentException ( ) ; } } 
public void METHOD_1 ( TYPE_1 x , TYPE_2 b ) { int VAR_1 = ( ( x . VAR_2 & TYPE_7 . TYPE_8 ) > > TYPE_7 . TYPE_5 ) ; if ( VAR_1 == TYPE_6 . VAR_7 && ! ( x . VAR_8 instanceof TYPE_3 ) ) { VAR_9 = true ; TYPE_4 VAR_10 = x . VAR_11 ; TYPE_4 VAR_12 = x . VAR_8 . VAR_11 ; boolean <START> VAR_13 = <END> ! VAR_10 . equals ( VAR_12 ) ; assert VAR_13 ; } } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( 0 ) ; VAR_1 . METHOD_3 ( new TYPE_2 ( VAR_2 , VAR_3 , VAR_4 ) ) ; VAR_5 = new TYPE_3 ( ) ; VAR_1 . METHOD_4 ( VAR_5 ) ; VAR_5 . add ( new TYPE_4 ( VAR_4 ) ) ; VAR_1 . start ( ) ; <START> VAR_6 = <END> STRING_1 . METHOD_5 ( VAR_7 ) ; } 
public static void METHOD_1 ( ANNOTATION_1 TYPE_1 in ) <START> throws IOException { <END> throw new TYPE_2 ( ) ; } 
public static void METHOD_1 ( ANNOTATION_1 TYPE_1 in ) <START> throws IOException { <END> } 
public void METHOD_1 ( String VAR_1 , byte VAR_2 , TYPE_1 response ) { TYPE_2 VAR_3 = TYPE_2 . METHOD_2 ( VAR_4 , response ) ; <START> VAR_3 . VAR_5 . METHOD_3 ( VAR_2 ) ; <END> VAR_3 . VAR_5 . METHOD_4 ( VAR_1 ) ; if ( VAR_6 ) METHOD_5 ( VAR_3 . METHOD_6 ( ) + STRING_1 + METHOD_7 ( VAR_3 . VAR_7 ) ) ; METHOD_8 ( VAR_3 ) ; } 
<START> public final boolean METHOD_1 ( ) throws TYPE_1 { <END> if ( ! VAR_1 ) { Class < ? extends TYPE_2 > VAR_2 = METHOD_2 ( ) ; VAR_3 = TYPE_3 . class . METHOD_3 ( VAR_2 ) ; VAR_1 = true ; } return VAR_3 ; } 
int METHOD_1 ( int VAR_1 ) { <START> int VAR_2 <END> = TYPE_1 . VAR_4 ; for ( int i = 0 ; i < VAR_5 . length ; i ++ ) { if ( ( VAR_1 & VAR_5 [ i ] [ 1 ] ) != 0 ) { VAR_2 |= VAR_5 [ i ] [ 0 ] ; } } return VAR_2 ; } 
public void METHOD_1 ( float VAR_1 ) { <START> if ( VAR_1 < 0 ) { throw new TYPE_1 ( ) ; } <END> VAR_2 = VAR_1 ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 <START> + 1 , false , <END> VAR_1 + 10 , false , false ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 - 1 , false , VAR_1 <START> + 1 , false , <END> true ) ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> VAR_1 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( View view , TYPE_1 VAR_1 ) { super . METHOD_1 ( view , VAR_1 ) ; <START> if ( ! Utils . VAR_2 ( ) ) { <END> METHOD_2 ( ) ; } } 
private static void METHOD_1 ( ) throws TYPE_1 { try { TYPE_2 VAR_1 ; VAR_1 = new TYPE_2 ( TYPE_3 . METHOD_2 ( ) ) ; VAR_1 . METHOD_3 ( ) ; System . out . println ( STRING_1 ) ; } catch ( TYPE_4 VAR_2 ) { Throwable VAR_3 = VAR_2 . METHOD_4 ( ) ; if ( VAR_3 instanceof TYPE_5 ) { System . out . println ( STRING_2 ) ; } else { System . out . println ( STRING_3 ) ; <START> VAR_2 . METHOD_5 ( ) ; <END> } } } 
private <START> int METHOD_1 ( int <END> VAR_1 ) { switch ( VAR_1 ) { case TYPE_1 . VAR_3 : return 4 ; case TYPE_1 . VAR_4 : return 3 ; case TYPE_1 . VAR_5 : return 2 ; case TYPE_1 . VAR_6 : return 1 ; default : return 0 ; } } 
public final boolean METHOD_1 ( String action ) { return <START> ( action != null ) ? action . equals ( TYPE_1 ) <END> || action . equals ( TYPE_2 ) : false ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { METHOD_2 ( VAR_1 ) ; <START> int VAR_2 = VAR_3 . METHOD_3 ( VAR_4 . size ( ) - 1 ) ; <END> int VAR_5 = VAR_3 . METHOD_3 ( VAR_1 . VAR_6 . METHOD_4 ( TYPE_4 . Type ) ) ; TYPE_3 VAR_8 = new TYPE_3 ( ) ; VAR_8 . METHOD_5 ( this . getClass ( ) , VAR_1 ) ; VAR_8 . VAR_9 = VAR_2 ; VAR_8 . VAR_5 = VAR_5 ; return VAR_8 ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 . METHOD_2 ( ) ) { <START> return ( VAR_2 . VAR_3 . info . VAR_4 == TYPE_3 . VAR_6 ) ; <END> } Log . debug ( STRING_1 ) ; return false ; } 
public TYPE_1 . Builder METHOD_1 ( ANNOTATION_1 int VAR_1 , TYPE_2 VAR_2 ) { <START> if ( VAR_3 . METHOD_2 ( VAR_1 ) != null ) { throw new IllegalArgumentException ( STRING_1 + STRING_2 ) ; } <END> VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; return this ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; METHOD_2 ( VAR_1 ) ; for ( int VAR_2 : VAR_3 ) { VAR_1 . METHOD_3 ( VAR_2 , VAR_4 ) ; try { VAR_1 . METHOD_4 ( VAR_2 , <START> VAR_5 ) ; <END> } catch ( IllegalArgumentException VAR_6 ) { } } try { VAR_7 . METHOD_5 ( VAR_1 , new TYPE_2 ( ) ) ; METHOD_6 ( STRING_1 + STRING_2 ) ; } catch ( IllegalArgumentException VAR_6 ) { } } 
public void METHOD_1 ( ) throws Exception { try { TYPE_2 . VAR_2 . METHOD_2 ( 1 ) ; METHOD_3 ( ) ; } catch ( TYPE_1 VAR_3 ) <START> { } <END> } 
private void METHOD_1 ( ) { if ( VAR_1 == null ) <START> { <END> TYPE_1 . e ( STRING_1 , STRING_2 ) ; return ; } TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 != null ) { TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( VAR_3 ) ; METHOD_7 ( ) . METHOD_8 ( VAR_3 ) ; } } 
public void METHOD_1 ( ) throws Exception { <START> int VAR_1 = METHOD_2 ( ) ; TYPE_1 VAR_2 = VAR_3 . METHOD_3 ( VAR_1 , new TYPE_2 ( ) ) ; <END> METHOD_4 ( VAR_4 ) . METHOD_5 ( METHOD_6 ( ) , METHOD_7 ( TYPE_3 . METHOD_8 ( ) ) ) ; VAR_3 . METHOD_9 ( VAR_2 . VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new <END> TYPE_1 ( this . key ) ; return VAR_1 ; } 
private static int METHOD_1 ( File f ) throws TYPE_1 { <START> TYPE_2 s = new TYPE_2 ( f ) ; try { return s . VAR_1 ( ) ; } finally { s . close ( ) ; } <END> } 
private void METHOD_1 ( int VAR_1 ) { synchronized ( VAR_2 ) { TYPE_1 VAR_3 = VAR_2 . get ( VAR_1 ) ; if ( VAR_3 != null ) { METHOD_2 ( STRING_1 ) ; return ; } VAR_3 = new TYPE_1 ( VAR_4 . METHOD_3 ( ) , VAR_5 , VAR_6 , VAR_1 ) ; VAR_2 . put ( VAR_1 , VAR_3 ) ; } if ( VAR_7 . METHOD_4 ( VAR_1 ) . METHOD_5 ( ) && <START> TYPE_2 . METHOD_6 ( ) ) { METHOD_7 ( ) ; <END> } } 
synchronized boolean METHOD_1 ( TYPE_1 VAR_1 , int id , byte [ ] data ) { if ( VAR_2 ) { Log . d ( TAG , STRING_1 + VAR_1 + STRING_2 + id + <START> STRING_3 + TYPE_2 . METHOD_2 ( ) ) ; <END> } return METHOD_3 ( VAR_1 ) && METHOD_4 ( ) && VAR_3 . METHOD_1 ( id , data ) ; } 
public static TYPE_1 METHOD_1 ( String name ) { final TYPE_2 VAR_1 = METHOD_2 ( name ) ; if ( VAR_1 == null ) return null ; final TYPE_3 VAR_2 = METHOD_3 ( VAR_1 ) ; try { return new TYPE_1 ( name , VAR_1 . METHOD_4 ( ) , VAR_2 , VAR_1 . METHOD_5 ( ) ) ; <START> } catch ( IllegalArgumentException | TYPE_4 | TYPE_5 e ) { <END> return null ; } } 
private boolean METHOD_1 ( ) { final Context context = TYPE_1 . METHOD_2 ( ) ; if ( ( context . VAR_1 ( ) . METHOD_3 ( ) . VAR_2 & TYPE_2 . VAR_4 ) <START> == TYPE_2 . VAR_5 ) { <END> return true ; } return false ; } 
public void METHOD_1 ( int VAR_1 ) { <START> if ( VAR_2 ) { log ( STRING_1 ) ; } <END> synchronized ( VAR_3 ) { VAR_3 . forEach ( VAR_4 - > VAR_4 . METHOD_1 ( VAR_1 ) ) ; } } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) VAR_2 . METHOD_2 ( Context . VAR_3 ) ; return ! VAR_1 . METHOD_3 ( ) <START> || VAR_2 . METHOD_4 ( ) . METHOD_5 ( TYPE_2 . VAR_5 ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { long VAR_3 = VAR_4 ; long VAR_5 = VAR_6 ; long VAR_7 = VAR_1 . VAR_4 ; if ( VAR_2 ) { VAR_3 &= ~ VAR_8 ; VAR_5 &= ~ VAR_8 ; <START> VAR_7 &= ~ VAR_8 ; <END> } return ( ( VAR_7 & VAR_3 ) == VAR_3 ) && ( ( VAR_5 & VAR_7 ) == 0 ) ; } 
public void METHOD_1 ( ANNOTATION_1 int [ ] VAR_1 ) { VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> VAR_3 &= ~ ( VAR_2 & VAR_3 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , int state ) { if ( state != TYPE_2 . VAR_2 && state != TYPE_2 . VAR_3 ) { Log . e ( TAG , STRING_1 + TYPE_2 . METHOD_2 ( state ) ) ; <START> return ; <END> } TYPE_3 m = VAR_4 . METHOD_3 ( VAR_5 ) ; m . obj = VAR_1 ; m . VAR_6 = state ; VAR_4 . METHOD_4 ( m ) ; } 
void METHOD_1 ( ) { Class [ ] VAR_1 = TYPE_1 . METHOD_2 ( ) ; if ( VAR_2 . size ( ) > 0 ) { METHOD_3 ( VAR_1 , TYPE_2 . VAR_4 ) ; } <START> METHOD_4 ( STRING_1 ) ; <END> } 
private void METHOD_1 ( ) { final int count = VAR_1 . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { TYPE_1 VAR_2 = VAR_1 . get ( i ) . get ( ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( ) ; } } <START> METHOD_3 ( ) ; <END> } 
private void METHOD_1 ( ) { VAR_1 = 0 ; VAR_2 = 0 ; final int count = VAR_3 . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { TYPE_1 VAR_4 = VAR_3 . get ( i ) . get ( ) ; if ( VAR_4 != null ) { VAR_4 . METHOD_2 ( ) ; } } <START> METHOD_3 ( ) ; <END> } 
private int METHOD_1 ( TYPE_1 uri ) throws TYPE_2 { <START> int id = - 1 ; if ( uri != null ) { id = Integer . parseInt ( uri . VAR_1 ( ) ) ; } return id ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) <START> throws IOException { <END> try { VAR_2 . METHOD_2 ( VAR_3 , VAR_1 ) ; } catch ( TYPE_2 e ) { throw e . VAR_4 ( ) ; } } 
public void METHOD_1 ( Integer VAR_1 , String VAR_2 , Integer VAR_3 ) { TYPE_1 VAR_4 = new TYPE_1 ( ) ; VAR_4 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <START> try { TYPE_2 VAR_5 = TYPE_3 . METHOD_4 ( VAR_2 ) ; TYPE_4 . METHOD_5 ( VAR_4 , VAR_5 , VAR_3 . METHOD_3 ( ) ) ; } catch ( TYPE_5 | TYPE_6 e ) { Log . e ( STRING_1 + e . toString ( ) ) ; } } <END> 
private void METHOD_1 ( ) { if ( ! VAR_1 ) { int VAR_2 = TYPE_1 . METHOD_2 ( ) ; if ( TYPE_1 . METHOD_3 ( VAR_2 ) ) { VAR_3 = new TYPE_2 ( VAR_2 , VAR_4 . METHOD_4 ( ) ) ; VAR_5 . METHOD_5 ( VAR_3 , TYPE_4 . VAR_7 | TYPE_4 . VAR_8 ) ; VAR_5 . METHOD_6 ( <START> TYPE_3 . VAR_10 <END> | TYPE_3 . VAR_11 , TYPE_3 . VAR_12 ) ; VAR_1 = true ; } else { Log . VAR_13 ( TAG , STRING_1 + VAR_2 ) ; } } } 
protected void METHOD_1 ( int VAR_1 ) { Log . i ( TAG , STRING_1 ) ; if ( ! TYPE_1 . METHOD_2 ( VAR_2 , false ) ) { Log . VAR_3 ( TAG , STRING_2 ) ; VAR_4 = null ; return ; } <START> VAR_5 . METHOD_3 ( new TYPE_2 ( ) ) ; <END> } 
private File METHOD_1 ( ) { File VAR_1 = new File ( TYPE_1 . METHOD_2 ( ) , VAR_2 ) ; File VAR_3 = new File ( TYPE_1 . METHOD_3 ( ) , VAR_4 ) ; File VAR_5 = new File ( TYPE_1 . METHOD_4 ( ) , VAR_2 ) ; File VAR_6 = new File ( TYPE_1 . METHOD_5 ( ) , VAR_7 ) ; VAR_1 = METHOD_6 ( VAR_1 , <START> VAR_5 ) ; <END> VAR_1 = METHOD_6 ( VAR_1 , VAR_3 ) ; VAR_1 = METHOD_6 ( VAR_1 , VAR_6 ) ; return VAR_1 ; } 
private void <START> METHOD_1 ( long <END> VAR_1 , Class < ? > VAR_2 ) { assertEquals ( VAR_1 , TYPE_1 . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) ) ; } 
public boolean METHOD_1 ( ) throws TYPE_1 { return <START> METHOD_2 ( VAR_1 ) == STRING_1 <END> && METHOD_2 ( VAR_2 ) == STRING_1 ; } 
public boolean METHOD_1 ( ) { try { return TYPE_3 . TYPE_4 . getInt ( VAR_1 , <START> TYPE_3 . TYPE_4 . VAR_2 ) > 0 ; <END> } catch ( TYPE_3 . TYPE_5 VAR_3 ) { return true ; } } 
private void METHOD_1 ( TYPE_1 config , TYPE_2 context , TYPE_3 listener ) { <START> if ( VAR_1 ) { <END> return ; } METHOD_2 ( context , config ) ; listener . VAR_2 ( context ) ; VAR_1 = true ; } 
public Collection < TYPE_1 > split ( int VAR_1 ) { if ( VAR_1 <= 1 || VAR_2 ) { <START> return null ; <END> } Collection < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_3 . add ( METHOD_1 ( VAR_1 , i ) ) ; } return VAR_3 ; } 
public Collection < TYPE_1 > split ( int VAR_1 ) { if ( VAR_1 <= 1 || VAR_2 ) { return null ; } Collection < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_3 . add ( METHOD_1 ( VAR_1 , i ) ) ; } <START> VAR_2 = true ; <END> return VAR_3 ; } 
public int METHOD_1 ( ) { <START> if ( VAR_1 && ( ! VAR_2 || VAR_3 ) ) { <END> return VAR_4 ; } return VAR_5 ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 == null ) { <START> return false ; <END> } return VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ; } 
private void METHOD_1 ( ) { <START> boolean VAR_1 = METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( VAR_1 && VAR_3 . METHOD_4 ( ) && ! VAR_4 ? View . VAR_5 : View . VAR_6 ) ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 == null ) { return true ; } return <START> VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ; <END> } 
<START> protected TYPE_1 ( ) <END> { } 
public void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> TYPE_1 . from ( METHOD_2 ( ) ) . METHOD_3 ( VAR_1 ) ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_2 VAR_2 = METHOD_2 ( ) ; TYPE_3 info = null ; try { <START> info = VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , 0 ) ; <END> } catch ( TYPE_2 . TYPE_5 e ) { Log . VAR_3 ( TAG , STRING_1 + VAR_1 . METHOD_4 ( ) ) ; } if ( info == null ) { return VAR_1 . METHOD_4 ( ) ; } else { return info . VAR_4 ( VAR_2 ) . toString ( ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { try { if ( METHOD_2 ( ) ) { METHOD_3 ( ) . METHOD_1 ( VAR_1 ) ; } } catch ( TYPE_2 e ) { Log . e ( TAG , STRING_1 , e ) ; } <START> return false ; <END> } 
public void METHOD_1 ( ) { Thread VAR_1 = Thread . VAR_2 ( ) ; String message ; if ( METHOD_2 ( ) && ( message = VAR_3 . get ( VAR_1 ) ) != null ) { <START> VAR_1 . METHOD_3 ( ) ; <END> throw new TYPE_1 ( message ) ; } } 
public void <START> METHOD_1 ( ) <END> { METHOD_2 ( true , true , false ) ; METHOD_3 ( METHOD_4 ( VAR_1 . VAR_2 . VAR_3 . R . id . VAR_4 ) ) . METHOD_5 ( METHOD_6 ( METHOD_7 ( ) ) ) ; METHOD_3 ( METHOD_4 ( VAR_1 . VAR_2 . VAR_3 . R . id . VAR_5 ) ) . METHOD_5 ( METHOD_6 ( METHOD_7 ( ) ) ) ; METHOD_3 ( METHOD_4 ( VAR_1 . VAR_2 . VAR_3 . R . id . VAR_6 ) ) . METHOD_5 ( METHOD_6 ( METHOD_7 ( ) ) ) ; } 
TYPE_1 ( ) { for ( int i = 0 ; i < <START> VAR_2 ; i ++ ) <END> { VAR_3 [ i ] = STRING_1 + i ; } } 
public void METHOD_1 ( ) { final int VAR_1 = TYPE_1 . System . getInt ( VAR_3 . METHOD_2 ( ) , TYPE_1 . System . VAR_4 , VAR_5 ) ; <START> if ( VAR_1 == 1 ) { VAR_6 . METHOD_3 ( VAR_7 , TYPE_1 . System . VAR_4 , STRING_1 ) ; METHOD_4 ( VAR_8 ) ; METHOD_4 ( VAR_9 ) ; VAR_6 . METHOD_3 ( VAR_7 , TYPE_1 . System . VAR_4 , STRING_2 ) ; } else { METHOD_4 ( VAR_8 ) ; METHOD_4 ( VAR_9 ) ; } <END> } 
public void METHOD_1 ( ) { if <START> ( TYPE_1 . METHOD_2 ( ) < TYPE_2 . VAR_2 . VAR_3 ) { <END> return ; } for ( byte [ ] VAR_4 : VAR_5 ) { METHOD_3 ( VAR_6 , VAR_4 ) ; } } 
protected void METHOD_1 ( int VAR_1 ) { final TYPE_1 result = new TYPE_1 ( VAR_1 ) ; final int index = VAR_2 . add ( ) ; <START> if ( index >= 0 && index < VAR_3 ) { <END> VAR_4 [ index ] = result ; } if ( result . VAR_5 ( ) ) { VAR_6 ++ ; } else { VAR_6 = 0 ; } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { synchronized ( VAR_2 ) { if ( VAR_1 == null ) { VAR_3 = null ; return ; } <START> if ( ! TYPE_2 . isEmpty ( VAR_1 . METHOD_2 ( ) ) && VAR_1 . METHOD_3 ( ) != 0 ) { <END> VAR_3 = VAR_1 ; } } } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; TYPE_2 . METHOD_2 ( String . format ( VAR_2 , VAR_3 ) ) ; <START> TYPE_2 . METHOD_2 ( String . format ( VAR_2 , VAR_4 ) ) ; <END> TYPE_2 . METHOD_2 ( String . format ( VAR_2 , VAR_4 ) ) ; TYPE_2 . METHOD_3 ( ) ; } 
private void METHOD_1 ( Builder < String , TYPE_1 > builder , String VAR_1 , String VAR_2 , TYPE_1 VAR_3 ) { builder . put ( VAR_1 , VAR_3 ) ; <START> builder . put ( VAR_2 , new TYPE_2 ( VAR_1 , VAR_3 ) ) ; <END> } 
public void METHOD_1 ( ) throws Throwable { int VAR_1 = 1 ; METHOD_2 ( VAR_1 ) ; TYPE_1 VAR_2 = VAR_3 . METHOD_3 ( ) ; VAR_4 . METHOD_4 ( ( ) - > { <START> ( ( TYPE_2 ) VAR_2 . METHOD_5 ( ) ) . METHOD_6 ( <END> new TYPE_2 . TYPE_6 ( ) { @Override public int METHOD_7 ( int position ) { return VAR_5 ; } } ) ; } ) ; TYPE_4 . METHOD_8 ( ) . METHOD_9 ( ) ; assertEquals ( VAR_1 , TYPE_5 . METHOD_10 ( VAR_2 ) ) ; } 
public static void <START> METHOD_1 ( Logger <END> logger ) { VAR_1 = logger ; } 
public void METHOD_1 ( ) throws IOException { File VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; try { TYPE_2 result = TYPE_3 . METHOD_3 ( ) . METHOD_4 ( VAR_2 , new <START> TYPE_4 ( VAR_1 ) , <END> null , STRING_3 , STRING_4 ) ; assertTrue ( TYPE_6 . TYPE_7 . equals ( result . getStatus ( ) ) ) ; assertEquals ( STRING_5 , TYPE_1 . METHOD_5 ( VAR_1 ) ) ; } finally { TYPE_1 . METHOD_6 ( VAR_1 ) ; } } 
public void <START> METHOD_1 ( float <END> VAR_1 ) { VAR_2 = VAR_1 ; METHOD_2 ( ) ; } 
private void <START> METHOD_1 ( ) <END> { TYPE_1 data = new TYPE_1 ( ) ; data . VAR_1 = TYPE_3 . VAR_3 ; data . VAR_4 = "" ; data . VAR_5 = "" ; data . VAR_6 = VAR_7 ; VAR_8 = TYPE_2 . METHOD_2 ( data ) ; } 
<START> private boolean METHOD_1 ( TYPE_1 <END> VAR_1 ) { if ( VAR_1 . VAR_2 == null ) { return true ; } for ( int VAR_3 : VAR_1 . VAR_2 ) { if ( ! TYPE_2 . containsKey ( VAR_3 ) ) { return false ; } } return true ; } 
public void start ( ) { if ( VAR_1 ) return ; VAR_1 = true ; new Thread ( ) { <START> @Override public void run ( ) { <END> while ( VAR_1 ) { METHOD_1 ( ) ; } } } . start ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( VAR_2 . METHOD_4 ( VAR_3 , new Pair < > ( VAR_4 , VAR_1 ) ) ) ; } 
<START> private <END> boolean METHOD_1 ( TYPE_1 VAR_1 , Set < String > VAR_2 ) { String VAR_3 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) + VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; return VAR_2 . contains ( VAR_3 ) ; } 
<START> public Map < String , <END> Set < TYPE_1 > > METHOD_1 ( ) { return VAR_1 ; } 
public boolean METHOD_1 ( ) { return ( this . getClass ( ) . equals ( TYPE_1 . class ) <START> && VAR_1 . getClass ( ) . equals ( TYPE_2 . class ) ) <END> || VAR_1 == null ; } 
static boolean METHOD_1 ( TYPE_1 [ ] VAR_1 , TYPE_1 [ ] VAR_2 ) { if ( ( VAR_1 . length > 1 ) || ( VAR_1 . length == 0 ) != ( VAR_2 . length == 0 ) ) { return false ; } if ( VAR_1 . length == 0 ) return true ; <START> TYPE_1 VAR_3 = VAR_1 [ 0 ] ; <END> return Arrays . asList ( VAR_2 ) . contains ( VAR_3 ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> METHOD_2 ( this ) ; VAR_1 = METHOD_3 ( new TYPE_2 ( TYPE_3 . class ) ) ; <END> } 
<START> public void <END> METHOD_1 ( ) { METHOD_2 ( TYPE_1 . class . METHOD_3 ( ) , new TYPE_1 ( TYPE_2 . METHOD_4 ( ) ) ) ; } 
public static void METHOD_1 ( ANNOTATION_1 int VAR_1 ) { switch ( VAR_1 ) { case VAR_2 : case VAR_3 : case VAR_4 : case VAR_5 : case VAR_6 : if ( VAR_7 != VAR_1 ) { VAR_7 = VAR_1 ; <START> synchronized ( VAR_8 ) { <END> METHOD_2 ( ) ; } } break ; default : Log . d ( TAG , STRING_1 ) ; break ; } } 
public TYPE_1 METHOD_1 ( ) { if <START> ( VAR_1 == <END> null ) return null ; return new TYPE_1 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) ) ; } 
void METHOD_1 ( ) { if ( VAR_1 == null && VAR_2 == null ) { return ; } TYPE_1 resource ; synchronized ( VAR_3 ) { resource = VAR_4 . get ( VAR_2 ) ; } if ( resource != null ) { METHOD_2 ( resource ) ; } VAR_2 = null ; VAR_1 = null ; if <START> ( ! VAR_5 . isEmpty ( ) ) <END> { for ( TYPE_2 VAR_6 : VAR_5 ) { VAR_6 . METHOD_1 ( ) ; } VAR_5 . clear ( ) ; } } 
<START> public static <END> void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { try { TYPE_4 . METHOD_2 ( VAR_1 , VAR_2 ) ; } catch ( TYPE_4 . TYPE_7 VAR_3 ) { TYPE_6 . d ( STRING_1 ) ; TYPE_4 . METHOD_3 ( VAR_1 ) ; } } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> return new ArrayList < > ( ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( VAR_1 != null ) ; <END> VAR_2 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( TYPE_4 < TYPE_2 > METHOD_5 ( VAR_4 ) ) ; METHOD_6 ( VAR_5 , METHOD_7 ( ) ) . METHOD_8 ( METHOD_9 ( TYPE_3 . class ) ) ; VAR_2 . METHOD_10 ( ) ; } 
private void METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 ) throws TYPE_2 { for ( int VAR_3 : <START> new int [ ] { TYPE_1 . VAR_4 , TYPE_1 . VAR_5 } ) { <END> TYPE_3 VAR_6 = TYPE_1 . METHOD_2 ( VAR_3 , TYPE_3 . class , VAR_1 ) ; TYPE_3 VAR_7 = TYPE_1 . METHOD_2 ( VAR_3 , TYPE_3 . class , VAR_2 ) ; if ( ! VAR_6 . contains ( VAR_7 ) ) { throw new TYPE_2 ( ) ; } } } 
private boolean METHOD_1 ( ) { if ( VAR_1 > 0 ) { return true ; } TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( ) > 0 && VAR_2 . METHOD_4 ( ) > 0 ) { Log . VAR_4 ( TAG , STRING_1 + <START> VAR_2 . METHOD_4 ( ) + STRING_2 + VAR_2 . METHOD_3 ( ) ) ; <END> return true ; } return false ; } 
public <START> TYPE_1 METHOD_1 ( ANNOTATION_1 <END> final TYPE_2 VAR_1 ) { return METHOD_2 ( VAR_1 , null ) ; } 
public TYPE_1 METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 , TAG ) ; try { return <START> VAR_3 . METHOD_3 ( VAR_4 , null , VAR_5 ) ; <END> } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } 
void METHOD_1 ( ) { METHOD_2 ( VAR_1 , <START> ( ) - > { return METHOD_3 ( ) ; <END> } ) ; METHOD_4 ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { boolean VAR_2 = VAR_3 || VAR_4 ; TYPE_1 VAR_5 = TYPE_3 . METHOD_2 ( <START> STRING_1 , <END> METHOD_3 ( ) . METHOD_4 ( ) , VAR_6 , VAR_1 , new TYPE_4 ( ) , VAR_7 , VAR_8 , ( VAR_2 ? VAR_9 . METHOD_5 ( ) : null ) , VAR_10 , VAR_11 . METHOD_6 ( ) ) ; return VAR_5 ; } 
protected String METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 <END> = VAR_1 . METHOD_2 ( ) ; return String . format ( ( VAR_2 instanceof TYPE_3 ? STRING_1 : STRING_2 ) , VAR_2 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; } 
private void METHOD_1 ( String VAR_1 , TYPE_1 target ) { <START> if ( ! VAR_2 . containsKey ( target ) <END> || ! TYPE_2 . isEmpty ( VAR_1 ) ) { TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_3 . VAR_4 = new Thread ( new TYPE_4 ( VAR_1 , target , VAR_3 ) ) ; VAR_2 . put ( target , VAR_3 ) ; } } 
public List < TYPE_1 > METHOD_1 ( ) { return <START> METHOD_2 ( ) ? METHOD_3 ( ) . METHOD_4 ( ) : null ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { return METHOD_2 ( ) ? METHOD_3 ( ) . METHOD_1 ( ) : <START> null ; <END> } 
private void METHOD_1 ( String data ) { VAR_1 . METHOD_2 ( VAR_2 , data , STRING_1 , <START> STRING_2 , null ) ; <END> } 
public static <START> ANNOTATION_1 TYPE_1 <END> METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 ) { final TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( TYPE_3 . class , VAR_1 ) ; return ( TYPE_1 ) VAR_2 . METHOD_3 ( ( ) - > new TYPE_1 ( VAR_2 ) ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( R . string . VAR_2 ) ; METHOD_4 ( ) . METHOD_5 ( METHOD_6 ( TYPE_1 . VAR_4 , STRING_1 ) ) . METHOD_7 ( METHOD_8 ( METHOD_9 ( ) , METHOD_10 ( STRING_2 ) ) ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> try { METHOD_2 ( ) ; } catch ( IllegalStateException e ) { return TYPE_3 . METHOD_3 ( e ) ; } <END> if ( VAR_1 == TYPE_4 . VAR_3 ) { close ( ) ; } VAR_1 = TYPE_4 . VAR_4 ; VAR_5 . METHOD_4 ( TYPE_4 . VAR_4 ) ; return TYPE_3 . METHOD_5 ( null ) ; } 
public <START> ANNOTATION_1 int <END> METHOD_1 ( ) { return VAR_1 ; } 
<START> TYPE_1 ( int <END> id , int VAR_2 , int VAR_3 , ANNOTATION_1 int [ ] VAR_4 ) { this . id = id ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; VAR_5 = VAR_4 ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> if ( VAR_1 ) log ( STRING_1 ) ; if ( VAR_2 != null ) { TYPE_1 . from ( VAR_3 ) . METHOD_3 ( VAR_2 ) ; VAR_2 = null ; } } 
<START> public int <END> METHOD_1 ( ) { METHOD_2 ( ) ; return VAR_1 ; } 
<START> public void <END> METHOD_1 ( ) { METHOD_2 ( ( ) - > { METHOD_3 ( ) ; } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_1 ( null , VAR_1 , null ) ; <START> TYPE_2 . getInstance ( ) . METHOD_1 ( VAR_1 ) ; <END> VAR_1 . println ( ) ; } 
public void METHOD_1 ( ) { TYPE_2 . TYPE_3 a = new TYPE_2 . TYPE_3 . Builder ( R . VAR_1 . VAR_2 , STRING_1 , null ) . build ( ) ; TYPE_2 . TYPE_3 VAR_3 = new TYPE_2 . TYPE_3 . Builder ( a ) . build ( ) ; <START> assertEquals ( a . VAR_4 ( ) . METHOD_2 ( ) , VAR_3 . METHOD_3 ( ) . METHOD_2 ( ) ) ; <END> } 
public <START> int METHOD_1 ( ) <END> { try { return VAR_1 . METHOD_1 ( ) ; } catch ( TYPE_1 ex ) { throw ex . VAR_2 ( ) ; } } 
public void METHOD_1 ( ) throws Exception { VAR_1 = new TYPE_1 ( VAR_2 ) ; <START> TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_2 ( VAR_4 ) ; VAR_3 . METHOD_3 ( true ) ; VAR_1 . METHOD_4 ( false ) ; VAR_1 . METHOD_5 ( VAR_3 ) ; METHOD_6 ( ) ; assertEquals ( VAR_3 , VAR_5 . METHOD_7 ( ) ) ; <END> METHOD_8 ( VAR_6 ) ; } 
private void update ( String key , int value ) { <START> VAR_1 . METHOD_1 ( ) ; <END> try { VAR_1 . METHOD_2 ( ) . METHOD_3 ( new TYPE_1 ( key , value ) ) ; VAR_1 . METHOD_4 ( ) ; } finally { VAR_1 . METHOD_5 ( ) ; } } 
public void METHOD_1 ( final long VAR_1 ) { <START> VAR_2 . METHOD_2 ( ) ; <END> try { TYPE_1 VAR_3 = new TYPE_1 ( VAR_4 , VAR_1 ) ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( VAR_3 ) ; VAR_2 . METHOD_5 ( ) ; } finally { VAR_2 . METHOD_6 ( ) ; } } 
public void METHOD_1 ( boolean VAR_1 ) { <START> VAR_2 . METHOD_2 ( ) ; <END> try { TYPE_1 VAR_3 = new TYPE_1 ( VAR_4 , VAR_1 ) ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( VAR_3 ) ; VAR_2 . METHOD_5 ( ) ; } finally { VAR_2 . METHOD_6 ( ) ; } } 
public TYPE_2 ( ) { super ( ) ; <START> VAR_2 = new TYPE_1 ( TYPE_3 . VAR_4 ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_4 = TYPE_3 . METHOD_3 ( VAR_5 . METHOD_4 ( ) , VAR_5 , VAR_2 . METHOD_5 ( R . id . VAR_6 ) ) ; VAR_4 . METHOD_6 ( <START> VAR_7 . METHOD_7 ( VAR_8 . VAR_9 . VAR_10 . R . VAR_11 . VAR_12 ) ) ; <END> VAR_4 . METHOD_8 ( VAR_13 . METHOD_9 ( ) ) ; VAR_4 . METHOD_10 ( VAR_5 . METHOD_4 ( ) , true ) ; } 
public int METHOD_1 ( ) { if <START> ( ! VAR_1 . METHOD_2 ( ) && <END> VAR_1 . METHOD_3 ( ) == - 1 ) { return VAR_2 ; } return VAR_1 . METHOD_4 ( VAR_1 . METHOD_3 ( ) ) . METHOD_5 ( ) ; } 
static boolean METHOD_1 ( ANNOTATION_1 ByteBuffer VAR_1 ) { return <START> VAR_1 . position ( ) < VAR_1 . METHOD_2 ( ) && VAR_1 . METHOD_3 ( ) >= TYPE_1 . VAR_3 ; <END> } 
private void METHOD_1 ( ) { if <START> ( METHOD_2 ( ) ) { <END> METHOD_3 ( VAR_1 , METHOD_4 ( ) ) ; } } 
boolean METHOD_1 ( ANNOTATION_1 final TYPE_1 VAR_1 , ANNOTATION_1 final String VAR_2 ) { if ( VAR_1 . VAR_3 == null || VAR_1 . VAR_4 == null ) { return false ; } final int index = TYPE_2 . METHOD_2 ( VAR_1 . VAR_3 , VAR_2 ) ; if ( index < 0 || index <START> > VAR_1 . VAR_4 . length ) <END> return false ; return ( VAR_1 . VAR_4 [ index ] & VAR_5 ) != 0 ; } 
public boolean METHOD_1 ( int VAR_1 ) { return <START> VAR_2 . containsKey ( VAR_1 ) ; <END> } 
private static TYPE_1 METHOD_1 ( boolean VAR_1 , int VAR_2 ) { final TYPE_1 VAR_3 = new TYPE_1 ( ) ; if ( VAR_1 ) { VAR_3 . VAR_4 = new String [ ] { <START> VAR_5 , VAR_6 , <END> VAR_7 } ; } else { VAR_3 . VAR_4 = new String [ 0 ] ; } VAR_3 . VAR_8 = new TYPE_2 ( ) ; VAR_3 . VAR_8 . VAR_9 = 0 ; VAR_3 . VAR_8 . VAR_2 = TYPE_3 . METHOD_2 ( TYPE_3 . VAR_10 , TYPE_3 . METHOD_3 ( VAR_2 ) ) ; return VAR_3 ; } 
private void METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_1 . from ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; METHOD_3 ( ) ; METHOD_4 ( ) ; VAR_4 = null ; <START> METHOD_5 ( TYPE_2 . VAR_6 , STRING_1 ) ; <END> } 
static Collection < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { <START> final HashSet < TYPE_3 > VAR_2 = new HashSet < > ( ) ; <END> final HashSet < TYPE_1 > VAR_3 = new HashSet < > ( ) ; for ( final TYPE_2 VAR_4 : VAR_1 ) { for ( final TYPE_3 VAR_5 : new TYPE_4 ( VAR_4 . VAR_6 , VAR_4 . VAR_7 ) . METHOD_2 ( ) ) { VAR_3 . add ( new TYPE_1 ( VAR_5 , null ) ) ; } } return VAR_3 ; } 
public void METHOD_1 ( Set < String > VAR_1 ) { <START> for ( String filter : VAR_1 ) { VAR_2 . add ( filter ) ; } <END> } 
TYPE_1 VAR_2 ( ) { TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . VAR_4 ( VAR_5 , VAR_6 ) ; VAR_3 . VAR_4 ( VAR_7 , VAR_8 ) ; VAR_3 . VAR_9 ( VAR_10 , VAR_11 ) ; VAR_3 . VAR_4 ( VAR_12 , message ) ; VAR_3 . VAR_13 ( VAR_14 , VAR_3 ) ; return VAR_3 ; <START> } } <END> 
protected void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; if ( ! METHOD_2 ( ) ) { return ; } VAR_1 = ( TYPE_1 ) VAR_2 . METHOD_3 ( Context . VAR_3 ) ; assertNotNull ( VAR_1 ) ; TYPE_2 . METHOD_4 ( STRING_1 ) ; Thread . VAR_4 ( VAR_5 ) ; <START> if ( METHOD_2 ( ) ) { <END> assertTrue ( VAR_1 . METHOD_5 ( ) ) ; } } 
public void METHOD_1 ( TYPE_1 listener ) { <START> if ( listener == null ) return ; String VAR_1 = VAR_2 != null ? VAR_2 . METHOD_2 ( ) : STRING_1 ; if ( VAR_3 ) { METHOD_3 ( STRING_2 + VAR_1 + STRING_3 + listener ) ; } TYPE_2 VAR_4 = ( TYPE_2 ) VAR_2 . METHOD_4 ( Context . VAR_5 ) ; if ( VAR_4 != null ) { VAR_4 . METHOD_1 ( listener , listener . VAR_6 ) ; } <END> } 
<START> void METHOD_1 ( ANNOTATION_1 <END> final int id ) { VAR_1 . METHOD_2 ( null , id ) ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; final boolean VAR_3 = VAR_1 . METHOD_3 ( TYPE_2 . VAR_5 ) ; final boolean VAR_6 = VAR_7 ; VAR_7 = VAR_3 ; final boolean VAR_8 = ( VAR_3 != VAR_6 ) ; if ( ! VAR_8 ) { return ; } if ( ! VAR_3 ) { VAR_9 . METHOD_4 ( ) ; return ; } VAR_9 . METHOD_5 ( ) ; <START> if ( VAR_10 . METHOD_6 ( ) . length != 0 ) { <END> VAR_10 . METHOD_7 ( ) ; } } 
private void METHOD_1 ( ) { final boolean VAR_1 = VAR_2 <= VAR_3 ; synchronized ( VAR_4 ) { <START> if ( VAR_5 ) { METHOD_2 ( ) ; } else if ( VAR_1 ) { <END> METHOD_3 ( ) ; } else { if ( METHOD_4 ( ) ) { return ; } METHOD_3 ( ) ; } } } 
public void METHOD_1 ( int VAR_1 ) { int VAR_2 = <START> VAR_3 [ VAR_1 - 1 ] ; <END> TYPE_1 . METHOD_2 ( VAR_2 ) ; } 
private void METHOD_1 ( ) { final TYPE_1 < TYPE_2 > VAR_1 = TYPE_1 . create ( ) ; TYPE_3 VAR_2 = METHOD_2 ( TYPE_3 . class ) ; VAR_2 . METHOD_3 ( this , new TYPE_3 . TYPE_7 ( ) { @Override public void METHOD_4 ( ) { VAR_1 . set ( null ) ; } } ) ; try { VAR_1 . get ( INT_1 , TimeUnit . VAR_3 ) ; } catch ( TYPE_5 | InterruptedException | TYPE_6 e ) { <START> Log . VAR_4 ( STRING_1 , STRING_2 ) ; <END> } } 
<START> public int METHOD_1 ( TYPE_1 VAR_1 ) { <END> try { return VAR_2 . METHOD_1 ( VAR_1 ) ; } catch ( TYPE_2 e ) { throw new RuntimeException ( e . toString ( ) ) ; } } 
public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { if <START> ( TYPE_2 . equals ( VAR_2 , <END> VAR_1 . METHOD_2 ( ) ) ) { return false ; } int i = METHOD_3 ( VAR_1 ) ; if ( i == - 1 ) { return false ; } VAR_3 . remove ( i ) ; return true ; } 
public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <START> if ( TYPE_2 . equals ( VAR_2 , VAR_1 . METHOD_2 ( ) ) ) { <END> int i = METHOD_3 ( VAR_1 ) ; if ( i >= 0 ) { VAR_3 . remove ( i ) ; return true ; } } return false ; } 
private void METHOD_1 ( ) { <START> for ( Map . Entry < TYPE_5 . TYPE_6 < TYPE_2 > , TYPE_3 < TYPE_4 > > entry <END> : VAR_1 . entrySet ( ) ) { entry . getKey ( ) . METHOD_2 ( ) ; } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <START> super . METHOD_1 ( VAR_1 ) ; <END> VAR_2 . METHOD_1 ( VAR_1 ) ; } 
private <START> boolean METHOD_1 ( TYPE_1 <END> VAR_1 ) { final TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( ) ; if ( VAR_2 == null ) { METHOD_3 ( STRING_1 + VAR_1 ) ; return false ; } int VAR_4 = VAR_2 . METHOD_4 ( VAR_1 ) ; if ( VAR_4 == TYPE_3 . VAR_6 ) { METHOD_5 ( STRING_2 + VAR_1 ) ; return VAR_2 . METHOD_6 ( VAR_1 ) ; } else { METHOD_5 ( STRING_3 + VAR_1 + STRING_4 + VAR_4 ) ; return false ; } } 
public void METHOD_1 ( String VAR_1 , String ... VAR_2 ) { VAR_3 = VAR_2 ; VAR_4 = VAR_1 ; VAR_5 = 0 ; VAR_6 = TYPE_1 . getInstance ( TYPE_2 . METHOD_2 ( ) ) ; <START> VAR_7 . METHOD_1 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ) { return ; } int VAR_4 = <START> TYPE_1 . METHOD_3 ( VAR_5 , <END> ( VAR_6 ) - > VAR_6 . METHOD_4 ( ) ) ; assertEquals ( 2 , VAR_4 ) ; } 
private Set < Integer > METHOD_1 ( ) { Set < Integer > VAR_1 = new TYPE_1 < > ( Arrays . asList ( TYPE_2 . values ( ) ) ) ; <START> if ( VAR_2 != null ) { <END> if ( ! METHOD_2 ( TYPE_3 . VAR_4 ) ) { VAR_1 . remove ( TYPE_3 . VAR_4 ) ; } if ( ! METHOD_2 ( TYPE_3 . VAR_5 ) ) { VAR_1 . remove ( TYPE_3 . VAR_5 ) ; } } return VAR_1 ; } 
private void METHOD_1 ( int type ) { <START> if ( METHOD_2 ( type ) ) { VAR_1 . METHOD_3 ( R . id . VAR_2 ) . METHOD_4 ( View . VAR_3 ) ; } else { VAR_1 . METHOD_3 ( R . id . VAR_2 ) . METHOD_4 ( View . VAR_4 ) ; } <END> } 
public static boolean METHOD_1 ( ANNOTATION_1 Context context , ANNOTATION_1 String VAR_1 , ANNOTATION_1 String name ) { <START> final int VAR_2 = METHOD_2 ( VAR_1 , name , 0 ) ; return METHOD_3 ( context , VAR_2 ) ; <END> } 
private static boolean METHOD_1 ( ANNOTATION_1 Context context , int VAR_1 , ANNOTATION_1 String VAR_2 , ANNOTATION_2 String VAR_3 , boolean VAR_4 ) { <START> return TYPE_1 . METHOD_2 ( context , VAR_1 , VAR_2 , VAR_4 ) ; <END> } 
boolean METHOD_1 ( TYPE_1 state ) { <START> if ( METHOD_2 ( ) ) { <END> return false ; } switch ( METHOD_3 ( ) ) { case VAR_1 : return true ; case VAR_2 : return state . VAR_3 . METHOD_4 ( ) == TYPE_3 . VAR_5 ; case VAR_6 : return false ; } throw new TYPE_2 ( METHOD_3 ( ) ) ; } 
public static boolean METHOD_1 ( Context context , TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) context . VAR_3 ( Context . VAR_4 ) ; TYPE_3 <START> VAR_5 = <END> VAR_2 . METHOD_2 ( VAR_1 ) ; return VAR_5 . METHOD_3 ( VAR_6 ) ; } 
public static boolean METHOD_1 ( Context context , TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) context . VAR_3 ( Context . VAR_4 ) ; TYPE_3 VAR_5 = VAR_2 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_5 == null ) { return false ; } return VAR_5 . METHOD_3 ( VAR_6 ) ; <END> } 
public void METHOD_1 ( ) { final TYPE_1 request = new TYPE_1 . Builder ( ) . METHOD_2 ( TYPE_2 ) . build ( ) ; METHOD_3 ( request . VAR_1 ( null ) ) ; METHOD_3 ( request . VAR_1 ( new TYPE_3 ( ) ) ) ; assertTrue ( request . VAR_1 ( TYPE_2 . METHOD_4 ( VAR_2 ) ) ) ; <START> assertEquals ( request . VAR_1 ( new TYPE_3 ( ) ) , TYPE_2 . METHOD_5 ( new TYPE_3 ( ) ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { final String VAR_1 = STRING_1 ; TYPE_1 VAR_2 = config . VAR_3 ( ) . METHOD_2 ( VAR_1 , STRING_2 ) ; final String VAR_4 = STRING_3 ; <START> final String version = STRING_2 ; <END> METHOD_3 ( VAR_1 , VAR_4 , version ) ; METHOD_4 ( VAR_1 , VAR_2 ) ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 ; String VAR_3 = null ; try { while ( ( VAR_2 = VAR_1 . METHOD_2 ( ) ) != null ) { VAR_3 += VAR_2 + CHAR_1 ; } } catch ( IOException e ) { log . error ( STRING_1 , e ) ; } <START> return ( VAR_3 == null ) ? null : VAR_3 . toString ( ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 task ) { <START> super ( VAR_2 ) ; <END> METHOD_1 ( STRING_1 , task . VAR_3 ( ) ) ; METHOD_1 ( STRING_2 , task . VAR_4 ( ) ) ; METHOD_1 ( STRING_3 , task . VAR_5 ( ) ) ; METHOD_1 ( STRING_4 , task . VAR_6 ( ) ) ; task . VAR_7 ( ) ; METHOD_1 ( STRING_5 , METHOD_2 ( task . VAR_7 ( ) ) ) ; METHOD_1 ( STRING_6 , task . VAR_7 ( ) . getClass ( ) . getName ( ) ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_1 status = null ; <END> if ( METHOD_2 ( ) != null && METHOD_2 ( ) . METHOD_3 ( ) != null ) { status = METHOD_2 ( ) . METHOD_3 ( ) ; } return status ; } 
protected static < T > List < T > METHOD_1 ( List < T > list , List < T > VAR_1 ) { <START> List < T > VAR_2 = list ; <END> if ( list != null ) { if ( VAR_1 != null ) { for ( T item : VAR_1 ) { if ( ! VAR_2 . contains ( item ) ) { VAR_2 . add ( item ) ; } } } } else { VAR_2 = VAR_1 ; } return VAR_2 ; } 
public static void execute ( TYPE_1 command ) { try { VAR_1 . METHOD_1 ( new TYPE_2 ( command , TYPE_3 . METHOD_2 ( ) , TYPE_3 . METHOD_3 ( ) ) ) ; } catch ( TYPE_4 e ) { log . error ( STRING_1 ) ; throw e ; <START> } <END> } 
public TYPE_2 ( ) { <START> VAR_2 = TYPE_1 . TYPE_3 ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 = new Date ( ) ; <END> VAR_1 . METHOD_2 ( id ) ; VAR_1 . METHOD_3 ( VAR_3 . size ( ) ) ; if ( VAR_1 . METHOD_4 ( ) == null ) { VAR_1 . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; } VAR_1 . METHOD_7 ( VAR_4 ) ; VAR_3 . add ( VAR_1 ) ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = new Date ( ) ; VAR_1 . METHOD_2 ( id ) ; VAR_1 . METHOD_3 ( VAR_3 . size ( ) ) ; VAR_1 . METHOD_4 ( VAR_4 ) ; if ( VAR_1 . METHOD_5 ( ) == null ) { VAR_1 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ; } VAR_1 . METHOD_8 ( VAR_5 ) ; <START> <END> VAR_3 . add ( VAR_1 ) ; VAR_4 . METHOD_9 ( VAR_1 ) ; VAR_4 . METHOD_10 ( id , VAR_2 ) ; return VAR_1 ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { try { if ( VAR_1 != null ) { TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( ) . METHOD_3 ( VAR_1 . getValue ( ) ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_4 ( VAR_2 ) ; } <START> TYPE_4 . METHOD_2 ( ) . METHOD_5 ( VAR_3 ) ; <END> } } catch ( Exception e ) { log . VAR_4 ( STRING_1 , VAR_1 , VAR_2 , e ) ; } } 
private TYPE_5 ( ) { VAR_2 = TYPE_3 < Integer > METHOD_1 ( TYPE_4 . TYPE_2 ) . METHOD_2 ( ) * - 1 ; VAR_6 = TYPE_3 < Integer > METHOD_1 ( TYPE_4 . TYPE_6 ) . METHOD_2 ( ) * - 1 ; <START> Integer VAR_8 = TYPE_3 < Integer > METHOD_1 ( TYPE_4 . TYPE_7 ) ; <END> TYPE_1 . getInstance ( ) . METHOD_3 ( this , STRING_1 , new Class [ ] { } , new Object [ ] { } , VAR_8 , VAR_8 , TimeUnit . VAR_10 ) ; } 
protected boolean METHOD_1 ( ) { if ( getParameters ( ) != null ) { if ( ! TYPE_1 . getInstance ( ) . METHOD_2 ( getParameters ( ) . METHOD_3 ( ) , METHOD_4 ( ) . METHOD_5 ( ) ) ) { METHOD_6 ( TYPE_4 . TYPE_5 . toString ( ) ) ; <START> METHOD_6 ( TYPE_4 . TYPE_6 . toString ( ) ) ; <END> return false ; } } return true ; } 
protected boolean METHOD_1 ( ) { if ( getParameters ( ) != null ) { if ( TYPE_1 . getInstance ( ) . METHOD_2 ( getParameters ( ) . METHOD_3 ( ) , METHOD_4 ( ) . METHOD_5 ( ) ) ) { METHOD_6 ( TYPE_4 . TYPE_5 . toString ( ) ) ; <START> METHOD_6 ( TYPE_4 . TYPE_6 . toString ( ) ) ; <END> } } return true ; } 
<START> protected void METHOD_1 ( ) { <END> TYPE_1 VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) ; VAR_1 . remove ( getParameters ( ) . METHOD_3 ( ) ) ; } 
public String METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> return ( VAR_1 != 0 ) ? Integer . toString ( VAR_1 ) : null ; <END> } 
protected TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { TYPE_1 VAR_2 = METHOD_2 ( ) ; <START> VAR_1 = ( VAR_2 == null || VAR_2 . METHOD_3 ( ) == TYPE_2 . VAR_4 ) ? ( null ) : ( VAR_2 ) ; <END> } return VAR_1 ; } 
protected void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , METHOD_4 ( ) ) ; <END> TYPE_2 . METHOD_5 ( new TYPE_3 < TYPE_4 > ( ) { @Override public TYPE_4 METHOD_6 ( ) { TYPE_5 VAR_2 = TYPE_6 . getInstance ( ) . METHOD_7 ( TYPE_7 . TYPE_8 , METHOD_8 ( ) ) ; METHOD_9 ( VAR_2 ) ; METHOD_10 ( ) ; return null ; } } ) ; TYPE_1 . METHOD_11 ( VAR_1 . METHOD_3 ( ) ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . getInstance ( ) . METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) ) ) ; TYPE_2 VAR_1 = METHOD_6 ( ) ; <START> <END> METHOD_7 ( TYPE_3 . getInstance ( ) . METHOD_8 ( TYPE_4 . TYPE_5 , getParameters ( ) . METHOD_9 ( ) . get ( 0 ) , METHOD_10 ( ) ) . METHOD_11 ( ) ) ; if ( ! METHOD_11 ( ) ) { log . warn ( STRING_1 ) ; } METHOD_12 ( ) ; } 
protected static boolean METHOD_1 ( Guid VAR_1 ) { <START> TYPE_2 . TYPE_3 . ArrayList < String > VAR_2 = new TYPE_2 . TYPE_3 . ArrayList < String > ( ) ; <END> return METHOD_2 ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > result = VAR_1 . METHOD_2 ( VAR_2 , VAR_3 , true ) ; assertNotNull ( result ) ; <START> assertTrue ( result . size ( ) == 0 ) ; <END> } 
private TYPE_4 ( ) { <START> TYPE_1 . METHOD_1 ( new TYPE_2 ( this , <END> new TYPE_3 ( ) { @Override public void METHOD_2 ( Object target , Object VAR_2 ) { METHOD_3 ( ( String ) VAR_2 ) ; } } ) ) ; } 
protected boolean METHOD_1 ( ) { <START> return ( ! TYPE_1 . getInstance ( ) . METHOD_2 ( getParameters ( ) . METHOD_3 ( ) , <END> METHOD_4 ( ) . METHOD_5 ( ) ) ) ; } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; <START> METHOD_1 ( parameters . VAR_2 ( ) ) ; <END> } 
protected boolean METHOD_1 ( ) { <START> if ( getParameters ( ) == null ) { <END> return false ; } else if ( ! TYPE_1 . getInstance ( ) . METHOD_2 ( getParameters ( ) . METHOD_3 ( ) , METHOD_4 ( ) . METHOD_5 ( ) ) ) { return false ; } return true ; } 
public TYPE_1 ( Guid VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; } 
protected void METHOD_1 ( ) { String configuration = METHOD_2 ( getParameters ( ) . METHOD_3 ( ) ) ; TYPE_1 result = new TYPE_1 ( ) ; if ( configuration != null ) { <START> new TYPE_2 ( ) . METHOD_4 ( result , configuration ) ; <END> } METHOD_5 ( ) . METHOD_6 ( result ) ; } 
private TYPE_1 < TYPE_2 > METHOD_1 ( Guid VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( ) ; when ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( VAR_1 ) ; TYPE_1 < TYPE_2 > VAR_3 = METHOD_5 ( ) ; <START> return VAR_3 ; <END> } 
<START> protected void METHOD_1 ( ) { <END> METHOD_2 ( ) ; METHOD_3 ( ) ; new TYPE_1 ( ) . METHOD_4 ( METHOD_5 ( ) ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; } 
<START> public void METHOD_1 ( Guid value ) { <END> VAR_1 = value ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 params , TYPE_4 context ) { <START> TYPE_1 result = new TYPE_1 ( ) ; <END> if ( METHOD_2 ( VAR_1 , params ) ) { result = METHOD_3 ( VAR_1 , params , context ) ; } else { result . VAR_2 ( false ) ; } return result ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 params , <START> TYPE_4 context ) { <END> if ( METHOD_2 ( VAR_1 , params ) ) { params . VAR_2 ( TYPE_6 . VAR_4 ) ; return TYPE_5 . getInstance ( ) . METHOD_3 ( VAR_1 , params ) ; } return new TYPE_1 ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 vds ) { TYPE_1 VAR_1 = null ; Guid VAR_2 = vds . VAR_3 ( ) ; TYPE_3 VAR_4 = VAR_5 . get ( VAR_2 ) ; <START> <END> if ( VAR_4 != null ) { VAR_1 = VAR_6 ; } return VAR_1 ; } 
public String METHOD_1 ( ) { <START> this . VAR_1 = TYPE_1 . METHOD_2 ( this . getId ( ) . METHOD_3 ( ) , this . VAR_1 ) ; <END> return this . VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { <START> if ( TYPE_2 . METHOD_2 ( vm . VAR_1 ( ) ) ) <END> return new TYPE_3 ( vm , VAR_2 ) ; else return new TYPE_4 ( vm , VAR_2 ) ; } 
<START> private TYPE_1 [ ] METHOD_1 ( List < String > VAR_1 ) { <END> return ( TYPE_1 [ ] ) ( new TYPE_2 < TYPE_3 > ( new TYPE_4 ( VAR_2 . getId ( ) , VAR_1 ) ) . METHOD_2 ( ) ) ; } 
public VAR_1 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { VAR_5 = new TYPE_7 . TYPE_8 . HashMap < String , TYPE_5 > ( ) ; VAR_6 = "" ; VAR_7 = "" ; VAR_8 = false ; VAR_9 = 0 ; VAR_10 = VAR_2 ; VAR_11 = VAR_3 ; VAR_12 = VAR_4 ; if ( VAR_10 != null ) { <START> VAR_10 . METHOD_1 ( new TYPE_7 . TYPE_8 . ArrayList < TYPE_5 > ( ) ) ; <END> VAR_10 . METHOD_2 ( new TYPE_7 . TYPE_8 . ArrayList < TYPE_6 > ( ) ) ; } } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) ) ; if ( METHOD_5 ( ) . METHOD_6 ( ) == TYPE_3 . TYPE_6 ) { if ( ! TYPE_1 . METHOD_7 ( VAR_3 . METHOD_8 ( ) , METHOD_5 ( ) . METHOD_8 ( ) ) ) { METHOD_9 ( TYPE_4 . TYPE_5 , new TYPE_2 ( METHOD_5 ( ) . getId ( ) , METHOD_5 ( ) . METHOD_8 ( ) ) ) ; } } METHOD_10 ( ) ; METHOD_11 ( true ) ; } 
protected boolean METHOD_1 ( TYPE_1 vm ) { <START> String [ ] VAR_1 = TYPE_2 < String > METHOD_2 ( TYPE_3 . TYPE_5 ) . split ( STRING_1 ) ; <END> for ( String VAR_5 : VAR_1 ) { if ( VAR_5 . equalsIgnoreCase ( vm . VAR_6 ( ) ) ) { return true ; } } METHOD_3 ( TYPE_4 . VAR_8 ) ; return false ; } 
public boolean METHOD_1 ( TYPE_1 vds ) { boolean VAR_1 = true ; for ( TYPE_2 VAR_2 : VAR_3 ) { VAR_1 = VAR_1 && VAR_2 . METHOD_1 ( vds ) ; <START> if ( VAR_1 ) { <END> break ; } } return VAR_1 ; } 
<START> public boolean METHOD_1 ( TYPE_1 vds ) { <END> boolean VAR_1 = false ; for ( TYPE_2 VAR_2 : VAR_3 ) { VAR_1 = VAR_1 || VAR_2 . METHOD_1 ( vds ) ; if ( VAR_1 ) { break ; } } return VAR_1 ; } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> final TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( Guid . TYPE_2 ( ) ) ; VAR_1 . METHOD_3 ( new ArrayList < Guid > ( Arrays . asList ( new Guid ( ) ) ) ) ; return VAR_1 ; } 
<START> protected TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { <END> final TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( true ) ; VAR_2 . METHOD_3 ( new TYPE_3 ( VAR_1 . METHOD_4 ( ) , Guid . TYPE_4 ( ) ) ) ; return VAR_2 ; } 
private boolean METHOD_1 ( ) { return TYPE_2 < Boolean > METHOD_2 ( <START> TYPE_3 . TYPE_1 , METHOD_3 ( ) . METHOD_4 ( ) . getValue ( ) ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 != null ) { if ( VAR_1 . METHOD_2 ( ) == TYPE_6 . VAR_3 ) { <START> return Collections . VAR_4 ( new TYPE_1 ( getParameters ( ) . METHOD_3 ( ) , <END> TYPE_5 . TYPE_2 , TYPE_3 . VAR_8 ) ) ; } if ( VAR_1 . METHOD_2 ( ) == TYPE_6 . VAR_9 ) { return Collections . VAR_4 ( new TYPE_1 ( VAR_1 . METHOD_4 ( ) , TYPE_5 . TYPE_4 , TYPE_3 . VAR_11 ) ) ; } } return null ; } 
protected void METHOD_1 ( ) { String VAR_1 = null ; if ( getParameters ( ) . METHOD_2 ( ) == null ) { METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; } else { <START> TYPE_1 vm = TYPE_2 . getInstance ( ) . METHOD_5 ( ) . METHOD_6 ( getParameters ( ) . METHOD_2 ( ) ) ; <END> VAR_1 = TYPE_3 . METHOD_7 ( vm . VAR_2 ( ) , TYPE_4 . METHOD_8 ( vm ) ) ; } METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; } 
protected boolean METHOD_1 ( ) { <START> if ( METHOD_2 ( ) . METHOD_3 ( ) ) { <END> METHOD_4 ( TYPE_1 . VAR_2 ) ; return false ; } return super . METHOD_1 ( ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , Boolean VAR_2 ) { try { <START> return new TYPE_1 ( VAR_3 . METHOD_1 ( VAR_1 , VAR_2 . toString ( ) ) ) ; <END> } catch ( TYPE_2 VAR_4 ) { throw new TYPE_3 ( VAR_4 ) ; } } 
public TYPE_2 ( TYPE_1 params ) { super ( params ) ; <START> METHOD_1 ( getParameters ( ) . METHOD_2 ( ) ) ; <END> } 
public void METHOD_1 ( ) { assertEquals ( VAR_1 . remove ( VAR_2 . METHOD_2 ( ) ) , 1 ) ; TYPE_1 result = VAR_1 . get ( VAR_2 . METHOD_2 ( ) ) ; METHOD_3 ( result ) ; <START> <END> assertEquals ( VAR_1 . remove ( VAR_2 . METHOD_2 ( ) ) , 0 ) ; } 
<START> public static Guid METHOD_1 ( TYPE_1 id ) { <END> if ( id == null ) { return null ; } return id . getValue ( ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = super . METHOD_1 ( ) ; <END> Guid VAR_2 = VAR_3 == null ? null : VAR_3 . METHOD_2 ( ) ; VAR_1 . add ( new TYPE_1 ( VAR_2 , TYPE_4 . TYPE_5 , TYPE_3 . VAR_7 ) ) ; VAR_1 = TYPE_2 . getInstance ( ) . METHOD_3 ( VAR_1 , METHOD_4 ( ) , METHOD_5 ( ) ) ; } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { <START> boolean VAR_1 = ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_2 . VAR_3 ) ; <END> TYPE_1 VAR_4 = METHOD_4 ( ) . METHOD_5 ( METHOD_2 ( ) , VAR_1 ) ; return VAR_4 ; } 
protected TYPE_1 METHOD_1 ( List < org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_2 > VAR_6 ) { TYPE_1 VAR_7 = new TYPE_1 ( ) ; for ( org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_2 entity : VAR_6 ) { TYPE_2 vm = map ( entity ) ; VAR_7 . METHOD_2 ( ) . add ( METHOD_3 ( METHOD_4 ( vm , entity ) ) ) ; <START> METHOD_5 ( vm ) ; <END> } return VAR_7 ; } 
public static ArrayList < Guid > METHOD_1 ( String VAR_1 ) { ArrayList < String > VAR_2 = METHOD_2 ( VAR_1 ) ; <START> ArrayList < Guid > VAR_3 = new ArrayList < Guid > ( ) ; <END> if ( ! ( VAR_2 == null || VAR_2 . isEmpty ( ) ) ) { for ( String VAR_4 : VAR_2 ) { VAR_3 . add ( Guid . VAR_5 ( VAR_4 ) ) ; } } if ( VAR_3 . isEmpty ( ) ) { VAR_3 . add ( Guid . TYPE_1 ) ; } return VAR_3 ; } 
<START> public Guid getId ( ) { <END> return VAR_1 ; } 
public String toString ( ) { return String . format ( STRING_1 , super . toString ( ) , METHOD_1 ( ) , METHOD_2 ( ) , <START> METHOD_3 ( ) , METHOD_4 ( ) . toString ( ) ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = super . METHOD_1 ( ) ; <START> if ( getParameters ( ) . METHOD_2 ( ) . METHOD_3 ( ) ) { <END> VAR_1 . add ( new TYPE_1 ( METHOD_4 ( ) . METHOD_5 ( ) , TYPE_4 . TYPE_2 , TYPE_3 . VAR_5 ) ) ; } return VAR_1 ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) { for ( int i = 0 ; i < VAR_2 ; ++ i ) { <START> assertEquals ( STRING_1 + i + STRING_2 , VAR_1 . getId ( ) , VAR_1 . METHOD_2 ( ) . get ( i ) . METHOD_3 ( ) ) ; <END> } } 
protected boolean METHOD_1 ( TYPE_1 entity , Guid id ) { <START> return id != null && ( id . equals ( entity . getId ( ) ) || id . equals ( entity . VAR_1 ( ) ) || id . equals ( entity . VAR_2 ( ) ) ) ; <END> } 
public boolean METHOD_1 ( ) { boolean VAR_1 = VAR_2 ; for ( TYPE_1 VAR_3 : METHOD_2 ( ) ) { <START> VAR_1 &= VAR_3 . METHOD_1 ( ) ; <END> } return VAR_1 ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) { Map < String , Object > values = VAR_2 . get ( VAR_1 . METHOD_2 ( ) ) ; <START> if ( values != null ) { <END> values . put ( VAR_1 . METHOD_3 ( ) , METHOD_4 ( VAR_1 ) ) ; } else { values = new HashMap < String , Object > ( ) ; values . put ( VAR_1 . METHOD_3 ( ) , METHOD_4 ( VAR_1 ) ) ; VAR_2 . put ( VAR_1 . METHOD_2 ( ) , values ) ; } } 
<START> private static boolean METHOD_1 ( String VAR_1 ) throws TYPE_1 , TYPE_2 { <END> return TYPE_3 . class . METHOD_2 ( VAR_1 ) . METHOD_3 ( TYPE_4 . class ) ; } 
protected TYPE_1 METHOD_1 ( String id ) { TYPE_2 params = new TYPE_2 ( Guid . VAR_1 ( id ) ) ; <START> params . VAR_2 ( TYPE_3 . METHOD_2 ( ) ) ; <END> return METHOD_3 ( TYPE_1 . class , TYPE_5 . TYPE_4 , params , id ) ; } 
public TYPE_1 list ( ) { TYPE_2 params = new TYPE_2 ( VAR_1 ) ; <START> params . VAR_2 ( TYPE_3 . METHOD_1 ( ) ) ; <END> return METHOD_2 ( METHOD_3 ( TYPE_4 . TYPE_5 , params ) ) ; } 
public TYPE_1 get ( ) { TYPE_2 params = new TYPE_2 ( VAR_1 ) ; <START> params . VAR_2 ( TYPE_3 . METHOD_1 ( ) ) ; <END> return METHOD_2 ( TYPE_5 . TYPE_4 , params ) ; } 
<START> public void METHOD_1 ( String VAR_1 ) { <END> if ( Boolean . VAR_2 ( VAR_1 ) ) { VAR_3 = true ; } else { VAR_3 = false ; } } 
public void METHOD_1 ( Guid VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( STRING_1 , <START> METHOD_4 ( ) . METHOD_5 ( STRING_2 , VAR_1 . METHOD_6 ( ) ) ) ; <END> } 
private boolean METHOD_1 ( ) { final Set < TYPE_1 > VAR_1 = METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ; final TYPE_1 VAR_2 = METHOD_5 ( ) . METHOD_6 ( ) ; <START> final TYPE_2 VAR_3 = METHOD_5 ( ) . METHOD_7 ( ) ; <END> if ( ! VAR_1 . contains ( VAR_2 ) ) { return false ; } if ( ( VAR_2 == TYPE_1 . VAR_4 ) && ( VAR_3 != TYPE_2 . VAR_5 ) && ( VAR_3 != TYPE_2 . VAR_6 ) ) { return false ; } return true ; } 
protected boolean METHOD_1 ( ) { return TYPE_1 < Boolean > METHOD_2 ( TYPE_2 . TYPE_3 , <START> METHOD_3 ( ) . METHOD_4 ( ) . getValue ( ) ) ; <END> } 
public TYPE_2 ( T parameters ) { super ( parameters ) ; if ( parameters . VAR_2 ( ) != null && TYPE_3 . VAR_4 == parameters . VAR_2 ( ) . METHOD_1 ( ) ) { METHOD_2 ( ( ( TYPE_1 ) parameters . VAR_2 ( ) ) . METHOD_3 ( ) ) ; <START> } <END> if ( METHOD_4 ( ) != null ) { METHOD_5 ( METHOD_4 ( ) . METHOD_6 ( ) ) ; } } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == null || METHOD_2 ( VAR_1 ) ) { <END> METHOD_3 ( TYPE_2 . VAR_3 ) ; return false ; } return true ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) <START> . METHOD_3 ( TYPE_5 . TYPE_4 , new TYPE_3 ( METHOD_4 ( ) ) ) ; <END> } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( TYPE_6 . TYPE_4 , new TYPE_3 ( METHOD_4 ( ) ) ) ; if ( ! VAR_1 . METHOD_5 ( ) ) { <START> VAR_4 = TYPE_5 . VAR_6 ; <END> } } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = getParameters ( ) . METHOD_2 ( ) ; if ( VAR_1 != null ) { TYPE_2 . METHOD_3 ( new TYPE_3 ( Guid . TYPE_4 ( ) , getParameters ( ) . METHOD_4 ( ) ) , TYPE_5 . VAR_4 , VAR_1 . getType ( ) , VAR_1 . METHOD_5 ( ) , true , true , <START> "" ) ; <END> } } 
public static TYPE_1 METHOD_1 ( TYPE_2 id , boolean VAR_1 ) { <START> return METHOD_2 ( id , TYPE_3 . VAR_3 , TYPE_3 . VAR_4 , null , VAR_1 , false , "" ) ; <END> } 
private static < T extends TYPE_1 > void METHOD_1 ( T entity , List < TYPE_2 > VAR_1 ) { final Guid id = entity . getId ( ) ; for ( TYPE_3 VAR_2 : METHOD_2 ( entity . VAR_3 ( ) ) ) { Guid VAR_4 = VAR_2 . getId ( ) ; TYPE_2 VAR_5 = METHOD_3 ( new TYPE_4 ( VAR_4 , id ) , TYPE_5 . VAR_7 , TYPE_5 . VAR_7 , null , true , false , <START> "" ) ; <END> METHOD_4 ( entity , VAR_5 , VAR_4 , VAR_1 ) ; } } 
private static < T extends TYPE_1 > void METHOD_1 ( T entity , List < TYPE_2 > VAR_1 ) { final Guid id = entity . getId ( ) ; for ( TYPE_3 VAR_2 : entity . VAR_3 ( ) ) { Guid VAR_4 = VAR_2 . getId ( ) ; TYPE_2 VAR_5 = METHOD_2 ( new TYPE_4 ( VAR_4 , id ) , TYPE_5 . VAR_7 , TYPE_5 . VAR_8 , null , true , false , <START> "" ) ; <END> METHOD_3 ( entity , VAR_5 , VAR_4 , VAR_1 ) ; } } 
private static void METHOD_1 ( TYPE_1 vm , int VAR_1 ) { for ( int index = 1 ; index <= VAR_1 ; index ++ ) { TYPE_2 . METHOD_2 ( new TYPE_3 ( Guid . TYPE_4 ( ) , vm . getId ( ) ) , TYPE_5 . VAR_4 , TYPE_5 . VAR_5 , METHOD_3 ( ) , true , false , <START> "" ) ; <END> } } 
private static void METHOD_1 ( Guid VAR_1 ) { TYPE_1 . METHOD_2 ( new TYPE_2 ( Guid . TYPE_4 ( ) , VAR_1 ) , TYPE_5 . VAR_4 , TYPE_5 . VAR_5 , TYPE_3 < String , Object > METHOD_3 ( TYPE_6 . Path , "" ) , true , true , <START> "" ) ; <END> } 
<START> public Response remove ( TYPE_1 VAR_1 ) { <END> for ( TYPE_2 VAR_2 : VAR_1 . METHOD_1 ( ) ) { METHOD_2 ( VAR_2 , STRING_1 ) ; } return METHOD_3 ( TYPE_5 . TYPE_4 , new TYPE_3 ( METHOD_4 ( METHOD_5 ( ) ) , METHOD_6 ( METHOD_4 ( METHOD_5 ( ) ) , VAR_1 ) ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { METHOD_2 ( ) . METHOD_3 ( STRING_1 , METHOD_4 ( ) . METHOD_5 ( STRING_2 , VAR_1 . getId ( ) ) . METHOD_5 ( STRING_3 , VAR_2 . getId ( ) ) . METHOD_5 ( STRING_4 , VAR_2 . METHOD_6 ( ) ) . METHOD_5 ( STRING_5 , VAR_2 . METHOD_7 ( ) ) <START> . METHOD_5 ( STRING_6 , VAR_1 . METHOD_8 ( ) ) <END> . METHOD_5 ( STRING_7 , TYPE_2 . METHOD_9 ( VAR_2 . getStatus ( ) ) ) ) ; } 
<START> private ArrayList < String > split ( String VAR_1 ) { <END> if ( TYPE_1 . METHOD_1 ( VAR_1 ) ) { return null ; } return new ArrayList < String > ( Arrays . asList ( VAR_1 . split ( VAR_2 ) ) ) ; } 
private void METHOD_1 ( ) { Map < Boolean , TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ( ( TYPE_2 ) VAR_2 ) . METHOD_5 ( ) ) ; <START> if ( ! VAR_1 . values ( ) . isEmpty ( ) ) { <END> METHOD_6 ( VAR_1 . values ( ) . iterator ( ) . next ( ) . getId ( ) ) ; } } 
public static String map ( org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_3 type , String VAR_7 ) { <START> if ( type == null ) { <END> return null ; } else { switch ( type ) { case VAR_8 : return TYPE_3 . TYPE_5 . value ( ) ; case VAR_9 : return TYPE_3 . TYPE_4 . value ( ) ; default : return null ; } } } 
public < TYPE_1 extends TYPE_2 < TYPE_1 > > List < TYPE_1 > METHOD_1 ( Class < TYPE_1 > VAR_1 , List < String > VAR_2 ) { ArrayList < TYPE_1 > VAR_3 = new ArrayList < TYPE_1 > ( ) ; String VAR_4 = METHOD_2 ( Messages . VAR_5 ) ; String VAR_6 = METHOD_2 ( Messages . VAR_7 ) ; for ( String name : VAR_2 ) { <START> VAR_3 . add ( TYPE_3 . METHOD_3 ( VAR_4 , VAR_6 , VAR_1 , name ) ) ; <END> } return VAR_3 ; } 
private TYPE_1 ( ) { <START> this ( null ) ; <END> } 
public boolean METHOD_1 ( Guid VAR_1 ) { if ( METHOD_2 ( ) . METHOD_3 ( VAR_1 ) . size ( ) > 0 ) { return true ; } else { return false ; <START> } <END> } 
protected void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) . METHOD_3 ( ) , METHOD_4 ( ) , 0 ) ; <END> TYPE_2 . getInstance ( ) . METHOD_5 ( ) . METHOD_6 ( VAR_1 ) ; if ( getParameters ( ) . METHOD_7 ( ) ) { METHOD_8 ( ) . METHOD_9 ( VAR_1 ) ; METHOD_8 ( ) . METHOD_10 ( ) ; } METHOD_11 ( true ) ; } 
public Response METHOD_1 ( ) { <START> VAR_1 = METHOD_2 ( ) . get ( TYPE_1 . class ) ; <END> TYPE_2 VAR_2 = null ; if ( VAR_1 == TYPE_1 . TYPE_3 ) { VAR_2 = METHOD_3 ( ) ; } else { VAR_2 = METHOD_4 ( ) ; } return METHOD_5 ( VAR_2 ) . build ( ) ; } 
public Map < String , String > METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new HashMap < String , String > ( ) ; VAR_1 . put ( TYPE_3 . TYPE_5 . name ( ) . METHOD_2 ( ) , <START> ( METHOD_3 ( ) == null ) ? "" : METHOD_3 ( ) ) ; <END> VAR_1 . put ( TYPE_3 . TYPE_4 . name ( ) . METHOD_2 ( ) , METHOD_4 ( ) ) ; } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 msg ) { assertTrue ( STRING_1 , command . VAR_1 ( ) . METHOD_2 ( ) <START> . contains ( msg . toString ( ) ) ) ; <END> } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) || METHOD_2 ( getParameters ( ) . METHOD_4 ( ) ) . METHOD_3 ( ) ) { <START> METHOD_5 ( TYPE_1 . VAR_2 ) ; <END> METHOD_5 ( TYPE_1 . VAR_3 ) ; } } 
public TYPE_2 ( Guid VAR_2 , Guid VAR_3 , Guid VAR_4 , Guid VAR_5 , Guid VAR_6 , Guid VAR_7 , TYPE_1 VAR_8 ) { <START> this ( VAR_2 , VAR_3 , VAR_4 , VAR_7 , VAR_8 ) ; <END> METHOD_1 ( VAR_6 ) ; METHOD_2 ( VAR_5 ) ; METHOD_3 ( VAR_6 ) ; } 
private void METHOD_1 ( ) { Guid VAR_1 = METHOD_2 ( ) . getId ( METHOD_3 ( ) , TYPE_5 . VAR_3 ) ; if ( VAR_4 . METHOD_4 ( ) == TYPE_4 . VAR_6 ) { TYPE_1 VAR_7 = ( ( TYPE_1 ) VAR_4 ) ; METHOD_5 ( ) . METHOD_6 ( VAR_7 . METHOD_7 ( ) , <START> VAR_1 ) ; <END> VAR_7 . METHOD_8 ( VAR_1 ) ; } else { throw new TYPE_2 ( TYPE_3 . TYPE_6 , STRING_1 ) ; } } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; parameters . VAR_2 ( ) . METHOD_1 ( Guid . TYPE_3 ( ) ) ; parameters . VAR_4 ( parameters . VAR_2 ( ) . getId ( ) ) ; <START> VAR_5 = ! Guid . TYPE_2 . equals ( parameters . VAR_7 ( ) ) ; <END> } 
public static String map ( org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_6 VAR_8 , String VAR_9 ) { switch ( VAR_8 ) { <START> case VAR_10 : <END> return TYPE_6 . TYPE_7 . name ( ) ; case VAR_11 : return TYPE_6 . TYPE_10 . name ( ) ; case VAR_12 : return TYPE_6 . TYPE_11 . name ( ) ; case VAR_13 : return TYPE_6 . TYPE_8 . name ( ) ; case VAR_14 : return TYPE_6 . TYPE_9 . name ( ) ; default : return null ; } } 
public boolean METHOD_1 ( TYPE_1 key , String value ) { if ( StringUtils . VAR_1 ( value ) && new File ( value ) . exists ( ) ) { return true ; } <START> if ( StringUtils . VAR_1 ( value ) && value . equals ( VAR_2 ) ) { <END> return true ; } if ( StringUtils . VAR_1 ( parser . VAR_3 ( ) ) && new File ( parser . VAR_3 ( ) ) . exists ( ) ) { return true ; } return false ; } 
protected boolean METHOD_1 ( ) { <START> if ( ! METHOD_2 ( ) ) { <END> return true ; } return METHOD_3 ( ) . get ( METHOD_4 ( ) ) == null ; } 
protected boolean METHOD_1 ( ) { boolean VAR_1 = true ; if ( METHOD_2 ( ) == null ) { List < TYPE_1 > VAR_2 = METHOD_3 ( ) ; METHOD_4 ( VAR_2 . isEmpty ( ) ? null : VAR_2 . get ( 0 ) ) ; <START> if ( METHOD_2 ( ) == null ) { <END> VAR_1 = false ; METHOD_5 ( TYPE_2 . VAR_4 ) ; } } return VAR_1 ; } 
public String METHOD_1 ( String value ) throws IOException { String VAR_1 = null ; <START> if ( StringUtils . VAR_2 ( value ) && value . equals ( VAR_3 ) ) { <END> VAR_1 = TYPE_1 . METHOD_2 ( null ) ; } else { VAR_1 = TYPE_1 . METHOD_3 ( ( StringUtils . VAR_2 ( value ) ) ? value : parser . VAR_4 ( ) ) ; } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 options = new TYPE_1 ( ) ; options . add ( TYPE_5 . VAR_2 , Boolean . toString ( getParameters ( ) . METHOD_2 ( ) ) ) ; if ( getParameters ( ) . METHOD_2 ( ) ) { int VAR_3 = getParameters ( ) . METHOD_3 ( ) ; <START> if ( VAR_3 <= 0 ) { <END> VAR_3 = TYPE_2 < Integer > METHOD_4 ( TYPE_3 . TYPE_4 ) ; } options . add ( TYPE_5 . VAR_3 , VAR_3 ) ; } return options ; } 
private void METHOD_1 ( ) { <START> if ( getParameters ( ) . METHOD_2 ( ) ) { <END> for ( TYPE_1 VAR_1 : METHOD_3 ( ) . METHOD_4 ( ) . values ( ) ) { if ( ! VAR_1 . METHOD_5 ( ) ) { TYPE_2 . log ( this , TYPE_3 . VAR_3 ) ; break ; } } } } 
public Map < String , String > METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new HashMap < String , String > ( ) ; <START> VAR_1 . put ( TYPE_3 . TYPE_5 . toString ( ) . METHOD_2 ( ) , METHOD_3 ( ) ) ; <END> VAR_1 . put ( TYPE_3 . TYPE_4 . toString ( ) . METHOD_2 ( ) , METHOD_4 ( ) ) ; } return VAR_1 ; } 
protected boolean METHOD_1 ( ) { <START> if ( ! super . METHOD_1 ( ) ) { <END> return false ; } if ( METHOD_2 ( ) == null ) { METHOD_3 ( TYPE_1 . VAR_2 ) ; return false ; } METHOD_4 ( METHOD_2 ( ) . METHOD_5 ( ) ) ; return true ; } 
private boolean METHOD_1 ( ) { METHOD_2 ( ) ; <START> return ! VAR_1 . isEmpty ( ) ; <END> } 
protected void METHOD_1 ( ) { METHOD_2 ( ) ; TYPE_1 vm = METHOD_3 ( ) ; <START> if ( vm != null ) { <END> TYPE_2 . METHOD_4 ( vm . getId ( ) ) ; METHOD_5 ( vm ) ; if ( getParameters ( ) . METHOD_6 ( ) ) { this . METHOD_7 ( vm ) ; } else { this . METHOD_8 ( vm ) ; } } else { METHOD_9 ( false ) ; log . warn ( STRING_1 ) ; } METHOD_10 ( true ) ; } 
private void METHOD_1 ( TYPE_1 vm ) { <START> METHOD_2 ( ) ; <END> TYPE_2 . METHOD_3 ( vm ) ; TYPE_3 . METHOD_4 ( vm . VAR_1 ( ) ) ; } 
<START> protected void METHOD_1 ( Guid VAR_1 ) { <END> List < Guid > VAR_2 = new ArrayList < Guid > ( ) ; METHOD_2 ( VAR_1 , VAR_2 ) ; Collections . VAR_3 ( VAR_2 ) ; for ( Guid child : VAR_2 ) { METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( child ) ) ; } } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , String VAR_4 , String VAR_5 , String VAR_6 , String VAR_7 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; } 
public Map < String , String > METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = super . METHOD_1 ( ) ; VAR_1 . put ( TYPE_3 . TYPE_4 . name ( ) . METHOD_2 ( ) , <START> ( METHOD_3 ( ) == null ) ? "" : METHOD_3 ( ) ) ; <END> VAR_1 . put ( TYPE_3 . TYPE_5 . name ( ) . METHOD_2 ( ) , ( METHOD_4 ( ) == null ) ? "" : METHOD_4 ( ) ) ; } return VAR_1 ; } 
protected boolean METHOD_1 ( ) { if ( ! super . METHOD_1 ( ) ) return false ; <START> if ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_1 . TYPE_2 ) { <END> return true ; } if ( METHOD_2 ( ) . METHOD_3 ( ) != TYPE_1 . TYPE_4 ) { METHOD_4 ( TYPE_3 . VAR_4 ) ; return false ; } return true ; } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { if ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_3 . TYPE_2 ) { TYPE_1 . METHOD_4 ( METHOD_2 ( ) , METHOD_5 ( ) ) ; } METHOD_6 ( METHOD_2 ( ) . METHOD_7 ( ) , Arrays . asList ( METHOD_2 ( ) ) ) ; } else { METHOD_8 ( false ) ; log . warn ( STRING_1 ) ; } <START> METHOD_9 ( true ) ; <END> } 
protected void METHOD_1 ( ) { <START> if ( METHOD_2 ( ) != null ) { <END> if ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_3 . TYPE_2 ) { TYPE_1 . METHOD_4 ( METHOD_2 ( ) , METHOD_5 ( ) ) ; } METHOD_6 ( METHOD_2 ( ) . METHOD_7 ( ) , Arrays . asList ( METHOD_2 ( ) ) ) ; } else { METHOD_8 ( false ) ; log . warn ( STRING_1 ) ; } METHOD_9 ( true ) ; } 
<START> private < T > void METHOD_1 ( List < TYPE_1 > VAR_1 , boolean VAR_2 ) { <END> TYPE_2 container = new TYPE_2 ( VAR_1 ) ; Set < TYPE_3 < TYPE_2 > > VAR_3 = VAR_4 . METHOD_2 ( container ) ; Assert . assertEquals ( VAR_2 , VAR_3 . isEmpty ( ) ) ; } 
private static void METHOD_1 ( TYPE_1 vds , TYPE_2 VAR_1 , Object [ ] VAR_2 ) { vds . VAR_3 ( ) . add ( VAR_1 ) ; if ( VAR_2 != null ) { for ( Object name : VAR_2 ) { for ( TYPE_2 VAR_4 : vds . VAR_3 ( ) ) { if ( VAR_4 . getName ( ) . equals ( name . toString ( ) ) ) { <START> VAR_4 . METHOD_2 ( VAR_1 . getName ( ) ) ; <END> } } } } } 
void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( VAR_1 ) ; TYPE_1 . METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; TYPE_1 . METHOD_5 ( ) . METHOD_4 ( new TYPE_2 ( ) { @Override public void METHOD_6 ( TYPE_3 VAR_3 , Object VAR_4 , TYPE_4 args ) { user . VAR_5 ( ) ; <START> VAR_2 . METHOD_7 ( ) ; <END> } } ) ; TYPE_1 . METHOD_8 ( METHOD_9 ( ) ) ; } 
public Map < String , String > METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> VAR_1 . put ( TYPE_2 . TYPE_3 . name ( ) . METHOD_2 ( ) , ( METHOD_3 ( ) == null ) ? "" : METHOD_3 ( ) ) ; } return VAR_1 ; } 
public TYPE_2 ( TYPE_1 VAR_2 , String ... params ) { <START> this ( STRING_1 , VAR_2 , params ) ; <END> } 
<START> protected <END> <END> <END> < TYPE_1 extends TYPE_2 < ? <END> <END> , <END> <END> ? > <END> > <END> TYPE_1 <END> METHOD_1 ( <END> TYPE_1 <END> resource <END> ) { <END> resource <END> . <END> VAR_1 ( <END> VAR_2 <END> ) <END> ; resource <END> . <END> VAR_3 <END> ( VAR_4 <END> ) <END> ; <END> resource . <END> VAR_5 <END> ( <END> VAR_6 ) <END> <END> ; <END> resource <END> . VAR_7 <END> <END> <END> ( VAR_8 
protected TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_2 ( ) ; <END> } return VAR_1 ; } 
private List < String > METHOD_1 ( TYPE_1 vds ) { List < String > VAR_1 = new ArrayList < String > ( ) ; for ( TYPE_2 VAR_2 : METHOD_2 ( ) . METHOD_3 ( vds . getId ( ) ) ) { <START> VAR_1 . add ( VAR_2 . METHOD_4 ( ) ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( ) { <START> log . info ( STRING_1 ) ; <END> List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; for ( TYPE_1 cluster : VAR_1 ) { if ( cluster . VAR_2 ( ) ) { log . VAR_3 ( STRING_2 , cluster . VAR_4 ( ) ) ; METHOD_4 ( cluster ) ; } } } 
public TYPE_1 METHOD_1 ( ) { <START> if ( ! ( Boolean ) VAR_1 . METHOD_2 ( ) || VAR_2 == null ) { <END> return METHOD_3 ( ) ; } return VAR_2 ; } 
public Map < String , String > METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = super . METHOD_1 ( ) ; VAR_1 . put ( TYPE_4 . TYPE_5 . name ( ) . METHOD_2 ( ) , ( METHOD_3 ( ) == null ) ? "" : METHOD_3 ( ) ) ; VAR_1 . put ( TYPE_4 . TYPE_7 . name ( ) . METHOD_2 ( ) , METHOD_4 ( ) ) ; <START> VAR_1 . put ( TYPE_4 . TYPE_6 . name ( ) , METHOD_5 ( ) ) ; <END> } return VAR_1 ; } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > list = new ArrayList < TYPE_1 > ( ) ; <START> for ( TYPE_2 VAR_1 : getParameters ( ) . METHOD_2 ( ) . METHOD_3 ( ) . values ( ) ) { <END> if ( VAR_1 instanceof TYPE_3 ) { TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; list . add ( new TYPE_1 ( VAR_2 . METHOD_4 ( ) , VAR_3 . get ( VAR_2 . getId ( ) ) , VAR_2 . METHOD_5 ( ) ) ) ; } } return list ; } 
public void METHOD_1 ( HashMap < Guid , ArrayList < Guid > > value ) { VAR_1 = value ; <START> METHOD_2 ( ) ; <END> } 
<START> public static boolean METHOD_1 ( TYPE_1 VAR_1 , Map < String , TYPE_2 > VAR_2 ) { <END> String VAR_3 = VAR_1 . METHOD_2 ( ) ; return ( VAR_2 . containsKey ( VAR_3 ) && VAR_2 . get ( VAR_3 ) . METHOD_3 ( ) ) ; } 
<START> public TYPE_4 ( Guid VAR_2 , TYPE_1 vm , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <END> super ( VAR_2 ) ; this . VAR_5 = vm . getId ( ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_6 = vm . VAR_7 ( ) ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( ) . get ( getParameters ( ) . METHOD_4 ( ) ) ; } return VAR_1 ; } 
protected boolean METHOD_1 ( ) { <START> METHOD_2 ( getParameters ( ) . METHOD_3 ( ) ) ; <END> if ( METHOD_4 ( ) == null ) { METHOD_5 ( TYPE_1 . VAR_2 ) ; return false ; } if ( METHOD_6 ( ) == null ) { METHOD_5 ( TYPE_1 . VAR_3 ) ; return false ; } if ( METHOD_7 ( ) . METHOD_8 ( ) . METHOD_9 ( METHOD_6 ( ) ) == null ) { METHOD_5 ( TYPE_1 . VAR_4 ) ; return false ; } return true ; } 
protected boolean METHOD_1 ( ) { Boolean VAR_1 = TYPE_1 < Boolean > METHOD_2 ( TYPE_2 . TYPE_3 ) ; <START> if ( VAR_1 == null ) { <END> VAR_1 = Boolean . VAR_5 ; } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( ! VAR_1 . METHOD_2 ( ) ) { List < TYPE_1 > VAR_2 = METHOD_3 ( ) . METHOD_4 ( VAR_1 . getId ( ) ) ; <START> if ( VAR_2 != null && ! VAR_2 . isEmpty ( ) ) { <END> return VAR_2 . get ( 0 ) ; } } return null ; } 
public TYPE_4 ( Guid VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 message ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . TYPE_5 = VAR_3 ; this . VAR_4 = VAR_4 ; this . message = message ; } 
protected void METHOD_1 ( TYPE_1 client , String VAR_1 ) { if ( ! VAR_1 . equals ( METHOD_2 ( client ) ) ) { <START> throw new TYPE_2 ( STRING_1 + getParameters ( ) . METHOD_3 ( ) <END> + STRING_2 + VAR_1 ) ; } } 
private String METHOD_1 ( TYPE_1 element , String VAR_1 ) { TYPE_2 VAR_2 = element . VAR_3 ( VAR_1 ) ; TYPE_1 VAR_4 = ( TYPE_1 ) VAR_2 . item ( 0 ) ; TYPE_2 VAR_5 = VAR_4 . METHOD_2 ( ) ; <START> return VAR_5 . item ( 0 ) . METHOD_3 ( ) . trim ( ) ; <END> } 
protected boolean METHOD_1 ( ) { if ( METHOD_2 ( ) == null ) { return METHOD_3 ( TYPE_2 . VAR_2 ) ; } <START> if ( true && METHOD_2 ( ) . METHOD_4 ( ) == TYPE_1 . TYPE_3 ) { <END> return METHOD_3 ( TYPE_2 . VAR_5 ) ; } return true ; } 
protected void METHOD_1 ( ) { try { TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( TYPE_3 . TYPE_4 , new TYPE_2 ( METHOD_4 ( ) , getParameters ( ) . METHOD_5 ( ) , getParameters ( ) . METHOD_6 ( ) , getParameters ( ) . METHOD_7 ( ) , getParameters ( ) . METHOD_8 ( ) ) ) ; METHOD_9 ( ) . METHOD_10 ( VAR_1 . METHOD_11 ( ) ) ; <START> } catch ( Exception e ) { <END> throw new RuntimeException ( e ) ; } } 
private Guid METHOD_1 ( List < TYPE_1 > VAR_1 , String VAR_2 ) { String [ ] VAR_3 = VAR_2 . split ( STRING_1 , - 1 ) ; <START> if ( VAR_3 . length != 2 ) { <END> throw new RuntimeException ( STRING_2 + VAR_2 + STRING_3 ) ; } for ( TYPE_1 VAR_4 : VAR_1 ) { if ( VAR_4 . METHOD_2 ( ) . equals ( VAR_2 ) ) { return VAR_4 . getId ( ) ; } } return null ; } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { if ( getParameters ( ) . METHOD_2 ( ) ) { <START> TYPE_1 VAR_2 = TYPE_2 . getInstance ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; <END> if ( VAR_2 == null ) { log . VAR_3 ( STRING_1 , VAR_1 . METHOD_5 ( ) ) ; VAR_2 = VAR_1 ; } return VAR_2 ; } else { return VAR_1 ; } } 
public String toString ( ) { String TYPE_1 = METHOD_1 ( ) ; return String . format ( STRING_1 , super . toString ( ) , <START> ( ! StringUtils . isEmpty ( TYPE_1 ) ? TYPE_1 + STRING_2 : "" ) , <END> ( getParameters ( ) != null ? getParameters ( ) . toString ( ) : STRING_3 ) ) ; } 
public boolean METHOD_1 ( TYPE_1 vm ) { Map < TYPE_2 , Integer > map = METHOD_2 ( vm ) ; Integer VAR_1 = TYPE_4 < Integer > METHOD_3 ( TYPE_5 . TYPE_6 ) ; <START> for ( TYPE_2 VAR_5 : map . keySet ( ) ) { <END> if ( ! TYPE_3 . METHOD_4 ( VAR_5 , VAR_1 * map . get ( VAR_5 ) ) ) { log . error ( STRING_1 + VAR_5 . getId ( ) ) ; return false ; } } return true ; } 
private void METHOD_1 ( RuntimeException ex ) { log . VAR_1 ( STRING_1 , METHOD_2 ( ) , TYPE_1 . getMessage ( ex ) ) ; <START> if ( ! ( ex instanceof TYPE_2 ) ) { <END> log . error ( TYPE_1 . METHOD_3 ( ex ) ) ; } } 
public String METHOD_1 ( Boolean VAR_1 ) { if ( VAR_1 == null ) return "" ; <START> <END> if ( VAR_2 == null || VAR_3 == null ) { return VAR_1 . toString ( ) ; } return VAR_1 . METHOD_2 ( ) ? VAR_2 : VAR_3 ; } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_5 . TYPE_4 , new TYPE_2 ( VAR_4 . getId ( ) , METHOD_3 ( ) ) ) ; METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; if ( ! METHOD_5 ( ) ) { METHOD_6 ( TYPE_3 . VAR_6 , VAR_1 . METHOD_7 ( ) . getMessage ( ) ) ; <START> return ; <END> } } 
<START> public static TYPE_1 METHOD_1 ( ) { <END> return TYPE_2 . getInstance ( ) . METHOD_2 ( ) ; } 
private static void METHOD_1 ( ) { <START> assertTrue ( VAR_1 , VAR_2 . size ( ) > 0 ) ; <END> VAR_2 . clear ( ) ; } 
private static void METHOD_1 ( ) { <START> assertTrue ( VAR_1 , VAR_2 . size ( ) == 0 ) ; <END> } 
private static void METHOD_1 ( ) { <START> assertTrue ( VAR_1 , VAR_2 ) ; <END> VAR_2 = false ; } 
protected void METHOD_1 ( ) { status = METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) , getParameters ( ) . METHOD_5 ( ) , getParameters ( ) . METHOD_6 ( ) ) ; METHOD_7 ( ) ; <START> METHOD_8 ( METHOD_9 ( ) ) ; <END> } 
public TYPE_2 ( TYPE_1 parameters ) { super ( parameters ) ; <START> VAR_2 = new HashSet < String > ( ) ; <END> } 
public void METHOD_1 ( ) { boolean VAR_1 = false ; for ( TYPE_1 VAR_2 : TYPE_1 . values ( ) ) { if ( ! VAR_3 . contains ( VAR_2 . toString ( ) ) ) { log . error ( STRING_1 + VAR_2 . toString ( ) ) ; VAR_1 = true ; break ; } } <START> METHOD_2 ( VAR_1 ) ; <END> } 
protected TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = new TYPE_2 ( VAR_1 ) ; <START> return VAR_2 ; <END> } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 ; final String VAR_2 = String . format ( STRING_1 , METHOD_2 ( ) , METHOD_3 ( ) . VAR_3 ) ; VAR_1 = METHOD_4 ( VAR_2 ) ; <START> return VAR_1 ; <END> } 
public TYPE_1 ( String VAR_2 , Throwable VAR_3 ) { <START> super ( STRING_1 + VAR_2 , VAR_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) , VAR_2 ) ; VAR_1 . METHOD_3 ( new ArrayList < TYPE_2 > ( ) ) ; for ( TYPE_2 VAR_3 : getParameters ( ) ) { TYPE_2 VAR_4 = VAR_3 instanceof TYPE_3 ? ( ( TYPE_3 ) VAR_3 ) . METHOD_1 ( ) : <START> ( ( TYPE_4 ) VAR_3 ) . METHOD_1 ( ) ; <END> VAR_1 . getParameters ( ) . add ( VAR_4 ) ; } return VAR_1 ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return this . VAR_1 ; } 
public static boolean METHOD_1 ( TYPE_1 version , TYPE_2 type ) { return ! ( ( type == TYPE_2 . VAR_1 && version . VAR_2 ( new TYPE_1 ( 2 , 2 ) ) <= 0 ) <START> || ( type == TYPE_2 . VAR_3 && version . VAR_2 ( new TYPE_1 ( 3 , 0 ) ) <= 0 ) <END> || ( type == TYPE_2 . VAR_4 && version . VAR_2 ( new TYPE_1 ( 3 , 2 ) ) <= 0 ) ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > list = new ArrayList < TYPE_1 > ( ) ; <START> for ( TYPE_2 VAR_1 : METHOD_2 ( ) ) { <END> list . add ( new TYPE_1 ( VAR_1 . METHOD_3 ( ) , null , TYPE_3 . TYPE_4 . VAR_3 , VAR_1 . METHOD_4 ( ) . get ( 0 ) , VAR_1 . METHOD_5 ( ) ) ) ; } return list ; } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) == TYPE_3 . TYPE_2 ) { METHOD_3 ( ) ; if ( getParameters ( ) . METHOD_4 ( ) ) { METHOD_5 ( ) . remove ( new TYPE_1 ( getParameters ( ) . METHOD_6 ( ) , getParameters ( ) . METHOD_7 ( ) ) ) ; } METHOD_8 ( ) ; <START> } else { <END> METHOD_3 ( ) ; } METHOD_9 ( true ) ; } 
protected TYPE_1 METHOD_1 ( int index ) { <START> TYPE_1 vds = METHOD_2 ( VAR_1 . METHOD_3 ( TYPE_1 . class ) , VAR_1 . METHOD_3 ( TYPE_2 . class ) , index ) ; <END> TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( TYPE_3 . class ) ; METHOD_4 ( VAR_2 . getId ( ) ) . METHOD_5 ( VAR_3 [ 2 ] ) . METHOD_6 ( ) ; METHOD_4 ( vds . VAR_4 ( ) ) . METHOD_5 ( VAR_2 ) . METHOD_6 ( ) ; return vds ; } 
protected void METHOD_1 ( int VAR_1 ) throws Exception { TYPE_1 host = TYPE_2 . METHOD_2 ( VAR_2 . METHOD_3 ( TYPE_1 . class ) , VAR_2 . METHOD_3 ( TYPE_3 . class ) , <START> VAR_1 ) ; <END> METHOD_4 ( TYPE_6 . TYPE_5 , TYPE_4 . class , new String [ ] { STRING_1 } , new Object [ ] { VAR_5 [ VAR_1 ] } , host ) ; } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new TYPE_2 < TYPE_1 > ( ) ; VAR_1 . add ( VAR_2 ) ; VAR_1 . add ( VAR_3 ) ; VAR_1 . add ( VAR_4 ) ; <START> return VAR_1 ; <END> } 
<START> private TYPE_3 ( ) { <END> VAR_2 = new TYPE_1 ( ) ; VAR_3 = new TYPE_2 < Guid > ( ) ; VAR_4 = new TYPE_2 < Long > ( ) ; } 
<START> private void METHOD_1 ( Guid VAR_1 ) { <END> List < Guid > VAR_2 = new TYPE_1 < Guid > ( METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ) ; for ( Guid id : VAR_2 ) { METHOD_4 ( VAR_1 , id , Guid . TYPE_2 ) ; } METHOD_2 ( ) . METHOD_5 ( VAR_2 ) ; } 
<START> public long METHOD_1 ( ) { <END> return VAR_1 ; } 
protected TYPE_1 METHOD_1 ( ) { <START> return TYPE_2 . getInstance ( ) . METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 result ) { assertNotNull ( result ) ; <START> assertTrue ( STRING_1 , result . VAR_1 ( ) == 1 ) ; <END> assertEquals ( result , VAR_2 ) ; } 
private static void METHOD_1 ( List < TYPE_1 > result ) { assertNotNull ( result ) ; METHOD_2 ( result . isEmpty ( ) ) ; assertEquals ( VAR_1 , result . size ( ) ) ; for ( TYPE_1 vm : result ) { <START> assertTrue ( STRING_1 , vm . VAR_2 ( ) == 1 ) ; <END> } } 
private static void METHOD_1 ( TYPE_1 result ) { assertNotNull ( result ) ; assertEquals ( VAR_1 , result . getId ( ) ) ; <START> assertTrue ( STRING_1 , result . VAR_2 ( ) == 1 ) ; <END> } 
private static void METHOD_1 ( List < TYPE_1 > result ) { assertNotNull ( result ) ; METHOD_2 ( result . isEmpty ( ) ) ; for ( TYPE_1 VAR_1 : result ) { <START> assertTrue ( STRING_1 , VAR_1 . METHOD_3 ( ) == 1 ) ; <END> } } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . METHOD_3 ( ) ) { METHOD_4 ( METHOD_5 ( ) ) ; } if ( VAR_1 . METHOD_6 ( ) ) { METHOD_4 ( METHOD_7 ( ) ) ; } <START> <END> METHOD_8 ( TYPE_3 . TYPE_4 , new TYPE_2 ( METHOD_9 ( ) ) ) ; } 
public TYPE_3 ( TYPE_1 parameters ) { <START> super ( parameters , parameters . VAR_2 ( ) ) ; <END> if ( METHOD_1 ( ) == null ) { METHOD_2 ( TYPE_2 . getInstance ( ) . METHOD_3 ( ) . get ( parameters . VAR_3 ( ) ) ) ; parameters . VAR_4 ( METHOD_1 ( ) ) ; } } 
private void METHOD_1 ( TYPE_1 e ) { log . VAR_1 ( STRING_1 , TYPE_2 . getMessage ( e ) ) ; TYPE_3 VAR_2 = new TYPE_3 ( ) ; VAR_2 . METHOD_2 ( STRING_2 , METHOD_3 ( ) ) ; <START> VAR_2 . METHOD_2 ( STRING_3 , METHOD_4 ( ) ) ; <END> TYPE_4 . log ( VAR_2 , TYPE_5 . VAR_4 ) ; } 
<START> public void METHOD_1 ( Guid VAR_1 , Guid VAR_2 ) { <END> VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) ; try { if ( ! VAR_4 . containsKey ( VAR_1 ) ) { return ; } synchronized ( VAR_4 . get ( VAR_1 ) ) { VAR_4 . get ( VAR_1 ) . remove ( VAR_2 ) ; } } finally { VAR_3 . METHOD_2 ( ) . METHOD_4 ( ) ; } } 
private boolean METHOD_1 ( Class VAR_1 , Class VAR_2 ) { if ( Arrays . asList ( VAR_1 . METHOD_2 ( ) ) . contains ( VAR_2 ) ) { return true ; } else { <START> return VAR_1 . METHOD_3 ( ) != TYPE_1 . class <END> && METHOD_1 ( VAR_1 . METHOD_3 ( ) , VAR_2 ) ; } } 
public TYPE_1 get ( Guid id ) { TYPE_2 VAR_1 = METHOD_1 ( ) . METHOD_2 ( STRING_1 , id ) ; TYPE_1 entity = METHOD_3 ( ) . METHOD_4 ( STRING_2 , VAR_2 , VAR_1 ) ; <START> entity . VAR_3 ( TYPE_3 . getInstance ( ) . METHOD_5 ( ) . get ( id ) ) ; <END> return entity ; } 
public void remove ( Guid id ) { TYPE_1 VAR_1 = METHOD_1 ( ) . METHOD_2 ( STRING_1 , id ) ; METHOD_3 ( ) . METHOD_4 ( STRING_2 , VAR_1 ) ; <START> TYPE_2 . getInstance ( ) . METHOD_5 ( ) . remove ( id ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { <START> <END> if ( METHOD_2 ( ) ) { return Collections . VAR_1 ( new TYPE_1 ( getParameters ( ) . METHOD_3 ( ) , TYPE_5 . TYPE_4 , TYPE_2 . VAR_5 ) ) ; } else { Guid VAR_6 = getParameters ( ) . METHOD_4 ( ) == null ? null : getParameters ( ) . METHOD_4 ( ) . getId ( ) ; return Collections . VAR_1 ( new TYPE_1 ( VAR_6 , TYPE_5 . TYPE_3 , METHOD_5 ( ) . METHOD_6 ( ) ) ) ; } } 
private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> if ( METHOD_2 ( ) == null ) { <END> return null ; } else { return TYPE_2 . METHOD_3 ( VAR_1 , new TYPE_3 < TYPE_1 > ( ) { @Override public boolean METHOD_4 ( TYPE_1 VAR_2 ) { return METHOD_2 ( ) . equals ( VAR_2 . getName ( ) ) ; } } ) ; } } 
protected void METHOD_1 ( ) { final TYPE_1 VAR_1 = getParameters ( ) . METHOD_2 ( ) ; if ( VAR_1 != null ) { <START> TYPE_2 . METHOD_3 ( new TYPE_3 < TYPE_4 > ( ) { <END> @Override public TYPE_4 METHOD_4 ( ) { METHOD_5 ( VAR_1 , METHOD_6 ( ) ) ; METHOD_7 ( ) . METHOD_8 ( VAR_1 . getId ( ) ) ; METHOD_7 ( ) . METHOD_9 ( true ) ; return null ; } } ) ; } } 
protected boolean METHOD_1 ( ) { List < String > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; Map < Guid , TYPE_1 > VAR_2 = new HashMap < Guid , TYPE_1 > ( ) ; <START> if ( ! METHOD_4 ( VAR_1 , VAR_2 ) ) { <END> return false ; } if ( getParameters ( ) . METHOD_5 ( ) ) { METHOD_6 ( ) ; } if ( ! METHOD_7 ( VAR_1 , VAR_2 ) ) { return false ; } return true ; } 
public static TYPE_1 METHOD_1 ( String v ) { try { if ( v == null ) { return null ; } if ( v . equals ( STRING_1 ) ) { return VAR_1 ; } else if ( v . equals ( STRING_2 ) ) { return VAR_2 ; } else { <START> return valueOf ( v . VAR_3 ( ) ) ; <END> } } catch ( IllegalArgumentException e ) { return null ; } } 
public void METHOD_1 ( TYPE_1 host ) { if ( host . VAR_1 ( ) ) { if ( host . VAR_2 ( ) . METHOD_2 ( ) ) { for ( TYPE_2 VAR_3 : host . VAR_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) { <START> METHOD_5 ( TYPE_3 . class , VAR_3 . METHOD_6 ( ) , true ) ; <END> } } } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; ArrayList < TYPE_2 > VAR_2 = new ArrayList < TYPE_2 > ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; <START> TYPE_3 VAR_3 = command . VAR_4 ( VAR_1 ) ; <END> assertEquals ( STRING_1 , VAR_3 , VAR_3 . VAR_5 ) ; } 
<START> protected < T > Response METHOD_1 ( TYPE_1 task , <END> TYPE_2 VAR_1 , TYPE_3 < T , TYPE_4 > VAR_2 , boolean VAR_3 ) { return METHOD_1 ( task , VAR_1 , VAR_2 , VAR_3 , null ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 model , TYPE_2 entity ) { if ( TYPE_5 . TYPE_6 . equals ( entity . VAR_1 ( ) ) ) { model . VAR_2 ( TYPE_4 . create ( TYPE_7 . VAR_4 ) ) ; } else { model . VAR_2 ( null ) ; } <START> return model ; <END> } 
protected File METHOD_1 ( final TYPE_1 request , TYPE_2 VAR_1 ) { File file = TYPE_3 . METHOD_2 ( request . VAR_2 ( ) , VAR_3 ) ; <START> if ( null != file && ! TYPE_3 . METHOD_3 ( file ) ) { <END> file = TYPE_3 . METHOD_2 ( METHOD_4 ( request . VAR_2 ( ) , VAR_1 ) , VAR_3 ) ; } return file ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 request ) { String VAR_1 = METHOD_2 ( request ) ; <START> if ( null == VAR_1 ) { <END> VAR_1 = METHOD_3 ( request . VAR_2 ( ) ) ; } TYPE_1 VAR_3 = TYPE_3 . METHOD_4 ( VAR_1 , true ) ; return VAR_3 ; } 
protected void METHOD_1 ( TYPE_1 request , TYPE_2 response ) throws TYPE_3 , IOException { File file = TYPE_4 . METHOD_2 ( request . VAR_1 ( ) , VAR_2 ) ; file = METHOD_3 ( request , response , file , request . VAR_1 ( ) ) ; <START> if ( null == file ) { <END> response . VAR_3 ( TYPE_2 . VAR_4 ) ; } else { TYPE_4 . METHOD_4 ( request , response , file , type ) ; } } 
private List < String > METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) { <START> return Collections . VAR_2 ( ) ; <END> } return Arrays . asList ( StringUtils . split ( VAR_1 , VAR_3 ) ) ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> when ( METHOD_2 ( ) . METHOD_3 ( ) ) . METHOD_4 ( VAR_1 ) ; <END> when ( VAR_1 . METHOD_5 ( ) ) . METHOD_4 ( VAR_2 ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , Guid VAR_2 , int type ) { TYPE_2 VAR_3 = TYPE_3 . getInstance ( ) . METHOD_2 ( ) . get ( VAR_2 ) ; if ( VAR_3 . METHOD_3 ( ) != null ) { return METHOD_4 ( VAR_1 , VAR_3 . METHOD_3 ( ) . getValue ( ) , type ) ; <START> } else { <END> log . VAR_4 ( STRING_1 , VAR_3 . METHOD_5 ( ) ) ; return false ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 vm = super . METHOD_1 ( ) ; if ( vm != null ) { return vm ; } <START> vm = METHOD_2 ( ) . get ( getParameters ( ) . METHOD_3 ( ) ) ; <END> if ( vm != null ) { METHOD_4 ( vm ) ; METHOD_5 ( vm . getId ( ) ) ; } return vm ; } 
private boolean METHOD_1 ( TYPE_1 vm ) { <START> return vm != null && vm . getStatus ( ) == TYPE_4 . TYPE_3 && <END> vm . VAR_3 ( ) != null && ! vm . VAR_3 ( ) . equals ( Guid . TYPE_2 ) ; } 
private boolean METHOD_1 ( TYPE_1 vm ) { <START> return vm != null && vm . getStatus ( ) == TYPE_3 . TYPE_2 ; <END> } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; for ( Guid VAR_2 : VAR_3 . keySet ( ) ) { <START> List < TYPE_2 > VAR_4 = VAR_3 . get ( VAR_2 ) ; <END> TYPE_1 VAR_5 = new TYPE_1 ( VAR_4 , VAR_2 ) ; VAR_5 . METHOD_2 ( TYPE_4 . TYPE_3 ) ; VAR_5 . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) ) ; VAR_1 . add ( VAR_5 ) ; } return VAR_1 ; } 
<START> public synchronized void METHOD_1 ( Guid VAR_1 , List < Guid > VAR_2 ) { <END> VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) ; try { if ( ! VAR_4 . containsKey ( VAR_1 ) ) { return ; } synchronized ( VAR_4 . get ( VAR_1 ) ) { Map < Guid , TYPE_1 > map = VAR_4 . get ( VAR_1 ) ; for ( Guid VAR_5 : VAR_2 ) { map . remove ( VAR_5 ) ; } } } finally { VAR_3 . METHOD_2 ( ) . METHOD_4 ( ) ; } } 
private boolean METHOD_1 ( TYPE_1 vm ) { <START> boolean VAR_1 = true ; <END> if ( ! METHOD_2 ( ) && ! TYPE_2 . METHOD_3 ( vm ) ) { METHOD_4 ( TYPE_3 . VAR_3 ) ; VAR_1 = false ; } return VAR_1 ; } 
<START> private Guid METHOD_1 ( ) { <END> TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . values ( ) . iterator ( ) . next ( ) ; if ( VAR_1 . METHOD_4 ( ) == TYPE_4 . VAR_3 ) { return ( ( TYPE_2 ) VAR_1 ) . METHOD_5 ( ) . get ( 0 ) ; } else { return Guid . TYPE_3 ; } } 
private void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; METHOD_3 ( ) . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ; <START> return ; <END> } 
protected boolean METHOD_1 ( ) { if ( METHOD_2 ( ) == null ) { return METHOD_3 ( TYPE_1 . VAR_2 ) ; } if ( METHOD_2 ( ) . METHOD_4 ( ) ) { return METHOD_3 ( TYPE_1 . VAR_3 ) ; } if ( ! ( super . METHOD_1 ( ) && METHOD_5 ( ) ) ) { return false ; } <START> return true ; <END> } 
private void METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) ) ; <END> if ( VAR_1 . size ( ) > 0 ) { METHOD_2 ( ) . METHOD_5 ( METHOD_4 ( ) ) ; } } 
public static < TYPE_1 > TYPE_2 < TYPE_1 > METHOD_1 ( ) { <START> TYPE_2 < TYPE_1 > VAR_1 = new TYPE_2 < TYPE_1 > ( VAR_2 ) ; <END> return VAR_1 ; } 
private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> return TYPE_2 . METHOD_2 ( VAR_1 , new TYPE_3 < TYPE_1 > ( ) { <END> @Override public boolean METHOD_3 ( TYPE_1 VAR_2 ) { return VAR_2 . METHOD_4 ( ) . equals ( METHOD_5 ( ) ) ; } } ) ; } 
private void METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( ) == TYPE_3 . TYPE_2 ) { VAR_3 . METHOD_3 ( false ) ; VAR_4 . METHOD_3 ( false ) ; <START> VAR_5 . METHOD_3 ( true ) ; <END> VAR_6 . METHOD_4 ( VAR_7 . METHOD_5 ( ) ) ; } } 
public boolean METHOD_1 ( ) { <START> return this . VAR_1 > 0 ; <END> } 
public void METHOD_1 ( ) { List < Guid > VAR_1 = new ArrayList < Guid > ( ) ; VAR_1 . add ( VAR_2 ) ; VAR_1 . add ( VAR_3 ) ; VAR_4 . METHOD_2 ( VAR_1 ) ; List < TYPE_1 > VAR_5 = VAR_4 . METHOD_3 ( VAR_6 ) ; <START> assertNotNull ( VAR_5 ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( TYPE_3 . VAR_3 , null , TYPE_2 . VAR_5 ) ; <END> TYPE_1 VAR_6 = VAR_1 . METHOD_3 ( TYPE_3 . VAR_3 ) ; assertNotNull ( VAR_6 ) ; assertEquals ( TYPE_2 . VAR_5 , VAR_6 . getStatus ( ) ) ; } 
public TYPE_1 METHOD_1 ( ) { List < TYPE_2 > VAR_1 = new ArrayList < TYPE_2 > ( ) ; for ( TYPE_2 VAR_2 : METHOD_2 ( ) . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ) { <START> for ( TYPE_3 VAR_4 : METHOD_5 ( ) . METHOD_6 ( VAR_3 . METHOD_4 ( ) ) ) { <END> if ( VAR_4 . METHOD_7 ( ) == VAR_5 . getName ( ) ) { VAR_1 . add ( VAR_2 ) ; } } } return METHOD_8 ( VAR_1 , TYPE_4 . VAR_7 ) ; } 
private void METHOD_1 ( String VAR_1 ) { if ( VAR_2 . containsKey ( VAR_1 ) ) { METHOD_2 ( VAR_2 , VAR_1 ) ; <START> VAR_3 . add ( VAR_1 ) ; <END> } else if ( VAR_4 . containsKey ( VAR_1 ) ) { METHOD_2 ( VAR_4 , VAR_1 ) ; } } 
private boolean METHOD_1 ( Map < String , Integer > VAR_1 , String VAR_2 ) { <START> boolean VAR_3 = false ; <END> if ( ! VAR_1 . containsKey ( VAR_2 ) ) { VAR_1 . put ( VAR_2 , 1 ) ; VAR_3 = true ; } else if ( METHOD_2 ( ) ) { METHOD_3 ( VAR_1 , VAR_2 ) ; VAR_3 = true ; } return VAR_3 ; } 
public static void METHOD_1 ( ) { log . info ( STRING_1 ) ; VAR_1 . clear ( ) ; for ( TYPE_1 VAR_2 : TYPE_4 < HashSet < TYPE_1 > > METHOD_2 ( TYPE_5 . TYPE_6 ) ) { VAR_1 . put ( VAR_2 , new TYPE_2 ( VAR_2 ) ) ; } <START> log . info ( STRING_2 + TYPE_3 . class . METHOD_3 ( ) ) ; <END> } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) , TYPE_1 . VAR_2 ) ; <END> } 
protected Map < String , String > METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) && ! METHOD_4 ( ) ) { return Collections . VAR_1 ( METHOD_5 ( ) . toString ( ) , TYPE_2 . TYPE_3 . name ( ) ) ; <START> } <END> return super . METHOD_1 ( ) ; } 
<START> public Map < String , String > METHOD_1 ( ) { <END> if ( VAR_1 != null ) { if ( VAR_2 == null ) { VAR_2 = super . METHOD_1 ( ) ; } VAR_2 . put ( TYPE_1 . VAR_4 , VAR_1 . getName ( ) ) ; } return VAR_2 ; } 
protected List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ; <START> if ( VAR_1 == null ) { <END> VAR_1 = TYPE_2 < TYPE_1 > METHOD_6 ( ) ; } } return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { <START> assertEquals ( TYPE_2 . TYPE_3 . getMessage ( ) , VAR_1 . METHOD_1 ( ) . getMessage ( ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( null ) . when ( VAR_1 ) . METHOD_3 ( ) ; <END> assertEquals ( new TYPE_1 ( TYPE_2 . VAR_3 ) . getMessage ( ) , VAR_1 . METHOD_4 ( ) . getMessage ( ) ) ; } 
public TYPE_9 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_2 ) { super ( VAR_2 ) ; VAR_3 = new TYPE_4 ( ) ; METHOD_1 ( TYPE_7 . VAR_5 . METHOD_2 ( this ) ) ; <START> TYPE_8 . VAR_7 . METHOD_3 ( this ) ; <END> VAR_8 = new TYPE_5 ( VAR_3 , 1 , 1 ) ; VAR_8 . METHOD_4 ( new TYPE_6 ( VAR_9 . METHOD_5 ( ) , name , 0 , 0 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 . VAR_3 . METHOD_2 ( METHOD_3 ( ) ) ; <END> VAR_4 . update ( METHOD_3 ( ) ) ; } 
public static synchronized void METHOD_1 ( TYPE_1 value ) { <START> if ( ! VAR_1 . containsKey ( value . VAR_2 ( ) ) ) <END> VAR_1 . METHOD_2 ( value . VAR_2 ( ) , value ) ; } 
<START> public static synchronized void METHOD_1 ( String key ) { <END> if ( key != null ) { VAR_1 . remove ( key ) ; } } 
public static TYPE_1 METHOD_1 ( String key ) { TYPE_1 value = VAR_1 . get ( key ) ; <START> return value ; <END> } 
public static synchronized void METHOD_1 ( String key ) { if ( VAR_1 . containsKey ( key ) ) { VAR_1 . remove ( key ) ; <START> } <END> } 
protected boolean METHOD_1 ( ) { boolean VAR_1 = super . METHOD_1 ( ) ; if ( VAR_1 && ( getParameters ( ) . METHOD_2 ( ) == null ^ getParameters ( ) . METHOD_3 ( ) == null ) ) { METHOD_4 ( TYPE_1 . VAR_3 ) ; VAR_1 = false ; } <START> if ( getParameters ( ) . METHOD_5 ( ) != null && ! METHOD_6 ( ) . METHOD_7 ( ) ) { <END> METHOD_4 ( TYPE_1 . VAR_4 ) ; VAR_1 = false ; } return VAR_1 ; } 
public final static String METHOD_1 ( String source , String VAR_1 , String VAR_2 , String VAR_3 ) throws Exception { try { String result = "" ; <START> if ( ! TYPE_1 . METHOD_2 ( source . trim ( ) ) ) { <END> TYPE_2 VAR_4 = TYPE_3 . METHOD_3 ( VAR_1 , VAR_2 , VAR_5 ) ; result = METHOD_1 ( source , VAR_4 . METHOD_4 ( VAR_3 ) ) ; } return result ; } catch ( Exception e ) { log . error ( STRING_1 , e ) ; throw e ; } } 
public String getMessage ( ) { <START> return ( STRING_1 . equalsIgnoreCase ( VAR_1 . METHOD_1 ( ) ) ) ? "" : VAR_1 ; <END> } 
protected void METHOD_1 ( ) { final TYPE_1 VAR_1 = getParameters ( ) . METHOD_2 ( ) ; <START> if ( VAR_1 != null ) { <END> METHOD_3 ( VAR_1 , METHOD_4 ( ) ) ; METHOD_5 ( ) . METHOD_6 ( VAR_1 . getId ( ) ) ; METHOD_5 ( ) . METHOD_7 ( true ) ; } } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return TYPE_3 < String > METHOD_2 ( TYPE_4 . TYPE_2 ) . equalsIgnoreCase ( VAR_1 . getName ( ) ) ; <END> } 
<START> protected TYPE_1 METHOD_1 ( int VAR_1 , Guid VAR_2 ) { <END> TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_2 ( TYPE_2 . TYPE_3 ) ; VAR_3 . METHOD_3 ( TYPE_5 . TYPE_4 ) ; VAR_3 . METHOD_4 ( VAR_1 ) ; VAR_3 . METHOD_5 ( VAR_8 ) ; VAR_3 . METHOD_6 ( VAR_2 ) ; return VAR_3 ; } 
public TYPE_1 list ( ) { if ( METHOD_1 ( ) ) { <START> throw new TYPE_2 ( Response . Status . VAR_1 ) ; <END> } TYPE_3 VAR_2 = METHOD_2 ( ) . get ( TYPE_3 . class ) ; if ( VAR_2 == TYPE_3 . TYPE_4 ) { return METHOD_3 ( ) ; } else { return METHOD_4 ( ) ; } } 
private static int METHOD_1 ( String VAR_1 , String VAR_2 ) { int VAR_3 = ( ( Integer ) Integer . parseInt ( VAR_1 ) ) . METHOD_2 ( Integer . parseInt ( VAR_2 ) ) ; <START> return VAR_3 != 0 ? VAR_3 : METHOD_3 ( VAR_1 , VAR_2 ) ; <END> } 
private boolean METHOD_1 ( ) { TYPE_1 vm = METHOD_2 ( ) ; Guid VAR_1 = METHOD_3 ( ) ; VAR_2 = vm . VAR_3 ( ) . size ( ) > 0 ; if ( getParameters ( ) . METHOD_4 ( ) && VAR_2 ) { if ( ! METHOD_5 ( null ) ) { return false ; <START> } else if ( METHOD_6 ( ) . METHOD_7 ( ) . isEmpty ( ) ) { <END> METHOD_8 ( ) ; } } else { METHOD_8 ( ) ; } return true ; } 
private boolean METHOD_1 ( Guid VAR_1 , Guid VAR_2 ) { TYPE_1 VAR_3 = METHOD_2 ( VAR_1 ) ; <START> Guid VAR_4 = VAR_3 . METHOD_3 ( ) . getValue ( ) ; <END> TYPE_2 VAR_5 = METHOD_4 ( VAR_2 , VAR_4 ) ; return METHOD_5 ( VAR_5 . METHOD_6 ( ) ) && METHOD_5 ( VAR_5 . METHOD_7 ( ) ) ; } 
public TYPE_4 ( Map < TYPE_1 , Object > VAR_2 ) { <START> this ( VAR_2 , new TYPE_2 < TYPE_3 , Object > ( TYPE_3 . class ) ) ; ; <END> } 
<START> boolean METHOD_1 ( ) { <END> if ( METHOD_2 ( ) == null ) { return METHOD_3 ( TYPE_1 . VAR_2 ) ; } return true ; } 
<START> boolean METHOD_1 ( ) { <END> return METHOD_2 ( ) . METHOD_3 ( ) && getParameters ( ) . METHOD_4 ( ) ; } 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . get ( getParameters ( ) . METHOD_4 ( ) . getId ( ) ) ; <END> } return VAR_1 ; } 
public String getValue ( ) { final StringBuilder val = new StringBuilder ( ) ; if ( this . VAR_1 > - 1 ) <START> val . append ( this . VAR_1 ) ; <END> METHOD_1 ( val , this . VAR_2 ) ; METHOD_1 ( val , this . build ) ; METHOD_1 ( val , this . VAR_3 ) ; return val . toString ( ) ; } 
<START> static void METHOD_1 ( StringBuilder val , int VAR_1 ) { <END> if ( VAR_1 > - 1 ) { if ( val . length ( ) != 0 ) { val . append ( STRING_1 ) ; } val . append ( VAR_1 ) ; } } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 parameters ) <END> throws TYPE_4 { TYPE_1 VAR_2 = METHOD_2 ( ) . METHOD_3 ( VAR_1 , parameters ) ; if ( ! VAR_2 . METHOD_4 ( ) ) { throw new TYPE_4 ( VAR_2 . METHOD_5 ( ) . METHOD_6 ( ) , VAR_2 . METHOD_5 ( ) . getMessage ( ) ) ; } return VAR_2 ; } 
protected void METHOD_1 ( ) { <START> ArrayList < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( VAR_2 . METHOD_2 ( ) ) ; <END> VAR_1 . addAll ( VAR_2 . METHOD_3 ( ) . values ( ) ) ; TYPE_2 . METHOD_1 ( METHOD_4 ( ) , METHOD_5 ( ) , VAR_2 , VAR_2 . METHOD_6 ( ) , true , VAR_1 , VAR_3 , VAR_4 ) ; } 
public TYPE_7 ( TYPE_1 VAR_2 ) { <START> VAR_3 = new TYPE_2 < TYPE_3 > ( ) ; <END> METHOD_1 ( TYPE_4 . VAR_5 . METHOD_2 ( this ) ) ; TYPE_6 . VAR_7 . METHOD_3 ( this ) ; TYPE_5 . VAR_9 . METHOD_4 ( this ) ; } 
public String toString ( ) { StringBuilder builder = new StringBuilder ( INT_1 ) ; builder . append ( STRING_1 ) ; builder . append ( METHOD_1 ( ) ) ; builder . append ( STRING_2 ) ; <START> builder . append ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> builder . append ( STRING_3 ) ; builder . append ( METHOD_4 ( ) ) ; return builder . toString ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 params ) { if ( log . VAR_2 ( ) ) { StringBuilder builder = new StringBuilder ( INT_1 ) ; builder . append ( STRING_1 ) ; builder . append ( VAR_1 ) ; builder . append ( STRING_2 ) ; <START> builder . append ( params ) ; <END> } } 
private Guid METHOD_1 ( TYPE_1 VAR_1 ) { if ( getParameters ( ) . METHOD_2 ( ) != null && getParameters ( ) . METHOD_2 ( ) . get ( VAR_1 . getId ( ) ) != null ) { return getParameters ( ) . METHOD_2 ( ) . get ( VAR_1 . getId ( ) ) . METHOD_3 ( ) ; <START> } else { <END> return VAR_1 . METHOD_3 ( ) ; } } 
private TYPE_1 METHOD_1 ( final TYPE_2 [ ] VAR_1 ) { TYPE_1 VAR_2 = null ; <START> if ( null != VAR_1 ) { <END> for ( TYPE_2 VAR_3 : VAR_1 ) { if ( TYPE_3 . equalsIgnoreCase ( VAR_3 . getName ( ) ) ) { VAR_2 = TYPE_4 . METHOD_2 ( VAR_3 . getValue ( ) ) ; break ; } } } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 value ) { <START> for ( Object VAR_1 : METHOD_2 ( ) . METHOD_3 ( ) ) { <END> if ( ( ( TYPE_2 ) VAR_1 ) . METHOD_4 ( ) == value ) { METHOD_2 ( ) . METHOD_5 ( VAR_1 ) ; break ; } } } 
public static void METHOD_1 ( TYPE_1 VAR_1 , Guid id ) { VAR_1 . VAR_2 = new TYPE_2 ( ) { @Override public Object METHOD_2 ( Object source , TYPE_1 VAR_3 ) <START> { <END> ArrayList < TYPE_3 > VAR_4 = ( ArrayList < TYPE_3 > ) source ; return VAR_4 ; } } ; TYPE_4 . METHOD_3 ( TYPE_7 . TYPE_6 , new TYPE_5 ( id ) , VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! TYPE_3 < String > METHOD_2 ( TYPE_4 . TYPE_2 ) . equals ( VAR_1 . METHOD_3 ( ) ) ) { <END> return true ; } if ( VAR_1 . METHOD_4 ( ) == TYPE_5 . VAR_6 && vds . VAR_7 ( ) . METHOD_5 ( TYPE_6 . VAR_9 ) ) { return StringUtils . equals ( vds . VAR_7 ( ) , VAR_1 . METHOD_6 ( ) ) ; } return true ; } 
protected Guid METHOD_1 ( ) { if ( VAR_1 == null ) { <START> return super . METHOD_1 ( VAR_2 ) ; <END> } TYPE_1 VAR_3 = METHOD_2 ( ) . get ( VAR_1 . METHOD_3 ( ) ) ; if ( VAR_3 . getStatus ( ) == TYPE_2 . TYPE_3 ) { return VAR_3 . getId ( ) ; } return super . METHOD_1 ( VAR_2 ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( TYPE_4 . TYPE_5 , new TYPE_3 ( METHOD_3 ( ) , VAR_5 , <START> VAR_1 , <END> VAR_6 . METHOD_4 ( ) , VAR_7 ) ) ; return ( TYPE_1 ) VAR_2 . METHOD_5 ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , Map < String , TYPE_2 > VAR_2 , boolean VAR_3 ) { boolean VAR_4 = true ; if ( ! VAR_1 . METHOD_2 ( ) ) { VAR_4 = false ; } else if ( VAR_3 ) { TYPE_2 VAR_5 = VAR_2 . get ( VAR_1 . METHOD_3 ( ) ) ; <START> VAR_4 = VAR_5 . METHOD_4 ( ) . METHOD_5 ( ) && VAR_5 . METHOD_6 ( ) ; <END> } return VAR_4 ; } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; <START> VAR_2 . addAll ( METHOD_1 ( ) . METHOD_2 ( METHOD_3 ( ) ) ) ; <END> } 
protected boolean METHOD_1 ( ) { if ( ! super . METHOD_1 ( ) ) { return false ; } List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) , TYPE_3 . TYPE_4 . getName ( ) ) ; if ( VAR_1 . isEmpty ( ) ) { return METHOD_5 ( TYPE_5 . VAR_3 ) ; } <START> return super . METHOD_1 ( ) ; <END> } 
protected void METHOD_1 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
protected void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; TYPE_1 VAR_2 = VAR_1 . get ( 0 ) ; VAR_2 . METHOD_3 ( METHOD_4 ( ) ) ; METHOD_5 ( ) . update ( VAR_2 ) ; <START> METHOD_6 ( VAR_2 ) ; <END> METHOD_7 ( true ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 model , TYPE_2 entity ) { model . VAR_1 ( entity . VAR_2 ( ) == null ? null : entity . VAR_2 ( ) . name ( ) ) ; model . VAR_3 ( entity . VAR_4 ( ) == null ? null : entity . VAR_4 ( ) . name ( ) ) ; model . VAR_5 ( entity . getId ( ) . toString ( ) ) ; <START> return model ; <END> } 
protected < T > boolean METHOD_1 ( TYPE_1 entity , T id ) { <START> return true ; <END> } 
private TYPE_4 ( ) { VAR_2 = TYPE_5 < TYPE_1 , TYPE_2 > METHOD_1 ( VAR_4 ) ; <START> VAR_5 = TYPE_5 < TYPE_1 , TYPE_3 > METHOD_1 ( VAR_6 ) ; <END> } 
private String METHOD_1 ( final String path ) { String result = null ; if ( TYPE_1 . METHOD_2 ( path ) ) { List < TYPE_2 > VAR_1 = VAR_2 . METHOD_3 ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { <START> if ( path . startsWith ( VAR_3 . getPath ( ) ) ) { <END> result = VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) + path ; } } } else { log . error ( STRING_1 + path + STRING_2 ) ; } return result ; } 
<START> protected TYPE_1 METHOD_1 ( final TYPE_2 request ) <END> throws TYPE_3 { TYPE_1 VAR_1 = METHOD_2 ( ) ; for ( TYPE_4 VAR_2 : TYPE_4 . values ( ) ) { if ( request . VAR_3 ( VAR_2 . METHOD_3 ( ) ) != null ) { VAR_1 . update ( request . VAR_3 ( VAR_2 . METHOD_3 ( ) ) . toString ( ) . METHOD_4 ( ) ) ; } } return VAR_1 ; } 
public TYPE_1 ( final File VAR_2 ) { <START> VAR_3 = new File ( VAR_2 + VAR_4 ) ; <END> } 
public TYPE_2 ( String VAR_2 , TYPE_1 context ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . context = context ; } 
protected boolean METHOD_1 ( ) { return METHOD_2 ( ) != null && <START> METHOD_3 ( new TYPE_1 ( METHOD_4 ( ) ) . METHOD_5 ( ) ) ; <END> } 
protected boolean METHOD_1 ( ) { VAR_1 = METHOD_2 ( ) . get ( getParameters ( ) . METHOD_3 ( ) ) ; return METHOD_4 ( ) && METHOD_5 ( ) && METHOD_6 ( VAR_1 ) && METHOD_7 ( ) && METHOD_8 ( ) && <START> METHOD_9 ( ) ; <END> } 
protected TYPE_1 METHOD_1 ( Guid TYPE_4 ) { <START> TYPE_2 VAR_2 = TYPE_3 . getInstance ( ) . METHOD_2 ( ) . get ( TYPE_4 ) ; <END> if ( VAR_2 != null ) { return VAR_2 . METHOD_3 ( ) ; } else { log . VAR_3 ( STRING_1 , getParameters ( ) . METHOD_4 ( ) ) ; return null ; } } 
public void METHOD_1 ( final TYPE_1 object ) { super . METHOD_1 ( object ) ; info . VAR_1 ( false ) ; message . VAR_1 ( false ) ; <START> VAR_2 . METHOD_2 ( false ) ; <END> VAR_3 . METHOD_2 ( false ) ; VAR_4 . remove ( VAR_5 ) ; VAR_4 . METHOD_3 ( VAR_6 , INT_1 ) ; METHOD_4 ( ) . METHOD_5 ( INT_2 , INT_2 ) ; } 
private void METHOD_1 ( TYPE_1 < ? > entity ) { if ( entity == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> Class < ? extends TYPE_1 > VAR_1 = entity . getClass ( ) ; <END> if ( TYPE_2 . getInstance ( ) . METHOD_2 ( ( Class < TYPE_1 < TYPE_3 > > ) VAR_1 ) == null ) { throw new IllegalArgumentException ( STRING_2 + VAR_1 . getName ( ) ) ; } } 
public Object METHOD_1 ( Object ctx ) { if ( ctx == null ) { return null ; } TYPE_1 VAR_1 = ( TYPE_1 ) ctx ; TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 == null ) { return null ; } try { return VAR_2 . get ( STRING_1 ) . get ( 0 ) ; } catch ( TYPE_3 e ) { <START> System . err . println ( VAR_3 + STRING_2 ) ; <END> return null ; } } 
public void METHOD_1 ( Integer value ) { <START> value = ( value == null ) ? new Integer ( 0 ) : value ; <END> if ( ! VAR_1 . equals ( value ) ) { VAR_1 = value ; } } 
private static Double METHOD_1 ( TYPE_1 input , String name ) { Double VAR_1 = METHOD_2 ( input , name ) ; <START> return ( VAR_1 == null ? new Double ( FLOAT_1 ) : VAR_1 ) ; <END> } 
public TYPE_1 ( Guid VAR_2 ) { <START> this ( ) ; <END> this . VAR_2 = VAR_2 ; } 
public Guid METHOD_1 ( TYPE_1 VAR_1 ) { Guid VAR_2 = Guid . TYPE_5 ; try { TYPE_2 task = METHOD_2 ( new TYPE_3 ( ) , VAR_1 ) ; VAR_2 = task . VAR_4 ( ) ; TYPE_4 . METHOD_3 ( task , null , VAR_5 ) ; } catch ( RuntimeException ex ) { <START> log . VAR_6 ( STRING_1 , this . getClass ( ) . getName ( ) , ex ) ; <END> } return VAR_2 ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; <START> if ( ( TYPE_1 ) METHOD_6 ( ) . METHOD_7 ( ) . METHOD_8 ( ) != null ) { <END> TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_6 ( ) . METHOD_7 ( ) . METHOD_8 ( ) ; METHOD_9 ( VAR_1 . METHOD_10 ( ) , VAR_1 . METHOD_11 ( ) ) ; } METHOD_12 ( ) ; } 
protected void METHOD_1 ( ) { <START> status = METHOD_2 ( ) . METHOD_3 ( VAR_1 . toString ( ) , ( Boolean . valueOf ( VAR_2 ) ) . toString ( ) ) ; <END> METHOD_4 ( ) ; } 
protected void METHOD_1 ( ) { if ( getParameters ( ) . METHOD_2 ( ) ) { status = METHOD_3 ( ) . METHOD_4 ( getParameters ( ) . METHOD_5 ( ) . toString ( ) , <START> ( Integer . valueOf ( getParameters ( ) . METHOD_6 ( ) ) ) . toString ( ) , <END> TYPE_1 < String > METHOD_7 ( TYPE_2 . TYPE_3 ) ) ; } else { status = METHOD_3 ( ) . METHOD_8 ( getParameters ( ) . METHOD_5 ( ) . toString ( ) ) ; } METHOD_9 ( ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , Map < String , Object > VAR_2 ) { <START> String s = Integer . valueOf ( VAR_1 . METHOD_2 ( ) ) . toString ( ) ; <END> if ( ! org . VAR_3 . VAR_4 . VAR_5 . StringUtils . isEmpty ( s ) && ! s . equals ( STRING_1 ) ) { VAR_2 . put ( TYPE_3 . TYPE_2 , s ) ; } } 
public void METHOD_1 ( String value ) { <START> if ( ! VAR_1 . equals ( value ) ) <END> { VAR_1 = value ; METHOD_2 ( new TYPE_1 ( STRING_1 ) ) ; } } 
private boolean METHOD_1 ( TYPE_1 model ) { <START> return ! ( model . VAR_1 ( ) != null && ! model . VAR_1 ( ) . equals ( "" ) ) ; <END> } 
private void METHOD_1 ( Exception e , TYPE_1 status ) { log . VAR_1 ( STRING_1 , METHOD_2 ( ) . getId ( ) , METHOD_2 ( ) . getName ( ) , e ) ; METHOD_3 ( status ) ; METHOD_4 ( false ) ; VAR_2 = METHOD_5 ( e . getMessage ( ) ) ; <START> METHOD_6 ( STRING_2 , VAR_2 ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
public static String METHOD_1 ( String VAR_1 , List < TYPE_1 > params ) { <START> StringBuilder VAR_2 = new StringBuilder ( "" ) ; <END> if ( params != null ) { for ( TYPE_1 VAR_3 : params ) { for ( TYPE_2 VAR_4 : VAR_3 . getParameters ( ) ) { VAR_2 . append ( String . format ( VAR_5 , VAR_4 . getName ( ) , VAR_4 . getValue ( ) ) ) ; } } } VAR_2 . METHOD_2 ( 0 , VAR_1 ) ; return VAR_2 . toString ( ) ; } 
String METHOD_1 ( ) { StringBuilder VAR_1 = new StringBuilder ( VAR_2 . empty ( ) ) ; for ( int i = 0 ; i < VAR_3 . size ( ) ; i ++ ) { String VAR_4 = VAR_3 . get ( i ) ; VAR_1 . append ( VAR_2 . METHOD_2 ( ) ) ; VAR_1 . append ( VAR_2 . METHOD_3 ( ) ) ; <START> VAR_1 . append ( VAR_4 ) ; <END> } return VAR_1 . toString ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> StringBuilder VAR_1 = new StringBuilder ( "" ) ; <END> for ( TYPE_2 a : METHOD_2 ( ) ) { if ( a . VAR_2 ( ) ) { TYPE_1 VAR_3 = ( TYPE_1 ) a . VAR_4 ( ) ; VAR_1 . append ( VAR_3 . toString ( ) ) ; } } return ! VAR_1 . equals ( "" ) ? TYPE_1 . valueOf ( VAR_1 . toString ( ) ) : null ; } 
private void METHOD_1 ( ) { for ( Guid VAR_1 : METHOD_2 ( ) . METHOD_3 ( ) ) { <START> TYPE_1 task = TYPE_2 . getInstance ( ) . METHOD_4 ( ) . get ( VAR_1 ) ; <END> if ( task . VAR_2 ( ) . equals ( TYPE_5 . TYPE_4 ) ) { TYPE_3 . METHOD_5 ( task ) ; } } } 
public TYPE_1 ( final int VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; } 
protected void METHOD_1 ( ) { Guid VAR_1 = METHOD_2 ( ) . getParameters ( ) . METHOD_3 ( ) ; Guid VAR_2 = METHOD_2 ( ) . getParameters ( ) . METHOD_4 ( ) ; TYPE_1 VAR_3 = METHOD_5 ( ) . get ( VAR_2 ) ; <START> if ( VAR_3 != null && VAR_3 . METHOD_6 ( ) . get ( 0 ) == VAR_1 ) { <END> METHOD_2 ( ) . getParameters ( ) . METHOD_7 ( 0 ) ; } } 
public TYPE_1 METHOD_1 ( ) { StringBuilder VAR_1 = new StringBuilder ( ) ; for ( TYPE_2 a : METHOD_2 ( ) ) { if ( a . VAR_2 ( ) ) { TYPE_1 VAR_3 = ( TYPE_1 ) a . VAR_4 ( ) ; VAR_1 . append ( VAR_3 . toString ( ) ) ; } } String VAR_5 = VAR_1 . toString ( ) ; if ( ! VAR_5 . equals ( "" ) ) { return TYPE_1 . valueOf ( VAR_5 ) ; } <START> return null ; <END> } 
public TYPE_1 METHOD_1 ( ) { return METHOD_2 ( ) ? ( VAR_1 . isEmpty ( ) ? TYPE_1 . VAR_2 : TYPE_1 . VAR_3 ) <START> : TYPE_1 . VAR_4 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 vds = new TYPE_1 ( ) ; vds . VAR_1 ( Guid . TYPE_4 ) ; vds . VAR_3 ( INT_1 ) ; TYPE_2 host = TYPE_3 . map ( vds , ( TYPE_2 ) null ) ; assertNotNull ( host . VAR_4 ( ) ) ; <START> assertEquals ( host . VAR_4 ( ) . METHOD_2 ( ) , INT_2 ) ; <END> } 
protected void METHOD_1 ( ArrayList < TYPE_1 > VAR_1 , TYPE_2 vds ) { <START> if ( VAR_1 != null && vds . VAR_2 ( ) != null ) <END> { METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; METHOD_2 ( ) . METHOD_4 ( TYPE_3 . METHOD_5 ( VAR_1 , new TYPE_3 . TYPE_5 ( vds . VAR_2 ( ) ) ) ) ; if ( METHOD_2 ( ) . METHOD_6 ( ) == null ) { METHOD_2 ( ) . METHOD_4 ( TYPE_3 . METHOD_5 ( VAR_1 ) ) ; } } } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; boolean VAR_2 = true ; if ( VAR_1 . METHOD_3 ( ) ) { <START> METHOD_4 ( METHOD_5 ( ) ) ; <END> } if ( VAR_1 . METHOD_6 ( ) ) { VAR_2 = METHOD_7 ( ) ; } if ( VAR_2 && VAR_1 . METHOD_8 ( ) ) { VAR_2 = METHOD_9 ( ) ; } METHOD_4 ( VAR_2 ) ; } 
public TYPE_1 ( String [ ] VAR_2 ) { if ( VAR_2 == null ) { this . VAR_2 . add ( new String ( ) ) ; <START> } else for ( String VAR_3 : VAR_2 ) { <END> this . VAR_2 . add ( VAR_3 . METHOD_1 ( ) ) ; } } 
private String METHOD_1 ( ) { <START> if ( METHOD_2 ( ) != null ) { <END> return new StringBuilder ( TYPE_3 . TYPE_4 . name ( ) ) . append ( String . format ( STRING_1 , METHOD_2 ( ) . getName ( ) ) ) . toString ( ) ; } return TYPE_3 . TYPE_5 . name ( ) ; } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 TYPE_3 ) { <END> boolean result = false ; TYPE_1 VAR_3 = new TYPE_1 ( TYPE_3 . VAR_4 ) ; if ( VAR_1 . METHOD_2 ( VAR_3 ) > 0 ) { result = true ; } return result ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 vds = METHOD_2 ( getParameters ( ) . METHOD_3 ( ) ) ; TYPE_1 VAR_2 = vds . VAR_3 ( ) ; log . VAR_4 ( STRING_1 , VAR_2 . toString ( ) , <START> VAR_1 . toString ( ) <END> ) ; return ( VAR_2 . METHOD_4 ( ) == VAR_1 . METHOD_4 ( ) && VAR_2 . METHOD_5 ( ) <= VAR_1 . METHOD_5 ( ) ) ; } 
public static synchronized TYPE_1 getInstance ( ) { if ( instance == null ) { <START> instance = new TYPE_1 ( ) ; <END> } return instance ; } 
<START> private TYPE_1 METHOD_1 ( TYPE_2 info ) { <END> log . VAR_1 ( STRING_1 , info . VAR_2 ) ; String VAR_3 = info . VAR_2 ; if ( VAR_4 == null || ! VAR_3 . equals ( VAR_4 . toString ( ) ) ) { VAR_4 = TYPE_1 . METHOD_2 ( VAR_3 ) ; } return VAR_4 ; } 
public static TYPE_1 getInstance ( ) { <START> if ( VAR_1 == null ) { <END> synchronized ( TYPE_1 . class ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; } } } return VAR_1 ; } 
protected void METHOD_1 ( ) { if ( ! ( Guid . VAR_1 ( VAR_2 ) ) ) { METHOD_2 ( ) ; } else if ( ! ( Guid . VAR_1 ( VAR_3 ) ) ) { METHOD_3 ( ) ; <START> } <END> } 
public void METHOD_1 ( ) { TYPE_1 params = new TYPE_1 ( ) ; params . VAR_1 ( STRING_1 ) ; cmd = METHOD_2 ( new TYPE_2 ( params ) ) ; METHOD_3 ( cmd . VAR_2 ( ) ) ; params . VAR_3 ( TYPE_3 . VAR_5 ) ; cmd = METHOD_2 ( new TYPE_2 ( params ) ) ; METHOD_3 ( cmd . VAR_2 ( ) ) ; <START> <END> params . VAR_6 ( null ) ; params . VAR_7 ( null ) ; METHOD_3 ( cmd . VAR_2 ( ) ) ; } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; <START> TYPE_1 VAR_1 = METHOD_3 ( ) . METHOD_4 ( <END> TYPE_3 . TYPE_4 , METHOD_5 ( ) , TYPE_2 . METHOD_6 ( METHOD_7 ( ) ) ) ; if ( VAR_1 . METHOD_8 ( ) ) { METHOD_9 ( ) . METHOD_10 ( ) . addAll ( VAR_1 . METHOD_11 ( ) ) ; } else { METHOD_12 ( VAR_1 ) ; METHOD_13 ( ) ; METHOD_9 ( ) . METHOD_14 ( VAR_1 . METHOD_15 ( ) ) ; } METHOD_16 ( VAR_1 . METHOD_8 ( ) ) ; } 
public String [ ] METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return VAR_2 ; } List < String > list = new ArrayList < String > ( ) ; for ( String VAR_3 : TYPE_2 . TYPE_3 . METHOD_2 ( ) . values ( ) ) { if ( VAR_3 . startsWith ( VAR_1 ) ) { list . add ( VAR_3 ) ; } } <START> return list . VAR_4 ( new String [ ] { } ) ; <END> } 
public void METHOD_1 ( final Guid VAR_1 , final List < TYPE_1 > VAR_2 ) { ArrayList < TYPE_2 > parameters = METHOD_2 ( VAR_1 , VAR_2 ) ; <START> if ( parameters . size ( ) == 0 ) { <END> VAR_3 . METHOD_3 ( ) ; return ; } METHOD_4 ( VAR_1 , parameters ) ; } 
private void METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) { return ; } METHOD_3 ( ) ; <START> TYPE_1 . METHOD_4 ( action , new TYPE_2 ( VAR_1 ) , null , true ) ; <END> METHOD_5 ( ) ; } 
protected boolean METHOD_1 ( ) { boolean VAR_1 = true ; <START> if ( getParameters ( ) . METHOD_2 ( ) . trim ( ) . length ( ) == 0 ) { <END> METHOD_3 ( TYPE_1 . VAR_3 ) ; VAR_1 = false ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = ( TYPE_2 ) METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <START> return VAR_1 == null ? TYPE_1 . VAR_2 : TYPE_1 . METHOD_5 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( String VAR_1 , TYPE_1 sb ) throws TYPE_2 , IOException { TYPE_3 VAR_2 = null ; try { VAR_2 = new TYPE_3 ( VAR_1 ) ; VAR_2 . write ( sb . toString ( ) . METHOD_2 ( ) ) ; } finally { if ( VAR_2 != null ) { VAR_2 . close ( ) ; } <START> } <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! TYPE_2 . METHOD_2 ( vds . VAR_2 ( ) ) && ! TYPE_3 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) <START> && StringUtils . VAR_3 ( VAR_1 . METHOD_5 ( ) ) ) { <END> METHOD_6 ( TYPE_4 . VAR_5 , VAR_1 . METHOD_4 ( ) ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 > VAR_2 , List < TYPE_2 > VAR_3 , TYPE_3 VAR_4 ) { int VAR_5 = VAR_4 . METHOD_2 ( ) ; int VAR_6 = VAR_4 . METHOD_3 ( ) ; if ( VAR_2 . size ( ) != VAR_5 * VAR_6 ) { return false ; <START> } <END> return true ; } 
private void METHOD_1 ( TYPE_1 connection , Guid VAR_1 ) { <START> if ( connection . VAR_2 ( ) != null && ! connection . VAR_2 ( ) . equalsIgnoreCase ( "" ) ) { <END> TYPE_2 . METHOD_2 ( TYPE_5 . TYPE_4 , new TYPE_3 ( connection , VAR_1 ) , null , this ) ; } } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; if ( METHOD_1 ( ) != null ) { METHOD_2 ( METHOD_1 ( ) . METHOD_3 ( ) ) ; } if ( METHOD_4 ( ) ) { METHOD_5 ( parameters . VAR_2 ( ) ) ; METHOD_5 ( METHOD_6 ( ) . METHOD_7 ( ) ) ; } <START> if ( parameters . VAR_3 ( ) == null ) { <END> parameters . VAR_4 ( false ) ; } } 
public List < TYPE_1 > METHOD_1 ( Guid VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( ) ; <START> VAR_2 . METHOD_3 ( STRING_1 , VAR_1 ) ; <END> return METHOD_4 ( ) . METHOD_5 ( STRING_2 , TYPE_3 . instance , VAR_2 ) ; } 
<START> public static String getMessage ( final String key ) { <END> return getMessage ( key , TYPE_1 . VAR_2 ) ; } 
public static TYPE_1 getInstance ( final File VAR_1 ) { if ( instance == null ) { instance = new TYPE_1 ( VAR_1 ) ; <START> } <END> return instance ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 vds = null ; try { METHOD_2 ( vds ) ; <START> } catch ( TYPE_3 . TYPE_4 . Exception e ) { <END> log . VAR_1 ( STRING_1 , METHOD_3 ( ) , e . getMessage ( ) ) ; } return vds ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { <START> final TYPE_2 vds = METHOD_2 ( ) ; <END> METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; log . VAR_3 ( VAR_2 + STRING_1 , vds . getName ( ) , vds . VAR_4 ( ) ) ; } 
public static Guid METHOD_1 ( Guid id ) { <START> return id == null ? null : id ; <END> } 
private void METHOD_1 ( TYPE_1 server ) { Map < String , String > VAR_1 = new HashMap < String , String > ( ) ; VAR_1 . put ( TYPE_5 . VAR_3 , STRING_1 ) ; <START> VAR_1 . put ( TYPE_5 . VAR_4 , server . VAR_5 ( ) ) ; <END> TYPE_2 VAR_6 = new TYPE_2 ( server . getId ( ) , TYPE_6 . VAR_8 , VAR_1 ) ; VAR_6 . METHOD_2 ( true ) ; TYPE_3 . getInstance ( ) . METHOD_3 ( TYPE_8 . TYPE_7 , VAR_6 , TYPE_4 . METHOD_4 ( ) ) ; } 
<START> protected static TYPE_1 METHOD_1 ( ) { <END> return TYPE_1 . getInstance ( ) ; } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( ) ; HashMap < Integer , String > VAR_2 = new HashMap < > ( 1 ) ; <START> VAR_2 . put ( 0 , STRING_1 ) ; <END> } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> return TYPE_1 . TYPE_2 ; } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> TYPE_2 parameters = new TYPE_2 ( ) ; parameters . VAR_1 ( METHOD_2 ( ) . getParameters ( ) . METHOD_3 ( ) ) ; parameters . VAR_2 ( METHOD_2 ( ) . getParameters ( ) . METHOD_4 ( ) ) ; parameters . VAR_3 ( METHOD_2 ( ) . getParameters ( ) . METHOD_5 ( ) ) ; return parameters ; } 
public boolean METHOD_1 ( ArrayList < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) { boolean VAR_3 = false ; for ( TYPE_1 VAR_4 : VAR_1 ) { if ( VAR_4 . METHOD_2 ( ) == VAR_2 . METHOD_2 ( ) && <START> VAR_4 . METHOD_3 ( VAR_2 ) != 0 ) { <END> VAR_3 = true ; break ; } } return VAR_3 ; } 
public void METHOD_1 ( TYPE_1 vds ) { VAR_1 = vds ; METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; <START> METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; <END> } 
public Response METHOD_1 ( TYPE_1 action ) { return METHOD_2 ( TYPE_3 . TYPE_4 , <START> new TYPE_2 ( VAR_3 , action . VAR_4 ( ) , action . VAR_5 ( ) ) , action ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_1 model , org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_1 entity ) { <START> if ( METHOD_2 ( ) ) { <END> TYPE_2 VAR_6 = METHOD_3 ( TYPE_6 . TYPE_7 , new TYPE_3 ( Guid . VAR_9 ( model . getId ( ) ) ) ) ; if ( VAR_6 . METHOD_4 ( ) && VAR_6 . METHOD_5 ( ) != null ) { return TYPE_4 . METHOD_6 ( ( String ) VAR_6 . METHOD_5 ( ) , TYPE_5 . VAR_11 , model ) ; } } return model ; } 
public boolean METHOD_1 ( ) { String VAR_1 = ( String ) TYPE_1 . METHOD_2 ( TYPE_3 . TYPE_2 ) ; <START> return VAR_1 != null && ! "" . equals ( VAR_1 ) && ! STRING_1 . equals ( VAR_1 ) ; <END> } 
protected void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . VAR_2 ) ; <START> METHOD_2 ( TYPE_1 . VAR_3 ) ; <END> } 
protected Map < String , Pair < String , String > > METHOD_1 ( ) { if ( METHOD_2 ( ) == null ) { return null ; } <START> if ( METHOD_2 ( ) . METHOD_3 ( ) != null ) { <END> switch ( METHOD_2 ( ) . METHOD_3 ( ) ) { case VAR_1 : return METHOD_4 ( ) ; case VAR_2 : return METHOD_5 ( ) ; } } log . VAR_3 ( STRING_1 , METHOD_2 ( ) . METHOD_3 ( ) ) ; return null ; } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) <START> return false ; <END> TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return TYPE_2 . METHOD_1 ( VAR_2 , VAR_1 . VAR_2 ) && TYPE_2 . METHOD_1 ( VAR_3 , VAR_1 . VAR_3 ) && TYPE_2 . METHOD_1 ( VAR_4 , VAR_1 . VAR_4 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return ( TYPE_1 ) ( ( super . METHOD_1 ( ) instanceof TYPE_1 ) ? super . METHOD_1 ( ) : null ) ; <END> } 
public TYPE_1 getParameters ( TYPE_2 VAR_1 , TYPE_3 entity ) { TYPE_3 VAR_2 = METHOD_1 ( VAR_3 , TYPE_3 . class ) . map ( VAR_1 , entity ) ; VAR_2 . METHOD_2 ( TYPE_4 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , entity . VAR_4 ( ) , METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ) ) ; TYPE_5 params = new TYPE_5 ( VAR_2 ) ; if ( VAR_1 . METHOD_7 ( ) ) { params . VAR_5 ( VAR_1 . METHOD_8 ( ) ) ; <START> } <END> return params ; } 
public boolean METHOD_1 ( ) { <START> boolean result = false ; <END> switch ( vds . getStatus ( ) ) { case TYPE_1 : case TYPE_2 : case TYPE_4 : case TYPE_3 : case TYPE_5 : result = true ; break ; default : break ; } return result ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = exists ( ) ; if ( ! VAR_1 . METHOD_2 ( ) ) { return VAR_1 ; } if ( vds . getStatus ( ) . equals ( TYPE_2 . TYPE_4 ) ) { return new TYPE_1 ( TYPE_3 . VAR_5 ) ; } <START> if ( vds . getStatus ( ) . equals ( TYPE_2 . TYPE_5 ) ) { <END> return new TYPE_1 ( TYPE_3 . VAR_7 ) ; } return TYPE_1 . VAR_8 ; } 
private void METHOD_1 ( TYPE_1 action ) { <START> String VAR_1 = action . VAR_2 ( ) ; <END> METHOD_1 ( action , STRING_1 ) ; METHOD_2 ( TYPE_2 . class , VAR_1 ) ; } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; if ( METHOD_2 ( ) == null ) { return VAR_1 ; } for ( Object VAR_2 : METHOD_2 ( ) ) { TYPE_2 VAR_3 = ( TYPE_2 ) VAR_2 ; TYPE_1 vm = VAR_3 . METHOD_3 ( ) ; if ( vm == null ) { <START> continue ; <END> } VAR_1 . add ( vm ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { return ; } final TYPE_1 VAR_1 = new TYPE_2 ( this ) ; METHOD_3 ( VAR_1 ) ; <START> VAR_1 . METHOD_4 ( null ) ; <END> METHOD_5 ( VAR_1 ) ; } 
public void METHOD_1 ( final List < TYPE_1 > VAR_1 ) { TYPE_2 . execute ( new TYPE_3 ( ) { ANNOTATION_1 ( STRING_1 ) @Override public void run ( ) { TYPE_4 . METHOD_2 ( new TYPE_5 < Object > ( ) { @Override public Object METHOD_3 ( ) { boolean VAR_2 = METHOD_4 ( VAR_1 ) ; for ( TYPE_1 task : VAR_1 ) { METHOD_5 ( VAR_2 , task ) ; } <START> VAR_3 . METHOD_6 ( ) ; <END> return null ; } } ) ; } } ) ; } 
private String METHOD_1 ( ) { StringBuilder builder = new StringBuilder ( TYPE_2 . TYPE_3 . name ( ) ) ; <START> builder . append ( String . format ( STRING_1 , METHOD_2 ( ) ) ) ; <END> return builder . toString ( ) ; } 
public void METHOD_1 ( ) { <START> Guid result = VAR_1 . METHOD_2 ( Guid . VAR_2 ( STRING_1 ) ) ; <END> assertNotNull ( result ) ; assertEquals ( VAR_3 , result ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 result = VAR_1 . METHOD_2 ( Guid . VAR_2 ( STRING_1 ) , TYPE_2 . TYPE_3 ) ; <END> assertNotNull ( result ) ; METHOD_3 ( result ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 result = VAR_1 . METHOD_2 ( VAR_2 . getId ( ) , Guid . VAR_3 ( STRING_1 ) ) ; <END> METHOD_3 ( result ) ; } 
public void METHOD_1 ( ) { <START> Guid VAR_1 = Guid . VAR_2 ( STRING_1 ) ; <END> List < TYPE_1 > result = VAR_3 . METHOD_2 ( VAR_1 , VAR_4 , true ) ; METHOD_3 ( result , VAR_1 ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > result = VAR_1 . METHOD_2 ( VAR_2 , TYPE_2 . VAR_4 , <START> Guid . VAR_5 ( STRING_1 ) ) ; <END> assertNotNull ( result ) ; METHOD_3 ( result . isEmpty ( ) ) ; assertEquals ( result . get ( 0 ) . getId ( ) , VAR_6 . getId ( ) ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > result = VAR_1 . METHOD_2 ( VAR_2 , TYPE_2 . VAR_4 , <START> Guid . VAR_5 ( STRING_1 ) ) ; <END> assertNotNull ( result ) ; assertTrue ( result . isEmpty ( ) ) ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { TYPE_2 params = new TYPE_2 ( VAR_2 , null , null ) ; TYPE_3 VAR_3 = TYPE_4 . getInstance ( ) . METHOD_2 ( TYPE_7 . TYPE_6 , params , TYPE_5 . METHOD_3 ( ) ) ; if ( ! VAR_3 . METHOD_4 ( ) ) { <START> log . VAR_6 ( STRING_1 , params . VAR_7 ( ) . getName ( ) ) ; <END> } } } 
public void METHOD_1 ( Collection < T > VAR_1 ) { <START> if ( VAR_1 != null && VAR_1 . size ( ) > 0 ) <END> METHOD_1 ( METHOD_2 ( ) , VAR_1 , METHOD_3 ( ) ) ; } 
<START> public synchronized TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . get ( VAR_2 . getId ( ) ) ; } return VAR_1 ; } 
protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) ) ; return METHOD_3 ( VAR_1 . exists ( ) ) && METHOD_3 ( VAR_1 . METHOD_4 ( ) ) <START> && METHOD_3 ( VAR_1 . METHOD_5 ( TYPE_2 . VAR_3 ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_1 ( VAR_1 , STRING_1 ) ; <START> if ( ! VAR_1 . METHOD_2 ( ) || ! VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) { <END> VAR_1 . METHOD_5 ( new TYPE_2 ( ) ) ; VAR_1 . METHOD_3 ( ) . METHOD_6 ( VAR_2 ) ; } } 
protected String METHOD_1 ( ) { String VAR_1 = TYPE_1 . METHOD_2 ( METHOD_3 ( ) , "" , VAR_2 ) ; return VAR_1 . equals ( STRING_1 ) ? VAR_1 + VAR_3 : <START> VAR_1 + VAR_4 + VAR_3 ; <END> } 
public void METHOD_1 ( ) { synchronized ( VAR_1 ) { TYPE_3 . TYPE_4 . ArrayList < TYPE_2 > TYPE_5 = METHOD_2 ( ) ; for ( TYPE_2 task : TYPE_5 ) { if ( task . VAR_3 ( ) . getStatus ( ) == TYPE_6 . VAR_5 ) { task . VAR_6 ( ) ; <START> if ( task . VAR_7 ( ) != null ) { <END> VAR_1 . remove ( task . VAR_7 ( ) ) ; } } } } } 
private void METHOD_1 ( ) { <START> ArrayList < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; <END> METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; METHOD_2 ( ) . METHOD_4 ( ) . METHOD_5 ( this ) ; } 
private static boolean METHOD_1 ( TYPE_1 task ) { if ( TYPE_5 . TYPE_7 . equals ( task . getStatus ( ) ) || TYPE_5 . TYPE_6 . equals ( task . getStatus ( ) ) <START> || TYPE_5 . TYPE_8 . equals ( task . getStatus ( ) ) ) { <END> return true ; } return false ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 vm ) { for ( TYPE_3 VAR_1 : vm . VAR_2 ( ) ) { if ( VAR_1 . METHOD_2 ( ) == null ) { <START> return ! TYPE_4 . METHOD_3 ( vm . VAR_3 ( ) ) ? <END> new TYPE_1 ( TYPE_5 . VAR_5 ) : TYPE_1 . VAR_6 ; } } return TYPE_1 . VAR_6 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 != null && VAR_1 . METHOD_2 ( ) != null && <END> VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) == TYPE_2 . TYPE_3 ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) { Map < String , Object > values = VAR_2 . get ( VAR_1 . METHOD_2 ( ) ) ; if ( values == null ) { values = new HashMap < String , Object > ( ) ; VAR_2 . put ( VAR_1 . METHOD_2 ( ) , values ) ; } <START> log . info ( STRING_1 + VAR_1 . METHOD_2 ( ) + STRING_2 + VAR_1 . METHOD_3 ( ) ) ; <END> values . put ( VAR_1 . METHOD_3 ( ) , METHOD_4 ( VAR_1 ) ) ; } 
public TYPE_3 ( Guid VAR_2 , String VAR_3 , TYPE_1 VAR_4 , String [ ] VAR_5 , int VAR_6 ) { this ( VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; METHOD_1 ( VAR_6 ) ; <START> VAR_7 = TYPE_2 . NONE ; <END> } 
protected boolean METHOD_1 ( ) { if ( ! super . METHOD_1 ( ) ) { return false ; } <START> if ( getParameters ( ) . METHOD_2 ( ) == null ) { <END> return METHOD_3 ( TYPE_1 . VAR_2 ) ; } if ( ! METHOD_4 ( ) . isEmpty ( ) ) { return METHOD_3 ( TYPE_1 . VAR_3 ) ; } return true ; } 
public String value ( ) { <START> return VAR_1 . METHOD_1 ( ) ; <END> } 
<START> public String METHOD_1 ( String VAR_1 ) { <END> List < TYPE_1 > VAR_2 = METHOD_2 ( ) ; for ( int i = VAR_2 . size ( ) - 1 ; i >= 0 ; i -- ) { String VAR_3 = VAR_2 . get ( i ) . METHOD_3 ( VAR_1 ) ; if ( VAR_3 != null ) { return VAR_3 ; } } return null ; } 
<START> private static int METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = TYPE_2 < String > METHOD_2 ( TYPE_3 . TYPE_4 ) ; return TYPE_1 . METHOD_3 ( VAR_1 , VAR_2 ) ; } 
private String METHOD_1 ( ) { if ( VAR_1 == null ) { StringBuilder builder = new StringBuilder ( TYPE_2 . TYPE_3 . name ( ) ) ; if ( METHOD_2 ( ) != null ) { builder . append ( String . format ( STRING_1 , METHOD_3 ( ) ) ) ; } builder . append ( String . format ( STRING_2 , TYPE_5 . TYPE_4 == getParameters ( ) . METHOD_4 ( ) ? STRING_3 : STRING_4 ) ) ; <START> VAR_1 = builder . toString ( ) ; <END> } return VAR_1 ; } 
void METHOD_1 ( TYPE_1 model ) { if ( model instanceof TYPE_2 ) { TYPE_3 VAR_1 = model . VAR_2 ( ) ; if ( VAR_1 != null && ! VAR_1 . METHOD_2 ( ) ) { TYPE_2 VAR_3 = ( TYPE_2 ) model ; <START> VAR_3 . METHOD_3 ( ) . execute ( ) ; <END> } } } 
protected boolean METHOD_1 ( ) { final boolean VAR_1 = super . METHOD_1 ( ) ; <START> if ( ! VAR_1 && METHOD_2 ( ) . METHOD_3 ( ) ) { <END> TYPE_1 . getInstance ( ) . METHOD_4 ( getParameters ( ) . METHOD_5 ( ) ) ; } return VAR_1 ; } 
protected void METHOD_1 ( ) { VAR_1 = METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) , getParameters ( ) . METHOD_5 ( ) . METHOD_6 ( new String [ 0 ] ) , getParameters ( ) . METHOD_7 ( ) , getParameters ( ) . METHOD_8 ( ) ) ; task = VAR_1 . METHOD_9 ( ) ; METHOD_10 ( task ) ; <START> METHOD_11 ( ) ; <END> } 
public void METHOD_1 ( ) { command . getParameters ( ) . METHOD_2 ( METHOD_3 ( ) ) ; METHOD_4 ( VAR_1 ) ; METHOD_5 ( TYPE_2 . TYPE_1 , Guid . VAR_4 ( ) , VAR_1 , false ) ; command . VAR_5 ( ) ; <START> assertTrue ( command . VAR_6 ( ) . size ( ) == 1 ) ; <END> } 
<START> public static List < String > METHOD_1 ( Guid id ) { <END> return TYPE_1 . getInstance ( ) . METHOD_2 ( List . VAR_1 , TYPE_3 . TYPE_4 , new TYPE_2 ( id ) , STRING_1 , true ) ; } 
protected TYPE_8 ( TYPE_1 vm , <START> TYPE_2 VAR_2 , Guid VAR_3 , <END> TYPE_3 VAR_4 , ArrayList < TYPE_4 > VAR_5 , TYPE_4 VAR_6 , TYPE_5 VAR_7 ) { super ( vm , VAR_3 , VAR_4 , VAR_5 , VAR_7 , new TYPE_6 ( ) ) ; this . VAR_6 = VAR_6 ; this . VAR_2 = VAR_2 ; METHOD_1 ( TYPE_7 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) ) ; METHOD_4 ( STRING_1 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( ) . get ( getParameters ( ) . METHOD_3 ( ) ) ; } return VAR_1 ; } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; <START> VAR_2 = METHOD_1 ( ) . get ( getParameters ( ) . METHOD_2 ( ) ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 == null ) { return ; } else { VAR_1 . METHOD_2 ( ) ; <START> } <END> } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { VAR_2 = new TYPE_2 ( ) { @Override public void run ( ) { METHOD_2 ( VAR_1 ) ; } } ; <START> VAR_2 . METHOD_3 ( INT_1 ) ; <END> } 
private static long METHOD_1 ( Map . Entry < String , Map < String , String > > VAR_1 ) { String VAR_2 = VAR_1 . getValue ( ) . get ( STRING_1 ) ; if ( VAR_2 == null ) { return VAR_3 ; } <START> <END> try { return Long . valueOf ( VAR_2 ) ; } catch ( TYPE_1 e ) { log . VAR_4 ( STRING_2 , VAR_1 . getKey ( ) , e ) ; return VAR_3 ; } } 
protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( ! super . METHOD_1 ( ) ) { return false ; } boolean VAR_2 = VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ; if ( ! VAR_2 ) { return METHOD_5 ( TYPE_2 . VAR_4 ) ; <START> } else if ( VAR_2 && VAR_1 . METHOD_6 ( ) . size ( ) == 1 ) { <END> return METHOD_5 ( TYPE_2 . VAR_5 ) ; } return true ; } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = 0 ; int VAR_3 = 0 ; <START> for ( int i = 0 ; i < VAR_1 . METHOD_2 ( ) . size ( ) ; i ++ ) { <END> TYPE_2 VAR_4 = VAR_1 . METHOD_2 ( ) . get ( i ) ; if ( VAR_4 . getStatus ( ) == TYPE_3 . VAR_6 ) { VAR_3 ++ ; } else { VAR_2 ++ ; } if ( VAR_3 > 0 && VAR_2 > 0 ) { return VAR_2 ; } } return VAR_2 ; } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = 0 ; int VAR_3 = 0 ; for ( int i = 0 ; i < VAR_1 . METHOD_2 ( ) . size ( ) ; i ++ ) { TYPE_2 VAR_4 = VAR_1 . METHOD_2 ( ) . get ( i ) ; if ( VAR_4 . getStatus ( ) == TYPE_3 . VAR_6 ) { VAR_3 ++ ; } else { VAR_2 ++ ; } <START> if ( VAR_3 > 1 && VAR_2 > 1 ) { <END> return VAR_2 ; } } return VAR_2 ; } 
public String METHOD_1 ( TYPE_1 type ) { if ( type == null ) { <START> type = VAR_1 ; <END> } return VAR_2 . getProperty ( type . VAR_3 ( ) ) ; } 
private boolean METHOD_1 ( ) { <START> if ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_3 . VAR_2 ) { <END> return false ; } Guid VAR_3 = ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_4 ( ) ; return ! TYPE_2 . METHOD_5 ( VAR_3 , METHOD_4 ( ) ) ; } 
protected void METHOD_1 ( Guid VAR_1 , boolean VAR_2 ) { if ( VAR_2 ) { if ( ( Boolean ) METHOD_2 ( ) . METHOD_3 ( ) ) { METHOD_4 ( VAR_1 ) ; } else { <START> METHOD_5 ( ) ; <END> METHOD_6 ( ) ; } } METHOD_5 ( ) ; } 
<START> private void METHOD_1 ( ) { <END> METHOD_2 ( ) . METHOD_3 ( ) ; METHOD_4 ( null ) ; } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_5 . TYPE_4 , new TYPE_2 ( VAR_4 . getId ( ) , METHOD_3 ( ) ) ) ; if ( ! VAR_1 . METHOD_4 ( ) ) { METHOD_5 ( TYPE_3 . VAR_6 , VAR_1 . METHOD_6 ( ) . getMessage ( ) ) ; <START> return ; <END> } METHOD_7 ( ) ; METHOD_8 ( ) ; METHOD_9 ( VAR_1 . METHOD_4 ( ) ) ; } 
protected void METHOD_1 ( Object VAR_1 , TYPE_1 e ) { super . METHOD_1 ( VAR_1 , e ) ; if ( e . TYPE_2 . equals ( STRING_1 ) ) <START> { <END> METHOD_2 ( ) . execute ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 model = VAR_1 . METHOD_1 ( ) ; <END> model . VAR_2 ( ) . METHOD_2 ( ) . METHOD_3 ( VAR_3 ) ; VAR_4 . METHOD_1 ( ) ; VAR_5 . METHOD_1 ( ) ; return model ; } 
<START> protected static TYPE_1 create ( String name , Class VAR_1 , String VAR_2 ) { <END> TYPE_2 VAR_3 = TYPE_2 . METHOD_1 ( VAR_2 ) ; synchronized ( VAR_4 ) { TYPE_1 VAR_5 = VAR_4 . get ( VAR_3 ) ; if ( VAR_5 != null ) { throw new TYPE_3 ( name , VAR_5 . METHOD_2 ( ) , VAR_5 . getName ( ) ) ; } VAR_5 = new TYPE_1 ( name , VAR_1 . getName ( ) , VAR_3 ) ; VAR_4 . put ( VAR_3 , VAR_5 ) ; return VAR_5 ; } } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; <START> return VAR_2 . equals ( VAR_1 . VAR_2 ) ; <END> } 
public boolean equals ( Object VAR_1 ) { if ( VAR_1 == null || ! ( VAR_1 instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 ; return getName ( ) . equals ( VAR_2 . getName ( ) ) && METHOD_1 ( ) . equals ( VAR_2 . METHOD_1 ( ) ) <START> && METHOD_2 ( ) . equals ( VAR_2 . METHOD_2 ( ) ) ; <END> } 
public int METHOD_1 ( ) { int VAR_1 = INT_1 ; VAR_1 = INT_2 * VAR_1 + ( this . name != null ? this . name . VAR_2 ( ) : 0 ) ; VAR_1 = INT_2 * VAR_1 + ( this . VAR_3 != null ? this . VAR_3 . METHOD_1 ( ) : 0 ) ; <START> VAR_1 = INT_2 * VAR_1 + ( this . VAR_4 != null ? this . VAR_4 . METHOD_1 ( ) : 0 ) ; <END> return VAR_1 ; } 
public int METHOD_1 ( ) { int VAR_1 = INT_1 ; final int VAR_2 = INT_2 ; <START> for ( Entry < TYPE_1 , Object > entry : VAR_3 . entrySet ( ) ) { <END> VAR_1 = VAR_2 * VAR_1 + entry . getKey ( ) . METHOD_1 ( ) ; VAR_1 = VAR_2 * VAR_1 + entry . getValue ( ) . METHOD_1 ( ) ; } return VAR_1 ; } 
public int METHOD_1 ( ) { int VAR_1 = INT_1 ; VAR_1 = INT_2 * VAR_1 + ( this . value != null ? this . value . VAR_2 ( ) : 0 ) ; return VAR_1 ; <START> } <END> 
protected void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( TYPE_1 . getInstance ( ) . METHOD_4 ( ) . get ( <START> getParameters ( ) . < Guid > METHOD_5 ( TYPE_2 . TYPE_3 , Guid . VAR_3 ) ) ) ; <END> } 
private void METHOD_1 ( String VAR_1 , TYPE_1 parent ) { <START> if ( VAR_2 == "" ) { <END> return ; } VAR_3 . METHOD_2 ( new TYPE_2 ( VAR_2 ) ) ; if ( TYPE_5 . TYPE_6 . equals ( VAR_1 ) ) { VAR_3 . METHOD_3 ( parent ) ; } else if ( TYPE_5 . TYPE_7 . equals ( VAR_1 ) ) { VAR_3 . METHOD_4 ( ) ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { try { <START> Map < String , Object > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <END> TYPE_1 VAR_4 = new TYPE_1 ( VAR_2 ) ; return VAR_4 ; } catch ( TYPE_2 VAR_5 ) { throw new TYPE_3 ( VAR_5 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( new TYPE_3 ( this , new TYPE_4 ( ) { @Override public void METHOD_3 ( Object model , Object VAR_2 ) { TYPE_5 VAR_3 = ( TYPE_5 ) VAR_2 ; TYPE_6 VAR_4 = VAR_3 . METHOD_4 ( ) ; <START> METHOD_5 ( VAR_4 ) ; <END> } } ) , VAR_1 . METHOD_6 ( ) , VAR_1 . getId ( ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , Guid VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) , VAR_2 , VAR_1 . METHOD_5 ( ) ) ; <START> VAR_3 . METHOD_6 ( VAR_4 . get ( VAR_1 . METHOD_2 ( ) ) . getId ( ) ) ; <END> return VAR_3 ; } 
private static String METHOD_1 ( TYPE_1 VAR_1 ) { <START> String query = STRING_1 + VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) + STRING_1 <END> + VAR_1 . METHOD_3 ( TYPE_2 . VAR_3 ) + STRING_2 ; return query ; } 
private static String METHOD_1 ( TYPE_1 VAR_1 ) { String query = STRING_1 + VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) + STRING_1 + VAR_1 . METHOD_3 ( TYPE_2 . VAR_3 ) + STRING_2 ; <START> System . out . println ( STRING_3 + query ) ; <END> return query ; } 
public String METHOD_1 ( ) { <START> String path = getPath ( ) ; <END> if ( path . startsWith ( STRING_1 ) ) { path = path . substring ( 1 ) ; } return path ; } 
public TYPE_1 list ( ) { <START> boolean VAR_1 = TYPE_2 . METHOD_1 ( METHOD_2 ( ) , STRING_1 ) ; <END> List < TYPE_3 > VAR_2 = METHOD_3 ( TYPE_6 . TYPE_5 , new TYPE_4 ( METHOD_4 ( METHOD_5 ( ) ) ) ) ; TYPE_1 VAR_5 = METHOD_6 ( VAR_2 ) ; return METHOD_7 ( VAR_5 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 != null && ! VAR_2 . contains ( VAR_1 ) ) { VAR_2 . add ( VAR_1 ) ; } } 
<START> public void METHOD_1 ( ) { <END> for ( TYPE_1 VAR_1 : VAR_2 ) { VAR_1 . METHOD_2 ( ) ; } VAR_2 . clear ( ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; VAR_2 . remove ( VAR_1 ) ; } } 
<START> public void METHOD_1 ( Guid VAR_1 , TYPE_1 VAR_2 , final String action , final String status , TYPE_2 VAR_3 ) { <END> VAR_4 . METHOD_2 ( VAR_1 , VAR_2 , null , VAR_3 , new HashMap < String , String > ( ) { { put ( STRING_1 , action ) ; put ( STRING_2 , status ) ; } } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( new TYPE_3 ( this , new TYPE_4 ( ) { @Override public void METHOD_3 ( Object model , Object VAR_2 ) { TYPE_5 VAR_3 = ( TYPE_5 ) VAR_2 ; TYPE_6 VAR_4 = VAR_3 . METHOD_4 ( ) ; if ( VAR_4 != null ) { METHOD_5 ( VAR_4 ) ; } else { <START> METHOD_6 ( ) ; <END> } } } ) , VAR_1 . METHOD_7 ( ) , VAR_1 . getId ( ) , METHOD_8 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> log . debug ( STRING_1 ) ; <END> TYPE_2 . getInstance ( ) . METHOD_2 ( ) . update ( VAR_1 ) ; } 
protected void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) , TYPE_4 . VAR_3 , METHOD_3 ( ) ) ; <END> VAR_1 . METHOD_4 ( METHOD_5 ( ) ) ; super . METHOD_1 ( TYPE_2 . TYPE_3 , VAR_1 ) ; } 
public TYPE_4 ( TYPE_1 map ) { for ( Map . Entry < TYPE_2 , TYPE_3 > entry : map . entrySet ( ) ) { put ( TYPE_2 . METHOD_1 ( entry . getKey ( ) . METHOD_2 ( ) . toString ( ) ) , entry . getValue ( ) ) ; } <START> } <END> 
protected boolean METHOD_1 ( TYPE_1 status ) { boolean VAR_1 = false ; <START> if ( METHOD_2 ( ) != null && METHOD_2 ( ) != null ) { <END> VAR_1 = ( METHOD_2 ( ) != status ) ; if ( ! VAR_1 ) { METHOD_3 ( ) ; } } return VAR_1 ; } 
private void METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( ) == TYPE_3 . TYPE_2 ) { VAR_3 . METHOD_3 ( false ) ; VAR_4 . METHOD_3 ( false ) ; VAR_5 . METHOD_3 ( false ) ; VAR_6 . METHOD_4 ( VAR_7 . METHOD_5 ( ) ) ; <START> VAR_8 . METHOD_3 ( false ) ; <END> } } 
public void METHOD_1 ( ) { VAR_1 = getParameters ( ) . METHOD_2 ( ) ; Guid VAR_2 = getParameters ( ) . METHOD_3 ( ) ; if ( VAR_2 != null ) { VAR_3 = METHOD_4 ( ) . METHOD_5 ( VAR_2 ) ; if ( VAR_3 == null ) { throw new RuntimeException ( TYPE_2 . TYPE_3 . toString ( ) ) ; } } if ( VAR_1 == null ) { <START> VAR_1 = VAR_3 . METHOD_2 ( ) ; <END> } METHOD_6 ( ) . METHOD_7 ( METHOD_8 ( ) ) ; } 
protected void METHOD_1 ( ) { <START> if ( METHOD_2 ( ) == null ) { <END> return ; } if ( METHOD_2 ( ) != null ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; if ( METHOD_3 ( ) == VAR_1 . METHOD_4 ( ) ) { METHOD_5 ( ) . METHOD_6 ( this , TYPE_3 . TYPE_2 ) ; } else { METHOD_7 ( VAR_1 . METHOD_4 ( ) ) ; } } else { METHOD_7 ( null ) ; } } 
public static TYPE_1 METHOD_1 ( TYPE_2 reader ) throws TYPE_3 { TYPE_4 VAR_1 = TYPE_5 . METHOD_1 ( reader ) ; <START> return TYPE_1 . METHOD_2 ( VAR_1 . toString ( ) ) ; <END> } 
public TYPE_1 put ( TYPE_2 VAR_1 , Object value ) { if ( ! METHOD_1 ( VAR_1 . METHOD_2 ( ) , value . getClass ( ) ) ) { <START> throw new TYPE_3 ( VAR_1 . getName ( ) , VAR_1 . METHOD_2 ( ) , value . getClass ( ) ) ; <END> } VAR_2 . put ( VAR_1 , ( TYPE_4 ) value ) ; return this ; } 
public List < TYPE_1 > METHOD_1 ( Guid id , Guid VAR_1 , boolean VAR_2 ) { <START> Integer VAR_3 = TYPE_3 < Integer > METHOD_2 ( TYPE_4 . TYPE_5 ) ; <END> TYPE_2 VAR_7 = METHOD_3 ( ) . METHOD_4 ( STRING_1 , id ) . METHOD_4 ( STRING_2 , VAR_1 ) . METHOD_4 ( STRING_3 , VAR_2 ) . METHOD_4 ( STRING_4 , VAR_3 . METHOD_5 ( ) ) ; return METHOD_6 ( ) . METHOD_7 ( STRING_5 , TYPE_6 . instance , VAR_7 ) ; } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( TYPE_1 . getInstance ( ) . METHOD_4 ( ) . METHOD_5 ( ) ) ; <END> } 
protected Map < String , Pair < String , String > > METHOD_1 ( ) { Map < String , Pair < String , String > > VAR_1 = new HashMap < String , Pair < String , String > > ( ) ; TYPE_1 cluster = METHOD_2 ( ) ; if ( cluster == null || cluster . VAR_2 ( ) ) { VAR_1 . put ( getParameters ( ) . METHOD_3 ( ) . toString ( ) , TYPE_2 . METHOD_4 ( TYPE_3 . VAR_4 , <START> TYPE_4 . VAR_6 ) ) ; <END> } return VAR_1 ; } 
public static boolean METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) { <START> ArrayList < String > VAR_3 = TYPE_2 . getInstance ( ) . get ( TYPE_3 . class ) . METHOD_2 ( VAR_1 , VAR_2 ) ; <END> return VAR_3 . contains ( TYPE_5 . TYPE_6 . toString ( ) ) ; } 
private String METHOD_1 ( List < TYPE_1 > VAR_1 ) { StringBuilder builder = new StringBuilder ( ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { builder . append ( VAR_2 . METHOD_2 ( ) ) ; builder . append ( STRING_1 ) ; } <START> return builder . substring ( 0 , builder . length ( ) - 2 ) . toString ( ) ; <END> } 
public void METHOD_1 ( final TYPE_1 VAR_1 , final List < TYPE_2 > parameters , final TYPE_3 VAR_2 ) { <START> METHOD_1 ( VAR_1 , parameters , VAR_2 , null , false ) ; <END> } 
private static List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> ArrayList < TYPE_1 > result = new ArrayList < TYPE_1 > ( ) ; <END> for ( TYPE_1 VAR_2 : VAR_1 ) { if ( METHOD_2 ( VAR_2 ) && VAR_2 . METHOD_3 ( ) ) { result . add ( VAR_2 ) ; } } return result ; } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; <START> this . METHOD_1 ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> } 
private void METHOD_1 ( ) { final List < String > VAR_1 = ( List < String > ) TYPE_1 . METHOD_2 ( TYPE_3 . TYPE_2 ) ; <START> final ArrayList < String > VAR_4 = new ArrayList < String > ( ) ; <END> VAR_4 . add ( null ) ; VAR_4 . addAll ( VAR_1 ) ; METHOD_3 ( ) . METHOD_4 ( VAR_4 ) ; METHOD_3 ( ) . METHOD_5 ( false ) ; } 
public void METHOD_1 ( TYPE_1 command ) { super . METHOD_1 ( command ) ; if ( command == METHOD_2 ( ) ) { remove ( ) ; } <START> else if ( STRING_1 . equals ( command . getName ( ) ) ) { <END> METHOD_3 ( ) ; } } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
private TYPE_1 < ? > METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . get ( METHOD_4 ( ) . METHOD_5 ( ) ) ; <END> } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> TYPE_2 VAR_2 = METHOD_2 ( ) . get ( getParameters ( ) . METHOD_3 ( ) ) ; <END> VAR_1 = VAR_2 . METHOD_4 ( ) ; } return VAR_1 ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> METHOD_3 ( ) . METHOD_4 ( VAR_1 != null && VAR_1 . METHOD_5 ( ) ) ; <END> METHOD_6 ( ) . METHOD_4 ( ( METHOD_7 ( ) != null && METHOD_7 ( ) . size ( ) > 0 ) ) ; } 
public void METHOD_1 ( TYPE_1 command ) { super . METHOD_1 ( command ) ; if ( command == METHOD_2 ( ) ) { METHOD_3 ( ) ; <START> } <END> else if ( command == METHOD_4 ( ) ) { remove ( ) ; } else if ( STRING_1 . equals ( command . getName ( ) ) ) { METHOD_5 ( ) ; } } 
<START> public void METHOD_1 ( TYPE_1 < String > name ) { <END> this . name = name ; } 
public void METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = new TYPE_1 ( ) ; } VAR_1 . METHOD_2 ( getName ( ) . METHOD_3 ( ) ) ; TYPE_2 VAR_2 = METHOD_4 ( ) . METHOD_5 ( ) ; VAR_1 . METHOD_6 ( VAR_2 != null ? VAR_2 . METHOD_7 ( ) : null ) ; VAR_1 . METHOD_8 ( METHOD_9 ( ) . METHOD_3 ( ) ) ; VAR_1 . METHOD_10 ( METHOD_11 ( ) . METHOD_5 ( ) ) ; } 
<START> protected void METHOD_1 ( TYPE_1 VAR_1 , String key ) { <END> VAR_1 . getValue ( ) . METHOD_2 ( false ) ; VAR_1 . METHOD_3 ( ) . METHOD_2 ( false ) ; } 
<START> public void METHOD_1 ( TYPE_1 < Pair < String , TYPE_2 > > VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
public Object METHOD_1 ( Object val ) throws TYPE_1 { if ( val == null ) return null ; if ( val instanceof byte [ ] ) { return new Guid ( ( byte [ ] ) val , true ) ; } if ( val instanceof TYPE_2 ) return new Guid ( ( TYPE_2 ) val ) ; if ( val instanceof Guid ) return new Guid ( ( ( Guid ) val ) . METHOD_2 ( ) ) ; <START> throw new TYPE_3 ( STRING_1 + val . getClass ( ) + STRING_2 ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( String VAR_1 , Guid VAR_2 ) { <START> List < TYPE_1 > VAR_3 = METHOD_2 ( VAR_2 , null , false ) ; <END> List < TYPE_1 > VAR_4 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_5 : VAR_3 ) { if ( StringUtils . equals ( VAR_5 . METHOD_3 ( ) , VAR_1 ) ) { VAR_4 . add ( VAR_5 ) ; } } return VAR_4 ; } 
protected void METHOD_1 ( ) { boolean VAR_1 = ( Boolean ) METHOD_2 ( ) . METHOD_3 ( ) ; METHOD_4 ( ) . METHOD_5 ( ! VAR_1 ) ; METHOD_6 ( ) . METHOD_7 ( ! VAR_1 ) ; String VAR_2 = METHOD_8 ( ) . METHOD_9 ( ) ; <START> if ( VAR_1 ) { <END> METHOD_8 ( ) . METHOD_10 ( new HashSet < String > ( ) ) ; } else { METHOD_8 ( ) . METHOD_10 ( VAR_3 ) ; } METHOD_8 ( ) . METHOD_11 ( VAR_2 ) ; } 
private List < TYPE_1 > METHOD_1 ( final Guid VAR_1 , Map < Guid , List < TYPE_1 > > VAR_2 ) { List < TYPE_1 > VAR_3 = VAR_2 . get ( VAR_1 ) ; VAR_3 = TYPE_2 . filter ( VAR_3 , new TYPE_3 < TYPE_1 > ( ) { @Override public boolean METHOD_2 ( TYPE_1 v ) { return v . VAR_4 ( ) == TYPE_4 . VAR_6 <START> && ! VAR_1 . equals ( v . VAR_7 ( ) ) ; <END> } } ) ; return VAR_3 ; } 
private Map < Guid , TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { Map < Guid , TYPE_1 > VAR_2 = new HashMap < Guid , TYPE_1 > ( ) ; for ( TYPE_3 VAR_3 : VAR_1 . METHOD_2 ( ) ) { <START> VAR_2 . put ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) , VAR_3 . METHOD_3 ( ) ) ; <END> } return VAR_2 ; } 
private boolean METHOD_1 ( String [ ] VAR_1 , List < TYPE_1 > VAR_2 ) { for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { String VAR_3 = VAR_2 . get ( i ) . getPath ( ) ; <START> if ( METHOD_2 ( VAR_3 ) || VAR_3 . equals ( VAR_1 [ i ] ) ) { <END> continue ; } else { return false ; } } return true ; } 
<START> public TYPE_4 ( ) throws TYPE_1 { <END> try { VAR_2 = new TYPE_2 ( ) ; } catch ( TYPE_3 e ) { throw new TYPE_1 ( STRING_1 , e ) ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String description , boolean VAR_3 ) { TYPE_2 request = <START> new TYPE_3 ( STRING_1 ) . METHOD_2 ( STRING_2 , VAR_1 ) <END> . METHOD_3 ( STRING_3 , VAR_2 ) . METHOD_3 ( STRING_4 , description ) . METHOD_3 ( STRING_5 , VAR_3 ) . build ( ) ; Map < String , Object > response = new TYPE_4 ( this . client , request ) . METHOD_4 ( ) ; return new TYPE_1 ( response ) ; } 
private void METHOD_1 ( String VAR_1 , Guid VAR_2 ) { TYPE_1 VAR_3 = METHOD_2 ( ) . METHOD_3 ( TYPE_5 . TYPE_4 , new TYPE_2 ( VAR_1 , VAR_2 ) , <START> TYPE_3 . METHOD_4 ( METHOD_5 ( ) ) ) ; <END> if ( ! VAR_3 . METHOD_6 ( ) ) { log . VAR_6 ( STRING_1 , VAR_1 ) ; } } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) == null || METHOD_4 ( ) . METHOD_3 ( ) == null ) { return ; } TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( ) ; <START> TYPE_2 VAR_2 = ( ( TYPE_3 ) METHOD_5 ( ) . METHOD_3 ( ) ) . METHOD_6 ( ) ; <END> METHOD_7 ( VAR_1 , VAR_2 ) ; METHOD_8 ( VAR_1 , VAR_2 ) ; } 
public synchronized HashSet < Guid > METHOD_1 ( Guid VAR_1 ) { HashSet < Guid > VAR_2 = new HashSet < > ( ) ; Map < Guid , Status > VAR_3 = VAR_4 . get ( VAR_1 ) ; for ( Entry < Guid , Status > status : VAR_3 . entrySet ( ) ) { <START> if ( status . getValue ( ) . METHOD_2 ( ) ) <END> VAR_2 . add ( status . getKey ( ) ) ; } return VAR_2 ; } 
private TYPE_1 METHOD_1 ( boolean VAR_1 ) { final TYPE_2 <START> ctx = <END> this . VAR_2 ; if ( ctx == null ) { return null ; } final TYPE_1 VAR_3 = ctx . VAR_4 ( ) ; VAR_3 . METHOD_2 ( VAR_1 ) ; return VAR_3 ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 model ) { <START> model . VAR_1 ( new TYPE_2 ( ) . METHOD_2 ( ) ) ; <END> model . VAR_2 ( TYPE_3 . METHOD_3 ( TYPE_4 . class ) . value ( ) ) ; return model ; } 
public static boolean METHOD_1 ( TYPE_1 version , boolean VAR_1 ) { if ( VAR_1 ) { return version . VAR_2 ( new TYPE_1 ( 3 , 0 ) ) >= 0 ; } else { <START> return version . VAR_2 ( new TYPE_1 ( 3 , 0 ) ) >= 0 ; <END> } } 
public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) == TYPE_1 . VAR_2 ; <END> } 
<START> public Boolean METHOD_1 ( ) { <END> return this . VAR_1 . METHOD_1 ( ) ; } 
private void METHOD_1 ( boolean VAR_1 ) { TYPE_1 vm = ( TYPE_1 ) METHOD_2 ( ) ; if ( vm == null ) { return ; } if ( ! vm . VAR_2 ( ) ) { return ; } TYPE_2 params = new TYPE_2 ( vm . VAR_3 ( ) , TYPE_4 . VAR_5 , VAR_1 ) ; <START> TYPE_3 . getInstance ( ) . METHOD_3 ( TYPE_6 . TYPE_5 , params , null , this ) ; <END> } 
public void METHOD_1 ( int VAR_1 ) { if ( METHOD_2 ( ) == VAR_1 ) { return ; } METHOD_3 ( ) ; logger . VAR_2 ( STRING_1 + name + STRING_2 + VAR_1 ) ; VAR_3 = VAR_1 ; <START> TYPE_1 . METHOD_4 ( this , String . valueOf ( METHOD_2 ( ) ) ) ; <END> } 
public static boolean METHOD_1 ( List < TYPE_1 > VAR_1 ) { boolean result = true ; for ( TYPE_1 vm : VAR_1 ) { result &= TYPE_2 . METHOD_2 ( vm . VAR_2 ( ) , <START> vm . VAR_3 ( ) ) ; <END> } return result ; } 
public TYPE_2 ( String VAR_2 , boolean VAR_3 , String VAR_4 , String name ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_5 = new TYPE_1 ( VAR_4 , name ) ; <START> } <END> 
public TYPE_2 ( String VAR_2 , boolean VAR_3 , String VAR_4 , String name ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; if ( VAR_4 != null ) { VAR_5 = new TYPE_1 ( VAR_4 , name ) ; } else { VAR_5 = null ; <START> } <END> } 
public TYPE_1 METHOD_1 ( ) { switch ( METHOD_2 ( ) ) { case VAR_1 : if ( METHOD_3 ( ) . METHOD_4 ( ) == TYPE_2 . VAR_3 ) { return METHOD_5 ( ) ? TYPE_1 . VAR_4 <START> : TYPE_1 . VAR_5 ; <END> } else { return METHOD_5 ( ) ? TYPE_1 . VAR_6 : TYPE_1 . VAR_7 ; } default : return TYPE_1 . VAR_8 ; } } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( TYPE_1 . VAR_2 , METHOD_3 ( TYPE_1 . VAR_2 , STRING_1 ) , true ) ; <END> } 
public List < File > METHOD_1 ( ) { String path = getProperty ( STRING_1 ) ; if ( path == null ) { <START> log . warn ( STRING_2 ) ; <END> return Collections . VAR_1 ( ) ; } List < File > results = new ArrayList < File > ( ) ; for ( String VAR_2 : path . split ( STRING_3 ) ) { if ( StringUtils . VAR_3 ( VAR_2 ) ) { results . add ( new File ( VAR_2 ) ) ; } } return results ; } 
public String METHOD_1 ( ) { TYPE_1 config = ( TYPE_1 ) context . get ( TYPE_2 . VAR_2 ) ; <START> return config . getProperty ( STRING_1 ) ; <END> } 
private TYPE_3 ( ) { for ( TYPE_1 VAR_2 : TYPE_2 . getInstance ( ) . METHOD_1 ( ) ) { VAR_3 . put ( VAR_2 . METHOD_2 ( ) . getName ( ) , VAR_2 . METHOD_2 ( ) ) ; <START> } <END> } 
private static void METHOD_1 ( String VAR_1 ) { <START> File VAR_2 = new File ( VAR_1 ) ; <END> if ( ! VAR_2 . exists ( ) ) { VAR_2 . METHOD_2 ( ) ; } } 
public TYPE_6 ( TYPE_1 VAR_2 ) throws TYPE_2 { this . VAR_2 = VAR_2 ; this . VAR_3 = new TYPE_3 ( ) ; this . VAR_4 = new TYPE_4 ( ) ; TYPE_5 VAR_5 = new TYPE_5 ( VAR_2 ) ; VAR_5 . METHOD_1 ( this . VAR_3 ) ; <START> METHOD_2 ( VAR_5 ) ; <END> this . VAR_4 . METHOD_3 ( VAR_5 ) ; VAR_6 = TYPE_4 . parse ( VAR_2 . getProperty ( TYPE_1 . VAR_7 ) ) ; METHOD_4 ( ) ; } 
<START> protected TYPE_2 . TYPE_3 . ArrayList < Guid > METHOD_1 ( ) { <END> return getParameters ( ) . METHOD_2 ( ) ; } 
<START> private boolean METHOD_1 ( ) { <END> List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_2 . METHOD_5 ( ) . equals ( METHOD_6 ( ) . METHOD_5 ( ) ) ) { return true ; } } return false ; } 
public TYPE_1 METHOD_1 ( Guid VAR_1 ) { <START> return METHOD_1 ( VAR_1 , true ) ; <END> } 
public TYPE_2 ( TYPE_1 parameters ) { <START> this ( parameters , true ) ; <END> } 
public boolean isEmpty ( ) { <START> return METHOD_1 ( ) == null || METHOD_1 ( ) . size ( ) == 0 ; <END> } 
<START> public static Map < Integer , Map < TYPE_1 , Boolean > > METHOD_1 ( ) { <END> return VAR_1 ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { <START> System . out . println ( STRING_1 ) ; <END> } if ( parent == null ) { System . out . println ( STRING_2 ) ; } return parent . VAR_2 ( VAR_1 ) ; } 
public static TYPE_1 METHOD_1 ( String value ) { <START> return valueOf ( value != null ? value . VAR_1 ( ) : null ) ; <END> } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { final TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( TYPE_2 . class ) ; <START> TYPE_4 . METHOD_3 ( VAR_1 ) ; <END> VAR_2 . METHOD_4 ( VAR_3 , VAR_4 ) ; METHOD_5 ( VAR_4 ) . METHOD_6 ( TYPE_5 . VAR_6 ) ; } 
protected void METHOD_1 ( TYPE_1 request , TYPE_2 response ) throws TYPE_3 , IOException { File file = TYPE_4 . METHOD_2 ( request . VAR_1 ( ) , VAR_2 ) ; file = METHOD_3 ( request , response , file , request . VAR_1 ( ) ) ; <START> TYPE_4 . METHOD_4 ( request , response , file , type , cache , file == VAR_2 && VAR_3 ) ; <END> } 
protected boolean METHOD_1 ( TYPE_1 < String > value ) { String text = value . VAR_1 ( ) ; <START> return text == null || text . isEmpty ( ) ; <END> } 
void METHOD_1 ( boolean VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( ) && ! VAR_2 . METHOD_4 ( ) ) { if ( VAR_1 ) { <START> VAR_2 . METHOD_5 ( ) ; <END> VAR_2 . METHOD_6 ( METHOD_7 ( ) ) ; } else { VAR_2 . METHOD_5 ( ) ; VAR_2 . METHOD_6 ( VAR_3 ) ; } VAR_2 . start ( ) ; } } 
public void METHOD_1 ( String value ) { if ( value == null ) { this . VAR_1 = "" ; } else { this . VAR_1 = value ; <START> } <END> } 
public void METHOD_1 ( String user , String VAR_1 ) { String VAR_2 = ( ( TYPE_1 ) context . get ( TYPE_5 . VAR_4 ) ) . getProperty ( STRING_1 ) ; String VAR_5 = ( ( TYPE_1 ) context . get ( TYPE_5 . VAR_4 ) ) . getProperty ( STRING_2 ) ; if ( ! TYPE_2 . equals ( user , VAR_2 ) <START> || ! TYPE_2 . equals ( VAR_1 , VAR_5 ) ) { <END> throw new TYPE_3 ( TYPE_3 . TYPE_4 . VAR_7 , "" ) ; } } 
public TYPE_4 ( TYPE_1 props ) { <START> this . file = null ; <END> context = new TYPE_2 < > ( TYPE_3 . class ) ; METHOD_1 ( props ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 action , TYPE_3 parameters ) { Class type ; try { type = Class . VAR_1 ( METHOD_2 ( action ) ) ; TYPE_4 info = TYPE_5 . METHOD_3 ( type , parameters . getClass ( ) ) ; Object VAR_2 = info . VAR_3 ( parameters ) ; return ( TYPE_1 ) ( ( VAR_2 instanceof TYPE_1 ) ? VAR_2 : null ) ; } catch ( TYPE_6 | TYPE_7 | TYPE_8 | IllegalArgumentException <START> | TYPE_9 e ) { <END> log . VAR_4 ( STRING_1 , action ) ; return null ; } } 
public void METHOD_1 ( final List < TYPE_1 > VAR_1 , final List < TYPE_2 > parameters , final List < TYPE_3 > VAR_2 , final TYPE_3 VAR_3 , final Object state ) { <START> METHOD_1 ( VAR_1 , parameters , VAR_2 , VAR_3 , state , false , null , null ) ; <END> } 
public void METHOD_1 ( final List < TYPE_1 > VAR_1 , final List < TYPE_2 > parameters , final List < TYPE_3 > VAR_2 , final TYPE_3 VAR_3 , final Object state ) { <START> METHOD_1 ( VAR_1 , parameters , VAR_2 , VAR_3 , state , false , null ) ; <END> } 
protected void METHOD_1 ( ) { <START> Integer VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( getParameters ( ) . getId ( ) ) ; <END> METHOD_5 ( ) . METHOD_6 ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( ) . METHOD_2 ( false ) ; <END> } 
protected boolean METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { <START> if ( VAR_2 . getStatus ( ) != TYPE_2 . VAR_4 && VAR_2 . getStatus ( ) != TYPE_2 . VAR_5 ) { <END> return false ; } } return true ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( getParameters ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) ; <START> VAR_1 . METHOD_5 ( getParameters ( ) . METHOD_3 ( ) . METHOD_6 ( ) ) ; <END> } 
public static TYPE_1 getParameters ( TYPE_2 VAR_1 ) { return VAR_1 . METHOD_1 ( ) != null ? ( TYPE_1 ) VAR_1 . METHOD_1 ( ) . get ( VAR_2 ) : null ; <START> } <END> 
private static void METHOD_1 ( TYPE_1 entity , TYPE_2 VAR_1 ) { HashSet < TYPE_2 > entry ; if ( ! VAR_2 . containsKey ( entity ) ) { VAR_2 . put ( entity , new HashSet < TYPE_2 > ( ) ) ; } entry = VAR_2 . get ( entity ) ; <START> entry . add ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> TYPE_1 VAR_3 = VAR_1 . METHOD_3 ( TYPE_2 . VAR_5 , TYPE_2 . VAR_6 ) ; assertNotNull ( STRING_1 , VAR_3 ) ; } 
public boolean METHOD_1 ( ) { try { METHOD_2 ( ) . execute ( new TYPE_1 < > ( METHOD_2 ( ) , TYPE_4 . VAR_2 , "" , null , null ) ) ; <START> return true ; <END> } catch ( RuntimeException e ) { throw new TYPE_2 ( TYPE_3 . VAR_4 , e ) ; } } 
<START> static private List < TYPE_1 > METHOD_1 ( int size ) { <END> List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( Guid . VAR_3 ( ) ) ; VAR_1 . add ( VAR_2 ) ; } return VAR_1 ; } 
<START> protected void METHOD_1 ( TYPE_1 < TYPE_2 > command ) { <END> METHOD_2 ( new TYPE_3 < List < TYPE_4 > > ( ) { @Override public List < TYPE_4 > METHOD_3 ( TYPE_5 VAR_1 ) throws Throwable { Object [ ] args = VAR_1 . METHOD_4 ( ) ; TYPE_4 VAR_2 = ( TYPE_4 ) args [ 0 ] ; List < TYPE_4 > list = METHOD_5 ( VAR_2 . getId ( ) , 3 ) ; return list ; } } ) . when ( command ) . METHOD_6 ( METHOD_7 ( TYPE_4 . class ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( VAR_2 ) . METHOD_4 ( ) ; TYPE_2 . METHOD_3 ( VAR_3 ) . METHOD_5 ( ) ; <START> TYPE_2 . METHOD_6 ( VAR_4 , VAR_5 , VAR_3 , VAR_2 ) ; <END> VAR_1 . METHOD_2 ( ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { <START> final TYPE_2 VAR_2 = METHOD_2 ( ) ; <END> if ( StringUtils . isEmpty ( VAR_1 . METHOD_3 ( ) ) && ( VAR_2 . METHOD_4 ( ) >= 1 ) ) { VAR_1 . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ; } } 
protected boolean METHOD_1 ( ) { <START> TYPE_1 VAR_1 = TYPE_2 . METHOD_1 ( METHOD_2 ( ) , METHOD_3 ( ) ) ; <END> if ( ! VAR_1 . METHOD_4 ( ) ) { return METHOD_5 ( VAR_1 . getMessage ( ) ) ; } return true ; } 
public void METHOD_1 ( Guid VAR_1 ) { List < TYPE_1 > VAR_2 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; if ( VAR_2 != null ) { METHOD_4 ( VAR_2 ) ; <START> final TYPE_2 VAR_3 = METHOD_5 ( VAR_1 ) ; <END> for ( TYPE_1 VAR_4 : VAR_2 ) { VAR_3 . METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; METHOD_2 ( ) . remove ( VAR_4 . getId ( ) ) ; METHOD_8 ( ) . remove ( VAR_4 . getId ( ) ) ; } } } 
public Guid METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
<START> public void METHOD_1 ( Guid value ) { <END> VAR_1 = value ; } 
public Object METHOD_1 ( String key , boolean VAR_1 ) { return METHOD_1 ( TYPE_1 . METHOD_2 ( ) , key , VAR_1 ) ; <START> } <END> 
private void METHOD_1 ( TYPE_1 VAR_1 ) { Date VAR_2 = new Date ( ) ; Date VAR_3 = ( Date ) VAR_1 . VAR_4 . get ( VAR_5 ) ; if ( VAR_3 == null ) { VAR_3 = VAR_2 ; <START> } <END> int VAR_6 = TYPE_3 < Integer > getValue ( TYPE_4 . TYPE_5 ) ; if ( VAR_6 > 0 ) { VAR_1 . VAR_4 . put ( VAR_5 , TYPE_2 . METHOD_2 ( VAR_2 , VAR_6 ) ) ; } } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = null ; for ( TYPE_1 VAR_3 : VAR_4 . values ( ) ) { if ( VAR_3 . VAR_1 . equals ( VAR_1 ) ) { VAR_2 = VAR_3 ; break ; } } <START> return VAR_2 ; <END> } 
public final void METHOD_1 ( String VAR_1 ) { Iterator < Entry < String , TYPE_1 > > iterator = VAR_2 . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { if ( iterator . next ( ) . getKey ( ) . equals ( VAR_1 ) ) { iterator . remove ( ) ; break ; <START> } <END> } } 
protected void METHOD_1 ( String VAR_1 , Object VAR_2 ) { <START> String message = String . format ( STRING_1 , VAR_1 , VAR_2 ) ; <END> METHOD_2 ( ) . METHOD_3 ( ) . add ( message ) ; } 
private boolean METHOD_1 ( ) { boolean VAR_1 = true ; if ( ! getParameters ( ) . METHOD_2 ( ) && ! METHOD_3 ( ) ) { VAR_1 = METHOD_4 ( VAR_2 ) ; } <START> return VAR_1 ; <END> } 
public TYPE_2 ( ) { update ( null , null ) ; <START> TYPE_1 . getInstance ( ) . METHOD_1 ( this ) ; <END> } 
public void METHOD_1 ( TYPE_1 record ) { METHOD_2 ( ) ; TYPE_2 VAR_1 = new TYPE_2 ( ) . METHOD_3 ( TYPE_6 . TYPE_5 . VAR_4 , Logger . TYPE_4 . VAR_6 ) ; TYPE_2 VAR_7 = new TYPE_2 ( ) ; for ( TYPE_3 VAR_8 : METHOD_4 ( ) ) { try { VAR_8 . METHOD_5 ( <START> VAR_1 . METHOD_3 ( Logger . TYPE_5 . VAR_9 , record ) , <END> VAR_7 ) ; } catch ( Exception ex ) { } } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( Boolean . VAR_1 . equals ( VAR_2 . METHOD_2 ( ) ) && VAR_2 . METHOD_3 ( ) == TYPE_5 . TYPE_2 && VAR_2 . METHOD_4 ( ) == TYPE_3 . VAR_6 ) { return new TYPE_1 ( TYPE_4 . VAR_8 ) ; } return TYPE_1 . VAR_9 ; } 
public TYPE_1 ( Guid VAR_2 , Guid VAR_3 ) { <START> super ( VAR_2 , VAR_3 ) ; <END> this . VAR_4 = false ; } 
public void METHOD_1 ( ) { long VAR_1 = INT_1 ; Pair < Long , TimeUnit > VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 , TimeUnit . VAR_3 ) ; assertEquals ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) , INT_2 ) ; <START> assertEquals ( VAR_2 . METHOD_5 ( ) , TimeUnit . VAR_4 ) ; <END> } 
public void METHOD_1 ( TYPE_1 entity ) { List < TYPE_2 > VAR_1 = entity . VAR_2 ( ) ; METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <START> METHOD_2 ( ) . METHOD_4 ( VAR_1 . get ( 0 ) ) ; <END> } 
public Guid METHOD_1 ( ) { if ( METHOD_2 ( ) ) { return getParameters ( ) . METHOD_3 ( ) ; <START> } else { <END> return super . METHOD_1 ( ) ; } } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { try { METHOD_2 ( VAR_2 , VAR_1 ) ; TYPE_3 VAR_3 = VAR_4 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , TYPE_3 . class ) ; return METHOD_5 ( Arrays . asList ( VAR_3 . METHOD_6 ( ) ) ) ; <START> } catch ( TYPE_4 e ) { <END> METHOD_7 ( e ) ; } catch ( TYPE_5 e ) { METHOD_7 ( e ) ; } catch ( IOException e ) { METHOD_7 ( e ) ; } return null ; } 
private void METHOD_1 ( TYPE_1 version , TYPE_2 [ ] values ) { if ( TYPE_3 . METHOD_2 ( version , VAR_1 ) ) { version . VAR_2 ( new TYPE_4 ( ) ) ; for ( TYPE_2 VAR_3 : values ) { <START> version . VAR_4 ( ) . METHOD_3 ( ) . add ( VAR_3 . toString ( ) . METHOD_4 ( ) ) ; <END> } } } 
private void METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) , TYPE_4 . VAR_3 ) ; <END> TYPE_3 . METHOD_5 ( VAR_4 . getId ( ) , METHOD_6 ( ) , METHOD_7 ( ) , METHOD_7 ( ) . METHOD_8 ( ) , true , VAR_1 , METHOD_9 ( ) , false , false , false , false , false ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; connection . VAR_3 ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . toString ( ) ) ; if ( VAR_2 . METHOD_4 ( ) . METHOD_3 ( ) != null ) { <START> connection . VAR_4 ( VAR_2 . METHOD_4 ( ) . METHOD_3 ( ) ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; String [ ] VAR_2 = { STRING_1 , STRING_2 , STRING_3 } ; TYPE_2 result = VAR_1 . METHOD_2 ( VAR_2 , STRING_4 ) ; int VAR_3 = result . VAR_4 ( ) ; <START> Assert . assertEquals ( 3 , VAR_3 ) ; <END> } 
public void METHOD_1 ( ) { Set < TYPE_1 < TYPE_2 > > VAR_1 = METHOD_2 ( new TYPE_2 ( 0 ) ) ; <START> Assert . assertEquals ( 0 , VAR_1 . size ( ) ) ; <END> } 
public void METHOD_1 ( ) { Guid VAR_1 = new Guid ( STRING_1 ) ; Guid VAR_2 = new Guid ( STRING_2 ) ; assertTrue ( VAR_1 . METHOD_2 ( VAR_2 ) < 0 ) ; <START> Assert . assertEquals ( 0 , VAR_1 . METHOD_2 ( VAR_1 ) ) ; <END> assertTrue ( VAR_2 . METHOD_2 ( VAR_1 ) > 0 ) ; } 
public synchronized String METHOD_1 ( TYPE_1 configuration ) { <START> return METHOD_2 ( configuration , null ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = new TYPE_2 ( METHOD_2 ( ) ) ; VAR_3 . remove ( VAR_3 . METHOD_3 ( ) - 1 ) ; VAR_3 . add ( VAR_2 ) ; <START> VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( TYPE_3 . VAR_5 ) ; <END> } 
protected void METHOD_1 ( ) { METHOD_2 ( METHOD_3 ( ) ) ; METHOD_4 ( ) . METHOD_5 ( TYPE_5 . TYPE_6 ) ; METHOD_4 ( ) . METHOD_6 ( VAR_3 ) ; METHOD_7 ( ) ; TYPE_1 VAR_4 = TYPE_1 . from ( TYPE_3 < Integer > getValue ( TYPE_4 . TYPE_1 ) ) ; <START> TYPE_2 . getInstance ( ) . METHOD_8 ( STRING_1 , VAR_4 ) ; <END> METHOD_9 ( true ) ; } 
public TYPE_1 ( String VAR_1 ) { VAR_2 = true ; VAR_3 = TYPE_4 . TYPE_5 ; METHOD_1 ( true ) ; METHOD_2 ( TYPE_2 . TYPE_6 ) ; VAR_8 = TYPE_3 . VAR_10 ; VAR_11 = false ; VAR_12 = TYPE_2 . TYPE_6 ; VAR_13 = TYPE_2 . TYPE_6 ; VAR_14 = new ArrayList < TYPE_1 > ( ) ; <START> VAR_15 = VAR_1 ; <END> } 
public void METHOD_1 ( TYPE_1 req , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws IOException , TYPE_4 { METHOD_2 ( req ) ; if ( ! VAR_3 . isEmpty ( ) ) { METHOD_3 ( ( TYPE_5 ) req , ( TYPE_6 ) VAR_1 , VAR_2 ) ; } <START> VAR_2 . METHOD_1 ( req , VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 request , TYPE_2 response , TYPE_3 VAR_1 ) throws IOException , TYPE_4 { TYPE_5 req = ( TYPE_5 ) request ; <START> TYPE_6 session = req . VAR_2 ( false ) ; <END> if ( ( req . VAR_3 ( STRING_1 ) != null ) ) { if ( session != null ) { session . VAR_4 ( ) ; session = null ; } } VAR_1 . METHOD_1 ( request , response ) ; } 
<START> public TYPE_1 METHOD_1 ( String id ) { <END> return METHOD_2 ( new TYPE_2 ( id , METHOD_3 ( id ) ) ) ; } 
protected boolean METHOD_1 ( ) { <START> return TYPE_1 . VAR_2 . equals ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> } 
protected void METHOD_1 ( ) { String VAR_1 = getParameters ( ) . METHOD_2 ( ) ; result = METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; TYPE_1 entity = result . VAR_2 ( ) ; entity . VAR_3 ( new Date ( ) ) ; entity . VAR_4 ( new Date ( ) ) ; <START> METHOD_5 ( ) ; <END> METHOD_6 ( entity ) ; } 
public void METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) . size ( ) ; VAR_3 . METHOD_3 ( STRING_1 ) ; VAR_3 . METHOD_4 ( STRING_2 ) ; <START> int VAR_4 = VAR_2 . METHOD_2 ( ) . size ( ) ; <END> VAR_2 . METHOD_5 ( VAR_3 ) ; TYPE_1 result = VAR_2 . get ( VAR_3 . getId ( ) ) ; assertEquals ( VAR_3 , result ) ; assertEquals ( 0 , VAR_4 - VAR_1 ) ; } 
public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } <START> super . equals ( obj ) ; <END> TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( VAR_1 . METHOD_1 ( ) == null ) { return false ; } if ( ! ( TYPE_2 . METHOD_2 ( METHOD_1 ( ) , VAR_1 . METHOD_1 ( ) ) ) ) { return false ; } return true ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( VAR_1 . getStatus ( ) != null && VAR_1 . getStatus ( ) . METHOD_3 ( ) ) { new TYPE_1 ( TYPE_4 . VAR_4 , <START> String . format ( STRING_1 , TYPE_5 . TYPE_3 ) ) ; <END> } return TYPE_1 . VAR_7 ; } 
protected void METHOD_1 ( ) { <START> final TYPE_1 VAR_1 = METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( Guid . VAR_2 ( ) ) ; VAR_1 . METHOD_4 ( TYPE_2 . TYPE_3 ) ; Guid VAR_5 = VAR_1 . METHOD_5 ( ) ; Guid VAR_6 = VAR_5 == null ? METHOD_6 ( ) . METHOD_7 ( ) . getId ( ) : VAR_5 ; VAR_1 . METHOD_8 ( VAR_6 ) ; METHOD_9 ( ) . METHOD_10 ( VAR_1 ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . VAR_2 = new TYPE_2 ( ) { @Override public Object METHOD_2 ( Object source , TYPE_1 VAR_3 ) { List < String > results = new ArrayList < String > ( ) ; for ( TYPE_3 VAR_4 : source != null ? ( Collection < TYPE_3 > ) source : new <START> ArrayList < TYPE_3 > ( ) ) <END> { results . add ( VAR_4 . METHOD_3 ( ) ) ; } return results ; } } ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 == null ? "" : VAR_1 . METHOD_2 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { if ( getParameters ( ) . METHOD_1 ( ) != null ) { VAR_1 = getParameters ( ) . METHOD_1 ( ) ; } <START> else if ( getParameters ( ) . METHOD_2 ( ) != null ) { <END> VAR_1 = METHOD_3 ( ) . get ( getParameters ( ) . METHOD_2 ( ) ) ; } else { log . error ( STRING_1 ) ; } } return VAR_1 ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return true ; <END> } 
public static String METHOD_1 ( TYPE_1 host ) { <START> return host . VAR_1 ( ) + STRING_1 + new String ( TYPE_2 . METHOD_2 ( host . getId ( ) . METHOD_3 ( ) ) ) . substring ( 0 , INT_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> METHOD_2 ( new TYPE_2 ( ) ) ; <END> return this ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 parameters , TYPE_4 context ) { TYPE_5 < ? > command = <START> context != null ? TYPE_6 . METHOD_2 ( VAR_1 , parameters , context . VAR_2 ( ) ) : <END> TYPE_6 . METHOD_2 ( VAR_1 , parameters ) ; return command . VAR_3 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return ; } <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_1 . getId ( ) != TYPE_3 . TYPE_4 ) ; <END> } 
public static Map < String , Object > METHOD_1 ( String VAR_1 ) throws TYPE_1 , TYPE_2 , IOException { final TYPE_3 VAR_2 = new TYPE_3 ( ) ; final TYPE_4 type = VAR_2 . METHOD_2 ( ) . METHOD_3 ( Map . VAR_3 , String . VAR_3 , Object . VAR_3 ) ; final Map < String , Object > data = VAR_2 . METHOD_4 ( VAR_1 , type ) ; <START> return data ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( ) ) { TYPE_1 VAR_2 = ( TYPE_1 ) METHOD_3 ( ) ; if ( ! TYPE_2 . equals ( VAR_2 . METHOD_4 ( ) , VAR_1 . METHOD_4 ( ) ) ) { METHOD_5 ( ) . METHOD_6 ( VAR_1 . getId ( ) , VAR_1 . METHOD_7 ( ) . get ( 0 ) , <START> VAR_1 . METHOD_8 ( ) . get ( 0 ) ) ; <END> } } } 
public void METHOD_1 ( ) { TYPE_1 TYPE_1 = VAR_1 . METHOD_2 ( VAR_2 ) . get ( 0 ) ; assertThat ( STRING_1 , <START> TYPE_1 . METHOD_3 ( ) , METHOD_4 ( METHOD_5 ( Guid . VAR_3 ( ) ) ) ) ; <END> VAR_1 . METHOD_6 ( VAR_4 , VAR_5 , TYPE_2 . VAR_7 ) ; TYPE_1 = VAR_1 . METHOD_2 ( VAR_2 ) . get ( 0 ) ; assertEquals ( STRING_2 , TYPE_1 . METHOD_3 ( ) , TYPE_2 . VAR_7 ) ; } 
protected boolean METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> Map < TYPE_1 , Guid > map = new HashMap < > ( ) ; for ( TYPE_1 VAR_2 : VAR_1 . values ( ) ) { map . put ( VAR_2 , VAR_2 . METHOD_2 ( ) . get ( 0 ) ) ; } return METHOD_3 ( TYPE_2 . METHOD_1 ( map ) ) ; } return true ; } 
protected boolean METHOD_1 ( ) { Map < TYPE_1 , Guid > map = new HashMap < > ( ) ; <START> if ( VAR_1 != null ) { <END> for ( TYPE_1 VAR_2 : VAR_1 . values ( ) ) { map . put ( VAR_2 , VAR_2 . METHOD_2 ( ) . get ( 0 ) ) ; } } return METHOD_3 ( TYPE_2 . METHOD_1 ( map ) ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> this ( VAR_2 . getId ( ) ) ; <END> this . VAR_2 = VAR_2 ; } 
<START> public void close ( ) throws IOException { <END> VAR_1 . close ( ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 parameters ) throws TYPE_4 { <START> parameters . VAR_2 ( METHOD_2 ( ) ) ; <END> return METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_1 , parameters ) ; } 
private void METHOD_1 ( ) { if ( ! VAR_1 ) { <START> synchronized ( VAR_2 ) { <END> if ( ! VAR_1 ) { for ( TYPE_1 VAR_3 : VAR_4 . METHOD_2 ( ) ) { switch ( VAR_3 . METHOD_3 ( ) ) { case VAR_5 : case VAR_6 : VAR_4 . METHOD_4 ( VAR_3 . getId ( ) ) . METHOD_5 ( TYPE_2 . VAR_8 ) ; break ; default : if ( ! VAR_3 . METHOD_6 ( ) ) { METHOD_7 ( VAR_3 ) ; } break ; } } VAR_1 = true ; } } } } 
public void METHOD_1 ( ) { Collection < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_2 VAR_2 = METHOD_4 ( ) ; if ( VAR_1 != null && VAR_2 != null ) { Guid VAR_3 = VAR_2 . METHOD_5 ( ) ; <START> if ( VAR_3 != null ) { <END> for ( TYPE_1 VAR_4 : VAR_1 ) { if ( VAR_3 . equals ( VAR_4 . getId ( ) ) ) { METHOD_2 ( ) . METHOD_6 ( VAR_4 ) ; break ; } } } } } 
public TYPE_2 ( ) { super ( new TYPE_1 < String > ( ) { @Override public String METHOD_1 ( String value ) { <START> String VAR_2 = super . METHOD_1 ( value ) ; <END> return VAR_2 ; } } ) ; } 
public void remove ( ) { if ( METHOD_1 ( ) != null ) { return ; } <START> TYPE_1 model = METHOD_2 ( ) ; <END> METHOD_3 ( model ) ; } 
public void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { return ; } final TYPE_1 < T , TYPE_2 > VAR_1 = METHOD_3 ( ) ; METHOD_4 ( VAR_1 ) ; <START> VAR_1 . METHOD_5 ( ) . METHOD_6 ( Arrays . asList ( METHOD_7 ( ) ) ) ; <END> VAR_1 . METHOD_5 ( ) . METHOD_8 ( METHOD_7 ( ) ) ; } 
protected void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 , this ) ; <END> VAR_1 . METHOD_2 ( TYPE_2 . getInstance ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) ; VAR_1 . METHOD_5 ( true ) ; METHOD_6 ( ) . add ( VAR_1 ) ; TYPE_1 VAR_2 = new TYPE_1 ( STRING_2 , this ) ; VAR_2 . METHOD_2 ( TYPE_2 . getInstance ( ) . METHOD_3 ( ) . METHOD_7 ( ) ) ; VAR_2 . METHOD_8 ( true ) ; METHOD_6 ( ) . add ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 , TYPE_3 > object ) { VAR_1 . METHOD_1 ( object . VAR_2 ( ) ) ; <START> VAR_3 . METHOD_1 ( object ) ; <END> } 
<START> static String METHOD_1 ( ) { <END> return STRING_1 ; } 
private void METHOD_1 ( ) { <START> if ( VAR_1 || VAR_2 ) { <END> return ; } VAR_1 = true ; TYPE_1 . get ( ) . METHOD_2 ( new TYPE_1 . TYPE_3 ( ) { @Override public boolean execute ( ) { if ( VAR_3 > VAR_4 || VAR_2 ) { VAR_1 = false ; return false ; } VAR_3 ++ ; METHOD_3 ( ) ; return true ; } } , VAR_5 ) ; } 
private void METHOD_1 ( ) { <START> if ( VAR_1 && VAR_2 . trim ( ) . isEmpty ( ) ) { <END> return ; } if ( VAR_3 ) { return ; } VAR_3 = true ; TYPE_1 . get ( ) . METHOD_2 ( new TYPE_1 . TYPE_3 ( ) { @Override public boolean execute ( ) { if ( VAR_4 > VAR_5 || VAR_6 ) { VAR_3 = false ; return false ; } VAR_4 ++ ; METHOD_3 ( ) ; return true ; } } , VAR_7 ) ; } 
protected void METHOD_1 ( TYPE_1 request , TYPE_2 response ) throws TYPE_3 , IOException { String VAR_1 = request . VAR_2 ( ) ; if ( StringUtils . VAR_3 ( VAR_1 ) ) { if ( url . VAR_4 ( STRING_1 ) == - 1 ) { url += STRING_1 ; } else { url += STRING_2 ; } url += VAR_1 ; } <START> response . VAR_5 ( response . VAR_6 ( url ) ) ; <END> } 
<START> private void METHOD_1 ( ) { <END> VAR_1 = true ; TYPE_1 . get ( ) . METHOD_2 ( new TYPE_1 . TYPE_3 ( ) { @Override public boolean execute ( ) { if ( VAR_2 > VAR_3 || VAR_4 ) { VAR_1 = false ; return false ; } VAR_2 ++ ; METHOD_3 ( ) ; return true ; } } , VAR_5 ) ; } 
protected List < Guid > METHOD_1 ( TYPE_1 parameters ) { <START> return ( ArrayList < Guid > ) METHOD_2 ( TYPE_3 . TYPE_2 , parameters ) . METHOD_3 ( ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( null ) ; METHOD_3 ( cmd . VAR_1 ( ) ) ; <START> Assert . assertTrue ( cmd . VAR_2 ( ) <END> . METHOD_4 ( ) . contains ( TYPE_2 . TYPE_3 . toString ( ) ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; METHOD_4 ( VAR_1 ) ; when ( VAR_2 . METHOD_5 ( VAR_3 , VAR_4 ) ) . METHOD_6 ( VAR_1 ) ; METHOD_7 ( cmd . VAR_5 ( ) ) ; <START> Assert . assertTrue ( cmd . VAR_6 ( ) <END> . METHOD_8 ( ) . contains ( TYPE_3 . TYPE_4 . toString ( ) ) ) ; } 
private void METHOD_1 ( ) { try { VAR_1 = new String ( TYPE_1 . METHOD_2 ( TYPE_2 . get ( VAR_2 ) ) ) ; <START> } catch ( IOException e ) { <END> e . VAR_3 ( ) ; } } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> TYPE_1 params = new TYPE_1 ( ) ; params . VAR_1 ( VAR_2 ) ; params . VAR_3 ( VAR_4 ) ; params . VAR_5 ( VAR_6 ) ; params . VAR_7 ( true ) ; return params ; } 
protected boolean METHOD_1 ( ) { VAR_1 = getParameters ( ) ; if ( VAR_1 == null || VAR_1 . METHOD_2 ( ) == null || VAR_1 . METHOD_3 ( ) == null || VAR_1 . METHOD_4 ( ) == null ) { return false ; } VAR_2 = METHOD_5 ( ) . METHOD_6 ( VAR_1 . METHOD_2 ( ) ) ; <START> if ( VAR_2 . getStatus ( ) == TYPE_1 . VAR_4 ) { <END> return false ; } return true ; } 
public TYPE_1 ( Guid VAR_2 , List < String > VAR_3 ) { <START> this ( VAR_2 , VAR_3 , STRING_1 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 . getInstance ( ) . getInstance ( ) . METHOD_2 ( new TYPE_2 ( this , <START> new TYPE_3 ( ) { <END> @Override public void METHOD_3 ( Object target , Object VAR_1 ) { TYPE_4 VAR_2 = ( TYPE_4 ) target ; VAR_2 . METHOD_4 ( ( Integer ) VAR_1 ) ; VAR_2 . METHOD_5 ( ) ; } } ) ) ; } 
protected void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class . getName ( ) ) ; List < String > VAR_2 = new ArrayList < > ( VAR_1 . size ( ) ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_2 . add ( TYPE_3 . getName ( VAR_3 ) ) ; } if ( getParameters ( ) . METHOD_4 ( ) ) { <START> VAR_2 . remove ( VAR_4 ) ; <END> } METHOD_5 ( VAR_2 ) ; METHOD_6 ( ) . METHOD_7 ( VAR_2 ) ; } 
<START> private List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 ) { <END> List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; VAR_3 . addAll ( VAR_1 ) ; VAR_3 . addAll ( VAR_2 ) ; return VAR_3 ; } 
protected TYPE_1 METHOD_1 ( ) { <START> if ( null == VAR_1 ) { <END> VAR_1 = METHOD_2 ( ) ; } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { <START> if ( null == VAR_1 ) { <END> TYPE_2 VAR_2 = TYPE_3 . getInstance ( ) . METHOD_2 ( ) . get ( VAR_3 ) ; VAR_1 = TYPE_4 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) ; <END> try { TYPE_3 . METHOD_3 ( METHOD_4 ( ) ) ; } finally { TYPE_2 . METHOD_5 ( VAR_1 ) ; } } 
public TYPE_4 ( TYPE_1 VAR_2 , String ... VAR_3 ) { <START> matcher = TYPE_2 . METHOD_1 ( <END> METHOD_2 ( METHOD_3 ( ) ) , new TYPE_3 ( VAR_2 ) , METHOD_4 ( VAR_3 ) ) ; } 
public TYPE_2 ( TYPE_1 message , String ... VAR_2 ) { if ( message == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } this . message = message ; <START> this . VAR_2 = VAR_2 == null <END> ? null : Collections . VAR_3 ( Arrays . asList ( VAR_2 ) ) ; } 
protected void METHOD_1 ( String VAR_1 , TYPE_1 query ) { TYPE_2 . getInstance ( ) . METHOD_2 ( TYPE_5 . TYPE_7 , <START> new TYPE_3 ( STRING_1 + ( ( TYPE_4 ) METHOD_3 ( ) . METHOD_4 ( ) ) . METHOD_5 ( ) + STRING_2 + VAR_1 , TYPE_8 . TYPE_6 , ( String ) METHOD_6 ( ) . METHOD_4 ( ) ) , query ) ; <END> } 
public List METHOD_1 ( ) { List VAR_1 = METHOD_2 ( ) ; VAR_1 . add ( STRING_1 ) ; <START> VAR_1 . add ( STRING_2 ) ; <END> VAR_1 . add ( STRING_3 ) ; VAR_1 . add ( STRING_4 ) ; VAR_1 . add ( STRING_5 ) ; VAR_1 . add ( STRING_6 ) ; VAR_1 . add ( STRING_7 ) ; VAR_1 . add ( STRING_7 ) ; VAR_1 . add ( STRING_8 ) ; VAR_1 . add ( STRING_9 ) ; VAR_1 . add ( STRING_10 ) ; return VAR_1 ; } 
<START> protected static <END> void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 context , List < TYPE_3 > VAR_2 ) { TYPE_4 builder = new TYPE_4 ( VAR_1 , context ) ; ArrayList < TYPE_5 > parameters = builder . VAR_3 ( VAR_2 ) ; if ( ! parameters . isEmpty ( ) ) { TYPE_6 . METHOD_2 ( parameters ) ; TYPE_7 . getInstance ( ) . METHOD_3 ( TYPE_8 . TYPE_9 , parameters , context ) ; } } 
public void METHOD_1 ( ) { TYPE_1 query = new TYPE_1 ( ) ; query . VAR_1 ( true ) ; <START> query . VAR_2 ( this ) ; <END> query . VAR_3 = new TYPE_2 ( ) { @Override public void METHOD_2 ( Object model , Object TYPE_6 ) { TYPE_4 . TYPE_5 . METHOD_3 ( ) ; } } ; VAR_5 . METHOD_4 ( VAR_5 . METHOD_5 ( ) , query ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 < TYPE_3 > > VAR_2 ) { List < TYPE_3 > VAR_3 = new ArrayList < TYPE_3 > ( VAR_1 . METHOD_2 ( ) ) ; List < TYPE_3 > VAR_4 = VAR_3 ; for ( TYPE_2 < TYPE_3 > VAR_5 : VAR_2 ) { <START> VAR_4 = TYPE_4 . filter ( VAR_3 , VAR_5 ) ; <END> } if ( VAR_4 . size ( ) > 0 ) { return true ; } return false ; } 
private String METHOD_1 ( ) { byte [ ] VAR_1 ; TYPE_1 session = METHOD_2 ( ) . METHOD_3 ( ) ; synchronized ( session ) { if ( session . VAR_2 ( VAR_3 ) == null ) { VAR_1 = new byte [ VAR_4 ] ; VAR_5 . METHOD_4 ( VAR_1 ) ; session . VAR_6 ( VAR_3 , VAR_1 ) ; } else { VAR_1 = ( byte [ ] ) session . VAR_2 ( VAR_3 ) ; <START> } <END> } return StringUtils . VAR_7 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( METHOD_2 ( ) ) { return TYPE_1 . VAR_1 ; <START> } else { <END> return VAR_2 ? TYPE_1 . VAR_3 : TYPE_1 . VAR_4 ; } } 
public void METHOD_1 ( ) { <START> ArrayList < TYPE_1 < ? > > <END> VAR_1 = new ArrayList < TYPE_1 < ? > > ( ) ; VAR_1 . add ( VAR_2 ) ; METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; METHOD_2 ( ) . METHOD_4 ( VAR_2 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . get ( TYPE_2 . VAR_4 ) ; assertNotNull ( VAR_1 ) ; String name = VAR_1 . getName ( ) ; <START> assertTrue ( name . equals ( VAR_2 . METHOD_3 ( TYPE_2 . VAR_4 , TYPE_3 . TYPE_1 ) ) ) ; <END> } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) != null ) { TYPE_1 cluster = METHOD_2 ( ) . METHOD_3 ( ) ; boolean VAR_1 = ( cluster . VAR_2 ( ) . METHOD_4 ( TYPE_2 . VAR_4 ) >= 0 && cluster . VAR_5 ( ) <START> . METHOD_4 ( TYPE_2 . VAR_6 ) != 0 ) ; <END> METHOD_2 ( ) . METHOD_5 ( ) . METHOD_6 ( VAR_1 ) ; } } 
private TYPE_1 METHOD_1 ( Guid VAR_1 , TYPE_2 VAR_2 , TYPE_3 parameters ) { <START> TYPE_1 VAR_3 = Guid . VAR_4 ( VAR_1 ) ? null : VAR_5 . METHOD_2 ( VAR_1 ) ; <END> if ( VAR_3 == null ) { VAR_3 = VAR_5 . METHOD_3 ( VAR_1 , VAR_2 , parameters ) ; if ( ! Guid . VAR_4 ( VAR_1 ) ) { VAR_3 . METHOD_4 ( TYPE_4 . VAR_7 ) ; VAR_5 . METHOD_5 ( VAR_3 ) ; } } return VAR_3 ; } 
private boolean METHOD_1 ( String VAR_1 ) { <START> for ( TYPE_1 VAR_2 : TYPE_1 . values ( ) ) { <END> if ( VAR_2 . name ( ) . equals ( VAR_1 ) ) { return true ; } } return false ; } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public void METHOD_1 ( ) { <END> TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . get ( getParameters ( ) . getId ( ) ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_4 ( ) . addAll ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_5 ( VAR_1 . getId ( ) ) ) ; VAR_1 . METHOD_6 ( ) . addAll ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_7 ( VAR_1 . getId ( ) ) ) ; METHOD_8 ( ) . METHOD_9 ( VAR_1 ) ; } } 
<START> boolean METHOD_1 ( ) { <END> Boolean VAR_1 = getParameters ( ) . METHOD_1 ( ) ; return VAR_1 != null ? VAR_1 : TYPE_1 . METHOD_1 ( METHOD_2 ( ) ) ; } 
public void METHOD_1 ( ) { <START> if ( METHOD_2 ( ) != null ) <END> super . METHOD_1 ( ) ; } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) == null ) { return ; } else { METHOD_3 ( null ) ; <START> } <END> } 
public boolean METHOD_1 ( String VAR_1 ) { <START> return ( VAR_1 != null && VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ) ; <END> } 
public boolean METHOD_1 ( String VAR_1 ) { <START> return ( VAR_1 == null || ! VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ) ? <END> false : true ; } 
<START> public static boolean METHOD_1 ( String VAR_1 ) { <END> return ( VAR_1 == null || ! VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ) ? false : true ; } 
private static int METHOD_1 ( String VAR_1 ) { String [ ] VAR_2 = VAR_1 . split ( STRING_1 ) ; int output = 0 ; int VAR_3 ; <START> for ( int index = 3 ; index > - 1 ; index -- ) { <END> VAR_3 = Integer . parseInt ( VAR_2 [ 3 - index ] ) ; VAR_3 <<= ( index * INT_1 ) ; output |= VAR_3 ; } return output ; } 
public TYPE_1 ( String VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; } 
public TYPE_1 METHOD_1 ( Object value ) { <START> assert value instanceof String ; <END> String VAR_1 = ( String ) value ; TYPE_1 result = new TYPE_1 ( ) ; if ( ! TYPE_2 . METHOD_2 ( VAR_1 ) ) { return METHOD_3 ( result , METHOD_4 ( ) ) ; } else if ( ! TYPE_2 . METHOD_5 ( VAR_1 ) ) { return METHOD_3 ( result , METHOD_6 ( ) ) ; } else { result . VAR_2 ( true ) ; return result ; } } 
public void METHOD_1 ( String VAR_1 ) { <START> this . VAR_1 = ( ( VAR_1 == null || VAR_1 . length ( ) == 0 ) ? null : VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( new TYPE_2 < Object > ( ) { @Override public Object METHOD_3 ( ) { <START> TYPE_3 VAR_1 = db ( ) . METHOD_4 ( ) . get ( id ) ; <END> VAR_1 . METHOD_5 ( TYPE_4 . TYPE_5 ) ; update ( VAR_1 ) ; return null ; } } ) ; } 
<START> protected void METHOD_1 ( ) { <END> METHOD_2 ( TYPE_1 . VAR_2 ) ; } 
protected boolean METHOD_1 ( ) { <START> METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> if ( ! super . METHOD_1 ( ) ) { return false ; } if ( METHOD_3 ( ) . getStatus ( ) == TYPE_1 . VAR_2 ) { return METHOD_5 ( TYPE_2 . VAR_4 ) ; } return false ; } 
<START> public synchronized ArrayList METHOD_1 ( ) { <END> return VAR_1 ; } 
public Map METHOD_1 ( String VAR_1 ) { final TYPE_1 host = METHOD_2 ( ) ; Map VAR_2 = METHOD_3 ( ) ; List VAR_3 = new ArrayList ( ) ; <START> TYPE_2 vm = host . VAR_4 ( ) . get ( VAR_1 ) ; <END> VAR_3 . add ( METHOD_4 ( vm ) ) ; VAR_2 . put ( STRING_1 , VAR_3 ) ; Utils . VAR_5 ( ) ; return VAR_2 ; } 
<START> public static Map METHOD_1 ( String message , int VAR_1 ) { <END> Map VAR_2 = new HashMap ( ) ; Map VAR_3 = new HashMap ( ) ; VAR_3 . put ( STRING_1 , message ) ; VAR_3 . put ( STRING_2 , Integer . valueOf ( VAR_1 ) ) ; VAR_2 . put ( STRING_3 , VAR_3 ) ; return VAR_2 ; } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( TYPE_2 . VAR_4 , null ) ; <START> assertTrue ( STRING_1 , ! VAR_1 . isEmpty ( ) ) ; <END> assertEquals ( STRING_2 , 2 , VAR_1 . size ( ) ) ; } 
public void METHOD_1 ( ) { log . info ( STRING_1 ) ; TYPE_1 . getInstance ( ) . METHOD_2 ( VAR_1 ) ; TYPE_2 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <START> if ( TYPE_3 . class . METHOD_5 ( VAR_2 ) ) { <END> ( ( TYPE_3 ) VAR_2 ) . close ( ) ; } } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , Integer VAR_3 ) { <END> List < Integer > VAR_4 = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < VAR_2 ; j ++ , VAR_3 ++ ) { VAR_4 . add ( VAR_3 ) ; } VAR_1 . METHOD_2 ( VAR_4 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { try { <START> return new TYPE_1 ( VAR_4 . METHOD_1 ( VAR_1 , VAR_3 , VAR_3 ) ) ; <END> } catch ( TYPE_2 VAR_5 ) { throw new TYPE_3 ( VAR_5 ) ; } } 
<START> protected Map < String , Pair < String , String > > METHOD_1 ( ) { <END> if ( ! METHOD_2 ( ) ) { return Collections . VAR_1 ( METHOD_3 ( ) . getId ( ) . toString ( ) , TYPE_1 . METHOD_4 ( TYPE_2 . VAR_3 , TYPE_3 . VAR_5 ) ) ; } return super . METHOD_1 ( ) ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 params = new TYPE_1 ( getParameters ( ) . METHOD_2 ( ) , getParameters ( ) . METHOD_3 ( ) ) ; params . VAR_1 ( getParameters ( ) . METHOD_4 ( ) ) ; params . VAR_2 ( getParameters ( ) . METHOD_5 ( ) ) ; <START> params . VAR_1 ( getParameters ( ) . METHOD_4 ( ) ) ; <END> params . VAR_3 ( getParameters ( ) . METHOD_6 ( ) ) ; return params ; } 
protected TYPE_1 METHOD_1 ( ) { if ( config != null ) { <START> new TYPE_1 ( <END> ( String ) TYPE_2 . getInstance ( ) . METHOD_2 ( TYPE_4 . TYPE_3 ) , METHOD_3 ( ) ) ; } return config ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return METHOD_2 ( ) . METHOD_3 ( STRING_1 , VAR_1 , METHOD_4 ( ) . METHOD_5 ( STRING_2 , null ) . METHOD_5 ( STRING_3 , false ) ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 = METHOD_2 ( TYPE_1 . class ) ; <END> VAR_2 = new TYPE_2 ( VAR_1 ) ; VAR_3 = new TYPE_2 ( null ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_2 == null ) { <END> TYPE_3 VAR_3 = METHOD_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) . get ( 0 ) , VAR_1 . METHOD_5 ( ) ) ; VAR_2 = new TYPE_1 ( VAR_3 ) ; } return VAR_2 ; } 
private boolean METHOD_1 ( ) { <START> if ( ! METHOD_2 ( METHOD_3 ( ) . METHOD_1 ( ) ) ) { <END> return false ; } return true ; } 
public void METHOD_1 ( ) throws IOException { <START> String VAR_1 = null ; <END> VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 , null ) ; assertTrue ( STRING_2 , VAR_1 . equals ( STRING_3 ) ) ; } 
private static void METHOD_1 ( ) { TYPE_1 [ ] values = TYPE_1 . values ( ) ; if ( values . length != VAR_1 . size ( ) ) { for ( TYPE_1 value : values ) { if ( ! VAR_1 . containsKey ( value ) ) { <START> log . info ( STRING_1 , value . toString ( ) ) ; <END> } } } } 
public TYPE_8 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_2 , TYPE_4 VAR_3 ) { super ( VAR_2 ) ; this . VAR_4 = new TYPE_5 ( VAR_2 , VAR_3 ) ; VAR_5 = TYPE_6 . METHOD_1 ( ) ; METHOD_2 ( TYPE_7 . VAR_7 . METHOD_3 ( this ) ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; <START> this . VAR_4 . METHOD_6 ( ) ; <END> } 
public static TYPE_1 map ( TYPE_2 entity , TYPE_1 VAR_1 ) { try { return TYPE_1 . valueOf ( entity ) ; } catch ( IllegalArgumentException e ) { log . error ( STRING_1 , entity , TYPE_1 . class . getName ( ) , e . getMessage ( ) ) ; <START> log . debug ( STRING_2 , e ) ; <END> return null ; } } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; for ( TYPE_1 cluster : VAR_1 ) { <START> METHOD_4 ( cluster , null ) ; <END> } } 
public int METHOD_1 ( ) { int result = TYPE_1 . METHOD_1 ( id ) ; <START> return result ; <END> } 
public boolean equals ( Object obj ) { if ( this == obj ) <START> return true ; <END> if ( this == obj ) { return true ; } if ( ! ( obj instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return TYPE_2 . equals ( VAR_2 , VAR_1 . VAR_2 ) && TYPE_2 . equals ( VAR_3 , VAR_1 . VAR_3 ) ; } 
public String METHOD_1 ( int VAR_1 , TYPE_1 version ) { <START> return TYPE_2 . getInstance ( ) . METHOD_2 ( METHOD_3 ( VAR_2 . get ( VAR_1 ) , STRING_1 , version ) ) ; <END> } 
<START> protected void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( StringUtils . isEmpty ( VAR_1 . METHOD_2 ( ) ) && METHOD_3 ( ) . METHOD_4 ( ) > 0 ) { VAR_1 . METHOD_5 ( METHOD_3 ( ) . METHOD_6 ( ) ) ; } } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 ) { super ( VAR_2 , VAR_3 ) ; this . VAR_5 = VAR_5 ; this . VAR_4 = VAR_4 ; this . VAR_6 = VAR_6 ; <START> METHOD_1 ( ) ; <END> METHOD_2 ( TYPE_6 . VAR_8 . METHOD_3 ( this ) ) ; TYPE_8 . VAR_10 . METHOD_4 ( this ) ; METHOD_5 ( ) ; VAR_11 . METHOD_6 ( this ) ; METHOD_7 ( VAR_4 . METHOD_8 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , Guid VAR_2 ) { VAR_1 . VAR_3 = new TYPE_2 ( ) { @Override public Object METHOD_2 ( Object source , TYPE_1 VAR_4 ) { <START> return source != null ? source : null ; <END> } } ; TYPE_3 . getInstance ( ) . METHOD_3 ( TYPE_5 . TYPE_6 , new TYPE_4 ( VAR_2 ) , VAR_1 ) ; } 
private void METHOD_1 ( ) { boolean VAR_1 = true ; if ( METHOD_2 ( ) == null || METHOD_2 ( ) . getStatus ( ) == TYPE_1 . VAR_3 ) { VAR_1 = false ; } METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; <START> boolean VAR_4 = false ; <END> if ( METHOD_2 ( ) != null && METHOD_2 ( ) . getStatus ( ) == TYPE_1 . VAR_5 && METHOD_2 ( ) . METHOD_5 ( ) ) { VAR_4 = true ; } METHOD_6 ( ) . METHOD_4 ( VAR_4 ) ; } 
public void METHOD_1 ( final TYPE_1 object ) { VAR_1 . METHOD_1 ( object ) ; VAR_2 . METHOD_2 ( object . VAR_3 ( ) . METHOD_3 ( ) ) ; <START> object . VAR_3 ( ) . METHOD_4 ( ) . METHOD_5 ( new TYPE_2 < TYPE_3 > ( ) { <END> @Override public void METHOD_6 ( TYPE_4 < ? extends TYPE_3 > VAR_4 , Object VAR_5 , TYPE_3 args ) { VAR_2 . METHOD_2 ( object . VAR_3 ( ) . METHOD_3 ( ) ) ; } } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <START> METHOD_2 ( ) ; <END> if ( VAR_1 != null && VAR_1 . METHOD_3 ( ) ) { METHOD_4 ( null ) ; } } 
public void METHOD_1 ( ) { assertEquals ( STRING_1 + VAR_1 , <START> VAR_2 && VAR_3 , TYPE_1 . getInstance ( ) . METHOD_2 ( VAR_1 ) ) ; <END> } 
public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { STRING_1 , INT_1 } , { STRING_2 , INT_2 } , { STRING_3 , INT_3 } , { STRING_4 , INT_4 } , { STRING_5 , INT_5 } , <START> { STRING_6 , INT_6 } , <END> { STRING_7 , INT_7 } , { STRING_2 , INT_2 } , } ) ; } 
public Collection < Guid > METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = Collections . VAR_2 ( ) ; } <START> return new ArrayList < Guid > ( VAR_1 ) ; <END> } 
<START> protected void METHOD_1 ( TYPE_1 ... VAR_1 ) { <END> for ( TYPE_1 msg : VAR_1 ) { METHOD_2 ( msg ) ; } } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> VAR_1 . METHOD_2 ( TYPE_3 . VAR_4 , <END> String . valueOf ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ) ; } 
<START> protected void METHOD_1 ( ArrayList < TYPE_1 > VAR_1 ) { <END> if ( METHOD_2 ( VAR_1 ) ) { if ( VAR_2 ) { METHOD_3 ( ) ; } else { METHOD_1 ( ) ; } } } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_2 VAR_2 = ( TYPE_2 ) METHOD_4 ( ) . METHOD_3 ( ) ; TYPE_3 vds = new TYPE_3 ( ) ; if ( VAR_1 != null && VAR_2 != null ) { <START> vds . VAR_3 ( VAR_1 . getName ( ) + STRING_1 + VAR_2 . METHOD_5 ( ) ) ; <END> vds . VAR_4 ( VAR_1 . METHOD_6 ( ) ) ; } METHOD_7 ( vds , null , false , null ) ; } 
private void METHOD_1 ( ) { METHOD_2 ( new TYPE_1 < String > ( ) ) ; METHOD_3 ( new TYPE_1 < String > ( ) ) ; METHOD_4 ( new TYPE_1 < String > ( ) ) ; METHOD_5 ( new TYPE_1 < Boolean > ( ) ) ; <START> METHOD_6 ( "" ) ; <END> METHOD_7 ( ) . METHOD_8 ( false ) ; } 
public void METHOD_1 ( final TYPE_1 object ) { VAR_1 . METHOD_1 ( object ) ; <START> VAR_2 . METHOD_2 ( object . VAR_3 ( ) == null ? VAR_4 . METHOD_3 ( ) : object . getMessage ( ) ) ; <END> VAR_5 . setText ( object . getMessage ( ) == null ? VAR_4 . METHOD_3 ( ) : object . getMessage ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( true ) ; <END> TYPE_2 . getInstance ( ) . METHOD_3 ( TYPE_4 . TYPE_5 , new TYPE_3 ( ) , VAR_1 ) ; } 
<START> private static List < String > METHOD_1 ( ) { <END> return Arrays . asList ( TYPE_2 < String > getValue ( TYPE_3 . TYPE_1 ) . split ( STRING_1 ) ) ; } 
private void METHOD_1 ( ) { TYPE_1 vds = METHOD_2 ( ) ; <START> METHOD_3 ( ) . METHOD_4 ( TYPE_3 . TYPE_4 . equals ( vds . getStatus ( ) ) ) ; <END> } 
private void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null ) { TYPE_2 VAR_3 = new TYPE_2 ( METHOD_3 ( VAR_1 , false ) ) ; <START> VAR_3 . METHOD_4 ( VAR_1 ) ; <END> VAR_2 . VAR_4 . put ( VAR_5 , METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( VAR_3 ) ) ; } } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { <START> VAR_1 . METHOD_2 ( ) ; <END> boolean VAR_2 = TYPE_2 . matcher ( VAR_1 ) . METHOD_3 ( ) ; if ( ! VAR_2 ) { return new TYPE_1 ( false , STRING_1 + VAR_1 + STRING_2 ) ; } else { return new TYPE_1 ( true ) ; } } 
protected void <START> METHOD_1 ( ) <END> { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_2 . METHOD_3 ( ) != null ) { METHOD_4 ( VAR_2 . METHOD_3 ( ) ) ; } } } 
protected boolean METHOD_1 ( ) { return METHOD_2 ( ) && METHOD_3 ( ) && METHOD_4 ( ) && METHOD_5 ( ) && METHOD_6 ( ) && METHOD_7 ( ) && METHOD_8 ( ) && METHOD_9 ( ) && METHOD_10 ( ) && METHOD_11 ( ) && METHOD_12 ( ) && METHOD_13 ( ) && METHOD_14 ( ) <START> && METHOD_15 ( ) ; <END> } 
protected boolean METHOD_1 ( ) { if ( getParameters ( ) . METHOD_2 ( ) . isEmpty ( ) ) { return METHOD_3 ( TYPE_1 . VAR_2 ) ; <START> } else { <END> return METHOD_4 ( ) ; } } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; <END> assertEquals ( true , VAR_1 . METHOD_3 ( ) ) ; when ( VAR_4 . get ( VAR_2 ) ) . METHOD_4 ( METHOD_5 ( ) ) ; TYPE_2 parameters = METHOD_6 ( ) ; parameters . VAR_5 ( ) . METHOD_7 ( true ) ; METHOD_8 ( parameters , Collections . VAR_6 ( METHOD_9 ( TYPE_6 . TYPE_5 ) ) ) ; TYPE_3 . METHOD_10 ( command , TYPE_4 . VAR_10 ) ; } 
private void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = Collections . VAR_2 ( VAR_3 ) ; TYPE_2 VAR_4 = METHOD_2 ( TYPE_2 . class ) ; when ( VAR_4 . METHOD_3 ( VAR_5 ) ) . METHOD_4 ( VAR_1 ) ; when ( METHOD_5 ( ) . METHOD_6 ( ) ) . METHOD_4 ( VAR_4 ) ; <START> TYPE_3 VAR_6 = METHOD_2 ( TYPE_3 . class ) ; <END> when ( METHOD_5 ( ) . METHOD_7 ( ) ) . METHOD_4 ( VAR_6 ) ; } 
public boolean METHOD_1 ( ) { <START> if ( getMessage ( ) . startsWith ( VAR_1 ) || getMessage ( ) . startsWith ( VAR_2 ) ) { <END> return true ; } else { return false ; } } 
private static String METHOD_1 ( TYPE_1 vds , Map < String , Map < String , Object > > VAR_1 ) { final String VAR_2 = TYPE_2 . METHOD_2 ( vds ) ; final TYPE_3 VAR_3 = METHOD_3 ( vds , VAR_2 ) ; String VAR_4 = ( VAR_3 == null ) ? null : VAR_3 . getName ( ) ; <START> final String VAR_5 = METHOD_4 ( VAR_2 , VAR_1 ) ; <END> if ( VAR_5 != null ) { VAR_4 = VAR_5 ; } return VAR_4 ; } 
private List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = ( ArrayList ) METHOD_2 ( ) . METHOD_3 ( ) ; <END> ArrayList < Guid > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_3 . METHOD_4 ( VAR_2 ) ; } return VAR_1 ; } 
public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = 1 ; result = VAR_1 * result + VAR_2 . METHOD_1 ( ) ; <START> result = VAR_1 * result + VAR_3 . METHOD_1 ( ) ; <END> result = VAR_1 * result + super . METHOD_1 ( ) ; return result ; } 
public boolean equals ( Object obj ) { return obj != null && obj instanceof TYPE_1 && TYPE_2 . METHOD_1 ( getId ( ) , ( ( TYPE_1 ) obj ) . getId ( ) ) <START> && TYPE_2 . METHOD_2 ( VAR_1 , <END> ( ( TYPE_1 ) obj ) . METHOD_3 ( ) ) && super . equals ( obj ) ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_4 : VAR_1 ) <START> if ( METHOD_2 ( VAR_4 . METHOD_3 ( ) , VAR_4 . METHOD_4 ( ) ) == null ) <END> VAR_2 . add ( VAR_4 ) ; else VAR_3 . add ( VAR_4 ) ; METHOD_5 ( VAR_2 ) ; METHOD_6 ( VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( METHOD_2 ( ) ) <END> return TYPE_1 . VAR_1 ; else return VAR_2 == null ? TYPE_1 . VAR_3 : VAR_2 ; } 
protected boolean METHOD_1 ( ) { <START> METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> return super . METHOD_1 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 model = ( TYPE_2 ) METHOD_2 ( ) ; model . VAR_2 ( ) ; if ( VAR_1 != null <START> && VAR_1 . METHOD_3 ( ) ) <END> METHOD_4 ( null ) ; } 
protected boolean METHOD_1 ( ) { String VAR_1 = ( String ) <START> this . entry . get ( STRING_1 ) ; <END> return VAR_1 != null && STRING_2 . equalsIgnoreCase ( VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> if ( VAR_1 . METHOD_2 ( ) && VAR_2 . METHOD_3 ( ) . equals ( TYPE_3 . VAR_4 ) ) { <END> return false ; } return true ; } 
public Guid getId ( ) { <START> return this . id ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; assertNotNull ( STRING_1 , VAR_1 ) ; <START> assertEquals ( STRING_2 , VAR_1 . getId ( ) , VAR_3 ) ; <END> VAR_1 = VAR_2 . METHOD_2 ( VAR_4 ) ; METHOD_3 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( METHOD_2 ( ) ) { <END> return TYPE_1 . VAR_1 ; } else { return TYPE_1 . VAR_2 ; } } 
<START> protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return ( VAR_1 . getStatus ( ) == TYPE_4 . TYPE_2 || VAR_1 . METHOD_2 ( ) == TYPE_5 . TYPE_3 ) ; } 
<START> @Override protected void METHOD_1 ( ) { <END> if ( getParameters ( ) . METHOD_2 ( ) != null ) { METHOD_3 ( ) . METHOD_4 ( TYPE_1 . METHOD_5 ( getParameters ( ) . METHOD_2 ( ) ) ) ; } } 
TYPE_1 METHOD_1 ( ) { TYPE_1 builder = METHOD_2 ( ) ; <START> builder . VAR_1 ( VAR_2 , STRING_1 ) ; <END> return builder ; } 
public TYPE_1 METHOD_1 ( TYPE_2 cluster , TYPE_3 VAR_1 ) { TYPE_3 . TYPE_5 source = VAR_1 . METHOD_2 ( ) ; boolean VAR_2 = cluster != null && METHOD_3 ( cluster . VAR_3 ( ) ) && cluster . VAR_4 ( ) . contains ( source ) ; if ( VAR_2 ) { return TYPE_1 . VAR_5 ; } <START> return new TYPE_1 ( TYPE_6 . VAR_7 ) ; <END> } 
protected TYPE_1 METHOD_1 ( ) { <START> return this . VAR_1 ; <END> } 
public void METHOD_1 ( Boolean VAR_1 ) { if ( ! TYPE_1 . METHOD_2 ( this . VAR_1 , VAR_1 ) ) { this . VAR_1 = VAR_1 ; <START> METHOD_3 ( new TYPE_2 ( STRING_1 ) ) ; <END> } } 
public TYPE_5 ( TYPE_1 VAR_2 ) { this ( VAR_2 , new TYPE_3 . TYPE_4 ( ) ) ; <START> METHOD_1 ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 response ) throws IOException { <START> for ( String VAR_1 : new HashSet < > ( VAR_2 ) ) { <END> response . VAR_3 ( STRING_1 , VAR_1 ) ; } response . VAR_4 ( TYPE_1 . VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( METHOD_2 ( ) ) <END> return TYPE_1 . VAR_1 ; else return TYPE_1 . VAR_2 ; } 
<START> public void METHOD_1 ( String value ) { <END> if ( value == null ) { METHOD_2 ( ) ; } if ( value . isEmpty ( ) ) { return ; } METHOD_1 ( value , false ) ; } 
private void METHOD_1 ( T VAR_1 ) { String VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> if ( VAR_4 . containsKey ( VAR_1 ) ) { <END> throw new IllegalArgumentException ( STRING_2 + VAR_2 ) ; } final TYPE_1 VAR_5 = METHOD_3 ( VAR_1 ) ; VAR_4 . put ( VAR_1 , VAR_5 ) ; } 
private int METHOD_1 ( int VAR_1 ) { int row = VAR_1 / VAR_2 ; <START> return VAR_1 % INT_1 == 0 ? row - 1 : row ; <END> } 
private void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( ) ; <START> VAR_1 . addAll ( TYPE_2 . getInstance ( ) . METHOD_3 ( ) ) ; <END> VAR_1 . addAll ( TYPE_2 . METHOD_4 ( ) ) ; VAR_1 . addAll ( TYPE_2 . METHOD_5 ( ) ) ; METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; } 
private boolean VAR_1 ( VAR_2 vds ) { TYPE_6 VAR_4 = vds . VAR_5 ( ) ; return ( VAR_4 . getStatus ( ) == TYPE_5 . TYPE_2 || VAR_4 . getStatus ( ) == TYPE_5 . TYPE_4 || VAR_4 . getStatus ( ) == TYPE_5 . TYPE_1 || VAR_4 . getStatus ( ) == TYPE_5 . TYPE_3 || ( VAR_4 . getStatus ( ) == TYPE_5 . TYPE_8 <START> || ( VAR_4 . getStatus ( ) == TYPE_5 . TYPE_9 <END> && VAR_4 . VAR_13 ( ) == TYPE_7 . VAR_15 ) ) ; } 
private double METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = ( VAR_1 . METHOD_2 ( ) == 0 ) ? 100 : VAR_1 . METHOD_3 ( ) ; <START> double VAR_3 = VAR_2 * VAR_1 . METHOD_4 ( ) / FLOAT_1 ; <END> return VAR_3 ; } 
public TYPE_2 ( Guid VAR_2 , TYPE_1 VAR_3 , Guid VAR_4 ) { <START> this . VAR_2 = VAR_2 ; <END> METHOD_1 ( VAR_3 ) ; METHOD_2 ( VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 model , boolean value ) { if ( ! METHOD_2 ( ) ) { if ( value ) { if ( METHOD_3 ( ) != null ) { METHOD_3 ( ) . METHOD_1 ( false ) ; } VAR_1 = model ; } else { <START> METHOD_4 ( ) . METHOD_1 ( true ) ; <END> } } model . VAR_2 ( value ) ; } 
<START> public boolean METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 vm , TYPE_3 VAR_1 ) { if ( vm == null && Boolean . VAR_2 . equals ( VAR_1 . METHOD_2 ( ) ) ) { return new TYPE_1 ( TYPE_4 . VAR_4 ) ; } if ( VAR_1 . METHOD_2 ( ) != null && <START> VAR_1 . METHOD_2 ( ) <END> && VAR_1 . METHOD_3 ( ) == TYPE_5 . VAR_6 ) { return new TYPE_1 ( TYPE_4 . VAR_7 ) ; } return TYPE_1 . VAR_8 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . get ( METHOD_2 ( ) ) ; boolean VAR_3 = ! VAR_1 . METHOD_3 ( ) ; <START> Assert . assertTrue ( StringUtils . VAR_4 ( VAR_1 . METHOD_4 ( ) ) ) ; <END> VAR_1 . METHOD_5 ( VAR_3 ) ; VAR_2 . update ( VAR_1 ) ; VAR_2 . get ( METHOD_2 ( ) ) ; assertEquals ( VAR_1 . METHOD_3 ( ) , VAR_3 ) ; } 
public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = super . METHOD_1 ( ) ; <START> result = VAR_1 * result + ( Boolean . VAR_2 . equals ( VAR_3 ) ? INT_2 : INT_3 ) ; <END> result = VAR_1 * result + ( ( VAR_4 == null ) ? 0 : VAR_4 . METHOD_1 ( ) ) ; return result ; } 
public TYPE_2 ( TYPE_1 resource , String VAR_2 ) { this . properties = METHOD_1 ( resource ) ; this . VAR_2 = VAR_2 ; METHOD_2 ( ) ; <START> } <END> 
public static TYPE_1 METHOD_1 ( Class < ? > VAR_1 , String resource ) throws IOException { try ( TYPE_2 is = new TYPE_3 ( VAR_1 . METHOD_2 ( resource ) , STRING_1 ) ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_3 ( is ) ; return VAR_2 ; } catch ( IOException e ) { throw new IOException ( String . format ( STRING_2 , resource ) <START> ) ; <END> } } 
public boolean METHOD_1 ( List < String > VAR_1 ) throws Exception { TYPE_1 parser = new TYPE_1 ( TYPE_2 . METHOD_2 ( getClass ( ) , STRING_1 ) , TYPE_2 . METHOD_2 ( getClass ( ) , STRING_2 ) ) ; args = parser . parse ( VAR_1 ) ; <START> return args . containsKey ( STRING_3 ) ; <END> } 
public void METHOD_1 ( ) { <START> TYPE_1 . when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( true ) ; <END> Assert . assertTrue ( VAR_2 . METHOD_4 ( VAR_1 ) ) ; } 
<START> @Override protected void METHOD_1 ( TYPE_1 connection ) { } <END> 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( VAR_1 ) ) ; <START> super . METHOD_1 ( VAR_1 ) ; <END> } 
private TYPE_1 METHOD_1 ( Guid VAR_1 , Guid VAR_2 ) { List < TYPE_1 > VAR_3 = METHOD_2 ( ) . METHOD_3 ( VAR_1 , TYPE_2 . TYPE_3 ) ; <START> if ( VAR_3 != null && VAR_3 . size ( ) > 0 ) { <END> for ( TYPE_1 vds : VAR_3 ) { if ( ! VAR_2 . equals ( vds . getId ( ) ) ) { return vds ; } } } return null ; } 
public static void METHOD_1 ( final TYPE_1 vm ) { vm . VAR_1 ( METHOD_2 ( ) . METHOD_3 ( String . format ( STRING_1 , vm . getId ( ) , <START> TYPE_3 . TYPE_1 ) ) ) ; <END> } 
private String METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) { return null ; } String [ ] VAR_2 = VAR_1 . split ( STRING_1 ) ; <START> return VAR_2 . length == 2 ? VAR_2 [ 0 ] + STRING_2 + VAR_2 [ 1 ] + STRING_3 : VAR_2 [ 0 ] ; <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { boolean VAR_2 = VAR_1 . METHOD_2 ( ) != null ; VAR_3 . METHOD_3 ( VAR_4 ) ; VAR_5 . METHOD_3 ( VAR_4 && VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) == TYPE_2 . VAR_7 ) ; <START> VAR_8 . METHOD_3 ( VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) != TYPE_2 . VAR_7 ) ; <END> VAR_9 . METHOD_6 ( ! VAR_2 ) ; } 
public ArrayList < TYPE_1 > METHOD_1 ( ) { ArrayList < TYPE_1 > VAR_1 = new ArrayList < > ( Arrays . asList ( new TYPE_1 [ ] { TYPE_1 . VAR_2 , TYPE_1 . VAR_3 , TYPE_1 . VAR_4 , TYPE_1 . VAR_5 } ) ) ; <START> return VAR_1 ; <END> } 
public TYPE_2 ( List < TYPE_1 < T > > VAR_2 , List VAR_3 ) { <START> super ( ) ; <END> METHOD_1 ( ) ; METHOD_2 ( TYPE_3 . VAR_5 . METHOD_3 ( this ) ) ; METHOD_4 ( VAR_2 , VAR_3 ) ; METHOD_5 ( ) ; } 
public TYPE_4 ( String VAR_2 , TYPE_1 VAR_3 , TYPE_1 VAR_4 , String VAR_5 ) { <START> super ( ) ; <END> METHOD_1 ( TYPE_5 . VAR_7 . METHOD_2 ( this ) ) ; METHOD_3 ( VAR_2 ) ; METHOD_4 ( TYPE_2 . METHOD_5 ( TYPE_3 . create ( VAR_3 ) . METHOD_6 ( ) ) ) ; METHOD_7 ( TYPE_2 . METHOD_5 ( TYPE_3 . create ( VAR_4 ) . METHOD_6 ( ) ) ) ; VAR_8 . METHOD_8 ( VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> final TYPE_1 host = TYPE_2 . getInstance ( ) . METHOD_2 ( VAR_1 ) ; <END> return host ; } 
public <START> synchronized static <END> Map < String , String > METHOD_1 ( ) { return VAR_1 ; } 
public <START> synchronized static <END> void METHOD_1 ( String VAR_1 , String VAR_2 ) { VAR_3 . put ( VAR_1 , VAR_2 ) ; } 
public static < TYPE_1 extends TYPE_2 > Map < String , TYPE_1 > METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { if ( VAR_1 != null ) { <START> Map < String , TYPE_1 > map = new HashMap < String , TYPE_1 > ( ) ; <END> for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_2 . METHOD_2 ( ) != null ) { map . put ( VAR_2 . METHOD_2 ( ) , VAR_2 ) ; } } return map ; } else { return Collections . VAR_3 ( ) ; } } 
public static boolean METHOD_1 ( TYPE_1 req ) throws TYPE_2 { String VAR_1 = ( String ) req . VAR_2 ( true ) . METHOD_2 ( TYPE_4 . VAR_4 ) ; boolean VAR_5 = false ; if ( StringUtils . VAR_6 ( VAR_1 ) ) { try { TYPE_3 . METHOD_3 ( req , String . format ( STRING_1 , VAR_1 ) ) ; <START> VAR_5 = true ; <END> } catch ( Exception e ) { log . error ( STRING_2 + VAR_1 , e . getMessage ( ) ) ; } } return VAR_5 ; } 
private boolean METHOD_1 ( String obj , String VAR_1 , boolean VAR_2 ) { if ( ! VAR_2 ) { return false ; } Boolean result = VAR_3 . containsKey ( obj + STRING_1 + VAR_1 ) ; if ( result != null && result ) { return true ; } <START> return false ; <END> } 
<START> public < T <END> extends TYPE_1 > T METHOD_1 ( Class < T > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_1 . METHOD_2 ( VAR_2 . getClass ( ) ) ) { METHOD_3 ( ( TYPE_2 ) VAR_2 ) ; return ( T ) VAR_2 ; } } log . error ( STRING_1 + VAR_1 ) ; return null ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) == TYPE_2 . TYPE_3 && VAR_1 . getStatus ( ) != null <END> && VAR_1 . getStatus ( ) == TYPE_5 . TYPE_4 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return ( TYPE_1 < TYPE_2 > ) METHOD_1 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 == null ) { return new TYPE_1 ( Status . VAR_2 , TYPE_3 . VAR_4 , STRING_1 ) ; } <START> List < TYPE_2 > VAR_5 = new ArrayList < > ( ) ; <END> VAR_5 . add ( VAR_1 ) ; return METHOD_2 ( TYPE_4 . VAR_7 , VAR_5 ) ; } 
public void METHOD_1 ( Guid VAR_1 , List < Guid > VAR_2 ) { super . METHOD_1 ( VAR_1 , VAR_2 ) ; <START> METHOD_2 ( ) . METHOD_3 ( ) ; <END> log . error ( STRING_1 , METHOD_4 ( ) ) ; METHOD_5 ( TYPE_2 . VAR_4 , METHOD_2 ( ) . METHOD_6 ( ) ) ; METHOD_2 ( ) . METHOD_7 ( ) ; TYPE_1 . METHOD_8 ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = <START> TYPE_3 . METHOD_2 ( METHOD_3 ( ) ) ; <END> return METHOD_4 ( TYPE_6 . TYPE_5 , new TYPE_4 ( VAR_1 . getId ( ) , getParameters ( ) . METHOD_5 ( ) ) ) ; } 
private boolean METHOD_1 ( List < String > VAR_1 , TYPE_1 VAR_2 ) { List < TYPE_2 > VAR_3 = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( ) ) ; <START> List < String > VAR_4 = new ArrayList < > ( VAR_1 ) ; <END> for ( TYPE_2 VAR_5 : VAR_3 ) { if ( VAR_4 . contains ( VAR_5 . METHOD_6 ( ) ) ) { VAR_4 . remove ( VAR_5 . METHOD_6 ( ) ) ; } } return VAR_4 . isEmpty ( ) ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( TYPE_3 . filter ( METHOD_3 ( ) , new TYPE_4 < TYPE_2 > ( ) { @Override public boolean METHOD_4 ( TYPE_2 vds ) { return vds . VAR_2 ( ) == TYPE_6 . VAR_4 ; } } ) ) ; return METHOD_5 ( TYPE_8 . TYPE_7 , <START> new TYPE_5 ( VAR_1 . getId ( ) , getParameters ( ) . METHOD_6 ( ) ) ) ; <END> } 
private Long METHOD_1 ( String VAR_1 ) { try { return ( Long ) METHOD_2 ( TYPE_4 . TYPE_3 , new TYPE_1 ( METHOD_3 ( ) , METHOD_4 ( ) , VAR_1 ) ) . METHOD_5 ( ) ; } catch ( TYPE_2 e ) { <START> log . error ( STRING_1 + VAR_1 , e ) ; <END> throw e ; } } 
protected void METHOD_1 ( final String VAR_1 , final TYPE_1 VAR_2 ) { VAR_2 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; VAR_3 . update ( VAR_2 ) ; <START> METHOD_3 ( ) . METHOD_5 ( ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { return super . METHOD_1 ( VAR_1 ) . append ( STRING_1 , VAR_2 . getId ( ) ) <START> . append ( STRING_2 , VAR_3 . toString ( ) ) ; <END> } 
<START> protected void METHOD_1 ( ) { <END> METHOD_2 ( TYPE_1 . VAR_2 ) ; METHOD_2 ( TYPE_1 . VAR_3 ) ; METHOD_2 ( TYPE_1 . VAR_4 ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 entry = VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) ; <END> METHOD_3 ( entry . VAR_4 ( ) ) ; VAR_1 . METHOD_4 ( ) ; entry = VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) ; assertTrue ( entry . VAR_4 ( ) ) ; } 
<START> @Override public void METHOD_1 ( ) { <END> METHOD_2 ( ) . METHOD_3 ( STRING_1 , METHOD_4 ( ) ) ; } 
public TYPE_2 ( TYPE_1 context ) { <START> super ( ) ; <END> this . context = context ; } 
protected TYPE_3 ( Guid VAR_2 , Class < TYPE_1 > VAR_3 ) { <START> super ( VAR_3 , TYPE_2 . class , VAR_4 ) ; <END> this . VAR_2 = VAR_2 ; } 
protected Response METHOD_1 ( String id ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( id ) ) ; <END> return METHOD_4 ( TYPE_4 . TYPE_3 , VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 < Boolean > value ) { this . VAR_1 = value ; <START> this . VAR_1 . METHOD_2 ( value . VAR_2 ( ) ) ; <END> } 
public Map < String , String > METHOD_1 ( ) { <START> METHOD_2 ( STRING_1 , METHOD_3 ( ) ) ; <END> return super . METHOD_1 ( ) ; } 
<START> public void METHOD_1 ( ) { } <END> 
<START> @Override public <END> TYPE_1 getId ( ) { TYPE_1 key = new TYPE_1 ( ) ; key . VAR_1 ( VAR_2 ) ; key . VAR_3 ( VAR_4 ) ; return key ; } 
<START> @Override public <END> void METHOD_1 ( TYPE_1 id ) { VAR_1 = id . VAR_2 ( ) ; VAR_3 = id . VAR_4 ( ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { List < TYPE_1 > VAR_2 = METHOD_2 ( VAR_3 . METHOD_3 ( STRING_1 , TYPE_1 . class ) . METHOD_4 ( STRING_2 , VAR_1 ) ) ; <START> if ( VAR_2 != null && VAR_2 . size ( ) > 0 ) { <END> return VAR_2 . get ( 0 ) ; } else { return null ; } } 
protected void METHOD_1 ( ) { <START> if ( METHOD_2 ( ) != null && METHOD_2 ( ) . getStatus ( ) == TYPE_7 . TYPE_6 ) { <END> try { TYPE_1 VAR_3 = METHOD_3 ( TYPE_5 . TYPE_4 , new TYPE_2 ( METHOD_4 ( ) , METHOD_5 ( ) ) ) ; if ( VAR_3 != null ) { VAR_6 = ( Integer ) VAR_3 . METHOD_6 ( ) ; } } catch ( TYPE_3 e ) { VAR_7 = e . VAR_8 ( ) ; } } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( new TYPE_2 ( ) { @Override public void METHOD_3 ( TYPE_3 result ) { <START> TYPE_4 . this . METHOD_4 ( null ) ; <END> } } , VAR_3 ) ; } 
TYPE_1 METHOD_1 ( ) { TYPE_1 vm = new TYPE_1 ( ) ; vm . VAR_1 ( new TYPE_2 ( ) ) ; vm . VAR_2 ( id ) ; vm . VAR_3 ( name ( ) ) ; vm . VAR_4 ( VAR_5 ) ; <START> vm . VAR_6 ( - FLOAT_1 ) ; <END> return vm ; } 
public void METHOD_1 ( TYPE_1 vm ) { METHOD_2 ( vm . getId ( ) ) ; <START> METHOD_3 ( vm , TYPE_5 . TYPE_4 , vm . VAR_3 ( ) ) ; <END> TYPE_2 VAR_4 = new TYPE_2 ( ) ; VAR_4 . METHOD_4 ( vm . getId ( ) ) ; VAR_5 . log ( VAR_4 , TYPE_3 . VAR_7 ) ; METHOD_5 ( vm ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( TYPE_2 . VAR_2 ) ; METHOD_3 ( TYPE_1 . VAR_4 , getParameters ( ) . METHOD_4 ( ) . METHOD_5 ( ) ) ; <START> METHOD_3 ( STRING_1 , <END> METHOD_6 ( ) ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( false ) ; <START> assertEquals ( VAR_1 , Arrays . asList ( VAR_2 ) ) ; <END> } 
private List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> final ArrayList < TYPE_1 > result = new ArrayList < > ( ) ; <END> for ( TYPE_1 VAR_2 : VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( ) ) { result . add ( VAR_2 ) ; } } return result ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; <START> TYPE_2 . when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_4 < TYPE_3 > METHOD_5 ( ) ) ; <END> return VAR_1 ; } 
<START> <END> <END> public <END> <END> TYPE_1 getValue <END> ( <END> <END> <END> TYPE_2 object <END> ) <END> { <END> if ( <END> <END> object <END> <END> <END> instanceof TYPE_1 <END> <END> ) { return <END> ( TYPE_1 ) object ; } <END> if ( <END> object instanceof <END> <END> TYPE_3 ) <END> { <END> if ( ( <END> ( TYPE_3 < ? , ? <END> > ) <END> object ) . METHOD_1 ( <END> <END> ) instanceof 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public static TYPE_1 [ ] METHOD_1 ( List < TYPE_2 > VAR_1 ) { Set < TYPE_1 > VAR_2 = new HashSet < > ( ) ; for <START> ( final TYPE_2 <END> VAR_3 : VAR_1 ) { TYPE_1 VAR_4 = new TYPE_1 ( TYPE_4 . TYPE_3 , VAR_3 . METHOD_2 ( ) . get ( 0 ) ) ; VAR_2 . add ( VAR_4 ) ; } return VAR_2 . METHOD_3 ( new TYPE_1 [ VAR_2 . size ( ) ] ) ; } 
<START> public Integer METHOD_1 ( ) { <END> return METHOD_2 ( ) == null ? 0 : METHOD_3 ( ) * METHOD_2 ( ) / 100 ; } 
private void METHOD_1 ( List < T > VAR_1 ) { for ( Entry < T , TYPE_1 > VAR_2 : VAR_3 . entrySet ( ) ) { VAR_4 . add ( VAR_2 . getValue ( ) ) ; if ( VAR_1 . contains ( VAR_2 . getKey ( ) ) ) { <START> VAR_2 . getValue ( ) . METHOD_2 ( true , false ) ; <END> } } } 
<START> private TYPE_1 ( int value ) { <END> VAR_2 = value ; } 
<START> public int getValue ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . get ( VAR_3 . getId ( ) ) ; VAR_1 . METHOD_2 ( TYPE_2 . TYPE_3 ) ; VAR_2 . METHOD_3 ( VAR_1 . getId ( ) , VAR_1 . METHOD_4 ( ) ) ; TYPE_1 VAR_6 = VAR_2 . get ( VAR_3 . getId ( ) ) ; <START> assertEquals ( VAR_1 , VAR_6 ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( getParameters ( ) . METHOD_3 ( ) ) ; if ( METHOD_4 ( ) ) { <START> VAR_1 . add ( new TYPE_1 ( new Guid ( getParameters ( ) . METHOD_3 ( ) . METHOD_5 ( ) . toString ( ) ) , <END> TYPE_3 . VAR_3 , TYPE_2 . VAR_5 ) ) ; } return VAR_1 ; } 
<START> <END> <END> <END> protected <END> <END> Object METHOD_1 <END> <END> <END> ( TYPE_1 
public List < TYPE_1 > METHOD_1 ( Guid VAR_1 , TYPE_2 VAR_2 , boolean VAR_3 ) { <START> List < TYPE_1 > VAR_4 ; <END> if ( ! METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ) { throw new TYPE_3 ( TYPE_4 . TYPE_5 ) ; } VAR_4 = METHOD_3 ( VAR_1 , VAR_2 ) ; return VAR_4 ; } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( true ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> VAR_1 = System . VAR_2 ( ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = TYPE_1 . getInstance ( ) . METHOD_2 ( ) ; <END> TYPE_2 VAR_2 = METHOD_3 ( ) . METHOD_4 ( TYPE_5 . List , new TYPE_3 ( VAR_4 . METHOD_5 ( ) ) ) ; if ( VAR_2 . METHOD_6 ( ) ) { VAR_5 = ( Map < Guid , TYPE_4 > ) VAR_2 . METHOD_7 ( ) ; METHOD_8 ( ) ; } else { METHOD_9 ( ) ; } } 
protected void METHOD_1 ( ) { Guid VAR_1 = getParameters ( ) . METHOD_2 ( ) . getId ( ) ; <START> METHOD_3 ( STRING_1 , VAR_1 . toString ( ) ) ; <END> METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { do { logger . info ( STRING_1 , VAR_1 . get ( TYPE_2 . TYPE_3 . VAR_4 , "" ) , VAR_1 . get ( TYPE_2 . TYPE_3 . VAR_5 , "" ) , VAR_1 . get ( TYPE_2 . TYPE_3 . VAR_6 , "" ) , VAR_1 . get ( TYPE_2 . TYPE_3 . VAR_7 , "" ) ) ; <START> } while ( ( VAR_1 = VAR_1 . get ( TYPE_2 . TYPE_3 . VAR_8 ) ) != null ) ; <END> } } 
public TYPE_1 ( Guid VAR_2 , Guid VAR_3 , Guid VAR_4 , Guid VAR_5 , Guid VAR_6 , Guid VAR_7 , Guid VAR_8 , String VAR_9 ) { super ( VAR_2 , VAR_3 ) ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; this . VAR_8 = VAR_8 ; <START> this . VAR_9 = Optional . VAR_10 ( VAR_9 ) ; <END> } 
public Map < String , Object > METHOD_1 ( TYPE_1 vm , TYPE_2 VAR_1 , Map < String , Object > VAR_2 ) { <START> this . METHOD_2 ( vm , <END> VAR_1 ) . METHOD_3 ( ( VAR_3 ) - > VAR_2 . put ( TYPE_4 . TYPE_3 , VAR_3 ) ) ; return VAR_2 ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( false ) ; <START> VAR_2 . METHOD_2 ( false ) ; <END> VAR_3 . METHOD_2 ( false ) ; } 
private Integer METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! VAR_1 . METHOD_2 ( ) ) { <END> Integer VAR_2 = VAR_3 . METHOD_3 ( ) . getValue ( ) ; return VAR_2 == null ? 0 : VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) * VAR_2 / 100 ; } return 0 ; } 
protected TYPE_3 ( String VAR_2 , String id ) { super ( id , TYPE_1 . class , TYPE_2 . class ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = METHOD_1 ( id ) ; <END> } 
private void METHOD_1 ( ) { ArrayList < TYPE_1 > VAR_1 = METHOD_2 ( ) != null ? TYPE_2 < TYPE_1 > METHOD_3 ( METHOD_2 ( ) ) : new ArrayList < TYPE_1 > ( ) ; <START> METHOD_4 ( ) . METHOD_5 ( VAR_1 . size ( ) > 0 ) ; <END> METHOD_6 ( ) . METHOD_5 ( VAR_1 . size ( ) > 0 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; List < TYPE_1 > VAR_3 = VAR_2 . METHOD_4 ( TYPE_2 . VAR_5 ) ; <START> assertEquals ( 1 , VAR_3 . size ( ) ) ; <END> assertEquals ( STRING_1 , VAR_3 . get ( 0 ) . getKey ( ) ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 object ) { if ( object instanceof <START> TYPE_1 ) { <END> return object ; } else { return null ; } } 
void METHOD_1 ( ) { TYPE_1 . get ( ) . METHOD_2 ( new TYPE_2 ( ) { @Override public boolean execute ( ) { boolean VAR_1 = VAR_2 != null ; if ( VAR_1 && VAR_3 ) { <START> METHOD_3 ( METHOD_4 ( VAR_4 ) , new TYPE_3 ( ) ) ; <END> VAR_3 = false ; } return VAR_1 ; } } , VAR_5 ) ; } 
public TYPE_1 ( ) { <START> super ( ) ; <END> } 
public TYPE_1 METHOD_1 ( boolean VAR_1 , TYPE_2 VAR_2 ) { return TYPE_1 . METHOD_2 ( TYPE_3 . VAR_4 ) . when ( VAR_1 == true && VAR_2 == null ) ; <START> } <END> 
private void METHOD_1 ( ) { <START> if ( METHOD_2 ( ) . METHOD_3 ( ) ) { <END> VAR_1 . METHOD_4 ( VAR_2 . METHOD_5 ( ) , VAR_1 ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; METHOD_8 ( ) ; METHOD_9 ( ) ; for ( TYPE_1 VAR_3 : VAR_2 . METHOD_10 ( ) . METHOD_11 ( ) ) { VAR_4 . METHOD_12 ( new Pair < > ( VAR_1 . getId ( ) , VAR_3 ) ) ; } } } 
private boolean METHOD_1 ( ) { if ( ! TYPE_1 . METHOD_1 ( METHOD_2 ( ) ) ) { log . error ( STRING_1 , METHOD_2 ( ) . getName ( ) ) ; <START> METHOD_3 ( TYPE_2 . VAR_2 , METHOD_2 ( ) ) ; <END> return false ; } return true ; } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) . exists ( METHOD_3 ( ) , TYPE_8 . VAR_2 ) <START> && ! TYPE_4 . TYPE_5 . equals ( METHOD_4 ( ) ) ) { <END> log . info ( STRING_1 , METHOD_3 ( ) ) ; METHOD_5 ( TYPE_7 . TYPE_6 , new TYPE_2 ( METHOD_3 ( ) ) , TYPE_3 . METHOD_6 ( METHOD_7 ( ) , METHOD_8 ( ) ) ) ; } } 
int METHOD_1 ( TYPE_1 item , Integer VAR_1 ) { List < Integer > VAR_2 = VAR_3 . get ( item ) ; int VAR_4 ; if ( VAR_1 != null ) { VAR_2 . set ( 1 , VAR_1 ) ; <START> VAR_4 = VAR_1 ; <END> } else { VAR_4 = VAR_2 . get ( 1 ) ; } return VAR_4 ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 ) { switch ( VAR_1 ) { case TYPE_3 : return VAR_2 ? VAR_4 . METHOD_2 ( ) : VAR_4 . METHOD_3 ( ) ; case TYPE_4 : return VAR_2 ? VAR_4 . METHOD_4 ( ) : VAR_4 . METHOD_5 ( ) ; default : <START> log . VAR_6 ( STRING_1 ) ; <END> return null ; } } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; <START> return new ArrayList < > ( VAR_1 ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Guid VAR_2 = VAR_1 . METHOD_2 ( ) ; String VAR_3 = VAR_1 . METHOD_3 ( ) ; Guid VAR_4 = VAR_1 . getId ( ) ; <START> return METHOD_4 ( VAR_4 == null ? null : VAR_4 . toString ( ) , <END> VAR_2 , VAR_3 , TYPE_3 . VAR_6 , VAR_7 ) ; } 
public static Boolean METHOD_1 ( String val ) { if ( val == null || val . trim ( ) . length ( ) == 0 ) { return false ; } try { return Boolean . valueOf ( val ) ; <START> } catch ( Exception e ) { <END> return false ; } } 
private void METHOD_1 ( String message ) { TYPE_1 client = TYPE_2 . METHOD_2 ( ) ; try { client . VAR_1 ( message . VAR_2 ( ) ) ; log . error ( STRING_1 , message ) ; } catch ( TYPE_3 e ) { <START> log . error ( STRING_2 , e ) ; <END> } finally { log . debug ( STRING_3 ) ; } } 
public void METHOD_1 ( TYPE_1 t , long VAR_1 , Object o ) { try { if ( TYPE_2 . getInstance ( ) . METHOD_2 ( ) ) { <START> TYPE_3 VAR_2 = new TYPE_3 ( ) ; <END> VAR_2 . METHOD_3 ( t , VAR_1 , o ) ; } else { TYPE_4 . getInstance ( ) . METHOD_1 ( new TYPE_5 ( t , VAR_1 , o ) ) ; } } catch ( Exception e ) { log . error ( STRING_1 , e . toString ( ) ) ; } } 
private void METHOD_1 ( String message , String VAR_1 , boolean VAR_2 ) throws TYPE_1 { String VAR_3 = null ; try { TYPE_2 client = TYPE_3 . METHOD_2 ( ) . get ( VAR_1 ) ; <START> VAR_3 = client . VAR_4 ( ) ; <END> client . VAR_5 ( message . VAR_6 ( ) ) ; log . debug ( STRING_1 , message ) ; } catch ( TYPE_1 e ) { log . error ( STRING_2 , VAR_3 , e ) ; } if ( VAR_2 ) { TYPE_3 . METHOD_3 ( VAR_1 ) ; } } 
public <START> static void <END> METHOD_1 ( String VAR_1 , TYPE_1 client ) { VAR_2 . put ( VAR_1 , client ) ; } 
public synchronized static void <START> METHOD_1 ( String <END> VAR_1 , TYPE_1 client ) { VAR_2 . put ( VAR_1 , client ) ; } 
public void METHOD_1 ( String message , String id ) { if ( message == null ) { log . warn ( STRING_1 ) ; return ; } message = METHOD_2 ( message , id ) ; <START> METHOD_3 ( message ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { return TYPE_1 . METHOD_2 ( TYPE_4 . VAR_3 , TYPE_3 . METHOD_3 ( STRING_1 , host . getStatus ( ) . name ( ) ) ) <START> . METHOD_4 ( VAR_1 == host . getStatus ( ) ) ; <END> } 
private void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; <START> List < Guid > VAR_2 = TYPE_2 . METHOD_3 ( VAR_1 ) ; <END> if ( ! VAR_1 . isEmpty ( ) ) { VAR_3 . METHOD_4 ( VAR_2 ) ; VAR_3 . METHOD_5 ( METHOD_6 ( ) ) ; } } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 , TYPE_3 , IOException { <START> if ( VAR_1 == null ) { <END> String url = String . format ( STRING_1 , VAR_2 , server , VAR_3 ) ; log . debug ( String . format ( STRING_2 , url , VAR_4 ) ) ; VAR_1 = new TYPE_1 ( url , VAR_4 , VAR_5 , true ) ; } return VAR_1 ; } 
<START> @Override public void METHOD_1 ( boolean VAR_1 ) { <END> VAR_2 . METHOD_1 ( VAR_1 ) ; if ( VAR_3 instanceof TYPE_1 ) { TYPE_1 VAR_4 = ( TYPE_1 ) this . VAR_3 ; VAR_4 . METHOD_1 ( VAR_1 ) ; } } 
public void METHOD_1 ( ) { <START> TYPE_1 . when ( VAR_1 . METHOD_2 ( VAR_2 ) ) . METHOD_3 ( true ) ; <END> METHOD_4 ( VAR_3 . METHOD_2 ( VAR_2 ) ) ; } 
protected void METHOD_1 ( ) { <START> logger . info ( this . getClass ( ) . toString ( ) + STRING_1 ) ; <END> if ( METHOD_2 ( ) != null ) { return ; } TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_3 ( VAR_2 . METHOD_4 ( getName ( ) ) ) ; VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ; VAR_1 . METHOD_7 ( getName ( ) ) ; METHOD_8 ( VAR_1 ) ; METHOD_9 ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( ) { <START> logger . info ( this . getClass ( ) . toString ( ) + STRING_1 ) ; <END> return TYPE_2 . get ( TYPE_3 . VAR_2 ) ; } 
protected void METHOD_1 ( ) { <START> logger . info ( this . getClass ( ) . toString ( ) + STRING_1 ) ; <END> TYPE_1 . METHOD_2 ( this , METHOD_3 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 event ) { <START> logger . info ( this . getClass ( ) . toString ( ) + STRING_1 ) ; <END> METHOD_2 ( event . VAR_1 ( ) ) ; } 
public TYPE_9 ( TYPE_1 VAR_2 , TYPE_2 view , TYPE_3 VAR_3 , TYPE_4 VAR_4 , TYPE_5 < TYPE_6 < TYPE_7 > , TYPE_8 > VAR_5 ) { super ( VAR_2 , view , VAR_3 , VAR_4 , VAR_5 , TYPE_10 . TYPE_11 ) ; VAR_8 = METHOD_1 ( ) . METHOD_2 ( ) ; <START> logger . info ( STRING_1 + this . toString ( ) ) ; <END> } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> logger . info ( this . getClass ( ) . toString ( ) + STRING_1 ) ; <END> METHOD_2 ( VAR_1 ) ; METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; METHOD_3 ( ) . METHOD_7 ( ) . METHOD_5 ( VAR_1 . METHOD_8 ( ) ) ; METHOD_3 ( ) . METHOD_9 ( ) . METHOD_5 ( VAR_1 . METHOD_10 ( ) ) ; } 
private void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; VAR_2 = new TYPE_2 ( ) ; VAR_3 = new TYPE_3 ( ) ; VAR_3 . METHOD_2 ( VAR_4 . METHOD_3 ( ) ) ; TYPE_1 VAR_5 = new TYPE_1 ( ) ; VAR_5 . METHOD_2 ( VAR_4 . METHOD_4 ( ) ) ; VAR_5 . add ( VAR_3 ) ; VAR_1 . add ( VAR_5 ) ; <START> VAR_1 . METHOD_2 ( STRING_1 ) ; <END> VAR_1 . add ( VAR_2 ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { <START> logger . info ( STRING_1 ) ; <END> VAR_2 . clear ( ) ; if ( VAR_1 ) { VAR_2 . METHOD_2 ( VAR_3 , VAR_4 ) ; } VAR_2 . add ( VAR_5 ) ; } 
protected Pair < Boolean , TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , Guid VAR_2 , int type ) { Guid VAR_3 = Guid . TYPE_3 ; if ( VAR_1 . METHOD_2 ( ) != null ) { VAR_3 = VAR_1 . METHOD_2 ( ) ; <START> } <END> return METHOD_1 ( VAR_1 , VAR_2 , type , null , VAR_3 ) ; } 
protected void METHOD_1 ( boolean VAR_1 ) { Set < TYPE_1 > VAR_2 ; VAR_2 = VAR_1 ? TYPE_2 . of ( TYPE_1 . TYPE_4 , TYPE_1 . TYPE_5 , TYPE_1 . TYPE_6 ) : TYPE_2 . of ( TYPE_1 . TYPE_4 , TYPE_1 . TYPE_5 ) ; VAR_6 = TYPE_3 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . getId ( ) , null , VAR_2 ) ; METHOD_5 ( ) ; <START> METHOD_6 ( ) ; <END> } 
<START> private Map < String , Object > METHOD_1 ( Map < TYPE_1 , TYPE_2 > VAR_1 ) { <END> Map < String , Object > VAR_2 = null ; if ( VAR_1 . containsKey ( TYPE_1 . VAR_3 ) ) { VAR_2 = new HashMap ( ) ; VAR_2 . put ( TYPE_3 . VAR_5 , Boolean . toString ( vm . VAR_6 ( ) ) ) ; VAR_2 . put ( TYPE_3 . VAR_7 , Boolean . toString ( vm . VAR_8 ( ) ) ) ; } return VAR_2 ; } 
public static boolean METHOD_1 ( TYPE_1 vds ) { if ( TYPE_2 . METHOD_2 ( METHOD_3 ( vds . getId ( ) ) . METHOD_4 ( ) ) ) { TYPE_3 VAR_1 = vds . VAR_2 ( ) ; <START> if ( VAR_1 == null || <END> VAR_1 . METHOD_5 ( ) == null || VAR_1 . METHOD_5 ( ) . isEmpty ( ) ) { return false ; } return true ; } return true ; } 
private boolean METHOD_1 ( TYPE_1 vds , List < TYPE_2 > VAR_1 , boolean VAR_2 ) { TYPE_3 VAR_3 = TYPE_4 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( TYPE_7 . TYPE_6 , new TYPE_5 ( vds . getId ( ) , VAR_1 , VAR_2 ) ) ; if ( ! VAR_3 . METHOD_4 ( ) ) { <START> log . error ( STRING_1 , vds . getName ( ) ) ; <END> return false ; } return true ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { switch ( VAR_1 ) { case TYPE_2 : return VAR_3 . METHOD_2 ( ) ; case TYPE_3 : return VAR_3 . METHOD_3 ( ) ; default : <START> return "" ; <END> } } 
public Boolean getValue ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_1 ( ) && VAR_1 . METHOD_2 ( ) ; <END> } 
public void execute ( T t ) { <START> return ; <END> } 
<START> private void METHOD_1 ( String VAR_1 , String VAR_2 ) throws IOException { <END> assertEquals ( STRING_1 , String . format ( STRING_2 + STRING_3 , VAR_1 , StringUtils . VAR_3 ( VAR_2 ) ) , TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 ) ) ; } 
public static void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) throws IOException { Map < String , Object > VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 ) ; VAR_2 . METHOD_3 ( ( String ) VAR_3 . get ( VAR_4 ) ) ; <START> VAR_2 . METHOD_4 ( ( String ) VAR_3 . get ( VAR_5 ) ) ; <END> } 
private int METHOD_1 ( String VAR_1 , Map < String , Object > VAR_2 ) { return String . format ( STRING_1 , VAR_1 ) . length ( ) + <START> ( VAR_2 . size ( ) >= 1 ? 1 : 0 ) ; <END> } 
protected boolean METHOD_1 ( ) { Guid VAR_1 = getParameters ( ) . METHOD_2 ( ) ; TYPE_1 VAR_2 = new TYPE_1 ( METHOD_3 ( ) ) ; TYPE_2 VAR_3 = VAR_2 . METHOD_4 ( VAR_1 ) ; if ( ! VAR_3 . METHOD_5 ( ) ) { return METHOD_1 ( VAR_3 ) ; } <START> return METHOD_1 ( VAR_2 . METHOD_6 ( METHOD_7 ( ) ) ) ; <END> } 
public TYPE_2 ( Guid VAR_2 , TYPE_1 VAR_3 ) { super ( VAR_2 ) ; METHOD_1 ( VAR_3 ) ; <START> METHOD_2 ( false ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { assertEquals ( STRING_1 , String . format ( STRING_2 + <START> STRING_3 , <END> VAR_1 . METHOD_2 ( ) , StringUtils . VAR_2 ( VAR_1 . METHOD_3 ( ) ) ) , TYPE_2 . METHOD_4 ( VAR_1 ) ) ; } 
<START> private static Set < String > METHOD_1 ( TYPE_1 vds ) { <END> return new HashSet < > ( Arrays . asList ( vds . VAR_1 ( ) . split ( STRING_1 ) ) ) ; } 
private boolean METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , <START> METHOD_4 ( ) ? VAR_2 . METHOD_5 ( ) . METHOD_6 ( ) <END> : null ) ; } 
private void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) , <START> METHOD_5 ( ) != null ? METHOD_5 ( ) . METHOD_6 ( ) : null ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( this ) ; if ( TYPE_2 . METHOD_3 ( ) == null ) { TYPE_2 . METHOD_4 ( METHOD_5 ( TYPE_3 . class ) ) ; } <START> when ( TYPE_2 . METHOD_3 ( ) . getValue ( TYPE_5 . TYPE_4 , TYPE_6 . VAR_4 ) ) . METHOD_6 ( INT_1 ) ; <END> } 
public void METHOD_1 ( ) { when ( model . VAR_1 ( ) ) . METHOD_2 ( null , VAR_2 ) ; TYPE_1 . METHOD_3 ( METHOD_4 ( TYPE_2 . class ) ) ; <START> when ( TYPE_1 . METHOD_5 ( ) . getValue ( TYPE_4 . TYPE_3 , TYPE_5 . VAR_6 ) ) . METHOD_2 ( INT_1 ) ; <END> } 
<START> protected void METHOD_1 ( TYPE_1 < Map . Entry < String , TYPE_2 < String > > > value ) { <END> VAR_1 = value ; } 
public void METHOD_1 ( TYPE_1 < ? extends TYPE_2 > VAR_1 , Object VAR_2 , TYPE_2 args ) { super . METHOD_1 ( VAR_1 , VAR_2 , args ) ; if ( VAR_1 . METHOD_2 ( TYPE_5 . TYPE_4 ) ) { METHOD_3 ( ) ; } if ( VAR_1 . METHOD_2 ( TYPE_3 . VAR_6 ) ) { METHOD_4 ( ) ; } <START> VAR_7 . METHOD_1 ( VAR_1 , VAR_2 , args ) ; <END> } 
<START> protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return true ; } 
protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = getParameters ( ) . METHOD_2 ( ) ; <START> return METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( VAR_1 . METHOD_6 ( ) , <END> VAR_1 . METHOD_7 ( ) ) ) ; } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) ) { METHOD_3 ( ) . METHOD_4 ( false ) ; } else { <START> METHOD_3 ( ) . METHOD_4 ( true ) ; <END> } } 
public List < TYPE_1 > METHOD_1 ( Guid VAR_1 ) { if ( ! VAR_2 . containsKey ( VAR_1 ) ) { TYPE_2 host = new TYPE_2 ( ) ; host . VAR_3 ( VAR_1 ) ; TYPE_3 VAR_4 = new TYPE_3 ( host , VAR_5 ) ; <START> VAR_2 . put ( VAR_1 , VAR_4 . METHOD_2 ( VAR_6 . METHOD_3 ( VAR_1 ) ) ) ; <END> } return VAR_2 . get ( VAR_1 ) ; } 
protected void METHOD_1 ( ) { <START> if ( ! METHOD_2 ( ) . METHOD_3 ( ) && METHOD_2 ( ) . METHOD_4 ( ) == null ) { <END> TYPE_1 . METHOD_5 ( METHOD_2 ( ) . METHOD_6 ( ) , false ) ; } } 
protected Integer METHOD_1 ( TYPE_1 VAR_1 , String string , Integer VAR_2 ) { TYPE_1 VAR_3 = METHOD_2 ( VAR_1 , string , VAR_4 ) ; if ( VAR_3 != null && VAR_3 . VAR_5 != null ) { Integer VAR_6 = Integer . parseInt ( VAR_3 . VAR_5 ) ; <START> return VAR_6 ; <END> } return VAR_2 ; } 
public TYPE_1 ( ) { <START> super ( Integer . VAR_2 , Integer . VAR_3 , Integer . VAR_4 ) ; <END> } 
protected void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( new TYPE_2 < TYPE_3 > ( ) { @Override public TYPE_3 METHOD_3 ( ) { METHOD_4 ( ) . METHOD_5 ( METHOD_6 ( ) ) ; METHOD_7 ( ) ; METHOD_8 ( ) ; METHOD_4 ( ) . METHOD_9 ( ) ; return null ; } } ) ; METHOD_10 ( false ) ; log ( ) ; METHOD_11 ( ) ; if ( VAR_1 ) { <START> getParameters ( ) . METHOD_12 ( true ) ; <END> METHOD_13 ( ) ; } else { METHOD_14 ( true ) ; } } 
<START> private TYPE_1 METHOD_1 ( ) { TYPE_1 status = null ; if ( METHOD_2 ( ) != null ) { status = METHOD_2 ( ) . METHOD_1 ( ) ; } return status ; } <END> 
protected void METHOD_1 ( ) { METHOD_2 ( TYPE_4 . VAR_2 ) ; TYPE_1 status = METHOD_3 ( ) ; TYPE_2 VAR_3 = METHOD_4 ( ) ; <START> Object VAR_4 ; if ( status == TYPE_1 . TYPE_3 && VAR_3 != null ) { VAR_4 = VAR_3 ; } else { VAR_4 = status ; } <END> METHOD_5 ( STRING_1 , VAR_4 ) ; } 
public static TYPE_1 METHOD_1 ( int value ) { <START> return VAR_1 . METHOD_2 ( value , VAR_2 ) ; <END> } 
private void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 ) { METHOD_2 ( ) ; METHOD_3 ( ) ; <START> METHOD_4 ( ) ; <END> } else { METHOD_5 ( ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; } } 
protected boolean METHOD_1 ( ) { final TYPE_1 vm = METHOD_2 ( ) ; <START> if ( vm == null ) { <END> return METHOD_3 ( TYPE_4 . VAR_2 ) ; } if ( ! METHOD_4 ( ) ) { return false ; } if ( METHOD_2 ( ) . getStatus ( ) != TYPE_5 . TYPE_2 && METHOD_2 ( ) . getStatus ( ) != TYPE_5 . TYPE_3 ) { return METHOD_5 ( ) ; } return true ; } 
protected boolean METHOD_1 ( Guid VAR_1 , TYPE_1 VAR_2 ) { return VAR_3 . METHOD_2 ( TYPE_4 . TYPE_5 , new TYPE_2 ( VAR_1 ) , TYPE_3 . METHOD_3 ( VAR_2 ) ) . METHOD_4 ( ) ; <START> } <END> 
public boolean METHOD_1 ( ) { <START> return value == VAR_1 . value ? true : false ; <END> } 
<START> public static TYPE_1 METHOD_1 ( String VAR_1 ) { <END> if ( VAR_1 == null ) { return null ; } String VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { return null ; } for ( TYPE_1 VAR_3 : TYPE_1 . values ( ) ) { if ( VAR_3 . getValue ( ) . equals ( VAR_2 ) ) { return VAR_3 ; } } return null ; } 
<START> public static TYPE_1 METHOD_1 ( String VAR_1 ) { <END> if ( VAR_1 == null ) { return VAR_2 ; } String VAR_3 = METHOD_2 ( VAR_1 ) ; if ( VAR_3 == null ) { return VAR_2 ; } for ( TYPE_1 VAR_4 : TYPE_1 . values ( ) ) { if ( VAR_4 . getValue ( ) . equals ( VAR_3 ) ) { return VAR_4 ; } } return VAR_2 ; } 
public TYPE_1 ( String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 , String VAR_6 , String VAR_7 , List < Map > VAR_8 , boolean VAR_9 ) { METHOD_1 ( VAR_2 ) ; METHOD_2 ( VAR_3 ) ; METHOD_3 ( VAR_4 ) ; METHOD_4 ( VAR_5 ) ; METHOD_5 ( VAR_6 ) ; <START> METHOD_6 ( STRING_1 ) ; <END> METHOD_7 ( VAR_8 ) ; METHOD_8 ( VAR_9 ) ; } 
<START> private TYPE_1 METHOD_1 ( ) { <END> return TYPE_2 . getInstance ( ) . METHOD_1 ( ) ; } 
public Response add ( TYPE_1 VAR_1 ) { if ( ! VAR_1 . METHOD_1 ( ) ) { VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <START> } <END> METHOD_4 ( VAR_1 , STRING_1 ) ; return METHOD_5 ( TYPE_3 . TYPE_4 , new TYPE_2 ( null , map ( VAR_1 ) ) , VAR_4 ) ; } 
<START> public boolean METHOD_1 ( ) { <END> return VAR_1 ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_1 VAR_3 ) { if ( VAR_1 != null ) { return VAR_1 ; } else if ( VAR_2 != null ) { return VAR_2 ; } else { return VAR_3 ; <START> } <END> } 
private Guid METHOD_1 ( ) { <START> return getParameters ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; <END> } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> if ( METHOD_3 ( ) ) { getParameters ( ) . METHOD_4 ( true ) ; METHOD_5 ( getParameters ( ) . METHOD_6 ( ) , true ) ; } METHOD_7 ( ) ; METHOD_8 ( true ) ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return super . equals ( obj ) && TYPE_2 . equals ( VAR_2 , <START> VAR_2 ) <END> && TYPE_2 . equals ( VAR_3 , VAR_1 . VAR_3 ) ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof TYPE_1 ) ) <START> return false ; <END> TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return TYPE_2 . equals ( VAR_2 , VAR_1 . VAR_2 ) && TYPE_2 . equals ( VAR_3 , VAR_1 . VAR_3 ) && TYPE_2 . equals ( VAR_4 , VAR_1 . VAR_4 ) && TYPE_2 . equals ( VAR_5 , VAR_1 . VAR_5 ) ; } 
public int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 , METHOD_3 ( ) , VAR_2 ) ; <START> } <END> 
public void METHOD_1 ( ) { try { String key = STRING_1 ; TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( key ) ; METHOD_3 ( STRING_2 ) ; <START> } catch ( TYPE_2 e ) { <END> assertNotNull ( e ) ; } } 
private List < TYPE_1 > METHOD_1 ( final TYPE_2 VAR_1 , final Guid VAR_2 ) { List < TYPE_1 > VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) ; return VAR_3 . stream ( ) . filter ( <START> v - > <END> v . VAR_4 ( ) == TYPE_3 . VAR_6 && ! v . VAR_7 ( ) . contains ( VAR_2 ) ) . collect ( Collectors . VAR_8 ( ) ) ; } 
protected void METHOD_1 ( final TYPE_1 VAR_1 ) { final TYPE_2 VAR_2 ; <START> if ( getParameters ( ) . METHOD_2 ( ) ) { <END> VAR_2 = METHOD_3 ( VAR_1 ) ; } else { VAR_2 = null ; } TYPE_3 . METHOD_4 ( TYPE_5 . TYPE_6 , new TYPE_4 < Object > ( ) { @Override public Object METHOD_5 ( ) { METHOD_6 ( VAR_1 , VAR_2 ) ; return null ; } } ) ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; VAR_1 = VAR_2 . METHOD_2 ( ) ; TYPE_1 VAR_3 = VAR_2 . METHOD_3 ( ) ; TYPE_2 VAR_4 = VAR_3 . get ( STRING_1 ) ; TYPE_2 <START> VAR_5 = <END> new TYPE_2 ( ) ; VAR_5 . METHOD_4 ( STRING_2 ) ; VAR_5 . METHOD_5 ( VAR_6 ) ; VAR_7 = VAR_1 . get ( new TYPE_3 ( STRING_3 , VAR_4 . METHOD_6 ( ) ) ) ; VAR_8 = new TYPE_4 ( VAR_9 , VAR_4 . METHOD_6 ( ) ) ; } 
private void METHOD_1 ( ) { log . info ( STRING_1 , getClass ( ) . METHOD_2 ( ) ) ; Integer VAR_1 = TYPE_2 < Integer > getValue ( TYPE_3 . TYPE_4 ) ; if ( VAR_1 > 0 ) { VAR_5 . METHOD_3 ( this , STRING_2 , new Class [ ] { } , new Object [ ] { } , VAR_1 , VAR_1 , TimeUnit . VAR_6 ) ; log . info ( STRING_3 , getClass ( ) . METHOD_2 ( ) ) ; } <START> VAR_7 = new TYPE_1 ( ) ; <END> } 
private long METHOD_1 ( ) { int index = VAR_1 . METHOD_2 ( VAR_2 ) ; boolean VAR_3 = index == VAR_4 ; if ( VAR_3 ) { index = VAR_1 . METHOD_2 ( 0 ) ; } <START> VAR_2 = index + 1 ; <END> return VAR_5 + index ; } 
<START> public boolean METHOD_1 ( Type type ) { <END> for ( TYPE_1 name : TYPE_2 ) { if ( name . toString ( ) . equals ( type . getName ( ) . toString ( ) ) ) { return true ; } } return false ; } 
private void METHOD_1 ( List < TYPE_1 > VAR_1 ) { final List < TYPE_1 > VAR_2 = VAR_1 . stream ( ) . filter ( host - > host . VAR_3 ( ) && host . getStatus ( ) == TYPE_4 . TYPE_5 ) . collect ( Collectors . VAR_6 ( ) ) ; if ( VAR_2 . size ( ) > 0 ) { TYPE_2 task = ( ) - > { METHOD_2 ( ) ; METHOD_3 ( VAR_2 ) ; } ; <START> TYPE_3 . execute ( task ) ; <END> } } 
public void METHOD_1 ( String message ) { super . METHOD_1 ( message ) ; if ( message != null && message . length ( ) > 0 ) { table . VAR_1 ( false ) ; } if ( message != null ) { <START> VAR_2 . setText ( message ) ; <END> } } 
public String toString ( ) { <START> return TYPE_1 . toString ( METHOD_1 ( ) , null ) + CHAR_1 + TYPE_1 . toString ( METHOD_2 ( ) , null ) ; <END> } 
public TYPE_2 ( ) { this . VAR_2 = "" ; this . VAR_3 = Guid . TYPE_1 ; <START> this . VAR_5 = false ; <END> } 
private void update ( List < TYPE_1 > VAR_1 ) { <START> if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { <END> for ( TYPE_1 VAR_2 : VAR_1 ) { TYPE_2 VAR_3 = VAR_2 . METHOD_1 ( ) ; VAR_4 . update ( VAR_3 ) ; } } } 
public boolean equals ( Object o ) { <START> if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; <END> TYPE_1 that = ( TYPE_1 ) o ; return TYPE_2 . equals ( name , that . name ) && TYPE_2 . equals ( version , that . version ) && TYPE_2 . equals ( id , that . id ) ; } 
<START> TYPE_2 ( TYPE_1 parameters ) { <END> super ( parameters ) ; } 
public String METHOD_1 ( ) { StringBuilder VAR_1 = new <START> StringBuilder ( "" ) ; <END> int VAR_2 = METHOD_2 ( ) . size ( ) ; for ( TYPE_2 . TYPE_3 VAR_3 : METHOD_2 ( ) ) { VAR_1 . append ( VAR_3 . METHOD_3 ( ) ) ; if ( VAR_2 != 1 ) { VAR_1 . append ( STRING_1 ) ; } VAR_2 -- ; } return VAR_1 . toString ( ) ; } 
private TYPE_1 < TYPE_2 < ? > > METHOD_1 ( TYPE_3 VAR_1 ) { return VAR_2 - > { <START> int VAR_3 = VAR_2 . METHOD_2 ( ) ; <END> return TYPE_4 . METHOD_3 ( VAR_3 ) || ( ! VAR_1 . equals ( VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) && ! TYPE_4 . METHOD_6 ( VAR_3 ) ) ; } ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_2 = TYPE_3 . METHOD_3 ( ) ; <START> } <END> if ( VAR_2 . METHOD_4 ( new TYPE_3 ( 3 , INT_1 ) ) ) { return new TYPE_5 ( ) ; } else { return new TYPE_6 ( ) ; } } 
<START> boolean METHOD_1 ( ) <END> { METHOD_2 ( ) . METHOD_3 ( new TYPE_1 [ ] { new TYPE_2 ( TYPE_4 . VAR_2 ) , new TYPE_3 ( ) } ) ; return METHOD_2 ( ) . METHOD_4 ( ) ; } 
public void METHOD_1 ( ) { VAR_1 = METHOD_2 ( TYPE_1 . class , TYPE_2 . class ) ; <START> } <END> 
<START> protected void <END> METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { VAR_3 . log ( VAR_1 , VAR_2 ) ; } 
private void METHOD_1 ( ) { <START> for ( TYPE_1 VAR_1 : getParameters ( ) . METHOD_2 ( ) ) { <END> if ( VAR_1 . METHOD_3 ( ) == null ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_4 ( ) ; VAR_1 . METHOD_5 ( VAR_2 ) ; } } } 
private TYPE_1 METHOD_1 ( ) { final TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> TYPE_1 VAR_2 = null ; <END> if ( TYPE_3 . METHOD_3 ( VAR_1 ) && TYPE_4 < Boolean > getValue ( TYPE_5 . TYPE_6 ) ) { VAR_2 = VAR_6 . METHOD_4 ( TYPE_1 . VAR_7 ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) { return TYPE_1 . METHOD_2 ( TYPE_3 . VAR_3 , TYPE_2 . METHOD_3 ( VAR_4 , VAR_5 . getName ( ) ) , TYPE_2 . METHOD_3 ( VAR_6 , VAR_5 . METHOD_4 ( ) ) ) <START> . when ( VAR_1 & VAR_5 . METHOD_4 ( ) != null ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 vm ) { if ( vm . getStatus ( ) == TYPE_5 . TYPE_4 || vm . getStatus ( ) == TYPE_5 . TYPE_6 || vm . getStatus ( ) == TYPE_5 . TYPE_3 ) { TYPE_2 VAR_5 = vm . VAR_6 ( ) ; return VAR_5 == null ? false <START> : VAR_5 . METHOD_2 ( VAR_7 ) ; <END> } return true ; } 
protected List < Guid > METHOD_1 ( Guid VAR_1 ) { return getParameters ( ) . METHOD_2 ( ) . stream ( ) <START> . filter ( ( VAR_2 ) - > METHOD_3 ( VAR_1 , VAR_2 ) ) <END> . collect ( METHOD_4 ( ) ) ; } 
public static Collection < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { return METHOD_2 ( VAR_1 , new TYPE_2 < TYPE_1 > ( ) { @Override public boolean METHOD_3 ( TYPE_1 i ) { return <START> ! TYPE_3 . METHOD_4 ( i . VAR_2 ( ) ) ; <END> } } ) ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 , Object [ ] VAR_2 ) { TYPE_2 connection = null ; try { connection = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; return connection . VAR_3 ( VAR_1 , VAR_2 ) ; } catch ( TYPE_3 e ) { throw new RuntimeException ( e ) ; } finally { if ( connection != null ) { <START> try { connection . close ( ) ; } catch ( TYPE_3 e ) { } <END> } } } 
public void METHOD_1 ( String VAR_1 , TYPE_1 host ) { <START> VAR_2 . put ( VAR_1 , host ) ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 , Guid VAR_2 , TYPE_2 cache ) { <START> if ( cache == null ) { cache = new TYPE_2 ( ) ; } <END> Map < String , Long > VAR_3 = METHOD_2 ( VAR_2 , cache ) ; if ( VAR_3 == null ) { return ; } if ( VAR_1 . METHOD_3 ( ) == null ) { VAR_1 . METHOD_4 ( new HashMap < > ( ) ) ; } VAR_1 . METHOD_3 ( ) . put ( TYPE_4 . TYPE_3 , VAR_3 ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { <START> HashMap < String , TYPE_1 > VAR_2 = new HashMap < > ( ) ; <END> METHOD_1 ( VAR_1 , TYPE_2 . VAR_4 , VAR_2 ) ; VAR_1 . put ( TYPE_2 . VAR_4 , new ArrayList < > ( VAR_2 . values ( ) ) ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( ( ) - > { <END> METHOD_3 ( true ) ; return null ; } ) ; log . info ( STRING_1 , METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) , METHOD_4 ( ) . METHOD_7 ( ) , METHOD_8 ( ) != null ? METHOD_8 ( ) . METHOD_7 ( ) : STRING_2 ) ; } 
public boolean METHOD_1 ( TYPE_1 vm ) { if ( vm == null ) { return true ; } TYPE_2 VAR_1 = vm . VAR_2 ( ) ; TYPE_2 VAR_3 = vm . VAR_4 ( ) ; if ( vm . VAR_5 ( ) != null ) { return true ; <START> } <END> return VAR_3 != null && VAR_1 . METHOD_2 ( ) == VAR_3 . METHOD_2 ( ) && VAR_1 . METHOD_3 ( ) == VAR_3 . METHOD_3 ( ) ; } 
private TYPE_1 METHOD_1 ( Map < TYPE_1 , Set < Guid > > VAR_1 ) { if ( VAR_1 != null ) { for ( Map . Entry < TYPE_1 , Set < Guid > > entry : VAR_1 . entrySet ( ) ) { TYPE_1 VAR_2 = entry . getKey ( ) ; TYPE_2 VAR_3 = VAR_2 . METHOD_2 ( ) ; if ( TYPE_3 . equals ( VAR_3 . METHOD_3 ( ) , id ) ) { return VAR_2 ; } } <START> } METHOD_4 ( ) ; return null ; <END> } 
public String METHOD_1 ( final String VAR_1 , final TYPE_1 VAR_2 ) { String VAR_3 = "" ; TYPE_2 VAR_4 = METHOD_2 ( VAR_2 == null ? TYPE_1 . METHOD_3 ( ) : VAR_2 ) ; if ( VAR_4 != null && VAR_4 . containsKey ( VAR_1 ) ) { VAR_3 = VAR_4 . getString ( VAR_1 ) ; } else if ( ! StringUtils . isEmpty ( VAR_1 ) ) { <START> VAR_3 = StringUtils . VAR_5 ( VAR_1 . METHOD_4 ( ) . split ( STRING_1 , - 1 ) , STRING_2 ) ; <END> } return VAR_3 ; } 
<START> private synchronized TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> try { if ( ! VAR_2 . containsKey ( VAR_1 ) ) { VAR_2 . put ( VAR_1 , TYPE_1 . METHOD_2 ( VAR_3 , VAR_1 ) ) ; } } catch ( RuntimeException e ) { log . error ( STRING_1 , VAR_3 , e . getMessage ( ) ) ; log . debug ( STRING_2 , e ) ; } return VAR_2 . get ( VAR_1 ) ; } 
private void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( ) ; <END> TYPE_2 . getInstance ( ) . METHOD_3 ( TYPE_5 . TYPE_4 , new TYPE_3 ( VAR_1 . METHOD_4 ( ) , VAR_1 . getId ( ) ) ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 , Guid VAR_3 ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; } 
public TYPE_1 ( Map < String , Object > VAR_2 ) { super ( VAR_2 ) ; Object VAR_3 = VAR_2 . get ( VAR_4 ) ; if ( VAR_3 != null ) { <START> VAR_5 = ( Map < String , Object > ) VAR_2 . get ( VAR_4 ) ; <END> } } 
private void METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( Guid VAR_2 : VAR_3 ) { VAR_4 . remove ( VAR_2 ) ; } for ( Iterator < TYPE_1 > iterator = VAR_1 . iterator ( ) ; iterator . hasNext ( ) ; ) { Guid VAR_5 = iterator . next ( ) . getId ( ) ; if <START> ( VAR_5 != null && <END> VAR_3 . contains ( VAR_5 ) ) { iterator . remove ( ) ; break ; } } } 
public boolean METHOD_1 ( long VAR_1 ) { TYPE_1 VAR_2 ; for ( Guid VAR_3 : TYPE_2 . METHOD_2 ( VAR_1 ) ) { VAR_2 = TYPE_2 . METHOD_3 ( VAR_3 ) ; if ( VAR_2 == TYPE_1 . VAR_4 || VAR_2 == TYPE_1 . VAR_5 ) { return true ; } } <START> if ( ! VAR_6 . METHOD_4 ( VAR_1 , TYPE_3 . VAR_8 ) . isEmpty ( ) ) { <END> return true ; } return false ; } 
protected void METHOD_1 ( TYPE_1 client ) { String VAR_1 = <START> ( ( TYPE_2 ) VAR_2 . METHOD_2 ( ) ) . METHOD_3 ( ) ; <END> TYPE_3 VAR_3 = new TYPE_3 ( VAR_2 . METHOD_4 ( ) , VAR_2 . METHOD_5 ( ) , VAR_2 . METHOD_6 ( ) ) ; client . VAR_4 ( VAR_3 . METHOD_7 ( VAR_1 ) ) ; } 
protected Map < String , String > METHOD_1 ( TYPE_1 VAR_1 ) { Map < String , String > VAR_2 = super . METHOD_1 ( VAR_1 ) ; VAR_2 . put ( STRING_1 , <START> ( ( TYPE_2 ) <END> VAR_3 . METHOD_2 ( ) ) . METHOD_3 ( ) ) ; return VAR_2 ; } 
public void METHOD_1 ( ) { TYPE_1 object = METHOD_2 ( STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 ) ; List < TYPE_2 > VAR_1 = Arrays . asList ( new TYPE_2 [ ] { TYPE_2 . VAR_2 , TYPE_2 . VAR_3 } ) ; <START> assertThat ( object . VAR_4 ( ) , is ( VAR_1 ) ) ; <END> } 
public final void METHOD_1 ( String VAR_1 ) { <START> if ( StringUtils . VAR_2 ( VAR_1 ) && METHOD_2 ( VAR_1 ) ) { <END> METHOD_3 ( VAR_1 , VAR_3 , new Date ( ) ) ; } } 
public void METHOD_1 ( boolean VAR_1 , String VAR_2 ) { <START> VAR_3 . METHOD_2 ( VAR_1 ) ; <END> VAR_3 . METHOD_3 ( VAR_1 ) ; if ( ! VAR_1 ) { VAR_4 . setText ( VAR_2 ) ; } } 
private Integer METHOD_1 ( Guid VAR_1 ) { Integer VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null ) { return VAR_2 ; } Integer VAR_3 = METHOD_3 ( VAR_1 ) ; <START> return VAR_3 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 object = METHOD_2 ( STRING_1 ) ; List < Boolean > VAR_1 = Arrays . asList ( false , true ) ; <START> assertEquals ( VAR_1 , object . properties ( ) ) ; <END> } 
public void METHOD_1 ( ) { List < Boolean > VAR_1 = Arrays . asList ( true , false ) ; TYPE_1 reader = METHOD_2 ( STRING_1 ) ; reader . next ( ) ; List < Boolean > VAR_2 = reader . VAR_3 ( ) ; assertEquals ( TYPE_2 . VAR_5 , reader . VAR_6 ( ) ) ; assertEquals ( STRING_2 , reader . VAR_7 ( ) ) ; assertEquals ( VAR_1 , VAR_2 ) ; <START> } <END> 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_4 . VAR_2 ) { TYPE_1 . METHOD_4 ( METHOD_2 ( ) . METHOD_5 ( ) , METHOD_6 ( ) . METHOD_7 ( ) ) ; <START> TYPE_2 VAR_3 = TYPE_3 . getInstance ( ) . METHOD_8 ( ) ; <END> VAR_3 . METHOD_9 ( METHOD_2 ( ) . METHOD_5 ( ) . METHOD_10 ( ) . values ( ) ) ; } } 
private TYPE_5 ( TYPE_1 props , File file ) { this . file = file ; this . name = props . getProperty ( TYPE_4 . TYPE_2 . VAR_4 , String . format ( STRING_1 , VAR_5 ++ ) ) ; this . VAR_6 = Boolean . valueOf ( props . getProperty ( TYPE_4 . TYPE_2 . VAR_7 , STRING_2 ) ) ; <START> this . VAR_8 = Boolean . valueOf ( props . getProperty ( TYPE_3 . TYPE_2 . VAR_10 . METHOD_1 ( ) . getName ( ) , STRING_3 ) ) ; <END> } 
public static long METHOD_1 ( TYPE_1 vm ) { long VAR_1 = ( long ) TYPE_2 . METHOD_2 ( vm ) * INT_1 * INT_1 ; <START> return vm . VAR_2 ( ) + INT_2 + VAR_1 ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 = VAR_2 ? VAR_1 : false ; <END> } 
public TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( VAR_2 ) ; if ( VAR_1 != null ) { return VAR_1 ; } <START> throw new RuntimeException ( STRING_1 + VAR_2 ) ; <END> } 
public TYPE_1 ( ) { VAR_2 = false ; VAR_3 = 100 ; VAR_4 = VAR_5 ; VAR_6 = VAR_7 ; VAR_8 = VAR_9 ; name = "" ; VAR_10 = "" ; VAR_11 = TYPE_2 . VAR_13 ; VAR_14 = true ; VAR_15 = false ; VAR_16 = true ; VAR_17 = null ; VAR_18 = null ; <START> VAR_19 = null ; <END> } 
public int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( id , VAR_1 , VAR_2 , name , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 , VAR_16 , <START> VAR_16 , <END> VAR_17 , VAR_18 , VAR_19 , VAR_20 , VAR_21 , VAR_22 , VAR_23 ) ; } 
<START> protected Map < Guid , <END> Integer > METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { TYPE_2 result = METHOD_2 ( TYPE_5 . TYPE_4 , new TYPE_3 ( VAR_1 . getId ( ) , VAR_2 ) ) ; if ( result . VAR_5 ( ) ) { return ( Map < Guid , Integer > ) result . VAR_6 ( ) ; } else { return Collections . VAR_7 ( ) ; } } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 . METHOD_2 ( ) ) { <START> if ( VAR_2 . METHOD_3 ( ) != null && VAR_2 . METHOD_3 ( ) > 0 ) { <END> return true ; } } return false ; } 
private TYPE_1 METHOD_1 ( Map < TYPE_1 , Set < Guid > > VAR_1 ) { TYPE_1 result = VAR_1 == null ? null : VAR_1 . keySet ( ) . stream ( ) . filter ( VAR_2 - > TYPE_2 . equals ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) , id ) ) . METHOD_4 ( ) <START> . METHOD_5 ( null ) ; <END> if ( result == null ) { METHOD_6 ( ) ; } return result ; } 
protected boolean METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; boolean VAR_3 = METHOD_3 ( ) . METHOD_4 ( ) || METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ; return getParameters ( ) . METHOD_7 ( ) ? VAR_3 && METHOD_5 ( VAR_2 . METHOD_8 ( ) ) <START> : VAR_3 ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if <START> ( ! VAR_3 . get ( VAR_2 . getId ( ) ) . contains ( VAR_1 ) ) <END> { METHOD_2 ( VAR_4 . METHOD_3 ( ) ) ; return false ; } return true ; } 
public static int METHOD_1 ( String VAR_1 ) { if ( STRING_1 . equals ( VAR_1 ) ) { return 0 ; } else if ( STRING_2 . equals ( VAR_1 ) ) { return 2 ; } else if ( STRING_3 . equals ( VAR_1 ) ) { return 0 ; } <START> return - 1 ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> this . METHOD_2 ( STRING_1 , <END> METHOD_3 ( ) . METHOD_4 ( ) ) ; return METHOD_5 ( ) ? TYPE_1 . VAR_1 : TYPE_1 . VAR_2 ; } 
public TYPE_1 METHOD_1 ( Guid VAR_1 ) { <START> return TYPE_2 . getInstance ( ) . METHOD_2 ( ) . get ( VAR_1 ) ; <END> } 
private void METHOD_1 ( ) { <START> Guid VAR_1 = ! getParameters ( ) . METHOD_2 ( ) ? Guid . VAR_2 ( ) : getParameters ( ) . METHOD_3 ( ) . getId ( ) ; <END> getParameters ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; if ( ! METHOD_5 ( ) ) { METHOD_6 ( ) . getId ( ) . METHOD_7 ( VAR_1 ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( TYPE_5 . TYPE_4 , new TYPE_3 ( getParameters ( ) . METHOD_3 ( ) ) ) ; <START> METHOD_4 ( ) . METHOD_5 ( ) . addAll ( VAR_1 . METHOD_6 ( ) ) ; <END> } 
protected void METHOD_1 ( String VAR_1 ) { VAR_1 = <START> VAR_1 . isEmpty ( ) ? <END> null : VAR_1 ; TYPE_1 . METHOD_1 ( METHOD_2 ( ) , METHOD_3 ( ) , VAR_1 ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 ) { <START> TYPE_2 . METHOD_1 ( VAR_2 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = new TYPE_3 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 result = METHOD_2 ( ) ; if ( ! result . VAR_1 ( ) ) { return result ; } if <START> ( ! ( result = METHOD_3 ( ) ) . METHOD_4 ( ) ) <END> { return result ; } return super . METHOD_1 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) { <END> final TYPE_2 VAR_2 = TYPE_3 . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( Collections . VAR_3 ( VAR_2 ) ) ; } if ( VAR_1 . METHOD_5 ( ) . isEmpty ( ) ) { final TYPE_4 VAR_4 = TYPE_3 . METHOD_6 ( ) ; VAR_1 . METHOD_7 ( Collections . VAR_3 ( VAR_4 ) ) ; } } 
<START> public void <END> METHOD_1 ( ArrayList < TYPE_1 > parameters ) { if ( ! parameters . isEmpty ( ) ) { TYPE_2 . METHOD_2 ( parameters ) ; METHOD_3 ( TYPE_3 . TYPE_4 , parameters ) ; } } 
<START> public TYPE_1 <END> METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_2 ( Guid . VAR_4 ( ) ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; VAR_3 . METHOD_4 ( VAR_1 . getId ( ) ) ; return VAR_3 ; } 
public void METHOD_1 ( ) { Guid VAR_1 = METHOD_2 ( ) ; if <START> ( ! Guid . VAR_2 ( VAR_1 ) ) <END> { METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) . METHOD_6 ( VAR_1 ) . METHOD_3 ( ) ) ; } else { METHOD_3 ( ) . METHOD_4 ( TYPE_2 . TYPE_1 ) ; } } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = getParameters ( ) . METHOD_2 ( ) ; return VAR_1 != null && METHOD_3 ( ) . METHOD_4 ( ) && <START> ( METHOD_3 ( ) . METHOD_5 ( ) == null || ! VAR_1 . equals ( METHOD_3 ( ) . METHOD_6 ( ) ) ) ; <END> } 
private String METHOD_1 ( String VAR_1 ) { if ( VAR_1 . equals ( STRING_1 ) ) { return STRING_2 ; } if ( VAR_1 . equals ( STRING_3 ) ) { return STRING_4 ; } if ( VAR_1 . equals ( STRING_5 ) ) { return STRING_6 ; } if ( VAR_1 . equals ( STRING_7 ) ) { return STRING_8 ; <START> } <END> return "" ; } 
public String METHOD_1 ( ) { <START> return VAR_1 == null ? "" : VAR_1 ; <END> } 
public TYPE_3 ( Map < String , Object > VAR_2 ) { status = new TYPE_1 ( ( Map < String , Object > ) VAR_2 . get ( VAR_3 ) ) ; Object [ ] VAR_4 = ( Object [ ] ) VAR_2 . get ( VAR_5 ) ; if ( VAR_4 != null ) { VAR_6 = <START> Arrays . asList ( VAR_4 ) . stream ( ) . map ( TYPE_2 : : toString ) . collect ( Collectors . VAR_7 ( ) ) ; <END> } } 
public String METHOD_1 ( ) { return <START> this . url ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . get ( new TYPE_2 ( VAR_3 , TYPE_3 . VAR_5 ) ) ; assertTrue ( VAR_1 . METHOD_2 ( ) ) ; <START> TYPE_1 VAR_6 = VAR_2 . get ( new TYPE_2 ( VAR_7 , TYPE_3 . VAR_5 ) ) ; METHOD_3 ( VAR_6 . METHOD_2 ( ) ) ; <END> } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; for ( int i = 0 ; i <START> == VAR_2 ; <END> i ++ ) { TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_2 ( Guid . VAR_4 ( ) . toString ( ) ) ; VAR_1 . add ( VAR_3 ) ; } return VAR_1 ; } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; for ( int i = 0 ; i <START> <= VAR_2 ; <END> i ++ ) { TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_2 ( Guid . VAR_4 ( ) . toString ( ) ) ; VAR_1 . add ( VAR_3 ) ; } return VAR_1 ; } 
private void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( ( ) - > { METHOD_4 ( ) . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; METHOD_4 ( ) . METHOD_7 ( ) ; VAR_1 . METHOD_8 ( TYPE_4 . VAR_3 ) ; TYPE_3 . METHOD_9 ( VAR_1 . METHOD_10 ( ) , TYPE_4 . VAR_3 ) ; return null ; <START> } ) ; <END> } 
private Map < String , Pair < String , String > > METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> return Collections . VAR_1 ( METHOD_3 ( ) . toString ( ) , TYPE_1 . METHOD_4 ( TYPE_2 . VAR_3 , TYPE_3 . VAR_5 ) ) ; } 
public boolean METHOD_1 ( ) { return this == <START> TYPE_1 . VAR_2 <END> || this == TYPE_1 . VAR_3 ; } 
private boolean METHOD_1 ( Guid VAR_1 ) { <START> return METHOD_2 ( ) . METHOD_3 ( VAR_1 ) . size ( ) == 0 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( TYPE_1 . TYPE_2 . VAR_3 ) ; <END> METHOD_3 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( Guid VAR_1 , TYPE_2 VAR_2 ) { final TYPE_1 VAR_3 ; try { VAR_3 = METHOD_2 ( METHOD_3 ( VAR_1 ) , VAR_2 ) ; } catch ( Exception e ) { <START> throw new IllegalStateException ( String . format ( STRING_1 , VAR_1 ) , <END> e ) ; } return VAR_3 ; } 
<START> private static IllegalStateException <END> METHOD_1 ( Guid VAR_1 ) { final String msg = String . format ( VAR_2 , VAR_1 ) ; return new IllegalStateException ( msg ) ; } 
boolean METHOD_1 ( String VAR_1 , boolean VAR_2 ) { TYPE_1 VAR_3 = METHOD_2 ( VAR_1 ) ; if ( VAR_3 == null ) { return false ; } boolean VAR_4 = VAR_3 . METHOD_3 ( TYPE_2 . VAR_6 ) || VAR_3 . METHOD_3 ( TYPE_2 . VAR_7 ) ; boolean VAR_8 = VAR_3 . METHOD_3 ( TYPE_2 . VAR_9 ) ; <START> return VAR_2 ? ( VAR_8 || VAR_4 ) : VAR_4 ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . name ( STRING_1 ) . METHOD_5 ( METHOD_5 ( ) . options ( METHOD_6 ( ) . name ( STRING_2 ) . type ( STRING_3 ) <START> . build ( ) <END> ) . METHOD_7 ( METHOD_4 ( ) . name ( STRING_4 ) . build ( ) , METHOD_4 ( ) . name ( STRING_5 ) . build ( ) ) . build ( ) ) . build ( ) ) . METHOD_8 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( getParameters ( ) . METHOD_2 ( ) ) { return new TYPE_2 ( ) ; } <START> return new TYPE_3 ( ) ; <END> } 
public void METHOD_1 ( Context context , TYPE_1 parent , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 event , TYPE_5 < TYPE_2 > VAR_3 ) { TYPE_6 status = TYPE_7 . METHOD_2 ( VAR_1 ) ; if ( TYPE_9 . TYPE_10 . equals ( event . getType ( ) ) && VAR_4 != null && ( status == TYPE_6 . VAR_5 || status == TYPE_6 . VAR_6 ) ) { VAR_4 . execute ( ) ; } else { <START> super . METHOD_1 ( context , parent , VAR_1 , VAR_2 , event , VAR_3 ) ; <END> } } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_3 . VAR_2 && METHOD_4 ( ) == TYPE_4 . VAR_4 ) { TYPE_1 VAR_5 = VAR_6 . get ( METHOD_5 ( ) ) ; for ( TYPE_2 VAR_7 : METHOD_2 ( ) . METHOD_6 ( ) ) { if ( VAR_5 . METHOD_7 ( ) . METHOD_8 ( ) ) { VAR_7 . METHOD_9 ( VAR_7 . METHOD_10 ( ) ) ; <START> } <END> } } } 
private void METHOD_1 ( ) { for ( TYPE_1 < ? > command : METHOD_2 ( ) ) { if ( command . VAR_1 ( ) . METHOD_3 ( ) ) { command . VAR_2 ( ) ; } } <START> } <END> 
private boolean METHOD_1 ( ) { ArrayList < TYPE_1 > VAR_1 = METHOD_2 ( ) != null ? TYPE_2 < TYPE_1 > METHOD_3 ( METHOD_2 ( ) ) : new ArrayList < TYPE_1 > ( ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { if ( METHOD_4 ( VAR_3 ) <START> || <END> ( ! METHOD_5 ( ) && VAR_3 . METHOD_6 ( ) ) ) { return false ; } } return true ; } 
public void METHOD_1 ( File VAR_1 ) { <START> this . VAR_2 <END> = VAR_1 ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; group . VAR_1 ( TYPE_1 . VAR_2 ) ; when ( command . VAR_3 ( METHOD_3 ( Guid . VAR_4 ) ) ) . METHOD_4 ( true ) ; when ( VAR_5 . METHOD_5 ( METHOD_3 ( Integer . VAR_4 ) , METHOD_3 ( TYPE_1 . VAR_4 ) ) ) . METHOD_4 ( <START> new ArrayList < > ( Collections . VAR_6 ( STRING_1 ) ) ) ; <END> TYPE_2 . METHOD_6 ( command , TYPE_3 . VAR_8 ) ; } 
protected void METHOD_1 ( boolean debug ) throws <START> Exception { <END> TYPE_1 field = TYPE_2 . class . METHOD_2 ( STRING_1 ) ; Logger logger = METHOD_3 ( Logger . VAR_1 ) ; when ( logger . VAR_2 ( ) ) . METHOD_4 ( debug ) ; METHOD_5 ( field , logger ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_1 ( ) ; VAR_2 . METHOD_1 ( ) ; VAR_3 . METHOD_1 ( ) ; <END> VAR_4 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_1 ( ) ; <END> VAR_2 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> } 
<START> public TYPE_1 <END> METHOD_1 ( String VAR_1 ) throws RuntimeException { log . info ( STRING_1 ) ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 ) ; return VAR_2 ; } 
<START> public TYPE_1 <END> METHOD_1 ( String VAR_1 ) { log . info ( STRING_1 , VAR_1 ) ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 ) ; return VAR_2 ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <END> TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_3 . METHOD_2 ( this ) ; VAR_3 . VAR_4 = new TYPE_4 ( ) { @Override public void METHOD_3 ( Object model , Object TYPE_7 ) { METHOD_4 ( ( Collection < T > ) ( ( TYPE_5 ) TYPE_7 ) . METHOD_5 ( ) ) ; } } ; VAR_2 . METHOD_6 ( METHOD_7 ( ) ) ; TYPE_6 . getInstance ( ) . METHOD_8 ( VAR_1 , VAR_2 , VAR_3 ) ; METHOD_9 ( false ) ; } 
public String get ( String VAR_1 , String VAR_2 ) { if ( VAR_1 != null ) { return VAR_1 ; } if ( VAR_2 != null ) { TYPE_1 VAR_3 = VAR_4 . METHOD_1 ( TYPE_1 . class , TYPE_3 . TYPE_4 , new TYPE_2 ( VAR_2 ) , <START> null , <END> true ) ; if ( VAR_3 != null ) { return VAR_3 . getId ( ) . toString ( ) ; } } return null ; } 
<START> public TYPE_1 <END> METHOD_1 ( TYPE_2 vm ) { if ( ! TYPE_3 . METHOD_2 ( vm . VAR_1 ( ) , vm . VAR_2 ( ) , TYPE_5 . TYPE_4 ) ) { return new TYPE_1 ( TYPE_6 . VAR_6 ) ; } return TYPE_1 . VAR_7 ; } 
public void METHOD_1 ( TYPE_1 vm , Boolean VAR_1 ) { if ( VAR_1 == null ) { return ; } if ( VAR_1 ) { <START> if ( ! METHOD_2 ( vm . getId ( ) ) ) { <END> METHOD_3 ( vm ) ; } } else { METHOD_4 ( vm . getId ( ) ) ; } } 
public TYPE_1 ( Guid VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . get ( 0 ) . equals ( VAR_2 ) || <START> VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . get ( 0 ) . equals ( VAR_3 ) ? <END> ( TYPE_1 ) VAR_1 . getParameters ( ) . get ( 0 ) : VAR_1 ; } 
public static <START> String METHOD_1 ( Object ... <END> params ) { return "" ; } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof TYPE_1 ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> return TYPE_2 . equals ( METHOD_1 ( ) , that . VAR_1 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( this . VAR_1 . METHOD_2 ( ) ) ; <END> } 
public TYPE_4 ( ) { VAR_2 = new TYPE_1 ( TYPE_2 . VAR_4 ) ; METHOD_1 ( TYPE_5 . VAR_6 . METHOD_2 ( this ) ) ; TYPE_3 . VAR_8 . METHOD_3 ( this ) ; VAR_9 . METHOD_4 ( this ) ; <START> VAR_2 . METHOD_5 ( VAR_10 . METHOD_6 ( ) ) ; <END> } 
private static TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( ) ; TYPE_3 VAR_2 = new TYPE_3 ( null , VAR_3 ) ; VAR_2 . METHOD_2 ( TYPE_4 . VAR_5 ) ; <START> VAR_2 . METHOD_3 ( true ) ; <END> return new TYPE_1 ( VAR_2 , VAR_1 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; command . getParameters ( ) . METHOD_3 ( VAR_1 ) ; <START> TYPE_2 VAR_2 = new TYPE_2 ( ) ; <END> command . getParameters ( ) . METHOD_4 ( ) . METHOD_5 ( false ) ; assertTrue ( STRING_1 , command . VAR_3 ( METHOD_6 ( VAR_1 ) ) ) ; } 
<START> private TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( true ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( ) ; TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 . getId ( ) , vm . getId ( ) ) ; VAR_2 . METHOD_2 ( TYPE_6 . TYPE_5 ) ; VAR_1 . METHOD_3 ( Collections . VAR_5 ( VAR_2 ) ) ; <START> when ( TYPE_4 . getInstance ( ) . METHOD_4 ( ) ) . METHOD_5 ( VAR_6 ) ; <END> assertThat ( VAR_7 . METHOD_6 ( Collections . VAR_5 ( VAR_1 ) ) , METHOD_7 ( TYPE_7 . VAR_9 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( METHOD_2 ( ) ) { <END> return new TYPE_2 ( ) ; } return null ; } 
public void METHOD_1 ( Guid VAR_1 , TYPE_1 VAR_2 ) { try { if ( VAR_1 != null ) { TYPE_2 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; if ( VAR_3 != null ) { <START> VAR_3 . METHOD_3 ( 100 ) ; <END> VAR_3 . METHOD_4 ( VAR_2 ) ; VAR_4 . METHOD_5 ( VAR_3 ) ; } } } catch ( Exception e ) { log . error ( STRING_1 , VAR_1 , VAR_2 , e . getMessage ( ) ) ; log . debug ( STRING_2 , e ) ; } } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( STRING_1 , VAR_2 , METHOD_4 ( ) <START> . METHOD_5 ( STRING_2 , 3 ) ) ; <END> METHOD_6 ( VAR_1 ) ; return VAR_1 ; } 
<START> public TYPE_3 ( TYPE_1 <END> VAR_2 , Guid VAR_3 , TYPE_2 VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_4 ; } 
private TYPE_1 ( String value ) { <START> value = <END> value ; } 
public TYPE_1 METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) || getParameters ( ) . METHOD_4 ( ) || <START> TYPE_2 . METHOD_5 ( METHOD_6 ( ) . METHOD_7 ( ) ) ) { <END> return new TYPE_3 ( ) ; } return null ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( TYPE_2 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ) { <END> return new TYPE_3 ( ) ; } if ( METHOD_5 ( ) . METHOD_6 ( ) || getParameters ( ) . METHOD_7 ( ) ) { return new TYPE_3 ( ) ; } return null ; } 
private TYPE_1 METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) ) { return TYPE_1 . TYPE_3 ; } <START> if ( TYPE_2 . METHOD_4 ( METHOD_5 ( ) . METHOD_6 ( ) ) ) { <END> return TYPE_1 . TYPE_5 ; } return TYPE_1 . TYPE_4 ; } 
public void METHOD_1 ( List < String > VAR_1 ) { TYPE_1 VAR_2 = this . VAR_3 . METHOD_2 ( ) ; TYPE_2 VAR_4 = this . VAR_4 ; log . debug ( STRING_1 , <START> Arrays . toString ( VAR_1 . METHOD_3 ( ) ) ) ; <END> VAR_4 . VAR_5 . addAll ( VAR_1 ) ; log . debug ( STRING_2 + VAR_4 ) ; VAR_2 . METHOD_4 ( VAR_4 ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; <START> if ( ! METHOD_2 ( ) ) { <END> VAR_1 . add ( new TYPE_1 ( getParameters ( ) . METHOD_3 ( ) , TYPE_4 . TYPE_2 , TYPE_3 . VAR_5 ) ) ; } else { VAR_1 . add ( new TYPE_1 ( getParameters ( ) . METHOD_4 ( ) , TYPE_4 . TYPE_5 , TYPE_3 . VAR_5 ) ) ; } return VAR_1 ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( TYPE_3 . VAR_3 ) ; <END> TYPE_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , TYPE_3 . VAR_3 ) ; } 
<START> public boolean equals ( Object o ) { <END> if ( o instanceof TYPE_1 ) { TYPE_1 VAR_1 = ( TYPE_1 ) o ; return TYPE_2 . equals ( VAR_1 . VAR_2 , VAR_2 ) && TYPE_2 . equals ( VAR_1 . TYPE_3 , TYPE_3 ) && TYPE_2 . equals ( VAR_1 . VAR_4 , VAR_4 ) ; } return false ; } 
public TYPE_2 ( Guid VAR_2 , TYPE_1 VAR_3 ) { <START> super ( ) ; <END> METHOD_1 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; } 
public TYPE_5 ( ) { super ( ) ; <START> VAR_2 = TYPE_1 . get ( TYPE_2 . class ) ; VAR_3 = TYPE_1 . get ( TYPE_3 . class ) ; VAR_4 = TYPE_1 . get ( TYPE_4 . class ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> Boolean <END> VAR_1 = VAR_2 . METHOD_2 ( ) ; boolean VAR_3 = ! VAR_1 && VAR_2 . METHOD_3 ( VAR_4 ) ; TYPE_2 VAR_5 = TYPE_2 . VAR_6 ; return TYPE_1 . METHOD_4 ( VAR_5 , TYPE_3 . METHOD_5 ( VAR_5 , VAR_4 ) ) . when ( VAR_3 ) ; } 
<START> private void METHOD_1 ( ) { <END> METHOD_2 ( TYPE_1 . VAR_2 , String . format ( STRING_1 , METHOD_3 ( ) ) ) ; } 
private String METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; String VAR_2 = METHOD_4 ( ) ; <START> VAR_3 . METHOD_5 ( METHOD_3 ( ) , METHOD_6 ( ) , Collections . VAR_4 ( VAR_2 ) ) ; <END> return VAR_2 ; } finally { VAR_1 . METHOD_7 ( METHOD_3 ( ) ) ; } } 
<START> public TYPE_2 ( TYPE_1 host ) { <END> this . host = host ; } 
private void METHOD_1 ( ) { ArrayList < TYPE_1 > VAR_1 = METHOD_2 ( ) != null ? TYPE_2 < TYPE_1 > METHOD_3 ( METHOD_2 ( ) ) : new ArrayList < TYPE_1 > ( ) ; <START> METHOD_4 ( ) . METHOD_5 ( true ) ; <END> METHOD_6 ( ) . METHOD_5 ( VAR_1 . size ( ) == 1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) != TYPE_3 . VAR_4 <START> && VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) != null ) { <END> for ( int i = 0 ; i < VAR_2 ; i ++ ) { METHOD_4 ( new TYPE_2 ( Guid . VAR_5 ( ) , VAR_1 . getId ( ) ) , TYPE_4 . VAR_7 , VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) , METHOD_5 ( VAR_1 ) , true , false ) ; } } } 
public void METHOD_1 ( ) { boolean VAR_1 = vm . VAR_2 ( ) && vm . VAR_3 ( ) != null ; boolean VAR_4 = vm . VAR_3 ( ) == TYPE_1 . VAR_6 ; if ( VAR_1 ) { <START> if ( VAR_4 ) <END> { return ; } METHOD_2 ( ) ; } else { METHOD_3 ( ) ; } } 
public static void METHOD_1 ( String VAR_1 , TYPE_1 element ) { <START> if ( VAR_1 != null ) { <END> element . VAR_2 ( VAR_1 ) ; } } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { METHOD_3 ( ) ; } <START> METHOD_4 ( ) ; <END> METHOD_5 ( true ) ; } 
private static List < TYPE_1 > METHOD_1 ( TYPE_2 model ) { List < TYPE_1 > result = new ArrayList < > ( ) ; if ( model . VAR_1 ( ) ) { result . add ( from ( model , false ) ) ; } for ( TYPE_2 child : model . VAR_2 ( ) ) { List < TYPE_1 > VAR_3 = METHOD_1 ( child ) ; <START> if ( ! VAR_3 . isEmpty ( ) ) { <END> result . addAll ( VAR_3 ) ; } } return result ; } 
private void METHOD_1 ( ) { for ( TYPE_1 m : METHOD_2 ( ) ) { if ( ! ( m instanceof TYPE_2 ) ) { <START> m . VAR_1 ( false ) ; <END> } } } 
protected void METHOD_1 ( ) { VAR_1 . METHOD_2 ( METHOD_3 ( ) ) . METHOD_4 ( ) . METHOD_5 ( 0 ) ; try { METHOD_6 ( METHOD_7 ( ) && METHOD_8 ( ) ) ; } catch ( Exception e ) { METHOD_6 ( false ) ; } <START> <END> if ( ! METHOD_9 ( ) ) { METHOD_10 ( METHOD_11 ( ) ) ; } } 
protected boolean METHOD_1 ( ) { return METHOD_2 ( ) && METHOD_3 ( METHOD_4 ( ) ) && METHOD_5 ( getParameters ( ) . METHOD_6 ( ) , <START> getParameters ( ) . METHOD_7 ( ) ) ; <END> } 
public int METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { final String VAR_3 = VAR_1 . getName ( ) ; final String VAR_4 = VAR_2 . getName ( ) ; final TYPE_2 <START> VAR_5 = <END> new TYPE_2 ( ) ; final List < String > VAR_6 = VAR_5 . METHOD_2 ( VAR_3 , VAR_4 ) ; return TYPE_3 . METHOD_1 ( VAR_6 . get ( 0 ) , VAR_6 . get ( 1 ) ) ; } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . contains ( getParameters ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) ? TYPE_3 . METHOD_5 ( getParameters ( ) . METHOD_3 ( ) , this : : METHOD_6 ) : TYPE_3 . METHOD_5 ( this : : METHOD_6 ) ; <START> METHOD_7 ( VAR_1 ) ; <END> } 
protected boolean METHOD_1 ( Guid VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , METHOD_3 ( ) ) ; TYPE_2 VAR_4 = new TYPE_2 ( VAR_2 ) ; if ( ! METHOD_4 ( VAR_4 . METHOD_5 ( ) ) || ! METHOD_4 ( VAR_4 . METHOD_6 ( ) ) ) { return false ; } <START> return true ; <END> } 
<START> public List < TYPE_1 > <END> METHOD_1 ( ) { return VAR_1 ; } 
private String METHOD_1 ( String field ) { if ( field . equals ( STRING_1 ) ) { String VAR_1 = VAR_2 . METHOD_2 ( ) ; try { VAR_1 = VAR_2 . getString ( STRING_1 ) ; <START> } catch ( TYPE_1 e ) { <END> } return VAR_1 ; } return field ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = VAR_2 ; <START> if ( this . VAR_2 == null ) { <END> this . VAR_2 = new TYPE_1 ( ) ; this . VAR_2 . METHOD_1 ( false ) ; } this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_5 = new TYPE_4 ( TYPE_6 . VAR_7 ) ; METHOD_2 ( TYPE_7 . VAR_9 . METHOD_3 ( this ) ) ; } 
public int METHOD_1 ( int VAR_1 ) { <START> VAR_1 ++ ; <END> VAR_2 . METHOD_2 ( VAR_1 ++ ) ; VAR_3 . METHOD_2 ( VAR_1 ++ ) ; VAR_4 . METHOD_2 ( VAR_1 ++ ) ; VAR_5 . METHOD_2 ( VAR_1 ++ ) ; return VAR_6 . METHOD_1 ( VAR_1 ) ; } 
private int METHOD_1 ( TYPE_1 VAR_1 ) { int res = 0 ; if ( VAR_1 != null ) { if ( VAR_1 . METHOD_2 ( ) ) { res += INT_1 ; } if ( VAR_1 . METHOD_3 ( ) ) { <START> res += INT_2 ; <END> } if ( VAR_1 . METHOD_4 ( ) ) { res += 4 ; } if ( VAR_1 . METHOD_5 ( ) ) { res += 2 ; } if ( VAR_1 . METHOD_6 ( ) ) { res += 1 ; } } return res ; } 
boolean METHOD_1 ( TYPE_1 status ) { switch ( status ) { case TYPE_4 : case TYPE_5 : case TYPE_3 : case TYPE_2 : case TYPE_6 : <START> case TYPE_8 : <END> case TYPE_7 : return true ; default : return false ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , Guid VAR_3 ) { TYPE_3 VAR_4 = VAR_1 . METHOD_2 ( ) . get ( 0 ) ; if ( VAR_4 == TYPE_3 . VAR_5 ) { <START> if ( TYPE_4 . METHOD_3 ( VAR_2 ) ) { return true ; } return METHOD_4 ( VAR_3 , TYPE_6 . TYPE_7 . name ( ) ) ; <END> } return false ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; <START> METHOD_3 ( null ) ; <END> TYPE_2 < TYPE_1 > VAR_2 = VAR_1 . METHOD_4 ( ) ; TYPE_1 VAR_3 = VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) ; METHOD_7 ( VAR_3 . METHOD_8 ( ) ) ; Collection < TYPE_1 > VAR_4 = VAR_2 . METHOD_9 ( ) ; VAR_2 . METHOD_10 ( null ) ; VAR_2 . METHOD_10 ( VAR_4 ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( true , false , VAR_1 , VAR_2 ) ; <END> assertThat ( VAR_3 . METHOD_3 ( true ) , METHOD_4 ( TYPE_1 . VAR_5 ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_2 ( Guid . VAR_2 ( ) ) ; <END> when ( METHOD_3 ( ) . getId ( ) ) . METHOD_4 ( VAR_3 ) ; METHOD_5 ( ) . METHOD_6 ( ) ; TYPE_1 result = METHOD_5 ( ) . METHOD_7 ( ) . METHOD_8 ( ) ; METHOD_9 ( result ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
private boolean METHOD_1 ( TYPE_2 . TYPE_3 status ) { <START> if ( status == TYPE_2 . TYPE_3 . TYPE_5 || status == TYPE_2 . TYPE_3 . TYPE_4 || status == TYPE_2 . TYPE_3 . TYPE_6 ) { <END> return true ; } return false ; } 
protected Pair < Boolean , TYPE_1 > METHOD_1 ( TYPE_1 VAR_1 ) { return new Pair < > ( TYPE_2 . getInstance ( ) . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_1 , null ) , <START> VAR_1 ) ; <END> } 
public String METHOD_1 ( String name ) { for ( int i = 0 ; i < reader . VAR_1 ( ) ; i ++ ) { String VAR_2 = reader . VAR_3 ( i ) ; if ( VAR_2 . equals ( name ) ) { return reader . VAR_4 ( i ) ; } } <START> return null ; <END> } 
protected boolean METHOD_1 ( ) { try { getParameters ( ) . METHOD_2 ( new Date ( ) ) ; VAR_1 = new TYPE_1 ( VAR_2 . METHOD_3 ( METHOD_4 ( ) ) ) ; <START> VAR_3 . METHOD_5 ( VAR_1 ) ; <END> if ( METHOD_6 ( ) && METHOD_7 ( METHOD_4 ( ) ) && METHOD_8 ( ) ) { TYPE_2 . METHOD_9 ( METHOD_10 ( ) , true ) ; return true ; } METHOD_11 ( ) ; return false ; } catch ( Exception e ) { METHOD_11 ( ) ; throw e ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( false ) ; <END> final TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ) ; VAR_2 . METHOD_6 ( VAR_1 . METHOD_4 ( ) . getMessage ( ) ) ; METHOD_7 ( ) . METHOD_8 ( VAR_2 ) ; } 
private void METHOD_1 ( List < TYPE_1 > VAR_1 ) { TYPE_4 < Set < TYPE_2 > > getValue ( TYPE_5 . TYPE_6 ) . stream ( ) . max ( TYPE_3 . METHOD_2 ( ) ) <START> . METHOD_3 ( VAR_5 - > VAR_1 . forEach ( VAR_6 - > VAR_6 . METHOD_4 ( <END> VAR_5 . METHOD_5 ( VAR_6 . METHOD_6 ( ) ) > 0 ) ) ) ; } 
protected boolean METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_4 . VAR_2 ) { TYPE_1 VAR_3 = ( TYPE_1 ) METHOD_2 ( ) ; return <START> ( VAR_3 . METHOD_4 ( ) <END> == TYPE_3 . VAR_5 ) && ! TYPE_2 . equals ( VAR_3 . METHOD_5 ( ) . METHOD_6 ( ) , ( ( TYPE_1 ) METHOD_7 ( ) ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; } return false ; } 
public void METHOD_1 ( ) { Map < String , String > VAR_1 = new HashMap < > ( ) ; <START> VAR_1 . put ( STRING_1 , STRING_2 ) ; <END> METHOD_2 ( STRING_3 , INT_1 , STRING_4 ) ; METHOD_2 ( STRING_5 , INT_1 , STRING_6 ) ; METHOD_3 ( ) ; connection = ( TYPE_1 ) METHOD_4 ( ) . METHOD_5 ( STRING_1 , STRING_2 ) . build ( ) ; VAR_2 = connection . VAR_3 ( ) . METHOD_6 ( ) ; VAR_4 = VAR_2 . METHOD_7 ( STRING_7 ) ; } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) && METHOD_2 ( ) . METHOD_4 ( ) ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_5 ( ) ; Collection < TYPE_2 > VAR_2 = VAR_1 . METHOD_6 ( ) ; if ( VAR_2 != null && ! METHOD_7 ( VAR_2 ) ) { METHOD_2 ( ) . METHOD_8 ( false ) ; <START> METHOD_2 ( ) . METHOD_9 ( ) . add ( <END> VAR_3 . METHOD_10 ( ) ) ; return ; } } METHOD_2 ( ) . METHOD_8 ( true ) ; } 
public TYPE_1 ( Guid VAR_2 ) { <START> super ( VAR_2 ) ; <END> } 
public static int METHOD_1 ( String VAR_1 ) { switch ( VAR_1 ) { case STRING_1 : <START> return 2 ; <END> case STRING_2 : return 2 ; case STRING_3 : return 2 ; default : return - 1 ; } } 
private void METHOD_1 ( ) { if ( getParameters ( ) . METHOD_2 ( ) != null <START> || METHOD_3 ( ) . METHOD_4 ( ) . equals ( getParameters ( ) . METHOD_2 ( ) ) ) { <END> return ; } TYPE_1 params = new TYPE_1 ( getParameters ( ) . METHOD_2 ( ) , METHOD_5 ( ) , METHOD_3 ( ) . METHOD_6 ( ) ) ; METHOD_7 ( METHOD_8 ( ) . METHOD_9 ( TYPE_2 . TYPE_3 , params ) . METHOD_10 ( ) ) ; } 
<START> public String METHOD_1 ( ) { <END> return TYPE_1 . METHOD_2 ( ) . toString ( ) ; } 
private List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 , TYPE_3 version ) { METHOD_2 ( version ) ; VAR_2 . METHOD_3 ( TYPE_4 . TYPE_5 , version ) ; List < TYPE_2 > VAR_5 = METHOD_4 ( VAR_1 ) ; when ( VAR_6 . METHOD_5 ( <START> VAR_1 . stream ( ) . map ( TYPE_2 : : METHOD_6 ) . collect ( Collectors . VAR_7 ( ) ) <END> ) ) . METHOD_7 ( VAR_5 ) ; return cmd . VAR_8 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 . getId ( ) , TYPE_7 . VAR_5 , TYPE_4 . TYPE_5 . getName ( ) ) ; if ( ! METHOD_3 ( VAR_1 . getId ( ) , TYPE_6 . VAR_7 ) ) { METHOD_4 ( VAR_2 ) ; } <START> } <END> 
private void METHOD_1 ( ) { if ( TYPE_2 < Boolean > getValue ( TYPE_3 . TYPE_4 ) ) { log . info ( STRING_1 ) ; <START> VAR_4 . METHOD_2 ( ( ) - > METHOD_3 ( ) , <END> TYPE_2 < Integer > getValue ( TYPE_3 . TYPE_1 ) , TYPE_2 < Integer > getValue ( TYPE_3 . TYPE_1 ) , TimeUnit . VAR_6 ) ; log . info ( STRING_2 ) ; } } 
private void METHOD_1 ( ) { if ( TYPE_1 < Boolean > getValue ( TYPE_2 . TYPE_4 ) ) { log . info ( STRING_1 ) ; Integer VAR_4 = TYPE_1 < Integer > getValue ( TYPE_2 . TYPE_3 ) ; <START> VAR_6 . METHOD_2 ( ( ) - > METHOD_3 ( ) , <END> VAR_4 , VAR_4 , TimeUnit . VAR_7 ) ; log . info ( STRING_2 ) ; } } 
<START> public void <END> METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { try { log . info ( STRING_1 ) ; METHOD_3 ( ) ; log . info ( STRING_2 ) ; } finally { VAR_1 . METHOD_4 ( ) ; } } } 
<START> public void <END> METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . stream ( ) . filter ( VAR_2 - > VAR_2 . getStatus ( ) . METHOD_3 ( ) ) . forEach ( this : : METHOD_4 ) ; } 
<START> public void <END> METHOD_1 ( ) { Date VAR_1 = new Date ( System . currentTimeMillis ( ) - TimeUnit . VAR_2 . METHOD_2 ( VAR_3 , TimeUnit . VAR_4 ) ) ; Date VAR_5 = new Date ( System . currentTimeMillis ( ) - TimeUnit . VAR_2 . METHOD_2 ( VAR_6 , TimeUnit . VAR_4 ) ) ; try { VAR_7 . METHOD_3 ( VAR_1 , VAR_5 ) ; } catch ( RuntimeException e ) { log . error ( STRING_1 , e . getMessage ( ) ) ; log . debug ( STRING_2 , e ) ; } } 
void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( true ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; <END> when ( VAR_3 . METHOD_4 ( METHOD_5 ( TYPE_3 . TYPE_4 ) , METHOD_6 ( TYPE_2 . class ) ) ) . METHOD_7 ( VAR_1 ) ; } 
} catch ( TYPE_1 e ) { <START> new RuntimeException ( STRING_1 , e ) ; <END> } 
<START> protected void <END> METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { String [ ] VAR_3 = VAR_2 . split ( STRING_1 ) ; for ( String VAR_4 : VAR_3 ) { VAR_1 = METHOD_2 ( VAR_1 , VAR_4 ) ; } } 
<START> private static <END> String METHOD_1 ( TYPE_1 VAR_1 ) { final String key = VAR_1 . name ( ) ; try { return VAR_2 . getString ( key ) ; } catch ( Exception e ) { log . error ( STRING_1 , key , METHOD_2 ( ) ) ; return null ; } } 
public TYPE_1 ( String VAR_2 ) { super ( ) ; String [ ] VAR_3 = VAR_2 . split ( STRING_1 ) ; <START> METHOD_1 ( VAR_3 [ 0 ] ) . METHOD_2 ( VAR_3 [ 1 ] ) . METHOD_3 ( VAR_3 [ 2 ] ) . METHOD_4 ( VAR_3 [ 3 ] ) . METHOD_5 ( VAR_3 [ 4 ] ) . METHOD_6 ( VAR_3 [ 5 ] ) ; <END> if ( VAR_3 . length >= INT_1 ) { METHOD_7 ( VAR_3 [ INT_2 ] ) ; } } 
private void METHOD_1 ( ) { try { <START> log . info ( STRING_1 ) ; <END> TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 < Integer > getValue ( TYPE_4 . TYPE_5 ) * - 1 ) ; VAR_5 . METHOD_4 ( VAR_1 ) ; log . info ( STRING_2 ) ; } catch ( Throwable t ) { log . error ( STRING_3 , TYPE_2 . METHOD_5 ( t ) ) ; log . debug ( STRING_4 , t ) ; } } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = getParameters ( ) . METHOD_2 ( ) ; TYPE_2 VAR_2 = getParameters ( ) . METHOD_3 ( ) ; <START> VAR_2 . METHOD_4 ( TYPE_2 . TYPE_5 . VAR_4 ) ; <END> VAR_2 . METHOD_5 ( TYPE_1 . TYPE_4 ) ; VAR_2 . METHOD_6 ( getParameters ( ) ) ; TYPE_3 . METHOD_7 ( VAR_1 , VAR_2 , METHOD_8 ( ) ) ; METHOD_9 ( true ) ; } 
private void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( true ) ; <END> boolean VAR_1 = METHOD_4 ( ) != null && METHOD_4 ( ) . size ( ) > 0 ; METHOD_5 ( ) . METHOD_3 ( VAR_1 && METHOD_4 ( ) . size ( ) == 1 ) ; METHOD_6 ( ) . METHOD_3 ( VAR_1 ) ; } 
private void METHOD_1 ( ) { <START> METHOD_2 ( null ) ; <END> } 
protected void METHOD_1 ( ) { TYPE_1 <START> command = <END> TYPE_1 . METHOD_2 ( STRING_1 , this ) ; METHOD_3 ( ) . add ( command ) ; METHOD_3 ( ) . add ( TYPE_1 . METHOD_4 ( STRING_2 , this ) ) ; } 
<START> public boolean <END> METHOD_1 ( Guid id ) { return VAR_1 . exists ( id ) ; } 
public void METHOD_1 ( final TYPE_1 server , final TYPE_2 VAR_1 ) { <START> METHOD_2 ( server == null ? <END> Guid . TYPE_3 : server . VAR_3 ( ) , server == null ? null : server . VAR_4 ( ) , null , server , VAR_1 , Collections . VAR_5 ( ) ) ; } 
protected boolean METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) return false ; final TYPE_1 VAR_1 = METHOD_3 ( ) ; <START> return METHOD_4 ( VAR_1 . METHOD_5 ( METHOD_6 ( ) , VAR_2 ) ) <END> && METHOD_4 ( VAR_1 . METHOD_7 ( VAR_2 ) ) && METHOD_4 ( VAR_1 . METHOD_8 ( VAR_2 ) ) ; } 
protected void log ( ) { <START> final TYPE_1 VAR_1 = TYPE_2 . METHOD_1 ( ) ; <END> try { try { VAR_2 . log ( this , METHOD_2 ( ) ) ; } catch ( final RuntimeException ex ) { log . error ( STRING_1 , getClass ( ) . getName ( ) , ex . getMessage ( ) ) ; log . debug ( STRING_2 , ex ) ; } } finally { TYPE_2 . METHOD_3 ( VAR_1 ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; Guid VAR_2 = Guid . VAR_3 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; <START> when ( VAR_4 . METHOD_3 ( METHOD_4 ( Guid . VAR_5 ) ) ) . METHOD_5 ( Collections . VAR_6 ( VAR_1 ) ) ; <END> when ( VAR_7 . get ( VAR_2 ) ) . METHOD_5 ( new TYPE_2 ( ) ) ; assertTrue ( cmd . VAR_8 ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; Guid VAR_2 = Guid . VAR_3 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; <START> when ( VAR_4 . METHOD_3 ( METHOD_4 ( Guid . VAR_5 ) ) ) . METHOD_5 ( Collections . VAR_6 ( VAR_1 ) ) ; <END> when ( VAR_7 . get ( VAR_2 ) ) . METHOD_5 ( null ) ; METHOD_6 ( cmd . VAR_8 ( ) ) ; } 
<START> public Boolean METHOD_1 ( ) { <END> return VAR_1 ; } 
public int METHOD_1 ( int VAR_1 ) { <START> VAR_1 = super . METHOD_1 ( VAR_1 ) ; <END> VAR_1 = VAR_2 . METHOD_1 ( VAR_1 ) ; VAR_1 = this . VAR_3 . METHOD_1 ( VAR_1 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 vm = new TYPE_1 ( ) ; vm . VAR_1 ( TYPE_5 . TYPE_4 ) ; TYPE_2 VAR_4 = new TYPE_2 ( ) ; VAR_4 . METHOD_2 ( true ) ; List < Pair < TYPE_1 , TYPE_2 > > VAR_5 = <START> Collections . VAR_6 ( new Pair ( vm , <END> VAR_4 ) ) ; METHOD_3 ( VAR_5 ) . when ( VAR_7 ) . METHOD_4 ( VAR_8 ) ; TYPE_3 . METHOD_5 ( command , TYPE_6 . VAR_10 ) ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . get ( METHOD_2 ( ) . METHOD_3 ( ) ) ; if ( METHOD_2 ( ) . METHOD_4 ( ) == TYPE_3 . VAR_4 && <START> METHOD_2 ( ) . METHOD_5 ( ) . equals ( TYPE_2 . VAR_6 ) ) <END> { VAR_1 . METHOD_6 ( METHOD_2 ( ) . METHOD_7 ( ) ) ; VAR_2 . update ( VAR_1 ) ; } } 
<START> public void METHOD_1 ( ) { <END> METHOD_2 ( ) ; if ( getParameters ( ) . METHOD_3 ( ) ) { Guid VAR_1 = METHOD_4 ( ) ; if ( VAR_1 != null ) { METHOD_5 ( VAR_1 ) ; } } METHOD_6 ( TYPE_1 . VAR_3 ) ; METHOD_7 ( true ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 request = new TYPE_4 ( STRING_1 ) . build ( ) ; Map < String , Object > response = new TYPE_5 ( this . client , request , TYPE_6 . getInstance ( ) . METHOD_2 ( ) , VAR_1 ) . METHOD_3 ( STRING_2 ) ; <START> return new TYPE_1 ( response ) ; <END> } 
protected boolean METHOD_1 ( ) { if ( ! getParameters ( ) . METHOD_2 ( ) . METHOD_3 ( ) ) { return METHOD_4 ( TYPE_2 . VAR_2 ) ; } <START> if ( ! TYPE_1 . METHOD_5 ( METHOD_6 ( ) ) ) { return METHOD_4 ( TYPE_2 . VAR_3 ) ; } <END> return METHOD_7 ( getParameters ( ) . METHOD_2 ( ) . METHOD_8 ( ) ) ; } 
protected boolean METHOD_1 ( ) { for ( TYPE_1 VAR_1 : METHOD_2 ( ) . METHOD_3 ( ) . values ( ) ) { TYPE_2 VAR_2 = VAR_3 . get ( VAR_1 . getId ( ) ) ; <START> if ( VAR_2 . METHOD_4 ( ) == true ) { <END> return false ; } } return true ; } 
public TYPE_1 < TYPE_2 > call ( TYPE_3 req , TYPE_4 VAR_1 ) throws TYPE_5 { final TYPE_6 call = new TYPE_6 ( req , <START> VAR_2 , VAR_1 ) ; <END> this . VAR_3 . METHOD_1 ( req , call ) ; METHOD_2 ( req , call ) ; try { this . METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( req . VAR_4 ( ) ) ) ; } finally { METHOD_2 ( req , call ) ; } return call ; } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) == null || METHOD_2 ( ) . METHOD_4 ( ) == null ) { VAR_1 . METHOD_5 ( METHOD_2 ( ) . METHOD_6 ( ) , <START> METHOD_7 ( ) . METHOD_8 ( ) ) ; <END> VAR_2 . update ( METHOD_2 ( ) . METHOD_6 ( ) ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ! VAR_2 . METHOD_2 ( ) <END> && ! METHOD_3 ( VAR_1 ) && VAR_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; } 
private void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 , boolean VAR_2 ) { for ( TYPE_1 < TYPE_2 > VAR_3 : VAR_4 ) { if ( VAR_3 != null <START> && VAR_2 ) { <END> VAR_3 . METHOD_2 ( null ) ; if ( VAR_3 instanceof TYPE_3 ) { ( ( TYPE_3 ) VAR_3 ) . METHOD_3 ( ) ; } } } if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( METHOD_4 ( METHOD_5 ( ) ) ) ; } } 
public static boolean METHOD_1 ( String VAR_1 ) throws IOException { final Map < String , String > map = METHOD_2 ( VAR_1 ) ; if ( map . isEmpty ( ) ) { return false ; <START> } <END> return TYPE_1 . equals ( map . get ( VAR_2 ) ) && TYPE_2 . equals ( map . get ( VAR_3 ) ) ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; if ( VAR_1 instanceof TYPE_3 ) { TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; <START> METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; <END> } } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { if ( VAR_1 instanceof TYPE_3 ) { TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; <START> METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; <END> } } 
public void METHOD_1 ( Object VAR_1 , TYPE_1 content ) { if ( VAR_1 == TYPE_4 . TYPE_2 ) { METHOD_2 ( VAR_4 , content ) ; } else if ( VAR_1 == TYPE_4 . TYPE_3 ) { <START> if ( ! VAR_6 ) { <END> METHOD_3 ( ) ; VAR_6 = true ; } METHOD_2 ( VAR_7 , content ) ; } else { super . METHOD_1 ( VAR_1 , content ) ; } } 
private void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : METHOD_2 ( ) . METHOD_3 ( ) . values ( ) ) { <START> if ( VAR_1 . METHOD_4 ( ) == TYPE_3 . VAR_3 ) { } <END> if ( ! VAR_1 . METHOD_5 ( ) ) { VAR_4 . log ( this , TYPE_2 . VAR_6 ) ; break ; } } } 
protected boolean METHOD_1 ( ) { return super . METHOD_1 ( ) && METHOD_2 ( ) && METHOD_3 ( ) && METHOD_4 ( ) && METHOD_5 ( ) && METHOD_6 ( ) && METHOD_7 ( ) && METHOD_8 ( ) && METHOD_9 ( ) && METHOD_10 ( ) && METHOD_11 ( ) && METHOD_12 ( ) && METHOD_13 ( ) && METHOD_14 ( ) && METHOD_15 ( ) <START> && METHOD_16 ( ) ; <END> } 
<START> protected void <END> METHOD_1 ( RuntimeException ex ) { if ( ex . getMessage ( ) == null || ! ex . getMessage ( ) . contains ( STRING_1 ) ) { log . error ( STRING_2 , this , ex . getMessage ( ) ) ; log . debug ( STRING_3 , ex ) ; } } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = model . VAR_2 ( ) . METHOD_2 ( TYPE_1 . class ) ; if ( VAR_1 == null ) { return ; } <START> VAR_1 . METHOD_3 ( ) ; VAR_1 . METHOD_3 ( ) ; <END> } 
private String METHOD_1 ( Object VAR_1 ) { String VAR_2 = STRING_1 ; if ( VAR_1 instanceof TYPE_1 ) { VAR_2 = ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( ) ; } <START> else if ( VAR_1 instanceof TYPE_2 ) { <END> VAR_2 = ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( ) ; } return VAR_2 ; } 
protected void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( ) ; <START> if ( VAR_2 != null ) { <END> TYPE_1 VAR_3 = VAR_1 . stream ( ) . filter ( VAR_4 - > TYPE_3 . equals ( VAR_2 . METHOD_3 ( ) , VAR_4 . getId ( ) ) ) . METHOD_4 ( ) . get ( ) ; METHOD_5 ( ) . METHOD_6 ( VAR_3 ) ; METHOD_5 ( ) . METHOD_7 ( false ) ; } } 
public TYPE_3 ( ) { METHOD_1 ( TYPE_2 . VAR_3 . METHOD_2 ( this ) ) ; <START> VAR_4 . METHOD_3 ( ( e ) - > { METHOD_4 ( ) ; } ) ; <END> TYPE_1 . METHOD_5 ( ( e ) - > { METHOD_4 ( ) ; } ) ; } 
<START> public boolean METHOD_1 ( ) { return this . VAR_1 . equals ( this . VAR_2 ) ; } <END> 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { try { VAR_1 . METHOD_2 ( true ) ; } catch ( Throwable t ) { <START> log . debug ( STRING_1 , TYPE_1 . METHOD_3 ( t ) ) ; <END> } } VAR_1 = VAR_2 . METHOD_4 ( this : : METHOD_5 , 0 , TYPE_2 < Integer > getValue ( TYPE_3 . TYPE_4 ) , TimeUnit . VAR_6 ) ; } 
public TYPE_1 list ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; Set < TYPE_2 > VAR_2 = METHOD_1 ( Set . VAR_3 , TYPE_5 . TYPE_6 , new TYPE_3 ( METHOD_2 ( VAR_6 ) ) , VAR_6 , false ) ; if ( VAR_2 != null ) { for ( TYPE_2 entity : VAR_2 ) { if ( entity . VAR_7 ( ) ) { <START> VAR_1 . METHOD_3 ( ) . add ( METHOD_4 ( TYPE_4 . map ( entity . VAR_8 ( ) , <END> null ) ) ) ; } } } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( String VAR_1 , String id ) { TYPE_1 VAR_2 ; <START> VAR_2 = VAR_3 ; <END> TYPE_2 VAR_4 = new TYPE_2 ( ) ; VAR_4 . METHOD_2 ( TYPE_3 . VAR_6 ) ; VAR_4 . setText ( VAR_1 ) ; VAR_2 . add ( VAR_4 ) ; VAR_2 . METHOD_3 ( id ) ; VAR_2 . METHOD_4 ( e - > { e . VAR_7 ( ) ; } ) ; return VAR_2 ; } 
public TYPE_9 ( TYPE_1 < TYPE_2 < TYPE_3 , TYPE_4 > , TYPE_5 , TYPE_6 > VAR_2 ) { super ( VAR_2 ) ; VAR_3 = new TYPE_7 < > ( Arrays . asList ( TYPE_8 . values ( ) ) ) ; VAR_3 . METHOD_1 ( TYPE_8 . VAR_4 ) ; <START> VAR_3 . METHOD_2 ( VAR_5 - > { <END> METHOD_3 ( VAR_5 ) ; } ) ; METHOD_4 ( ) ; METHOD_5 ( METHOD_6 ( ) ) ; } 
public Response remove ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_1 ( this , id ) ; TYPE_3 parameters = new TYPE_3 ( VAR_1 ) ; <START> parameters . VAR_2 ( METHOD_2 ( ) ) ; <END> return METHOD_3 ( TYPE_4 . TYPE_5 , parameters ) ; } 
public TYPE_3 ( ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . setText ( VAR_4 . METHOD_1 ( ) + STRING_1 ) ; VAR_3 . METHOD_2 ( STRING_2 ) ; <START> VAR_2 . add ( VAR_3 ) ; <END> VAR_2 . add ( METHOD_3 ( ) ) ; METHOD_4 ( VAR_2 ) ; } 
protected void METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; VAR_1 . METHOD_5 ( METHOD_6 ( ) . METHOD_7 ( ) ) ; TYPE_1 < TYPE_2 > VAR_2 = METHOD_2 ( ) . METHOD_8 ( ) . METHOD_4 ( ) ; VAR_2 . METHOD_5 ( METHOD_6 ( ) . METHOD_9 ( ) ) ; <START> super . METHOD_1 ( ) ; <END> } 
public static TYPE_1 map ( TYPE_2 entity , TYPE_1 VAR_1 ) { TYPE_1 model = VAR_1 != null ? VAR_1 : new TYPE_1 ( ) ; model . VAR_2 ( entity . VAR_3 ( ) ) ; model . VAR_4 ( entity . VAR_5 ( ) ) ; <START> if ( entity . VAR_6 ( ) != null ) { <END> model . VAR_7 ( entity . VAR_6 ( ) ) ; } model . VAR_8 ( map ( entity . VAR_9 ( ) , null ) ) ; return model ; } 
public static TYPE_1 map ( org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_1 VAR_8 , TYPE_1 VAR_9 ) { switch ( VAR_8 ) { case TYPE_4 : return TYPE_1 . VAR_11 ; case VAR_12 : return TYPE_1 . VAR_12 ; case TYPE_3 : return TYPE_1 . VAR_14 ; case TYPE_5 : return TYPE_1 . VAR_16 ; case TYPE_2 : return TYPE_1 . VAR_18 ; <START> default : return null ; <END> } } 
public TYPE_5 ( TYPE_1 < T , TYPE_2 > VAR_2 , TYPE_3 VAR_3 ) { this . VAR_3 = VAR_3 ; <START> METHOD_1 ( TYPE_4 . VAR_5 . METHOD_2 ( this ) ) ; <END> this . VAR_2 = VAR_2 ; } 
private List < TYPE_1 > METHOD_1 ( ) { <START> TYPE_1 VAR_1 = VAR_2 ; <END> VAR_1 . METHOD_2 ( ) . addAll ( VAR_3 ) ; return Arrays . asList ( VAR_2 , VAR_4 , VAR_5 , VAR_6 ) ; } 
private void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_2 instanceof TYPE_2 ) { continue ; } TYPE_3 VAR_3 = TYPE_3 . class . METHOD_2 ( VAR_2 ) ; assertTrue ( STRING_1 , <START> VAR_3 . METHOD_3 ( ) ) ; <END> } } 
<START> private void METHOD_1 ( ) { <END> VAR_1 = new TYPE_1 ( TYPE_2 . VAR_3 , VAR_4 . METHOD_2 ( ) , TYPE_3 . VAR_6 ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 < T , ? > column , TYPE_3 < T > table ) { this . VAR_2 = VAR_2 ; this . column = column ; this . table = table ; this . VAR_3 = TYPE_4 . METHOD_1 ( this ) ; <START> VAR_4 = <END> VAR_2 . METHOD_2 ( ) ; table . VAR_5 ( column , VAR_2 ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > result = VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 , null , false ) ; <START> List < TYPE_1 > VAR_4 = result . stream ( ) . filter ( VAR_5 - > VAR_5 . getId ( ) . equals ( TYPE_2 . VAR_3 ) ) . collect ( Collectors . VAR_6 ( ) ) ; assertEquals ( STRING_1 , 4 , VAR_4 . size ( ) ) ; <END> } 
public int METHOD_1 ( TYPE_1 o ) { int VAR_1 = VAR_2 . METHOD_1 ( o . VAR_2 ) ; if ( VAR_1 == 0 ) { return VAR_3 . METHOD_1 ( o . VAR_3 ) ; } <START> else { <END> return VAR_1 ; } } 
public TYPE_1 ( Map < String , Object > VAR_2 ) { super ( VAR_2 ) ; <START> this . VAR_3 <END> = ( Map < String , Object > ) VAR_2 . get ( VAR_4 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) { return false ; } return true ; <END> } 
public int METHOD_1 ( Integer VAR_1 , TYPE_1 VAR_2 ) { <START> String VAR_3 = ( VAR_2 != null ) ? VAR_2 . getValue ( ) : TYPE_1 . METHOD_2 ( ) . getValue ( ) ; <END> if ( VAR_1 == null ) { return METHOD_3 ( VAR_3 ) ; } final TYPE_2 VAR_4 = METHOD_4 ( VAR_1 ) ; return ( Integer ) METHOD_5 ( VAR_4 , VAR_3 ) ; } 
public String METHOD_1 ( Guid VAR_1 ) { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; for ( TYPE_2 VAR_4 : VAR_5 . METHOD_3 ( TYPE_5 . VAR_7 ) ) { for ( TYPE_1 VAR_8 : VAR_2 ) { TYPE_3 VAR_9 = VAR_8 . METHOD_4 ( ) ; if ( ( VAR_9 != null ) <START> && ( VAR_9 . METHOD_5 ( ) . equals ( VAR_4 . getId ( ) ) ) ) { <END> return TYPE_4 . METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; } } } return null ; } 
public String METHOD_1 ( Guid VAR_1 ) { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; for ( TYPE_2 VAR_4 : VAR_5 . METHOD_3 ( TYPE_5 . VAR_7 ) ) { for ( TYPE_1 VAR_8 : VAR_2 ) { TYPE_3 VAR_9 = VAR_8 . METHOD_4 ( ) ; if ( VAR_9 != null <START> && ( VAR_9 . METHOD_5 ( ) . equals ( VAR_4 . getId ( ) ) ) ) { <END> return TYPE_4 . METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; } } } return null ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; VAR_3 = new HashMap < > ( ) ; VAR_4 = new HashMap < > ( ) ; VAR_5 = new HashMap < > ( ) ; VAR_6 = 0 ; <START> this . VAR_7 = TYPE_3 . VAR_9 ; <END> } 
public void METHOD_1 ( ) { cluster . VAR_1 ( TYPE_1 . VAR_3 ) ; VAR_4 . METHOD_2 ( VAR_5 ) ; assertThat ( METHOD_3 ( true , VAR_5 ) . METHOD_4 ( ) , <START> is ( false ) ) ; <END> } 
<START> private TYPE_1 ( Guid <END> VAR_2 , Guid VAR_3 , boolean VAR_4 ) { this ( VAR_2 , VAR_3 ) ; this . VAR_4 = VAR_4 ; } 
<START> protected TYPE_1 ( String <END> id ) { this . id = id ; } 
private String METHOD_1 ( ) throws IOException { ANNOTATION_1 ( STRING_1 ) Path VAR_1 = TYPE_1 . get ( VAR_2 ) ; <START> return ( new String ( TYPE_2 . METHOD_2 ( VAR_1 ) ) ) . trim ( ) ; <END> } 
<START> static Set < Guid > <END> METHOD_1 ( TYPE_1 VAR_1 ) { Set < Guid > VAR_2 = null ; if ( VAR_1 . METHOD_2 ( ) ) { VAR_2 = METHOD_3 ( VAR_1 . METHOD_4 ( ) . stream ( ) . map ( TYPE_2 : : METHOD_5 ) ) ; } return VAR_2 ; } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { TYPE_2 format = TYPE_2 . METHOD_2 ( ) ; return format . format ( VAR_1 ) ; } else { <START> return null ; <END> } } 
private void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { <START> if ( VAR_1 != null ) { <END> VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_4 - > new ArrayList < > ( ) ) . add ( VAR_1 ) ; } } } 
protected void METHOD_1 ( ) { TYPE_1 parameters = new TYPE_1 ( METHOD_2 ( ) ) ; TYPE_2 VAR_1 = METHOD_3 ( TYPE_3 . TYPE_5 , parameters , METHOD_4 ( ) ) ; <START> HashSet < Guid > <END> VAR_4 = VAR_1 . METHOD_5 ( ) ; if ( ! VAR_4 . isEmpty ( ) ) { METHOD_6 ( TYPE_3 . TYPE_4 , METHOD_7 ( ) ) ; } METHOD_8 ( true ) ; } 
public TYPE_1 METHOD_1 ( ) { switch ( METHOD_2 ( ) ) { case VAR_1 : return <START> METHOD_3 ( ) <END> ? TYPE_1 . VAR_2 : TYPE_1 . VAR_3 ; default : return TYPE_1 . VAR_2 ; } } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , int VAR_4 , boolean VAR_5 ) { VAR_6 . METHOD_2 ( VAR_4 , VAR_1 , VAR_2 ) ; VAR_7 . create ( VAR_2 , VAR_3 ) ; if ( VAR_5 && <START> VAR_8 instanceof TYPE_1 ) { <END> ( ( TYPE_1 ) VAR_8 ) . METHOD_3 ( VAR_2 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) { METHOD_1 ( TYPE_2 . METHOD_3 ( VAR_1 . METHOD_2 ( ) ) ) ; <START> } <END> } 
protected void METHOD_1 ( Guid VAR_1 , Guid VAR_2 , Guid VAR_3 , Guid VAR_4 , TYPE_1 VAR_5 ) { TYPE_2 vm = VAR_6 . METHOD_2 ( VAR_5 . getId ( ) ) . stream ( ) . <START> map ( VAR_7 - > VAR_7 . METHOD_3 ( ) ) . <END> METHOD_4 ( ) . get ( ) ; METHOD_5 ( VAR_5 . METHOD_6 ( ) , VAR_1 , VAR_2 , VAR_3 , VAR_4 , vm . VAR_8 ( ) ) ; } 
public Status ( Map < String , Object > VAR_1 ) { VAR_2 = ( Integer ) VAR_1 . get ( VAR_3 ) ; if ( VAR_1 . get ( VAR_4 ) == null ) { message = "" ; } else if ( VAR_1 . get ( VAR_4 ) instanceof Object [ ] ) { message = Arrays . toString ( ( Object [ ] ) <START> VAR_1 . get ( VAR_4 ) ) ; <END> } else { message = VAR_1 . get ( VAR_4 ) . toString ( ) ; } } 
protected boolean METHOD_1 ( ) { if ( VAR_1 . isEmpty ( ) && ! METHOD_2 ( ) ) { return false ; } else if ( ! METHOD_3 ( ) ) { <START> return false ; <END> } if ( METHOD_4 ( ) . size ( ) != VAR_1 . size ( ) ) { log . error ( STRING_1 , VAR_2 . getId ( ) ) ; return METHOD_5 ( TYPE_1 . VAR_4 ) ; } return METHOD_6 ( ) ; } 
public TYPE_1 ( ) { <START> super ( ) ; <END> this . VAR_2 = new HashMap < > ( ) ; } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; VAR_1 = new TYPE_1 ( <START> TYPE_2 . this , <END> VAR_3 ) ; VAR_1 . METHOD_3 ( ) ; } 
public TYPE_1 ( Guid VAR_2 , Guid VAR_3 , Guid VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; <START> this . VAR_5 = null ; <END> } 
protected void METHOD_1 ( ) { int VAR_1 = METHOD_2 ( ) ; if ( VAR_1 <= 0 ) { METHOD_3 ( TYPE_1 . VAR_3 ) ; <START> METHOD_4 ( ) ; <END> METHOD_5 ( VAR_4 . isEmpty ( ) ) ; } else { METHOD_3 ( TYPE_1 . VAR_5 ) ; METHOD_5 ( METHOD_6 ( METHOD_2 ( ) ) ) ; } } 
<START> public TYPE_1 < Integer > METHOD_1 ( ) { <END> return VAR_1 ; } 
private void METHOD_1 ( ) { log . info ( STRING_1 , getClass ( ) . getName ( ) ) ; boolean VAR_1 = true ; <START> try { <END> METHOD_2 ( ) ; } catch ( Exception e ) { VAR_1 = false ; } finally { if ( METHOD_3 ( ) == TYPE_1 . VAR_3 ) { if ( VAR_1 ) { METHOD_4 ( ) . METHOD_5 ( ) ; } else { METHOD_6 ( ) ; } } } } 
public void METHOD_1 ( ) { METHOD_2 ( TYPE_2 . VAR_2 ) ; METHOD_3 ( ) . METHOD_4 ( ) ; Map < String , TYPE_1 > VAR_3 = METHOD_3 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ; <START> assertTrue ( VAR_3 == null ) ; <END> } 
public TYPE_3 ( TYPE_1 parameters ) { <START> TYPE_2 . METHOD_1 ( parameters ) ; this . parameters = parameters ; <END> } 
public void METHOD_1 ( String value ) { <START> if ( ! TYPE_1 . equals ( VAR_1 , value ) ) { <END> VAR_2 = value ; METHOD_2 ( new TYPE_2 ( STRING_1 ) ) ; } } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) instanceof TYPE_1 ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; VAR_1 . METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; <START> VAR_1 . METHOD_7 ( ) . METHOD_8 ( null ) ; <END> VAR_1 . METHOD_7 ( ) . METHOD_8 ( true ) ; } METHOD_9 ( ) ; VAR_2 . METHOD_10 ( ) ; } 
public static String METHOD_1 ( Map < String , Object > input ) { try { return METHOD_2 ( input ) ; } catch ( IOException e ) { throw new RuntimeException ( String . format ( STRING_1 , <START> e ) ) ; <END> } } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; <START> METHOD_2 ( ) . stream ( ) . forEach ( VAR_2 <END> - > { TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_3 ( VAR_2 . METHOD_4 ( ) . getId ( ) ) ; VAR_3 . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ; VAR_1 . add ( VAR_3 ) ; } ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { <START> VAR_1 . values ( ) . stream ( ) . forEach ( TYPE_1 : : METHOD_2 ) ; <END> } 
public TYPE_2 ( TYPE_1 vm , Guid VAR_2 ) { this ( ) ; <START> this . vm = <END> vm ; METHOD_1 ( vm . getId ( ) ) ; this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; <START> VAR_1 . METHOD_3 ( TYPE_7 . TYPE_5 ) ; <END> TYPE_1 VAR_5 = METHOD_2 ( VAR_6 ) ; VAR_5 . METHOD_4 ( TYPE_3 . VAR_8 ) ; METHOD_5 ( VAR_9 , VAR_10 ) ; METHOD_6 ( TYPE_8 . TYPE_6 , Guid . VAR_13 ( ) , VAR_9 ) ; TYPE_2 . METHOD_7 ( command , TYPE_4 . VAR_15 ) ; } 
private TYPE_1 METHOD_1 ( ) { int max = TYPE_2 . METHOD_2 ( VAR_1 , VAR_2 , STRING_1 , - 1 , - 1 ) ; TYPE_3 params = new TYPE_3 ( max ) ; String VAR_3 = TYPE_4 . METHOD_3 ( VAR_1 , VAR_2 , "" , VAR_4 ) ; Integer VAR_5 = TYPE_4 . METHOD_4 ( VAR_3 ) ; <START> params . VAR_6 ( VAR_5 == null ? 1 : VAR_5 ) ; <END> return METHOD_5 ( METHOD_6 ( TYPE_6 . TYPE_5 , params ) ) ; } 
public static long METHOD_1 ( long a , long b ) { while ( b != 0 ) { <START> a = b ; <END> b = a % b ; } return a ; } 
<START> protected boolean METHOD_1 ( ) { <END> final boolean result = METHOD_2 ( ) ; if ( ! result && ! METHOD_3 ( ) && ! getParameters ( ) . METHOD_4 ( ) ) { METHOD_5 ( ) ; } return result ; } 
public void METHOD_1 ( Map < String , Object > response ) { try { TYPE_1 VAR_1 = ( TYPE_1 ) response . get ( STRING_1 ) ; <START> METHOD_2 ( vds , <END> VAR_1 ) ; } catch ( Throwable t ) { METHOD_3 ( t ) ; } } 
public void METHOD_1 ( ) { TYPE_1 params = METHOD_2 ( ) ; when ( params . VAR_1 ( ) ) . METHOD_3 ( VAR_2 ) ; when ( params . VAR_3 ( ) ) . METHOD_3 ( VAR_4 ) ; when ( VAR_5 . METHOD_4 ( VAR_2 , VAR_4 ) ) . METHOD_3 ( VAR_6 ) ; TYPE_2 < TYPE_1 > query = METHOD_5 ( ) ; query . VAR_7 ( ) ; TYPE_3 VAR_8 = query . VAR_9 ( ) . METHOD_6 ( ) ; <START> assertTrue ( VAR_8 . equals ( VAR_6 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( Guid VAR_1 , Guid VAR_2 ) { TYPE_2 VAR_3 = METHOD_2 ( ) <START> . METHOD_3 ( STRING_1 , VAR_1 ) . METHOD_3 ( STRING_2 , VAR_2 ) ; <END> return METHOD_4 ( ) . METHOD_5 ( STRING_3 , TYPE_3 . instance , VAR_3 ) ; } 
private Guid METHOD_1 ( Map < Guid , Long > TYPE_1 , long VAR_1 , List < Guid > VAR_2 ) { Guid VAR_3 = VAR_2 . stream ( ) <START> . METHOD_2 ( TYPE_2 . METHOD_3 ( TYPE_1 : : get ) ) <END> . METHOD_4 ( VAR_2 . get ( 0 ) ) ; long VAR_4 = TYPE_1 . get ( VAR_3 ) ; TYPE_1 . put ( VAR_3 , VAR_4 - VAR_1 ) ; return VAR_3 ; } 
public TYPE_1 ( TYPE_2 VAR_1 , TYPE_1 . TYPE_7 view , TYPE_4 < TYPE_5 > VAR_2 ) { super ( VAR_1 , view ) ; this . VAR_2 = VAR_2 ; <START> for ( int i = 0 ; i < TYPE_6 . values ( ) . length ; i ++ ) { <END> VAR_3 . add ( TYPE_6 . values ( ) [ i ] . getId ( ) ) ; } VAR_3 . add ( null ) ; } 
private Collection < TYPE_1 > METHOD_1 ( ) { if ( getParameters ( ) . METHOD_2 ( ) ) { TYPE_1 VAR_1 = VAR_2 . get ( METHOD_3 ( ) , TYPE_2 . VAR_4 ) ; return VAR_1 . METHOD_4 ( ) ? Collections . VAR_5 ( VAR_1 ) : Collections . VAR_6 ( ) ; } else { return <START> VAR_2 . METHOD_5 ( METHOD_3 ( ) ) . stream ( ) . filter ( s - > s . VAR_7 ( ) ) . collect ( Collectors . VAR_8 ( ) ) ; <END> } } 
protected void METHOD_1 ( ) { METHOD_2 ( ( TYPE_1 ) ( ) - > <START> TYPE_2 . METHOD_3 ( <END> ( TYPE_3 < TYPE_4 > ) ( ) - > { VAR_1 . METHOD_4 ( VAR_2 ) ; return null ; } ) ) ; VAR_3 . update ( METHOD_5 ( ) ) ; VAR_1 . METHOD_6 ( METHOD_5 ( ) ) ; METHOD_7 ( true ) ; METHOD_8 ( ) . METHOD_9 ( METHOD_10 ( ) ) ; } 
public String METHOD_1 ( ) { String user = String . format ( STRING_1 , VAR_1 . VAR_2 . TYPE_1 . toString ( VAR_3 , "" ) , <START> VAR_1 . VAR_2 . TYPE_1 . toString ( VAR_4 , "" ) ) ; <END> return STRING_2 . equals ( user ) ? STRING_3 : user ; } 
public TYPE_1 ( ) { <START> VAR_2 = VAR_2 == null ? "" : VAR_2 ; <END> } 
public TYPE_1 ( ) { VAR_2 = true ; description = "" ; <START> VAR_3 = "" ; <END> } 
public TYPE_1 ( ) { VAR_2 = false ; VAR_3 = 100 ; VAR_4 = VAR_5 ; VAR_6 = VAR_7 ; VAR_8 = VAR_9 ; name = "" ; VAR_10 = <START> VAR_10 == null ? "" : VAR_10 ; <END> VAR_11 = TYPE_2 . VAR_13 ; VAR_14 = true ; VAR_15 = false ; VAR_16 = true ; VAR_17 = null ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 < TYPE_4 > VAR_2 ) { TYPE_5 VAR_3 = TYPE_6 . METHOD_2 ( VAR_1 , VAR_2 ) ; TYPE_7 VAR_4 = VAR_1 instanceof TYPE_8 ? <START> TYPE_9 . METHOD_3 ( ( TYPE_2 ) null , VAR_2 ) <END> : VAR_5 . METHOD_4 ( VAR_1 ) ; return METHOD_1 ( VAR_1 . getId ( ) , VAR_1 . METHOD_5 ( ) , VAR_4 , VAR_3 ) ; } 
private boolean METHOD_1 ( TYPE_1 entity , long VAR_1 , Integer VAR_2 ) { int <START> VAR_3 = <END> entity . VAR_4 ( ) != null ? entity . VAR_4 ( ) : METHOD_2 ( ) ; boolean VAR_5 = VAR_2 != null ? VAR_2 > VAR_3 : VAR_1 > ( entity . VAR_6 ( ) . METHOD_3 ( ) / INT_1 ) + VAR_3 ; return VAR_3 > 0 && VAR_5 && ! entity . VAR_7 ( ) ; } 
protected void METHOD_1 ( ) { Guid VAR_1 = METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; getParameters ( ) . METHOD_4 ( VAR_1 ) ; TYPE_1 VAR_2 = METHOD_5 ( ) ; METHOD_6 ( ) ; TYPE_2 VAR_3 = METHOD_7 ( ) ; if ( VAR_3 . METHOD_8 ( ) ) { VAR_2 . build ( ) ; METHOD_9 ( VAR_1 , VAR_2 ) ; METHOD_10 ( ) ; METHOD_11 ( true ) ; } <START> else { METHOD_11 ( false ) ; } <END> } 
private static void METHOD_1 ( TYPE_1 VAR_1 , StringBuilder builder ) { Iterator < Object > iterator = VAR_1 . iterator ( ) ; <START> if ( ! iterator . hasNext ( ) ) { builder . append ( STRING_1 ) ; return ; } <END> builder . append ( STRING_2 ) ; while ( iterator . hasNext ( ) ) { METHOD_1 ( iterator . next ( ) , builder ) ; if ( iterator . hasNext ( ) ) { builder . append ( STRING_3 ) ; } } builder . append ( STRING_4 ) ; } 
protected void METHOD_1 ( ) { TYPE_1 parameters = new TYPE_1 ( VAR_1 , METHOD_2 ( ) ) ; METHOD_3 ( TYPE_2 . TYPE_3 , parameters ) ; <START> VAR_1 . METHOD_4 ( null ) ; VAR_1 . METHOD_5 ( null ) ; VAR_4 . update ( VAR_1 ) ; <END> METHOD_6 ( true ) ; } 
private boolean METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) && <START> getType ( ) == TYPE_2 . TYPE_3 && METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) ; <END> } 
private boolean METHOD_1 ( ) { if ( METHOD_2 ( ) == null ) { return false ; } <START> return METHOD_3 ( ) <END> . stream ( ) . map ( TYPE_1 : : METHOD_4 ) . METHOD_5 ( TYPE_2 : : METHOD_6 ) ; } 
private boolean METHOD_1 ( TYPE_1 entity , long VAR_1 , Integer VAR_2 ) { int VAR_3 = METHOD_2 ( ) ; boolean VAR_4 = VAR_2 != null ? VAR_2 > VAR_3 : VAR_1 > ( entity . VAR_5 ( ) . METHOD_3 ( ) / INT_1 ) + VAR_3 ; return VAR_3 > 0 && VAR_4 && entity . VAR_6 ( ) . METHOD_4 ( ) && <START> ! entity . VAR_7 ( ) ; <END> } 
private void METHOD_1 ( List < TYPE_1 < ? > > VAR_1 ) { if ( METHOD_2 ( ) ) { for ( TYPE_1 < ? > VAR_2 : VAR_1 ) { METHOD_3 ( ) . METHOD_4 ( ( TYPE_1 ) VAR_2 , <START> ( int ) VAR_2 . METHOD_5 ( ) ) ; <END> } } } 
private void METHOD_1 ( TYPE_4 . TYPE_5 . VAR_1 . VAR_2 . model . TYPE_2 VAR_3 , TYPE_2 VAR_4 ) { String VAR_5 = VAR_3 . METHOD_2 ( ) ; <START> VAR_4 . METHOD_3 ( ) . METHOD_4 ( VAR_5 != null && VAR_5 . equals ( TYPE_3 ) <END> ? VAR_3 . METHOD_5 ( ) : null ) ; VAR_4 . METHOD_3 ( ) . METHOD_6 ( VAR_3 . METHOD_7 ( ) ) ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( TYPE_5 . TYPE_4 , new TYPE_3 ( getParameters ( ) . METHOD_3 ( ) ) ) ; <START> return VAR_1 . METHOD_4 ( ) ? VAR_1 . METHOD_5 ( ) : null ; <END> } 
private Guid METHOD_1 ( TYPE_1 VAR_1 ) { return <START> ( VAR_1 . METHOD_2 ( ) != null && <END> ! VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) ? METHOD_3 ( VAR_1 . METHOD_2 ( ) . get ( 0 ) . getId ( ) ) : Guid . TYPE_2 ; } 
public void METHOD_1 ( Guid VAR_1 , String VAR_2 ) { <START> if ( log . VAR_3 ( ) && VAR_4 . contains ( VAR_1 ) ) { <END> log . debug ( STRING_1 , VAR_1 , VAR_2 ) ; } VAR_4 . remove ( VAR_1 ) ; } 
private boolean METHOD_1 ( ) { return METHOD_2 ( ) != null <START> && METHOD_2 ( ) . equals ( TYPE_2 . TYPE_3 ) <END> && VAR_1 . contains ( STRING_1 ) ; } 
<START> protected boolean METHOD_1 ( Guid VAR_1 ) { if ( ! TYPE_5 < Boolean > getValue ( TYPE_6 . TYPE_4 ) ) { return VAR_5 . METHOD_2 ( VAR_1 ) ; } return ! VAR_6 . METHOD_3 ( VAR_1 ) . stream ( ) . filter ( vm - > ! TYPE_2 . TYPE_3 . equals ( vm . VAR_7 ( ) ) ) . collect ( Collectors . VAR_8 ( ) ) . isEmpty ( ) ; } <END> 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) { METHOD_2 ( ) . METHOD_3 ( ) . METHOD_5 ( VAR_1 == TYPE_1 . TYPE_3 || VAR_1 == TYPE_1 . TYPE_2 ) ; } if ( METHOD_2 ( ) . METHOD_6 ( ) . METHOD_4 ( ) ) { METHOD_2 ( ) . METHOD_6 ( ) . METHOD_5 ( VAR_1 == TYPE_1 . TYPE_3 || VAR_1 == TYPE_1 . TYPE_2 ) ; <START> } <END> super . METHOD_1 ( VAR_1 ) ; } 
protected boolean METHOD_1 ( ) { <START> if ( METHOD_2 ( ) != null ) { if ( METHOD_2 ( ) . getStatus ( ) == TYPE_1 . TYPE_2 && METHOD_3 ( ) . METHOD_4 ( ) ) <END> { return METHOD_5 ( TYPE_3 . VAR_4 ) ; } } return true ; } 
protected boolean METHOD_1 ( ) { if ( ! super . METHOD_1 ( ) || ! METHOD_2 ( ) ) { return false ; } VAR_1 = VAR_2 . get ( METHOD_3 ( ) . getId ( ) ) ; METHOD_3 ( ) . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; <START> return METHOD_6 ( ) && METHOD_7 ( ) ; <END> } 
public static TYPE_1 map ( TYPE_2 entity ) { if ( entity == null ) { return null ; } switch ( entity ) { <START> case VAR_1 : <END> case VAR_2 : return TYPE_1 . VAR_2 ; case VAR_3 : return TYPE_1 . VAR_3 ; case NONE : return TYPE_1 . NONE ; case VAR_4 : return TYPE_1 . VAR_5 ; default : return null ; } } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( VAR_1 == TYPE_1 . VAR_3 ) { return true ; } <START> return VAR_1 == TYPE_1 . METHOD_2 ( VAR_2 ) ; <END> } 
private void METHOD_1 ( TYPE_1 cluster , TYPE_2 VAR_1 ) { <START> Integer VAR_2 = <END> cluster . VAR_3 ( ) ; if ( VAR_1 . METHOD_2 ( ) > VAR_2 ) { METHOD_3 ( vds , VAR_1 , TYPE_3 . VAR_5 , VAR_2 ) ; } } 
TYPE_10 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 , TYPE_6 VAR_7 , TYPE_7 VAR_8 , TYPE_8 VAR_9 , TYPE_9 VAR_10 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; this . VAR_8 = VAR_8 ; this . VAR_9 = VAR_9 ; this . VAR_10 = VAR_10 ; <START> this . VAR_11 = null ; <END> } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 d = new TYPE_1 ( ) ; d . VAR_1 ( Guid . VAR_2 ( ) ) ; d . VAR_3 ( true ) ; d . VAR_4 ( TYPE_2 . TYPE_3 ) ; d . VAR_7 ( STRING_1 ) ; d . VAR_8 ( TYPE_4 . VAR_10 ) ; <START> d . VAR_11 ( "" ) ; <END> return d ; } 
protected boolean METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; List < TYPE_1 > VAR_2 = METHOD_3 ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( VAR_1 ) ; TYPE_2 VAR_4 = new TYPE_2 ( VAR_2 ) ; <END> return METHOD_4 ( VAR_3 ) && ( METHOD_5 ( ) . METHOD_6 ( ) || METHOD_7 ( VAR_4 . METHOD_8 ( ) ) ) && ( ! METHOD_5 ( ) . METHOD_6 ( ) || METHOD_9 ( ) ) ; } 
public ArrayList < TYPE_1 > METHOD_1 ( ) { return new ArrayList < > ( Arrays . asList ( <START> TYPE_1 . VAR_1 , TYPE_1 . TYPE_2 , TYPE_1 . TYPE_3 , TYPE_1 . VAR_4 , TYPE_1 . VAR_5 <END> ) ) ; } 
<START> public void METHOD_1 ( TYPE_1 < T > VAR_1 , List < TYPE_1 < T > > VAR_2 ) { <END> TYPE_2 VAR_3 = METHOD_2 ( ) . METHOD_3 ( VAR_1 , VAR_2 , this ) ; VAR_4 . add ( VAR_1 ) ; for ( TYPE_1 VAR_5 : VAR_2 ) { VAR_4 . add ( VAR_5 ) ; } METHOD_4 ( VAR_1 , VAR_3 ) ; } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) == null || METHOD_2 ( ) == 0 ) { METHOD_3 ( 0 ) ; } else { <START> METHOD_3 ( ( int ) ( ( METHOD_4 ( ) <END> - METHOD_5 ( ) ) * 100 / METHOD_2 ( ) ) ) ; } } 
public <START> long METHOD_1 ( ) <END> { return VAR_1 ; } 
public String getMessage ( TYPE_1 < ? > VAR_1 , TYPE_1 < ? > VAR_2 ) { <START> return METHOD_1 ( METHOD_2 ( METHOD_3 ( VAR_2 ) ) , VAR_2 ) ; <END> } 
protected void METHOD_1 ( ) { Map < Guid , TYPE_1 > VAR_1 = new HashMap < > ( ) ; for ( Guid id : getParameters ( ) . METHOD_2 ( ) ) { TYPE_1 VAR_2 = VAR_3 . METHOD_3 ( id , METHOD_4 ( ) , getParameters ( ) . METHOD_5 ( ) ) ; <START> VAR_1 . put ( id , VAR_2 ) ; <END> } METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 vm , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = VAR_1 . METHOD_2 ( ) . get ( 0 ) ; String VAR_4 = METHOD_3 ( vm , VAR_1 , VAR_2 ) ; boolean VAR_5 = ! STRING_1 . equals ( VAR_4 ) || ( VAR_3 == TYPE_4 . VAR_6 && TYPE_5 . METHOD_4 ( vm . VAR_7 ( ) ) ) ; if ( STRING_1 . equals ( VAR_4 ) && VAR_2 . METHOD_5 ( ) != null ) { VAR_5 = false ; } <START> return VAR_5 ; <END> } 
public void METHOD_1 ( ) { <START> assertEquals ( INT_1 , TYPE_1 . values ( ) . length , <END> STRING_1 + STRING_2 ) ; } 
<START> protected TYPE_1 ( Guid <END> VAR_2 ) { super ( VAR_2 ) ; } 
public boolean equals ( Object o ) { <START> if ( this == o ) <END> return true ; if ( ! ( o instanceof TYPE_1 ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; return TYPE_2 . equals ( VAR_1 , that . VAR_1 ) && TYPE_2 . equals ( VAR_2 , that . VAR_2 ) ; } 
private String METHOD_1 ( String VAR_1 ) { <START> for ( TYPE_1 VAR_2 : VAR_3 . METHOD_2 ( ) ) { <END> if ( VAR_2 != null && VAR_2 . METHOD_3 ( ) != null ) { if ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) . equals ( VAR_1 ) ) { return VAR_2 . METHOD_3 ( ) . getName ( ) ; } } } return "" ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 , TYPE_4 . VAR_3 , STRING_2 , STRING_3 ) ; VAR_1 . METHOD_3 ( Guid . VAR_4 ( ) . toString ( ) ) ; parameters . VAR_5 ( VAR_1 ) ; parameters . VAR_6 ( Guid . TYPE_3 ) ; <START> METHOD_4 ( "" ) . when ( command ) . METHOD_5 ( VAR_1 , <END> null ) ; TYPE_2 . METHOD_6 ( command , TYPE_5 . VAR_9 ) ; } 
public boolean METHOD_1 ( ) { return this == VAR_1 <START> || this == VAR_2 ; <END> } 
public boolean equals ( Object o ) { <START> if ( this == o ) <END> return true ; if ( ! ( o instanceof TYPE_1 ) ) return false ; if ( ! super . equals ( o ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; return TYPE_2 . equals ( VAR_1 , that . VAR_1 ) ; } 
protected void METHOD_1 ( ) { <START> return ; <END> } 
public static <START> final TYPE_1 < TYPE_2 > <END> METHOD_1 ( String VAR_1 ) { TYPE_1 < TYPE_2 > column = new TYPE_1 < TYPE_2 > ( ) { @Override public String getValue ( TYPE_2 object ) { if ( object . VAR_2 ( ) . size ( ) == 1 ) { return object . VAR_2 ( ) . iterator ( ) . next ( ) . METHOD_2 ( ) ; } return null ; } } ; return METHOD_3 ( column , VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { String VAR_3 = TYPE_3 . toString ( VAR_1 . METHOD_2 ( ) , <START> "" ) ; <END> for ( TYPE_4 VAR_4 : VAR_2 . METHOD_3 ( ) ) { String VAR_5 = TYPE_3 . toString ( VAR_4 . METHOD_4 ( ) . METHOD_2 ( ) , "" ) ; if ( ! VAR_3 . equals ( VAR_5 ) ) { return false ; } } return true ; } 
public TYPE_5 ( ) { VAR_2 = TYPE_6 . VAR_4 ; name = "" ; VAR_5 = true ; VAR_6 = TYPE_3 . NONE ; VAR_8 = new HashSet < > ( ) ; VAR_9 = new TYPE_1 ( ) ; VAR_10 = new HashSet < > ( ) ; VAR_11 = true ; VAR_12 = TYPE_4 . VAR_14 ; VAR_15 = TYPE_7 . VAR_17 ; VAR_18 = TYPE_2 . VAR_20 ; description = "" ; VAR_21 = "" ; VAR_22 = "" ; VAR_23 = true ; VAR_24 = true ; <START> VAR_25 = true ; <END> } 
public static TYPE_1 map ( org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_4 action ) { switch ( action ) { case <START> TYPE_6 : <END> return TYPE_1 . VAR_8 ; case TYPE_5 : return TYPE_1 . VAR_10 ; case TYPE_3 : return TYPE_1 . VAR_12 ; case TYPE_2 : return TYPE_1 . VAR_14 ; default : return null ; } } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 cluster , TYPE_4 VAR_4 ) { this ( VAR_2 , VAR_3 , cluster , VAR_4 , <START> null , <END> null , null , null , null , null ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 host ) { TYPE_3 <START> VAR_1 = <END> METHOD_2 ( ) ; TYPE_4 VAR_2 = new TYPE_4 ( host , getParameters ( ) , METHOD_3 ( ) , METHOD_4 ( ) , VAR_1 , METHOD_5 ( ) , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 ) ; return VAR_2 . METHOD_6 ( ) ; } 
<START> public static <END> boolean METHOD_1 ( TYPE_1 a , TYPE_1 b ) { return a != null && b != null && a . getId ( ) != null && a . getId ( ) . equals ( b . getId ( ) ) ; } 
<START> static boolean METHOD_1 ( TYPE_1 a , TYPE_1 b ) { <END> return a != null && b != null && a . getId ( ) != null && a . getId ( ) . equals ( b . getId ( ) ) ; } 
public TYPE_4 ( String id , TYPE_1 parent ) { super ( id , parent , TYPE_3 . TYPE_2 ) ; VAR_4 = <START> ( ( TYPE_1 ) parent ) . VAR_4 ; <END> } 
private <START> static String <END> METHOD_1 ( String VAR_1 ) { StringBuilder builder = new StringBuilder ( ) ; int VAR_2 = 4 - VAR_1 . length ( ) ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { builder . append ( VAR_3 ) ; } builder . append ( VAR_1 ) ; return builder . toString ( ) ; } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) . METHOD_3 ( ) == TYPE_1 . VAR_2 && METHOD_4 ( ) == TYPE_4 . VAR_4 && METHOD_5 ( ) != null && METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) ) { METHOD_2 ( ) . METHOD_8 ( ) . forEach ( VAR_5 - > VAR_5 . METHOD_9 ( VAR_5 . METHOD_10 ( ) ) ) ; <START> METHOD_2 ( ) . METHOD_8 ( ) . forEach ( VAR_5 - > VAR_5 . METHOD_11 ( TYPE_2 . TYPE_3 ) ) ; <END> } } 
protected boolean METHOD_1 ( TYPE_1 group ) { <START> if ( ! VAR_1 . METHOD_2 ( group . VAR_2 ( ) , <END> getParameters ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) ) { return true ; } return VAR_1 . METHOD_1 ( group . VAR_2 ( ) , METHOD_3 ( ) . METHOD_5 ( ) , METHOD_3 ( ) . METHOD_4 ( ) ) ; } 
protected void METHOD_1 ( final Integer VAR_1 ) { TYPE_1 cluster = METHOD_2 ( ) . METHOD_3 ( ) ; <START> if ( cluster != null ) { <END> List < Integer > VAR_2 = TYPE_2 . getInstance ( ) . METHOD_4 ( cluster . VAR_3 ( ) ) ; if ( VAR_1 == null || ! VAR_2 . contains ( VAR_1 ) ) { METHOD_5 ( ) ; return ; } METHOD_2 ( ) . METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; } } 
private void METHOD_1 ( List < String > VAR_1 ) { Guid VAR_2 = VAR_3 . METHOD_2 ( METHOD_3 ( ) ) . METHOD_4 ( ) ; TYPE_1 < T > VAR_4 = VAR_5 . METHOD_5 ( VAR_2 ) ; String VAR_6 = VAR_1 . get ( 0 ) ; VAR_4 . METHOD_6 ( STRING_1 , VAR_6 ) ; <START> VAR_7 . log ( VAR_4 , TYPE_2 . VAR_9 , VAR_6 ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . stream ( ) . map ( VAR_3 - > new TYPE_1 ( VAR_3 , TYPE_4 . VAR_5 , METHOD_2 ( ) . METHOD_3 ( ) ) ) . collect ( Collectors . VAR_6 ( ) ) ; <START> VAR_1 . add ( new TYPE_1 ( METHOD_4 ( ) , TYPE_4 . TYPE_3 , TYPE_2 . VAR_9 ) ) ; <END> return VAR_1 ; } 
private boolean METHOD_1 ( ) { boolean VAR_1 ; if ( getParameters ( ) . METHOD_1 ( ) != null ) { <START> VAR_1 = <END> getParameters ( ) . METHOD_1 ( ) ; } else { VAR_1 = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) ) ; } return VAR_1 ; } 
protected void METHOD_1 ( ) { TYPE_1 vm = METHOD_2 ( ) ; if ( vm == null ) { return ; } <START> TYPE_1 VAR_1 = VAR_2 . METHOD_3 ( getParameters ( ) . getId ( ) , METHOD_4 ( ) , getParameters ( ) . METHOD_5 ( ) ) ; <END> if ( VAR_1 != null ) { vm . VAR_3 ( VAR_1 . METHOD_6 ( ) ) ; } METHOD_7 ( vm ) ; METHOD_8 ( ) . METHOD_9 ( vm ) ; } 
public TYPE_1 ( Guid VAR_2 ) { <START> super ( VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { <START> List < TYPE_1 > result = VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( - 1 ) ) ; <END> METHOD_4 ( result ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( TYPE_2 . equals ( METHOD_2 ( ) ) && <END> METHOD_3 ( ) ) { return METHOD_4 ( ) ? VAR_1 : VAR_2 ; } else if ( TYPE_2 . equals ( METHOD_2 ( ) ) && ! METHOD_3 ( ) ) { return VAR_3 ; } else if ( TYPE_3 . equals ( METHOD_2 ( ) ) ) { return VAR_4 ; } return VAR_5 ; } 
private void METHOD_1 ( TYPE_1 e , TYPE_3 . TYPE_4 VAR_1 ) { if ( e != null && <START> e != METHOD_2 ( ) . METHOD_3 ( ) ) { <END> e . VAR_2 ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ; METHOD_1 ( e . VAR_2 ( ) , VAR_1 ) ; } } 
private boolean METHOD_1 ( ) { return <START> METHOD_2 ( ) . METHOD_3 ( ) != TYPE_1 . VAR_2 && METHOD_2 ( ) . METHOD_3 ( ) == METHOD_4 ( ) . METHOD_3 ( ) ; <END> } 
public <START> synchronized Map < Guid , <END> TYPE_1 > METHOD_1 ( Set < Guid > VAR_1 ) { if ( VAR_1 == null ) { return Collections . VAR_2 ( ) ; } return VAR_1 . stream ( ) . collect ( Collectors . VAR_3 ( TYPE_2 . METHOD_2 ( ) , this : : METHOD_3 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> METHOD_2 ( ) ; <END> } return VAR_1 ; } 
<START> public boolean <END> METHOD_1 ( ) { TYPE_1 VAR_1 ; try { VAR_1 = METHOD_2 ( TYPE_5 . TYPE_4 , new TYPE_2 ( parent . VAR_4 , VAR_5 ) ) ; } catch ( TYPE_3 e ) { if ( e . VAR_6 ( ) . getStatus ( ) == Response . Status . VAR_7 . METHOD_3 ( ) ) { return false ; } throw e ; } return VAR_1 != null ; } 
private Guid METHOD_1 ( TYPE_1 VAR_1 ) { if ( Guid . TYPE_2 . equals ( VAR_1 . METHOD_2 ( ) ) ) { return Guid . TYPE_2 ; } <START> else { if ( ! getParameters ( ) . METHOD_3 ( ) . isEmpty ( ) ) <END> { return getParameters ( ) . METHOD_4 ( ) ; } } return VAR_1 . METHOD_5 ( ) . equals ( VAR_1 . METHOD_2 ( ) ) ? VAR_3 . get ( VAR_1 . METHOD_5 ( ) ) . METHOD_6 ( ) : getParameters ( ) . METHOD_7 ( ) ; } 
public <START> TYPE_2 ( ) <END> { this . METHOD_1 ( Guid . TYPE_1 ) ; this . METHOD_2 ( Guid . TYPE_1 ) ; this . METHOD_3 ( Guid . TYPE_1 ) ; } 
<START> protected void <END> METHOD_1 ( ) { METHOD_2 ( false ) ; METHOD_3 ( true ) ; } 
private void METHOD_1 ( Guid VAR_1 , Guid VAR_2 ) { <START> if ( ! METHOD_2 ( ) ) { <END> List < TYPE_1 > VAR_3 = VAR_4 . METHOD_3 ( VAR_1 , VAR_2 ) ; if ( ! VAR_3 . isEmpty ( ) ) { VAR_5 = VAR_3 . get ( 0 ) ; try { METHOD_4 ( ) ; } catch ( TYPE_2 e ) { log . error ( STRING_1 , e . getMessage ( ) , VAR_5 . METHOD_5 ( ) ) ; log . debug ( STRING_2 , e ) ; } } } } 
<START> protected void <END> METHOD_1 ( Guid VAR_1 , Guid VAR_2 ) { if ( ! METHOD_2 ( ) ) { List < TYPE_1 > VAR_3 = VAR_4 . METHOD_3 ( VAR_1 , VAR_2 ) ; if ( ! VAR_3 . isEmpty ( ) ) { VAR_5 = VAR_3 . get ( 0 ) ; try { METHOD_4 ( ) ; } catch ( TYPE_2 e ) { log . error ( STRING_1 , e . getMessage ( ) , VAR_5 . METHOD_5 ( ) ) ; log . debug ( STRING_2 , e ) ; } } } } 
<START> public void <END> METHOD_1 ( ) { when ( VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) ) . METHOD_3 ( new ArrayList < > ( ) ) ; } 
public void METHOD_1 ( TYPE_1 command ) { super . METHOD_1 ( command ) ; if ( command == METHOD_2 ( ) ) { METHOD_3 ( ) ; } else if ( command == METHOD_4 ( ) ) { remove ( ) ; } else if <START> ( STRING_1 . equals ( command . getName ( ) ) ) <END> { METHOD_5 ( ) ; } else if ( command . getName ( ) . equals ( STRING_2 ) ) { METHOD_6 ( ) ; } } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) == null || ! VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ) ; <END> VAR_3 . METHOD_3 ( METHOD_6 ( VAR_1 ) ) ; VAR_4 . METHOD_3 ( VAR_1 . METHOD_7 ( ) == TYPE_2 . VAR_6 || VAR_1 . METHOD_7 ( ) == TYPE_2 . VAR_7 ) ; } } 
public static TYPE_1 < TYPE_2 < ? > > METHOD_1 ( ) { <START> return TYPE_1 . of ( TYPE_2 . of ( TYPE_4 . TYPE_3 , STRING_1 ) , TYPE_2 . of ( TYPE_4 . TYPE_5 , INT_1 ) ) ; <END> } 
public static void METHOD_1 ( TYPE_1 < List < String > > VAR_1 , Guid VAR_2 , int VAR_3 , TYPE_2 VAR_4 ) { <START> TYPE_3 . METHOD_2 ( new TYPE_1 < > ( VAR_5 - > { <END> if ( VAR_5 ) { METHOD_3 ( VAR_1 , VAR_2 , false , TYPE_5 . TYPE_6 , new TYPE_4 ( ) ) ; } } ) , VAR_3 , VAR_4 ) ; } 
public TYPE_2 ( ) { super ( ) ; METHOD_1 ( new TYPE_1 < > ( ) ) ; METHOD_2 ( ) . METHOD_3 ( false ) ; <START> METHOD_2 ( ) . METHOD_4 ( true ) ; <END> } 
private void METHOD_1 ( TYPE_1 model ) { <START> VAR_1 . METHOD_2 ( model . getName ( ) . METHOD_3 ( ) ) ; <END> METHOD_4 ( model , VAR_1 ) ; } 
public TYPE_1 update ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_1 ( ) ) { <START> return METHOD_2 ( <END> VAR_1 , new TYPE_2 < > ( TYPE_12 . TYPE_10 , TYPE_3 . class ) , TYPE_9 . TYPE_8 , new TYPE_4 ( ) ) ; } return METHOD_2 ( VAR_1 , new TYPE_5 ( ) , TYPE_9 . TYPE_11 , new TYPE_7 . TYPE_4 ( ) ) ; } 
public void METHOD_1 ( Collection < T > value , T VAR_1 ) { List < T > VAR_2 = new ArrayList < > ( value ) ; <START> if ( VAR_2 . get ( 0 ) != null ) <END> { VAR_2 . add ( 0 , null ) ; } super . METHOD_1 ( VAR_2 , VAR_1 ) ; } 
<START> private void METHOD_1 ( ) { <END> METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) && METHOD_7 ( ) . METHOD_5 ( ) != null ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( TYPE_6 . VAR_2 != VAR_3 . getType ( ) ) { return TYPE_1 . VAR_4 ; } List < TYPE_2 < ? > > VAR_5 = TYPE_3 . get ( TYPE_4 . class ) . METHOD_2 ( TYPE_6 . VAR_2 ) ; <START> if ( TYPE_5 . METHOD_3 ( VAR_3 ) ) { return METHOD_4 ( VAR_5 ) ; } else { return METHOD_5 ( VAR_5 ) ; } <END> } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; if ( ! METHOD_5 ( new TYPE_2 ( METHOD_6 ( ) ) . METHOD_7 ( ) ) ) { return false ; } TYPE_3 VAR_2 = new <START> TYPE_3 ( Collections . VAR_3 ( VAR_1 ) ) ; <END> return METHOD_5 ( VAR_2 . METHOD_8 ( ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 command , String VAR_1 ) { return TYPE_3 . METHOD_2 ( command . VAR_2 ( ) . get ( 0 ) , command . VAR_3 ( ) , <START> new HashMap < > ( ) { { put ( STRING_1 , VAR_1 ) ; put ( STRING_2 , command . VAR_4 ( ) ) ; } } <END> ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> METHOD_2 ( STRING_1 , String . format ( STRING_2 , METHOD_3 ( ) ) ) ; <END> return METHOD_4 ( ) ? TYPE_1 . VAR_1 : TYPE_1 . VAR_2 ; } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) ) { METHOD_3 ( ) ; return ; } if ( METHOD_4 ( ) ) { METHOD_5 ( ) ; return ; } if ( METHOD_6 ( ) ) { METHOD_7 ( ) ; return ; } <START> if ( METHOD_8 ( ) ) { <END> METHOD_9 ( ) ; } if ( ! METHOD_10 ( ) ) { METHOD_11 ( ) ; return ; } METHOD_12 ( ) ; } 
<START> public TYPE_1 <END> METHOD_1 ( TYPE_2 VAR_1 , TYPE_1 VAR_2 ) { return VAR_1 != null && VAR_1 . METHOD_2 ( ) ? TYPE_1 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) : VAR_2 ; } 
<START> public TYPE_1 <END> METHOD_1 ( TYPE_2 VAR_1 ) { return VAR_1 != null ? VAR_2 . get ( VAR_1 . METHOD_2 ( ) ) : null ; } 
<START> public List < TYPE_1 > <END> METHOD_1 ( ) { return VAR_1 . METHOD_1 ( ) ; } 
private void METHOD_1 ( Map < Guid , TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) { TYPE_1 VAR_3 = VAR_1 . get ( VAR_2 . getId ( ) ) ; if ( VAR_3 == null ) { return ; } <START> if ( VAR_2 . getType ( ) == TYPE_3 . VAR_5 || VAR_2 . getType ( ) == TYPE_3 . VAR_6 ) { <END> VAR_3 . METHOD_2 ( true ) ; } else { VAR_3 . METHOD_2 ( false ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( ) . METHOD_3 ( new TYPE_2 [ ] { <END> new TYPE_3 ( ) , new TYPE_4 ( ) , } ) ; if ( METHOD_2 ( ) . METHOD_4 ( ) ) { long VAR_2 = Long . VAR_3 ( METHOD_2 ( ) . METHOD_5 ( ) ) ; if ( VAR_2 > 0 ) { VAR_1 . METHOD_6 ( VAR_1 . METHOD_7 ( ) + VAR_2 ) ; } } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { try { <START> long VAR_2 = Long . VAR_3 ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> if ( VAR_2 > 0 ) { VAR_1 . METHOD_4 ( VAR_1 . METHOD_5 ( ) + VAR_2 ) ; } } catch ( TYPE_2 VAR_4 ) { } } 
public int METHOD_1 ( int VAR_1 ) { <START> VAR_2 . METHOD_2 ( ++ VAR_1 ) ; VAR_3 . METHOD_2 ( ++ VAR_1 ) ; VAR_4 . METHOD_2 ( ++ VAR_1 ) ; <END> return VAR_1 ; } 
protected void METHOD_1 ( ) { TYPE_1 cluster = VAR_1 . get ( getParameters ( ) . METHOD_2 ( ) ) ; if ( cluster . VAR_2 ( ) ) { try { VAR_3 . METHOD_3 ( cluster ) ; } catch ( Exception e ) { <START> log . error ( STRING_1 , <END> cluster . getName ( ) , e . getMessage ( ) ) ; log . debug ( STRING_2 , e ) ; } METHOD_4 ( true ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { vm . VAR_2 ( VAR_1 ) ; vm . VAR_3 ( VAR_4 ) ; vm . VAR_5 ( Guid . VAR_6 ( ) ) ; when ( VAR_7 . get ( command . getParameters ( ) . METHOD_2 ( ) ) ) . METHOD_3 ( vm ) ; <START> return vm ; <END> } 
public static int METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < ? > column ) { if ( VAR_1 == null || column == null ) { return - 1 ; } for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { TYPE_1 . TYPE_4 VAR_2 = VAR_1 . get ( i ) ; if <START> ( column == VAR_2 . METHOD_2 ( ) ) { <END> return i ; } } return - 1 ; } 
public Guid METHOD_1 ( Guid VAR_1 , Collection < Guid > VAR_2 ) { return METHOD_1 ( VAR_1 , vds - > <START> ! VAR_2 . contains ( vds ) ) ; <END> } 
public boolean METHOD_1 ( Guid VAR_1 , Guid VAR_2 , Guid VAR_3 , Guid VAR_4 ) { TYPE_1 VAR_5 = METHOD_2 ( VAR_3 ) ; TYPE_1 VAR_6 = METHOD_3 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; <START> return VAR_5 . getId ( ) . equals ( VAR_6 . getId ( ) ) ? TYPE_2 . VAR_8 == VAR_6 . METHOD_4 ( ) : true ; <END> } 
public boolean METHOD_1 ( Guid VAR_1 , Guid VAR_2 , Guid VAR_3 , Guid VAR_4 ) { TYPE_1 VAR_5 = METHOD_2 ( VAR_3 ) ; TYPE_1 VAR_6 = METHOD_3 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; if ( VAR_5 . getId ( ) . equals ( VAR_6 . getId ( ) ) ) { return TYPE_2 . VAR_8 == VAR_6 . METHOD_4 ( ) ; } return <START> true ; <END> } 
private String METHOD_1 ( TYPE_1 response ) { TYPE_2 reader = null ; try { reader = new TYPE_2 ( new TYPE_3 ( response . VAR_1 ( ) . METHOD_2 ( ) ) ) ; } catch ( IOException e ) { e . VAR_2 ( ) ; } <START> return reader . VAR_3 ( ) . collect ( Collectors . VAR_4 ( ) ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( METHOD_2 ( ) . toString ( ) ) ; } <START> return VAR_1 ; <END> } 
<START> public void METHOD_1 ( Object instance , <END> String VAR_1 , Class < ? > [ ] VAR_2 , Object [ ] VAR_3 , long VAR_4 , long VAR_5 , TimeUnit VAR_6 ) { VAR_7 . METHOD_1 ( METHOD_2 ( instance , VAR_1 ) , VAR_4 , VAR_5 , TimeUnit . VAR_8 ) ; } 
public void close ( ) throws IOException { <START> VAR_1 . close ( ) ; <END> } 
public void METHOD_1 ( ) { try { <START> VAR_1 . close ( ) ; <END> } catch ( IOException e ) { } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; try { <START> VAR_1 . close ( ) ; <END> } catch ( IOException e ) { } } 
public boolean METHOD_1 ( int VAR_1 ) { METHOD_2 ( ) ; switch ( getParameters ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) { case VAR_2 : <START> if ( METHOD_5 ( ) ) { METHOD_6 ( TYPE_1 . VAR_4 ) ; } else { METHOD_7 ( TYPE_2 . VAR_6 ) ; } <END> log . info ( STRING_1 ) ; break ; case VAR_4 : return true ; case VAR_7 : METHOD_8 ( ) ; METHOD_7 ( TYPE_2 . VAR_8 ) ; break ; } METHOD_9 ( ) ; return true ; } 
private static TYPE_1 METHOD_1 ( ) { TYPE_1 group = new TYPE_1 ( ) ; group . VAR_1 ( STRING_1 ) ; group . VAR_2 ( "" ) ; group . VAR_3 ( VAR_4 ) ; group . VAR_5 ( VAR_6 ) ; group . VAR_7 ( VAR_8 ) ; group . VAR_9 ( TYPE_2 . VAR_11 ) ; group . VAR_12 ( Guid . VAR_13 ( ) ) ; group . VAR_14 ( 100 ) ; <START> group . VAR_15 ( TYPE_3 . VAR_17 ) ; <END> return group ; } 
public TYPE_1 ( Map < String , Object > VAR_2 ) { super ( VAR_2 ) ; VAR_3 = ( Map < String , Object > ) VAR_2 . get ( TYPE_2 . VAR_5 ) ; Object VAR_6 = VAR_2 . get ( TYPE_2 . VAR_7 ) ; if ( VAR_6 != null ) { VAR_8 = ( String ) <START> VAR_2 . get ( TYPE_2 . VAR_7 ) ; <END> } } 
private String METHOD_1 ( int from , int to , int VAR_1 ) { if ( VAR_1 > 0 ) { return VAR_2 . METHOD_2 ( from , to , VAR_1 ) ; <START> } else { <END> return VAR_2 . METHOD_3 ( from , to ) ; } } 
private void METHOD_1 ( TYPE_1 vm ) { vm . VAR_1 ( null ) ; vm . VAR_2 ( ) . clear ( ) ; vm . VAR_3 ( null ) ; vm . VAR_4 ( null ) ; vm . VAR_5 ( null ) ; <START> vm . VAR_6 ( "" ) ; <END> vm . VAR_7 ( null ) ; vm . VAR_8 ( null ) ; vm . VAR_9 ( null ) ; vm . VAR_10 ( null ) ; vm . VAR_11 ( false ) ; vm . VAR_12 ( 0 ) ; } 
private boolean METHOD_1 ( Guid VAR_1 , String VAR_2 ) { String <START> VAR_3 = <END> String . format ( STRING_1 , VAR_2 , VAR_4 , VAR_1 ) ; TYPE_1 VAR_5 = METHOD_2 ( VAR_1 , VAR_3 ) ; log . info ( STRING_2 , VAR_1 ) ; try { METHOD_3 ( ) . METHOD_4 ( VAR_5 ) ; } catch ( RuntimeException e ) { log . error ( STRING_3 , e . getMessage ( ) , e ) ; return false ; } return true ; } 
<START> public static <END> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 parameters = new TYPE_1 ( ) ; parameters . VAR_2 ( TYPE_4 . TYPE_5 ) ; parameters . VAR_5 ( VAR_1 . getId ( ) ) ; String VAR_6 = VAR_1 . METHOD_2 ( ) == TYPE_3 . VAR_8 ? STRING_1 : STRING_2 ; parameters . VAR_9 ( VAR_1 . METHOD_3 ( ) + VAR_6 ) ; parameters . VAR_10 ( VAR_1 . METHOD_4 ( ) ) ; parameters . VAR_11 ( true ) ; return parameters ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> TYPE_1 parameters = new TYPE_1 ( ) ; parameters . VAR_2 ( TYPE_4 . TYPE_5 ) ; parameters . VAR_5 ( VAR_1 . getId ( ) ) ; String VAR_6 = VAR_1 . METHOD_2 ( ) == TYPE_3 . VAR_8 ? STRING_1 : STRING_2 ; parameters . VAR_9 ( VAR_1 . METHOD_3 ( ) + VAR_6 ) ; parameters . VAR_10 ( VAR_1 . METHOD_4 ( ) ) ; parameters . VAR_11 ( true ) ; return parameters ; } 
private boolean METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; return VAR_1 != null && <START> VAR_1 . size ( ) != 0 ; <END> } 
private <START> List METHOD_1 ( TYPE_1 <END> VAR_1 , TYPE_2 params ) { TYPE_3 VAR_2 ; try { VAR_2 = METHOD_2 ( VAR_1 , params ) ; if ( ! VAR_2 . METHOD_3 ( ) ) { TYPE_4 VAR_3 = new TYPE_4 ( ) ; VAR_3 . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ; throw VAR_3 ; } } catch ( TYPE_4 e ) { log . error ( STRING_1 , VAR_1 , e ) ; throw e ; } return ( List ) VAR_2 . METHOD_6 ( ) ; } 
private boolean METHOD_1 ( ) { return METHOD_2 ( ) || METHOD_3 ( ) || METHOD_4 ( ) <START> || VAR_1 . METHOD_5 ( ) == METHOD_5 ( ) ; <END> } 
protected boolean METHOD_1 ( ) { if ( ! ( METHOD_2 ( ) . getStatus ( ) == TYPE_3 . TYPE_2 || METHOD_2 ( ) . METHOD_3 ( ) ) ) { return METHOD_4 ( TYPE_4 . VAR_4 ) ; } TYPE_1 VAR_5 = new TYPE_1 ( VAR_6 ) ; <START> METHOD_1 ( VAR_5 . METHOD_5 ( ) ) ; <END> return super . METHOD_1 ( ) ; } 
public boolean METHOD_1 ( String VAR_1 , String VAR_2 , String <START> VAR_3 ) { <END> String VAR_4 = TYPE_1 . getInstance ( ) . METHOD_2 ( VAR_2 ) ; TYPE_2 VAR_5 = VAR_6 . METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_3 VAR_7 = VAR_6 . METHOD_4 ( VAR_3 ) ; return VAR_5 . METHOD_5 ( VAR_7 ) ; } 
protected void METHOD_1 ( final int VAR_1 , final int column , final int line , final short file ) { <START> METHOD_1 ( VAR_1 , column , line , file , "" ) ; <END> } 
private static List < String > METHOD_1 ( final TYPE_1 config , final String name ) { String s [ ] = config . VAR_1 ( STRING_1 , null , name ) ; <START> if ( s == null || s . length == 0 ) { <END> return null ; } final List < String > VAR_2 = new ArrayList < String > ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { VAR_2 . add ( s [ i ] ) ; } return VAR_2 ; } 
TYPE_5 ( final TYPE_3 . TYPE_4 i , final TYPE_2 VAR_2 ) { id = i ; VAR_3 = VAR_2 ; <START> VAR_4 = null ; <END> } 
public void METHOD_1 ( TYPE_1 listener , TYPE_2 user ) { <START> TYPE_3 VAR_1 = new TYPE_3 ( listener , user ) ; <END> VAR_2 . put ( listener , VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 user ) { <START> final TYPE_3 VAR_2 = VAR_3 . get ( VAR_1 . METHOD_2 ( ) ) ; <END> final TYPE_4 VAR_4 = VAR_2 . METHOD_3 ( user ) ; final TYPE_5 VAR_5 = VAR_4 . METHOD_4 ( VAR_1 . METHOD_5 ( ) . get ( ) ) ; return VAR_5 . METHOD_6 ( ) ; } 
<START> public TYPE_1 ( ) { <END> } 
protected TYPE_2 ( ) { <START> this ( new ArrayList < TYPE_1 > ( ) , false ) ; <END> } 
public int METHOD_1 ( Set < TYPE_3 . TYPE_4 > VAR_1 ) { int val = Integer . VAR_2 ; for ( TYPE_2 VAR_3 : VAR_4 ) { if ( VAR_1 . contains ( VAR_3 . METHOD_2 ( ) ) ) { <START> if ( ( val < 0 && VAR_3 . METHOD_3 ( ) > 0 ) ) { <END> val = Math . max ( VAR_3 . METHOD_3 ( ) , val ) ; } } } return val ; } 
TYPE_6 ( final TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 VAR_3 , final TYPE_4 context , ANNOTATION_1 final TYPE_5 VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_5 = VAR_3 . METHOD_1 ( ) ; <END> this . context = context ; this . VAR_6 = METHOD_2 ( VAR_4 , STRING_1 , null , STRING_2 , 5 , VAR_7 ) ; } 
public static String METHOD_1 ( String VAR_1 ) { if ( VAR_1 . equalsIgnoreCase ( STRING_1 ) ) { return STRING_2 ; <START> } <END> StringBuilder VAR_2 = new StringBuilder ( INT_1 ) ; VAR_2 . METHOD_2 ( INT_1 ) ; METHOD_3 ( VAR_2 , - INT_2 - METHOD_4 ( VAR_1 ) ) ; return VAR_2 . toString ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { db . create ( ) ; final TYPE_2 config = db . VAR_1 ( ) ; <START> METHOD_2 ( TYPE_3 . VAR_3 + STRING_1 , config . VAR_4 , <END> TYPE_4 . VAR_6 , 1 , 1 ) ; } 
public TYPE_9 ( TYPE_1 < TYPE_2 > VAR_2 , ANNOTATION_1 ( TYPE_8 . VAR_4 ) final TYPE_3 < TYPE_5 . TYPE_7 , TYPE_5 > cache ) throws TYPE_6 { <START> this . VAR_5 = VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) ; <END> this . cache = cache ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = null ; <END> try { VAR_1 = VAR_2 . get ( ) . METHOD_2 ( ) . get ( METHOD_3 ( ) ) ; if ( VAR_1 == null ) { return TYPE_1 . METHOD_4 ( METHOD_3 ( ) ) ; } } catch ( TYPE_2 e ) { log . warn ( STRING_1 , e ) ; } return VAR_1 ; } 
void METHOD_1 ( TYPE_1 event ) { update ( ) ; if ( TYPE_2 . METHOD_2 ( ) ) { <START> METHOD_3 ( ) ; <END> } } 
private void METHOD_1 ( ) { if ( VAR_1 != - 1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; <START> if ( VAR_2 != null ) { <END> VAR_2 . METHOD_2 ( false ) ; } VAR_1 = - 1 ; } } 
<START> public TYPE_3 ( TYPE_1 < TYPE_2 > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return VAR_1 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 e ) { TYPE_1 VAR_1 = new TYPE_1 ( e . VAR_2 ( ) , e . VAR_3 ( ) , e . VAR_4 ( ) , e . VAR_5 ( ) ) ; <START> if ( e instanceof TYPE_3 ) { <END> TYPE_3 VAR_6 = ( TYPE_3 ) e ; List < TYPE_1 > VAR_7 = TYPE_1 . METHOD_2 ( VAR_6 . METHOD_3 ( ) ) ; VAR_1 = new TYPE_5 . TYPE_6 . VAR_8 . VAR_9 . VAR_10 . TYPE_3 ( VAR_1 , VAR_7 ) ; } return VAR_1 ; } 
public static List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { ArrayList < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( VAR_1 . size ( ) ) ; for ( TYPE_2 e : VAR_1 ) { <START> VAR_2 . add ( METHOD_2 ( e ) ) ; <END> } return Collections . VAR_3 ( VAR_2 ) ; } 
<START> public TYPE_2 ( T object , TYPE_1 < T > VAR_2 ) { <END> buf = new byte [ VAR_2 . METHOD_1 ( object ) ] ; VAR_2 . METHOD_2 ( object , buf ) ; this . object = object ; this . VAR_2 = VAR_2 ; VAR_3 = object . VAR_4 ( ) ; } 
<START> public T METHOD_1 ( TYPE_1 < T > VAR_1 , TYPE_2 < T > VAR_2 ) { <END> if ( object == null ) { this . VAR_1 = VAR_1 ; if ( VAR_2 == null ) { object = VAR_1 . METHOD_2 ( buf ) ; } else { object = VAR_2 . get ( ) ; try { VAR_1 . METHOD_3 ( TYPE_3 . METHOD_4 ( buf ) , object ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING_1 , e ) ; } } buf = null ; } return object ; } 
private void METHOD_1 ( final List < TYPE_1 > VAR_1 , final TYPE_2 VAR_2 ) throws IOException { final String VAR_3 = VAR_2 . METHOD_2 ( ) ; String VAR_4 = VAR_2 . METHOD_3 ( ) ; <START> if ( VAR_4 == null ) VAR_4 = VAR_3 ; <END> final boolean VAR_5 = VAR_2 . METHOD_4 ( ) ; VAR_1 . add ( new TYPE_1 ( db , VAR_3 , VAR_4 , VAR_5 , null , null ) ) ; } 
<START> public TYPE_3 ( <END> Collection < ? extends TYPE_1 < TYPE_2 > > that ) { super ( that ) ; } 
<START> public TYPE_3 ( TYPE_1 < TYPE_2 > ... that ) { <END> super ( that ) ; } 
private void METHOD_1 ( Map map , TYPE_1 VAR_1 , TYPE_2 info , Boolean VAR_2 ) { <START> if ( VAR_2 != null ) { <END> if ( VAR_2 . METHOD_2 ( ) != VAR_1 . METHOD_3 ( ) ) { return ; } } map . put ( VAR_1 . getId ( ) , info ) ; } 
public void run ( ) { try { final TYPE_1 db = VAR_1 . METHOD_1 ( ) ; try { for ( final TYPE_2 project : db . VAR_2 ( ) . METHOD_2 ( ) ) { <START> if ( ! project . VAR_3 ( ) . equals ( VAR_4 . METHOD_3 ( ) ) ) { <END> VAR_5 . METHOD_4 ( project . VAR_3 ( ) , VAR_6 ) ; } } } finally { db . close ( ) ; } } catch ( TYPE_3 e ) { log . error ( STRING_1 , e ) ; } } 
private Collection < TYPE_1 > METHOD_1 ( ) { <START> final TYPE_2 s = VAR_1 . get ( VAR_2 . METHOD_2 ( ) ) ; <END> return s != null ? s . VAR_3 ( ) : TYPE_3 < TYPE_1 > METHOD_3 ( ) ; } 
private void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( TYPE_5 . TYPE_6 . METHOD_2 ( ) ) ; VAR_1 . METHOD_3 ( false ) ; VAR_1 . METHOD_4 ( new TYPE_3 ( ) { @Override public void METHOD_5 ( final TYPE_4 event ) { <START> METHOD_6 ( false ) ; <END> METHOD_7 ( ) ; } } ) ; } 
<START> public String METHOD_1 ( ) { <END> return VAR_1 ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { TYPE_2 . add ( new TYPE_3 ( ) { public void execute ( ) { String VAR_2 = VAR_3 . get ( VAR_1 ) ; <START> VAR_2 = VAR_2 == null ? "" : VAR_2 ; <END> if ( ! VAR_2 . equals ( VAR_1 . METHOD_2 ( ) ) ) { VAR_4 . METHOD_3 ( true ) ; } } } ) ; } 
private void METHOD_1 ( final TYPE_2 . TYPE_3 VAR_1 ) { if ( VAR_2 != null ) { for ( int i = 0 ; i < VAR_2 . METHOD_2 ( ) ; i ++ ) { if ( VAR_1 . name ( ) . equals ( VAR_2 . getValue ( i ) ) ) { <START> VAR_2 . METHOD_3 ( i ) ; <END> return ; } } VAR_2 . METHOD_3 ( - 1 ) ; METHOD_4 ( ) ; } } 
<START> public void METHOD_1 ( final TYPE_2 . TYPE_3 VAR_1 ) { <END> VAR_2 . setText ( VAR_1 . get ( ) ) ; } 
private void METHOD_1 ( final TYPE_1 config ) throws TYPE_2 , TYPE_3 { final TYPE_4 VAR_1 ; if ( VAR_2 != null ) { final TYPE_5 VAR_3 = VAR_4 . get ( VAR_2 ) ; if ( VAR_3 == null ) { throw new TYPE_3 ( VAR_2 ) ; } VAR_1 = VAR_3 . METHOD_2 ( ) ; } else { <START> VAR_1 = null ; <END> } VAR_5 . create ( Collections . VAR_6 ( config . VAR_7 ( ) ) , VAR_1 ) . METHOD_3 ( ) ; config . VAR_7 ( ) . METHOD_4 ( VAR_2 ) ; } 
private void METHOD_1 ( ) throws IOException , TYPE_1 { project = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; try { repo = VAR_2 . METHOD_4 ( project . VAR_3 ( ) ) ; } catch ( TYPE_2 e ) { <START> final String name = project . getName ( ) ; <END> throw new TYPE_1 ( 1 , STRING_1 + name + STRING_2 , e ) ; } try { METHOD_5 ( ) ; } finally { repo . close ( ) ; } } 
public Set < TYPE_2 . TYPE_3 > METHOD_1 ( ) { if ( VAR_1 == null ) { <START> Set < TYPE_2 . TYPE_3 > VAR_2 = new HashSet < TYPE_2 . TYPE_3 > ( ) ; <END> if ( VAR_3 . METHOD_2 ( state ( ) . METHOD_3 ( ) ) ) { VAR_2 = VAR_4 . METHOD_4 ( state ( ) ) ; } else { VAR_2 = VAR_3 . METHOD_5 ( ) ; } VAR_1 = METHOD_6 ( VAR_2 ) ; } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . remove ( 0 ) ; <END> switch ( VAR_1 ) { case VAR_3 : VAR_2 . add ( new TYPE_2 ( ) ) ; break ; case VAR_4 : VAR_2 . add ( VAR_5 ) ; break ; case VAR_6 : VAR_2 . add ( VAR_7 ) ; break ; case VAR_8 : VAR_2 . add ( VAR_9 ) ; break ; case VAR_10 : VAR_2 . add ( VAR_11 ) ; break ; } } 
private String METHOD_1 ( ) { if ( VAR_1 != null ) { if ( VAR_1 . METHOD_2 ( ) != null ) { return VAR_1 . METHOD_2 ( ) ; <START> } else { <END> return VAR_1 . METHOD_3 ( ) . toString ( ) ; } } else { return VAR_2 . getName ( ) ; } } 
<START> public static boolean METHOD_1 ( final TYPE_4 . TYPE_7 VAR_1 ) { <END> if ( TYPE_4 . TYPE_6 . equals ( VAR_1 ) || TYPE_4 . TYPE_5 . equals ( VAR_1 ) ) { return false ; } return true ; } 
<START> public TYPE_1 ( ) { <END> super ( TYPE_2 . this . VAR_3 , TYPE_2 . VAR_4 . VAR_5 ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return TYPE_2 . METHOD_2 ( METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; <END> } 
<START> protected TYPE_1 commit ( final TYPE_2 m , final TYPE_3 VAR_1 ) <END> throws IOException , TYPE_4 { TYPE_5 VAR_2 = m . VAR_3 ( ) ; try { TYPE_1 id = VAR_2 . METHOD_1 ( VAR_1 ) ; VAR_2 . METHOD_2 ( ) ; return id ; } finally { VAR_2 . METHOD_3 ( ) ; } } 
public TYPE_4 ( TYPE_1 config , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { this . VAR_3 = VAR_3 ; <START> String s = config . getString ( STRING_1 , null , STRING_2 ) ; <END> VAR_4 = VAR_2 . METHOD_1 ( config . getString ( STRING_1 , null , STRING_2 ) ) ; } 
<START> TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 n ) { <END> VAR_3 = VAR_2 ; VAR_4 = n ; } 
<START> TYPE_3 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 , TYPE_1 VAR_4 , TYPE_2 n ) { <END> super ( VAR_2 , VAR_3 , VAR_4 , n ) ; } 
<START> TYPE_3 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 , TYPE_1 VAR_4 , TYPE_1 VAR_5 , TYPE_2 n ) { <END> VAR_6 = VAR_2 ; VAR_7 = VAR_3 ; VAR_8 = VAR_4 ; VAR_9 = VAR_5 ; VAR_10 = n ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> this . VAR_1 = VAR_1 ; <END> } 
public static String METHOD_1 ( final TYPE_1 . Status status ) { if ( status == null ) { return "" ; } switch ( status ) { case VAR_1 : return TYPE_2 . METHOD_2 ( ) ; case VAR_2 : return TYPE_2 . METHOD_3 ( ) ; case VAR_3 : return TYPE_2 . METHOD_4 ( ) ; case VAR_4 : return TYPE_2 . METHOD_5 ( ) ; <START> case VAR_5 : <END> return TYPE_2 . METHOD_6 ( ) ; default : return status . name ( ) ; } } 
<START> public List < TYPE_1 > METHOD_1 ( TYPE_2 < TYPE_3 > db ) <END> throws TYPE_4 { if ( VAR_1 == null ) { VAR_1 = db . get ( ) . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) . METHOD_4 ( ) ; } return VAR_1 ; } 
private boolean METHOD_1 ( TYPE_1 req , TYPE_2 VAR_1 ) throws IOException { <START> if ( ! VAR_2 . METHOD_2 ( ) ) <END> return true ; final String VAR_3 = req . VAR_4 ( ) ; final TYPE_3 VAR_5 = VAR_6 . METHOD_3 ( VAR_3 ) ; if ( VAR_5 == null || ! VAR_5 . METHOD_4 ( ) . METHOD_5 ( ) ) { VAR_1 . METHOD_6 ( VAR_7 ) ; return false ; } session . get ( ) . METHOD_7 ( VAR_5 . METHOD_4 ( ) . getId ( ) ) ; return true ; } 
private static boolean METHOD_1 ( String VAR_1 ) { <START> return VAR_1 . METHOD_2 ( STRING_1 ) && ! VAR_1 . METHOD_2 ( STRING_2 ) ; <END> } 
public int METHOD_1 ( ) { int VAR_1 = 0 ; if ( VAR_2 != null ) { VAR_1 = VAR_1 * INT_1 + VAR_2 . METHOD_1 ( ) ; } VAR_1 = VAR_1 * INT_1 + VAR_3 . METHOD_1 ( ) ; VAR_1 = VAR_1 * INT_1 + VAR_4 . name ( ) . METHOD_1 ( ) ; <START> VAR_1 = VAR_1 * INT_1 + VAR_5 . METHOD_1 ( ) ; <END> return VAR_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 c , TYPE_3 VAR_1 ) { TYPE_1 d = METHOD_2 ( c , VAR_1 ) ; <START> d . VAR_2 = new Boolean ( c . VAR_3 ( ) . equals ( VAR_1 . getId ( ) ) ) ; <END> return d ; } 
private Collection < File > METHOD_1 ( ) throws IOException { <START> if ( VAR_1 == null || ! VAR_1 . exists ( ) ) <END> return Collections . VAR_2 ( ) ; return TYPE_1 . METHOD_2 ( VAR_1 , new String [ ] { STRING_1 } , false ) ; } 
<START> public void METHOD_1 ( Status VAR_1 ) { <END> this . status = VAR_1 ; } 
} catch ( Exception e ) { LOG . error ( STRING_1 ) ; <START> VAR_1 = null ; <END> } 
public static String METHOD_1 ( final String VAR_1 ) { <START> String user = TYPE_1 . METHOD_2 ( VAR_1 ) . METHOD_3 ( STRING_1 , STRING_2 ) ; <END> return STRING_3 + user + STRING_4 + VAR_2 ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 == null ) { TYPE_1 VAR_2 = VAR_3 . get ( group . VAR_4 ( ) ) ; <START> TYPE_1 . TYPE_3 VAR_5 = VAR_2 != null ? VAR_2 . METHOD_2 ( ) : null ; <END> VAR_1 = METHOD_3 ( ) . METHOD_4 ( ) . contains ( VAR_5 ) || METHOD_3 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ; } return VAR_1 ; } 
public static TYPE_1 METHOD_1 ( ) { return new TYPE_2 ( ) { @Override protected void METHOD_2 ( ) { cache ( VAR_1 , TYPE_7 . TYPE_8 . class , new TYPE_4 < List < TYPE_5 > > ( ) { } ) . METHOD_3 ( INT_1 ) <START> . METHOD_4 ( INT_2 , TimeUnit . VAR_2 ) <END> . METHOD_5 ( TYPE_6 . class ) ; } } ; } 
private TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 , IOException { String VAR_3 = VAR_1 != null ? VAR_1 : "" ; <START> if ( ! VAR_3 . METHOD_2 ( STRING_1 ) ) { <END> VAR_3 = VAR_3 + STRING_1 ; } return VAR_2 . METHOD_3 ( Constants . VAR_4 , VAR_3 . METHOD_4 ( STRING_2 ) ) ; } 
<START> TYPE_1 ( boolean VAR_2 , String VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , final String token ) { TYPE_5 . TYPE_6 . METHOD_2 ( VAR_2 , VAR_1 , false , token , new TYPE_3 < TYPE_4 > ( ) { public void METHOD_3 ( final TYPE_4 result ) { METHOD_4 ( result ) ; } @Override public void METHOD_5 ( final Throwable VAR_3 ) { <START> super . METHOD_5 ( VAR_3 ) ; <END> } } ) ; } 
TYPE_6 ( TYPE_1 < TYPE_2 > session , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) <START> throws TYPE_5 { <END> this . session = session ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . get ( ) ; if ( VAR_1 . METHOD_2 ( ) . equals ( METHOD_3 ( VAR_1 ) ) ) { <START> return VAR_2 instanceof TYPE_3 && VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ; <END> } return true ; } 
static String METHOD_1 ( String VAR_1 ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { VAR_1 = STRING_1 ; <START> <END> } else if ( VAR_1 . contains ( STRING_2 ) && ! VAR_1 . startsWith ( STRING_3 ) ) { VAR_1 = STRING_3 + VAR_1 + STRING_4 ; } return VAR_1 ; } 
protected Class < ? > METHOD_1 ( final String VAR_1 ) throws TYPE_1 { final Set < TYPE_2 > VAR_2 = VAR_3 . get ( METHOD_2 ( VAR_1 ) ) ; <START> if ( VAR_2 != null ) { <END> for ( final TYPE_2 VAR_4 : VAR_2 ) { try { return Class . VAR_5 ( VAR_1 , true , VAR_4 ) ; } catch ( TYPE_1 e ) { } } } throw new TYPE_1 ( VAR_1 ) ; } 
private void METHOD_1 ( ) throws Exception { <START> Collection < ? extends TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_3 . run ( ) ; } } 
public int METHOD_1 ( ) { int VAR_1 = 0 ; VAR_1 = VAR_1 * INT_1 + VAR_2 . METHOD_1 ( ) ; VAR_1 = VAR_1 * INT_1 + VAR_3 . METHOD_1 ( ) ; <START> VAR_1 = VAR_1 * INT_1 + VAR_4 . METHOD_1 ( ) ; <END> return VAR_1 ; } 
public boolean equals ( final Object o ) { if ( o instanceof TYPE_1 ) { final TYPE_1 VAR_1 = ( TYPE_1 ) o ; return VAR_2 . equals ( VAR_1 . VAR_2 ) && VAR_3 . equals ( VAR_1 . VAR_3 ) <START> && VAR_4 . equals ( VAR_1 . VAR_4 ) ; <END> } return false ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; VAR_1 = null ; VAR_2 = null ; VAR_3 = null ; VAR_4 = null ; if ( VAR_5 != null ) { try { <START> TYPE_1 . METHOD_2 ( VAR_5 , TYPE_1 . VAR_6 ) ; <END> } catch ( IOException e ) { } } } } 
public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) ; } catch ( InterruptedException e ) { <START> log . error ( STRING_1 ) ; ; <END> } } 
public void start ( ) { VAR_1 . start ( ) ; if ( VAR_2 . METHOD_1 ( ) == TYPE_3 . TYPE_4 . VAR_5 && VAR_1 . VAR_6 ) { TYPE_1 state = <START> new TYPE_1 ( TYPE_2 . VAR_8 ) ; <END> VAR_9 . set ( VAR_10 . create ( null , state ) . METHOD_2 ( INT_1 , TimeUnit . VAR_11 ) ) ; } } 
<START> public TYPE_2 ( TYPE_1 type ) { <END> this ( null , type ) ; } 
public boolean METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> try { if ( VAR_2 == 0 ) { return false ; } } finally { VAR_1 . METHOD_3 ( ) ; } return true ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 val ) { <START> if ( VAR_1 != null ) { <END> for ( int i = 0 ; i < VAR_1 . METHOD_2 ( ) ; i ++ ) { if ( val . name ( ) . equals ( VAR_1 . getValue ( i ) ) ) { VAR_1 . METHOD_3 ( i ) ; break ; } } } } 
public TYPE_1 METHOD_1 ( String VAR_1 , String entity , TYPE_2 err ) { switch ( err . VAR_2 ( ) ) { <START> case 1 : <END> case INT_1 : return new TYPE_3 ( entity , err ) ; default : return super . METHOD_1 ( VAR_1 , entity , err ) ; } } 
public void start ( TYPE_1 VAR_1 ) throws Exception { <START> VAR_2 = new TYPE_2 ( ) ; <END> String VAR_3 = METHOD_1 ( ) . getName ( ) ; VAR_4 = TYPE_3 . METHOD_2 ( new TYPE_4 ( getName ( ) , VAR_3 ) ) ; VAR_2 . add ( VAR_4 ) ; VAR_2 . start ( ) ; } 
<START> public TYPE_1 ( String <END> VAR_2 , String VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public boolean METHOD_1 ( String VAR_1 , TYPE_1 key , TYPE_2 session ) { final TYPE_3 VAR_2 = session . VAR_3 ( TYPE_3 . VAR_4 ) ; TYPE_4 VAR_5 = new TYPE_4 ( VAR_1 , VAR_2 . METHOD_2 ( ) ) ; <START> VAR_5 . METHOD_3 ( key ) ; <END> return METHOD_1 ( VAR_2 , VAR_5 , session ) ; } 
<START> public TYPE_2 ( String VAR_2 , TYPE_1 VAR_3 ) { <END> this ( VAR_2 , null , VAR_3 ) ; } 
public List < TYPE_2 . TYPE_3 > METHOD_1 ( ) { TYPE_2 . TYPE_3 update = new TYPE_2 . TYPE_3 ( ) { public String METHOD_2 ( ) { return VAR_1 ; } <START> @Override <END> public String METHOD_3 ( ) { return VAR_2 ; } @Override public String METHOD_4 ( ) { return VAR_3 ; } } ; return ImmutableList . of ( update ) ; } 
public void METHOD_1 ( TYPE_5 . TYPE_6 project , String VAR_1 , TYPE_2 VAR_2 , TYPE_2 VAR_3 ) { <START> TYPE_2 VAR_4 = VAR_2 != null ? VAR_2 : TYPE_2 . METHOD_2 ( ) ; <END> TYPE_3 event = new TYPE_3 ( project , VAR_1 , VAR_4 . name ( ) , VAR_3 . name ( ) ) ; for ( TYPE_4 VAR_5 : VAR_6 ) { VAR_5 . METHOD_3 ( event ) ; } } 
<START> static void METHOD_1 ( TYPE_1 res , int VAR_1 , <END> String msg ) throws IOException { res . VAR_2 ( VAR_1 ) ; TYPE_2 . METHOD_2 ( res ) ; METHOD_3 ( null , res , msg ) ; } 
public static < T > TYPE_1 < T > bind ( TYPE_2 binder , TYPE_3 < T > type ) { <START> return binder . bind ( type ) . METHOD_1 ( TYPE_4 . create ( ) ) ; <END> } 
public static void METHOD_1 ( TYPE_9 . TYPE_10 VAR_1 , Set < TYPE_7 . TYPE_8 > VAR_2 , TYPE_3 < TYPE_4 > VAR_3 ) { TYPE_5 call = new TYPE_5 ( METHOD_2 ( VAR_1 ) ) ; TYPE_6 input = TYPE_6 . create ( ) ; for ( TYPE_7 . TYPE_8 id : VAR_2 ) { <START> input . VAR_4 ( Integer . toString ( id . get ( ) ) ) ; <END> } call . data ( input ) . METHOD_3 ( VAR_3 ) ; } 
private Map < TYPE_7 . TYPE_8 , TYPE_2 > METHOD_1 ( final TYPE_9 . TYPE_8 VAR_1 ) throws TYPE_4 , TYPE_5 { final Map < TYPE_7 . TYPE_8 , TYPE_2 > VAR_2 = TYPE_6 . METHOD_2 ( ) ; final List < TYPE_2 > VAR_3 = <START> db . VAR_4 ( ) . METHOD_3 ( VAR_1 ) . METHOD_4 ( ) ; <END> for ( final TYPE_2 m : VAR_3 ) { VAR_2 . put ( m . VAR_5 ( ) , m ) ; } return VAR_2 ; } 
public String METHOD_1 ( ) { String uri = VAR_1 + VAR_2 + path ; <START> if ( ! parameters . isEmpty ( ) ) { <END> uri += STRING_1 + TYPE_1 . METHOD_2 ( parameters ) ; } return uri ; } 
public synchronized TYPE_1 METHOD_1 ( ) { METHOD_2 ( writer == null , STRING_1 ) ; if ( outputStream == null ) { <START> final TYPE_2 VAR_1 = new TYPE_2 ( VAR_2 ) ; <END> outputStream = new TYPE_1 ( ) { @Override public void write ( int c ) throws IOException { VAR_1 . write ( c ) ; VAR_1 . METHOD_3 ( ) ; } } ; } return outputStream ; } 
public void METHOD_1 ( String [ ] VAR_1 ) { <START> VAR_2 = new ArrayList < TYPE_1 > ( ) ; <END> for ( String n : VAR_1 ) VAR_2 . add ( new TYPE_1 ( n ) ) ; } 
public Object apply ( TYPE_1 resource , TYPE_7 . TYPE_8 input ) throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 { <START> return Response . VAR_1 ( ) ; <END> } 
private String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , String VAR_4 ) { <START> String name = METHOD_2 ( VAR_3 ) ; <END> return METHOD_3 ( VAR_1 ) + STRING_1 + VAR_4 + STRING_2 + name + STRING_3 ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { String name = VAR_2 ; <START> if ( VAR_1 != null && VAR_1 . name != null ) { <END> name = VAR_1 . name ; } return name ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> TYPE_6 . TYPE_7 . VAR_1 . VAR_2 . TYPE_10 < TYPE_2 > VAR_4 = <END> new TYPE_3 < TYPE_2 > ( this ) { @Override protected void METHOD_2 ( final TYPE_2 result ) { VAR_5 . METHOD_3 ( true ) ; METHOD_4 ( result ) ; } @Override protected void METHOD_5 ( ) { message . VAR_6 ( true ) ; } } ; TYPE_4 VAR_7 = new TYPE_4 ( ) ; TYPE_8 . TYPE_9 . METHOD_6 ( VAR_8 , VAR_7 . add ( VAR_4 ) ) ; } 
public Object apply ( TYPE_1 VAR_1 ) throws TYPE_2 , <START> TYPE_3 { <END> return VAR_2 . format ( VAR_1 ) ; } 
private void METHOD_1 ( Map < String , TYPE_1 > VAR_1 , TYPE_1 type ) { TYPE_1 VAR_2 = VAR_1 . get ( type . getName ( ) ) ; <START> if ( VAR_2 == null || ! VAR_2 . METHOD_2 ( ) ) { <END> VAR_1 . put ( type . getName ( ) , type ) ; } } 
public void METHOD_1 ( String VAR_1 ) { if ( VAR_2 == null ) { VAR_2 = new HashSet < String > ( ) ; } VAR_2 . add ( VAR_1 ) ; <START> VAR_3 = 1 ; <END> } 
public static TYPE_1 METHOD_1 ( String name ) { METHOD_2 ( name ) ; List < TYPE_2 > values = new ArrayList < TYPE_2 > ( 2 ) ; values . add ( new TYPE_2 ( ( short ) 0 , STRING_1 ) ) ; values . add ( new TYPE_2 ( ( short ) 1 , STRING_2 ) ) ; <START> TYPE_1 type = new TYPE_1 ( name , values ) ; <END> return type ; } 
private TYPE_2 ( String name , List < TYPE_1 > values ) { super ( name , values ) ; <START> METHOD_1 ( id . length ( ) <= 4 , STRING_1 , id ) ; <END> } 
boolean METHOD_1 ( TYPE_1 VAR_1 ) { synchronized ( VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) ) { <START> return true ; <END> } if ( VAR_3 . containsKey ( VAR_1 . METHOD_3 ( ) ) ) { return false ; } VAR_4 . remove ( VAR_1 . METHOD_3 ( ) ) ; VAR_3 . put ( VAR_1 . METHOD_3 ( ) , VAR_1 ) ; } return true ; } 
public static TYPE_1 parse ( final String VAR_1 ) { final TYPE_1 r = new TYPE_1 ( ) ; String VAR_2 = VAR_1 ; <START> if ( VAR_2 . METHOD_1 ( STRING_1 ) ) { <END> VAR_2 = VAR_2 . substring ( 0 , VAR_2 . length ( ) - 1 ) ; } r . VAR_3 ( VAR_2 ) ; return r ; } 
public void METHOD_1 ( ) { VAR_1 = VAR_2 ; VAR_3 = true ; VAR_4 = true ; VAR_5 = false ; VAR_6 = false ; VAR_7 = false ; VAR_8 = null ; VAR_9 = null ; VAR_10 = null ; VAR_11 = null ; <START> VAR_12 = true ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = this . VAR_1 ; if ( VAR_1 == null ) { synchronized ( this ) { <START> if ( this . VAR_1 == null ) { <END> VAR_1 = METHOD_2 ( ) ; this . VAR_1 = VAR_1 ; } } } if ( VAR_1 == TYPE_1 . VAR_2 ) { TYPE_2 parent = TYPE_3 . METHOD_3 ( METHOD_4 ( ) , null ) ; return parent != null ? parent . VAR_3 ( ) : null ; } return VAR_1 ; } 
private int METHOD_1 ( TYPE_1 VAR_1 ) { final int VAR_2 ; final String VAR_3 = VAR_1 . toString ( ) ; if ( VAR_3 . equals ( STRING_1 ) ) { <START> VAR_2 = - 1 ; <END> } else if ( VAR_3 . equals ( STRING_2 ) ) { VAR_2 = 0 ; } else { VAR_2 = VAR_1 . METHOD_2 ( ) ; } return VAR_2 ; } 
static TYPE_1 config ( TYPE_4 . TYPE_5 name ) { <START> return TYPE_3 . project ( name ) . view ( STRING_1 ) ; <END> } 
private static String METHOD_1 ( String VAR_1 ) { String host = null ; if ( VAR_1 != null ) { try { host = new TYPE_1 ( VAR_1 ) . METHOD_2 ( ) ; } catch ( TYPE_2 e ) { } } if ( host == null ) { host = TYPE_3 . getInstance ( ) . METHOD_3 ( ) ; } <START> return METHOD_4 ( host ) ; <END> } 
public TYPE_1 apply ( TYPE_2 VAR_1 ) { TYPE_1 info = new TYPE_1 ( ) ; <START> TYPE_3 VAR_2 = VAR_1 . METHOD_1 ( ) ; <END> info . id = VAR_2 . getKey ( ) . get ( ) ; info . VAR_3 = VAR_2 . METHOD_2 ( ) ; info . VAR_4 = VAR_2 . METHOD_3 ( ) ; info . VAR_5 = VAR_2 . METHOD_4 ( ) ; info . VAR_6 = TYPE_4 . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ; info . VAR_7 = VAR_2 . METHOD_7 ( ) ; return info ; } 
private void METHOD_1 ( TYPE_5 . TYPE_6 project , String VAR_1 , String VAR_2 ) throws IOException { TYPE_2 r = VAR_3 . METHOD_2 ( project ) ; try { <START> TYPE_3 VAR_4 = new TYPE_3 ( r ) ; <END> try { TYPE_4 VAR_5 = r . VAR_6 ( VAR_1 ) . METHOD_3 ( ) ; TYPE_4 VAR_7 = r . VAR_6 ( VAR_2 ) . METHOD_3 ( ) ; assertEquals ( VAR_5 , VAR_7 ) ; } finally { VAR_4 . METHOD_4 ( ) ; } } finally { r . close ( ) ; } } 
private boolean METHOD_1 ( ) { int count = VAR_1 . METHOD_2 ( ) ; int VAR_2 = count - 1 ; <START> for ( int i = 0 ; i < count ; i ++ ) { <END> if ( this == VAR_1 . METHOD_3 ( i ) ) { return i == VAR_2 ; } } return false ; } 
public TYPE_1 parse ( TYPE_2 parent , TYPE_3 id ) throws TYPE_4 , Exception { <START> return null ; <END> } 
public TYPE_1 parse ( TYPE_2 VAR_1 , TYPE_3 id ) throws TYPE_4 { <START> if ( ! STRING_1 . equals ( id . get ( ) ) ) { <END> throw new TYPE_4 ( id ) ; } return new TYPE_1 ( ) ; } 
public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( group ) ; if ( VAR_1 != null && VAR_1 . METHOD_3 ( ) ) { <START> return true ; <END> } return user instanceof TYPE_3 || user . VAR_2 ( ) . contains ( group . VAR_3 ( ) ) || METHOD_4 ( ) ; } 
protected void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( binder ( ) , VAR_1 ) ; TYPE_1 . METHOD_2 ( binder ( ) , VAR_2 ) ; <START> TYPE_1 . METHOD_2 ( binder ( ) , TYPE_2 . class ) ; <END> child ( VAR_1 , STRING_1 ) . to ( TYPE_3 . class ) ; } 
public Builder METHOD_1 ( TYPE_1 VAR_1 ) { switch ( type ) { case VAR_2 : case LOG : this . VAR_3 = VAR_1 ; break ; default : METHOD_2 ( VAR_1 == null , STRING_1 , type ) ; <START> this . VAR_3 = VAR_1 ; <END> break ; } return this ; } 
public Builder METHOD_1 ( String path ) { switch ( type ) { case VAR_1 : case VAR_2 : this . path = METHOD_2 ( METHOD_3 ( path ) ) ; break ; case VAR_3 : case VAR_4 : case LOG : this . path = path != null ? METHOD_2 ( path ) : null ; break ; default : METHOD_4 ( path == null , STRING_1 , type ) ; this . path = path ; break ; } <START> return this ; <END> } 
private static String METHOD_1 ( String name ) { <START> if ( name . startsWith ( TYPE_1 . VAR_2 ) ) <END> return TYPE_1 . VAR_2 + name ; return name ; } 
TYPE_4 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 id ) { <START> super ( TYPE_5 . VAR_4 , id . toString ( ) ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_5 = id ; } 
public void METHOD_1 ( ) { TYPE_1 read = VAR_1 . get ( ) ; if ( read != null ) { read . close ( ) ; } for ( TYPE_1 write : VAR_2 ) { if ( write != read ) { <START> read . close ( ) ; <END> } } } 
<START> private boolean METHOD_1 ( List < ? > list ) { <END> return list == null || list . isEmpty ( ) ; } 
<START> private List < TYPE_1 > METHOD_1 ( List < TYPE_1 > list , <END> TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) > 1 ) { list . add ( VAR_1 ) ; } return list ; } 
<START> void METHOD_1 ( boolean VAR_1 ) { <END> if ( VAR_1 || ( VAR_2 . METHOD_2 ( ) == 0 && VAR_3 . METHOD_2 ( ) == 0 ) ) { TYPE_1 . METHOD_3 ( VAR_4 , false ) ; TYPE_1 . METHOD_3 ( VAR_5 , false ) ; } else if ( VAR_6 . METHOD_4 ( ) ) { TYPE_1 . METHOD_3 ( VAR_4 , true ) ; TYPE_1 . METHOD_3 ( VAR_5 , true ) ; } host . VAR_7 ( ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . add ( VAR_1 ) ; table . VAR_3 ( false ) ; <START> VAR_4 . add ( VAR_1 ) ; <END> } 
public TYPE_2 ( TYPE_1 config ) { VAR_2 = config . getString ( STRING_1 , null , STRING_2 ) ; VAR_3 = config . getString ( STRING_3 , null , STRING_4 ) ; VAR_4 = config . getString ( STRING_5 , null , STRING_6 ) ; <START> VAR_5 = config . VAR_6 ( STRING_7 , null , STRING_8 ) ; <END> } 
boolean METHOD_1 ( TYPE_4 . TYPE_7 VAR_1 , boolean VAR_2 ) { if ( TYPE_4 . TYPE_6 . equals ( VAR_1 ) ) { return METHOD_2 ( ) ; } else if ( TYPE_4 . TYPE_5 . equals ( VAR_1 ) && VAR_2 ) { <START> return true ; <END> } else { return user . VAR_3 ( ) . contains ( VAR_1 ) ; } } 
private void METHOD_1 ( TYPE_1 < TYPE_2 > in , boolean VAR_1 ) { if ( VAR_1 && VAR_2 == null ) { VAR_2 = in ; <START> } else if ( VAR_3 == null ) { <END> VAR_3 = in ; } else { TYPE_1 < TYPE_2 > VAR_4 = VAR_1 ? VAR_2 : VAR_3 ; for ( int i = 0 ; i < in . length ( ) ; i ++ ) { VAR_4 . METHOD_2 ( in . get ( i ) ) ; } } } 
protected void METHOD_1 ( ) { METHOD_2 ( STRING_1 ) . METHOD_3 ( TYPE_1 . class ) ; <START> METHOD_2 ( STRING_2 ) . METHOD_3 ( TYPE_1 . class ) ; <END> } 
public Object apply ( TYPE_1 VAR_1 , TYPE_2 input ) throws TYPE_3 , InterruptedException , TYPE_4 { <START> TYPE_5 VAR_2 = VAR_1 . METHOD_1 ( ) . METHOD_2 ( ) ; if ( ! VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) { throw new TYPE_3 ( STRING_1 ) ; } <END> VAR_3 . index ( VAR_1 . METHOD_5 ( ) ) . get ( ) ; return Response . VAR_4 ( ) ; } 
private static < T extends TYPE_1 > T METHOD_1 ( Class < ? > VAR_1 , Class < T > VAR_2 ) { <START> if ( VAR_1 == null ) { return null ; } T VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) ; if ( VAR_3 == null ) { VAR_3 = METHOD_1 ( VAR_1 . METHOD_3 ( ) , VAR_2 ) ; if ( VAR_3 != null ) { return VAR_3 ; } } return VAR_3 ; <END> } 
private void METHOD_1 ( TYPE_1 cmd ) throws TYPE_2 { String VAR_1 = null ; if ( cmd instanceof TYPE_3 ) { VAR_1 = ( ( TYPE_3 ) cmd ) . METHOD_2 ( ) ; } try { TYPE_4 . METHOD_1 ( VAR_2 , VAR_1 , cmd . getClass ( ) ) ; } catch ( TYPE_5 e ) { throw new TYPE_2 ( TYPE_3 . VAR_3 , <START> STRING_1 ) ; <END> } } 
private static TYPE_1 < TYPE_2 > METHOD_1 ( ) { return new TYPE_3 < TYPE_2 > ( ) { public void METHOD_2 ( TYPE_2 result ) { METHOD_3 ( ) ; } public void METHOD_4 ( Throwable err ) { if ( TYPE_4 . METHOD_5 ( err ) ) { new TYPE_4 ( err . getMessage ( ) ) . METHOD_6 ( ) ; METHOD_3 ( ) ; } else { super . METHOD_4 ( err ) ; } } <START> private void METHOD_3 ( ) { TYPE_5 . METHOD_7 ( TYPE_6 . VAR_2 ) ; } <END> } ; } 
void set ( TYPE_1 info , String VAR_1 , <START> TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <END> this . VAR_4 = info . VAR_5 ( ) ; this . info = info ; this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; VAR_6 . METHOD_1 ( VAR_4 ) ; METHOD_2 ( info ) ; } 
private <START> String METHOD_1 ( TYPE_1 <END> options , String VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . create ( ) ; return VAR_2 . METHOD_2 ( new File ( VAR_1 ) , options ) ; } 
public TYPE_1 < ? > index ( TYPE_2 VAR_1 ) { <START> return VAR_2 . METHOD_1 ( METHOD_2 ( VAR_1 ) ) ; <END> } 
<START> String METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> void METHOD_1 ( int VAR_1 ) { <END> if ( VAR_2 == 0 ) { return ; } TYPE_1 event = new TYPE_1 ( VAR_3 , VAR_4 , VAR_2 ) ; METHOD_2 ( VAR_3 , VAR_4 , event ) ; } 
public static List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { <START> return METHOD_2 ( VAR_1 , false ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 req ) { <START> if ( TYPE_2 . METHOD_2 ( req . VAR_1 ( ) ) ) { return false ; } if ( req . VAR_1 ( ) . startsWith ( VAR_2 ) ) { return true ; } return false ; <END> } 
public void METHOD_1 ( ) throws TYPE_1 , IOException , TYPE_2 { TYPE_6 . TYPE_7 r = METHOD_2 ( ) ; TYPE_4 VAR_1 = VAR_2 . METHOD_3 ( ) . id ( STRING_1 + r . VAR_3 ( ) ) . METHOD_4 ( r . VAR_4 ( ) . name ( ) ) ; VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ; <START> VAR_1 . METHOD_1 ( new TYPE_5 ( ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> assertEquals ( VAR_1 . getId ( ) . get ( ) , ( int ) VAR_2 . VAR_3 ) ; <END> } 
protected void METHOD_1 ( String message , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> assertEquals ( message , VAR_1 . getId ( ) . get ( ) , ( int ) VAR_2 . VAR_3 ) ; <END> } 
<START> public TYPE_3 ( TYPE_1 < TYPE_2 > <END> VAR_2 ) { super ( TYPE_4 . VAR_4 , STRING_1 ) ; this . VAR_2 = VAR_2 ; } 
public boolean METHOD_1 ( TYPE_1 object ) throws TYPE_2 { TYPE_3 c = object . VAR_1 ( VAR_2 ) ; <START> if ( c == null ) { return false ; } return c . VAR_3 ( ) ; <END> } 
<START> public TYPE_2 ( TYPE_1 <END> db ) { this . db = db ; } 
<START> TYPE_1 ( String <END> m , String c , String VAR_2 ) { VAR_3 = c ; message = m ; VAR_4 = VAR_2 ; } 
protected void METHOD_1 ( ) { METHOD_2 ( new TYPE_1 ( ) { @Override protected void METHOD_3 ( ) { <START> factory ( TYPE_7 . TYPE_6 . class ) ; <END> factory ( TYPE_5 . TYPE_6 . class ) ; } } ) ; METHOD_4 ( TYPE_4 . class ) ; } 
public boolean equals ( Object o ) { <START> if ( ! ( o instanceof TYPE_1 ) ) { return false ; } <END> TYPE_1 VAR_1 = ( TYPE_1 ) o ; return TYPE_2 . METHOD_1 ( name , VAR_1 . name ) && value == VAR_1 . value ; } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( new TYPE_1 ( ) { <END> @Override protected void METHOD_1 ( ) { cache ( VAR_1 , TYPE_2 . class , TYPE_3 . class ) . METHOD_3 ( 2 < < INT_1 ) . METHOD_4 ( TYPE_4 . class ) ; } } ) ; } 
private void METHOD_1 ( ) throws TYPE_1 , IOException { VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( VAR_2 ) ) ; for ( TYPE_2 commit : VAR_1 ) { <START> VAR_1 . METHOD_4 ( commit ) ; <END> parse ( commit ) ; } METHOD_5 ( ) ; for ( Collection < TYPE_3 > v : VAR_3 . METHOD_6 ( ) . values ( ) ) { Collections . VAR_4 ( ( List < TYPE_3 > ) v , VAR_5 ) ; } } 
static TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( STRING_1 , null , STRING_2 , true ) ; <START> VAR_1 . METHOD_2 ( STRING_1 , STRING_3 , STRING_4 , true ) ; <END> return new TYPE_1 ( VAR_1 ) ; } 
private void METHOD_1 ( TYPE_4 . TYPE_5 r ) throws Exception { METHOD_2 ( r , 2 ) ; <START> TYPE_2 input = new TYPE_2 ( ) ; input . VAR_1 = true ; <END> METHOD_3 ( r ) . METHOD_4 ( input ) ; TYPE_3 repo = VAR_2 . METHOD_5 ( project ) ; try { assertEquals ( r . VAR_3 ( ) , repo . VAR_4 ( STRING_1 ) . METHOD_6 ( ) ) ; } finally { repo . close ( ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) <= VAR_2 . METHOD_4 ( ) ; <END> } 
protected void run ( ) <START> throws TYPE_1 , TYPE_2 , Exception { <END> VAR_1 . println ( STRING_1 ) ; } 
protected void METHOD_1 ( final String p ) { try { try ( TYPE_1 in = TYPE_2 . class . METHOD_2 ( ) . METHOD_3 ( p ) ) { if ( in != null ) { METHOD_4 ( in , STRING_1 + p ) ; } else { log . error ( STRING_2 + p ) ; } } <START> } catch ( IOException e ) { <END> log . error ( e . getMessage ( ) , e ) ; } } 
<START> private boolean METHOD_1 ( ) { <END> if ( ! VAR_1 . contains ( VAR_2 ) ) { while ( VAR_3 > 0 ) { TYPE_1 c = VAR_4 . get ( VAR_3 ) . commit ( ) ; TYPE_2 b = VAR_4 . get ( VAR_3 ) . METHOD_2 ( ) ; if ( b . get ( 0 ) != null ) { VAR_1 . add ( c . commit ( ) ) ; } VAR_3 -- ; } return true ; } return false ; } 
private static boolean METHOD_1 ( String url ) { <START> String VAR_1 = <END> STRING_1 ; return url . VAR_2 ( VAR_1 ) ; } 
static void METHOD_1 ( final String target , final TYPE_1 req , final TYPE_2 VAR_1 ) throws IOException { final StringBuilder url = new StringBuilder ( ) ; <START> url . append ( TYPE_3 . METHOD_2 ( req . VAR_2 ( ) , STRING_1 ) ) ; <END> url . append ( CHAR_1 ) ; url . append ( CHAR_2 ) ; url . append ( target ) ; VAR_1 . METHOD_3 ( url . toString ( ) ) ; } 
protected void METHOD_1 ( final TYPE_1 req , final TYPE_2 VAR_1 ) throws IOException { final StringBuilder VAR_2 = new StringBuilder ( ) ; <START> VAR_2 . append ( TYPE_3 . METHOD_2 ( VAR_3 . get ( ) , STRING_1 ) ) ; <END> VAR_2 . append ( CHAR_1 ) ; VAR_2 . append ( METHOD_3 ( req ) ) ; TYPE_4 . METHOD_4 ( VAR_1 ) ; VAR_1 . METHOD_5 ( VAR_2 . toString ( ) ) ; } 
public boolean equals ( Object obj ) { if ( obj instanceof TYPE_1 ) { TYPE_1 o = ( TYPE_1 ) obj ; <START> return TYPE_2 . METHOD_1 ( VAR_1 , o . VAR_1 ) ; <END> } return equals ( obj ) ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 db , TYPE_3 VAR_1 , TYPE_8 . TYPE_7 VAR_2 ) throws TYPE_5 { if ( ! VAR_3 . METHOD_2 ( ) ) { return METHOD_3 ( db . VAR_4 ( ) . METHOD_1 ( VAR_2 ) ) ; } TYPE_6 < TYPE_7 , TYPE_1 > VAR_5 = VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; <START> if ( VAR_5 != null ) { <END> return VAR_5 . get ( VAR_2 ) ; } return Collections . VAR_6 ( ) ; } 
public TYPE_1 get ( long VAR_1 , TimeUnit VAR_2 ) throws InterruptedException , TYPE_2 , TYPE_3 { if ( ! METHOD_1 ( ) ) { if <START> ( VAR_3 . METHOD_2 ( VAR_4 , <END> ( int ) TYPE_4 . METHOD_3 ( VAR_1 , VAR_2 ) ) ) { set ( null ) ; } } return super . get ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( ) throws IOException { if ( METHOD_2 ( ) ) { if ( ! METHOD_3 ( ) ) { <START> VAR_1 . remove ( this ) ; <END> set ( null ) ; } } } 
public void METHOD_1 ( List < String > VAR_1 ) throws TYPE_1 { TYPE_2 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 != null ) { <START> VAR_3 . put ( Integer . valueOf ( VAR_2 . METHOD_3 ( ) ) , <END> ImmutableList . VAR_4 ( VAR_1 ) ) ; } } 
<START> public <END> TYPE_3 ( TYPE_1 < TYPE_2 > VAR_2 ) { this . VAR_3 = VAR_2 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 commit ) throws IOException { <START> METHOD_2 ( commit . VAR_2 ( ) == 1 ) ; <END> TYPE_3 VAR_3 = commit . VAR_4 ( 0 ) ; TYPE_4 VAR_5 = new TYPE_4 ( TYPE_5 . toString ( VAR_3 . getId ( ) ) ) ; try { return TYPE_6 . METHOD_3 ( db . get ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_5 ) . METHOD_6 ( ) ) ; } catch ( TYPE_7 e ) { throw new IOException ( e ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , <START> TYPE_4 VAR_3 , TYPE_4 <END> VAR_4 , TYPE_1 VAR_5 ) throws IOException { TYPE_5 builder = new TYPE_5 ( ) ; builder . VAR_6 ( VAR_5 ) ; builder . VAR_7 ( VAR_4 ) ; builder . VAR_8 ( VAR_3 . METHOD_2 ( ) ) ; builder . VAR_9 ( METHOD_3 ( VAR_1 ) ) ; builder . VAR_10 ( VAR_3 . METHOD_4 ( ) ) ; TYPE_1 VAR_11 = VAR_2 . METHOD_5 ( builder ) ; VAR_2 . METHOD_6 ( ) ; return VAR_11 ; } 
public TYPE_3 ( ) throws IOException { TYPE_1 VAR_2 = <START> TYPE_2 . class . METHOD_1 ( VAR_3 ) ; <END> if ( VAR_2 != null ) { METHOD_2 ( VAR_2 ) ; } else { log . error ( STRING_1 , VAR_3 ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_3 VAR_2 = <END> VAR_3 . METHOD_2 ( VAR_1 ) ; return VAR_2 . getInstance ( TYPE_1 . class ) ; } 
void METHOD_1 ( TYPE_1 e ) { <START> METHOD_2 ( null ) ; <END> } 
<START> static boolean METHOD_1 ( TYPE_1 req ) { <END> return ! TYPE_2 . METHOD_2 ( req . VAR_1 ( ) ) && req . VAR_1 ( ) . startsWith ( VAR_2 ) ; } 
static public TYPE_1 <START> METHOD_1 ( TYPE_2 <END> project , String VAR_1 , TYPE_4 . TYPE_5 group ) { TYPE_1 VAR_2 = METHOD_2 ( project , group ) ; project . VAR_3 ( TYPE_6 . VAR_5 , true ) . METHOD_3 ( VAR_1 , true ) . add ( VAR_2 ) ; return VAR_2 ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { return VAR_2 > VAR_1 . METHOD_2 ( ) <START> || ( VAR_3 && VAR_4 . VAR_5 . METHOD_3 ( ) > VAR_1 . METHOD_2 ( ) ) ; <END> } 
private static String METHOD_1 ( ) { byte [ ] VAR_1 = new byte [ INT_1 ] ; <START> new TYPE_1 ( ) . METHOD_2 ( VAR_1 ) ; <END> return TYPE_2 . METHOD_3 ( VAR_1 ) ; } 
private String METHOD_1 ( String VAR_1 , String path ) throws TYPE_1 { if ( VAR_1 . METHOD_2 ( STRING_1 ) > 0 ) { return new TYPE_2 ( new TYPE_2 ( VAR_1 ) , path ) . METHOD_3 ( ) ; } else { return VAR_1 + METHOD_4 ( VAR_1 ) + STRING_2 + <START> TYPE_3 . is ( CHAR_1 ) . METHOD_5 ( path ) ; <END> } } 
<START> private long <END> METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { long VAR_3 = - 1 ; try { VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 , VAR_2 , null , VAR_4 , - 1 , TimeUnit . VAR_5 ) ; if ( VAR_3 == - 1 ) { log . info ( TYPE_3 . format ( STRING_1 , VAR_2 , VAR_4 ) ) ; } } catch ( IllegalArgumentException e ) { log . error ( TYPE_3 . format ( STRING_2 , VAR_2 , VAR_4 ) , e ) ; } return VAR_3 ; } 
public void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( true ) ; } <END> } 
<START> public static List < TYPE_1 > METHOD_1 ( TYPE_2 < TYPE_1 > VAR_1 ) { return TYPE_4 . TYPE_5 . METHOD_2 ( VAR_1 ) ; } <END> 
public void METHOD_1 ( TYPE_1 r ) { VAR_1 = <START> VAR_1 == <END> null ? null : new TYPE_2 ( VAR_1 . VAR_2 , VAR_1 . VAR_3 , VAR_1 . VAR_4 , VAR_1 . VAR_5 ) ; } 
public TYPE_1 get ( ) { <START> TYPE_1 VAR_1 = <END> new TYPE_1 ( VAR_2 ) ; return VAR_1 ; } 
<START> private Collection < TYPE_1 > METHOD_1 ( <END> Collection < TYPE_1 > VAR_1 , Collection < TYPE_1 > VAR_2 , String file ) { for ( TYPE_1 c : VAR_2 ) { String VAR_3 = c . getKey ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_3 . equals ( file ) ) { VAR_1 . add ( c ) ; } } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) throws TYPE_2 { try { TYPE_3 r = new TYPE_3 ( in , TYPE_8 . VAR_2 ) ; return TYPE_6 . TYPE_7 . METHOD_2 ( ) . METHOD_3 ( TYPE_5 . toString ( r ) , TYPE_1 . class ) ; } catch <START> ( IOException e ) <END> { throw error ( STRING_1 ) ; } } 
TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 ; <END> } 
<START> protected boolean isEmpty ( ) { <END> return VAR_1 . isEmpty ( ) && VAR_2 . isEmpty ( ) && VAR_3 . isEmpty ( ) && VAR_4 . isEmpty ( ) && status == null && VAR_5 == null && VAR_6 == null ; } 
public static synchronized void METHOD_1 ( ) throws IOException { <START> System . out . println ( STRING_1 ) ; <END> for ( File VAR_1 : VAR_2 ) { System . err . println ( STRING_2 + VAR_1 . METHOD_2 ( ) ) ; METHOD_3 ( VAR_1 ) ; } VAR_2 . clear ( ) ; } 
private List < TYPE_3 . TYPE_5 > METHOD_1 ( String VAR_1 , TYPE_2 < TYPE_3 > VAR_2 ) { List < TYPE_3 . TYPE_5 > VAR_3 = <START> TYPE_4 . METHOD_2 ( ) ; <END> for ( TYPE_3 VAR_4 : VAR_2 ) { if ( VAR_4 . METHOD_3 ( VAR_1 ) ) { VAR_3 . add ( VAR_4 . getKey ( ) ) ; } } return VAR_3 ; } 
<START> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> TYPE_1 p = new TYPE_1 ( ) ; p . name = VAR_1 . getName ( ) ; p . VAR_2 = VAR_1 . METHOD_2 ( ) ; p . VAR_3 = VAR_1 . METHOD_3 ( ) ; p . VAR_4 = VAR_1 . METHOD_4 ( ) ; return p ; } 
<START> private List < TYPE_1 > <END> METHOD_1 ( TYPE_2 < TYPE_1 > VAR_1 , final TYPE_1 . Status status ) throws TYPE_3 { return TYPE_4 . METHOD_2 ( TYPE_5 . filter ( VAR_1 , new TYPE_6 < TYPE_1 > ( ) { @Override public boolean apply ( TYPE_1 input ) { return ( input . getStatus ( ) == status ) ; } } ) ) ; } 
public Collection < TYPE_1 > METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 == null ) { <START> VAR_1 = TYPE_3 . METHOD_2 ( VAR_2 . METHOD_3 ( db , METHOD_4 ( ) ) ) ; <END> } return VAR_1 ; } 
public String METHOD_1 ( String VAR_1 , String path ) throws TYPE_1 { if ( VAR_1 . METHOD_2 ( STRING_1 ) > 0 ) { return new TYPE_2 ( new TYPE_2 ( VAR_1 ) , path ) . METHOD_3 ( ) ; } else { <START> return VAR_1 + ( VAR_1 . METHOD_4 ( STRING_2 ) ? "" : STRING_2 ) <END> + ( path . startsWith ( STRING_2 ) ? path . substring ( 1 ) : path ) ; } } 
<START> private List < TYPE_1 > <END> METHOD_1 ( List < TYPE_1 > VAR_1 ) { Collections . VAR_2 ( VAR_1 , TYPE_3 . TYPE_2 ) ; return VAR_1 ; } 
private static void METHOD_1 ( ) throws TYPE_1 { for ( TYPE_2 < Logger > logger = TYPE_3 . METHOD_2 ( ) ; logger . VAR_1 ( ) ; ) { logger . VAR_2 ( ) . METHOD_3 ( null ) ; } if <START> ( TYPE_4 . METHOD_4 ( System . getProperty ( VAR_3 ) ) ) <END> { TYPE_5 . METHOD_5 ( TYPE_6 . METHOD_6 ( VAR_4 ) ) ; } else { TYPE_5 . METHOD_5 ( new TYPE_7 ( System . getProperty ( VAR_3 ) ) ) ; } } 
private static TYPE_1 METHOD_1 ( String name , int value ) { TYPE_2 VAR_1 = new TYPE_2 ( TYPE_3 . VAR_2 ) ; TYPE_4 builder = new TYPE_4 ( ) ; builder . append ( VAR_1 ) ; <START> TYPE_3 . METHOD_2 ( value , 0 , builder ) ; <END> return new TYPE_1 ( name , VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 event ) { TYPE_4 . TYPE_3 <START> p = <END> new TYPE_3 ( event . VAR_1 ( ) ) ; VAR_2 . METHOD_2 ( p ) ; } 
private boolean METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { for <START> ( final TYPE_1 <END> cmd : VAR_1 ) { if ( cmd . getType ( ) != TYPE_1 . Type . VAR_2 ) return true ; } return false ; } 
private TYPE_4 ( String p , String f , String r ) { project = <START> p != null ? <END> new TYPE_2 . TYPE_3 ( p ) : null ; file = f ; VAR_2 = r ; } 
<START> public TYPE_5 ( TYPE_3 . TYPE_4 <END> project , String r , TYPE_2 VAR_2 ) { this . project = project ; this . resource = r ; this . VAR_2 = VAR_2 ; } 
private TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) { try { ANNOTATION_1 ( STRING_1 ) Class < ? extends TYPE_1 > VAR_3 = ( Class < ? extends TYPE_1 > ) Class . VAR_4 ( VAR_1 ) ; return VAR_2 . getInstance ( VAR_3 ) ; } catch ( TYPE_3 e ) { throw new RuntimeException ( <START> String . format ( STRING_2 ) , e ) ; <END> } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws IOException , TYPE_4 { try { int VAR_3 = VAR_2 . getName ( ) . METHOD_2 ( STRING_1 ) ; String VAR_4 = <START> VAR_2 . getName ( ) . substring ( ++ VAR_3 ) ; <END> return db . get ( ) . METHOD_3 ( ) . get ( new TYPE_1 . TYPE_7 ( VAR_1 . getId ( ) , Integer . valueOf ( VAR_4 ) ) ) ; } catch ( TYPE_6 e ) { throw new IOException ( e ) ; } } 
public <START> Response < TYPE_1 < String > > apply ( TYPE_2 <END> req ) throws TYPE_3 , TYPE_4 , IOException , TYPE_5 { TYPE_6 VAR_1 = req . VAR_2 ( ) ; TYPE_7 VAR_3 = VAR_1 . METHOD_1 ( ) . METHOD_2 ( ) ; Set < String > VAR_4 = VAR_3 . METHOD_3 ( ) ; if ( VAR_4 == null ) { VAR_4 = TYPE_8 . of ( ) ; } return Response . VAR_5 ( new TYPE_1 < String > ( VAR_4 ) ) ; } 
public Set < TYPE_3 . TYPE_4 > METHOD_1 ( ) { Set < TYPE_3 . TYPE_4 > result = new <START> HashSet < TYPE_3 . TYPE_4 > ( ) ; <END> for ( TYPE_2 p : METHOD_2 ( ) ) { result . addAll ( p . VAR_1 ) ; } return result ; } 
void METHOD_1 ( TYPE_1 e ) { String VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> while ( VAR_1 . startsWith ( STRING_1 ) ) { <END> VAR_1 = VAR_1 . substring ( 1 ) ; } if ( ! VAR_1 . isEmpty ( ) ) { METHOD_3 ( VAR_1 ) ; } } 
<START> static public void METHOD_1 ( int <END> value ) { VAR_1 . set ( value ) ; } 
<START> static public void METHOD_1 ( ) <END> { VAR_1 . remove ( ) ; } 
public int METHOD_1 ( TYPE_1 VAR_1 , Boolean v ) { return INT_1 + 2 * ( INT_1 + INT_2 ) + INT_3 + INT_3 + <START> 2 * VAR_1 . VAR_2 . length ( ) <END> + 1 ; } 
<START> public static <END> TYPE_1 METHOD_1 ( TYPE_5 . TYPE_6 id , int VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( null , null , null , null , null , null , null , null , null , null , null , null , null , id ) ; VAR_2 . VAR_3 = new TYPE_3 ( new TYPE_3 . TYPE_6 ( id , VAR_1 ) ) ; return VAR_2 ; } 
private List < TYPE_1 > METHOD_1 ( String err , Exception e ) { if ( VAR_1 ) { if <START> ( err == null ) { <END> log . error ( err ) ; } else { log . error ( err , e ) ; } return METHOD_2 ( ) ; } else { return METHOD_3 ( err ) ; } } 
<START> public void METHOD_1 ( ) throws IOException { VAR_1 = TYPE_1 . parse ( METHOD_2 ( TYPE_1 . VAR_2 ) , this ) ; } <END> 
public boolean METHOD_1 ( TYPE_1 name ) { boolean VAR_1 ; if ( VAR_2 . isEmpty ( ) ) { VAR_1 = true ; } else { VAR_1 = false ; String VAR_3 = name . get ( ) ; for ( String VAR_4 : VAR_2 ) { VAR_1 = METHOD_2 ( VAR_3 , VAR_4 ) ; if ( VAR_1 ) { break ; } } } <START> return VAR_1 ; <END> } 
public TYPE_1 apply ( TYPE_2 VAR_1 ) throws TYPE_3 , IOException , <START> TYPE_4 , TYPE_5 , <END> TYPE_6 { Optional < TYPE_7 > VAR_2 = VAR_3 . METHOD_1 ( VAR_1 . METHOD_2 ( ) ) ; String m = VAR_2 . isPresent ( ) ? VAR_2 . get ( ) . METHOD_3 ( ) . METHOD_4 ( ) : VAR_4 . getMessage ( VAR_1 . METHOD_2 ( ) ) ; return TYPE_1 . create ( m ) . METHOD_5 ( ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 , String VAR_3 ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = METHOD_1 ( VAR_3 ) ; } 
public static TYPE_2 . TYPE_3 METHOD_1 ( String VAR_1 ) { int d = VAR_1 . METHOD_2 ( CHAR_1 ) ; return new TYPE_2 . TYPE_3 ( Integer . parseInt ( VAR_1 . substring ( d + <START> 1 ) , 10 ) ) ; <END> } 
public <START> TYPE_1 METHOD_1 ( TYPE_2 <END> c ) { METHOD_2 ( ) ; VAR_1 = c ; try { METHOD_3 ( ) ; TYPE_1 result = new TYPE_1 ( ) ; result . VAR_2 = VAR_2 ; return result ; } finally { if ( VAR_3 != null ) { VAR_3 . METHOD_4 ( ) ; } if ( repo != null ) { repo . close ( ) ; } } } 
static boolean METHOD_1 ( final int VAR_1 ) { switch ( VAR_1 ) { case CHAR_1 : case CHAR_2 : case CHAR_3 : case CHAR_4 : case CHAR_5 : case CHAR_6 : case CHAR_7 : return false ; default : if <START> ( ( VAR_1 >= CHAR_8 && VAR_1 <= CHAR_9 ) <END> || ( VAR_1 >= CHAR_10 && VAR_1 <= CHAR_11 ) || ( VAR_1 >= CHAR_12 && VAR_1 <= CHAR_13 ) ) { return false ; } else { return true ; } } } 
private static void METHOD_1 ( TYPE_1 req ) throws TYPE_2 { <START> if ( ! STRING_1 . equals ( req . VAR_1 ( ) ) && ! STRING_2 . equals ( req . VAR_1 ( ) ) ) { <END> throw new TYPE_2 ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( 1 ) ) ; String <START> VAR_3 = <END> TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( 2 ) ) ; VAR_1 . METHOD_4 ( new TYPE_3 ( VAR_2 , STRING_1 , VAR_3 ) ) ; VAR_1 . METHOD_5 ( METHOD_6 ( VAR_3 ) ) ; } 
private int METHOD_1 ( ) { <START> if ( ! VAR_1 ) { return Integer . VAR_2 ; } return VAR_3 . get ( ) . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . VAR_5 ) . METHOD_4 ( ) ; <END> } 
void METHOD_1 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 e ) { VAR_1 = TYPE_3 . TYPE_2 . VAR_4 ; METHOD_2 ( ) ; VAR_5 . METHOD_3 ( false ) ; <START> VAR_6 . METHOD_3 ( false ) ; <END> VAR_7 . METHOD_3 ( true ) ; VAR_8 . METHOD_3 ( true ) ; } 
public Object apply ( TYPE_1 VAR_1 ) throws <START> TYPE_2 , TYPE_3 , TYPE_4 , Exception { <END> return Response . VAR_2 ( VAR_3 . get ( ) . format ( VAR_1 ) ) ; } 
public Object apply ( TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 , TYPE_4 , Exception { <START> return Response . VAR_2 ( VAR_3 . format ( VAR_1 ) ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 db , TYPE_6 . TYPE_7 VAR_1 , TYPE_5 . TYPE_8 key ) throws TYPE_4 { boolean VAR_2 = false ; for ( TYPE_5 id : db . VAR_3 ( ) . METHOD_2 ( VAR_1 ) ) { if ( id . getKey ( ) . equals ( key ) ) { <START> VAR_2 = true ; break ; <END> } } return VAR_2 ; } 
public TYPE_1 [ ] METHOD_1 ( ) { return new TYPE_1 [ ] { METHOD_2 ( ) , METHOD_3 ( ) , <START> METHOD_4 ( ) , <END> } ; } 
public void execute ( ) throws TYPE_1 , TYPE_2 { try { METHOD_1 ( ) ; METHOD_2 ( ) ; METHOD_3 ( ) ; VAR_1 . METHOD_4 ( project , <START> VAR_2 ) ; <END> METHOD_5 ( ) ; } catch ( TYPE_1 | TYPE_2 e ) { throw e ; } catch ( Exception e ) { TYPE_3 . METHOD_6 ( e ) ; throw new TYPE_1 ( e ) ; } } 
<START> private int METHOD_1 ( final TYPE_1 VAR_1 ) { <END> long VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 , null , STRING_2 , VAR_3 , TimeUnit . VAR_4 ) ; if ( VAR_2 < 0 ) { return 0 ; } return ( int ) VAR_2 ; } 
public synchronized void METHOD_1 ( TYPE_1 key ) { <START> if ( VAR_1 . containsKey ( key ) ) { <END> TYPE_2 VAR_2 = VAR_1 . get ( key ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( ) < 1 ) { VAR_1 . remove ( key ) ; } } } } 
private TYPE_1 METHOD_1 ( ) { for ( final TYPE_1 VAR_1 : VAR_2 ) <START> if ( METHOD_2 ( VAR_1 ) == Constants . VAR_3 ) <END> return VAR_1 ; return VAR_2 . get ( 0 ) ; } 
protected TYPE_2 ( int VAR_2 , int VAR_3 , int VAR_4 , TYPE_1 VAR_5 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; } 
public TYPE_3 ( TYPE_1 repo , TYPE_2 VAR_2 , boolean VAR_3 ) { this . VAR_2 = VAR_2 ; this . repo = repo ; <START> VAR_4 = VAR_2 . METHOD_1 ( ) ; <END> this . VAR_3 = VAR_3 ; VAR_5 = Constants . VAR_6 + VAR_4 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( null == VAR_1 ) { <END> return ; } for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) if ( VAR_1 . equals ( VAR_2 . get ( i ) . VAR_1 ) ) { VAR_3 . METHOD_2 ( i ) ; break ; } } 
public TYPE_1 METHOD_1 ( String name , String VAR_1 ) { <START> this . VAR_2 = new TYPE_2 ( name , VAR_1 ) ; <END> return this ; } 
public TYPE_1 commit ( ) { <START> return ( new TYPE_1 ( this ) ) ; <END> } 
public TYPE_1 log ( ) { <START> return ( new TYPE_1 ( this ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return ( repo ) ; <END> } 
public void execute ( TYPE_1 action ) { <START> TYPE_2 view = TYPE_3 . METHOD_1 ( TYPE_4 . METHOD_2 ( ) , METHOD_3 ( ) [ 0 ] , null ) ; <END> TYPE_5 page = view . VAR_1 ( ) ; if ( page instanceof TYPE_6 ) { TYPE_6 VAR_2 = ( TYPE_6 ) page ; VAR_2 . METHOD_4 ( true ) ; } } 
private void METHOD_1 ( File f ) { File VAR_1 = f . VAR_2 ( ) ; while ( ! VAR_1 . equals ( repo . VAR_3 ( ) ) ) { <START> if ( VAR_1 . list ( ) . length == 0 ) <END> VAR_1 . METHOD_2 ( ) ; else break ; VAR_1 = VAR_1 . METHOD_3 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) throws IOException { if ( METHOD_2 ( ) ) <START> throw new IOException ( <END> TYPE_2 . get ( ) . VAR_1 ) ; if ( index == null ) { index = new TYPE_1 ( this ) ; index . read ( ) ; } else { index . VAR_2 ( ) ; } return index ; } 
public boolean METHOD_1 ( ) { boolean VAR_1 = METHOD_2 ( ) . getString ( TYPE_1 . VAR_3 , null , TYPE_1 . VAR_4 ) != null ; if ( VAR_1 ) return METHOD_2 ( ) . METHOD_3 ( TYPE_1 . VAR_3 , TYPE_1 . VAR_4 , false ) ; if ( VAR_5 && VAR_6 == null ) return true ; if ( METHOD_4 ( ) . getName ( ) . equals ( Constants . VAR_7 ) ) return false ; <START> return true ; <END> } 
public void METHOD_1 ( TYPE_1 event ) { <START> if ( event . getType ( ) == TYPE_1 . VAR_1 ) { <END> state = true ; } } 
public boolean METHOD_1 ( String VAR_1 ) { TYPE_1 table = VAR_2 . table ( 0 ) ; int VAR_3 = METHOD_2 ( ) ; for ( int i = 0 ; i < VAR_3 ; i ++ ) { String VAR_4 = table . VAR_5 ( i ) . METHOD_3 ( ) ; <START> if ( VAR_4 . contains ( VAR_1 ) ) { <END> return true ; } } return false ; } 
private String METHOD_1 ( TYPE_1 repo , TYPE_2 VAR_1 ) { String VAR_2 = repo . VAR_3 ( ) . toString ( ) ; if ( ! STRING_1 . equals ( File . VAR_4 ) ) { VAR_2 = VAR_2 . METHOD_2 ( File . VAR_5 , CHAR_1 ) ; } String VAR_6 = VAR_1 . METHOD_3 ( ) . toString ( ) ; VAR_6 = VAR_6 . METHOD_2 ( VAR_2 , "" ) ; <START> if ( VAR_6 . startsWith ( STRING_1 ) ) { <END> VAR_6 = VAR_6 . substring ( 1 ) ; } return VAR_6 ; } 
public void METHOD_1 ( TYPE_1 resource , int VAR_1 ) throws TYPE_2 { <START> if ( ! VAR_2 . METHOD_2 ( resource . VAR_3 ( ) ) . METHOD_3 ( ) ) { <END> VAR_4 . METHOD_4 ( resource , VAR_1 ) ; } } 
protected int METHOD_1 ( final byte [ ] VAR_1 , int VAR_2 , final int VAR_3 ) { int VAR_4 = INT_1 ; for ( ; VAR_2 < VAR_3 ; VAR_2 ++ ) { <START> if ( ! TYPE_1 . METHOD_2 ( VAR_1 [ VAR_2 ] ) ) { <END> VAR_4 = ( VAR_4 < < 5 ) ^ ( VAR_1 [ VAR_2 ] & INT_2 ) ; } } return VAR_4 ; } 
TYPE_3 ( final byte [ ] b , final int offset ) { <START> VAR_2 = TYPE_1 . VAR_4 ; <END> buf = b ; VAR_5 = offset ; VAR_6 = TYPE_2 . VAR_8 ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; VAR_1 = project . project ; if ( ! VAR_2 . exists ( ) ) new TYPE_1 ( VAR_2 ) . create ( ) ; <START> new TYPE_2 ( VAR_1 , VAR_2 ) . execute ( null ) ; <END> VAR_3 = new TYPE_3 ( VAR_2 ) ; VAR_3 . METHOD_2 ( VAR_1 ) ; repo = TYPE_4 . METHOD_3 ( VAR_1 ) . METHOD_4 ( ) ; } 
<START> private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_1 > list ) { <END> TYPE_1 VAR_2 = null ; int VAR_3 = - 1 ; for ( TYPE_1 d : list ) { if ( METHOD_2 ( METHOD_3 ( d ) , METHOD_3 ( VAR_1 ) ) ) { int VAR_4 = TYPE_2 . METHOD_4 ( path ( d ) , path ( VAR_1 ) ) ; if ( VAR_4 > VAR_3 ) { VAR_2 = d ; VAR_3 = VAR_4 ; } } } return VAR_2 ; } 
public void close ( ) throws IOException { try { <START> super . close ( ) ; <END> } finally { is . close ( ) ; } } 
protected void METHOD_1 ( TYPE_1 parent ) { METHOD_2 ( parent , TYPE_2 . VAR_2 , TYPE_2 . VAR_3 , true ) ; <START> METHOD_3 ( VAR_4 ) ; <END> } 
public String getMessage ( ) { <START> return name ; <END> } 
private static int METHOD_1 ( byte [ ] VAR_1 , char VAR_2 , int VAR_3 ) { <START> while ( VAR_3 >= 0 && VAR_1 [ VAR_3 ] == CHAR_1 ) { <END> VAR_3 -- ; } while ( VAR_3 >= 0 && VAR_1 [ VAR_3 ] != VAR_2 ) { VAR_3 -- ; } return VAR_3 ; } 
public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = 1 ; result = VAR_1 * result + VAR_2 . METHOD_1 ( ) ; <START> result = VAR_1 * result + VAR_3 . METHOD_1 ( ) ; <END> result = VAR_1 * result + METHOD_2 ( ) . METHOD_1 ( ) ; return result ; } 
public static int METHOD_1 ( final byte [ ] b , int o , int value ) { if ( value == 0 ) { b [ -- o ] = CHAR_1 ; return o ; } final boolean VAR_1 = value < 0 ; <START> if ( VAR_1 ) { <END> value = - value ; } while ( value != 0 ) { b [ -- o ] = VAR_2 [ value % 10 ] ; value /= 10 ; } if ( VAR_1 ) b [ -- o ] = CHAR_2 ; return o ; } 
public List < TYPE_1 > METHOD_1 ( String VAR_1 , boolean VAR_2 ) { if ( VAR_3 . isEmpty ( ) ) return Collections . VAR_4 ( ) ; for ( int i = VAR_3 . size ( ) - 1 ; i > - 1 ; i -- ) { TYPE_2 VAR_5 = VAR_3 . get ( i ) ; <START> if ( VAR_5 . METHOD_2 ( VAR_1 , VAR_2 ) ) { <END> return VAR_5 . METHOD_1 ( ) ; } } return Collections . VAR_4 ( ) ; } 
public boolean equals ( Object obj ) { <START> if ( obj == null || obj . getClass ( ) != getClass ( ) ) { <END> return false ; } final TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return TYPE_2 . METHOD_1 ( key , VAR_1 . getKey ( ) ) && TYPE_2 . METHOD_1 ( value , VAR_1 . getValue ( ) ) ; } 
public int METHOD_1 ( ) { <START> return key . VAR_1 ( ) ^ value . VAR_1 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 ... VAR_1 ) { METHOD_2 ( ) ; this . VAR_2 . clear ( ) ; <START> for ( TYPE_2 VAR_3 : VAR_1 ) <END> VAR_2 . add ( VAR_3 ) ; return this ; } 
TYPE_2 ( int [ ] VAR_2 ) { VAR_3 = VAR_2 [ 0 ] ; VAR_4 = VAR_2 [ 1 ] ; VAR_5 = VAR_2 [ 2 ] ; VAR_6 = VAR_2 [ 3 ] ; VAR_7 = VAR_2 [ 4 ] ; VAR_8 = VAR_2 [ 5 ] ; VAR_9 = TYPE_1 . METHOD_1 ( VAR_2 [ INT_1 ] ) ; VAR_10 = VAR_2 [ INT_2 ] ; VAR_11 = VAR_2 [ INT_3 ] ; <START> size = VAR_2 [ INT_4 ] + VAR_2 [ 10 ] < < INT_5 ; <END> } 
<START> public TYPE_1 ( ) { <END> } 
public int METHOD_1 ( ) { <START> return VAR_1 [ INT_1 ] ; <END> } 
protected void run ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_2 ( db ) . add ( ) ; VAR_1 . METHOD_1 ( update ) ; <START> for ( String p : VAR_2 ) { <END> VAR_1 . METHOD_2 ( p ) ; } VAR_1 . call ( ) ; } 
<START> public HashSet < String > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public static TYPE_1 METHOD_1 ( ) { <END> return new TYPE_1 ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 == null ) return VAR_2 ; if ( VAR_1 instanceof TYPE_1 ) return ( TYPE_1 ) VAR_1 ; <START> TYPE_1 VAR_3 = ( ( TYPE_3 ) VAR_1 ) . split ( ) ; <END> return VAR_3 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 , TYPE_1 VAR_4 ) { super ( TYPE_2 . format ( <START> TYPE_3 . get ( ) . VAR_5 , VAR_2 . name ( ) , <END> VAR_3 . name ( ) , VAR_4 . name ( ) ) ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { if ( VAR_1 == null ) return VAR_2 ; if ( VAR_1 instanceof TYPE_1 ) return ( TYPE_1 ) VAR_1 ; TYPE_1 VAR_3 = ( ( TYPE_3 ) VAR_1 ) . split ( ) ; <START> VAR_3 . METHOD_2 ( VAR_4 ) ; <END> return VAR_3 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 , TYPE_1 VAR_4 ) { super ( TYPE_2 . format ( TYPE_3 . get ( ) . VAR_5 , <START> VAR_2 , VAR_3 , VAR_4 ) ) ; <END> } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; TYPE_1 VAR_2 = METHOD_2 ( STRING_2 ) ; TYPE_1 result = VAR_3 . METHOD_3 ( VAR_4 , VAR_1 , VAR_2 ) ; assertEquals ( result , VAR_5 ) ; assertEquals ( result . VAR_6 ( ) , VAR_7 . METHOD_4 ( STRING_3 ) ) ; result = VAR_3 . METHOD_3 ( VAR_4 , VAR_2 , VAR_1 ) ; assertEquals ( result , VAR_5 ) ; assertEquals ( result . VAR_6 ( ) , VAR_7 . METHOD_4 ( STRING_4 ) ) ; } 
<START> public List < String > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return data ; } 
<START> public TYPE_3 . TYPE_4 . VAR_1 . TYPE_2 [ ] METHOD_1 ( ) { <END> return null ; } 
private void METHOD_1 ( ) { VAR_1 = new HashMap < String , TYPE_1 > ( ) ; <START> for ( TYPE_1 commit : VAR_2 ) { <END> VAR_1 . put ( commit . getId ( ) . name ( ) , commit ) ; } } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { final String name = VAR_1 . getName ( ) ; <START> if ( name . startsWith ( Constants . VAR_2 ) ) { <END> return name . substring ( Constants . VAR_2 . length ( ) ) ; } else if ( name . startsWith ( Constants . VAR_3 ) ) { return name . substring ( Constants . VAR_3 . length ( ) ) ; } return name ; } 
protected void METHOD_1 ( TYPE_1 configuration ) { configuration . VAR_1 ( TYPE_1 . VAR_2 , VAR_3 ) ; configuration . VAR_1 ( TYPE_4 . VAR_5 , TYPE_3 . VAR_7 ) ; <START> configuration . VAR_8 ( new TYPE_2 ( ) ) ; <END> super . METHOD_1 ( configuration ) ; configuration . VAR_8 ( new TYPE_2 ( ) ) ; } 
private void METHOD_1 ( ) throws IOException { try { repo . VAR_1 ( null ) ; repo . VAR_2 ( null ) ; <START> } catch ( IOException e ) { <END> throw e ; } } 
public final int METHOD_1 ( ) { <START> return VAR_1 == null ? 0 : VAR_1 . length ; <END> } 
private static void METHOD_1 ( final TYPE_1 VAR_1 , final File VAR_2 ) { if ( VAR_2 . METHOD_2 ( ) ) { try { VAR_1 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <START> } catch ( final TYPE_2 e ) { <END> } } } 
public void METHOD_1 ( ) { <START> if ( VAR_1 . METHOD_2 ( ) ) { <END> VAR_1 . METHOD_1 ( ) ; } } 
public void METHOD_1 ( ) { <START> if ( channel . VAR_1 ( ) ) { <END> channel . VAR_2 ( ) ; } } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new TYPE_2 < TYPE_1 > ( ) ; Iterator < TYPE_3 > it = ( ( TYPE_4 ) VAR_2 . METHOD_2 ( ) ) . iterator ( ) ; <START> while ( it . hasNext ( ) ) { <END> VAR_1 . add ( it . next ( ) . METHOD_3 ( ) ) ; } return VAR_1 ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> return null ; } return VAR_1 ; } 
public boolean METHOD_1 ( String msg ) { <START> TYPE_3 . TYPE_4 p = new TYPE_3 . TYPE_4 ( ) ; <END> if ( VAR_1 . get ( uri , p ) ) { VAR_2 = new String ( p . getValue ( ) ) ; return true ; } else { TYPE_3 . TYPE_5 v = METHOD_2 ( msg ) ; if ( VAR_1 . get ( uri , v ) ) { VAR_2 = v . getValue ( ) ; return true ; } else { VAR_2 = null ; return false ; } } } 
public boolean METHOD_1 ( String msg ) { TYPE_3 . TYPE_4 p = new TYPE_3 . TYPE_4 ( msg ) ; if ( VAR_1 . get ( uri , p ) ) { VAR_2 = new String ( p . getValue ( ) ) ; return true ; } else { <START> TYPE_3 . TYPE_5 v = METHOD_2 ( msg ) ; <END> if ( VAR_1 . get ( uri , v ) ) { VAR_2 = v . getValue ( ) ; return true ; } else { VAR_2 = null ; return false ; } } } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) ; <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_4 ( VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( final Object element , final int VAR_1 ) { if ( VAR_1 == 0 ) { final TYPE_2 c = ( TYPE_2 ) element ; switch ( c . VAR_2 ( ) ) { case VAR_3 : return METHOD_2 ( METHOD_3 ( c ) , TYPE_3 . VAR_5 ) ; case VAR_6 : <START> return VAR_6 ; <END> case VAR_7 : return METHOD_2 ( METHOD_3 ( c ) , TYPE_3 . VAR_8 ) ; case VAR_9 : case VAR_10 : return METHOD_3 ( c ) ; } } return null ; } 
public Object execute ( TYPE_1 event ) throws TYPE_2 { TYPE_3 [ ] VAR_1 = METHOD_1 ( event ) ; if ( VAR_1 . length == 0 ) return null ; Set < TYPE_3 > VAR_2 = new HashSet < TYPE_3 > ( ) ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) <START> VAR_2 . add ( VAR_1 [ i ] ) ; <END> new TYPE_4 ( VAR_2 ) . start ( ) ; return null ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) . clear ( ) ; for ( TYPE_2 project : VAR_1 ) { <START> if ( project . exists ( ) ) { <END> project . VAR_2 ( true , true , null ) ; } } for ( File VAR_3 : VAR_4 ) { if ( VAR_3 . exists ( ) ) { TYPE_3 . METHOD_4 ( VAR_3 , TYPE_3 . VAR_5 | TYPE_3 . VAR_6 ) ; } } } 
public static void METHOD_1 ( ) { if ( VAR_1 ) return ; try { VAR_2 . METHOD_2 ( STRING_1 ) . close ( ) ; VAR_1 = true ; } catch ( TYPE_1 e ) { <START> VAR_1 = true ; <END> } } 
public TYPE_1 METHOD_1 ( ) throws IOException , TYPE_2 { if ( METHOD_2 ( ) || METHOD_3 ( ) == null ) throw new TYPE_2 ( ) ; File VAR_1 = new File ( METHOD_3 ( ) , Constants . VAR_2 ) ; byte [ ] VAR_3 ; try { VAR_3 = TYPE_3 . METHOD_4 ( VAR_1 ) ; } catch ( TYPE_4 VAR_4 ) { return null ; } if ( VAR_3 . length == 0 ) return null ; <START> TYPE_1 VAR_5 = TYPE_1 . METHOD_5 ( VAR_3 , 0 ) ; <END> return VAR_5 ; } 
protected void METHOD_1 ( String VAR_1 ) throws Exception { METHOD_2 ( ) ; <START> Thread . VAR_2 ( INT_1 ) ; <END> commit ( VAR_1 ) ; } 
<START> private byte [ ] METHOD_1 ( String VAR_1 ) throws IOException { <END> File file = new File ( METHOD_2 ( ) , VAR_1 ) ; byte [ ] VAR_2 ; try { VAR_2 = TYPE_1 . METHOD_3 ( file ) ; } catch ( TYPE_2 VAR_3 ) { return null ; } if ( VAR_2 . length == 0 ) return null ; return VAR_2 ; } 
public Object METHOD_1 ( Class VAR_1 ) { <START> if ( VAR_1 == TYPE_1 . class ) { <END> return resource ; } return null ; } 
public String toString ( ) { <START> if ( parent != null && parent . VAR_1 ( ) instanceof TYPE_1 ) { <END> return resource . VAR_2 ( ) . toString ( ) ; } return resource . getName ( ) ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 , int VAR_3 ) { <END> commit = VAR_2 ; VAR_4 = VAR_3 ; } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 child ) { TYPE_2 [ ] VAR_1 = child . VAR_2 ( ) ; List < TYPE_1 > result = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { <START> if ( VAR_3 . METHOD_2 ( ) ) { <END> result . addAll ( METHOD_1 ( VAR_3 ) ) ; } else { result . add ( METHOD_3 ( VAR_3 ) ) ; } } return result ; } 
protected void METHOD_1 ( TYPE_1 configuration ) { configuration . VAR_1 ( TYPE_1 . VAR_2 , VAR_3 ) ; String VAR_4 ; if ( TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( <START> TYPE_5 . VAR_6 ) ) { <END> VAR_4 = TYPE_4 . VAR_8 ; } else { VAR_4 = VAR_9 ; } configuration . VAR_1 ( TYPE_6 . VAR_11 , VAR_4 ) ; super . METHOD_1 ( configuration ) ; configuration . VAR_12 ( new TYPE_3 ( ) ) ; } 
private Collection < String > METHOD_1 ( Collection < TYPE_1 > VAR_1 ) throws TYPE_2 { <START> Collection < String > result = new ArrayList < String > ( ) ; <END> for ( TYPE_1 file : VAR_1 ) { TYPE_3 VAR_2 = TYPE_3 . METHOD_2 ( file ) ; if ( VAR_2 == null ) throw new TYPE_2 ( TYPE_4 . error ( TYPE_5 . bind ( TYPE_7 . TYPE_6 , file ) , null ) ) ; String VAR_5 = VAR_2 . METHOD_3 ( file ) ; result . add ( VAR_5 ) ; } return result ; } 
private Object METHOD_1 ( Object VAR_1 , Class c ) { if ( c . VAR_2 ( VAR_1 ) ) { return VAR_1 ; } if ( VAR_1 instanceof TYPE_1 ) { TYPE_1 a = ( TYPE_1 ) VAR_1 ; Object VAR_3 = a . VAR_4 ( c ) ; <START> if ( c . VAR_2 ( VAR_3 ) ) { <END> return VAR_3 ; } } return null ; } 
public void METHOD_1 ( String user , String VAR_1 ) { if ( user != null && VAR_1 != null ) { TYPE_1 VAR_2 = new TYPE_2 ( user , VAR_1 ) ; this . client . VAR_3 ( ) . METHOD_1 ( new TYPE_3 ( VAR_4 . METHOD_2 ( ) , VAR_4 . METHOD_3 ( ) ) , VAR_2 ) ; <START> } <END> } 
public void run ( ) { VAR_1 . METHOD_1 ( VAR_2 , METHOD_2 ( ) ) ; <START> if ( VAR_1 . METHOD_3 ( ) ) { <END> try { VAR_1 . METHOD_4 ( ) ; } catch ( IOException e ) { TYPE_1 . METHOD_5 ( e . getMessage ( ) , e , false ) ; } } } 
List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; TYPE_2 [ ] VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; <START> for ( TYPE_2 VAR_3 : VAR_2 ) { <END> VAR_1 . addAll ( Arrays . asList ( VAR_3 . METHOD_4 ( ) ) ) ; } return VAR_1 ; } 
public static synchronized TYPE_1 METHOD_1 ( ) { <START> if ( instance == null ) { <END> instance = new TYPE_1 ( ) ; } return instance ; } 
private static TYPE_1 [ ] METHOD_1 ( TYPE_2 [ ] VAR_1 ) { List < TYPE_1 > result = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_2 resource : VAR_1 ) { <START> result . add ( METHOD_2 ( resource ) ) ; <END> } return result . VAR_2 ( new TYPE_1 [ result . size ( ) ] ) ; } 
public void execute ( TYPE_1 monitor ) throws TYPE_2 { TYPE_3 VAR_1 ; if ( VAR_2 != null ) { for ( TYPE_4 res : VAR_3 ) { <START> VAR_1 = new TYPE_3 ( METHOD_1 ( res ) ) ; <END> VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) . call ( ) ; } } else { for ( TYPE_4 res : VAR_3 ) { VAR_1 = new TYPE_3 ( METHOD_1 ( res ) ) ; VAR_1 . METHOD_2 ( ) . call ( ) ; } } } 
private static String METHOD_1 ( String input ) { <START> for ( int i = 0 ; i < input . length ( ) ; i ++ ) { <END> if ( input . VAR_1 ( i ) != CHAR_1 ) { return input . substring ( i ) ; } } return "" ; } 
private int METHOD_1 ( int VAR_1 , String message ) { <START> int VAR_2 = message . VAR_3 ( STRING_1 , VAR_1 + 1 ) ; <END> if ( VAR_2 > - 1 ) return VAR_2 ; return message . VAR_3 ( TYPE_1 . VAR_5 , VAR_1 + 1 ) ; } 
public boolean equals ( Object obj ) { <START> if ( obj == null || ! ( obj instanceof TYPE_1 ) ) { <END> return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( path == null ) { return VAR_1 . path == null ; } return path . equals ( VAR_1 . path ) ; } 
public int METHOD_1 ( ) { <START> if ( path != null ) { <END> return path . VAR_1 ( ) ; } return super . METHOD_1 ( ) ; } 
public void METHOD_1 ( TYPE_1 filter ) { super . METHOD_1 ( filter ) ; if ( filter instanceof TYPE_2 ) { TYPE_2 VAR_1 = ( TYPE_2 ) filter ; TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_2 == null ) { <END> VAR_1 . METHOD_3 ( VAR_3 ) ; } } } 
public void METHOD_1 ( final TYPE_1 repo ) throws IOException { for ( TYPE_2 VAR_1 : repo . VAR_2 ( ) . METHOD_2 ( ) ) { Set < TYPE_2 > set = VAR_3 . get ( VAR_1 . METHOD_3 ( ) ) ; <START> if ( set == null ) { <END> set = Collections . VAR_4 ( VAR_1 ) ; } else { set = new HashSet < TYPE_2 > ( set ) ; set . add ( VAR_1 ) ; } VAR_3 . put ( VAR_1 . METHOD_3 ( ) , set ) ; } } 
private void METHOD_1 ( final TYPE_1 uri , Exception e , String VAR_1 ) { <START> if ( uri != null ) <END> VAR_2 . METHOD_2 ( uri , VAR_1 ) ; String VAR_3 ; if ( uri == null ) VAR_3 = STRING_1 ; else VAR_3 = uri . toString ( ) ; String VAR_4 = TYPE_2 . bind ( TYPE_5 . TYPE_4 , VAR_3 , VAR_1 ) ; TYPE_3 . METHOD_3 ( VAR_4 , e ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = new TYPE_2 ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = Constants . VAR_3 + Constants . VAR_4 ; try { TYPE_2 VAR_5 = VAR_1 . METHOD_2 ( Constants . VAR_6 ) ; if ( VAR_5 != null && VAR_5 . METHOD_3 ( ) ) <START> VAR_2 = VAR_5 . METHOD_4 ( ) . getName ( ) ; <END> } catch ( IOException e ) { TYPE_3 . METHOD_5 ( STRING_1 , e ) ; } METHOD_1 ( VAR_1 , VAR_2 ) ; } 
private static int METHOD_1 ( String VAR_1 , int VAR_2 , TYPE_1 VAR_3 ) { <START> if ( VAR_3 != null && VAR_3 == CHAR_1 ) { <END> return VAR_1 . METHOD_2 ( CHAR_2 , VAR_2 ) ; } return METHOD_3 ( VAR_1 , VAR_2 , CHAR_2 ) ; } 
static File METHOD_1 ( final String path , final String ... VAR_1 ) { <START> if ( path == null ) { <END> return null ; } for ( final String p : path . split ( File . VAR_2 ) ) { for ( String command : VAR_1 ) { final File e = new File ( p , command ) ; if ( e . VAR_3 ( ) ) return e . VAR_4 ( ) ; } } return null ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { Iterator VAR_2 = VAR_1 . iterator ( ) ; <START> for ( Object VAR_3 = VAR_2 . next ( ) ; VAR_2 . hasNext ( ) ; VAR_3 = VAR_2 <END> . next ( ) ) { if ( VAR_3 instanceof TYPE_2 ) { TYPE_2 node = ( TYPE_2 ) VAR_3 ; String VAR_4 = node . VAR_5 ( ) . getName ( ) ; if ( ! VAR_4 . startsWith ( Constants . VAR_6 ) ) return false ; } else return false ; } return true ; } 
private static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { TYPE_1 VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) ; <START> if ( VAR_3 == null ) { <END> VAR_3 = VAR_1 . METHOD_3 ( VAR_2 ) ; } return VAR_3 ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; TYPE_2 VAR_3 = cache ; cache = VAR_2 ; if ( VAR_3 != null ) { if ( VAR_3 . VAR_4 != null ) VAR_3 . VAR_4 . METHOD_2 ( ) ; <START> for ( TYPE_3 VAR_5 : VAR_3 . METHOD_3 ( ) ) { <END> VAR_5 . key . VAR_6 . set ( 0 ) ; } } } 
public static void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 monitor ) throws TYPE_3 { List < File > VAR_2 = new ArrayList < File > ( ) ; if ( TYPE_4 . METHOD_2 ( VAR_2 , VAR_1 . METHOD_3 ( ) <START> . METHOD_4 ( ) , null , monitor ) ) <END> for ( File file : VAR_2 ) TYPE_4 . METHOD_5 ( VAR_1 , file , monitor ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 view ) { TYPE_3 VAR_1 = view . VAR_2 ( ) . METHOD_1 ( ) ; <START> if ( VAR_1 instanceof TYPE_1 ) { <END> return ( TYPE_1 ) VAR_1 ; } else return new TYPE_4 ( ) ; } 
private boolean METHOD_1 ( List < String > VAR_1 , List < String > VAR_2 ) { if ( VAR_1 . size ( ) != VAR_2 . size ( ) ) return true ; <START> for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { <END> if ( ! VAR_1 . get ( i ) . equals ( VAR_2 . get ( i ) ) ) return true ; } return false ; } 
<START> boolean METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) != VAR_2 ; } 
public static TYPE_1 METHOD_1 ( List < ? extends TYPE_1 > VAR_1 ) { TYPE_1 [ ] VAR_2 = new TYPE_1 [ VAR_1 . size ( ) ] ; int i = 0 ; for ( TYPE_1 VAR_3 : VAR_1 ) { <START> if ( VAR_3 != TYPE_1 . VAR_4 ) <END> VAR_2 [ i ++ ] = VAR_3 ; } if ( i == 0 ) return TYPE_1 . VAR_4 ; else if ( i == 1 ) return VAR_2 [ 0 ] ; else return new TYPE_2 ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> for ( TYPE_3 VAR_2 : VAR_3 ) { <END> VAR_2 . METHOD_1 ( VAR_1 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , Collection < ? extends TYPE_2 > VAR_2 , int VAR_3 ) throws TYPE_3 { <START> for ( TYPE_4 VAR_4 : VAR_5 ) { <END> VAR_4 . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , Collection < ? extends TYPE_2 > VAR_2 , int VAR_3 , int VAR_4 , boolean VAR_5 ) throws TYPE_3 { <START> for ( TYPE_4 VAR_6 : VAR_7 ) { <END> VAR_6 . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , Collection < ? extends TYPE_2 > VAR_2 , Collection < ? extends TYPE_2 > VAR_3 ) throws TYPE_3 { <START> for ( TYPE_4 VAR_4 : VAR_5 ) { <END> VAR_4 . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; } } 
public static TYPE_1 METHOD_1 ( List < ? extends TYPE_1 > VAR_1 ) { TYPE_1 [ ] VAR_2 = new TYPE_1 [ VAR_1 . size ( ) ] ; int i = 0 ; for ( TYPE_1 logger : VAR_1 ) { <START> if ( logger != TYPE_1 . VAR_3 ) <END> VAR_2 [ i ++ ] = logger ; } if ( i == 0 ) return TYPE_1 . VAR_3 ; else if ( i == 1 ) return VAR_2 [ 0 ] ; else return new TYPE_2 ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 ) { <START> for ( TYPE_2 logger : VAR_2 ) { <END> logger . VAR_3 ( VAR_1 ) ; } } 
private TYPE_1 METHOD_1 ( final Throwable VAR_1 ) { Throwable VAR_2 = VAR_1 ; <START> while ( VAR_2 . METHOD_2 ( ) != null ) { <END> VAR_2 = VAR_2 . METHOD_2 ( ) ; } return new TYPE_1 ( VAR_2 . getMessage ( ) , VAR_2 ) ; } 
private static boolean METHOD_1 ( TYPE_1 config , TYPE_2 url ) throws TYPE_3 { Set < String > VAR_1 = config . VAR_2 ( TYPE_4 . VAR_4 ) ; for ( String VAR_5 : VAR_1 ) { String VAR_6 = config . getString ( TYPE_4 . VAR_4 , VAR_5 , TYPE_4 . VAR_7 ) ; TYPE_2 VAR_8 = new TYPE_2 ( VAR_6 ) ; <START> if ( VAR_8 . equals ( url ) ) { <END> return true ; } } return false ; } 
public static List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( ) ; TYPE_4 [ ] config = VAR_2 . METHOD_3 ( VAR_3 ) ; <START> if ( config . length > 0 ) { <END> METHOD_4 ( VAR_1 , config , 0 ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 == null ) return null ; Object object = VAR_1 . METHOD_2 ( STRING_1 ) ; TYPE_1 VAR_2 = null ; <START> if ( object instanceof TYPE_1 ) { <END> VAR_2 = ( TYPE_1 ) object ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 == null ) return null ; Object object = VAR_1 . METHOD_2 ( STRING_1 ) ; TYPE_1 page = null ; if ( object instanceof TYPE_1 <START> && object instanceof TYPE_3 ) { <END> page = ( TYPE_1 ) object ; } return page ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , Collection < TYPE_2 > VAR_2 ) { <START> for ( TYPE_2 info : VAR_2 ) { <END> VAR_3 . put ( info , VAR_1 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 ) { <START> for ( String VAR_4 : VAR_2 . METHOD_2 ( ) ) { <END> VAR_1 . METHOD_3 ( new TYPE_3 ( VAR_3 , VAR_4 ) ) ; } } 
public void METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; <START> for ( TYPE_1 VAR_2 : VAR_3 ) { <END> VAR_2 . METHOD_1 ( ) ; } } 
private TYPE_1 ( int VAR_2 ) { <START> this . count = 0 ; <END> this . VAR_2 = VAR_2 ; } 
protected void run ( ) throws Exception { <START> if ( list ) { <END> list ( ) ; } else { throw new TYPE_1 ( STRING_1 ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 ) { if ( VAR_2 . equals ( VAR_4 ) ) { if ( VAR_1 == null ) return VAR_3 == null ; <START> return ( VAR_1 . equals ( VAR_3 ) ) ; <END> } return false ; } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> return this ; } 
public static List < TYPE_1 > filter ( List < TYPE_1 > VAR_1 , final TYPE_2 VAR_2 ) { <START> final List < TYPE_1 > r = new ArrayList < TYPE_1 > ( VAR_1 <END> . size ( ) ) ; for ( final TYPE_1 cmd : VAR_1 ) { if ( cmd . VAR_3 ( ) == VAR_2 ) r . add ( cmd ) ; } return r ; } 
public void METHOD_1 ( String VAR_1 , TYPE_1 [ ] VAR_2 ) { if ( VAR_2 . length == 0 ) { <START> return ; <END> } METHOD_2 ( VAR_2 ) ; METHOD_3 ( VAR_1 , VAR_2 ) ; } 
private void METHOD_1 ( TYPE_1 entry , TYPE_2 [ ] VAR_1 ) { for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { METHOD_2 ( entry , VAR_1 [ i ] ) ; } entry . VAR_2 ( ) . METHOD_3 ( Arrays . asList ( VAR_1 ) ) ; <START> if ( entry . VAR_2 ( ) . size ( ) == 0 && entry . VAR_3 . size ( ) == 0 ) { <END> METHOD_4 ( entry ) ; } } 
private void METHOD_1 ( TYPE_1 entry ) { if ( entry . parent == null ) { return ; } Map VAR_1 = new HashMap ( ) ; VAR_1 . METHOD_2 ( entry . parent . VAR_2 ) ; VAR_1 . remove ( entry . path . METHOD_3 ( ) ) ; entry . parent . VAR_2 = VAR_1 ; <START> if ( entry . parent . METHOD_4 ( ) . isEmpty ( ) && entry . VAR_2 . isEmpty ( ) ) { <END> METHOD_1 ( entry . parent ) ; } } 
private void METHOD_1 ( TYPE_1 entry , TYPE_2 VAR_1 ) { Iterator VAR_2 = entry . VAR_3 ( ) ; while ( VAR_2 . hasNext ( ) ) { TYPE_1 child = ( TYPE_1 ) VAR_2 . next ( ) ; METHOD_1 ( child , VAR_1 ) ; child . VAR_4 ( ) . remove ( VAR_1 ) ; <START> if ( child . VAR_4 ( ) . size ( ) == 0 && child . VAR_5 . size ( ) == 0 ) { <END> METHOD_2 ( child ) ; } } } 
public void execute ( TYPE_1 monitor ) throws TYPE_2 , InterruptedException { super . execute ( monitor ) ; if ( VAR_1 . length ( ) == 0 ) { VAR_1 . METHOD_1 ( ) ; METHOD_2 ( ) ; return ; } if ( this . VAR_2 && ( ! VAR_3 && ! VAR_4 && ! VAR_5 ) ) { <START> VAR_1 . METHOD_1 ( ) ; <END> METHOD_2 ( ) ; return ; } METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 ... cmd ) { <START> VAR_1 . addAll ( Arrays . asList ( cmd ) ) ; <END> VAR_2 = false ; return this ; } 
byte [ ] METHOD_1 ( TYPE_1 obj , TYPE_2 VAR_1 ) throws TYPE_3 , TYPE_4 , IOException { try { <START> return VAR_1 . METHOD_1 ( VAR_2 ) ; <END> } catch ( TYPE_3 VAR_3 ) { VAR_3 . METHOD_2 ( obj ) ; throw VAR_3 ; } } 
private String [ ] METHOD_1 ( String VAR_1 , String [ ] VAR_2 ) { int VAR_3 = VAR_2 . length ; String [ ] VAR_4 = new String [ VAR_3 + 1 ] ; System . VAR_5 ( VAR_2 , 0 , VAR_4 , 1 , VAR_3 ) ; <START> VAR_4 [ 0 ] = VAR_1 ; <END> return VAR_4 ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; for ( TYPE_2 VAR_3 : VAR_1 . METHOD_3 ( ) ) { try { Object o = VAR_3 . METHOD_4 ( VAR_4 ) ; <START> VAR_5 = ( TYPE_3 ) o ; <END> } catch ( TYPE_4 e ) { TYPE_5 . log ( e ) ; } } } 
public static int getValue ( String text ) { <START> if ( text == null || text . isEmpty ( ) || text . equals ( STRING_1 ) ) { <END> return VAR_1 ; } if ( text . equals ( STRING_2 ) ) { return VAR_2 ; } throw new IllegalArgumentException ( STRING_3 + text ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { for ( TYPE_1 child : VAR_1 ) { METHOD_2 ( child ) ; } VAR_1 = null ; VAR_2 = 0 ; } if ( VAR_3 != null ) { for ( TYPE_1 VAR_4 : VAR_3 ) { if ( VAR_4 == null ) { break ; } METHOD_2 ( VAR_4 ) ; } METHOD_3 ( ) ; <START> } <END> } 
public static TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( TYPE_3 . class . getName ( ) ) ; VAR_1 . METHOD_2 ( TYPE_4 . class ) ; VAR_1 . METHOD_2 ( TYPE_5 . class ) ; <START> <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( ! VAR_1 . isEmpty ( ) ) <END> return VAR_1 . METHOD_2 ( ) ; return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { TYPE_2 uri ; TYPE_2 VAR_2 = METHOD_2 ( ) ; <START> if ( ! VAR_1 . METHOD_3 ( ) ) <END> uri = TYPE_3 . append ( VAR_2 , VAR_1 . toString ( ) ) ; else { uri = METHOD_4 ( VAR_1 ) ; if ( uri == null ) return ; } METHOD_5 ( uri ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { <START> if ( VAR_1 . METHOD_2 ( ) ) <END> VAR_2 . METHOD_3 ( VAR_1 ) ; else VAR_2 . METHOD_3 ( TYPE_2 . METHOD_4 ( VAR_1 , METHOD_5 ( ) ) ) ; } } 
protected TYPE_1 METHOD_1 ( TYPE_2 path ) { TYPE_3 uri ; if ( ! path . VAR_1 ( ) ) { TYPE_3 VAR_2 = METHOD_2 ( ) ; uri = TYPE_4 . METHOD_3 ( ) . append ( VAR_2 , path . toString ( ) ) ; } else { uri = METHOD_4 ( path ) ; <START> if ( uri == null ) <END> return null ; } return METHOD_1 ( uri ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 uri ) { <START> if ( ! uri . VAR_1 ( ) ) <END> uri = TYPE_3 . METHOD_2 ( uri , METHOD_3 ( ) ) ; TYPE_1 f = TYPE_4 . METHOD_4 ( uri , VAR_2 ) ; if ( f != null && f . VAR_3 ( ) ) return f ; return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . add ( VAR_1 ) ; VAR_3 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_1 . VAR_4 == TYPE_2 . VAR_6 ) <END> VAR_7 = true ; } 
public void METHOD_1 ( ) throws IOException { <START> if ( outputStream != null ) <END> outputStream . VAR_1 ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 path ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; String VAR_2 = path . toString ( ) ; <START> if ( path . VAR_3 ( ) && VAR_2 . METHOD_3 ( 0 ) != TYPE_2 . VAR_4 ) <END> VAR_2 = TYPE_2 . VAR_4 + VAR_2 ; return TYPE_3 . METHOD_4 ( ) . METHOD_5 ( VAR_1 , VAR_2 ) ; } 
public static String [ ] METHOD_1 ( ) { <START> return VAR_1 . keySet ( ) . METHOD_2 ( new String [ 0 ] ) ; <END> } 
public static String [ ] METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> return VAR_2 . keySet ( ) . METHOD_2 ( new String [ 0 ] ) ; } return VAR_1 . METHOD_2 ( new String [ 0 ] ) ; } 
public boolean METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> return VAR_1 != null && METHOD_3 ( VAR_1 ) ; <END> } 
public static void trace ( String VAR_1 , String message , Throwable VAR_2 ) { String VAR_3 = message ; while ( VAR_3 . length ( ) > 100 ) { String VAR_4 = VAR_3 . substring ( 0 , 100 ) ; VAR_3 = VAR_3 . substring ( 100 ) ; System . out . println ( VAR_4 + STRING_1 ) ; <START> } <END> if ( VAR_5 != null ) { VAR_5 . trace ( VAR_1 , message , VAR_2 ) ; } } 
public TYPE_5 ( TYPE_1 VAR_2 ) { VAR_3 = VAR_2 ; VAR_4 = new TYPE_2 ( ) ; <START> new TYPE_3 ( TYPE_4 . METHOD_1 ( ) ) ; <END> } 
public static void trace ( String VAR_1 , String message , Throwable VAR_2 ) { String VAR_3 = message ; while ( VAR_3 . length ( ) > 100 ) { String VAR_4 = VAR_3 . substring ( 0 , 100 ) ; VAR_3 = VAR_3 . substring ( 100 ) ; System . out . METHOD_1 ( VAR_4 + STRING_1 ) ; } <START> System . out . println ( VAR_3 ) ; <END> if ( VAR_5 != null ) { VAR_5 . trace ( VAR_1 , message , VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) { METHOD_2 ( ) ; <START> if ( VAR_1 ) { <END> VAR_2 = TYPE_2 . VAR_4 ; } else { VAR_2 = TYPE_2 . VAR_5 ; } return this ; } 
<START> private String METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 { <END> String VAR_3 = VAR_1 . METHOD_1 ( VAR_2 ) ; if ( VAR_3 == null ) { return null ; } VAR_3 = VAR_3 . trim ( ) ; if ( VAR_3 . length ( ) == 0 ) { return null ; } return VAR_3 ; } 
public String METHOD_1 ( Object object ) { <START> return "" + object ; <END> } 
<START> public String getKey ( ) { <END> return key ; } 
private void METHOD_1 ( ) throws IOException , TYPE_1 { <START> if ( VAR_1 == null ) { <END> METHOD_2 ( ) ; } } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ; try { TYPE_3 index = VAR_1 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( new TYPE_4 ( index ) ) ; <START> if ( VAR_1 . METHOD_4 ( ) ) <END> VAR_2 . METHOD_5 ( new TYPE_4 ( index ) ) ; else VAR_2 . VAR_3 = true ; } catch ( IOException e ) { VAR_2 . METHOD_6 ( ) ; throw e ; } return VAR_2 ; } 
public String toString ( ) { <START> return STRING_1 + command . toString ( ) + STRING_2 + VAR_1 + STRING_3 ; <END> } 
public int METHOD_1 ( ) { int VAR_1 = 1 ; VAR_1 = VAR_1 * INT_1 + command . VAR_2 ( ) ; VAR_1 = VAR_1 * INT_1 + VAR_3 . METHOD_1 ( ) ; <START> return VAR_1 ; <END> } 
private void METHOD_1 ( String VAR_1 , List < TYPE_1 > VAR_2 ) throws IOException { write ( STRING_1 + VAR_1 ) ; for ( TYPE_1 cmd : VAR_2 ) { switch ( cmd . VAR_3 ( ) ) { case VAR_4 : write ( STRING_2 + cmd . VAR_5 ( ) ) ; break ; case VAR_6 : write ( STRING_3 + cmd . VAR_5 ( ) ) ; break ; default : <START> throw new IllegalArgumentException ( ) ; <END> } } } 
TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> VAR_3 = false ; <END> } 
<START> public void METHOD_1 ( ) { <END> VAR_1 . METHOD_1 ( ) ; VAR_2 . METHOD_1 ( ) ; VAR_3 . METHOD_1 ( ) ; VAR_4 . METHOD_1 ( ) ; } 
<START> public void METHOD_1 ( int VAR_1 ) { <END> VAR_2 = VAR_1 ; } 
private TYPE_2 ( TYPE_1 n , int VAR_2 ) { VAR_3 = start = VAR_4 = n ; VAR_5 = VAR_2 ; <START> VAR_6 = new ArrayList < TYPE_1 > ( VAR_2 ) ; <END> } 
public static boolean METHOD_1 ( String VAR_1 ) { <START> return VAR_1 != null && VAR_1 . METHOD_2 ( VAR_2 ) ; <END> } 
long METHOD_1 ( ) { <START> return System . VAR_1 ( ) / INT_1 ; <END> } 
<START> void METHOD_1 ( <END> Map < String , List < TYPE_1 > > VAR_1 , TYPE_2 output ) throws TYPE_3 , TYPE_4 , InterruptedException , IOException { connection = VAR_2 . METHOD_2 ( VAR_3 ) ; VAR_2 . METHOD_3 ( VAR_4 ) ; try { connection . VAR_5 ( VAR_3 , VAR_1 , output ) ; } finally { METHOD_4 ( ) ; } } 
public void start ( TYPE_1 context ) throws Exception { super . start ( context ) ; VAR_1 = new TYPE_2 ( VAR_2 ) ; File VAR_3 = METHOD_1 ( ) . METHOD_2 ( ) ; if ( ! VAR_3 . exists ( ) ) { VAR_3 . METHOD_3 ( ) ; } VAR_1 . METHOD_4 ( VAR_3 ) ; VAR_4 = new TYPE_3 ( VAR_1 ) ; <START> METHOD_5 ( ) ; <END> } 
protected void METHOD_1 ( <START> TYPE_1 VAR_1 ) throws TYPE_2 { <END> VAR_1 . METHOD_2 ( TYPE_3 . VAR_3 , false ) ; VAR_1 . METHOD_2 ( TYPE_3 . VAR_4 , true ) ; } 
public String METHOD_1 ( ) { try { float res = TYPE_1 . METHOD_2 ( result ) ; if ( res > 0 ) { return STRING_1 + result ; } else { return result ; } <START> } catch ( Exception e ) { <END> return result ; } } 
public TYPE_2 ( String name ) { super ( 1 , new TYPE_1 ( name + STRING_1 + VAR_2 ++ ) ) ; VAR_3 = name ; <START> if ( TYPE_3 . VAR_5 || VAR_6 ) { <END> METHOD_1 ( ) ; VAR_7 . put ( ( ( TYPE_1 ) METHOD_2 ( ) ) . VAR_8 , TYPE_2 . VAR_9 ) ; } } 
public void execute ( TYPE_1 command ) { <START> if ( TYPE_3 . VAR_2 && TYPE_3 . VAR_3 && command instanceof TYPE_2 ) { <END> assert ! ( ( TYPE_2 ) command ) . METHOD_1 ( ) : STRING_1 ; ( ( TYPE_2 ) command ) . METHOD_2 ( ) ; } command . run ( ) ; } 
public void METHOD_1 ( Class < ? > VAR_1 , Object VAR_2 ) { <START> if ( TYPE_1 . VAR_3 && TYPE_1 . VAR_4 && TYPE_1 . VAR_5 ) { <END> String msg = new TYPE_2 ( ) . format ( STRING_1 , TYPE_3 . METHOD_2 ( ) , TYPE_4 . toString ( VAR_2 ) , VAR_1 . getName ( ) , TYPE_4 . toString ( this ) , getId ( ) ) . toString ( ) ; TYPE_1 . trace ( msg ) ; } VAR_6 . put ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( Class < ? > VAR_1 ) { <START> if ( TYPE_1 . VAR_2 && TYPE_1 . VAR_3 && TYPE_1 . VAR_4 ) { <END> String msg = new TYPE_2 ( ) . format ( STRING_1 , TYPE_3 . METHOD_2 ( ) , VAR_1 . getName ( ) , TYPE_4 . toString ( this ) , getId ( ) ) . toString ( ) ; TYPE_1 . trace ( msg ) ; } VAR_5 . remove ( VAR_1 ) ; } 
public double METHOD_1 ( TYPE_1 < ? > location ) { final TYPE_2 VAR_1 = ( TYPE_2 ) location ; <START> TYPE_3 iterator = TYPE_4 . METHOD_2 ( this , ctx ) ; <END> ctx . VAR_2 ( VAR_1 ) ; ctx . VAR_3 ( VAR_1 . METHOD_3 ( ) ) ; long VAR_4 = ( ( Long ) ctx . VAR_5 ( ) . METHOD_3 ( ) ) ; return ( ( double ) VAR_4 - iterator . VAR_6 ( ) ) / ( iterator . VAR_7 ( ) - iterator . VAR_6 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { for ( int i = 0 ; i < this . VAR_2 . length ; i ++ ) { if ( this . VAR_2 [ i ] . equals ( VAR_1 ) ) return ; } int length = this . VAR_2 . length ; System . VAR_3 ( this . VAR_2 , 0 , this . VAR_2 = new TYPE_1 [ length + 1 ] , 0 , length ) ; <START> this . VAR_2 [ this . VAR_2 . length - 1 ] = VAR_1 ; <END> } 
public void METHOD_1 ( TYPE_1 event , TYPE_2 VAR_1 ) { TYPE_3 < String > [ ] VAR_2 = METHOD_2 ( event , VAR_1 ) ; for ( TYPE_3 < String > path : VAR_2 ) <START> ++ ( METHOD_3 ( path ) . getValue ( ) . VAR_3 ) ; <END> VAR_2 = METHOD_4 ( event , VAR_1 ) ; for ( TYPE_3 < String > path : VAR_2 ) ++ ( METHOD_3 ( path ) . getValue ( ) . VAR_3 ) ; } 
<START> public int METHOD_1 ( TYPE_1 object ) { <END> if ( VAR_1 == null || object . VAR_2 ( ) == null ) { return 0 ; } return VAR_1 . METHOD_1 ( object . VAR_2 ( ) ) ; } 
private void METHOD_1 ( ) { <START> Assert . VAR_1 ( VAR_2 , STRING_1 ) ; <END> VAR_3 . addAll ( VAR_4 . METHOD_2 ( VAR_2 ) ) ; try { TYPE_1 VAR_5 = new TYPE_1 ( ) ; VAR_5 . METHOD_3 ( VAR_4 ) ; VAR_5 . query ( VAR_2 , null ) ; } catch ( TYPE_2 e ) { System . out . println ( e ) ; } VAR_3 . addAll ( VAR_4 . METHOD_2 ( VAR_2 ) ) ; } 
public Collection < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <START> VAR_3 . addAll ( new TYPE_3 ( ) . METHOD_2 ( ( ( TYPE_4 ) VAR_1 ) . METHOD_3 ( ) . METHOD_4 ( ) ) ) ; <END> return VAR_3 ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_1 ( ) ; } TYPE_1 . METHOD_2 ( ) ; } 
public TYPE_1 < TYPE_2 > query ( TYPE_3 < TYPE_2 > query , TYPE_4 monitor ) { <START> if ( VAR_1 == TYPE_6 . VAR_3 ) { <END> return new TYPE_5 < TYPE_2 > ( TYPE_7 < TYPE_2 > METHOD_1 ( ) ) ; } else { return super . query ( query , monitor ) ; } } 
void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 ) VAR_2 |= VAR_3 ; else <START> VAR_2 &= VAR_3 ; <END> } 
public TYPE_2 ( final TYPE_1 VAR_2 ) { super ( VAR_2 . getValue ( ) , 0 , 0 ) ; <START> if ( VAR_2 . METHOD_1 ( ) != 0 || VAR_2 . METHOD_2 ( ) != 0 ) { <END> throw new IllegalArgumentException ( ) ; } } 
public TYPE_1 METHOD_1 ( double VAR_1 ) { TYPE_2 context = new TYPE_2 ( this ) ; final long VAR_2 = this . METHOD_2 ( ) . getValue ( ) ; final long start = this . METHOD_3 ( ) . getValue ( ) ; final long VAR_3 = VAR_2 - start ; final TYPE_3 VAR_4 = new TYPE_3 ( ( long ) ( VAR_3 * VAR_1 ) + start ) ; <START> context . VAR_5 ( VAR_4 . getValue ( ) ) ; <END> context . VAR_6 ( TYPE_1 . VAR_7 ) ; return context ; } 
private void METHOD_1 ( TYPE_1 result , TYPE_2 configuration ) { String value = METHOD_2 ( configuration . VAR_1 ( STRING_1 ) ) ; if ( value == null ) { return ; } <START> if ( value . startsWith ( STRING_2 ) ) { <END> throw new RuntimeException ( STRING_3 ) ; } try { TYPE_3 . METHOD_3 ( value ) ; } catch ( TYPE_4 e ) { throw new RuntimeException ( STRING_4 + value ) ; } result . VAR_2 ( value ) ; } 
public void METHOD_1 ( TYPE_1 config , String VAR_1 , Object data ) { <START> TYPE_2 < String , String > parameters = ( TYPE_2 < String , String > ) data ; <END> String VAR_2 = parameters . get ( TYPE_3 . VAR_4 ) ; String VAR_5 = parameters . get ( TYPE_3 . VAR_6 ) ; if ( VAR_2 == null ) { VAR_2 = "" ; } if ( VAR_5 == null ) { VAR_5 = "" ; } METHOD_2 ( VAR_2 ) ; METHOD_3 ( VAR_5 ) ; } 
public void METHOD_1 ( TYPE_1 config , String VAR_1 , Object data ) { <START> TYPE_2 < String , String > parameters = ( TYPE_2 < String , String > ) data ; <END> String VAR_2 = parameters . get ( TYPE_3 . VAR_4 ) ; String VAR_5 = parameters . get ( TYPE_3 . VAR_6 ) ; if ( VAR_2 == null ) { VAR_2 = "" ; } if ( VAR_5 == null ) { VAR_5 = "" ; } METHOD_2 ( VAR_5 ) ; METHOD_3 ( VAR_2 ) ; } 
public String METHOD_1 ( ) { String text = METHOD_2 ( ) ; text = Utils . VAR_1 ( text ) ; <START> if ( METHOD_3 ( ) ) { <END> text = METHOD_4 ( text ) ; } return text ; } 
public void METHOD_1 ( ) { <START> if ( ! METHOD_2 ( TYPE_1 . VAR_2 ) ) { <END> return ; } super . METHOD_1 ( ) ; } 
public void execute ( ) throws TYPE_1 , TYPE_2 { if ( ! TYPE_3 . equals ( project . VAR_1 ( ) ) ) { throw new TYPE_1 ( STRING_1 <START> + TYPE_3 + STRING_2 ) ; <END> } File VAR_2 = new File ( project . VAR_3 ( ) , project . VAR_4 ( ) + VAR_5 ) ; if ( ! VAR_2 . METHOD_1 ( ) ) { throw new TYPE_1 ( STRING_3 + VAR_2 . METHOD_2 ( ) + STRING_4 ) ; } project . VAR_6 ( ) . METHOD_3 ( VAR_2 ) ; } 
<START> protected TYPE_1 METHOD_1 ( TYPE_1 e ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( e . VAR_2 ( ) , e . VAR_3 ( ) ) ; VAR_1 . METHOD_2 ( e . VAR_4 ( ) ) ; VAR_1 . METHOD_3 ( e . VAR_5 ( ) ) ; VAR_1 . METHOD_4 ( e . VAR_6 ( ) ) ; VAR_1 . METHOD_5 ( e . VAR_7 ( ) ) ; builder . add ( VAR_1 ) ; return VAR_1 ; } 
<START> protected int METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 ) { <END> if ( VAR_2 == VAR_3 ) return VAR_2 ; if ( VAR_1 == VAR_2 ) return ( VAR_3 == TYPE_2 . TYPE_3 . METHOD_2 ( ) ) ? VAR_2 : VAR_3 ; if ( VAR_1 == VAR_3 ) return ( VAR_2 == TYPE_2 . TYPE_3 . METHOD_2 ( ) ) ? VAR_3 : VAR_2 ; return TYPE_2 . TYPE_3 . METHOD_2 ( ) ; } 
protected boolean METHOD_1 ( ) throws IOException { boolean VAR_1 = false ; boolean VAR_2 = false ; if ( VAR_3 == null ) { VAR_3 = METHOD_2 ( ) . METHOD_3 ( ) ; VAR_1 = true ; } VAR_2 = METHOD_4 ( METHOD_5 ( ) . METHOD_6 ( ) , VAR_4 [ 0 ] , VAR_4 [ 1 ] ) ; <START> if ( VAR_1 ) { <END> VAR_3 . METHOD_7 ( ) ; } return VAR_2 ; } 
public TYPE_2 ( TYPE_1 VAR_2 , TYPE_1 task ) { <START> this . VAR_2 = VAR_2 ; <END> this . task = task ; } 
public boolean filter ( List < ? > VAR_1 ) { if ( VAR_1 == null ) { <START> return true ; <END> } VAR_2 . METHOD_1 ( ) ; try { METHOD_2 ( ) ; List < TYPE_1 > list = ( List < TYPE_1 > ) VAR_1 ; VAR_3 = new ArrayList < TYPE_1 > ( list ) ; METHOD_3 ( VAR_4 ) ; } finally { VAR_2 . METHOD_4 ( ) ; } return true ; } 
public TYPE_1 ( ) { <START> METHOD_1 ( Messages . TYPE_2 ) ; <END> } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <END> Collection < TYPE_3 > VAR_3 = METHOD_2 ( ) ; for ( TYPE_3 VAR_4 : VAR_3 ) { METHOD_3 ( VAR_2 , VAR_1 , VAR_4 ) ; } } 
private TYPE_1 METHOD_1 ( File VAR_1 ) throws IOException { final File parent = VAR_1 . METHOD_2 ( ) ; if ( TYPE_2 . METHOD_3 ( parent , VAR_2 ) ) { TYPE_2 key = TYPE_2 . METHOD_4 ( parent , VAR_2 ) ; TYPE_3 db = ( TYPE_3 ) TYPE_4 . METHOD_5 ( key ) ; return new TYPE_5 ( db ) ; } <START> TYPE_6 db = new TYPE_6 ( config , VAR_1 , null , VAR_2 , VAR_3 ) ; <END> return new TYPE_1 ( db ) ; } 
public boolean METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_1 VAR_2 ) throws TYPE_2 , TYPE_3 , IOException { <START> METHOD_2 ( ) ; <END> final TYPE_4 VAR_3 = filter ; final TYPE_5 VAR_4 = VAR_5 ; try { METHOD_3 ( ) ; METHOD_4 ( ~ VAR_6 & VAR_7 ) ; filter = TYPE_4 . VAR_8 ; VAR_5 = TYPE_5 . VAR_9 ; METHOD_5 ( VAR_2 ) ; METHOD_5 ( VAR_1 ) ; return next ( ) == VAR_1 ; } finally { filter = VAR_3 ; VAR_5 = VAR_4 ; } } 
public TYPE_1 next ( ) throws TYPE_2 , TYPE_3 , IOException { <START> METHOD_1 ( ) ; <END> return VAR_1 . next ( ) ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 id ) throws TYPE_3 , TYPE_4 , IOException { <START> METHOD_2 ( ) ; <END> TYPE_5 c = METHOD_3 ( METHOD_4 ( id ) ) ; if ( ! ( c instanceof TYPE_1 ) ) throw new TYPE_4 ( id . VAR_1 ( ) , Constants . VAR_2 ) ; return ( TYPE_1 ) c ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { TYPE_3 VAR_3 = null ; try { VAR_3 = new TYPE_3 ( VAR_1 ) ; return VAR_3 . METHOD_2 ( TYPE_4 . METHOD_3 ( VAR_2 ) ) ; <START> } catch ( TYPE_5 e ) { <END> return null ; } catch ( TYPE_6 e ) { return null ; } catch ( IOException e ) { return null ; } finally { if ( VAR_3 != null ) { VAR_3 . METHOD_4 ( ) ; } } } 
TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 instanceof TYPE_1 ) { <END> return ( TYPE_1 ) VAR_1 ; } return null ; } 
public String getProperty ( String key ) { if ( properties != null ) { <START> if ( properties . containsKey ( key ) ) { <END> return properties . get ( key ) ; } } return null ; } 
public void add ( final String [ ] log ) { table . VAR_1 ( ) . METHOD_1 ( ) . METHOD_2 ( new TYPE_1 ( ) { public void run ( ) { table . VAR_2 ( log ) ; try { TYPE_2 . METHOD_3 ( ) . METHOD_4 ( ) [ 0 ] . METHOD_5 ( ) . METHOD_6 ( VAR_3 ) ; } catch ( TYPE_3 VAR_4 ) { <START> } catch ( TYPE_4 VAR_5 ) { } <END> } } ) ; } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( ) . METHOD_3 ( ) ; <END> VAR_1 = null ; VAR_2 = null ; VAR_3 = null ; VAR_4 = null ; if ( VAR_5 != null ) { VAR_5 . METHOD_4 ( ) ; VAR_5 = null ; } super . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( METHOD_3 ( ) , VAR_1 , true ) ; <END> } 
public String [ ] METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_1 node = TYPE_2 . METHOD_2 ( ) ; node = node . VAR_3 ( METHOD_3 ( VAR_1 ) ) ; if ( node == null ) return VAR_4 ; node = node . VAR_3 ( VAR_1 ) ; if ( node == null ) return VAR_4 ; String [ ] VAR_5 = METHOD_4 ( node , VAR_2 ) ; if ( VAR_5 . length == 0 ) <START> return VAR_4 ; <END> return VAR_5 ; } 
public void METHOD_1 ( ) { <START> Collection < String > VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> assertEquals ( 0 , VAR_1 . size ( ) ) ; String VAR_3 = VAR_2 . METHOD_3 ( STRING_1 ) ; METHOD_4 ( VAR_3 ) ; } 
public void METHOD_1 ( ) { for ( TYPE_1 reader : VAR_1 ) { if ( reader != null ) { reader . VAR_2 ( ) ; } <START> } <END> } 
static String METHOD_1 ( File path ) throws IOException { Path VAR_1 = path . VAR_2 ( ) ; Path target = TYPE_1 . METHOD_2 ( VAR_1 ) ; String VAR_3 = target . toString ( ) ; if ( TYPE_2 . getInstance ( ) . METHOD_3 ( ) ) VAR_3 = VAR_3 . METHOD_4 ( CHAR_1 , CHAR_2 ) ; <START> else if ( TYPE_2 . getInstance ( ) . METHOD_5 ( ) ) { <END> VAR_3 = TYPE_3 . METHOD_6 ( VAR_3 , TYPE_4 . VAR_5 ) ; } return VAR_3 ; } 
public void METHOD_1 ( File path , boolean VAR_1 ) throws IOException { <START> super . METHOD_1 ( path , VAR_1 ) ; <END> } 
public TYPE_4 ( TYPE_1 project ) { VAR_2 = null ; VAR_3 = false ; try { if ( project . VAR_4 ( VAR_5 ) ) { TYPE_2 VAR_6 = ( TYPE_2 ) project . VAR_7 ( TYPE_2 . class ) ; uri = VAR_6 . METHOD_1 ( ) ; } else { uri = project . VAR_8 ( ) ; } VAR_9 = System . getProperty ( STRING_1 , STRING_2 ) ; } catch ( TYPE_3 e ) { <START> e . VAR_10 ( ) ; <END> } } 
private String METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) ) { return STRING_1 + METHOD_3 ( ) ; } return "" ; <START> } <END> 
public static int METHOD_1 ( String message , String VAR_1 ) { String [ ] VAR_2 = message . split ( VAR_1 ) ; int VAR_3 = METHOD_2 ( VAR_2 ) ; if ( VAR_3 == VAR_2 . length ) return - 1 ; int VAR_4 = 0 ; <START> for ( int i = 0 ; i < VAR_3 ; ++ i ) { <END> VAR_4 += VAR_2 [ i ] . length ( ) + VAR_1 . length ( ) ; } return message . VAR_5 ( VAR_6 , VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( STRING_1 , TYPE_2 . instance ) ; <END> VAR_1 . METHOD_2 ( STRING_2 , VAR_3 . keySet ( ) . size ( ) ) ; VAR_1 . METHOD_2 ( STRING_3 , VAR_4 . size ( ) ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 , String name ) { this . VAR_2 = VAR_2 ; int VAR_3 = name . VAR_4 ( CHAR_1 ) ; this . VAR_5 = ( VAR_3 < 0 ) ? name : name . substring ( 0 , VAR_3 ) ; <START> this . VAR_6 = new HashMap < String , Long > ( ) ; <END> } 
public long METHOD_1 ( String VAR_1 ) { Long size = VAR_2 . get ( VAR_1 ) ; <START> return ( size == null ) ? 0 : size . VAR_3 ( ) ; <END> } 
public String METHOD_1 ( ) { String VAR_1 = "" ; for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { <START> VAR_1 += STRING_1 + i + STRING_2 + VAR_3 [ i ] . size ( ) + STRING_3 ; <END> } return VAR_1 ; } 
protected int METHOD_1 ( Map < Object , TYPE_1 < TYPE_2 > > VAR_1 ) { Iterator < Entry < Object , TYPE_1 < TYPE_2 > > > iterator = VAR_1 . entrySet ( ) . iterator ( ) ; int count = 0 ; while ( iterator . hasNext ( ) ) { count += iterator . next ( ) . getValue ( ) . size ( ) ; <START> } <END> return count ; } 
public void run ( ) { TYPE_1 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( new TYPE_2 ( ) { public void run ( ) { <START> TYPE_3 VAR_1 = TYPE_3 . METHOD_4 ( ) ; <END> if ( null != VAR_1 && VAR_1 . METHOD_5 ( ) ) { VAR_1 . METHOD_6 ( ) ; } } } ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> final TYPE_2 VAR_1 = super . VAR_2 . METHOD_2 ( ) ; if ( VAR_1 != null ) { return new TYPE_3 ( VAR_1 . METHOD_1 ( ) , VAR_1 . METHOD_3 ( ) , ( TYPE_4 ) this . METHOD_4 ( ) ) ; } return null ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ( VAR_2 & VAR_1 . METHOD_2 ( ) ) == VAR_1 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( int p ) { <START> if ( VAR_1 == p ) return ; <END> VAR_1 = p > VAR_2 ? p : VAR_2 ; METHOD_2 ( ) ; METHOD_3 ( ) ; } 
public TYPE_1 ( Integer [ ] c ) { <START> assert ( c != null && c . length >= INT_1 ) ; <END> VAR_2 = c [ 0 ] ; VAR_3 = c [ 1 ] ; VAR_4 = c [ 2 ] ; VAR_5 = c [ 3 ] ; VAR_6 = c [ 4 ] ; VAR_7 = c [ 5 ] ; VAR_8 = c [ INT_2 ] ; } 
public String toString ( ) { if ( VAR_1 != null ) { <START> return STRING_1 + VAR_2 + STRING_2 + VAR_1 . METHOD_1 ( ) ; <END> } else { return STRING_1 + VAR_2 + STRING_3 ; } } 
<START> public int METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> VAR_2 = VAR_1 ; METHOD_2 ( ) ; METHOD_3 ( ) ; } 
protected String METHOD_1 ( ) { if ( path != null ) { return path . VAR_1 ( ) ; } TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 . METHOD_4 ( ) instanceof TYPE_2 ) return ( ( TYPE_2 ) VAR_2 . METHOD_4 ( ) ) . getPath ( ) . toString ( ) ; else <START> return TYPE_3 . METHOD_5 ( VAR_2 . METHOD_4 ( ) ) . METHOD_6 ( ) . toString ( ) ; <END> } 
<START> public List < TYPE_1 > getValue ( ) { <END> return new ArrayList < TYPE_1 > ( Arrays . asList ( ( TYPE_1 [ ] ) super . getValue ( ) ) ) ; } 
public TYPE_2 ( TYPE_1 [ ] VAR_2 , long [ ] VAR_3 ) { <START> assert ( VAR_2 . length == VAR_3 . length ) ; <END> VAR_4 = Arrays . VAR_5 ( VAR_2 , VAR_2 . length ) ; VAR_6 = Arrays . VAR_5 ( VAR_3 , VAR_3 . length ) ; } 
private String METHOD_1 ( String name ) throws TYPE_1 { <START> TYPE_2 VAR_1 = null ; <END> try { VAR_1 = TYPE_3 . METHOD_2 ( TYPE_6 . TYPE_7 , name , TYPE_4 . METHOD_3 ( ) ) ; if ( VAR_1 != null ) { return METHOD_1 ( VAR_1 ) ; } } catch ( TYPE_1 ex ) { throw ex ; } catch ( Exception ex ) { throw new TYPE_5 ( String . format ( STRING_1 , name ) , ex ) ; } return null ; } 
static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { assertThat ( VAR_1 , METHOD_2 ( METHOD_3 ( VAR_2 ) ) ) ; <START> assertEquals ( VAR_1 . METHOD_4 ( ) , VAR_2 . METHOD_4 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 buffer , boolean VAR_1 ) throws TYPE_2 { VAR_1 = VAR_1 && VAR_2 != TYPE_3 . VAR_4 ; short VAR_5 = TYPE_1 . VAR_6 ; if ( VAR_1 ) VAR_5 |= TYPE_1 . VAR_7 ; switch ( VAR_8 ) { case VAR_9 : VAR_5 |= TYPE_1 . VAR_10 ; break ; case VAR_11 : <START> VAR_5 |= TYPE_1 . VAR_12 ; <END> break ; default : break ; } buffer . VAR_13 ( VAR_5 ) ; buffer . VAR_14 ( VAR_15 ) ; if ( VAR_1 ) { buffer . VAR_16 ( VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { int VAR_1 = VAR_2 ; short VAR_3 = METHOD_2 ( ) ; <START> if ( VAR_3 == VAR_4 ) { <END> return null ; } VAR_2 = VAR_1 ; return VAR_5 . METHOD_1 ( this ) ; } 
public TYPE_1 ( ) { super ( ) ; <START> METHOD_1 ( ) ; <END> METHOD_2 ( ) ; } 
public String toString ( ) { StringBuilder sb = new StringBuilder ( getName ( ) ) ; sb . append ( CHAR_1 ) ; <START> sb . append ( METHOD_1 ( getValue ( ) , VAR_1 ) ) ; <END> return sb . toString ( ) ; } 
private StringBuilder format ( ) { <START> StringBuilder sb = new StringBuilder ( String . valueOf ( VAR_1 ) ) ; <END> if ( VAR_2 > 0 ) sb . append ( CHAR_1 ) . append ( VAR_2 ) ; return sb ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 client = METHOD_2 ( VAR_1 ) ; <START> return new TYPE_4 ( client ) ; <END> } 
public Object execute ( TYPE_1 event ) throws TYPE_2 { TYPE_3 VAR_1 = new TYPE_3 ( ) ; VAR_1 . METHOD_1 ( event . VAR_2 ( ) ) ; <START> if ( VAR_1 . METHOD_2 ( ) ) { <END> return VAR_1 . execute ( event ) ; } else { return null ; } } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; TYPE_1 VAR_1 = METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_1 ) ; VAR_3 . METHOD_4 ( VAR_1 ) ; VAR_4 . METHOD_4 ( VAR_1 ) ; Object VAR_5 = VAR_1 . METHOD_5 ( ) ; <START> if ( VAR_5 != null && VAR_5 instanceof TYPE_2 ) { <END> VAR_4 . METHOD_6 ( ( ( TYPE_2 ) VAR_5 ) . METHOD_7 ( ) != null ) ; } } 
<START> public void METHOD_1 ( ) { <END> VAR_1 . clear ( ) ; VAR_2 . clear ( ) ; } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> TYPE_2 . METHOD_3 ( VAR_1 ) ; <END> METHOD_4 ( ) ; VAR_1 . METHOD_5 ( ) . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { assertEquals ( STRING_1 , STRING_2 , VAR_1 . toString ( ) ) ; assertEquals ( STRING_1 , STRING_3 , VAR_2 . toString ( ) ) ; assertEquals ( STRING_1 , STRING_4 , VAR_3 . toString ( ) ) ; <START> TYPE_1 VAR_4 = new TYPE_2 ( null , VAR_5 , VAR_6 ) ; <END> assertEquals ( STRING_1 , STRING_5 , VAR_4 . toString ( ) ) ; } 
public Object METHOD_1 ( Object id ) { <START> if ( id . equals ( VAR_1 ) && VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) != null ) { <END> return VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; } else if ( id . equals ( VAR_3 ) ) { return VAR_2 . METHOD_2 ( ) . METHOD_4 ( ) ; } else if ( id . equals ( VAR_4 ) ) { return Long . valueOf ( VAR_2 . METHOD_2 ( ) . METHOD_5 ( ) ) ; } return null ; } 
public void METHOD_1 ( ) { try { new TYPE_1 ( null ) ; METHOD_2 ( STRING_1 ) ; <START> } catch ( final IllegalArgumentException e ) { <END> } } 
private void METHOD_1 ( Object element ) { <START> Object e = element ; <END> METHOD_2 ( e ) ; for ( Object child : VAR_1 . METHOD_3 ( e ) ) { METHOD_1 ( child ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 ) { if ( VAR_3 == 0 ) return ; TYPE_1 n = res . next ; <START> while ( VAR_3 < VAR_4 + VAR_2 ) { <END> clear ( n ) ; if ( n == VAR_1 ) throw new TYPE_3 . TYPE_4 ( VAR_3 , VAR_4 + VAR_2 ) ; n = n . next ; } } 
private int METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 == null ) { int n = res . size ( ) > > > 1 ; return n - ( n * VAR_1 . METHOD_2 ( ) / VAR_3 ) ; } int d = VAR_2 . METHOD_2 ( ) ; int n = ( int ) VAR_4 . length ( ) ; <START> return n * ( VAR_3 - VAR_1 . METHOD_2 ( ) ) / ( VAR_3 - d ) ; <END> } 
private TYPE_1 METHOD_1 ( ) throws TYPE_2 , TYPE_3 { TYPE_1 VAR_1 = TYPE_4 . METHOD_2 ( ) ; TYPE_5 VAR_2 = new TYPE_5 ( TYPE_8 . VAR_4 ) ; <START> VAR_2 . METHOD_3 ( TYPE_9 . VAR_6 ) ; <END> VAR_2 . METHOD_3 ( TYPE_9 . VAR_7 ) ; for ( TYPE_6 VAR_8 : TYPE_7 . METHOD_4 ( VAR_2 ) ) { VAR_1 . add ( VAR_8 . getId ( ) ) ; } VAR_1 . METHOD_5 ( ) ; return VAR_1 ; } 
private int METHOD_1 ( int VAR_1 ) throws TYPE_1 { int VAR_2 = VAR_1 % VAR_3 ; long VAR_4 = record + VAR_5 + VAR_1 / VAR_3 ; int VAR_6 = METHOD_2 ( ) . METHOD_3 ( VAR_4 ) ; <START> VAR_6 &= VAR_7 < < VAR_2 * VAR_8 ; <END> VAR_6 >>>= VAR_2 * VAR_8 ; return VAR_6 ; } 
private long METHOD_1 ( int VAR_1 ) throws TYPE_1 { <START> if ( VAR_1 >= VAR_2 ) { <END> return 0 ; } return METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( VAR_1 ) ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , long record ) throws TYPE_2 { this . VAR_2 = VAR_2 ; this . record = record ; <START> METHOD_1 ( ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 ) throws TYPE_2 { TYPE_3 db = VAR_2 . METHOD_1 ( ) ; this . VAR_2 = VAR_2 ; this . record = db . VAR_3 ( VAR_4 ) ; db . VAR_5 ( record , VAR_4 ) ; <START> METHOD_2 ( ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return METHOD_2 ( ) . METHOD_3 ( ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public TYPE_1 [ ] METHOD_1 ( ) { <END> final TYPE_1 trace = VAR_1 ; if ( trace instanceof TYPE_2 ) { final TYPE_2 VAR_2 = ( TYPE_2 ) trace ; return VAR_2 . METHOD_2 ( ) ; } return new TYPE_1 [ ] { trace } ; } 
protected String [ ] METHOD_1 ( String group ) { if ( TYPE_1 . equals ( group ) ) { return new String [ ] { STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , <START> STRING_8 , <END> STRING_9 , STRING_10 , } ; } return null ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( ! VAR_1 ) <END> return TYPE_1 . VAR_2 ; TYPE_1 VAR_3 = TYPE_1 . TYPE_3 . METHOD_2 ( length ) ; return VAR_3 . METHOD_3 ( TYPE_1 . valueOf ( 2 ) ) . METHOD_4 ( ) ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) throws TYPE_2 { TYPE_1 VAR_2 = null ; if ( VAR_1 <= 0 ) { VAR_2 = METHOD_2 ( TYPE_4 . TYPE_3 ) ; } else { for ( TYPE_1 VAR_5 : METHOD_3 ( ) ) { if ( VAR_1 == VAR_5 . METHOD_4 ( ) ) { <START> VAR_2 = VAR_5 ; <END> } } } return VAR_2 ; } 
public Object METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_2 instanceof TYPE_3 ) { TYPE_1 VAR_3 = VAR_1 ; try { if ( VAR_1 != null ) { <START> return TYPE_4 . METHOD_2 ( METHOD_3 ( ( TYPE_3 ) VAR_2 ) , VAR_3 ) ; <END> } else { TYPE_5 element = METHOD_3 ( ( TYPE_3 ) VAR_2 ) ; return element ; } } catch ( TYPE_6 e ) { } } return null ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 r = db . VAR_1 ( ) ; <START> r . VAR_2 ( VAR_3 ) ; <END> return r ; } 
private TYPE_1 METHOD_1 ( TYPE_1 id , long offset ) throws IOException { TYPE_2 obj = new TYPE_2 ( id ) ; obj . VAR_1 ( offset ) ; obj . VAR_2 ( ( int ) VAR_3 . VAR_4 . getValue ( ) ) ; VAR_5 . add ( obj ) ; VAR_6 . METHOD_2 ( obj ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> return id ; } 
public TYPE_2 ( TYPE_1 repo ) { <START> VAR_2 = repo . VAR_3 ( ) ; <END> VAR_4 = repo . VAR_5 ( ) . get ( TYPE_3 . VAR_7 ) . METHOD_1 ( ) ; METHOD_2 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 = false ; <END> } 
public Object METHOD_1 ( Class VAR_1 ) { <START> if ( VAR_1 == TYPE_1 . class || VAR_1 == TYPE_2 . class ) { <END> return METHOD_2 ( ) ; } else if ( VAR_1 == TYPE_3 . class ) { return path ; } return null ; } 
private Object [ ] METHOD_1 ( ) { if ( VAR_1 == null ) { List < Object > VAR_2 = new ArrayList < Object > ( ) ; VAR_3 = METHOD_2 ( ) ; <START> for ( TYPE_1 VAR_4 : VAR_3 ) { <END> VAR_2 . add ( VAR_4 ) ; } for ( TYPE_2 VAR_5 : VAR_6 ) { VAR_2 . add ( VAR_5 ) ; } VAR_1 = new Object [ VAR_2 . size ( ) ] ; VAR_2 . METHOD_3 ( VAR_1 ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws TYPE_1 { METHOD_2 ( VAR_1 ) ; TYPE_2 trace = new TYPE_2 ( VAR_2 ) ; assertNotNull ( trace ) ; <START> trace . VAR_3 ( ) ; <END> } 
public static void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( TYPE_2 . getInstance ( ) . METHOD_2 ( ) , TYPE_2 . getInstance ( ) . METHOD_3 ( ) ) ; VAR_2 = new TYPE_1 ( TYPE_2 . getInstance ( ) . METHOD_4 ( ) ) ; <START> TYPE_3 . METHOD_5 ( new TYPE_4 ( null ) ) ; <END> } 
public static TYPE_1 METHOD_1 ( String name ) throws TYPE_2 { for ( TYPE_3 VAR_1 : TYPE_4 . METHOD_2 ( name , TYPE_5 . METHOD_3 ( ) , TYPE_7 . VAR_3 , TYPE_9 . VAR_5 ) ) { if ( VAR_1 . METHOD_4 ( TYPE_6 . TYPE_8 ) ) { return ( TYPE_1 ) VAR_1 ; } } <START> return null ; <END> } 
private Map < String , String > METHOD_1 ( ) <START> { <END> for ( TYPE_1 VAR_1 : TYPE_2 . getInstance ( ) . METHOD_2 ( ) ) { if ( VAR_1 . METHOD_3 ( ) . equals ( this . METHOD_3 ( ) ) ) { if ( VAR_1 instanceof TYPE_3 ) { TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; return VAR_2 . METHOD_1 ( ) ; } } } return null ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> VAR_2 = VAR_1 ; } 
<START> public boolean METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public boolean METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public void METHOD_1 ( int VAR_1 ) { <END> VAR_2 = VAR_1 ; } 
public Map < String , TYPE_1 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; VAR_1 = ( TYPE_1 ) METHOD_3 ( VAR_2 ) ; if ( VAR_1 != VAR_2 ) { <START> if ( METHOD_4 ( ) ) { <END> METHOD_5 ( new TYPE_3 ( this , TYPE_5 . VAR_4 , TYPE_4 . VAR_6 , VAR_2 , VAR_1 ) ) ; } } } return VAR_1 ; } 
public boolean METHOD_1 ( String [ ] VAR_1 ) { <START> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <END> if ( ! METHOD_2 ( VAR_1 [ i ] ) ) { return false ; } } return true ; } 
public void METHOD_1 ( ) throws Exception { <START> assertTrue ( VAR_1 . METHOD_2 ( VAR_2 ) . getName ( ) . equals ( STRING_1 ) ) ; <END> } 
public Object [ ] METHOD_1 ( Object VAR_1 ) { Object [ ] VAR_2 = VAR_3 . METHOD_1 ( VAR_1 ) ; <START> Object [ ] VAR_4 = Arrays . VAR_5 ( VAR_2 , VAR_2 . length + VAR_6 ) ; <END> for ( int i = 0 ; i < VAR_6 ; i ++ ) { VAR_4 [ VAR_2 . length + i ] = VAR_7 ; } return VAR_4 ; } 
public void start ( TYPE_1 context ) throws Exception { <START> TYPE_2 . METHOD_1 ( STRING_1 , new TYPE_3 ( ) ) ; <END> TYPE_2 . METHOD_1 ( STRING_2 , new TYPE_4 ( ) ) ; TYPE_2 . METHOD_1 ( STRING_3 , new TYPE_5 ( ) ) ; TYPE_2 . METHOD_1 ( STRING_4 , new TYPE_6 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 context ) throws Exception { TYPE_2 . METHOD_2 ( STRING_1 ) ; <START> TYPE_2 . METHOD_2 ( STRING_2 ) ; <END> TYPE_2 . METHOD_2 ( STRING_3 ) ; TYPE_2 . METHOD_2 ( STRING_4 ) ; } 
public void METHOD_1 ( ) { Collection < TYPE_1 > VAR_1 = VAR_2 . values ( ) ; TYPE_2 < TYPE_1 > VAR_3 = TYPE_3 . filter ( VAR_1 , new TYPE_4 < TYPE_1 > ( ) { public boolean apply ( TYPE_1 VAR_4 ) { return VAR_4 . METHOD_2 ( ) . METHOD_3 ( ) != null ; } } ) ; <START> for ( TYPE_1 VAR_4 : VAR_3 ) { <END> METHOD_4 ( VAR_4 , false , true ) ; } } 
private void METHOD_1 ( ) throws InterruptedException { <START> if ( ! VAR_1 . isEmpty ( ) ) { <END> for ( Thread VAR_2 : VAR_1 ) { VAR_2 . METHOD_2 ( ) ; } } } 
public void run ( ) { final TYPE_1 VAR_1 = TYPE_1 . METHOD_1 ( ) ; if ( ( VAR_1 == null ) || VAR_1 . METHOD_2 ( ) ) { return ; } TYPE_1 . METHOD_1 ( ) . METHOD_3 ( new TYPE_2 ( ) { @Override public void run ( ) { <START> if ( ! VAR_1 . METHOD_2 ( ) ) { <END> VAR_2 . METHOD_4 ( VAR_3 , VAR_4 ) ; } } } ) ; } 
public TYPE_4 ( TYPE_1 data , TYPE_2 VAR_2 ) { model = new TYPE_3 ( data ) ; <START> if ( VAR_3 = ( VAR_2 != null ) ) { <END> model . VAR_4 ( VAR_2 . VAR_5 ) ; model . VAR_6 ( VAR_2 . key ) ; model . VAR_7 ( VAR_2 . VAR_8 ) ; model . VAR_9 ( VAR_2 . VAR_10 ) ; model . VAR_11 ( VAR_2 . VAR_12 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { VAR_1 . METHOD_2 ( VAR_2 ) ; for ( TYPE_2 child : VAR_1 . METHOD_3 ( ) ) { if ( child == VAR_3 || child == VAR_4 ) { child . VAR_5 ( false ) ; <START> } <END> if ( child instanceof TYPE_1 ) { METHOD_1 ( ( TYPE_1 ) child , VAR_2 ) ; } } } 
<START> private void METHOD_1 ( String VAR_1 ) { <END> model . VAR_2 ( VAR_1 ) ; METHOD_2 ( TYPE_1 . METHOD_3 ( model . VAR_3 ( ) , model . VAR_4 ( ) ) , TYPE_1 . METHOD_4 ( model . VAR_3 ( ) , model . VAR_4 ( ) ) ) ; } 
private void execute ( ) throws TYPE_1 { TYPE_2 VAR_1 = TYPE_3 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; <START> VAR_1 . execute ( this , new TYPE_4 ( ) , null ) ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_4 . TYPE_5 . VAR_1 . VAR_2 . TYPE_6 . Status VAR_4 ) { <START> switch ( VAR_4 ) { <END> case VAR_5 : return TYPE_1 . VAR_5 ; case VAR_6 : return TYPE_1 . VAR_6 ; case VAR_7 : return TYPE_1 . VAR_7 ; case VAR_8 : return TYPE_1 . VAR_8 ; default : if ( VAR_4 != null ) { TYPE_3 . METHOD_2 ( STRING_1 + VAR_4 , new Exception ( ) ) ; } return TYPE_1 . VAR_9 ; } } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 element ) { <START> final TYPE_3 < TYPE_2 > node = VAR_1 . get ( element ) ; <END> if ( node != null ) { return new TYPE_4 < TYPE_2 > ( node ) . build ( ) ; } return Collections . VAR_2 ( ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 input ) { TYPE_4 super . METHOD_1 ( VAR_1 , input ) ; TYPE_3 VAR_3 = METHOD_2 ( ) ; <START> if ( VAR_3 != null ) { <END> METHOD_3 ( ) ; VAR_4 = VAR_3 . METHOD_4 ( ) . METHOD_5 ( VAR_3 . METHOD_6 ( ) , METHOD_7 ( ) . METHOD_8 ( ) ) ; VAR_4 . METHOD_9 ( VAR_5 ) ; VAR_4 . METHOD_10 ( ) ; } } 
public void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 && ! METHOD_2 ( ) ) { builder . VAR_2 ( ) ; <START> builder . VAR_3 ( STRING_1 ) ; <END> builder . VAR_2 ( ) ; } super . METHOD_1 ( VAR_1 ) ; } 
public String METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_1 != null ) { return ( String ) VAR_1 . getProperty ( VAR_2 ) ; } <START> return getName ( ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 trace ) { if ( ! ( trace instanceof TYPE_2 ) ) { return false ; } TYPE_2 VAR_1 = ( TYPE_2 ) trace ; String [ ] VAR_2 = { TYPE_3 . VAR_4 , TYPE_3 . VAR_5 } ; <START> return ( VAR_1 . METHOD_2 ( VAR_2 ) ) ; <END> } 
protected void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_2 ( VAR_2 ) ; } List < TYPE_1 > VAR_3 = VAR_4 . get ( METHOD_3 ( ) ) ; if ( VAR_3 == null ) { return ; } for ( TYPE_2 trace : VAR_2 ) { for ( TYPE_1 VAR_5 : VAR_3 ) { if ( VAR_5 . METHOD_4 ( trace ) ) { VAR_6 . put ( trace , VAR_5 ) ; break ; } } } } 
<START> public boolean METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = new TYPE_1 ( TYPE_2 . METHOD_2 ( ) , VAR_1 ) ; TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( TYPE_3 . class ) ; VAR_2 . METHOD_4 ( ) ; if ( VAR_3 != null && VAR_3 . METHOD_5 ( ) == TYPE_4 . VAR_5 ) { return true ; } return false ; } 
public TYPE_2 ( List < TYPE_1 > list , long VAR_2 , long VAR_3 ) { if ( list != null ) { VAR_4 = Collections . VAR_5 ( list ) ; <START> } <END> VAR_6 = VAR_2 ; VAR_7 = VAR_3 ; } 
public boolean METHOD_1 ( ) { <START> return false ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 [ ] VAR_3 , int VAR_4 , int VAR_5 , TYPE_4 VAR_6 ) { for ( int i = VAR_4 ; i < VAR_3 . length ; i ++ ) { TYPE_3 item = VAR_3 [ i ] ; METHOD_2 ( item , VAR_1 , VAR_2 , i , VAR_5 , VAR_6 ) ; <START> } <END> VAR_7 . METHOD_3 ( VAR_1 , VAR_6 ) ; } 
public void METHOD_1 ( TYPE_1 data ) { <START> if ( data != null && ! ( data instanceof TYPE_2 ) ) { <END> VAR_1 ++ ; } } 
private void METHOD_1 ( StringBuilder buffer ) { buffer . append ( STRING_1 ) ; <START> buffer . append ( STRING_2 ) ; <END> buffer . append ( STRING_3 ) ; buffer . append ( STRING_4 ) ; buffer . append ( STRING_5 ) ; buffer . append ( STRING_6 ) ; buffer . append ( STRING_7 ) ; buffer . append ( STRING_8 ) ; } 
public TYPE_3 ( TYPE_1 file ) throws IOException , TYPE_2 { VAR_2 = new HashMap < String , String > ( ) ; VAR_3 = new HashMap < String , String > ( ) ; <START> if ( file . VAR_4 ( ) . METHOD_1 ( ) <= 0 ) <END> return ; this . file = file ; parse ( ) ; } 
public TYPE_1 ( ) { <START> } <END> 
protected final List < TYPE_1 > METHOD_1 ( Collection < ? > values ) { List < TYPE_1 > VAR_1 = METHOD_2 ( values . size ( ) ) ; for ( Object value : values ) { <START> if ( value instanceof TYPE_2 ) { <END> TYPE_1 VAR_2 = METHOD_1 ( ( TYPE_2 ) value ) ; if ( VAR_2 != null ) { VAR_1 . add ( VAR_2 ) ; } } } return VAR_1 ; } 
private List < Object > METHOD_1 ( String VAR_1 ) { List < Object > VAR_2 = new ArrayList < Object > ( ) ; String VAR_3 = VAR_1 . trim ( ) ; TYPE_1 VAR_4 = METHOD_2 ( VAR_1 ) ; if ( VAR_4 == null ) <START> return null ; <END> TYPE_2 VAR_5 = VAR_4 . matcher ( VAR_3 ) ; if ( VAR_5 != null ) { while ( VAR_5 . METHOD_3 ( ) ) { VAR_2 . add ( VAR_5 . group ( ) ) ; } } return VAR_2 ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = false ; TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( VAR_3 != null ) { <START> return VAR_3 . METHOD_3 ( ) > TYPE_2 . VAR_4 ; <END> } return VAR_2 ; } 
public final TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( ! VAR_2 . containsKey ( VAR_1 ) ) { <END> return null ; } return VAR_2 . get ( VAR_1 ) ; } 
public void METHOD_1 ( String name , Object value ) { <START> synchronized ( VAR_1 ) { <END> if ( ! VAR_2 . contains ( name ) ) { throw new RuntimeException ( TYPE_1 . bind ( Messages . TYPE_2 , name , getName ( ) ) ) ; } Object VAR_4 = VAR_1 . get ( name ) ; VAR_1 . put ( name , value ) ; if ( ( value != null ) && ! ( value . equals ( VAR_4 ) ) ) { METHOD_2 ( name ) ; } } } 
<START> public void METHOD_1 ( TYPE_1 output ) { <END> VAR_1 . add ( output ) ; } 
<START> public static void METHOD_1 ( String VAR_1 , Class < ? extends TYPE_1 > VAR_2 ) { <END> if ( ! VAR_3 . containsKey ( VAR_1 ) ) { VAR_3 . put ( VAR_1 , new ArrayList < Class < ? extends TYPE_1 > > ( ) ) ; } VAR_3 . get ( VAR_1 ) . add ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 > VAR_1 ) { if ( VAR_1 != null ) { TYPE_1 < TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 > VAR_2 = VAR_1 ; if ( VAR_2 . METHOD_2 ( ) != null && VAR_2 . METHOD_2 ( ) != this ) { VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; } VAR_2 . METHOD_4 ( this ) ; } <START> VAR_3 . add ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { String query = STRING_1 ; String VAR_1 = "" ; List < TYPE_1 > results = null ; try { results = METHOD_2 ( query , VAR_1 ) ; } catch ( TYPE_2 e ) { <START> exception . VAR_2 ( TYPE_3 . class ) ; <END> exception . VAR_3 ( VAR_4 ) ; return ; } assertNotNull ( results ) ; } 
public void METHOD_1 ( ) throws Exception { String query = STRING_1 ; String VAR_1 = STRING_2 ; List < TYPE_1 > results = METHOD_2 ( query , VAR_1 ) ; <START> assertNotNull ( results ) ; <END> } 
public void METHOD_1 ( final String VAR_1 , final boolean state ) { <START> if ( VAR_1 . equals ( TYPE_1 . VAR_3 ) ) { <END> VAR_4 = state ; } } 
<START> public static void METHOD_1 ( ) { <END> if ( ! METHOD_2 ( ) ) METHOD_3 ( ) ; if ( ! METHOD_2 ( ) ) { TYPE_1 . METHOD_4 ( STRING_1 , null ) ; } else { METHOD_5 ( ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; if ( VAR_3 != null ) VAR_2 . METHOD_2 ( VAR_3 . METHOD_1 ( VAR_1 ) ) ; <START> for ( TYPE_3 VAR_4 : METHOD_3 ( ) ) <END> VAR_2 . METHOD_4 ( VAR_4 == null ? null : VAR_4 . METHOD_1 ( VAR_1 ) ) ; VAR_2 . METHOD_5 ( VAR_5 ) ; VAR_2 . METHOD_6 ( this ) ; if ( VAR_1 == TYPE_2 . VAR_6 ) { VAR_2 . METHOD_7 ( this ) ; } return VAR_2 ; } 
private TYPE_1 METHOD_1 ( TYPE_1 name ) { <START> if ( name instanceof TYPE_2 ) { <END> name = name . VAR_1 ( ) ; } return name ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 parent , TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = TYPE_3 . VAR_4 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( VAR_1 . name . METHOD_4 ( STRING_1 , STRING_2 ) ) ; <START> System . err . println ( VAR_2 ) ; <END> return VAR_2 ; } 
<START> public boolean METHOD_1 ( ) { <END> return ! ( VAR_1 . isEmpty ( ) && VAR_2 . isEmpty ( ) ) ; } 
<START> public static TYPE_1 METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = null ; TYPE_2 VAR_3 = ( TYPE_2 ) TYPE_3 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; TYPE_4 VAR_4 = VAR_3 . METHOD_4 ( STRING_1 ) ; if ( VAR_4 == null ) return null ; TYPE_5 [ ] VAR_5 = VAR_4 . METHOD_5 ( ) ; for ( TYPE_5 t : VAR_5 ) { if ( t instanceof TYPE_1 ) VAR_2 = ( TYPE_1 ) t ; } return VAR_2 ; } 
public void add ( Integer VAR_1 , Integer VAR_2 , Integer VAR_3 ) { <START> this . VAR_2 = VAR_2 ; <END> VAR_4 . add ( new Entry ( VAR_1 , VAR_2 , VAR_3 ) ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { boolean VAR_3 = false ; try { <START> VAR_3 = TYPE_3 . METHOD_1 ( ( TYPE_4 ) VAR_1 , VAR_2 ) ; <END> } catch ( TYPE_5 ex ) { TYPE_6 . log ( TYPE_7 . class , Level . VAR_4 , ex . toString ( ) , ex ) ; VAR_3 = false ; } return VAR_3 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , boolean VAR_3 ) { TYPE_3 VAR_4 ; try { VAR_4 = <START> TYPE_4 . METHOD_2 ( ( TYPE_5 ) VAR_1 , false , false , VAR_2 , VAR_3 ) ; <END> TYPE_6 . METHOD_3 ( VAR_4 , true ) ; } catch ( TYPE_7 ex ) { TYPE_8 . log ( TYPE_9 . class , Level . VAR_5 , ex . toString ( ) , ex ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_4 VAR_2 = VAR_3 . METHOD_2 ( ) . get ( 0 ) ; <START> for ( TYPE_4 res : VAR_3 . METHOD_2 ( ) ) <END> if ( res != VAR_2 ) TYPE_5 . METHOD_3 ( res ) ; VAR_2 . METHOD_4 ( VAR_4 ) ; TYPE_1 VAR_5 = super . METHOD_1 ( VAR_1 ) ; return VAR_5 ; } 
public TYPE_2 ( String VAR_2 ) { <START> this ( VAR_2 == null ? null : VAR_2 . isEmpty ( ) ? null : TYPE_1 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ) ; <END> } 
TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 , TYPE_2 project ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; this . project = project ; VAR_4 = new ArrayList < Thread > ( ) ; } 
public String METHOD_1 ( TYPE_1 element , int VAR_1 ) { <START> if ( element instanceof TYPE_1 ) { <END> switch ( VAR_1 ) { case 0 : return ( ( TYPE_1 ) element ) . VAR_2 ; case 1 : return ( ( TYPE_1 ) element ) . VAR_3 ; } } return "" ; } 
synchronized TYPE_1 METHOD_1 ( ) throws IOException { if ( VAR_1 || VAR_2 ) return null ; if ( VAR_3 == null && METHOD_2 ( VAR_4 ) ) { final TYPE_1 VAR_5 = TYPE_1 . METHOD_3 ( METHOD_4 ( VAR_4 ) , METHOD_5 ( ) , METHOD_6 ( ) ) ; <START> if ( ! Arrays . equals ( VAR_6 , VAR_5 . VAR_6 ) ) <END> VAR_2 = true ; else VAR_3 = VAR_5 ; } return VAR_3 ; } 
protected TYPE_1 ( String VAR_2 , String VAR_3 ) { this . VAR_3 = VAR_3 ; <START> this . VAR_2 = VAR_2 ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> Assert . VAR_4 ( VAR_3 != TYPE_2 . VAR_5 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_6 = null ; } 
protected boolean METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { return METHOD_2 ( ) . METHOD_1 ( ) ; } else { <START> return false ; <END> } } 
public boolean METHOD_1 ( String path ) { boolean VAR_1 = false ; if ( VAR_2 != null ) { VAR_1 = METHOD_2 ( path ) ; } else if ( TYPE_1 . METHOD_3 ( METHOD_4 ( ) ) ) { <START> VAR_1 = METHOD_5 ( path ) ; <END> } return VAR_1 ; } 
public Object METHOD_1 ( Object VAR_1 , Class VAR_2 ) { if ( VAR_2 == TYPE_1 . class ) { if ( VAR_3 == null ) { if ( VAR_1 instanceof TYPE_2 ) { TYPE_3 VAR_4 = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; if ( VAR_4 instanceof TYPE_4 ) { VAR_3 = new TYPE_5 ( null ) ; <START> TYPE_6 configuration = ( ( TYPE_4 ) VAR_4 ) <END> . METHOD_3 ( ) ; } } } return VAR_3 ; } return null ; } 
<START> public static void METHOD_1 ( ) { <END> List < String > VAR_1 = new ArrayList < String > ( ) ; for ( String s : VAR_2 ) { VAR_1 . add ( s ) ; } final int VAR_3 = INT_1 ; TYPE_1 VAR_4 = new TYPE_1 ( VAR_1 , INT_2 * Integer . VAR_5 - 100 , INT_3 , VAR_3 ) ; VAR_4 . METHOD_2 ( VAR_6 ) ; } 
private String METHOD_1 ( ) { TYPE_1 VAR_1 = getClass ( ) . METHOD_2 ( ) ; <START> if ( VAR_1 != null ) { <END> return VAR_1 . METHOD_1 ( ) ; } return null ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 file ) { final TYPE_1 uri ; String VAR_1 = file . VAR_2 ( ) . toString ( ) ; <START> if ( METHOD_2 ( VAR_1 ) ) { <END> uri = TYPE_1 . METHOD_3 ( VAR_1 , false ) ; } else { uri = TYPE_1 . METHOD_3 ( VAR_1 , true ) ; } return uri ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_1 VAR_2 = null ; <END> try { VAR_2 = TYPE_9 . TYPE_8 . METHOD_1 ( VAR_1 ) ; if ( VAR_2 != null ) { if ( ! VAR_2 . METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( new TYPE_4 ( ) ) ; } TYPE_5 VAR_3 = TYPE_7 . TYPE_8 . METHOD_4 ( VAR_2 ) ; VAR_3 . METHOD_3 ( ) ; } } catch ( IllegalStateException e ) { } return VAR_2 ; } 
public String toString ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; VAR_2 . METHOD_1 ( STRING_1 ) ; for ( Map . Entry < String , String > e : VAR_3 . entrySet ( ) ) <START> VAR_2 . METHOD_1 ( e . getKey ( ) + STRING_2 + e . getValue ( ) + STRING_3 ) ; <END> VAR_2 . close ( ) ; return VAR_1 . toString ( ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { VAR_3 = VAR_2 ; <START> new Throwable ( ) . METHOD_1 ( ) ; <END> } 
<START> public TYPE_1 ( ) { <END> METHOD_1 ( this ) ; } 
<START> String METHOD_1 ( String val , String VAR_1 ) { <END> if ( val == null || val . trim ( ) . equals ( "" ) ) { return VAR_1 ; } else { return val ; } } 
<START> synchronized public void METHOD_1 ( ) { <END> if ( METHOD_2 ( ) != null ) { try { METHOD_2 ( ) . close ( ) ; } catch ( Exception exception ) { TYPE_1 . log ( exception ) ; } } if ( METHOD_3 ( ) != null ) { try { METHOD_3 ( ) . close ( ) ; } catch ( Exception exception ) { TYPE_1 . log ( exception ) ; } } } 
<START> static synchronized void METHOD_1 ( TYPE_1 view ) { <END> VAR_1 . add ( view ) ; } 
<START> static void METHOD_1 ( TYPE_1 input , TYPE_2 VAR_1 ) { <END> int VAR_2 = ( int ) VAR_1 . METHOD_2 ( ) ; int VAR_3 = input . position ( ) + ( ( VAR_2 - ( input . position ( ) % VAR_2 ) ) % VAR_2 ) ; input . position ( VAR_3 ) ; } 
public void METHOD_1 ( String name , Class < ? extends TYPE_1 > type ) { super . METHOD_1 ( name ) ; VAR_1 = type ; VAR_2 = ( VAR_3 > 1 ) ? new TYPE_2 < TYPE_1 > ( VAR_3 ) : new TYPE_3 < TYPE_1 > ( ) ; <START> if ( VAR_4 != null ) { <END> VAR_4 . METHOD_2 ( ) ; } VAR_4 = new TYPE_4 ( ) ; VAR_5 = 0 ; VAR_6 = TYPE_5 . METHOD_3 ( ) ; TYPE_6 . METHOD_4 ( VAR_1 , this ) ; } 
private TYPE_6 ( ) { VAR_2 = new TYPE_1 < TYPE_2 , TYPE_3 > ( ) ; <START> VAR_3 = new TYPE_1 < TYPE_2 , TYPE_4 > ( ) ; <END> TYPE_5 . METHOD_1 ( this ) ; } 
public void METHOD_1 ( List < TYPE_1 < ? > > VAR_1 ) { <START> VAR_2 . clear ( ) ; <END> int VAR_3 = VAR_1 . size ( ) + VAR_2 . size ( ) ; for ( TYPE_1 < ? > VAR_4 : VAR_1 ) { this . METHOD_2 ( VAR_4 , VAR_3 ) ; VAR_3 -- ; } } 
public TYPE_11 ( String name , TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 < TYPE_4 > action , TYPE_5 VAR_3 , TYPE_6 VAR_4 ) { TYPE_7 < TYPE_4 > VAR_5 = TYPE_8 . METHOD_1 ( VAR_3 , action ) ; <START> TYPE_7 < TYPE_4 > job = TYPE_8 . METHOD_2 ( VAR_5 ) ; <END> VAR_6 = TYPE_9 . METHOD_3 ( VAR_2 , VAR_4 , TYPE_10 . METHOD_4 ( job ) ) ; } 
public boolean METHOD_1 ( ) { synchronized ( VAR_1 ) { <START> return VAR_2 ; <END> } } 
public synchronized void METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> VAR_2 = true ; } TYPE_1 . METHOD_2 ( VAR_3 , STRING_1 ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 type , TYPE_1 VAR_3 ) { super ( VAR_3 ) ; VAR_4 = - 1 ; VAR_5 = VAR_2 ; VAR_6 = type ; VAR_7 = type != null ; if ( VAR_5 == null ) { <START> TYPE_3 . log ( new TYPE_4 ( ) ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_5 . TYPE_6 . METHOD_2 ( ) ; <START> TYPE_3 . TYPE_4 . METHOD_2 ( ) ; <END> } 
<START> protected Double METHOD_1 ( Object o ) { <END> if ( o == null ) { return null ; } if ( o instanceof Integer ) { return ( double ) ( ( Integer ) o ) . METHOD_2 ( ) ; } if ( o instanceof Double ) { return ( ( Double ) o ) . METHOD_3 ( ) ; } try { return new Double ( o . toString ( ) ) . METHOD_3 ( ) ; } catch ( TYPE_1 e ) { return null ; } } 
public String toString ( ) { return String . format ( STRING_1 , VAR_1 . toString ( ) , VAR_2 . toString ( ) , <START> VAR_3 . toString ( ) ) ; <END> } 
private void METHOD_1 ( File VAR_1 ) { VAR_2 . METHOD_2 ( VAR_1 ) ; <START> if ( METHOD_3 ( ) ) { <END> METHOD_4 ( VAR_1 ) ; } } 
<START> public boolean equals ( Object obj ) { <END> return obj instanceof TYPE_1 && key . VAR_1 ( ) == obj . VAR_1 ( ) ; } 
public TYPE_1 METHOD_1 ( String path ) { for ( TYPE_2 VAR_1 : METHOD_2 ( ) ) { String VAR_2 = ( new <START> Path ( VAR_1 . getPath ( ) ) ) . METHOD_3 ( ) ; <END> if ( path . VAR_3 ( VAR_2 ) == 0 ) { return VAR_1 ; } } return null ; } 
private void METHOD_1 ( TYPE_1 parent ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( parent ) ; if ( VAR_1 != null ) { try { METHOD_3 ( parent , VAR_1 ) ; } catch ( IOException e ) { TYPE_3 . METHOD_4 ( <START> STRING_1 + parent . VAR_3 ( ) , e ) ; <END> } } } 
public TYPE_3 ( TYPE_1 VAR_2 , Collection < String > VAR_3 ) { super ( TYPE_6 . TYPE_4 ) ; METHOD_1 ( TYPE_6 . TYPE_5 ) ; METHOD_2 ( TYPE_6 . TYPE_2 ) ; this . VAR_2 = VAR_2 ; for ( String VAR_8 : VAR_3 ) { <START> if ( VAR_8 . startsWith ( Constants . VAR_9 ) ) { <END> VAR_10 . add ( VAR_8 ) ; } else { VAR_10 . add ( Constants . VAR_9 + VAR_8 ) ; } } } 
private void METHOD_1 ( boolean VAR_1 ) { final String VAR_2 ; if ( VAR_1 ) { VAR_2 = TYPE_2 . TYPE_3 ; } else { VAR_2 = TYPE_2 . TYPE_1 ; <START> } <END> METHOD_1 ( VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { TYPE_1 user = VAR_1 . METHOD_2 ( ) ; if ( user == null ) { <START> System . err . println ( STRING_1 ) ; <END> user = TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) ; } return user ; } 
private List < String > METHOD_1 ( ) { if ( VAR_1 != null ) { String VAR_2 = VAR_1 . get ( TYPE_1 . VAR_4 , TYPE_2 . VAR_6 ) ; if ( ! VAR_2 . isEmpty ( ) ) { return Arrays . asList ( VAR_2 . split ( TYPE_2 . VAR_7 ) ) ; } } <START> return TYPE_2 . VAR_8 ; <END> } 
public void METHOD_1 ( ) throws TYPE_1 { <START> VAR_1 = new TYPE_2 ( VAR_2 . VAR_3 . ByteBuffer . VAR_4 ( INT_1 ) ) ; <END> VAR_1 . METHOD_2 ( TYPE_3 . VAR_6 ) ; METHOD_3 ( VAR_1 ) ; } 
public TYPE_1 ( int VAR_2 ) { <START> this . value = new Integer ( VAR_2 ) ; <END> } 
public boolean equals ( ANNOTATION_1 Object object ) { if ( ! ( object instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) object ; <START> return this . METHOD_1 ( ) == VAR_1 . METHOD_1 ( ) ; <END> } 
<START> public String METHOD_1 ( ) { <END> if ( VAR_1 == null ) { List < String > VAR_2 = new ArrayList < String > ( ) ; for ( TYPE_1 element : getValue ( ) ) { VAR_2 . add ( element . VAR_3 ( ) ) ; } VAR_1 = VAR_2 . toString ( ) ; } return VAR_1 ; } 
private Set < String > METHOD_1 ( String key ) { String VAR_1 = METHOD_2 ( ) . getProperty ( key ) ; <START> if ( VAR_1 != null && VAR_1 . length ( ) > 0 ) { <END> return new HashSet < String > ( Arrays . asList ( VAR_1 . split ( STRING_1 ) ) ) ; } return Collections . VAR_2 ( ) ; } 
<START> private String METHOD_1 ( TYPE_1 VAR_1 ) { <END> String VAR_2 ; if ( VAR_1 . METHOD_2 ( ) ) VAR_2 = VAR_1 . METHOD_3 ( ) . getName ( ) ; else VAR_2 = VAR_1 . METHOD_4 ( ) . getName ( ) ; return VAR_2 ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( STRING_1 ) ; String result = VAR_1 . getValue ( ) ; assertNotNull ( result ) ; <START> assertEquals ( result , STRING_1 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 ; METHOD_2 ( VAR_1 ) ; try { METHOD_3 ( VAR_1 ) ; <START> METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( this ) ; <END> } catch ( TYPE_2 e ) { LOG . warn ( null , e ) ; } catch ( Throwable t ) { LOG . warn ( null , t ) ; } } 
public boolean METHOD_1 ( TYPE_1 entry , boolean VAR_1 ) { <START> return METHOD_1 ( null , false , null ) ; <END> } 
protected ANNOTATION_1 TYPE_1 METHOD_1 ( ) { TYPE_2 trace = METHOD_2 ( ) ; <START> if ( ! ( trace instanceof TYPE_3 ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } return new TYPE_4 ( ( TYPE_3 ) trace ) ; } 
public String METHOD_1 ( ) { <START> return new String ( ) ; <END> } 
public TYPE_4 ( String VAR_2 , TYPE_1 config , TYPE_2 session ) <START> throws TYPE_3 { <END> VAR_3 = VAR_2 ; VAR_4 = session ; VAR_5 = config ; } 
private TYPE_1 METHOD_1 ( TYPE_2 element ) { if ( element != null ) { for ( String VAR_1 : element . VAR_2 ( ) ) { if ( VAR_1 . startsWith ( TYPE_3 ) ) { <START> return TYPE_1 . parse ( VAR_1 . substring ( 5 ) ) ; <END> } } } return null ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { assert ( this . VAR_2 ) ; <START> if ( VAR_3 . size ( ) == 0 ) { <END> return ; } for ( int i = 0 ; i < VAR_3 . size ( ) ; i ++ ) { VAR_1 . add ( VAR_3 . get ( i ) ) ; } return ; } 
<START> public TYPE_1 < org . VAR_1 . VAR_2 . VAR_3 . description . filter . TYPE_2 > METHOD_1 ( ) { <END> if ( VAR_4 == null ) { VAR_4 = new TYPE_4 . TYPE_5 < org . VAR_1 . VAR_2 . VAR_3 . description . filter . TYPE_2 > ( org . VAR_1 . VAR_2 . VAR_3 . description . filter . TYPE_2 . class , this , TYPE_6 . VAR_6 ) ; } return VAR_4 ; } 
public int METHOD_1 ( TYPE_1 event , int VAR_1 ) { int VAR_2 = VAR_1 ; for ( TYPE_2 VAR_3 : VAR_4 ) { <START> VAR_2 = VAR_3 . METHOD_2 ( event , VAR_2 ) ; <END> } return VAR_2 ; } 
protected void METHOD_1 ( TYPE_1 node ) { <START> if ( METHOD_2 ( ) != null ) { <END> METHOD_2 ( ) . update ( node , null ) ; } } 
public String METHOD_1 ( ) { <START> return String . valueOf ( id ) ; <END> } 
public void start ( TYPE_1 context ) throws Exception { super . start ( context ) ; METHOD_1 ( this ) ; <START> TYPE_2 . METHOD_2 ( ) ; <END> } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> if ( VAR_1 == null ) { METHOD_2 ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( final boolean VAR_1 ) { if ( VAR_1 ) { <START> VAR_2 = VAR_3 ; <END> } else if ( VAR_2 != VAR_3 ) { VAR_2 = VAR_4 ; } if ( METHOD_2 ( ) instanceof TYPE_1 ) { ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_1 ( false ) ; } } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 project ) { <START> List < TYPE_1 > result = VAR_1 . get ( project ) ; <END> if ( result == null ) { result = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_2 ( project ) ) { result . add ( VAR_2 ) ; } } VAR_1 . put ( project , result ) ; } return result ; } 
<START> protected int METHOD_1 ( ) { <END> int VAR_1 = 0 ; synchronized ( VAR_2 ) { for ( TYPE_1 request : VAR_3 ) { if ( request . VAR_4 ( ) . equals ( TYPE_2 . VAR_6 ) ) { VAR_1 ++ ; } } } return VAR_1 ; } 
<START> private void METHOD_1 ( ) throws TYPE_1 { <END> METHOD_2 ( VAR_1 . exists ( ) ) ; VAR_2 = new TYPE_2 ( VAR_1 . METHOD_3 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 name ) throws TYPE_3 { <START> if ( VAR_1 . equals ( METHOD_2 ( ) ) ) <END> METHOD_1 ( name ) ; else new TYPE_4 ( METHOD_3 ( ) , record + VAR_2 ) . METHOD_1 ( VAR_1 , name ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ( VAR_1 . METHOD_2 ( TYPE_3 . TYPE_4 . name ( ) ) ) ; <END> } 
<START> public void set ( TYPE_1 VAR_1 ) { <END> this . VAR_2 = VAR_1 ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } <START> return this . VAR_1 . equals ( ( ( TYPE_1 ) obj ) . METHOD_1 ( ) ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> VAR_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; VAR_3 = new TYPE_2 ( ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; assertNotNull ( VAR_1 ) ; <START> assertEquals ( VAR_1 , TYPE_1 . METHOD_2 ( ) ) ; <END> TYPE_2 VAR_2 = new TYPE_2 ( TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) , STRING_1 ) ; TYPE_3 VAR_3 = new TYPE_3 ( STRING_2 , STRING_3 ) ; VAR_2 . METHOD_4 ( TYPE_5 . VAR_5 , VAR_3 , false ) ; TYPE_4 configuration = TYPE_1 . METHOD_2 ( ) . METHOD_5 ( VAR_2 ) ; METHOD_6 ( configuration ) ; } 
public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = 1 ; <START> result = VAR_1 * result + ( ( VAR_2 == null ) ? 0 : VAR_2 . METHOD_1 ( ) ) ; <END> return result ; } 
public Collection < TYPE_1 > METHOD_1 ( ) { <START> return VAR_1 . values ( ) ; <END> } 
<START> public Map < String , TYPE_1 > METHOD_1 ( TYPE_2 monitor ) throws TYPE_3 { <END> return METHOD_2 ( monitor , STRING_1 , new TYPE_4 < TYPE_5 , TYPE_1 [ ] > ( ) { public TYPE_1 [ ] apply ( TYPE_5 input ) { return input . VAR_1 ( ) ; } } , new TYPE_6 < TYPE_5 > ( ) { } ) ; } 
public void METHOD_1 ( String name , Class < ? extends TYPE_1 > type ) { super . METHOD_1 ( name ) ; VAR_1 = type ; VAR_2 = ( VAR_3 > 1 ) ? new TYPE_2 < TYPE_1 > ( VAR_3 ) : new TYPE_3 < TYPE_1 > ( ) ; VAR_4 . METHOD_1 ( ) ; VAR_5 = 0 ; synchronized ( VAR_6 ) { <START> VAR_7 = new TYPE_4 ( ) ; <END> } TYPE_5 . METHOD_2 ( VAR_1 , this ) ; } 
public void METHOD_1 ( Collection < ? extends TYPE_1 > VAR_1 ) throws IOException { if ( ! VAR_2 ) <START> METHOD_2 ( ) ; <END> for ( TYPE_1 id : VAR_1 ) METHOD_3 ( id ) . VAR_3 = TYPE_2 . VAR_5 ; } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( SWT . VAR_2 ) . METHOD_3 ( ) ; } 
protected void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( new TYPE_3 ( ) ) ; VAR_1 . METHOD_4 ( new TYPE_4 ( ) ) ; VAR_1 . METHOD_4 ( new TYPE_5 ( ) ) ; METHOD_5 ( ) . METHOD_6 ( VAR_1 ) ; <START> METHOD_7 ( ) ; <END> VAR_2 = new TYPE_6 ( STRING_1 ) ; } 
public TYPE_2 ( ) { <START> this . VAR_2 = new TYPE_1 ( ) ; <END> } 
<START> public TYPE_1 [ ] METHOD_1 ( ) { <END> Set < TYPE_1 > VAR_1 = new HashSet < TYPE_1 > ( ) ; VAR_1 . addAll ( VAR_2 . METHOD_2 ( ) ) ; for ( TYPE_1 VAR_3 : VAR_4 . METHOD_1 ( ) ) { VAR_1 . add ( VAR_3 ) ; } return VAR_1 . METHOD_3 ( new TYPE_1 [ 0 ] ) ; } 
public List < TYPE_1 < T > > METHOD_1 ( ) { ArrayList < TYPE_1 < T > > VAR_1 = TYPE_2 . METHOD_2 ( VAR_2 . values ( ) ) ; if ( VAR_1 . size ( ) > 0 ) { <START> Collections . VAR_3 ( VAR_1 ) ; <END> } return VAR_1 ; } 
private void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( VAR_1 , true ) ; METHOD_2 ( ) . METHOD_3 ( VAR_2 , VAR_3 ) ; if ( METHOD_2 ( ) . getString ( VAR_2 ) . equals ( VAR_4 ) || METHOD_2 ( ) . getString ( VAR_2 ) . equals ( VAR_5 ) <START> || METHOD_2 ( ) . getString ( VAR_2 ) . equals ( VAR_6 ) ) { <END> METHOD_2 ( ) . METHOD_4 ( VAR_2 , VAR_3 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 input ) throws TYPE_3 { METHOD_2 ( VAR_1 ) ; METHOD_3 ( input ) ; <START> if ( ! ( input instanceof TYPE_4 ) ) { <END> throw new TYPE_3 ( new Status ( TYPE_5 . VAR_3 , TYPE_6 . VAR_5 , STRING_1 ) ) ; } TYPE_4 VAR_6 = ( ( TYPE_4 ) input ) ; if ( VAR_6 != null ) { source = VAR_6 . METHOD_4 ( ) ; } } 
public TYPE_1 ( File VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> } 
public static void METHOD_1 ( ) { <START> final TYPE_1 c = new TYPE_1 ( ) ; <END> TYPE_2 . METHOD_2 ( c ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { boolean result ; <START> result = VAR_1 != null && VAR_1 . METHOD_2 ( ) == TYPE_1 . VAR_2 || VAR_1 . METHOD_2 ( ) == TYPE_1 . VAR_3 ; <END> return result ; } 
public static boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) || METHOD_3 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( METHOD_2 ( ) , METHOD_3 ( ) ) ; <END> return VAR_1 ; } 
public String METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> return "" ; } else { return VAR_1 ; } } 
public TYPE_2 ( TYPE_1 VAR_2 , String VAR_3 ) { super ( VAR_2 , VAR_3 ) ; <START> METHOD_1 ( false ) ; <END> METHOD_2 ( false ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { assert ( VAR_1 != null ) ; VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_2 [ ] VAR_3 = TYPE_3 . METHOD_3 ( VAR_2 ) ; if ( VAR_3 != null ) { this . VAR_4 . METHOD_4 ( VAR_3 . length < VAR_5 . METHOD_5 ( ) ) ; <START> } <END> METHOD_6 ( ) ; } 
public TYPE_1 ( String VAR_2 , String VAR_3 , long VAR_4 , String VAR_5 , long line ) { VAR_6 = VAR_2 ; VAR_7 = VAR_5 ; VAR_8 = VAR_3 ; <START> this . VAR_9 = VAR_4 ; <END> this . VAR_10 = line ; } 
protected T METHOD_1 ( T VAR_1 ) throws TYPE_1 { T VAR_2 ; if ( VAR_1 == null ) { VAR_2 = null ; } else { <START> T t = TYPE_2 . METHOD_2 ( VAR_1 , METHOD_3 ( ) ) ; <END> TYPE_3 b = METHOD_4 ( t ) ; if ( b != null ) { VAR_2 = t ; } else { throw new TYPE_1 ( STRING_1 + VAR_1 ) ; } } return VAR_2 ; } 
public TYPE_1 < T > METHOD_1 ( T value ) { for ( TYPE_1 < T > b : METHOD_2 ( ) ) { <START> T VAR_1 = TYPE_2 . METHOD_3 ( b . VAR_2 ( ) , METHOD_4 ( ) ) ; <END> if ( TYPE_3 . equals ( VAR_1 , value ) ) { return b ; } } return null ; } 
protected void METHOD_1 ( ) throws TYPE_1 { METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) . METHOD_6 ( ) ) ; METHOD_7 ( ) . METHOD_8 ( METHOD_5 ( ) . METHOD_9 ( ) ) ; <START> METHOD_7 ( ) . METHOD_10 ( ( TYPE_2 ) METHOD_5 ( ) . METHOD_11 ( ) ) ; <END> METHOD_12 ( ) . METHOD_13 ( METHOD_5 ( ) . METHOD_14 ( ) != null ) ; METHOD_12 ( ) . METHOD_15 ( METHOD_5 ( ) . METHOD_14 ( ) ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> this . VAR_4 = VAR_2 ; <END> this . VAR_5 = VAR_3 ; } 
public TYPE_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 trace ) { <START> this . VAR_3 = trace ; <END> this . VAR_4 = VAR_2 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_1 VAR_2 = METHOD_1 ( new TYPE_3 ( ) , VAR_1 ) ; <END> for ( TYPE_4 VAR_3 : TYPE_5 . trim ( VAR_4 ) ) { VAR_2 . METHOD_2 ( VAR_3 . METHOD_1 ( VAR_1 ) ) ; } return VAR_2 ; } 
public void METHOD_1 ( String key , String value ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( key ) . METHOD_4 ( value ) ; <END> METHOD_5 ( key , value ) ; } 
protected ArrayList < TYPE_1 > METHOD_1 ( TYPE_2 in ) { <START> TYPE_3 < ArrayList < TYPE_1 > > <END> type = new TYPE_3 < ArrayList < TYPE_1 > > ( ) { } ; return new TYPE_4 ( ) . METHOD_2 ( type . getType ( ) , new TYPE_5 ( ) ) . METHOD_3 ( VAR_1 ) . create ( ) . METHOD_4 ( in , type . getType ( ) ) ; } 
public TYPE_1 build ( ) { if ( VAR_1 ) { <START> TYPE_2 . METHOD_1 ( VAR_2 == null || VAR_2 . size ( ) == 1 ) ; <END> } boolean VAR_3 = VAR_4 != null ; if ( VAR_3 ) { TYPE_2 . METHOD_1 ( VAR_5 != null ) ; } final TYPE_1 VAR_6 = new TYPE_1 ( parent , VAR_7 , VAR_3 ) ; TYPE_3 VAR_8 = METHOD_2 ( VAR_6 ) ; if ( VAR_3 ) { METHOD_3 ( VAR_6 ) ; } METHOD_4 ( VAR_8 ) ; METHOD_5 ( VAR_6 , VAR_8 ) ; return VAR_6 ; } 
public static void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { <START> final List < TYPE_2 > VAR_3 = VAR_2 . METHOD_2 ( ) ; <END> for ( TYPE_2 view : VAR_3 ) { if ( view . VAR_4 ( ) . METHOD_3 ( ) . equals ( VAR_1 . METHOD_3 ( ) ) ) { view . close ( ) ; VAR_2 . METHOD_4 ( TYPE_3 . METHOD_5 ( view ) ) ; } } } 
public static String METHOD_1 ( String VAR_1 ) { try ( TYPE_1 VAR_2 = new TYPE_1 ( new TYPE_2 ( VAR_1 ) ) ) { TYPE_3 buffer = new TYPE_3 ( ) ; String line ; while ( ( line = VAR_2 . METHOD_2 ( ) ) != null ) { buffer . append ( line . VAR_3 ( STRING_1 ) ) ; } return METHOD_3 ( buffer . toString ( ) ) ; } catch ( IOException e ) { <START> e . VAR_4 ( ) ; <END> return "" ; } } 
<START> public static void METHOD_1 ( TYPE_1 source ) { <END> synchronized ( VAR_1 ) { VAR_1 . add ( source ) ; METHOD_2 ( ) ; } } 
<START> public static Map < String , TYPE_1 > METHOD_1 ( ) { <END> synchronized ( VAR_1 ) { if ( VAR_1 . isEmpty ( ) ) { for ( TYPE_2 source : VAR_2 ) { for ( TYPE_1 VAR_3 : source . VAR_4 ( ) ) { VAR_1 . put ( VAR_3 . getId ( ) , VAR_3 ) ; } } } } return Collections . VAR_5 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( "" , "" ) ; METHOD_2 ( "" , STRING_1 ) ; METHOD_2 ( STRING_1 , STRING_2 ) ; METHOD_2 ( STRING_3 , STRING_4 ) ; METHOD_2 ( STRING_5 , STRING_6 ) ; <START> assertEquals ( 0 , METHOD_3 ( "" , "" ) ) ; <END> assertEquals ( 0 , METHOD_3 ( STRING_1 , STRING_1 ) ) ; assertTrue ( METHOD_3 ( "" , STRING_1 ) < 0 ) ; assertTrue ( METHOD_3 ( STRING_1 , "" ) > 0 ) ; } 
private boolean METHOD_1 ( byte [ ] buf , int p ) { <START> if ( VAR_1 || VAR_2 ) <END> return METHOD_2 ( buf [ p ] ) == CHAR_1 && METHOD_2 ( buf [ p + 1 ] ) == CHAR_2 && METHOD_2 ( buf [ p + 2 ] ) == CHAR_3 ; return buf [ p ] == CHAR_1 && buf [ p + 1 ] == CHAR_2 && buf [ p + 2 ] == CHAR_3 ; } 
void METHOD_1 ( long id , long VAR_1 , long VAR_2 ) { VAR_3 . METHOD_2 ( ) ; <START> if ( VAR_4 . length > 0 ) { <END> METHOD_3 ( VAR_4 [ ( int ) VAR_5 . METHOD_4 ( ) ] ) ; } } 
public void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; } } 
protected TYPE_1 execute ( TYPE_2 client , TYPE_3 monitor ) throws TYPE_4 { <START> return client . VAR_1 ( METHOD_1 ( ) , getMessage ( ) , METHOD_2 ( ) , METHOD_3 ( ) , METHOD_4 ( ) , monitor , METHOD_5 ( ) ) ; <END> } 
private boolean METHOD_1 ( ) { <START> if ( TYPE_1 . METHOD_2 ( ) . equals ( TYPE_1 . VAR_1 ) ) { <END> return true ; } return false ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 . METHOD_2 ( VAR_3 ) ; if ( VAR_2 == null ) { <START> if ( VAR_2 == null ) { <END> VAR_2 = new TYPE_1 ( VAR_1 ) ; VAR_1 . METHOD_3 ( VAR_3 , VAR_2 ) ; } } return VAR_2 ; } 
public void METHOD_1 ( long id , File VAR_1 ) throws TYPE_1 { if ( ! VAR_2 . containsKey ( id ) ) { VAR_2 . put ( id , new TYPE_2 ( this ) ) ; } <START> TYPE_2 stream = VAR_2 . get ( id ) ; <END> stream . VAR_3 ( new TYPE_3 ( stream , VAR_1 ) ) ; } 
public void METHOD_1 ( long VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
public void METHOD_1 ( final ANNOTATION_1 TYPE_1 event ) { super . METHOD_1 ( event ) ; if ( event != null && event . VAR_1 ( ) != trace ) { <START> System . out . println ( STRING_1 ) ; <END> } if ( event != null && event . VAR_1 ( ) == trace ) { VAR_2 . METHOD_2 ( event ) ; } } 
<START> int METHOD_1 ( TYPE_1 entry ) { <END> TYPE_2 item = VAR_1 . get ( entry ) ; if ( item == null ) { return - 1 ; } return item . VAR_2 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 commit ) { <START> if ( commit . VAR_3 ( ) != 1 ) { <END> throw new TYPE_3 ( STRING_1 ) ; } this . VAR_2 = VAR_2 ; this . commit = commit ; } 
public void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_2 ( VAR_4 ) ; VAR_1 . METHOD_2 ( VAR_5 ) ; VAR_1 . METHOD_2 ( VAR_6 ) ; } 
public void METHOD_1 ( ) { VAR_1 . add ( null ) ; <START> assertTrue ( VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 listener ) { <START> if ( METHOD_2 ( listener ) ) { <END> VAR_1 . remove ( listener ) ; } } 
public String METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = TYPE_1 . METHOD_2 ( METHOD_3 ( ) . getClass ( ) ) ; } <START> System . err . println ( VAR_1 ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null || VAR_1 . getName ( ) == null || <START> VAR_1 . getName ( ) . equals ( this . getName ( ) ) ) { <END> throw new IllegalArgumentException ( ) ; } VAR_2 . put ( VAR_1 . getName ( ) , VAR_1 ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> List < TYPE_2 > VAR_1 = new ArrayList < > ( ) ; <END> TYPE_3 factory = new TYPE_3 ( ) ; switch ( VAR_2 ) { case VAR_3 : VAR_1 . add ( factory . VAR_4 ( ) ) ; VAR_1 . add ( factory . VAR_5 ( ) ) ; break ; case VAR_6 : VAR_1 . add ( factory . VAR_7 ( ) ) ; VAR_1 . add ( factory . VAR_5 ( ) ) ; break ; default : break ; } return VAR_1 ; } 
public int METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; int VAR_2 = 0 ; if ( VAR_1 instanceof TYPE_2 ) { VAR_2 = ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( ) . length ; if ( VAR_1 instanceof TYPE_3 ) { for ( TYPE_4 VAR_3 : ( ( TYPE_3 ) VAR_1 ) . METHOD_4 ( ) ) { if ( VAR_3 . METHOD_5 ( ) ) { <START> System . err . println ( STRING_1 ) ; <END> break ; } else { VAR_2 ++ ; } } } } return VAR_2 ; } 
TYPE_1 ( String name , String path , String VAR_2 ) { this . name = name ; this . path = path ; this . VAR_2 = new HashSet < String > ( ) ; <START> if ( VAR_2 != null && VAR_2 . length ( ) > 0 ) { <END> this . VAR_2 . addAll ( Arrays . asList ( VAR_2 . split ( STRING_1 ) ) ) ; } } 
void METHOD_1 ( ) throws IOException { TYPE_1 input = new TYPE_1 ( VAR_1 ) ; TYPE_2 output = new TYPE_2 ( VAR_2 ) ; try { TYPE_3 channel = input . VAR_3 ( ) ; output . VAR_3 ( ) . METHOD_2 ( channel , 0 , channel . size ( ) ) ; <START> } finally { input . close ( ) ; output . close ( ) ; } <END> } 
void METHOD_1 ( ) throws IOException { TYPE_1 input = new TYPE_1 ( VAR_1 ) ; TYPE_2 output = new TYPE_2 ( VAR_2 ) ; <START> TYPE_3 channel = input . VAR_3 ( ) ; output . VAR_3 ( ) . METHOD_2 ( channel , 0 , channel . size ( ) ) ; input . close ( ) ; output . close ( ) ; <END> } 
private static Map < String , String > METHOD_1 ( TYPE_1 configuration ) throws IOException { <START> Map < String , String > VAR_1 = new HashMap < String , String > ( TYPE_2 . METHOD_2 ( ) ) ; <END> VAR_1 . METHOD_3 ( configuration . VAR_2 ( ) ) ; return VAR_1 ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return version ; } 
public boolean METHOD_1 ( ) { <START> return Type . VAR_1 . equals ( type ) && TYPE_3 . TYPE_2 . METHOD_2 ( version ) < 0 ; <END> } 
private static TYPE_1 METHOD_1 ( long start , long VAR_1 ) { <START> return System . out . format ( STRING_1 , FLOAT_1 * ( VAR_1 - start ) ) ; <END> } 
boolean add ( TYPE_1 VAR_1 ) { if ( VAR_2 . METHOD_1 ( VAR_1 ) ) return false ; <START> else { <END> VAR_2 . add ( VAR_1 ) ; return true ; } } 
public Response METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 ) { Response response ; TYPE_1 result = VAR_2 . METHOD_2 ( VAR_3 , VAR_1 ) ; if ( result == null ) { response = Response . status ( Response . Status . VAR_4 ) . entity ( TYPE_3 . TYPE_4 ) . build ( ) ; } else { <START> response = Response . status ( Response . Status . VAR_7 ) . entity ( TYPE_2 . METHOD_3 ( result ) ) . build ( ) ; <END> } return response ; } 
public TYPE_9 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { TYPE_2 VAR_4 = TYPE_3 . METHOD_1 ( VAR_3 , this ) ; <START> this . VAR_5 = new TYPE_4 ( ) ; <END> this . VAR_6 = new TYPE_5 ( VAR_2 , VAR_4 ) ; this . VAR_7 = new TYPE_6 ( VAR_2 , VAR_4 ) ; this . VAR_8 = new TYPE_7 ( VAR_2 , VAR_4 ) ; this . VAR_9 = new TYPE_8 ( VAR_2 , VAR_4 ) ; } 
public void METHOD_1 ( final TYPE_1 monitor ) throws TYPE_2 { try { ( new TYPE_3 < Integer > ( this ) { @Override public Integer execute ( ) throws TYPE_2 { call ( monitor , VAR_1 ) ; return - 1 ; } } ) . execute ( ) ; <START> } catch ( TYPE_2 e ) { <END> e . VAR_2 ( ) ; throw e ; } finally { VAR_3 = - 1 ; token = null ; } return ; } 
public void METHOD_1 ( final TYPE_1 monitor ) throws TYPE_2 { VAR_1 = - 1 ; token = null ; ( new TYPE_3 < Integer > ( this ) { ANNOTATION_1 ( STRING_1 ) @Override public Integer execute ( ) throws TYPE_2 { try { <START> VAR_2 . METHOD_2 ( null ) ; <END> } catch ( TYPE_4 e ) { e . VAR_3 ( ) ; } Object response = call ( monitor , VAR_4 , null ) ; return - 1 ; } } ) . execute ( ) ; return ; } 
<START> public static boolean METHOD_1 ( byte [ ] VAR_1 ) { <END> return VAR_1 . length > 4 && VAR_1 [ 0 ] == CHAR_1 && VAR_1 [ 1 ] == CHAR_2 && VAR_1 [ 2 ] == 3 && VAR_1 [ 3 ] == 4 ; } 
public void METHOD_1 ( String VAR_1 , File file ) throws Exception { TYPE_1 VAR_2 = METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( file , new File ( METHOD_4 ( ) , VAR_1 ) ) ; <START> VAR_2 . add ( ) . METHOD_5 ( STRING_1 ) . call ( ) ; <END> } 
<START> private TYPE_1 < byte [ ] > empty ( ) { <END> return METHOD_1 ( byte [ ] . class ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; } if ( VAR_2 != null ) { VAR_2 . METHOD_1 ( ) ; <START> } <END> } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 resource , Messages Messages ) { super ( VAR_2 ) ; this . resource = resource ; this . Messages = Messages ; <START> TYPE_3 . METHOD_1 ( ) . METHOD_2 ( this ) ; <END> } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = ( TYPE_1 ) TYPE_3 . TYPE_4 . METHOD_2 ( ) ; <END> assertNotNull ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 resource , String path , Class < ? extends TYPE_2 > type ) throws TYPE_3 { super . METHOD_1 ( resource , path , type ) ; VAR_1 = new File ( path ) ; try { <START> VAR_2 = new TYPE_4 ( VAR_1 , STRING_1 ) ; <END> METHOD_2 ( ) ; } catch ( IOException e ) { } } 
public Object METHOD_1 ( Object element , Class key ) { <START> TYPE_1 VAR_1 = ( TYPE_1 ) element ; <END> if ( TYPE_2 . class . equals ( key ) ) { return new TYPE_3 ( VAR_1 ) ; } return null ; } 
public void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> VAR_1 . close ( ) ; } if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( ) ; File VAR_3 = new File ( TYPE_1 . METHOD_3 ( VAR_2 ) ) ; METHOD_4 ( VAR_3 ) ; } } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> ArrayList < TYPE_1 > VAR_1 = new ArrayList < > ( VAR_2 ) ; VAR_1 . METHOD_2 ( Collections . VAR_3 ( null ) ) ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( String string ) { <START> for ( TYPE_1 state : new TYPE_2 < TYPE_1 > ( VAR_1 ) ) { <END> if ( state . getName ( ) . equals ( string ) ) { return state ; } } return null ; } 
public TYPE_1 METHOD_1 ( TYPE_2 context , TYPE_3 VAR_1 ) { <START> if ( VAR_1 == null ) { <END> return TYPE_1 . VAR_2 ; } return TYPE_1 . VAR_3 ; } 
public void METHOD_1 ( int VAR_1 ) { int VAR_2 = VAR_3 . size ( ) + 1 ; if ( ! METHOD_2 ( ) ) { throw new TYPE_1 ( STRING_1 ) ; } <START> String VAR_4 = STRING_2 ; <END> METHOD_3 ( VAR_2 , false ) ; int VAR_5 = 1 ; while ( ! VAR_4 . equals ( VAR_6 ) && VAR_5 <= VAR_1 ) { VAR_4 = VAR_6 ; METHOD_4 ( VAR_5 ++ ) ; METHOD_3 ( VAR_2 , false ) ; } METHOD_3 ( VAR_2 , true ) ; } 
private TYPE_1 [ ] METHOD_1 ( ) { <START> TYPE_1 [ ] VAR_1 = new TYPE_1 [ 10 ] ; <END> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { VAR_1 [ i ] = new TYPE_1 ( i ) ; } return VAR_1 ; } 
private TYPE_1 [ ] METHOD_1 ( ) { <START> TYPE_1 [ ] VAR_1 = new TYPE_1 [ INT_1 ] ; <END> for ( int i = 0 ; i < VAR_1 . length - 1 ; i ++ ) { VAR_1 [ i ] = new TYPE_1 ( i ) ; } VAR_1 [ VAR_1 . length - 1 ] = new TYPE_1 ( INT_2 ) ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( String name ) { TYPE_2 VAR_1 = METHOD_2 ( name ) ; <START> return ( TYPE_1 ) ( ( VAR_1 . METHOD_3 ( ) instanceof TYPE_3 ) ? VAR_1 : null ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = this ; while ( VAR_1 . METHOD_2 ( ) != null && VAR_1 . METHOD_2 ( ) . METHOD_2 ( ) != null ) { VAR_1 = VAR_1 . METHOD_2 ( ) ; <START> } <END> } return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = STRING_1 ; METHOD_2 ( VAR_1 , STRING_2 ) ; VAR_2 . add ( ) . METHOD_3 ( VAR_1 ) . call ( ) ; TYPE_1 VAR_3 = VAR_2 . METHOD_4 ( ) . call ( ) ; <START> assertNotNull ( VAR_3 ) ; <END> METHOD_5 ( VAR_3 ) ; assertTrue ( STRING_3 , VAR_4 . exists ( ) ) ; assertEquals ( STRING_4 , read ( VAR_4 ) ) ; } 
private static boolean METHOD_1 ( TYPE_1 [ ] VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_2 . getType ( ) == TYPE_1 . VAR_3 ) return true ; else if ( VAR_2 . getType ( ) == TYPE_1 . VAR_4 ) <START> return METHOD_2 ( VAR_2 ) ; <END> } return false ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) ; if ( VAR_1 != null ) { <START> this . VAR_1 = VAR_1 ; <END> VAR_1 . METHOD_3 ( this ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; } } 
protected void METHOD_1 ( TYPE_1 resource , IOException exception ) throws RuntimeException { try { super . METHOD_1 ( resource , exception ) ; <START> } catch ( Exception e ) { <END> } } 
public void METHOD_1 ( TYPE_1 listener ) { <START> if ( ! METHOD_2 ( listener ) ) { <END> VAR_1 . add ( listener ) ; } } 
private TYPE_1 [ ] METHOD_1 ( int offset ) { TYPE_1 [ ] VAR_1 = null ; boolean VAR_2 = false ; try { if ( VAR_3 != null ) { VAR_1 = VAR_4 . METHOD_2 ( VAR_3 , offset ) ; } else { VAR_1 = VAR_4 . METHOD_2 ( VAR_5 , offset ) ; } <START> VAR_2 = true ; <END> } finally { if ( ! VAR_2 ) { METHOD_3 ( ) ; } } return VAR_1 ; } 
public void METHOD_1 ( Thread t , Throwable e ) { if ( e instanceof TYPE_1 ) { } else { <START> if ( VAR_1 != null ) { <END> VAR_1 . add ( TYPE_2 . METHOD_2 ( e ) ) ; } else { TYPE_3 . METHOD_3 ( ) . log ( e ) ; } } } 
private String [ ] METHOD_1 ( ) { String [ ] VAR_1 = { STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , STRING_8 , STRING_9 , STRING_10 , STRING_11 , <START> STRING_12 } ; <END> return VAR_1 ; } 
public Collection < TYPE_1 > call ( ) throws TYPE_2 , TYPE_3 , org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_4 { <START> return METHOD_1 ( ) . values ( ) ; <END> } 
<START> private void METHOD_1 ( ) { <END> if ( ! VAR_1 ) { for ( TYPE_1 VAR_2 : TYPE_2 . METHOD_2 ( TYPE_6 . TYPE_4 , TYPE_3 . METHOD_3 ( ) ) ) { TYPE_4 user = ( TYPE_4 ) VAR_2 ; TYPE_5 VAR_5 = new TYPE_5 ( user ) ; VAR_6 . put ( user . VAR_7 ( ) , VAR_5 ) ; VAR_8 . put ( user . getName ( ) , VAR_5 ) ; } VAR_1 = true ; } } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> METHOD_4 ( ) ; } 
<START> protected void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <START> super ( STRING_1 , VAR_5 , VAR_2 , VAR_3 == null <END> ? ( TYPE_4 . METHOD_1 ( ) == null ? new TYPE_4 ( ) : TYPE_4 . METHOD_1 ( ) ) : VAR_3 , VAR_4 == null ? new TYPE_5 ( ) : VAR_4 ) ; METHOD_2 ( true ) ; METHOD_3 ( true ) ; } 
private boolean METHOD_1 ( ) throws IOException { TYPE_1 repo = METHOD_2 ( ) ; TYPE_2 VAR_1 = new TYPE_2 ( repo ) ; VAR_1 . METHOD_3 ( true ) ; final TYPE_3 VAR_2 = repo . VAR_3 ( STRING_1 ) ; if ( VAR_2 != null ) <START> VAR_1 . METHOD_4 ( new TYPE_4 ( repo ) . METHOD_5 ( VAR_2 ) ) ; <END> VAR_1 . METHOD_4 ( new TYPE_5 ( repo . VAR_4 ( ) ) ) ; VAR_1 . METHOD_6 ( TYPE_6 . VAR_6 ) ; return VAR_1 . next ( ) ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> for ( TYPE_1 VAR_1 : this . VAR_2 ) { <END> VAR_1 . METHOD_1 ( ) ; } } 
public boolean add ( Object o ) { if ( ! ( o instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = TYPE_2 . METHOD_1 ( ( TYPE_1 ) o , VAR_2 ) ; TYPE_3 command = new TYPE_4 ( VAR_2 , VAR_1 , ( TYPE_5 ) VAR_3 ) ; VAR_4 . add ( command ) ; <START> VAR_4 . add ( new TYPE_4 ( VAR_2 , VAR_1 , ( TYPE_5 ) VAR_3 ) ) ; <END> return VAR_5 . add ( o ) ; } 
public TYPE_4 ( TYPE_1 set , TYPE_2 parent , Collection < TYPE_3 > VAR_2 ) { super ( set ) ; this . VAR_2 = VAR_2 ; <START> this . parent = parent ; <END> } 
void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> if ( VAR_1 == null ) return ; VAR_1 . METHOD_3 ( false ) ; } 
void METHOD_1 ( int x , int y ) { <START> METHOD_2 ( ) ; <END> if ( VAR_1 == null ) return ; VAR_1 . METHOD_3 ( x , y ) ; VAR_1 . METHOD_4 ( true ) ; } 
int METHOD_1 ( ) { if ( ( state & VAR_1 ) != 0 ) return 0 ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; if ( VAR_3 != 0 ) { METHOD_2 ( VAR_3 , VAR_2 ) ; return VAR_2 . VAR_4 ; } else { return 0 ; <START> } <END> } 
public void METHOD_1 ( ) { <START> ANNOTATION_1 ( STRING_1 ) <END> TYPE_1 result = VAR_1 . METHOD_2 ( VAR_2 ) ; METHOD_3 ( result ) ; } 
private void METHOD_1 ( Object element , boolean VAR_1 ) { <START> VAR_2 . METHOD_2 ( element , VAR_1 ) ; <END> if ( VAR_1 ) { VAR_2 . METHOD_3 ( element , false ) ; } VAR_2 . METHOD_2 ( element , VAR_1 ) ; Object [ ] VAR_3 = VAR_4 . METHOD_4 ( element ) ; if ( VAR_3 != null ) { for ( Object child : VAR_3 ) { METHOD_1 ( child , VAR_1 ) ; } } } 
public void METHOD_1 ( ) { <START> if ( VAR_1 . METHOD_2 ( ) != null ) { <END> VAR_1 . METHOD_3 ( ) . remove ( this ) ; } VAR_1 = null ; session = null ; } 
public void close ( ) { <START> VAR_1 = TYPE_1 . VAR_3 ; <END> } 
<START> private ANNOTATION_1 static List < TYPE_1 > METHOD_1 ( int size , int VAR_1 ) { <END> List < TYPE_1 > VAR_2 = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { String content = STRING_1 + i ; VAR_2 . add ( new TYPE_2 ( TYPE_3 . METHOD_2 ( VAR_1 , false , INT_1 , TYPE_5 . VAR_4 , TYPE_4 . VAR_6 , content , INT_2 ) , null , content , i ) ) ; } return VAR_2 ; } 
<START> ANNOTATION_1 ByteBuffer METHOD_1 ( long position , long size ) throws TYPE_1 , IOException { <END> TYPE_2 map = VAR_1 . map ( TYPE_3 . VAR_3 , position , size ) ; if ( map == null ) { throw new TYPE_1 ( STRING_1 ) ; } return map ; } 
public TYPE_1 METHOD_1 ( Object VAR_1 , int VAR_2 ) { if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 item = ( TYPE_2 ) VAR_1 ; String state = item . VAR_3 ( TYPE_2 . VAR_4 ) ; if ( state != null ) { <START> if ( state . equals ( STRING_1 ) ) { <END> return VAR_5 ; } else if ( state . equals ( STRING_2 ) ) { return VAR_6 ; } } } return VAR_7 ; } 
public void METHOD_1 ( boolean VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> if ( ! VAR_1 ) { <END> METHOD_2 ( null ) ; } } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { int result = 0 ; Object VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 instanceof TYPE_3 || VAR_2 instanceof TYPE_4 || VAR_2 instanceof TYPE_5 ) { <START> result = 2 ; <END> } METHOD_3 ( ) ; return result ; } 
private TYPE_1 METHOD_1 ( TYPE_2 writer , boolean VAR_1 ) { TYPE_3 VAR_2 = builder . add ( TYPE_4 . VAR_4 ) . METHOD_2 ( VAR_1 ) . METHOD_3 ( "" , "" ) . name ( STRING_1 ) . create ( ) ; <START> return VAR_2 . METHOD_4 ( writer ) ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_2 project ) { TYPE_3 VAR_1 = TYPE_4 . METHOD_2 ( project ) ; <START> TYPE_1 TYPE_5 = VAR_1 . METHOD_3 ( ) ; <END> return TYPE_5 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( ) ; } TYPE_2 VAR_2 = TYPE_3 . getInstance ( ) . METHOD_2 ( ) ; if ( VAR_2 == null ) { VAR_3 = VAR_1 ; return ; } <START> ANNOTATION_1 ( STRING_1 ) <END> TYPE_1 VAR_4 = VAR_2 . METHOD_3 ( VAR_1 . getId ( ) ) ; if ( VAR_4 == VAR_1 ) { VAR_3 = VAR_1 ; } } 
<START> public TYPE_4 . TYPE_5 METHOD_1 ( ) { <END> TYPE_2 VAR_1 = new TYPE_2 ( TYPE_6 . TYPE_7 . TYPE_5 . VAR_5 , TYPE_3 . METHOD_2 ( VAR_6 ) ) ; return VAR_1 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> try ( TYPE_3 VAR_1 = METHOD_2 ( ) ; ) { <END> if ( VAR_1 != null ) { return VAR_1 . METHOD_1 ( ) ; } return Collections . VAR_2 ; } } 
<START> protected int METHOD_1 ( ) { <END> int start ; if ( VAR_1 instanceof TYPE_1 ) { TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 ; start = VAR_2 . METHOD_2 ( ) ; } else { start = VAR_3 . METHOD_3 ( ) ; } return start ; } 
public void METHOD_1 ( boolean VAR_1 ) { METHOD_2 ( ) ; TYPE_1 event = null ; synchronized ( TYPE_4 . this ) { if ( VAR_1 != VAR_3 ) { VAR_3 = VAR_1 ; if ( VAR_1 ) { VAR_4 = new TYPE_2 ( TYPE_4 . VAR_5 ) ; } <START> else if ( VAR_4 != null ) <END> { VAR_4 . METHOD_3 ( ) ; VAR_4 = null ; } event = new TYPE_3 ( VAR_1 ) ; } } METHOD_4 ( event ) ; } 
<START> public Collection < TYPE_1 < TYPE_2 , TYPE_3 > > METHOD_1 ( ) <END> { return new ArrayList < TYPE_5 . TYPE_1 < TYPE_2 , TYPE_3 > > ( VAR_1 . values ( ) ) ; } 
public static void METHOD_1 ( ) { TYPE_1 job = new TYPE_1 ( TYPE_6 . TYPE_7 ) { @Override protected TYPE_2 run ( TYPE_3 monitor ) { if ( TYPE_4 . METHOD_2 ( ) ) TYPE_4 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( new TYPE_5 ( ) { public void run ( ) { METHOD_6 ( ) ; } } ) ; else <START> METHOD_7 ( INT_1 ) ; <END> return Status . VAR_3 ; } } ; job . VAR_4 ( ) ; } 
public String METHOD_1 ( long time ) { try { int VAR_1 = VAR_2 . METHOD_2 ( VAR_3 , time ) ; TYPE_1 value = VAR_4 . METHOD_3 ( time , VAR_1 ) ; if ( value != null && ! value . VAR_5 ( ) . METHOD_4 ( ) ) { TYPE_2 state = value . VAR_5 ( ) ; return state . toString ( ) ; } } catch ( TYPE_3 | TYPE_4 | TYPE_5 | TYPE_6 e ) { } return null ; <START> <END> } 
private static Collection < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <START> List < TYPE_1 > VAR_2 = new TYPE_3 < > ( ) ; <END> List < TYPE_4 > VAR_3 = VAR_1 . VAR_3 ; for ( int i = 0 ; i < VAR_3 . size ( ) ; i ++ ) { String name = VAR_3 . get ( i ) . name ; if ( name != null ) { VAR_2 . add ( new TYPE_1 ( name , i ) ) ; } } return VAR_2 ; } 
<START> public TYPE_3 ( TYPE_1 offset ) { <END> VAR_2 = new TYPE_2 ( offset ) ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { <START> final StringBuilder VAR_2 = new StringBuilder ( ) ; <END> final Integer VAR_3 ; for ( String VAR_4 : VAR_1 . METHOD_2 ( ) . keySet ( ) ) { VAR_2 . append ( STRING_1 ) . append ( VAR_4 ) . append ( VAR_5 ) ; VAR_2 . append ( STRING_2 ) . append ( VAR_4 ) . append ( VAR_5 ) ; } return VAR_2 . toString ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { <START> return VAR_2 ? METHOD_2 ( VAR_1 ) : METHOD_3 ( VAR_1 ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ( VAR_1 . METHOD_2 ( ) == TYPE_3 . VAR_3 && VAR_1 . METHOD_3 ( ) == TYPE_2 . VAR_5 ) <END> || ( VAR_1 . METHOD_2 ( ) == TYPE_3 . VAR_6 && VAR_1 . METHOD_3 ( ) == TYPE_2 . VAR_7 ) ; } 
public void METHOD_1 ( String text ) { METHOD_2 ( ) ; <START> try { <END> for ( int x = 0 ; x < text . length ( ) ; ++ x ) { char c = text . VAR_1 ( x ) ; VAR_2 . write ( c ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
public void METHOD_1 ( String entity ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
protected void METHOD_1 ( ) throws Throwable { <START> ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( false , false ) ; <END> super . METHOD_1 ( ) ; } 
public Collection < TYPE_1 > METHOD_1 ( ) { Collection < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; <START> VAR_2 . METHOD_2 ( new TYPE_3 ( VAR_3 , VAR_4 ) ) ; <END> VAR_1 . add ( VAR_2 ) ; return VAR_1 ; } 
public void run ( ) { TYPE_1 VAR_1 = new TYPE_1 ( this . VAR_2 . METHOD_1 ( ) , VAR_3 ) ; TYPE_2 VAR_4 = new TYPE_2 ( null , VAR_1 ) ; VAR_4 . create ( ) ; if ( VAR_4 . METHOD_2 ( ) == TYPE_3 . VAR_6 ) <START> this . result = VAR_1 . METHOD_3 ( ) ; <END> } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! this . VAR_2 . equals ( VAR_1 . VAR_2 ) ) { <END> return this . VAR_2 . METHOD_1 ( VAR_1 . VAR_2 ) ; } else if ( ! this . VAR_3 . equals ( VAR_1 . VAR_3 ) ) { return this . VAR_3 . METHOD_1 ( VAR_1 . VAR_3 ) ; } return 0 ; } 
public void METHOD_1 ( TYPE_1 filter ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; for ( int i = 0 ; i < VAR_1 . METHOD_3 ( ) ; i ++ ) { <START> if ( VAR_1 . METHOD_4 ( 0 ) . equals ( filter ) ) { <END> return ; } } VAR_1 . METHOD_5 ( filter ) ; VAR_2 . METHOD_6 ( VAR_1 ) ; } 
public TYPE_1 ( long offset ) { <START> VAR_2 = Long . valueOf ( offset ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 uri , Map < ? , ? > options ) throws IOException { TYPE_1 stream = METHOD_2 ( uri , options ) ; if ( stream != null ) { synchronized ( VAR_1 ) { <START> VAR_1 . put ( uri , stream ) ; <END> } } return stream ; } 
public String METHOD_1 ( TYPE_1 target ) { <START> return METHOD_2 ( target ) == null ? null : METHOD_2 ( target ) . name ; <END> } 
public Set < TYPE_2 . TYPE_3 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
<START> public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 , IOException , <END> TYPE_3 , TYPE_4 { final String VAR_1 = STRING_1 ; final TYPE_5 item = VAR_2 . METHOD_2 ( new TYPE_6 ( VAR_1 ) ) ; Assert . assertTrue ( item instanceof TYPE_7 ) ; final TYPE_8 VAR_3 = ( TYPE_8 ) item ; Assert . assertEquals ( VAR_1 , VAR_3 . getPath ( ) ) ; TYPE_9 . METHOD_3 ( new String [ ] { STRING_2 } , new String [ 0 ] , VAR_3 . list ( ) ) ; } 
public static TYPE_1 METHOD_1 ( String name ) { if ( name == null ) { <START> throw new TYPE_2 ( ) ; <END> } for ( TYPE_1 VAR_1 : TYPE_1 . values ( ) ) { if ( VAR_1 . METHOD_2 ( ) . equalsIgnoreCase ( name ) ) { return VAR_1 ; } } return VAR_2 ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> TYPE_2 VAR_1 = METHOD_2 ( ) ; TYPE_3 location = TYPE_5 . VAR_3 . METHOD_3 ( ) ; TYPE_4 VAR_4 = TYPE_5 . VAR_3 . METHOD_4 ( ) ; VAR_4 . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; VAR_4 . METHOD_7 ( VAR_1 . METHOD_6 ( ) + VAR_1 . METHOD_8 ( ) ) ; location . VAR_5 ( ) . add ( VAR_4 ) ; return location ; } 
<START> public long getId ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 e ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_1 != null ) { <END> VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , 0 ) ; } } 
<START> public int METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( this . VAR_2 != null && VAR_1 . VAR_2 == null ) { return - 1 ; } else { if ( this . VAR_2 == null && VAR_1 . VAR_2 != null ) { return 1 ; } else { if ( this . VAR_2 == null && VAR_1 . VAR_2 == null ) { return 0 ; } else { return this . VAR_2 . METHOD_2 ( VAR_1 . VAR_2 ) ; } } } } 
<START> public int METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( this . VAR_2 != null && VAR_1 . VAR_2 == null ) { return 1 ; } else { if ( this . VAR_2 == null && VAR_1 . VAR_2 != null ) { return - 1 ; } else { if ( this . VAR_2 == null && VAR_1 . VAR_2 == null ) { return 0 ; } else { return this . VAR_2 - VAR_1 . VAR_2 ; } } } } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( toString ( ) ) ; <END> } 
private String METHOD_1 ( TYPE_1 action ) { String results = action . VAR_1 ( TYPE_4 . TYPE_3 , "" ) ; if ( TYPE_2 . METHOD_2 ( results ) ) { results = VAR_4 . METHOD_3 ( results ) . getName ( ) ; } else { TYPE_1 VAR_5 = METHOD_4 ( action ) ; if ( VAR_5 != null ) { <START> return METHOD_1 ( VAR_5 ) ; <END> } } return results ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 VAR_3 ) { TYPE_2 VAR_4 = new TYPE_2 ( ) ; VAR_4 . METHOD_2 ( VAR_2 ) ; VAR_4 . METHOD_3 ( VAR_1 ) ; VAR_4 . METHOD_4 ( VAR_3 ) ; METHOD_5 ( ) ; <START> data . add ( VAR_4 ) ; <END> } 
private Map < String , TYPE_1 > METHOD_1 ( TYPE_2 config ) { Map < String , TYPE_1 > result = new HashMap < String , TYPE_1 > ( ) ; <START> result . put ( new String ( TYPE_3 . VAR_2 ) , TYPE_1 . VAR_3 ) ; <END> result . put ( new String ( TYPE_3 . VAR_4 ) , TYPE_1 . VAR_5 ) ; result . VAR_6 ( config . VAR_7 ( ) ) ; return result ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 ) { VAR_3 = new TYPE_3 ( VAR_1 , VAR_2 ) ; VAR_3 . METHOD_2 ( new TYPE_4 ( ) { @Override public void METHOD_3 ( TYPE_5 event ) { VAR_4 . put ( event . VAR_5 ( ) , event . VAR_6 ( ) ) ; } } ) ; <START> VAR_7 = <END> VAR_3 ; return VAR_7 ; } 
private void METHOD_1 ( Object element , boolean state ) { TYPE_1 item = ( TYPE_1 ) <START> VAR_1 . METHOD_2 ( element ) ; <END> if ( ! state || ( item != null ) ) { VAR_2 . put ( element , state ) ; for ( Object o : ( ( TYPE_2 ) VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( element ) ) { METHOD_1 ( o , state ) ; } } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) == TYPE_4 . TYPE_3 . VAR_4 && VAR_1 . METHOD_3 ( ) instanceof TYPE_2 ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return TYPE_4 . TYPE_3 . VAR_4 . METHOD_2 ( ) . contains ( VAR_1 . METHOD_3 ( ) ) && VAR_1 . METHOD_4 ( ) instanceof TYPE_2 ; <END> } 
protected void METHOD_1 ( TYPE_1 out ) throws IOException { super . METHOD_1 ( out ) ; <START> out . write ( TYPE_2 . METHOD_2 ( VAR_1 ) ) ; <END> out . write ( VAR_2 ) ; out . write ( TYPE_2 . METHOD_3 ( VAR_3 , METHOD_4 ( ) ) ) ; out . write ( VAR_2 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 . get ( VAR_1 . size ( ) - 1 ) ; } 
protected Long METHOD_1 ( int VAR_1 ) { <START> TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( METHOD_3 ( ) ) ; <END> TYPE_2 VAR_4 = VAR_2 . METHOD_4 ( ) ; Long VAR_5 = VAR_4 . METHOD_5 ( VAR_1 ) . METHOD_6 ( ) . METHOD_7 ( ) . METHOD_8 ( ) ; return VAR_5 ; } 
<START> String METHOD_1 ( ) { <END> return VAR_1 ; } 
protected Collection < ? extends TYPE_1 > METHOD_1 ( ) { Set < TYPE_1 > VAR_1 = new HashSet < > ( ) ; for ( TYPE_1 trace : VAR_2 ) { <START> VAR_1 . addAll ( Arrays . asList ( TYPE_2 . METHOD_2 ( trace ) ) ) ; <END> } return VAR_1 ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_2 = VAR_1 . METHOD_4 ( STRING_1 ) ; TYPE_3 . METHOD_5 ( TYPE_4 . class , VAR_2 ) ; TYPE_3 . METHOD_5 ( TYPE_5 . class , VAR_2 ) ; TYPE_3 . METHOD_5 ( TYPE_6 . class , VAR_2 ) ; METHOD_6 ( VAR_2 ) ; METHOD_7 ( VAR_2 ) ; METHOD_8 ( VAR_2 ) ; } 
<START> protected static Collection < TYPE_1 > METHOD_1 ( <END> TYPE_2 VAR_1 , final Collection < TYPE_3 > VAR_2 ) { final Collection < TYPE_1 > VAR_3 ; if ( VAR_1 == null ) { VAR_3 = Collections . VAR_4 ( ) ; } else { VAR_3 = TYPE_4 . filter ( VAR_1 . METHOD_2 ( ) , new TYPE_5 < TYPE_1 > ( ) { public boolean apply ( TYPE_1 input ) { return input . VAR_5 ( VAR_2 ) ; } } ) ; } return VAR_3 ; } 
private void METHOD_1 ( final Set < File > VAR_1 ) { TYPE_1 job = new TYPE_1 ( TYPE_6 . TYPE_5 ) { @Override public TYPE_2 METHOD_2 ( TYPE_3 monitor ) throws TYPE_4 { for ( File f : VAR_1 ) { <START> if ( monitor . VAR_4 ( ) ) { <END> return Status . VAR_5 ; } String VAR_6 = f . VAR_7 ( ) ; METHOD_3 ( VAR_6 ) ; } return Status . VAR_8 ; } } ; job . VAR_9 ( ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . close ( ) ; <END> } 
public TYPE_1 METHOD_1 ( Object VAR_1 ) { TYPE_1 VAR_2 = null ; if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 ; if ( VAR_3 . METHOD_2 ( TYPE_4 . TYPE_3 ) ) { <START> VAR_2 = new TYPE_3 ( logger , VAR_6 , ( TYPE_2 ) VAR_1 ) ; <END> } } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { try { TYPE_3 VAR_1 = new TYPE_3 ( ( TYPE_4 ) repo ) ; <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> return METHOD_3 ( VAR_1 . METHOD_1 ( ) ) ; } catch ( IOException e ) { throw new TYPE_5 ( TYPE_6 . get ( ) . VAR_3 , e ) ; } } 
public int METHOD_1 ( ANNOTATION_1 TYPE_1 object ) { if ( object instanceof TYPE_2 ) { <START> return - 1 ; <END> } return 1 ; } 
public TYPE_1 [ ] METHOD_1 ( ) throws TYPE_2 { <START> synchronized ( VAR_1 ) { <END> Set < TYPE_1 > set = VAR_1 . keySet ( ) ; return set . VAR_2 ( new TYPE_1 [ set . size ( ) ] ) ; } } 
<START> public TYPE_1 METHOD_1 ( String id , boolean VAR_1 ) { <END> TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( TYPE_1 . class ) ; VAR_2 . METHOD_3 ( ) . add ( STRING_1 ) ; VAR_2 . METHOD_4 ( id ) ; VAR_2 . METHOD_5 ( VAR_1 ) ; return VAR_2 ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , <END> int VAR_3 , float VAR_4 ) { int VAR_5 = ( int ) ( VAR_4 * INT_1 ) ; METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_5 ) ; } 
public TYPE_3 ( TYPE_1 ... VAR_2 ) { <START> this . VAR_3 = new TYPE_2 < TYPE_1 > ( ) ; <END> for ( TYPE_1 p : VAR_2 ) VAR_3 . add ( p ) ; } 
public static boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( ! VAR_1 . contains ( TYPE_2 . VAR_3 ) ) VAR_1 . METHOD_3 ( <START> TYPE_2 . VAR_3 , true ) ; <END> return VAR_1 . METHOD_4 ( TYPE_2 . VAR_3 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; TYPE_2 VAR_3 = new TYPE_2 ( TYPE_4 . VAR_5 ) ; TYPE_3 VAR_6 = new TYPE_3 ( VAR_3 ) ; VAR_1 . METHOD_2 ( VAR_6 ) ; <START> Assert . VAR_7 ( ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( VAR_3 , TYPE_3 . VAR_5 ) ; <START> Assert . VAR_6 ( ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( null , TYPE_2 . VAR_4 ) ; <START> Assert . VAR_5 ( ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; <START> Assert . VAR_4 ( ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( null ) ; <START> Assert . VAR_3 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 ) { TYPE_4 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> <END> TYPE_1 VAR_2 = METHOD_1 ( VAR_1 . METHOD_3 ( ) ) ; while ( ! VAR_1 . isEmpty ( ) ) { METHOD_4 ( VAR_2 , METHOD_1 ( VAR_1 . METHOD_3 ( ) ) ) ; } return VAR_2 ; } 
<START> public static synchronized TYPE_1 METHOD_1 ( String value ) { <END> if ( value . contains ( STRING_1 ) ) { value = STRING_1 ; } if ( VAR_1 . isEmpty ( ) ) { for ( TYPE_1 VAR_2 : TYPE_1 . values ( ) ) { TYPE_1 . VAR_1 . put ( VAR_2 . VAR_3 , VAR_2 ) ; } } TYPE_1 VAR_4 = VAR_1 . get ( value ) ; return VAR_4 != null ? VAR_4 : VAR_5 ; } 
public void METHOD_1 ( ) { <START> Iterator < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( VAR_2 ) . iterator ( ) ; <END> while ( VAR_1 . hasNext ( ) ) { TYPE_1 VAR_3 = VAR_1 . next ( ) ; VAR_3 . close ( ) ; } VAR_2 . clear ( ) ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; this . METHOD_2 ( TYPE_3 . VAR_2 , new TYPE_1 ( ) ) ; <START> METHOD_3 ( TYPE_3 . VAR_3 ) ; <END> METHOD_2 ( TYPE_3 . VAR_3 , new TYPE_2 ( ) ) ; } 
<START> public static boolean METHOD_1 ( TYPE_1 object , TYPE_2 VAR_1 ) { <END> final Object value = TYPE_3 . METHOD_2 ( object , VAR_1 ) ; final Object VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( value == null ) { return VAR_2 == null ; } return value . equals ( VAR_1 . METHOD_3 ( ) ) || "" . equals ( value ) ; } 
protected TYPE_1 METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> return VAR_2 ; } } 
public boolean METHOD_1 ( Object VAR_1 , TYPE_1 VAR_2 , Object VAR_3 ) { boolean VAR_4 = false ; TYPE_2 VAR_5 = METHOD_2 ( VAR_1 ) ; TYPE_2 VAR_6 = METHOD_2 ( VAR_3 ) ; <START> if ( VAR_5 != null & VAR_6 != null ) { <END> VAR_4 = VAR_5 . METHOD_3 ( VAR_2 , VAR_6 ) ; } return VAR_4 ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 [ ] VAR_2 ) { TYPE_3 [ ] VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; TYPE_4 VAR_4 = VAR_1 . METHOD_3 ( ) ; <START> for ( TYPE_3 VAR_5 : VAR_3 ) { <END> VAR_4 . METHOD_4 ( VAR_5 ) ; } } 
public TYPE_1 [ ] METHOD_1 ( ) { TYPE_1 [ ] VAR_1 = new TYPE_1 [ VAR_2 . keySet ( ) . size ( ) ] ; <START> return VAR_2 . keySet ( ) . METHOD_2 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) . METHOD_3 ( true , null ) ; } catch ( TYPE_1 e ) { <START> e . VAR_2 ( ) ; <END> } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( METHOD_2 ( trace ) ) { METHOD_3 ( false ) ; } else { VAR_1 += METHOD_4 ( ) ; synchronized ( VAR_2 ) { final TYPE_1 VAR_3 = VAR_4 ; if ( VAR_3 != null ) { <START> if ( METHOD_5 ( ) . METHOD_6 ( ) . getValue ( ) > VAR_3 . METHOD_6 ( ) . getValue ( ) ) { <END> METHOD_7 ( ) ; } } } } } 
public TYPE_8 ( TYPE_1 stream , TYPE_2 output ) { this . reader = new TYPE_3 ( new TYPE_4 ( stream ) ) ; if ( output == null ) this . writer = new TYPE_5 ( new TYPE_6 ( new <START> TYPE_7 ( ) ) ) ; <END> else this . writer = new TYPE_5 ( new TYPE_6 ( output ) ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , long VAR_3 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_4 = new TYPE_2 < TYPE_3 > ( ) ; <END> } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( TYPE_1 . VAR_2 ) ; <START> VAR_3 = null ; <END> } 
public void run ( ) { for ( TYPE_1 entry : VAR_1 ) { if ( VAR_2 . METHOD_1 ( ) ) { return ; } if ( entry == null ) { break ; } METHOD_2 ( entry , VAR_2 ) ; } List < TYPE_2 > VAR_3 = METHOD_3 ( VAR_4 , VAR_5 , VAR_6 , VAR_2 ) ; <START> VAR_7 . METHOD_4 ( ) . METHOD_5 ( VAR_3 ) ; <END> METHOD_6 ( ) ; } 
public static boolean METHOD_1 ( String uri ) { if ( uri != null && uri . startsWith ( TYPE_1 ) ) { <START> String [ ] split = uri . substring ( INT_1 ) . split ( STRING_1 ) ; <END> if ( split . length == 2 ) { return true ; } ; } return false ; } 
<START> public synchronized TYPE_1 METHOD_1 ( ) { <END> return METHOD_1 ( false ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { TYPE_1 VAR_3 = VAR_1 ; for ( TYPE_2 VAR_4 : VAR_5 ) { <START> VAR_3 = VAR_4 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } return VAR_3 ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { <END> TYPE_1 VAR_3 = null ; for ( TYPE_2 VAR_4 : VAR_5 ) { VAR_3 = VAR_4 . METHOD_1 ( VAR_1 , VAR_2 ) ; if ( VAR_3 != null ) { break ; } } return VAR_3 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 element : VAR_1 . METHOD_2 ( ) ) { String VAR_2 = element . VAR_3 ( ) ; <START> if ( ! VAR_2 . startsWith ( STRING_1 ) && ! VAR_2 . startsWith ( STRING_2 ) && <END> ! TYPE_3 . METHOD_3 ( element ) ) { return true ; } } return false ; } 
public void METHOD_1 ( ) { <START> TYPE_1 result = METHOD_2 ( METHOD_3 ( STRING_1 ) , VAR_1 ) ; <END> assertNotNull ( result ) ; assertEquals ( INT_1 , result . VAR_2 ( ) ) ; assertEquals ( 0 , result . VAR_3 ( ) ) ; assertEquals ( 0 , result . VAR_4 ( ) ) ; } 
<START> public static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { <END> if ( VAR_1 instanceof TYPE_3 ) { TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; TYPE_4 VAR_3 = new TYPE_4 ( ) ; VAR_3 . METHOD_2 ( VAR_2 ) ; return VAR_3 ; } return null ; } 
public void METHOD_1 ( final boolean VAR_1 ) { VAR_2 = VAR_1 ; <START> if ( ! VAR_1 ) VAR_3 = false ; <END> } 
public void METHOD_1 ( TYPE_1 event ) { TYPE_2 VAR_1 = event . VAR_2 ( ) ; if ( VAR_1 != null ) { TYPE_3 VAR_3 = METHOD_2 ( ) ; try { VAR_1 . METHOD_3 ( VAR_3 ) ; <START> } catch ( TYPE_4 e ) { <END> e . VAR_4 ( ) ; } for ( String VAR_5 : VAR_3 . VAR_6 ) { TYPE_5 . METHOD_4 ( ) . METHOD_5 ( VAR_5 ) ; } } } 
public void METHOD_1 ( ) { TYPE_1 a = new TYPE_1 ( ) ; TYPE_1 b = new TYPE_1 ( ) ; b . VAR_1 ( STRING_1 , TYPE_2 . METHOD_2 ( TYPE_3 . VAR_3 ) ) ; TYPE_1 c = new TYPE_1 ( ) ; c . VAR_1 ( STRING_1 , TYPE_2 . METHOD_2 ( TYPE_3 . VAR_3 ) ) ; <START> assertEquals ( VAR_4 . METHOD_3 ( ) , a . VAR_5 ( ) ) ; <END> assertEquals ( b . VAR_5 ( ) , c . VAR_5 ( ) ) ; } 
public void METHOD_1 ( ) { assertEquals ( STRING_1 , <START> TYPE_1 . METHOD_2 ( STRING_2 , STRING_3 , STRING_4 ) ) ; <END> assertEquals ( STRING_1 , TYPE_1 . METHOD_2 ( STRING_2 , STRING_5 , STRING_4 ) ) ; assertEquals ( STRING_6 , TYPE_1 . METHOD_2 ( STRING_2 , STRING_7 , STRING_4 ) ) ; assertEquals ( STRING_6 , TYPE_1 . METHOD_2 ( STRING_2 , STRING_8 , STRING_4 ) ) ; } 
private String METHOD_1 ( final TYPE_1 element ) { TYPE_2 VAR_1 = new TYPE_2 ( TYPE_2 . TYPE_4 . TYPE_5 . VAR_4 ) ; <START> TYPE_3 VAR_5 = new TYPE_3 ( VAR_1 ) ; String text = VAR_5 . METHOD_1 ( element ) ; VAR_1 . METHOD_2 ( ) ; <END> return text ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 node , TYPE_3 container , String VAR_3 ) { <START> super ( VAR_2 , node , container , TYPE_4 . METHOD_1 ( Collections . VAR_4 ) , VAR_3 ) ; <END> } 
public String getName ( ) { <START> return TYPE_1 . METHOD_1 ( VAR_1 . name ( ) ) ; <END> } 
private TYPE_2 ( ANNOTATION_1 String VAR_2 ) { VAR_3 = VAR_2 ; VAR_4 = null ; <START> VAR_5 = TYPE_1 . METHOD_1 ( Collections . VAR_6 ) ; <END> } 
public String METHOD_1 ( TYPE_1 event ) { if ( ! ( event instanceof TYPE_2 ) ) { return VAR_1 ; } TYPE_2 VAR_2 = ( TYPE_2 ) event ; TYPE_3 VAR_3 = VAR_2 . METHOD_2 ( ) ; <START> return TYPE_4 . METHOD_3 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) ) ; <END> } 
protected ANNOTATION_1 TYPE_1 < TYPE_2 > METHOD_1 ( ANNOTATION_1 TYPE_2 trace ) { <START> return TYPE_3 . METHOD_2 ( Arrays . asList ( TYPE_4 . METHOD_3 ( trace ) ) ) ; <END> } 
protected boolean METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
protected void METHOD_1 ( TYPE_1 event ) { METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) , null ) ; <START> METHOD_3 ( ) . METHOD_5 ( ) . METHOD_6 ( this ) ; <END> VAR_1 . METHOD_7 ( ) ; super . METHOD_1 ( event ) ; } 
<START> public void METHOD_1 ( ) { <END> final String [ ] VAR_1 = { "" } ; METHOD_2 ( VAR_2 , VAR_1 , VAR_3 ) ; } 
public TYPE_2 ( TYPE_1 parent , int VAR_2 , int VAR_3 ) { this ( parent , VAR_2 ) ; <START> METHOD_1 ( VAR_3 ) ; <END> } 
private View METHOD_1 ( ) { <START> if ( this instanceof TYPE_1 ) { return ( View ) METHOD_2 ( ) ; } else { <END> return METHOD_3 ( ) ; } } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; <END> List < String > VAR_3 = TYPE_2 . METHOD_2 ( VAR_4 , TYPE_2 . VAR_5 ) ; METHOD_3 ( VAR_2 , VAR_3 ) ; for ( TYPE_1 VAR_1 : VAR_2 ) { if ( ! VAR_6 . contains ( VAR_1 ) ) { VAR_6 . add ( VAR_1 ) ; } } } } 
<START> protected void METHOD_1 ( final String name , final Object content ) { <END> if ( ! TYPE_1 . METHOD_2 ( name ) ) throw new RuntimeException ( STRING_1 + name + STRING_2 ) ; } 
public boolean METHOD_1 ( TYPE_1 type ) { if ( type == this ) return true ; if ( type instanceof TYPE_2 || type instanceof TYPE_3 ) return type . VAR_1 ( this ) ; <START> if ( VAR_2 != null && type instanceof TYPE_4 ) { <END> return type . VAR_1 ( VAR_2 ) ; } return false ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 type ) { TYPE_2 factory = VAR_1 ; if ( VAR_2 ) { if ( type != null && type . VAR_3 ( ) != null && type . VAR_3 ( ) . METHOD_2 ( ) != null ) { factory = type . VAR_3 ( ) . METHOD_2 ( ) ; } } <START> TYPE_1 VAR_4 = super . METHOD_1 ( factory , type ) ; if ( VAR_2 ) { VAR_4 = TYPE_4 . getInstance ( ) . METHOD_3 ( VAR_4 , version ) ; } return VAR_4 ; <END> } 
<START> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_2 offset ) { <END> return new TYPE_3 ( new TYPE_4 ( VAR_1 , offset ) ) ; } 
<START> private String METHOD_1 ( final TYPE_1 VAR_1 ) { <END> String VAR_2 = STRING_1 ; if ( VAR_1 instanceof TYPE_2 ) { VAR_2 = new TYPE_3 ( ( TYPE_2 ) VAR_1 ) . METHOD_1 ( ) ; } else if ( VAR_1 instanceof TYPE_4 ) { VAR_2 = ( ( TYPE_4 ) VAR_1 ) . getName ( ) ; } else { VAR_2 = VAR_1 . METHOD_2 ( ) . getName ( ) ; } return VAR_2 ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> this . VAR_3 = VAR_2 ; <END> VAR_4 = true ; VAR_5 = new ArrayList < > ( ) ; VAR_6 = new ArrayList < > ( ) ; VAR_7 = new ArrayList < > ( ) ; VAR_8 = VAR_2 . METHOD_1 ( ) ; } 
public TYPE_5 ( TYPE_1 trace , Class < ? extends TYPE_2 > VAR_2 , String id ) { this . VAR_3 = trace ; <START> this . VAR_4 = VAR_2 ; <END> VAR_5 = new TYPE_3 < > ( VAR_6 ) ; VAR_7 = false ; VAR_8 = new Thread ( new TYPE_4 ( ) , id + STRING_1 ) ; } 
private boolean <START> METHOD_1 ( TYPE_1 <END> input ) { return new TYPE_2 ( input ) . METHOD_2 ( ) && METHOD_3 ( input . VAR_1 ( ) ) && METHOD_4 ( input ) ; } 
private boolean METHOD_1 ( String VAR_1 ) throws TYPE_1 { <START> assertTrue ( STRING_1 , VAR_2 . METHOD_2 ( ) <END> . METHOD_3 ( new TYPE_2 ( ) ) ) ; TYPE_3 [ ] VAR_3 = VAR_2 . METHOD_4 ( ) . METHOD_5 ( STRING_2 , new TYPE_2 ( ) ) ; for ( TYPE_3 VAR_4 : VAR_3 ) { String VAR_5 = StringUtils . VAR_6 ( StringUtils . VAR_7 ( VAR_4 . METHOD_6 ( ) , STRING_3 ) ) ; if ( VAR_5 . equals ( VAR_1 ) ) { return true ; } } return false ; } 
<START> public void METHOD_1 ( TYPE_1 resource ) { if ( ! VAR_1 ) { METHOD_2 ( ) ; } VAR_2 . METHOD_1 ( resource ) ; } <END> 
TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { VAR_4 = VAR_3 . VAR_5 ; VAR_6 = VAR_3 . VAR_7 ; <START> VAR_8 = new TYPE_3 ( ) ; <END> db = VAR_2 ; } 
public String getName ( ) { String name = super . getName ( ) ; if ( name != null ) { name = TYPE_1 . VAR_2 + name ; if ( VAR_3 != null && <START> VAR_3 . length ( ) > 0 ) { <END> name = name + TYPE_1 . VAR_4 + VAR_3 ; } return name ; } return null ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 < String > VAR_2 = TYPE_3 . getInstance ( ) . METHOD_2 ( VAR_1 ) ; if ( VAR_2 . METHOD_3 ( ) ) { return METHOD_1 ( VAR_2 . get ( ) ) ; } else { <START> if ( VAR_3 ) { <END> return METHOD_4 ( VAR_1 ) ; } else { return super . METHOD_1 ( VAR_1 ) ; } } } 
private static void METHOD_1 ( IOException e , TYPE_1 p ) { StringBuilder buf = new StringBuilder ( TYPE_2 . format ( TYPE_3 . get ( ) . VAR_1 , p . VAR_2 ( ) . METHOD_2 ( ) ) ) ; buf . append ( CHAR_1 ) ; TYPE_4 VAR_3 = new TYPE_4 ( ) ; e . VAR_4 ( new TYPE_5 ( VAR_3 ) ) ; buf . append ( VAR_3 . toString ( ) ) ; <START> System . err . println ( buf . toString ( ) ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_2 builder , boolean VAR_1 ) { if ( ! VAR_1 && builder instanceof TYPE_3 ) { <START> ( ( TYPE_3 ) builder ) . METHOD_2 ( false ) ; <END> } return new TYPE_4 ( builder ) ; } 
private Set < TYPE_1 > METHOD_1 ( boolean VAR_1 ) { List < TYPE_1 > result = TYPE_2 . METHOD_2 ( ) ; for ( TYPE_3 VAR_2 : METHOD_3 ( ) ) { TYPE_1 res = VAR_2 . METHOD_4 ( ) ; if ( res != null && <START> ( VAR_2 != VAR_3 || VAR_1 ) ) <END> { result . add ( res ) ; } } return TYPE_4 . METHOD_5 ( result ) ; } 
private String METHOD_1 ( String input ) { <START> if ( input . startsWith ( TYPE_1 ) ) { <END> return input . substring ( TYPE_1 . length ( ) ) . trim ( ) ; } return input . trim ( ) ; } 
public TYPE_1 METHOD_1 ( String [ ] path ) { <START> if ( path == null || path . length == 0 ) <END> return this ; TYPE_1 VAR_1 = this ; int i = 0 ; while ( VAR_1 != null && i < path . length ) { VAR_1 = VAR_1 . METHOD_2 ( path [ i ] ) ; i ++ ; } if ( VAR_1 == null ) return null ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 is ) throws IOException { TYPE_3 parser = new <START> TYPE_3 ( org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_5 . TYPE_3 . VAR_8 . VAR_9 ) ; <END> parser . parse ( is , new TYPE_4 ( ) ) ; return parser . VAR_10 ( ) . get ( 0 ) ; } 
public Set < TYPE_1 > METHOD_1 ( TYPE_2 is ) throws IOException { TYPE_3 parser = new <START> TYPE_3 ( org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_8 . TYPE_3 . VAR_8 . VAR_9 ) ; <END> parser . parse ( is , new TYPE_4 ( ) ) ; Set < TYPE_1 > VAR_10 = new TYPE_5 < TYPE_1 > ( ) ; for ( TYPE_6 VAR_11 : parser . VAR_12 ( ) ) { VAR_10 . add ( TYPE_7 . METHOD_2 ( VAR_11 ) ) ; } return VAR_10 ; } 
protected void METHOD_1 ( ) { <START> if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) > 0 ) { <END> String VAR_2 = ( String ) VAR_1 . METHOD_3 ( Integer . toString ( VAR_1 . METHOD_2 ( ) ) ) ; String VAR_3 = VAR_4 ; if ( VAR_2 . equals ( VAR_5 ) ) { VAR_3 = TYPE_3 . TYPE_1 ; } else if ( VAR_2 . equals ( VAR_4 ) ) { VAR_3 = TYPE_3 . TYPE_2 ; } VAR_1 . METHOD_4 ( VAR_3 ) ; } } 
public void METHOD_1 ( boolean VAR_1 ) { <START> boolean VAR_2 = VAR_3 ; <END> VAR_3 = VAR_1 ; if ( VAR_2 != VAR_3 ) { } } 
public boolean METHOD_1 ( ) { return <START> VAR_1 ; <END> } 
public boolean METHOD_1 ( ) { return <START> METHOD_2 ( ) . METHOD_1 ( ) ; <END> } 
<START> public static <END> Set < String > METHOD_1 ( Set < String > VAR_1 , Collection < String > VAR_2 , Set < String > VAR_3 ) { Set < String > VAR_4 = new HashSet < String > ( ) ; for ( String VAR_5 : VAR_1 ) { boolean VAR_6 = METHOD_2 ( VAR_5 , VAR_2 ) ; if ( ! VAR_6 ) { VAR_4 . add ( VAR_5 ) ; } } VAR_4 . addAll ( VAR_3 ) ; return VAR_4 ; } 
<START> public static <END> boolean METHOD_1 ( String VAR_1 , Collection < String > VAR_2 ) { for ( String VAR_3 : VAR_2 ) { if ( VAR_1 . startsWith ( VAR_3 ) ) { return true ; } if ( VAR_3 . length ( ) == VAR_1 . length ( ) + 1 && VAR_3 . METHOD_2 ( VAR_3 . length ( ) - 1 ) == CHAR_1 && VAR_3 . startsWith ( VAR_1 ) ) { return true ; } } return false ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 . length ( ) > INT_1 ) { <START> VAR_2 = STRING_1 + VAR_2 . substring ( 0 , INT_2 ) ; <END> } if ( VAR_2 . length ( ) == 0 ) { VAR_2 += STRING_2 ; } return TYPE_2 . METHOD_3 ( VAR_2 ) ; } 
public String getProperty ( String key ) { <START> return ( String ) value . get ( key ) ; <END> } 
private void METHOD_1 ( TYPE_1 [ ] VAR_1 ) throws TYPE_2 { assertEquals ( STRING_1 , VAR_2 . size ( ) , VAR_1 . length ) ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <START> Map values = VAR_2 . get ( new Long ( VAR_1 [ i ] . getId ( ) ) ) ; <END> assertEquals ( STRING_2 , VAR_1 [ i ] . METHOD_2 ( ) , values ) ; } } 
private static List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { HashSet < TYPE_1 > set = new <START> HashSet < TYPE_1 > ( ) ; <END> set . addAll ( VAR_1 ) ; return Arrays . asList ( set . VAR_2 ( new TYPE_1 [ set . size ( ) ] ) ) ; } 
public List < Object > METHOD_1 ( List < Object > list , Object object ) { <START> final List < Object > result = TYPE_1 . METHOD_2 ( ) ; <END> result . add ( object ) ; result . addAll ( list ) ; return result ; } 
<START> private String METHOD_1 ( ) throws TYPE_1 { <END> String name = VAR_1 ; int count = 1 ; while ( METHOD_2 ( ) . METHOD_3 ( name ) != null ) { name = VAR_1 + STRING_1 + count ++ ; } return name ; } 
<START> public boolean METHOD_1 ( ) { <END> String VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; return VAR_1 != null ? Boolean . VAR_4 ( VAR_1 ) : VAR_5 ; } 
public TYPE_1 ( final long VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> this . VAR_3 = count ++ ; } 
public Long METHOD_1 ( ANNOTATION_1 Object VAR_1 ) { Long VAR_2 = INT_1 ; for ( Long VAR_3 : VAR_4 . get ( VAR_1 ) ) { <START> VAR_2 += VAR_3 ; <END> } return VAR_2 ; } 
private TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 ; TYPE_2 VAR_2 = METHOD_2 ( ) ; <START> if ( VAR_2 != null && VAR_2 instanceof TYPE_1 ) { <END> VAR_1 = ( TYPE_1 ) VAR_2 ; } else { VAR_1 = new TYPE_1 ( ) { public TYPE_3 METHOD_3 ( ) { return new TYPE_4 ( ) ; } } ; } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { TYPE_2 < TYPE_3 > container = METHOD_2 ( VAR_1 ) ; <START> if ( container == null ) <END> return ; List < TYPE_1 > VAR_3 = METHOD_3 ( VAR_1 , VAR_2 ) ; METHOD_4 ( VAR_1 , VAR_3 , true ) ; } 
<START> protected void METHOD_1 ( TYPE_1 value ) { <END> METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) . METHOD_4 ( value ) ; } 
<START> protected final TYPE_1 METHOD_1 ( TYPE_2 parent , int VAR_1 ) { <END> if ( parent == null ) { return TYPE_3 . METHOD_2 ( ) . METHOD_1 ( VAR_1 ) ; } return parent . VAR_2 ( ) . METHOD_3 ( ) . METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , String url ) { METHOD_2 ( ) ; try { VAR_2 . write ( CHAR_1 ) ; METHOD_3 ( VAR_1 ) ; if ( url != null ) <START> { <END> VAR_2 . write ( url ) ; } VAR_2 . write ( CHAR_1 ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
<START> public static void METHOD_1 ( Object VAR_1 ) { <END> int length = ( ( String ) VAR_1 ) . length ( ) ; if ( length > VAR_2 ) { throw METHOD_2 ( STRING_1 , VAR_2 , length , VAR_1 ) ; } } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( ) ; } 
public void METHOD_1 ( long VAR_1 , long VAR_2 ) { VAR_3 = VAR_1 ; VAR_4 = VAR_2 ; VAR_5 = VAR_3 != SWT . VAR_6 ? VAR_3 : VAR_4 ; <START> VAR_7 = VAR_4 != SWT . VAR_6 ? VAR_4 : VAR_3 ; <END> if ( VAR_5 > VAR_7 ) { VAR_3 = VAR_2 ; VAR_4 = VAR_1 ; VAR_5 = VAR_3 ; VAR_7 = VAR_4 ; } METHOD_2 ( ) ; } 
private void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 , String VAR_2 ) { <START> if ( VAR_3 . size ( ) > 0 ) { <END> for ( String VAR_4 : VAR_3 ) { if ( VAR_4 . METHOD_2 ( ) . contains ( VAR_2 ) ) { VAR_1 . add ( new TYPE_2 ( VAR_4 ) ) ; } } } } 
public TYPE_2 ( ) { <START> super ( ) ; <END> VAR_2 = new TYPE_1 ( ) ; } 
private void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( ) ; <END> VAR_1 = null ; } if ( this . VAR_2 != null ) { this . VAR_2 . METHOD_2 ( ) ; this . VAR_2 = null ; } } 
public void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { if ( session != null ) { <START> if ( TYPE_3 . TYPE_4 . equals ( session . getStatus ( ) ) ) { <END> VAR_2 = null ; } } } 
public void METHOD_1 ( TYPE_1 event ) { if ( session != null && <START> TYPE_3 . TYPE_4 . equals ( session . getStatus ( ) ) ) <END> { if ( VAR_1 == null ) { VAR_1 = event . VAR_2 ( ) ; } } } 
protected String METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; TYPE_1 token = ( ( TYPE_2 ) METHOD_3 ( ) ) . METHOD_4 ( ) ; <START> if ( ( ! ( this instanceof TYPE_3 ) && ! ( this instanceof TYPE_4 ) ) <END> && token != null && VAR_1 . length ( ) > 0 ) { if ( ! VAR_1 . METHOD_5 ( STRING_1 ) ) { VAR_1 += STRING_2 ; } VAR_1 += STRING_3 + token . VAR_2 ( ) ; } return METHOD_6 ( ) + VAR_1 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 config , String VAR_1 ) throws TYPE_3 { <START> List < TYPE_1 > VAR_2 ; <END> TYPE_1 VAR_3 = null ; VAR_2 = TYPE_1 . METHOD_2 ( config ) ; for ( TYPE_1 VAR_4 : VAR_2 ) { if ( VAR_4 . getName ( ) . equals ( VAR_1 ) ) VAR_3 = VAR_4 ; } return VAR_3 ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) <START> throws TYPE_3 { <END> List < TYPE_2 > VAR_3 = new ArrayList < TYPE_2 > ( VAR_1 . METHOD_2 ( ) ) ; for ( TYPE_2 VAR_4 : VAR_3 ) { VAR_1 . METHOD_3 ( VAR_4 ) ; } VAR_1 . METHOD_4 ( VAR_2 ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = Constants . VAR_3 + STRING_1 ; List < TYPE_2 > VAR_4 = VAR_1 . METHOD_2 ( ) ; for ( TYPE_2 VAR_5 : VAR_4 ) { <START> if ( VAR_5 . METHOD_3 ( VAR_2 ) ) <END> return ; } VAR_1 . METHOD_4 ( new TYPE_2 ( VAR_2 + STRING_2 + VAR_2 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( TYPE_5 . VAR_2 ) . METHOD_3 ( TYPE_1 . METHOD_2 ( TYPE_5 . VAR_3 ) ) <START> . and ( TYPE_1 . METHOD_4 ( TYPE_2 . class ) . and ( TYPE_1 . TYPE_4 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 <END> = VAR_2 ; if ( VAR_1 == null ) { VAR_1 = new TYPE_2 ( ) ; if ( ( VAR_3 != null ) && ( VAR_4 != null ) ) { VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_3 ( VAR_4 ) ; } VAR_2 = VAR_1 ; } return VAR_1 ; } 
public void run ( ) { TYPE_1 . METHOD_1 ( ) . METHOD_2 ( new TYPE_2 ( ) { @Override public void run ( ) { <START> if ( ! METHOD_3 ( ) . METHOD_4 ( ) && TYPE_4 . this . VAR_2 != null && TYPE_4 . VAR_3 . VAR_2 . equals ( METHOD_5 ( ) ) ) { <END> commit ( TYPE_3 . NONE , false ) ; } } } ) ; } 
private static String METHOD_1 ( TYPE_1 result ) { TYPE_1 VAR_1 = METHOD_2 ( result . VAR_2 ( ) ) ; if ( VAR_1 != null ) { <START> return result . getMessage ( ) + STRING_1 + METHOD_1 ( VAR_1 ) + METHOD_3 ( VAR_1 ) ; <END> } return result . getMessage ( ) ; } 
<START> public void METHOD_1 ( TYPE_1 monitor ) { <END> item . VAR_1 ( true ) ; METHOD_2 ( ) ; } 
public void METHOD_1 ( TYPE_1 monitor ) { <START> this . VAR_1 = monitor ; <END> item . VAR_2 ( true ) ; METHOD_2 ( ) ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( ! TYPE_2 . METHOD_1 ( VAR_2 , VAR_1 . VAR_2 ) ) { return false ; } <START> return TYPE_2 . METHOD_1 ( VAR_3 , VAR_1 . VAR_3 ) ; <END> } 
private String METHOD_1 ( boolean VAR_1 ) { <START> return ( VAR_1 ? VAR_2 : "" ) + ( VAR_3 != "" ? STRING_1 + VAR_3 : "" ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( this ) ; VAR_2 = new ArrayList < TYPE_2 > ( ) ; VAR_3 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; if ( VAR_3 == null ) { VAR_3 = STRING_1 ; } <START> METHOD_6 ( ) ; <END> } 
private void METHOD_1 ( T value ) { String VAR_1 = TYPE_1 . METHOD_2 ( value . toString ( ) ) ; <START> TYPE_2 VAR_2 = TYPE_3 . METHOD_3 ( ) ; <END> if ( VAR_1 != null ) { VAR_2 . put ( VAR_3 , VAR_1 ) ; try { VAR_2 . METHOD_4 ( ) ; } catch ( TYPE_4 e ) { e . VAR_4 ( ) ; } } } 
<START> protected <END> void METHOD_1 ( long VAR_1 , int VAR_2 , int VAR_3 ) { OS . VAR_4 ( VAR_1 , VAR_2 ) ; OS . VAR_5 ( VAR_1 , VAR_3 ) ; } 
protected void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> METHOD_2 ( ) ; <END> VAR_1 = METHOD_3 ( METHOD_4 ( ) ) ; VAR_2 = VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) . METHOD_8 ( ) ; final TYPE_1 VAR_3 = TYPE_2 . METHOD_9 ( ) . METHOD_10 ( ) . METHOD_11 ( ) ; TYPE_3 view = VAR_3 . METHOD_12 ( STRING_1 ) ; if ( view != null ) { VAR_3 . METHOD_13 ( view ) ; } } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_1 ( ) ; <END> VAR_1 = null ; super . METHOD_1 ( ) ; if ( METHOD_2 ( ) instanceof TYPE_1 ) { ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_1 ( ) ; } if ( VAR_2 != null ) { METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_2 ) ; VAR_2 = null ; } } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_1 ( ) ; <END> VAR_1 = null ; if ( VAR_2 != null ) { METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; } VAR_2 = null ; super . METHOD_1 ( ) ; if ( METHOD_5 ( ) instanceof TYPE_1 ) { ( ( TYPE_1 ) METHOD_5 ( ) ) . METHOD_1 ( ) ; } } 
public void METHOD_1 ( int state ) { try { final TYPE_1 field = TYPE_2 . class . METHOD_2 ( STRING_1 ) ; field . VAR_1 ( true ) ; field . set ( this , new Integer ( state ) ) ; } catch ( Exception e ) { <START> e . VAR_2 ( ) ; <END> throw new RuntimeException ( e ) ; } } 
public static TYPE_1 METHOD_1 ( View view , String VAR_1 , TYPE_1 VAR_2 ) { TYPE_1 value = VAR_2 ; TYPE_2 VAR_3 = TYPE_5 . VAR_5 . METHOD_2 ( ) ; TYPE_3 <START> VAR_6 ; <END> if ( VAR_3 != null ) { VAR_6 = view . VAR_7 ( VAR_3 , VAR_1 ) ; if ( VAR_6 instanceof TYPE_4 ) { value = ( ( TYPE_4 ) VAR_6 ) . METHOD_1 ( ) ; } } return value ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 ) ) ; TYPE_1 VAR_2 = METHOD_1 ( ) ; <START> METHOD_2 ( VAR_3 . METHOD_4 ( ) ) ; <END> return VAR_2 ; } 
private TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 ) { if <START> ( TYPE_3 . getInstance ( ) . METHOD_2 ( VAR_2 ) <END> && VAR_1 != null ) { return TYPE_4 . METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( VAR_1 , STRING_1 ) ) ; } return VAR_1 ; } 
public void add ( TYPE_1 VAR_1 ) { if ( VAR_2 == null ) VAR_2 = new <START> ArrayList < TYPE_1 > ( 2 ) ; <END> VAR_2 . add ( VAR_1 ) ; } 
private static String METHOD_1 ( byte [ ] VAR_1 ) { <START> StringBuilder builder = new StringBuilder ( ) ; <END> for ( byte b : VAR_1 ) { builder . append ( TYPE_1 . METHOD_2 ( ( b & INT_1 ) > > 4 ) ) ; builder . append ( TYPE_1 . METHOD_2 ( b & INT_2 ) ) ; } return builder . toString ( ) ; } 
public static TYPE_1 METHOD_1 ( final TYPE_2 db , final String path , final TYPE_3 ... VAR_1 ) throws TYPE_4 , TYPE_5 , TYPE_6 , IOException { <START> TYPE_7 reader = db . VAR_2 ( ) ; try { return METHOD_1 ( reader , path , VAR_1 ) ; } finally { reader . close ( ) ; } <END> } 
<START> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( ! ( VAR_1 instanceof TYPE_2 ) ) { return false ; } TYPE_2 node = ( TYPE_2 ) VAR_1 ; if ( node instanceof TYPE_3 ) { return false ; } if ( node . VAR_2 ( ) instanceof TYPE_4 ) { return true ; } if ( node . VAR_2 ( ) instanceof TYPE_5 ) { if ( node . VAR_3 ( ) != null ) { return true ; } } return false ; } 
public TYPE_1 METHOD_1 ( Object node ) { if ( node == null ) { return null ; } TYPE_2 VAR_1 = METHOD_2 ( node ) ; <START> TYPE_3 VAR_2 = new TYPE_3 ( ) ; <END> View VAR_3 = VAR_2 . METHOD_3 ( VAR_1 ) ; if ( VAR_3 . METHOD_4 ( ) == null ) { return null ; } return super . METHOD_1 ( VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> final int VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> if ( VAR_2 == TYPE_2 . VAR_4 ) { METHOD_3 ( ) ; METHOD_4 ( ) ; } else if ( VAR_2 == TYPE_2 . VAR_5 ) { METHOD_3 ( ) ; METHOD_4 ( ) ; } } 
public TYPE_3 ( View view , TYPE_1 VAR_2 ) { super ( view , VAR_2 ) ; <START> super . VAR_3 = new TYPE_2 ( ) ; <END> } 
<START> public String METHOD_1 ( ) { <END> return VAR_1 ; } 
public T value ( ) { if ( VAR_1 == null ) { VAR_1 = METHOD_1 ( ) ; } else if ( ! METHOD_2 ( ) ) { VAR_1 = METHOD_1 ( ) ; } <START> return ( VAR_1 != null ) ? VAR_1 : VAR_2 ; <END> } 
private List < T > METHOD_1 ( List < String > VAR_1 ) { List < T > VAR_2 = new ArrayList < T > ( ) ; for ( String val : VAR_1 ) { <START> VAR_2 . add ( super . METHOD_1 ( val ) ) ; <END> } return VAR_2 ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> if ( ! VAR_1 . METHOD_2 ( ) . contains ( this ) ) { <END> VAR_1 . METHOD_2 ( ) . add ( this ) ; } for ( final TYPE_2 view : VAR_1 . METHOD_3 ( ) ) { METHOD_4 ( view ) ; } } 
public TYPE_1 ( final int VAR_2 , final int VAR_3 ) { <START> super ( VAR_3 , VAR_2 ) ; <END> } 
public TYPE_4 ( boolean VAR_2 , int VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; VAR_4 = TYPE_1 . METHOD_1 ( ) . METHOD_2 ( ) ; VAR_5 = new HashSet ( ) ; TYPE_2 VAR_6 = TYPE_2 . getInstance ( ) ; <START> VAR_6 . METHOD_3 ( TYPE_2 . VAR_7 ) ; <END> VAR_8 = new TYPE_3 ( VAR_6 ) ; METHOD_4 ( ) ; } 
protected void METHOD_1 ( final TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( METHOD_5 ( ) ) ; VAR_1 . METHOD_6 ( METHOD_7 ( ) ) ; <START> VAR_1 . METHOD_8 ( METHOD_9 ( ) ) ; <END> final TYPE_2 VAR_2 = METHOD_10 ( new TYPE_3 ( METHOD_11 ( ) ) ) ; VAR_1 . METHOD_12 ( VAR_2 ) ; VAR_1 . METHOD_13 ( VAR_2 ) ; } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , boolean VAR_4 , boolean VAR_5 ) { super ( VAR_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_2 = VAR_2 ; this . VAR_6 = new TYPE_3 ( ) { @Override public void METHOD_1 ( TYPE_4 event ) { <START> if ( event . VAR_7 == SWT . VAR_8 ) <END> METHOD_2 ( ) ; } } ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( SWT . TYPE_5 , VAR_6 ) ; } 
public void METHOD_1 ( ) { String VAR_1 = METHOD_2 ( STRING_1 ) ; <START> assertEquals ( VAR_1 , "" ) ; <END> } 
public void METHOD_1 ( ) { String VAR_1 = METHOD_2 ( STRING_1 ) ; assertEquals ( VAR_1 , STRING_2 ) ; <START> } <END> 
public void METHOD_1 ( ) { if ( VAR_1 ) { <START> VAR_2 . close ( ) ; <END> } } 
private static String METHOD_1 ( TYPE_1 e ) { <START> String VAR_1 = e . VAR_2 ( ) ; <END> if ( VAR_1 . equals ( "" ) ) return null ; return VAR_1 ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 { final TYPE_4 < TYPE_5 > VAR_3 = VAR_1 . METHOD_2 ( ) ; for ( final TYPE_5 VAR_4 : VAR_3 ) { if ( TYPE_6 . class . METHOD_3 ( VAR_4 ) ) { final TYPE_6 VAR_5 = ( TYPE_6 ) VAR_4 ; final boolean VAR_6 = VAR_5 . METHOD_4 ( VAR_2 ) ; if ( ! VAR_6 ) { <START> throw new TYPE_3 ( Messages . TYPE_7 ) ; <END> } return ; } } throw new TYPE_3 ( Messages . TYPE_7 ) ; } 
public boolean METHOD_1 ( View VAR_1 ) { boolean TYPE_5 ; String VAR_3 = TYPE_1 . METHOD_2 ( VAR_1 , TYPE_3 . VAR_5 , TYPE_3 . VAR_6 ) ; <START> TYPE_5 = TYPE_3 . TYPE_4 . equals ( VAR_3 ) ; <END> return TYPE_5 ; } 
void METHOD_1 ( ) { <START> VAR_1 = new HashMap < String , Integer > ( ) ; <END> Integer VAR_2 = new Integer ( VAR_3 ) ; for ( String VAR_4 : VAR_5 ) VAR_1 . put ( VAR_4 , VAR_2 ) ; } 
<START> String METHOD_1 ( Date VAR_1 ) throws TYPE_1 { <END> String VAR_2 = format . format ( VAR_1 ) ; try { TYPE_2 . METHOD_2 ( TYPE_2 . VAR_3 + STRING_1 + VAR_2 ) ; } catch ( IllegalArgumentException e ) { throw new TYPE_1 ( STRING_2 + format . VAR_4 ( ) + STRING_3 ) ; } return VAR_2 ; } 
public String METHOD_1 ( ) { try { return METHOD_2 ( ) ; } catch ( TYPE_1 e ) { if ( ! VAR_1 ) { METHOD_3 ( ) ; <START> return METHOD_2 ( ) ; <END> } return null ; } } 
private static void METHOD_1 ( ) { synchronized ( VAR_1 ) { <START> while ( VAR_2 > 0 ) { <END> try { VAR_1 . METHOD_2 ( INT_1 ) ; } catch ( InterruptedException e ) { } } if ( VAR_1 . isEmpty ( ) == false ) { TYPE_1 buffer = new TYPE_1 ( ) ; for ( String VAR_3 : VAR_1 ) { buffer . append ( STRING_1 + VAR_3 ) ; } VAR_1 . clear ( ) ; Assert . assertTrue ( buffer . toString ( ) , false ) ; } } } 
public TYPE_1 METHOD_1 ( TYPE_2 req , String name ) throws TYPE_3 , TYPE_4 { if ( ! name . equals ( VAR_1 ) ) <START> throw new TYPE_3 ( name ) ; <END> TYPE_1 db = repo . VAR_2 ( ) ; db . VAR_3 ( ) ; return db ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) throws IOException { <START> return new TYPE_2 ( METHOD_2 ( ) , STRING_1 ) . start ( VAR_1 ) ; <END> } 
public < T extends TYPE_2 . TYPE_5 > T METHOD_1 ( TYPE_2 connection , Class < T > VAR_1 ) { if ( TYPE_3 . class . equals ( VAR_1 ) ) { return ( T ) new TYPE_4 ( connection ) ; } else { <START> return null ; <END> } } 
protected void METHOD_1 ( ) { TYPE_1 <START> VAR_1 = <END> TYPE_2 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( TYPE_3 . VAR_3 ) ; } 
public long METHOD_1 ( int index ) { <START> return VAR_1 + ( long ) ( index * VAR_2 + FLOAT_1 ) ; <END> } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , Map < Object , Object > context ) { TYPE_3 status = Status . VAR_3 ; if ( VAR_2 != null ) { if ( ! METHOD_2 ( VAR_1 , context ) ) { <START> if ( METHOD_3 ( VAR_1 ) ) { <END> status = VAR_4 . METHOD_4 ( VAR_1 , new TYPE_4 ( ) ) ; METHOD_5 ( VAR_1 , context , status ) ; METHOD_6 ( status , VAR_2 ) ; } } } return status . VAR_5 ( ) ; } 
public int METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 , TYPE_2 VAR_3 ) { String VAR_4 ; <START> synchronized ( VAR_5 ) { <END> VAR_4 = TYPE_3 . format ( new Date ( VAR_2 / VAR_6 ) ) ; } return Utils . VAR_7 ( VAR_1 , VAR_4 , VAR_3 , true ) ; } 
public int METHOD_1 ( int VAR_1 ) { <START> int VAR_2 = VAR_3 . METHOD_2 ( ) . x ; <END> int VAR_4 = VAR_2 - VAR_1 ; return VAR_4 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( TYPE_4 < TYPE_3 > METHOD_3 ( ) ) ; <END> } 
public static void METHOD_1 ( int VAR_1 , String message , Throwable VAR_2 , boolean VAR_3 ) { TYPE_1 status = new Status ( VAR_1 , METHOD_2 ( ) , message , VAR_2 ) ; int VAR_4 = TYPE_2 . LOG ; <START> if ( VAR_3 ) <END> VAR_4 |= TYPE_2 . VAR_5 ; TYPE_2 . METHOD_3 ( ) . METHOD_4 ( status , VAR_4 ) ; } 
public boolean METHOD_1 ( ) { <START> return version . VAR_1 ( VAR_2 ) >= 0 && version . VAR_1 ( VAR_3 ) < 0 ; <END> } 
<START> boolean METHOD_1 ( TYPE_1 <END> VAR_1 ) { return ( VAR_1 instanceof TYPE_2 || VAR_1 instanceof TYPE_3 ) ; } 
public void METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) { final TYPE_1 VAR_1 = TYPE_2 . METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) . METHOD_6 ( ) ) ; VAR_1 . METHOD_7 ( this . METHOD_8 ( ) ) ; super . METHOD_1 ( ) ; TYPE_3 . METHOD_1 ( this ) ; } <START> TYPE_4 VAR_2 = METHOD_8 ( ) ; if ( VAR_2 . METHOD_9 ( ) ) { VAR_2 . METHOD_10 ( ) ; } <END> } 
public TYPE_2 ( final String VAR_2 , final Collection < TYPE_1 > VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; TYPE_1 VAR_4 = ( TYPE_1 ) <START> VAR_3 . METHOD_1 ( ) [ 0 ] ; <END> VAR_5 = VAR_4 . METHOD_2 ( ) ; } 
<START> public static void METHOD_1 ( ) { <END> VAR_1 = new TYPE_1 ( TYPE_2 . METHOD_2 ( ) , TYPE_2 . METHOD_3 ( ) , TYPE_2 . METHOD_4 ( ) ) ; VAR_2 = new TYPE_1 ( TYPE_2 . METHOD_5 ( ) ) ; } 
public void METHOD_1 ( int VAR_1 ) { <START> int VAR_2 = this . VAR_3 ; <END> this . VAR_3 = VAR_1 ; if ( VAR_2 != VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( new TYPE_1 [ ] { this } ) ; } } 
public int METHOD_1 ( TYPE_1 o ) { int VAR_1 = METHOD_2 ( ) . METHOD_1 ( o . VAR_2 ( ) ) ; if ( VAR_1 == 0 ) { if ( METHOD_3 ( ) != null ) { <START> if ( o . VAR_3 ( ) != null ) { <END> VAR_1 = METHOD_3 ( ) . METHOD_1 ( o . VAR_3 ( ) ) ; } } } return VAR_1 ; } 
private void METHOD_1 ( final TYPE_1 e ) { TYPE_1 p = e . VAR_1 ; TYPE_1 n = e . VAR_2 ; <START> if ( p != null ) <END> p . VAR_2 = n ; else VAR_3 = n ; if ( n != null ) n . VAR_1 = p ; else VAR_4 = p ; } 
public static void METHOD_1 ( String task , TYPE_1 < TYPE_2 > VAR_1 ) { TYPE_3 group = METHOD_2 ( ) ; try { group . VAR_2 ( task , size ( VAR_1 ) ) ; for ( TYPE_2 job : VAR_1 ) { job . VAR_3 ( group , 1 ) ; job . VAR_4 ( ) ; } for ( TYPE_2 job : VAR_1 ) { <START> job . VAR_5 ( ) ; <END> } } catch ( InterruptedException e ) { } finally { group . VAR_6 ( ) ; } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( this . VAR_1 != null ) { this . VAR_1 . METHOD_1 ( ) ; this . VAR_1 = null ; } VAR_2 . clear ( ) ; for ( TYPE_1 VAR_3 : TYPE_2 . METHOD_2 ( ) ) { TYPE_3 VAR_4 = VAR_3 . METHOD_3 ( ) ; if ( VAR_4 != null ) { VAR_4 . METHOD_1 ( ) ; } } <START> VAR_5 . METHOD_4 ( ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; METHOD_4 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; <START> assertEquals ( Collections . VAR_3 ( ) , METHOD_5 ( TYPE_1 . class ) ) ; <END> } 
<START> public static TYPE_1 [ ] METHOD_1 ( TYPE_2 connection ) { <END> return new TYPE_3 ( ) . METHOD_1 ( connection ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 item ) { <START> return item != null ? item : METHOD_2 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 data ) { TYPE_3 VAR_1 = new TYPE_3 ( logger , VAR_2 ) ; TYPE_1 VAR_3 = null ; try { METHOD_2 ( data ) ; VAR_3 = VAR_1 . METHOD_3 ( data , VAR_4 ) ; <START> } catch ( Exception ex ) { <END> throw new TYPE_4 ( Status . VAR_5 , STRING_1 , ex ) ; } return VAR_3 ; } 
private TYPE_1 METHOD_1 ( String name ) throws IOException { final TYPE_2 id = db . VAR_1 ( name ) ; if ( id == null ) throw new IllegalArgumentException ( name ) ; final TYPE_3 p = new TYPE_3 ( ) ; <START> try ( final TYPE_4 VAR_2 = db . VAR_3 ( ) ) { <END> p . VAR_4 ( VAR_2 , new TYPE_5 ( db ) . METHOD_2 ( id ) ) ; return p ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_2 == null || VAR_1 instanceof TYPE_3 ) { return ; } TYPE_4 VAR_3 = TYPE_5 . METHOD_2 ( VAR_2 ) ; System . out . println ( STRING_1 + VAR_1 + STRING_2 <START> + VAR_3 . size ( ) ) ; <END> if ( VAR_3 . isEmpty ( ) ) { return ; } METHOD_3 ( VAR_3 ) ; } 
protected VAR_1 ( ) { <START> VAR_2 = new TYPE_1 < File > ( METHOD_1 ( ) ) ; <END> } 
<START> protected View METHOD_1 ( ) { <END> if ( METHOD_2 ( ) . METHOD_3 ( ) instanceof View ) { if ( ( ( View ) METHOD_2 ( ) . METHOD_3 ( ) ) instanceof View ) { return ( View ) ( ( View ) METHOD_2 ( ) . METHOD_3 ( ) ) ; } return null ; } return null ; } 
public TYPE_1 [ ] METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( new TYPE_1 [ VAR_1 . size ( ) ] ) ; <END> } 
<START> public long <END> METHOD_1 ( ) { return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 entry ) { if <START> ( entry . equals ( VAR_1 ) ) <END> { return VAR_2 ; } throw new IllegalArgumentException ( ) ; } 
public Builder METHOD_1 ( final String VAR_1 ) { <START> if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { <END> this . VAR_1 = VAR_1 ; } return this ; } 
public Builder cmd ( final List < String > cmd ) { <START> if ( cmd != null && ! cmd . isEmpty ( ) ) { <END> this . cmd = new ArrayList < String > ( cmd ) ; } return this ; } 
public Builder METHOD_1 ( final String VAR_1 ) { <START> if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { <END> return METHOD_1 ( VAR_1 . split ( STRING_1 ) ) ; } return this ; } 
public void METHOD_1 ( long time , boolean VAR_1 ) { synchronized ( VAR_2 ) { <START> if ( VAR_3 != null && VAR_3 . METHOD_2 ( ) ) { <END> return ; } } METHOD_3 ( time , VAR_1 , false ) ; } 
public void METHOD_1 ( long VAR_1 , long VAR_2 ) { synchronized ( VAR_3 ) { <START> if ( VAR_4 != null && VAR_4 . METHOD_2 ( ) ) { <END> return ; } } VAR_5 = Math . max ( VAR_6 , Math . VAR_7 ( VAR_8 , VAR_1 ) ) ; VAR_9 = Math . max ( VAR_6 , Math . VAR_7 ( VAR_8 , VAR_2 ) ) ; VAR_10 . METHOD_3 ( ) ; VAR_11 . METHOD_3 ( ) ; } 
protected boolean METHOD_1 ( ) { <START> return true ; <END> } 
public TYPE_1 < String > METHOD_1 ( String VAR_1 ) { boolean contains = false ; String VAR_2 = VAR_1 ; if ( VAR_1 . METHOD_2 ( STRING_1 ) ) { contains = true ; VAR_2 = VAR_2 + STRING_2 ; <START> } if ( VAR_1 . contains ( STRING_3 ) ) <END> { contains = true ; VAR_2 = VAR_2 . METHOD_3 ( STRING_3 , STRING_4 ) ; } if ( contains ) { return TYPE_2 . METHOD_4 ( VAR_2 ) ; } else { return super . METHOD_1 ( VAR_1 ) ; } } 
public boolean METHOD_1 ( TYPE_1 configuration ) throws TYPE_2 { if ( METHOD_2 ( configuration ) ) { <START> if ( configuration . VAR_1 ( ) ) <END> return true ; METHOD_3 ( configuration ) ; return METHOD_4 ( configuration ) ; } else if ( VAR_2 . contains ( configuration ) ) { TYPE_3 VAR_3 = METHOD_5 ( ) ; VAR_3 . METHOD_3 ( configuration ) ; VAR_3 . METHOD_6 ( configuration ) ; return true ; } else { return false ; } } 
<START> public boolean METHOD_1 ( final Object element ) { <END> if ( element instanceof TYPE_1 ) { final Object object = ( ( TYPE_1 ) element ) . METHOD_2 ( ) ; if ( object instanceof TYPE_2 ) { TYPE_2 VAR_1 = ( TYPE_2 ) object ; Object VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( VAR_2 instanceof TYPE_3 ) { final TYPE_4 VAR_3 = ( ( TYPE_3 ) VAR_2 ) . METHOD_4 ( ) ; return VAR_3 instanceof TYPE_5 || VAR_3 instanceof TYPE_6 ; } } } return false ; } 
private String METHOD_1 ( final TYPE_1 table , final Object VAR_1 ) { <START> if ( VAR_1 instanceof TYPE_2 ) { <END> return Constants . VAR_2 ; } else if ( VAR_1 instanceof TYPE_3 ) { return Constants . VAR_3 ; } else { return "" ; } } 
private TYPE_1 METHOD_1 ( String value ) { if ( TYPE_2 . METHOD_2 ( STRING_1 ) != null ) { String VAR_1 = TYPE_3 . METHOD_3 ( VAR_2 , value ) ; if ( VAR_1 != null ) { TYPE_1 VAR_3 = TYPE_3 . METHOD_4 ( VAR_1 ) ; if ( VAR_3 != null ) { return VAR_3 ; } } } <START> return METHOD_5 ( ) . METHOD_6 ( ) ; <END> } 
public synchronized void METHOD_1 ( TYPE_1 location ) { if ( location != null ) { TYPE_2 iterator = METHOD_2 ( ) ; <START> iterator . VAR_1 ( ( ( TYPE_3 ) location ) . METHOD_3 ( ) ) ; <END> VAR_2 = iterator . VAR_3 ( ) ; } else { VAR_2 = null ; } } 
protected View METHOD_1 ( ) { TYPE_1 host = METHOD_2 ( ) ; if ( host == null ) { return null ; } Object VAR_1 = host . VAR_2 ( ) ; if ( VAR_1 instanceof View ) { <START> if ( ( ( View ) METHOD_2 ( ) . METHOD_3 ( ) ) instanceof View ) { <END> return ( View ) ( ( View ) METHOD_2 ( ) . METHOD_3 ( ) ) ; } return null ; } return null ; } 
public void METHOD_1 ( ) throws Exception { <START> String result = <END> METHOD_2 ( STRING_1 + METHOD_3 ( ) . METHOD_4 ( ) + STRING_2 , TYPE_1 . VAR_2 , null , VAR_3 . VAR_4 . VAR_5 . VAR_6 . Response . Status . VAR_7 . METHOD_5 ( ) ) ; Assert . assertTrue ( result . contains ( STRING_3 ) ) ; } 
<START> public boolean METHOD_1 ( View VAR_1 ) { <END> boolean empty = true ; if ( METHOD_2 ( VAR_1 ) ) { Iterator < ? > VAR_2 = VAR_1 . METHOD_3 ( ) . iterator ( ) ; while ( VAR_2 . hasNext ( ) && empty ) { Object child = VAR_2 . next ( ) ; if ( METHOD_4 ( child ) ) { empty = ! ( ( View ) child ) . METHOD_5 ( ) ; } } } return ! empty ; } 
public void METHOD_1 ( ) { if ( ! VAR_1 . isEmpty ( ) ) { <START> if ( VAR_2 != null ) { <END> for ( TYPE_1 VAR_3 : VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( VAR_4 . METHOD_4 ( VAR_2 , VAR_3 ) , this ) ; METHOD_2 ( ) . METHOD_3 ( VAR_4 . METHOD_5 ( VAR_2 , VAR_3 ) , this ) ; } } } } 
protected void METHOD_1 ( final TYPE_1 VAR_1 , final View VAR_2 ) { <START> if ( VAR_2 != null ) { <END> TYPE_2 . METHOD_2 ( ) . METHOD_3 ( new TYPE_3 ( ) { @Override public void run ( ) { if ( TYPE_4 . METHOD_4 ( VAR_2 ) == VAR_1 ) { TYPE_5 command = new TYPE_5 ( VAR_2 ) ; try { TYPE_6 . write ( VAR_1 , command ) ; } catch ( Exception e ) { TYPE_7 . log . error ( e ) ; } } } } ) ; } } 
protected boolean METHOD_1 ( final View view ) { boolean result = false ; <START> if ( view . VAR_1 ( ) instanceof TYPE_1 && ! ( ( TYPE_1 ) view . VAR_1 ( ) ) . METHOD_2 ( ) . isEmpty ( ) ) { <END> result = true ; } return result ; } 
public void METHOD_1 ( int VAR_1 ) { METHOD_2 ( ) ; if ( this . VAR_1 == VAR_1 ) return ; long VAR_2 = METHOD_3 ( ) ; if ( VAR_2 != 0 ) METHOD_4 ( VAR_2 ) ; this . VAR_1 = VAR_1 ; <START> if ( VAR_2 != 0 ) { METHOD_5 ( VAR_2 ) ; } } <END> 
public static < TYPE_1 > TYPE_2 < TYPE_1 > METHOD_1 ( final List < TYPE_3 < TYPE_1 > > VAR_1 ) { final TYPE_3 < ? > [ ] VAR_2 <START> = <END> VAR_1 . METHOD_2 ( new TYPE_3 [ VAR_1 . size ( ) ] ) ; return new TYPE_2 < TYPE_1 > ( ) { @Override public TYPE_3 < ? > [ ] METHOD_3 ( ) { return VAR_2 ; } } ; } 
private T METHOD_1 ( ) { for ( TYPE_1 VAR_1 : options ) { if <START> ( Boolean . VAR_2 . equals ( VAR_1 . VAR_3 . getValue ( ) ) ) <END> return VAR_1 . value ; } return null ; } 
protected void METHOD_1 ( Object value ) { int index = METHOD_2 ( value ) ; try { VAR_1 = true ; for ( int i = 0 ; i < options . size ( ) ; i ++ ) { <START> options . get ( i ) . VAR_2 . METHOD_3 ( i == index ? Boolean . VAR_3 : Boolean . VAR_4 ) ; <END> } } finally { VAR_1 = false ; } METHOD_4 ( index ) ; } 
public boolean addAll ( Collection < ? extends TYPE_1 > c ) { boolean VAR_1 = false ; for <START> ( Iterator < ? <END> extends TYPE_1 > iterator = c . iterator ( ) ; iterator . hasNext ( ) ; ) { TYPE_1 element = iterator . next ( ) ; VAR_1 |= VAR_2 . add ( TYPE_2 . METHOD_1 ( element ) ) ; } return VAR_1 ; } 
protected Boolean METHOD_1 ( ) { return <START> VAR_1 . METHOD_2 ( ) ? Boolean . VAR_2 : Boolean . VAR_3 ; <END> } 
boolean METHOD_1 ( Object value ) { for <START> ( Iterator < TYPE_1 > <END> it = VAR_1 . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { TYPE_1 cache = it . next ( ) ; if ( cache . VAR_2 ( value ) ) return true ; } return false ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( ) . METHOD_3 ( ) . remove ( VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 cmd , String VAR_1 ) { <START> VAR_2 = true ; <END> VAR_3 . add ( cmd ) ; VAR_4 . append ( VAR_1 ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> VAR_2 = true ; <END> VAR_3 . add ( METHOD_2 ( METHOD_3 ( VAR_1 ) ) ) ; VAR_4 . append ( VAR_1 ) ; } 
public int METHOD_1 ( ) { int VAR_1 = 0 ; if ( this . METHOD_2 ( ) ) { VAR_1 ++ ; } for ( int i = 0 ; i < this . VAR_2 . length ; i ++ ) { <START> VAR_1 = VAR_1 * INT_1 + this . VAR_2 . METHOD_1 ( ) ; <END> } return VAR_1 ; } 
TYPE_1 METHOD_1 ( long VAR_1 , TYPE_2 VAR_2 ) { int VAR_3 = 0 ; int VAR_4 = 0 ; int VAR_5 = 0 ; OS . VAR_6 ( VAR_1 , VAR_2 ) ; VAR_3 = ( int ) ( VAR_2 . VAR_3 * INT_1 ) ; VAR_4 = ( int ) ( VAR_2 . VAR_4 * INT_1 ) ; VAR_5 = ( int ) ( VAR_2 . VAR_5 * INT_1 ) ; <START> VAR_7 = new TYPE_1 ( VAR_3 , VAR_4 , VAR_5 ) ; <END> return VAR_7 ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; VAR_2 . METHOD_4 ( VAR_1 . getMessage ( ) ) ; } <END> 
private static List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> HashSet < TYPE_1 > set <END> = new HashSet < > ( ) ; set . addAll ( VAR_1 ) ; return Arrays . asList ( set . VAR_2 ( new TYPE_1 [ set . size ( ) ] ) ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 instanceof TYPE_1 ) { return ( TYPE_1 ) VAR_1 ; } <START> else { <END> return null ; } } 
public TYPE_3 ( String name , TYPE_1 VAR_2 , int VAR_3 , char [ ] VAR_4 , TYPE_2 VAR_5 ) { this . name = name ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = <START> false ; <END> } 
protected TYPE_1 getType ( TYPE_2 VAR_1 ) { if ( ! METHOD_1 ( VAR_1 ) ) { if ( VAR_1 instanceof TYPE_3 ) { return ( ( TYPE_3 ) VAR_1 ) . getType ( ) ; } else { <START> return null ; <END> } } return null ; } 
protected void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { element . VAR_3 ( VAR_1 ) ; <START> element . VAR_4 ( new TYPE_2 ( TYPE_3 . VAR_6 , true , true , true ) ) ; <END> } } 
<START> public static void METHOD_1 ( TYPE_1 VAR_1 , <END> TYPE_1 VAR_2 , String VAR_3 , String VAR_4 , TYPE_2 VAR_5 , TYPE_3 VAR_6 ) { final TYPE_4 VAR_7 = TYPE_5 . METHOD_2 ( VAR_3 , VAR_1 , VAR_5 ) ; final TYPE_4 next = TYPE_5 . METHOD_2 ( VAR_4 , VAR_2 , VAR_5 ) ; TYPE_6 in = new TYPE_7 ( VAR_7 , next , VAR_5 , null ) ; TYPE_5 . METHOD_3 ( VAR_6 , in ) ; } 
public String getPath ( ) { TYPE_1 uri = VAR_1 . METHOD_1 ( ) ; <START> if ( uri != null ) { <END> return uri . getPath ( ) ; } return getName ( ) ; } 
protected void METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 VAR_3 ) throws TYPE_2 , IOException { project = TYPE_3 . METHOD_2 ( VAR_1 ) ; VAR_4 = TYPE_4 . METHOD_3 ( project , VAR_3 , METHOD_4 ( ) , VAR_2 ) ; if ( VAR_4 != null ) { <START> System . out . println ( STRING_1 ) ; <END> } } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> this . VAR_3 = VAR_2 ; <END> } 
protected void METHOD_1 ( final TYPE_1 VAR_1 , final View VAR_2 ) { if ( null != VAR_2 ) { <START> if ( VAR_1 != null && TYPE_2 . METHOD_2 ( VAR_2 ) == VAR_1 ) { <END> TYPE_3 command = new TYPE_3 ( VAR_2 ) ; try { TYPE_4 . write ( VAR_1 , command ) ; } catch ( Exception e ) { TYPE_5 . log . error ( e ) ; } } } } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 [ ] VAR_2 = new TYPE_1 [ VAR_1 . VAR_3 . size ( ) ] ; for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { <START> VAR_2 [ i ] = new TYPE_3 ( METHOD_2 ( VAR_1 . VAR_3 . get ( i ) . name ) , null , null ) ; <END> } TYPE_1 VAR_4 = new TYPE_3 ( TYPE_1 . VAR_5 , null , VAR_2 ) ; return VAR_4 ; } 
public Object METHOD_1 ( ANNOTATION_1 ( STRING_1 ) final Class VAR_1 ) { Object result ; <START> if ( STRING_2 . equals ( VAR_1 . toString ( ) ) ) { System . out . println ( ) ; } <END> if ( VAR_1 . METHOD_2 ( this ) ) { result = this ; } else { result = this . VAR_2 . METHOD_1 ( VAR_1 ) ; if ( result == null ) { result = super . METHOD_1 ( VAR_1 ) ; } } return result ; } 
public TYPE_1 METHOD_1 ( String id ) { <START> System . err . println ( id ) ; <END> for ( TYPE_1 column : VAR_1 ) { if ( column . VAR_2 ( ) . equals ( id ) ) { return column ; } } return null ; } 
private boolean METHOD_1 ( String format ) { <START> String VAR_1 = format . VAR_2 ( STRING_1 , "" ) ; <END> return ! VAR_1 . contains ( STRING_2 ) && ! VAR_1 . contains ( STRING_3 ) && ! VAR_1 . contains ( STRING_4 ) && ! VAR_1 . contains ( STRING_5 ) && ! VAR_1 . contains ( STRING_6 ) && ! VAR_1 . contains ( STRING_7 ) ; } 
public void METHOD_1 ( ) throws Throwable { <START> METHOD_2 ( false ) ; <END> } 
protected void METHOD_1 ( TYPE_1 trace , TYPE_2 VAR_1 , List < TYPE_3 > list ) { METHOD_1 ( trace , list ) ; synchronized ( VAR_2 ) { List < TYPE_3 > VAR_3 = VAR_2 . get ( VAR_1 ) ; if ( VAR_3 == null ) { VAR_2 . put ( VAR_1 , new TYPE_4 < > ( list ) ) ; } else { VAR_3 . addAll ( list ) ; } <START> VAR_4 . put ( trace , VAR_1 ) ; <END> } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { <START> return ; <END> } TYPE_2 < TYPE_3 > results = VAR_1 . METHOD_2 ( ) ; if ( results != null ) { METHOD_3 ( TYPE_4 . METHOD_4 ( results ) ) ; return ; } TYPE_4 . METHOD_5 ( VAR_2 ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( ) ; <END> super . METHOD_1 ( ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null ) { <START> VAR_2 . METHOD_3 ( VAR_3 ) ; <END> if ( VAR_2 . METHOD_4 ( ) == null ) { if ( TYPE_3 . METHOD_5 ( ) ) { return ; } } VAR_4 = TYPE_3 . METHOD_6 ( VAR_2 ) ; METHOD_7 ( VAR_4 ) ; } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null ) { <START> VAR_2 . METHOD_3 ( VAR_3 ) ; <END> TYPE_3 . METHOD_4 ( ) ; } } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 ) { if ( VAR_1 != null ) { TYPE_3 < TYPE_4 > results = VAR_1 . METHOD_2 ( ) ; if ( results != null ) { <START> return METHOD_3 ( results ) ; <END> } } return new TYPE_1 ( new TYPE_5 < > ( ) ) ; } 
public void METHOD_1 ( int index ) { final TYPE_1 VAR_1 = VAR_2 ; final TYPE_2 [ ] VAR_3 = VAR_4 ; <START> if ( VAR_1 != null && VAR_3 != null ) { VAR_1 . METHOD_2 ( VAR_3 [ index ] , index ) ; } <END> } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 Object VAR_2 , ANNOTATION_1 Object VAR_3 ) { VAR_4 = ( TYPE_2 ) VAR_1 ; if ( VAR_3 instanceof TYPE_3 < ? > ) { TYPE_3 < ? > VAR_5 = ( TYPE_3 < ? > ) VAR_3 ; VAR_6 = TYPE_4 . METHOD_2 ( VAR_5 , TYPE_5 . class ) ; if ( VAR_7 != null ) { Arrays . VAR_8 ( VAR_6 , VAR_7 ) ; } <START> } <END> } 
protected boolean <START> METHOD_1 ( char <END> VAR_1 ) { return TYPE_1 . METHOD_2 ( VAR_1 ) ; } 
public String getPath ( ) { <START> try { return file . VAR_1 ( ) . getPath ( ) ; } catch ( TYPE_1 e ) { return file . VAR_2 ( ) ; } <END> } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> this . VAR_2 = VAR_1 ; } 
protected String METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 . METHOD_2 ( VAR_2 ) ; <END> if ( VAR_1 != null ) { Object VAR_3 = VAR_2 . METHOD_3 ( VAR_1 , TYPE_3 . class ) ; if ( VAR_3 instanceof TYPE_3 ) { return ( ( TYPE_3 ) VAR_3 ) . METHOD_4 ( VAR_1 ) ; } } return null ; } 
public void METHOD_1 ( int index ) { final TYPE_1 VAR_1 = VAR_2 ; final TYPE_2 [ ] VAR_3 = VAR_4 ; if ( ( VAR_1 != null ) && ( VAR_3 != null ) && <START> ( VAR_3 . length > index ) && ! VAR_5 ) { <END> VAR_5 = true ; VAR_1 . METHOD_2 ( VAR_3 [ index ] , index ) ; VAR_5 = false ; } } 
<START> public void METHOD_1 ( final boolean VAR_1 , final boolean VAR_2 ) { <END> final TYPE_1 VAR_3 = METHOD_2 ( ) ; if ( VAR_3 . METHOD_3 ( ) ) { return ; } TYPE_2 . METHOD_4 ( ) . METHOD_5 ( new TYPE_3 ( ) { @Override public void run ( ) { if ( ! VAR_3 . METHOD_3 ( ) ) { VAR_4 . METHOD_6 ( VAR_1 , VAR_2 ) ; } } } ) ; } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> METHOD_2 ( ) ; METHOD_3 ( false ) ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
<START> public void METHOD_1 ( ) { <END> final TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . METHOD_3 ( ) ) { return ; } TYPE_2 . METHOD_4 ( ) . METHOD_5 ( new TYPE_3 ( ) { @Override public void run ( ) { if ( ! VAR_1 . METHOD_3 ( ) ) { VAR_2 . METHOD_6 ( ) ; } } } ) ; } 
<START> public void METHOD_1 ( boolean VAR_1 , TYPE_1 VAR_2 ) { <END> Map < TYPE_1 , TYPE_2 > VAR_3 = VAR_1 ? VAR_4 : VAR_5 ; TYPE_2 job = VAR_3 . remove ( VAR_2 ) ; if ( job != null ) { job . VAR_6 ( ) ; } } 
public void METHOD_1 ( final TYPE_1 context ) { TYPE_2 . METHOD_2 ( ) . METHOD_3 ( new TYPE_3 ( ) { @Override public void run ( ) { <START> synchronized ( context . VAR_1 ( ) ) { <END> if ( ! context . VAR_2 ( ) ) { context . VAR_3 ( ) ; context . VAR_4 ( ) . METHOD_4 ( ) ; } } } } ) ; } 
public void METHOD_1 ( TYPE_1 parent , String VAR_1 , TYPE_2 trace ) { super . METHOD_1 ( parent , VAR_1 ) ; VAR_2 ++ ; VAR_3 = VAR_2 ; VAR_4 = trace ; <START> VAR_5 = new TYPE_3 ( ) ; <END> VAR_6 = ( trace instanceof TYPE_4 ) ; METHOD_2 ( parent ) ; METHOD_3 ( ) ; } 
public Boolean exists ( Collection < Object > VAR_1 , TYPE_1 VAR_2 ) { Boolean result = Boolean . VAR_3 ; if ( VAR_1 != null && VAR_2 == null ) { result = Boolean . VAR_3 ; } else { <START> for ( Object input : VAR_1 ) { <END> try { if ( Boolean . VAR_4 . equals ( VAR_2 . METHOD_1 ( new Object [ ] { input } ) ) ) { result = Boolean . VAR_4 ; break ; } } catch ( Exception e ) { } } } return result ; } 
<START> public Map < String , TYPE_1 > METHOD_1 ( long VAR_1 , String VAR_2 ) { <END> TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 , "" ) ; TYPE_1 VAR_4 = METHOD_3 ( ) . METHOD_4 ( VAR_1 ) . METHOD_5 ( VAR_2 ) . METHOD_6 ( ) . METHOD_7 ( ) ; List < TYPE_1 > VAR_5 = VAR_4 . METHOD_8 ( ) ; return METHOD_9 ( VAR_5 , VAR_3 ) ; } 
protected TYPE_1 METHOD_1 ( int VAR_1 ) { <START> TYPE_2 ctx = VAR_2 . METHOD_2 ( ) . METHOD_3 ( 0 ) ; <END> for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_2 . METHOD_2 ( ) . METHOD_4 ( ctx ) ; } final TYPE_1 next = VAR_2 . METHOD_2 ( ) . METHOD_4 ( ctx ) ; ctx . VAR_3 ( ) ; return next ; } 
<START> private void METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ; METHOD_4 ( VAR_2 . METHOD_5 ( METHOD_6 ( ) , VAR_1 ) ) ; } 
public static TYPE_1 METHOD_1 ( ) { TYPE_1 path = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ; path = path . VAR_1 ( ) . append ( VAR_2 ) ; File VAR_3 = path . VAR_4 ( ) ; if ( ! VAR_3 . exists ( ) || ! VAR_3 . METHOD_4 ( ) ) { VAR_3 . METHOD_5 ( ) ; } <START> VAR_3 . METHOD_6 ( ) ; <END> return path ; } 
public TYPE_3 ( final TYPE_1 model ) { super ( STRING_1 , TYPE_2 . getString ( STRING_2 ) , TYPE_4 . VAR_3 ) ; METHOD_1 ( TYPE_2 . getString ( STRING_2 ) ) ; <START> METHOD_2 ( true ) ; <END> this . model = model ; } 
public Object [ ] METHOD_1 ( Object VAR_1 ) { <START> List < TYPE_1 > list = new ArrayList < TYPE_1 > ( ) ; <END> Iterator < TYPE_1 > iterator = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { TYPE_1 VAR_2 = iterator . next ( ) ; list . add ( VAR_2 ) ; } return list . VAR_3 ( ) ; } 
public TYPE_1 <START> METHOD_1 ( TYPE_2 <END> event ) throws TYPE_3 { List < TYPE_4 > VAR_1 = event . VAR_2 ( ) ; TYPE_5 VAR_3 = new TYPE_5 ( ) ; for ( TYPE_4 VAR_4 : VAR_1 ) { TYPE_1 VAR_5 = METHOD_2 ( VAR_4 ) ; if ( null != VAR_5 ) { VAR_3 . append ( VAR_5 ) ; } } return VAR_3 . isEmpty ( ) ? null : VAR_3 ; } 
public String METHOD_1 ( Object element ) { String VAR_1 = <START> VAR_2 ; <END> if ( element instanceof TYPE_1 ) { VAR_1 = ( ( TYPE_1 ) element ) . getName ( ) ; } else { VAR_1 = super . METHOD_1 ( element ) ; } return VAR_1 ; } 
public String METHOD_1 ( final Object element ) { String text = STRING_1 ; if ( element instanceof TYPE_1 ) { text = <START> element . toString ( ) ; <END> } return text ; } 
public TYPE_1 METHOD_1 ( ) { <START> Collection < TYPE_2 > VAR_1 = Arrays . asList ( VAR_2 . METHOD_2 ( ) ) ; <END> Set < TYPE_3 > VAR_3 = METHOD_3 ( VAR_1 ) ; return new TYPE_1 ( VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 parent ) { TYPE_1 table = ( TYPE_1 ) METHOD_2 ( ) ; if ( table == null ) { VAR_1 = parent ; VAR_2 = METHOD_3 ( parent , SWT . VAR_3 | SWT . VAR_4 | SWT . VAR_5 | SWT . VAR_6 | SWT . VAR_7 ) ; table = VAR_2 . METHOD_4 ( ) ; table . VAR_8 ( parent . VAR_9 ( ) ) ; VAR_2 . METHOD_5 ( new TYPE_3 ( ) ) ; VAR_2 . METHOD_6 ( this ) ; } <START> else { <END> } return table ; } 
<START> private List < Object > METHOD_1 ( ) { <END> List < Object > result = new ArrayList ( this . VAR_1 . length ) ; for ( String VAR_2 : this . VAR_1 ) { result . add ( VAR_2 ) ; } return result ; } 
public boolean METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( TYPE_1 . VAR_2 , VAR_3 . METHOD_4 ( ) ) ; <START> System . out . println ( VAR_3 . METHOD_4 ( ) ) ; <END> System . out . println ( VAR_4 . METHOD_4 ( ) ) ; METHOD_2 ( ) . METHOD_3 ( TYPE_1 . VAR_5 , VAR_4 . METHOD_4 ( ) ) ; return super . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) <START> throws Exception { <END> METHOD_2 ( null ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { List < TYPE_3 > VAR_3 = METHOD_2 ( VAR_2 . METHOD_3 ( ) , ( ( TYPE_4 ) VAR_1 ) . METHOD_4 ( ) ) ; if ( ! VAR_3 . isEmpty ( ) ) { TYPE_6 . TYPE_7 . METHOD_5 ( VAR_2 , VAR_3 ) ; <START> } <END> } 
<START> TYPE_2 . TYPE_3 METHOD_1 ( ) { <END> return VAR_1 . METHOD_1 ( ) ; } 
Set < TYPE_2 . TYPE_3 > METHOD_1 ( Set < TYPE_2 . TYPE_3 > VAR_1 ) { Set < TYPE_2 . TYPE_3 > VAR_2 = new HashSet < TYPE_2 . TYPE_3 > ( ) ; <START> if ( VAR_1 != null ) VAR_2 . addAll ( VAR_1 ) ; <END> VAR_2 . add ( METHOD_2 ( ) ) ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( String path , boolean VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( ( TYPE_3 ) VAR_3 ) ; TYPE_4 file = METHOD_3 ( ( TYPE_3 ) VAR_3 ) ; boolean VAR_4 ; <START> if ( file == null ) { <END> VAR_4 = false ; } else { VAR_4 = true ; } if ( ! VAR_1 && VAR_2 != null ) { return new TYPE_5 ( path , VAR_4 , VAR_2 . METHOD_4 ( ) , VAR_2 . METHOD_5 ( ) ) ; } else { return new TYPE_5 ( path , VAR_4 ) ; } } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . METHOD_4 ( ) . METHOD_5 ( TYPE_3 . VAR_3 ) ) ; <END> } 
private View METHOD_1 ( TYPE_1 VAR_1 ) { View VAR_2 = null ; Iterator < ? > iterator = VAR_3 . METHOD_2 ( ) . iterator ( ) ; while ( iterator . hasNext ( ) <START> && null == VAR_2 ) { <END> Object child = iterator . next ( ) ; if ( ( child instanceof TYPE_2 ) && ( ( TYPE_2 ) child ) . METHOD_3 ( ) . equals ( VAR_1 ) ) { VAR_2 = ( TYPE_2 ) child ; } } return VAR_2 ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( TYPE_4 . VAR_4 ) ; TYPE_2 [ ] VAR_5 = null ; try { VAR_5 = VAR_1 . call ( ) ; } catch ( TYPE_3 e ) { METHOD_3 ( e . getMessage ( ) ) ; } <START> System . out . println ( VAR_5 [ 0 ] . METHOD_4 ( ) ) ; <END> assertEquals ( VAR_5 [ 0 ] . METHOD_4 ( ) , STRING_1 ) ; } 
public String METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public Collection < TYPE_1 > METHOD_1 ( TYPE_2 m , boolean VAR_1 ) throws TYPE_3 { <START> TYPE_2 monitor ; if ( m == null ) monitor = new TYPE_4 ( ) ; else monitor = m ; <END> METHOD_1 ( monitor , VAR_2 , VAR_1 ) ; return results ; } 
public void run ( TYPE_1 monitor ) throws TYPE_2 { ArrayList < TYPE_3 > list = new ArrayList < > ( ) ; if ( VAR_1 != null ) { <START> TYPE_4 VAR_2 = TYPE_4 . METHOD_1 ( monitor , "" , 3 ) ; <END> METHOD_2 ( list , VAR_2 . METHOD_3 ( 1 ) ) ; METHOD_4 ( list , VAR_2 . METHOD_3 ( 1 ) ) ; METHOD_5 ( list , VAR_2 . METHOD_3 ( 1 ) ) ; } VAR_3 = list . VAR_4 ( new TYPE_5 [ list . size ( ) ] ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 , TYPE_4 { TYPE_5 VAR_2 = new TYPE_5 ( TYPE_6 . format ( TYPE_8 . TYPE_9 , new Object [ ] { VAR_5 . METHOD_2 ( ) , VAR_5 . METHOD_3 ( ) } ) ) ; <START> TYPE_7 VAR_6 = TYPE_7 . METHOD_4 ( VAR_1 , "" , 2 ) ; <END> METHOD_5 ( VAR_2 , VAR_6 . METHOD_6 ( 1 ) ) ; if ( VAR_5 . METHOD_7 ( ) ) METHOD_8 ( VAR_2 , VAR_6 . METHOD_6 ( 1 ) ) ; return VAR_2 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , Collection < ? > VAR_2 , TYPE_2 monitor ) { if ( VAR_2 != null && VAR_2 . contains ( VAR_1 . getValue ( ) ) ) { <START> monitor . VAR_3 ( ) ; <END> return false ; } return ! METHOD_2 ( VAR_1 , monitor ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , String description ) { TYPE_2 VAR_2 = new TYPE_2 ( new TYPE_3 ( new TYPE_4 ( "" , "" ) ) , "" , VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) ) ; VAR_2 . METHOD_4 ( ) . METHOD_5 ( TYPE_6 . VAR_4 ) . METHOD_6 ( description ) ; try { when ( VAR_5 . METHOD_7 ( VAR_1 ) ) . METHOD_8 ( VAR_2 ) ; } catch ( TYPE_5 e ) { <START> e . VAR_6 ( ) ; <END> } } 
public void METHOD_1 ( ) { <START> org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_2 <END> VAR_8 = new org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_2 ( ) ; TYPE_1 VAR_9 = VAR_8 . METHOD_2 ( null ) ; Assert . assertEquals ( STRING_1 , TYPE_1 . VAR_10 , VAR_9 . METHOD_3 ( ) ) ; } 
public void METHOD_1 ( ) { org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_2 VAR_8 = new org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_2 ( ) ; org . VAR_1 . VAR_9 . VAR_10 . TYPE_4 VAR_12 = TYPE_3 . VAR_14 . METHOD_2 ( ) ; TYPE_1 VAR_15 = VAR_8 . METHOD_3 ( VAR_12 ) ; <START> Assert . assertEquals ( STRING_1 , TYPE_1 . VAR_16 , VAR_15 . METHOD_4 ( ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 project , TYPE_2 monitor ) throws TYPE_3 { if ( ! TYPE_4 . METHOD_2 ( ) ) { return ; } List < TYPE_5 > VAR_1 = METHOD_3 ( project ) ; if ( VAR_1 . size ( ) > 0 ) { TYPE_6 VAR_2 = new TYPE_6 ( VAR_1 ) ; TYPE_2 VAR_3 = new <START> TYPE_7 ( monitor , <END> 1 ) ; VAR_2 . execute ( VAR_3 ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_3 . METHOD_4 ( VAR_1 ) ; VAR_1 . METHOD_5 ( TYPE_4 . VAR_3 , true ) ; VAR_1 . METHOD_5 ( TYPE_4 . VAR_4 , false ) ; VAR_1 . METHOD_5 ( TYPE_4 . VAR_5 , true ) ; VAR_1 . METHOD_5 ( TYPE_4 . VAR_6 , true ) ; VAR_1 . METHOD_5 ( TYPE_4 . VAR_7 , true ) ; <START> VAR_1 . METHOD_5 ( TYPE_4 . VAR_8 , TYPE_4 . VAR_9 ) ; <END> } 
private void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <END> TYPE_1 VAR_2 = VAR_1 [ i ] ; VAR_2 . METHOD_2 ( VAR_3 ) ; } } } 
protected TYPE_3 ( TYPE_1 VAR_2 ) { super ( "" ) ; <START> METHOD_1 ( Messages . TYPE_4 ) ; <END> METHOD_2 ( Messages . TYPE_2 ) ; VAR_5 = VAR_2 ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 resource ) { if <START> ( resource instanceof <END> TYPE_1 ) { return ( TYPE_1 ) resource ; } return TYPE_3 . METHOD_2 ( resource , TYPE_1 . class , true ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , true ) ; TYPE_4 VAR_4 = VAR_2 . METHOD_3 ( ) ; <START> return ( TYPE_1 ) TYPE_5 . METHOD_4 ( VAR_4 , TYPE_1 . class , true ) ; <END> } 
public static TYPE_1 METHOD_1 ( Object o ) { <START> if ( o instanceof TYPE_1 ) { <END> return ( TYPE_1 ) o ; } return TYPE_2 . METHOD_2 ( o , TYPE_1 . class , true ) ; } 
public static boolean METHOD_1 ( File file ) throws IOException { try ( TYPE_1 VAR_1 = new TYPE_1 ( file ) ) { int count = 0 ; <START> while ( count ++ < VAR_2 ) { <END> int val = VAR_1 . read ( ) ; if ( val == 0 ) { return false ; } } } return true ; } 
public void METHOD_1 ( ) { assertEquals ( null , VAR_1 . METHOD_2 ( null , STRING_1 ) ) ; <START> } <END> 
public void METHOD_1 ( ) { <START> assertEquals ( null , VAR_1 . METHOD_2 ( null , null ) ) ; <END> } 
public TYPE_7 ( TYPE_1 VAR_2 ) { this . VAR_3 = TYPE_6 . this . VAR_5 ; this . VAR_6 = new TYPE_2 < Iterator < TYPE_3 < TYPE_1 > > > ( ) ; VAR_6 . add ( TYPE_4 . METHOD_1 ( TYPE_6 . VAR_7 . VAR_8 . get ( VAR_2 ) ) ) ; VAR_9 = new <START> TYPE_5 < TYPE_3 < TYPE_1 > > ( ) ; <END> } 
protected void METHOD_1 ( TYPE_1 parent ) { METHOD_2 ( parent , TYPE_3 . VAR_2 , TYPE_3 . VAR_3 , true ) ; <START> TYPE_2 VAR_4 = METHOD_2 ( parent , TYPE_3 . VAR_5 , TYPE_3 . VAR_6 , true ) ; <END> VAR_4 . METHOD_3 ( false ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_4 VAR_2 = TYPE_4 . METHOD_2 ( VAR_1 , 2 ) ; <START> VAR_3 . METHOD_3 ( VAR_2 . METHOD_4 ( 1 ) ) ; <END> Assert . VAR_4 ( VAR_3 . METHOD_5 ( ) , VAR_3 . toString ( ) ) ; return super . METHOD_1 ( VAR_2 . METHOD_4 ( 1 ) ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 [ ] VAR_2 ; int VAR_3 ; synchronized ( VAR_4 ) { VAR_2 = VAR_5 ; VAR_3 = VAR_6 ; VAR_6 = 0 ; } <START> VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) ; <END> } 
private String METHOD_1 ( Object element , int VAR_1 ) { TYPE_1 VAR_2 = ( TYPE_1 ) element ; switch ( VAR_1 ) { case 0 : return VAR_2 . METHOD_2 ( ) ; case 1 : <START> return VAR_2 . METHOD_3 ( ) ; <END> case 2 : return VAR_2 . METHOD_4 ( ) ; case 3 : return VAR_2 . METHOD_5 ( ) ; default : return "" ; } } 
public TYPE_1 ( String VAR_2 , String VAR_3 , String v , String VAR_4 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . v = v ; this . VAR_4 = VAR_4 ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) ; <START> VAR_2 . METHOD_3 ( VAR_3 ) ; <END> VAR_3 . METHOD_4 ( TYPE_3 . METHOD_5 ( ) ) ; METHOD_6 ( ) . METHOD_7 ( VAR_2 ) ; METHOD_8 ( VAR_1 , VAR_3 ) ; VAR_1 . METHOD_9 ( VAR_3 ) ; VAR_2 . METHOD_3 ( VAR_3 ) ; } 
private static void METHOD_1 ( String VAR_1 , TYPE_1 buffer ) { assertEquals ( VAR_1 , buffer . getString ( ) ) ; for ( TYPE_2 v : buffer . VAR_2 ( ) ) { <START> assertEquals ( true , v . VAR_3 ( ) ) ; <END> assertEquals ( true , v . VAR_4 ( ) ) ; } } 
protected String METHOD_1 ( ) { final String VAR_1 = METHOD_2 ( ) ; String [ ] VAR_2 = METHOD_3 ( ) ; for ( int i = 0 ; i < VAR_2 . length ; ++ i ) { String VAR_3 = VAR_2 [ i ] ; if ( VAR_3 . isEmpty ( ) || ( ! VAR_3 . isEmpty ( ) && VAR_1 . METHOD_4 ( STRING_1 + VAR_3 ) ) ) { return VAR_1 ; } } <START> return VAR_1 + STRING_1 + VAR_2 [ 0 ] ; <END> } 
public void METHOD_1 ( Map < String , String > VAR_1 ) { <START> TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> this . VAR_1 = VAR_1 ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> TYPE_2 VAR_2 = TYPE_1 . METHOD_2 ( STRING_1 ) ; assertEquals ( new TYPE_2 ( INT_1 , INT_1 , INT_1 ) , VAR_2 ) ; } 
int METHOD_1 ( int VAR_1 ) { if ( VAR_1 < 0 ) <START> throw new IllegalArgumentException ( ) ; <END> if ( VAR_1 <= VAR_2 ) return VAR_3 ; int next = Math . VAR_4 ( VAR_1 - VAR_2 , VAR_5 ) ; return Math . max ( next , VAR_3 ) ; } 
private int METHOD_1 ( String line ) { int VAR_1 = line . VAR_2 ( TYPE_1 ) ; int VAR_3 = line . VAR_2 ( VAR_4 ) ; if ( VAR_1 != - 1 && VAR_3 != - 1 ) { String VAR_5 = line . substring ( VAR_1 + TYPE_1 . length ( ) , VAR_3 ) ; <START> int VAR_6 = Integer . valueOf ( VAR_5 ) . METHOD_2 ( ) ; <END> if ( VAR_6 == - 1 ) { return TYPE_2 . VAR_8 ; } return VAR_6 ; } return VAR_9 ; } 
private void METHOD_1 ( String action , long start ) { Long VAR_1 = Long . valueOf ( System . currentTimeMillis ( ) - start ) ; <START> Long length = Long . valueOf ( METHOD_2 ( ) . length ( ) ) ; <END> String VAR_2 = STRING_1 ; String message = TYPE_1 . bind ( VAR_2 , new Object [ ] { action , length , VAR_1 } ) ; System . out . println ( message ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 parent ) { TYPE_1 VAR_1 = null ; if ( object instanceof TYPE_3 && METHOD_2 ( ) . METHOD_3 ( ( TYPE_3 ) object ) ) { VAR_1 = <START> super . METHOD_1 ( parent ) ; <END> } return VAR_1 ; } 
protected TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = new TYPE_2 ( METHOD_2 ( ) ) ; } return VAR_1 ; } 
public boolean METHOD_1 ( final TYPE_1 VAR_1 ) { boolean VAR_2 = false ; if ( VAR_1 instanceof TYPE_2 ) { final TYPE_3 VAR_3 = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; final View view = VAR_3 . METHOD_3 ( View . VAR_4 ) ; <START> if ( view != null && TYPE_7 . TYPE_8 . equals ( TYPE_5 . METHOD_4 ( view ) ) && view . VAR_5 ( ) instanceof TYPE_6 ) { <END> VAR_2 = true ; } else { VAR_2 = false ; } } return VAR_2 ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } 
private static void METHOD_1 ( TYPE_1 r , File VAR_1 ) throws TYPE_2 , IOException { <START> try { <END> if ( TYPE_6 . TYPE_7 . exists ( VAR_1 ) ) { TYPE_4 in = new TYPE_4 ( VAR_1 ) ; try { r . parse ( in ) ; } finally { in . close ( ) ; } } } catch ( TYPE_5 VAR_2 ) { } } 
public TYPE_1 METHOD_1 ( TYPE_2 parent , TYPE_3 VAR_1 ) { final File VAR_2 = VAR_1 . METHOD_2 ( ) ; File VAR_3 = new File ( VAR_2 , STRING_1 ) ; try { VAR_3 . METHOD_3 ( ) ; } catch ( TYPE_4 e ) { <START> return new TYPE_1 ( null , VAR_1 ) { <END> public void METHOD_4 ( ) { } public boolean METHOD_5 ( ) { return false ; } } ; } return new TYPE_1 ( parent , VAR_3 , VAR_1 ) ; } 
final public List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 , int VAR_2 , boolean VAR_3 ) { <START> VAR_4 = new TYPE_3 < TYPE_1 > ( ) ; <END> for ( TYPE_2 VAR_5 : VAR_1 ) { TYPE_4 VAR_6 = METHOD_2 ( VAR_5 , VAR_2 , VAR_3 ) ; if ( VAR_6 != null ) { VAR_2 += VAR_6 . METHOD_3 ( ) . VAR_7 ; } } return VAR_4 ; } 
public TYPE_1 ANNOTATION_1 [ ] METHOD_1 ( ANNOTATION_1 Object VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) { <START> List < ANNOTATION_2 ? extends TYPE_1 > VAR_2 = ( ( TYPE_2 ) VAR_1 ) . METHOD_1 ( ) ; <END> return VAR_2 . METHOD_2 ( new TYPE_3 [ VAR_2 . size ( ) ] ) ; } return null ; } 
<START> public TYPE_1 < ANNOTATION_1 TYPE_2 > METHOD_1 ( ) { <END> return METHOD_2 ( ImmutableList . VAR_1 ( VAR_2 . METHOD_3 ( ) . METHOD_1 ( ) ) ) ; } 
<START> public TYPE_1 < ANNOTATION_1 TYPE_2 > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public ANNOTATION_1 String getName ( ) { <END> return VAR_1 ; } 
<START> public static < ANNOTATION_1 T > TYPE_1 < ANNOTATION_1 T > METHOD_1 ( TYPE_2 trace , Class < T > VAR_1 ) { <END> TYPE_1 < ANNOTATION_1 TYPE_3 > VAR_2 = trace . VAR_3 ( ) ; Set < T > VAR_4 = new HashSet < > ( ) ; for ( TYPE_3 VAR_5 : VAR_2 ) { if ( VAR_1 . METHOD_2 ( VAR_5 . getClass ( ) ) ) { VAR_4 . add ( VAR_1 . METHOD_3 ( VAR_5 ) ) ; } } return VAR_4 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 trace ) { <START> TYPE_1 VAR_1 = TYPE_3 . getInstance ( ) ; <END> if ( trace instanceof TYPE_4 ) { VAR_1 = ( ( TYPE_4 ) trace ) . METHOD_2 ( ) ; } return VAR_1 ; } 
public <START> long <END> METHOD_1 ( ) { if ( VAR_1 instanceof TYPE_1 ) { TYPE_2 VAR_2 = ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( ) ; if ( VAR_2 instanceof TYPE_3 ) { return ( ( TYPE_3 ) VAR_2 ) . METHOD_3 ( ) ; } } return INT_1 ; } 
private boolean METHOD_1 ( TYPE_1 task ) { boolean VAR_1 = true ; boolean VAR_2 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( task ) ; boolean VAR_3 = false ; TYPE_3 VAR_4 = ( TYPE_3 ) task ; if ( VAR_4 != null ) { VAR_3 = VAR_4 . METHOD_4 ( ) != null ; } boolean VAR_5 = task . VAR_6 ( ) != null ; <START> return VAR_1 && ! ( VAR_1 || VAR_3 || VAR_5 ) ; <END> } 
public void METHOD_1 ( TYPE_1 target ) { String text = Messages . TYPE_2 + STRING_1 + VAR_2 . getStatus ( target ) . getMessage ( ) ; METHOD_1 ( text ) ; <START> System . out . println ( text ) ; <END> } 
public static boolean METHOD_1 ( final TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { boolean result = false ; String VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( TYPE_3 . isEmpty ( VAR_3 ) ) { <START> if ( ! ( VAR_2 instanceof TYPE_4 ) ) { result = true ; } <END> } else if ( TYPE_4 . METHOD_3 ( VAR_3 ) ) { if ( ! ( VAR_2 instanceof TYPE_5 ) ) { result = true ; } } else if ( ! ( VAR_2 instanceof TYPE_4 ) ) { result = true ; } return result ; } 
protected TYPE_1 run ( TYPE_2 monitor ) { <START> TYPE_3 VAR_1 = null ; <END> while ( ( VAR_1 = VAR_2 . METHOD_1 ( ) ) != null ) { if ( monitor . VAR_3 ( ) ) { return Status . VAR_4 ; } METHOD_2 ( VAR_1 , VAR_5 , state ) ; } return Status . VAR_6 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 , TYPE_4 . NONE ) ; return VAR_2 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 task = METHOD_2 ( TYPE_1 . class ) ; when ( task . VAR_1 ( STRING_1 ) ) . METHOD_3 ( STRING_2 ) ; TYPE_2 filter = new TYPE_2 ( ) ; boolean VAR_2 = ! filter . VAR_3 ( null , task ) ; <START> Assert . assertTrue ( VAR_2 ) ; <END> } 
public long METHOD_1 ( ) { <START> if ( METHOD_2 ( ) . METHOD_3 ( ) ) { <END> return super . METHOD_1 ( ) ; } return VAR_1 ; } 
public boolean METHOD_1 ( ) { <START> if ( METHOD_2 ( ) . METHOD_3 ( ) ) { <END> return super . METHOD_1 ( ) ; } return path . VAR_1 ( ) . METHOD_4 ( ) == VAR_2 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 buffer ) { TYPE_3 location = getPath ( buffer ) ; if ( location != null ) { return <START> org . VAR_1 . VAR_2 . VAR_3 . TYPE_4 . METHOD_2 ( ) <END> . METHOD_3 ( ) . METHOD_1 ( location ) ; } return null ; } 
public String METHOD_1 ( ) throws IOException { String name = METHOD_2 ( ) ; if ( name != null ) return METHOD_3 ( name ) ; <START> return name ; <END> } 
private void METHOD_1 ( boolean VAR_1 ) { if ( VAR_2 != null ) throw new IllegalStateException ( ) ; if ( VAR_3 != null ) VAR_3 . close ( ) ; if ( VAR_1 ) VAR_3 = new TYPE_1 ( METHOD_2 ( ) ) ; else VAR_3 = new TYPE_2 ( METHOD_2 ( ) ) ; VAR_4 = VAR_3 . METHOD_3 ( STRING_1 ) ; reader = VAR_3 . METHOD_4 ( ) ; <START> VAR_5 = new TYPE_3 ( METHOD_2 ( ) , reader ) ; <END> VAR_5 . METHOD_5 ( true ) ; } 
TYPE_4 ( final TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> VAR_3 = new TYPE_2 ( VAR_2 , reader ) ; <END> cache = TYPE_3 . METHOD_1 ( ) ; } 
public int METHOD_1 ( int key ) { METHOD_2 ( ) ; Integer action = <START> VAR_1 . get ( new Integer ( key ) ) ; <END> return action == null ? SWT . VAR_2 : action . VAR_3 ( ) ; } 
public static int METHOD_1 ( String text ) { <START> return 0 ; <END> } 
protected int METHOD_1 ( ) { int VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; int VAR_2 = VAR_3 + VAR_3 + VAR_3 * VAR_1 + VAR_4 * VAR_1 + VAR_4 * VAR_1 <START> + VAR_3 * VAR_1 <END> + VAR_3 * VAR_1 ; return VAR_2 ; } 
public int METHOD_1 ( int VAR_1 , long VAR_2 ) { int index = - 1 ; for ( int i = 0 ; i < VAR_3 ; i ++ ) { if ( VAR_1 == this . VAR_4 [ i ] ) { VAR_5 [ i ] = VAR_2 ; <START> index = i ; <END> } } return index ; } 
public List < Integer > METHOD_1 ( long time ) { List < Integer > <START> VAR_1 = <END> new TYPE_1 < > ( ) ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { if ( time >= VAR_3 [ i ] && time <= VAR_4 [ i ] ) { VAR_1 . add ( VAR_5 [ i ] ) ; } } return VAR_1 ; } 
public int METHOD_1 ( int VAR_1 , long VAR_2 ) { for ( int i = 0 ; i < VAR_3 ; i ++ ) { <START> if ( VAR_1 == this . VAR_4 [ i ] ) { <END> VAR_5 [ i ] = VAR_2 ; return i ; } } return - 1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_3 VAR_3 = METHOD_3 ( ) ; <START> assert VAR_3 != null ; <END> if ( VAR_2 != null ) { return new TYPE_4 ( VAR_4 , getName ( ) , VAR_3 , VAR_2 ) ; } else { return new TYPE_5 ( VAR_4 , getName ( ) , VAR_3 ) ; } } 
private static < T > T METHOD_1 ( Class < T > VAR_1 ) { final TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( TYPE_3 . class ) ; final TYPE_4 VAR_3 = VAR_2 . METHOD_3 ( ) ; final TYPE_5 < T > VAR_4 = VAR_3 . METHOD_4 ( VAR_1 ) ; if ( VAR_4 == null ) { return null ; } <START> final Object VAR_5 = VAR_3 . METHOD_1 ( VAR_4 ) ; <END> VAR_3 . METHOD_5 ( VAR_4 ) ; return VAR_1 . METHOD_6 ( VAR_5 ) ; } 
<START> private void METHOD_1 ( List < TYPE_1 > VAR_1 ) throws TYPE_2 { <END> for ( TYPE_3 VAR_2 : VAR_3 ) { VAR_1 . add ( new TYPE_1 ( VAR_2 ) ) ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 [ ] VAR_1 = null ; Map < String , String > VAR_2 = null ; if ( VAR_3 != null ) { VAR_1 = VAR_3 . METHOD_2 ( ) ; TYPE_3 VAR_4 = VAR_3 . METHOD_3 ( ) ; if ( VAR_4 instanceof TYPE_4 ) { TYPE_4 VAR_5 = ( TYPE_4 ) VAR_4 ; <START> VAR_2 = VAR_5 . METHOD_4 ( ) ; <END> } } return new TYPE_1 ( VAR_6 . METHOD_5 ( ) , VAR_7 . METHOD_6 ( ) , VAR_1 , VAR_2 ) ; } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) { final TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; if ( VAR_2 . METHOD_2 ( ) != null ) { return METHOD_1 ( VAR_2 . METHOD_2 ( ) ) ; } } final TYPE_3 VAR_3 = METHOD_3 ( ) ; final String VAR_4 = METHOD_4 ( VAR_3 , VAR_1 ) ; <START> VAR_3 . METHOD_5 ( ) ; <END> return VAR_4 ; } 
private void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( VAR_3 , null , TYPE_1 . class , null ) ; for ( TYPE_1 VAR_4 : VAR_1 ) { Object VAR_5 = VAR_4 . METHOD_3 ( ) ; if ( VAR_5 instanceof TYPE_2 ) { <START> METHOD_4 ( ( TYPE_2 ) VAR_5 ) ; <END> } } } 
<START> private static <END> TYPE_1 METHOD_1 ( Map < TYPE_1 , TYPE_2 > VAR_1 , TYPE_2 command ) { for ( Map . Entry < TYPE_1 , TYPE_2 > entry : VAR_1 . entrySet ( ) ) { if ( entry . getValue ( ) == command ) { return entry . getKey ( ) ; } } return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { List <START> VAR_3 ; <END> if ( VAR_4 == null ) { VAR_3 = Collections . VAR_5 ( ) ; } else { VAR_3 = METHOD_2 ( ) ; for ( Object object : VAR_3 ) { METHOD_3 ( object , false ) ; } } VAR_6 . METHOD_4 ( VAR_1 ) ; VAR_6 . METHOD_5 ( VAR_2 ) ; VAR_7 = VAR_1 ; VAR_8 = VAR_2 ; for ( Object object : VAR_3 ) { METHOD_3 ( object , true ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> try { return new TYPE_1 ( url . toString ( ) ) ; } catch ( TYPE_2 e ) { return null ; } <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( ) ) { <END> return ; } TYPE_2 VAR_3 = METHOD_3 ( ) ; if ( VAR_3 == null ) return ; VAR_4 = METHOD_4 ( ) ; VAR_5 = VAR_6 . METHOD_5 ( ) ; VAR_7 . METHOD_6 ( VAR_1 , VAR_3 ) ; if ( ! VAR_7 . METHOD_7 ( ) ) VAR_8 . METHOD_6 ( VAR_1 , VAR_3 ) ; } 
public TYPE_5 ( TYPE_1 connection ) { if ( connection instanceof TYPE_2 ) try { ( ( TYPE_2 ) connection ) . METHOD_1 ( ) ; } catch ( TYPE_3 e ) { throw new TYPE_4 ( Messages . TYPE_6 ) ; <START> } <END> VAR_3 = connection ; } 
protected Object METHOD_1 ( ) { TYPE_1 VAR_1 = null ; METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( ) == VAR_2 . METHOD_4 ( ) ) { VAR_1 = TYPE_1 . VAR_3 ; <START> } else if ( VAR_2 . METHOD_3 ( ) == 0 ) { <END> if ( TYPE_4 . TYPE_5 . equals ( VAR_4 ) ) { VAR_1 = TYPE_1 . VAR_5 ; } else if ( TYPE_4 . TYPE_6 . equals ( VAR_4 ) ) { VAR_1 = TYPE_1 . VAR_6 ; } } return VAR_1 ; } 
<START> protected static <END> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { return TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) ; } 
<START> public void <END> METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 ; } 
public static String getPath ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_1 ( ) ; if ( VAR_1 == null ) { return null ; } Path VAR_2 = TYPE_2 . get ( STRING_1 , STRING_1 , STRING_2 , STRING_3 , VAR_3 , VAR_4 ) ; VAR_2 = VAR_2 . METHOD_2 ( ) ; File file = VAR_2 . METHOD_3 ( ) ; <START> if ( file . exists ( ) ) { <END> METHOD_4 ( VAR_2 ) ; } METHOD_5 ( file ) ; return file . VAR_5 ( ) ; } 
private void METHOD_1 ( TYPE_1 task , boolean VAR_1 ) { <START> task . VAR_2 ( TYPE_2 . VAR_4 , VAR_1 ? STRING_1 : STRING_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 , TYPE_2 element ) { super . METHOD_1 ( VAR_1 , element ) ; METHOD_2 ( VAR_1 ) ; TYPE_3 VAR_2 = ( TYPE_3 ) METHOD_3 ( element ) ; if ( VAR_2 != null && ! VAR_2 . METHOD_4 ( ) ) { <START> VAR_2 . METHOD_5 ( true ) ; <END> VAR_2 . METHOD_6 ( ) ; } } 
public Set < TYPE_1 > <START> METHOD_1 ( ) <END> { return Collections . VAR_1 ( new TYPE_2 < > ( VAR_2 ) ) ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = TYPE_1 . VAR_2 ; TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( new File ( VAR_3 , STRING_1 ) , STRING_2 ) ; <START> assertTrue ( VAR_1 . METHOD_3 ( ) ) ; <END> String target = VAR_1 . METHOD_5 ( new File ( VAR_3 , STRING_1 ) ) ; assertEquals ( STRING_2 , target ) ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = TYPE_1 . VAR_2 ; TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; File file = new File ( VAR_3 , STRING_1 ) ; VAR_1 . METHOD_4 ( file , STRING_2 ) ; <START> assertTrue ( VAR_1 . METHOD_3 ( ) ) ; <END> String target = VAR_1 . METHOD_5 ( file ) ; assertEquals ( STRING_2 , target ) ; VAR_1 . METHOD_4 ( file , STRING_3 ) ; target = VAR_1 . METHOD_5 ( file ) ; assertEquals ( STRING_3 , target ) ; } 
public TYPE_1 getValue ( TYPE_2 event ) { if ( VAR_1 != null ) { return VAR_1 ; } if ( VAR_2 . equals ( TYPE_6 . VAR_4 ) ) { <START> return TYPE_3 . METHOD_1 ( ) ; <END> } try { return METHOD_2 ( VAR_5 ) . getValue ( event ) ; } catch ( TYPE_4 e ) { TYPE_5 . METHOD_3 ( STRING_1 , e ) ; } throw new IllegalStateException ( STRING_2 + VAR_6 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_1 VAR_3 ) { if ( VAR_2 == TYPE_2 . VAR_4 ) { VAR_1 . METHOD_2 ( ) . addAll ( TYPE_3 . filter ( METHOD_3 ( VAR_3 ) , <START> TYPE_4 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ) ) ; <END> } } 
<START> void execute ( TYPE_1 VAR_1 , List < TYPE_2 > VAR_2 ) throws IOException { <END> if ( apply ( VAR_2 ) && VAR_3 != null ) { commit ( VAR_1 ) ; } } 
void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { List < TYPE_2 > VAR_3 = <START> new ArrayList < TYPE_2 > ( ) ; <END> VAR_3 . addAll ( VAR_1 . METHOD_2 ( ) ) ; VAR_1 . METHOD_3 ( ) ; Iterator < TYPE_2 > VAR_4 = VAR_3 . iterator ( ) ; while ( VAR_4 . hasNext ( ) ) { if ( METHOD_4 ( VAR_4 . next ( ) ) ) VAR_4 . remove ( ) ; } VAR_1 . METHOD_5 ( VAR_3 ) ; } } 
public void METHOD_1 ( TYPE_1 listener ) { if ( this . text != null && ! this . text . VAR_1 ( ) ) this . text . VAR_2 ( listener ) ; if <START> ( this . VAR_3 != <END> null && ! this . VAR_4 . METHOD_2 ( ) ) this . VAR_4 . METHOD_1 ( listener ) ; } 
public void METHOD_1 ( TYPE_1 listener ) { if <START> ( this . VAR_1 != <END> null && ! this . VAR_2 . METHOD_2 ( ) ) this . VAR_2 . METHOD_1 ( listener ) ; } 
protected String [ ] METHOD_1 ( ) { <START> System . out . println ( this . VAR_1 ) ; <END> List < String > VAR_2 = new ArrayList < String > ( ) ; for ( String item : this . VAR_1 . keySet ( ) ) { Boolean VAR_3 = this . VAR_1 . get ( item ) ; if ( VAR_3 != null && VAR_3 ) { VAR_2 . add ( item ) ; } } return VAR_2 . METHOD_2 ( new String [ VAR_2 . size ( ) ] ) ; } 
<START> public void METHOD_1 ( String VAR_1 ) throws Exception { <END> METHOD_2 ( TYPE_1 . VAR_3 , VAR_1 ) ; super . METHOD_1 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) ; <START> if ( VAR_1 != null && VAR_1 . METHOD_3 ( ) ) error ( SWT . VAR_2 ) ; <END> VAR_3 = VAR_1 ; if ( METHOD_4 ( ) ) { METHOD_5 ( ) ; METHOD_6 ( ) ; } } 
public static boolean METHOD_1 ( TYPE_1 request ) { Object value = request . VAR_1 ( TYPE_2 . VAR_3 ) ; if ( value instanceof Boolean ) { return ( Boolean ) value ; } else if ( value instanceof String ) { Boolean VAR_4 = Boolean . valueOf ( ( String ) value ) ; return VAR_4 . METHOD_2 ( ) ; } <START> return true ; <END> } 
public TYPE_1 METHOD_1 ( int offset ) { for ( TYPE_2 VAR_1 : TYPE_3 . filter ( VAR_2 , TYPE_2 . class ) ) { <START> if ( VAR_1 instanceof TYPE_2 ) { <END> if ( VAR_1 . METHOD_2 ( ) . offset <= offset && ( VAR_1 . METHOD_2 ( ) . length + VAR_1 . METHOD_2 ( ) . offset ) >= offset ) { return VAR_1 ; } } } return null ; } 
<START> protected TYPE_2 ( ) <END> { super ( TYPE_3 . VAR_3 , new TYPE_1 ( ) ) ; } 
private boolean METHOD_1 ( ) { <START> boolean VAR_1 ; <END> try { if ( TYPE_6 . TYPE_7 . METHOD_2 ( ) ) { VAR_1 = true ; } else if ( VAR_2 . METHOD_3 ( ) . size ( ) > 0 ) { VAR_1 = TYPE_2 . METHOD_4 ( VAR_3 , TYPE_8 . VAR_5 ) ; } else { VAR_1 = true ; } } catch ( TYPE_3 ex ) { TYPE_4 . log ( TYPE_5 . class , Level . VAR_6 , ex ) ; VAR_1 = false ; } return VAR_1 ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) . getPath ( ) + STRING_1 + File . VAR_2 + STRING_1 + File . VAR_2 + STRING_2 + File . VAR_2 + STRING_3 ; } 
private static Map < String , TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { Map < String , TYPE_1 > m = new TYPE_3 < > ( ) ; for ( TYPE_2 <START> c : <END> VAR_1 ) { m . put ( c . VAR_2 ( ) , c ) ; } return m ; } 
public Collection < TYPE_1 > METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> return VAR_2 ; } } 
public List < TYPE_1 > METHOD_1 ( ) { final TYPE_1 [ ] VAR_1 = new TYPE_1 [ this . VAR_2 . size ( ) ] ; <START> for ( int i = 0 ; i < VAR_2 . METHOD_2 ( ) . length ; i ++ ) { <END> VAR_1 [ i ] = ( TYPE_1 ) VAR_2 . METHOD_2 ( ) [ i ] ; } return Arrays . asList ( VAR_1 ) ; } 
private static synchronized TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { List < TYPE_2 > VAR_2 = new ArrayList < > ( ) ; for ( Object listener : VAR_1 . METHOD_1 ( ) ) { <START> if ( listener != null ) { <END> VAR_2 . add ( ( TYPE_2 ) listener ) ; } } return VAR_2 ; } 
<START> public TYPE_1 ( ) { <END> METHOD_1 ( ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) instanceof TYPE_2 ) { <START> TYPE_2 element = ( TYPE_2 ) VAR_1 . METHOD_2 ( ) ; if ( TYPE_3 . METHOD_3 ( element ) ) { return true ; } <END> } return false ; } 
public TYPE_1 ( Boolean VAR_2 ) { <START> super ( VAR_2 ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! VAR_2 ) { return VAR_1 ; } VAR_1 . METHOD_2 ( ) ; try { <START> return new TYPE_2 ( VAR_3 , METHOD_3 ( VAR_4 ) , VAR_5 ) ; <END> } catch ( IOException e ) { METHOD_4 ( e . getMessage ( ) ) ; return null ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ; VAR_1 . METHOD_4 ( STRING_2 ) ; VAR_1 . METHOD_5 ( ) . METHOD_6 ( TYPE_1 . VAR_3 ) ; TYPE_2 VAR_4 = VAR_5 . METHOD_7 ( VAR_2 , VAR_6 , new TYPE_3 ( ) ) ; <START> assertEquals ( VAR_4 . METHOD_8 ( ) , Collections . VAR_7 ( VAR_1 ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , new TYPE_3 < TYPE_4 > ( ) { ANNOTATION_1 ( STRING_1 ) public boolean apply ( TYPE_4 input ) { return TYPE_5 . size ( TYPE_5 . filter ( input . VAR_2 ( ) . iterator ( ) , <START> METHOD_5 ( METHOD_6 ( TYPE_6 . class ) ) ) ) <END> > 1 ; } } ) ) ; } 
public < T > Set < T > METHOD_1 ( Set < T > set , T object ) { if ( set . contains ( object ) ) { return TYPE_1 . METHOD_2 ( set ) ; <START> } else { <END> Set < T > result = TYPE_1 . METHOD_2 ( set ) ; result . add ( object ) ; return result ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { final TYPE_3 VAR_3 = VAR_2 . METHOD_2 ( TYPE_3 . class ) ; <START> METHOD_3 ( METHOD_4 ( VAR_3 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { <START> if ( VAR_1 instanceof TYPE_2 ) { <END> Object element = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; if ( element != null && element instanceof TYPE_3 ) { TYPE_3 VAR_3 = ( TYPE_3 ) element ; METHOD_1 ( VAR_3 , VAR_2 ) ; } } } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> return ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; } 
public void METHOD_1 ( TYPE_1 context ) throws Exception { TYPE_2 . METHOD_2 ( ) ; VAR_1 . METHOD_2 ( ) ; VAR_1 = null ; VAR_2 . METHOD_2 ( ) ; VAR_2 = null ; VAR_3 . METHOD_2 ( ) ; VAR_3 = null ; TYPE_3 . getInstance ( ) . METHOD_2 ( ) ; TYPE_4 . getInstance ( ) . METHOD_2 ( ) ; <START> TYPE_5 . getInstance ( ) . METHOD_3 ( ) ; <END> super . METHOD_1 ( context ) ; } 
public ANNOTATION_1 Map < ANNOTATION_1 String , ANNOTATION_1 String > METHOD_1 ( ) { Map < ANNOTATION_1 String , ANNOTATION_1 String > properties = new HashMap < > ( ) ; properties . put ( TYPE_1 . METHOD_2 ( Messages . TYPE_3 ) , TYPE_1 . METHOD_2 ( VAR_2 . getName ( ) ) ) ; properties . put ( TYPE_1 . METHOD_2 ( Messages . TYPE_2 ) , <START> TYPE_1 . METHOD_2 ( VAR_4 . name ( ) ) ) ; <END> return properties ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 , SWT . NONE ) ; TYPE_2 . METHOD_2 ( ) . METHOD_3 ( true , true ) . METHOD_4 ( SWT . VAR_3 , SWT . VAR_3 ) . METHOD_5 ( 1 , METHOD_6 ( ) ) <START> . METHOD_7 ( VAR_2 ) ; <END> TYPE_3 . METHOD_2 ( ) . METHOD_8 ( 1 ) . METHOD_7 ( VAR_2 ) ; return VAR_2 ; } 
private void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( new TYPE_2 ( ) { @Override public void run ( ) { <START> METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ; <END> } } ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 file ) throws TYPE_3 { <START> try { return METHOD_1 ( file , true , false ) ; } catch ( TYPE_4 ex ) { throw new TYPE_3 ( ex . getMessage ( ) , ex ) ; } <END> } 
public boolean METHOD_1 ( final String VAR_1 ) { <START> if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) <END> return false ; return METHOD_2 ( VAR_1 ) != null ; } 
public static TYPE_1 METHOD_1 ( final TYPE_1 [ ] VAR_1 , final String name ) { TYPE_1 VAR_2 = null ; if ( VAR_1 != null && VAR_1 . length > 0 ) { <START> for ( TYPE_1 VAR_3 : VAR_1 ) { <END> if ( VAR_3 . METHOD_2 ( ) . equals ( name ) ) { VAR_2 = VAR_3 ; break ; } VAR_2 = METHOD_1 ( VAR_3 . METHOD_3 ( ) , name ) ; if ( VAR_2 != null ) { break ; } } } return VAR_2 ; } 
public Map < String , String > METHOD_1 ( ) { Map < String , String > properties = new HashMap < > ( ) ; properties . VAR_1 ( VAR_2 . METHOD_2 ( ) ) ; properties . put ( VAR_3 , <START> Long . VAR_4 ( VAR_2 . METHOD_3 ( ) ) ) ; <END> properties . put ( Messages . TYPE_1 , METHOD_4 ( ) ) ; return properties ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) <END> { VAR_1 . close ( false ) ; VAR_1 = null ; } } 
public Long METHOD_1 ( ) { <START> return new Long ( METHOD_2 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( this . METHOD_2 ( ) , this . VAR_1 ) ; <END> } 
<START> public ANNOTATION_1 String METHOD_1 ( ) { <END> return STRING_1 ; } 
public int METHOD_1 ( ) { int VAR_1 = 0 ; for ( TYPE_1 field : VAR_2 ) { VAR_1 += field . VAR_3 ( ) ; } <START> return Math . VAR_4 ( VAR_1 , Integer . VAR_5 ) ; <END> } 
public final void run ( ) { METHOD_1 ( ) ; <START> VAR_1 = true ; <END> VAR_2 . METHOD_2 ( ) ; } 
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( STRING_1 ) . append ( METHOD_1 ( ) ) . append ( STRING_2 ) . append ( METHOD_2 ( ) ) . append ( STRING_3 ) . append ( METHOD_3 ( ) ) <START> . append ( STRING_4 ) . append ( METHOD_4 ( ) ) <END> . append ( CHAR_1 ) ; return builder . toString ( ) ; } 
public String METHOD_1 ( ) { String VAR_1 = VAR_2 ; if ( VAR_1 == null ) { TYPE_1 VAR_3 = new TYPE_1 ( STRING_1 ) ; METHOD_2 ( ) . forEach ( ( Long value ) - > VAR_3 . add ( TYPE_2 . METHOD_3 ( TYPE_3 . METHOD_4 ( ) ) . format ( value ) ) ) ; VAR_1 = VAR_3 . toString ( ) ; <START> VAR_2 = VAR_1 ; <END> } return VAR_1 ; } 
public String METHOD_1 ( int column ) { String value = METHOD_2 ( ) . get ( column ) ; if <START> ( value . equals ( TYPE_2 . TYPE_3 ) ) { <END> return null ; } return value ; } 
void METHOD_1 ( List < String > VAR_1 ) { <START> for ( TYPE_1 < String > iterator = VAR_1 . METHOD_2 ( ) ; iterator . hasNext ( ) ; ) { String string = iterator . next ( ) ; iterator . set ( StringUtils . VAR_2 ( string , TYPE_2 . VAR_4 ) ) ; } <END> VAR_5 = VAR_1 ; } 
public Map < TYPE_1 , TYPE_2 > METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = null ; if ( VAR_1 != null ) { VAR_2 = new TYPE_2 ( ) ; <START> VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <END> } String VAR_4 = STRING_1 ; if ( VAR_2 != null ) { String VAR_5 = METHOD_3 ( VAR_2 ) ; VAR_4 += STRING_2 + VAR_5 + STRING_3 ; } VAR_4 += STRING_4 ; long context = OS . VAR_6 ( VAR_7 ) ; METHOD_4 ( context , VAR_4 ) ; } 
TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = null ; if ( VAR_1 != null ) { <START> VAR_2 = new TYPE_1 ( ) ; <END> VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; } return VAR_2 ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 trace ) { TYPE_1 VAR_1 = new TYPE_1 ( trace . getName ( ) ) ; TYPE_3 < TYPE_4 > VAR_2 = TYPE_5 . METHOD_2 ( trace , TYPE_4 . class ) ; for ( TYPE_4 VAR_3 : VAR_2 ) { VAR_3 . METHOD_3 ( ) ; if ( ! VAR_3 . METHOD_4 ( ) ) { <START> return VAR_1 ; <END> } for ( TYPE_6 VAR_4 : VAR_3 . METHOD_5 ( ) ) { VAR_1 . METHOD_6 ( new TYPE_7 ( VAR_4 ) ) ; } } return VAR_1 ; } 
public boolean METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) ; <START> } catch ( InterruptedException e ) { } <END> return VAR_2 ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( ) ; <START> assertEquals ( STRING_1 , true , VAR_1 . METHOD_5 ( ) ) ; <END> assertNotNull ( VAR_1 . METHOD_3 ( ) ) ; } 
public boolean METHOD_1 ( TYPE_1 node ) { VAR_1 . METHOD_2 ( node ) ; <START> return METHOD_1 ( ( TYPE_2 ) node ) ; <END> } 
<START> public ANNOTATION_1 String METHOD_1 ( long VAR_1 ) { <END> if ( ( VAR_1 & ( INT_1 < < INT_2 ) ) != 0 ) { return String . format ( STRING_1 , VAR_1 ) ; } return String . format ( STRING_2 , VAR_1 ) ; } 
protected void METHOD_1 ( String output ) { <START> if ( output . toString ( ) . contains ( STRING_1 ) ) { <END> VAR_1 = TYPE_1 . VAR_3 ; } else if ( output . toString ( ) . contains ( STRING_2 ) ) { VAR_1 = TYPE_1 . VAR_4 ; } else if ( output . toString ( ) . contains ( STRING_3 ) ) { VAR_1 = TYPE_1 . VAR_5 ; } else { VAR_1 = TYPE_1 . VAR_6 ; } } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_3 . Builder < TYPE_2 > builder = TYPE_3 . builder ( ) ; builder . addAll ( super . METHOD_1 ( ) ) ; builder . add ( TYPE_5 . VAR_2 ) ; builder . add ( TYPE_6 . VAR_2 ) ; return <START> TYPE_4 . METHOD_2 ( builder . build ( ) ) ; <END> } 
public Object execute ( final TYPE_1 event ) throws TYPE_2 { final TYPE_3 VAR_1 = TYPE_4 . METHOD_1 ( event ) ; final TYPE_5 VAR_2 = METHOD_2 ( VAR_1 ) ; final TYPE_6 configuration = METHOD_3 ( VAR_2 ) ; <START> TYPE_7 VAR_3 = new TYPE_7 ( configuration , VAR_2 ) ; <END> TYPE_8 VAR_4 = new TYPE_8 ( TYPE_9 . METHOD_4 ( ) . METHOD_5 ( ) , VAR_3 ) ; VAR_4 . METHOD_6 ( ) ; return null ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 configuration ) { TYPE_1 VAR_1 = null ; if ( 0 < configuration . VAR_2 ( ) . size ( ) ) { final Iterator < TYPE_3 > VAR_3 = configuration . VAR_2 ( ) . iterator ( ) ; while ( VAR_3 . hasNext ( ) && null == VAR_1 ) { <START> TYPE_3 VAR_4 = VAR_3 . next ( ) ; <END> if ( VAR_4 instanceof TYPE_1 ) { VAR_1 = ( TYPE_1 ) VAR_4 ; } } } return VAR_1 ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 configuration ) { TYPE_1 VAR_1 = null ; if ( 0 < configuration . VAR_2 ( ) . size ( ) ) { final Iterator < TYPE_3 > VAR_3 = configuration . VAR_4 ( ) . iterator ( ) ; while ( VAR_3 . hasNext ( ) && null == VAR_1 ) { <START> TYPE_3 VAR_5 = VAR_3 . next ( ) ; <END> if ( VAR_5 instanceof TYPE_1 ) { VAR_1 = ( TYPE_1 ) VAR_5 ; } } } return VAR_1 ; } 
public static final boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 . METHOD_2 ( TYPE_6 . VAR_4 . METHOD_3 ( ) ) ; <END> Assert . VAR_5 ( VAR_2 ) ; final TYPE_3 VAR_6 = VAR_2 . METHOD_4 ( ) ; return TYPE_3 . TYPE_5 . equals ( VAR_6 ) ; } 
private boolean METHOD_1 ( String type ) { <START> return Arrays . asList ( TYPE_1 ) . contains ( type ) ; <END> } 
public <START> ANNOTATION_1 TYPE_1 <END> METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null ) { TYPE_2 VAR_2 = METHOD_3 ( ) ; if ( VAR_2 != null ) { TYPE_1 VAR_3 = TYPE_3 . METHOD_4 ( VAR_2 , VAR_1 ) ; if ( VAR_3 != null ) { return VAR_3 ; } } } return TYPE_3 . VAR_4 ; } 
<START> public <END> TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { writer = new TYPE_1 ( ) ; VAR_1 = new TYPE_2 ( writer ) ; VAR_1 . METHOD_2 ( false ) ; builder = new TYPE_3 ( VAR_1 ) ; builder . VAR_2 ( TYPE_4 . METHOD_3 ( TYPE_8 . VAR_4 ) ) ; builder . VAR_5 ( TYPE_4 . METHOD_3 ( TYPE_5 . VAR_6 ) , TYPE_9 < TYPE_6 > METHOD_4 ( ) , <START> TYPE_7 < TYPE_5 , String > of ( ) ) ; <END> builder . VAR_9 ( 3 ) ; builder . VAR_10 ( ) ; } 
private Set < String > METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 == null || VAR_1 . length ( ) == 0 ) <END> return Collections . VAR_2 ( ) ; Set < String > VAR_3 = new HashSet < String > ( ) ; TYPE_1 VAR_4 = new TYPE_1 ( VAR_1 , File . VAR_5 ) ; while ( VAR_4 . METHOD_2 ( ) ) { VAR_3 . add ( VAR_6 . METHOD_3 ( VAR_4 . METHOD_4 ( ) ) . toString ( ) ) ; } return VAR_3 ; } 
protected void METHOD_1 ( ) throws IOException { if ( METHOD_2 ( ) == null ) { <START> if ( METHOD_3 ( ) != null ) <END> METHOD_4 ( METHOD_5 ( ) . METHOD_6 ( METHOD_3 ( ) , VAR_1 ) ) ; else if ( METHOD_7 ( ) != null ) METHOD_4 ( METHOD_5 ( ) . METHOD_6 ( METHOD_7 ( ) , VAR_1 ) ) ; } } 
public static TYPE_1 < String , String > METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 ) { <START> TYPE_1 < String , String > VAR_2 = TYPE_4 . METHOD_2 ( TYPE_5 . create ( ) ) ; <END> for ( TYPE_3 VAR_3 : VAR_1 ) { for ( TYPE_6 VAR_4 : VAR_3 . METHOD_3 ( ) ) { VAR_2 . METHOD_4 ( VAR_4 . getType ( ) , VAR_4 . METHOD_5 ( ) ) ; } } return VAR_2 ; } 
public void METHOD_1 ( ) { File VAR_1 = VAR_2 ; if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } } 
<START> public ANNOTATION_1 String METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; } 
public Object METHOD_1 ( String name ) { if ( name . equals ( TYPE_1 . VAR_1 ) ) { final TYPE_2 VAR_2 = VAR_3 ; if ( VAR_2 == null ) { return null ; } TYPE_3 VAR_4 = METHOD_2 ( ) ; if ( ( VAR_4 != null ) && ( VAR_4 instanceof TYPE_1 ) ) { TYPE_4 VAR_5 = new TYPE_4 ( VAR_2 , "" , 0 ) ; return VAR_5 ; } <START> return VAR_2 ; <END> } return null ; } 
private <START> ArrayList < TYPE_1 > <END> METHOD_1 ( Set < TYPE_2 > VAR_1 ) { ArrayList < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { VAR_2 . add ( new TYPE_1 ( VAR_3 , TYPE_3 . TYPE_4 , TYPE_5 . VAR_7 ) ) ; } return VAR_2 ; } 
private <START> ArrayList < TYPE_1 > <END> METHOD_1 ( Set < TYPE_2 > VAR_1 ) { ArrayList < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { VAR_2 . add ( new TYPE_1 ( VAR_3 , TYPE_4 . TYPE_3 , TYPE_5 . VAR_7 ) ) ; } return VAR_2 ; } 
public String METHOD_1 ( int row , int VAR_1 ) { METHOD_2 ( row , VAR_1 ) ; Object obj = VAR_2 . METHOD_3 ( VAR_1 , row ) ; if ( obj != null ) { return obj . toString ( ) ; } <START> else <END> return "" ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) throws TYPE_3 { METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> TYPE_4 location = METHOD_4 ( ) ; return TYPE_5 . METHOD_1 ( VAR_2 , location . x + ( location . VAR_3 / 2 ) , location . y + ( location . VAR_4 / 2 ) ) ; } 
public TYPE_1 METHOD_1 ( int row , int VAR_1 , String text ) throws TYPE_2 { METHOD_2 ( row , VAR_1 ) ; Assert . VAR_2 ( text ) ; METHOD_3 ( ) ; METHOD_4 ( row , VAR_1 ) ; TYPE_3 location = VAR_3 . METHOD_5 ( VAR_1 , row ) ; <START> return TYPE_4 . METHOD_1 ( VAR_3 , location . x + ( location . VAR_4 / 2 ) , location . y + ( location . VAR_5 / 2 ) , text ) ; <END> } 
<START> public TYPE_1 <END> METHOD_1 ( final TYPE_2 VAR_1 ) throws TYPE_3 { METHOD_2 ( ) ; TYPE_4 location = METHOD_3 ( ) ; return TYPE_5 . METHOD_1 ( VAR_2 , location . VAR_3 / 2 , location . VAR_4 / 2 ) ; } 
public ANNOTATION_1 TYPE_1 < ANNOTATION_1 TYPE_2 > METHOD_1 ( ) { Set < ANNOTATION_1 TYPE_2 > VAR_1 = VAR_2 ; if ( VAR_1 == null ) { TYPE_3 trace = METHOD_2 ( ) ; <START> TYPE_4 VAR_3 = TYPE_4 . VAR_4 ; <END> if ( trace != null ) { VAR_3 = trace . VAR_5 ( ) ; } VAR_1 = TYPE_5 . of ( new TYPE_6 ( VAR_3 ) ) ; VAR_2 = VAR_1 ; } return VAR_1 ; } 
<START> static TYPE_1 METHOD_1 ( ) { <END> TYPE_2 TYPE_3 = TYPE_2 . create ( ) ; return new TYPE_4 ( TYPE_3 : : add ) ; } 
public boolean METHOD_1 ( long VAR_1 ) { <START> return ( start <= VAR_1 && VAR_2 >= VAR_1 ) ; <END> } 
private String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 = METHOD_2 ( VAR_1 ) ; String VAR_4 = METHOD_3 ( VAR_3 ) ; if ( VAR_2 != null ) { <START> int VAR_5 ; <END> try { VAR_5 = Integer . parseInt ( VAR_2 . METHOD_4 ( ) ) ; VAR_4 += ! VAR_4 . isEmpty ( ) ? STRING_1 : "" ; VAR_4 += STRING_2 + Integer . toString ( VAR_5 ) + STRING_3 ; } catch ( TYPE_4 e ) { } } return VAR_4 ; } 
<START> public synchronized static void METHOD_1 ( String key , TYPE_1 VAR_1 ) { <END> METHOD_2 ( ) . put ( key , VAR_1 ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 VAR_1 = VAR_2 . get ( TYPE_1 . class ) ; VAR_1 . METHOD_2 ( listener ) ; if ( VAR_3 != null ) { VAR_3 . close ( ) ; } VAR_2 . METHOD_3 ( ) ; } 
public boolean isEmpty ( ) { <START> return this . VAR_1 . isEmpty ( ) ; <END> } 
private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { TYPE_1 session = TYPE_7 . TYPE_8 . METHOD_2 ( VAR_1 ) ; if ( session == null ) { TYPE_9 . TYPE_8 . METHOD_3 ( VAR_1 , true ) ; try { TYPE_5 . METHOD_4 ( ) . METHOD_5 ( TYPE_10 . VAR_3 , new TYPE_6 ( ) ) ; } catch ( InterruptedException e ) { <START> throw new RuntimeException ( e ) ; <END> } session = TYPE_7 . TYPE_8 . METHOD_2 ( VAR_1 ) ; } return session ; } 
public TYPE_8 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 , TYPE_6 VAR_7 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) ; <START> VAR_8 = new TYPE_7 ( ) ; <END> } 
TYPE_6 ( Map < TYPE_1 , TYPE_2 > VAR_2 ) { this . VAR_2 = new TYPE_3 < TYPE_1 , TYPE_5 . TYPE_2 > ( ) ; <START> this . VAR_2 . METHOD_1 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 config , String VAR_1 , Object data ) throws TYPE_2 { VAR_2 = new String [ 0 ] ; if ( data != null ) { <START> if ( data instanceof String && data . toString ( ) . length ( ) > 0 ) { <END> VAR_2 = StringUtils . VAR_3 ( data . toString ( ) ) ; } } } 
<START> private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 , TYPE_2 record , TYPE_3 context ) { <END> TYPE_1 VAR_3 = new TYPE_4 ( TYPE_6 . VAR_5 , VAR_1 , null , context . VAR_6 ( ) ) . METHOD_2 ( record , context ) ; if ( VAR_2 ) { return VAR_3 ; } else { return new TYPE_5 ( VAR_3 . getType ( null ) , VAR_3 . METHOD_3 ( null ) , VAR_3 . getValue ( null ) ) ; } } 
public TYPE_1 [ ] METHOD_1 ( ) { <START> return new TYPE_1 [ ] { this . METHOD_2 ( ) } ; <END> } 
public static TYPE_1 getType ( int VAR_1 ) { <START> if ( VAR_1 % 2 == 0 ) { <END> return VAR_2 ; } return VAR_3 ; } 
public boolean METHOD_1 ( ) { <START> if ( resource . VAR_1 ( ) != null ) { <END> return new TYPE_1 ( resource . VAR_1 ( ) . METHOD_2 ( ) ) . METHOD_3 ( ) ; } return false ; } 
protected final void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 = VAR_1 . METHOD_2 ( TYPE_2 . class ) ; <END> if ( VAR_2 == null ) { throw new IllegalStateException ( STRING_1 ) ; } METHOD_3 ( VAR_1 . METHOD_4 ( VAR_2 ) ) ; } 
public void METHOD_1 ( TYPE_1 parent , String VAR_1 , TYPE_2 trace ) { super . METHOD_1 ( parent , VAR_1 ) ; VAR_2 ++ ; VAR_3 = VAR_2 ; VAR_4 = trace ; VAR_5 = ( trace instanceof TYPE_3 ) ; METHOD_2 ( parent ) ; METHOD_3 ( ) ; <START> VAR_6 . METHOD_4 ( new TYPE_4 ( ) { <END> @Override public void METHOD_5 ( TYPE_5 e ) { METHOD_6 ( ) ; } } ) ; } 
public synchronized TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { try { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( TYPE_4 . get ( VAR_3 . append ( VAR_4 ) <START> . append ( VAR_5 ) . METHOD_3 ( ) ) ) ; <END> TYPE_5 config = new TYPE_5 ( new TYPE_6 ( ) ) ; config . VAR_6 ( TYPE_7 . VAR_8 ) ; VAR_1 = new TYPE_1 ( VAR_2 , config ) ; } catch ( IOException e ) { Logger . VAR_9 ( e ) ; } } return VAR_1 ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( File VAR_1 ) { if ( VAR_1 != null && <START> ! VAR_1 . equals ( VAR_2 ) ) { <END> VAR_2 = VAR_1 ; } } 
public void METHOD_1 ( String VAR_1 ) { <START> if ( VAR_2 == null ) { <END> if ( VAR_1 == null ) { return ; } } else if ( VAR_2 . equals ( VAR_1 ) ) { return ; } VAR_2 = VAR_1 ; } 
private static Integer METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . METHOD_4 ( TYPE_2 . class ) ) ; <START> return TYPE_4 . METHOD_5 ( new TYPE_5 ( ) { <END> @Override public Integer run ( ) { return VAR_2 . METHOD_6 ( ) ; } } ) ; } 
public void run ( ) { TYPE_1 VAR_1 = VAR_2 ; if ( VAR_1 == null ) { return ; } METHOD_1 ( VAR_1 ) ; if ( VAR_3 == null ) { VAR_3 = new TYPE_2 ( VAR_1 . METHOD_2 ( ) ) ; } if ( VAR_3 != null ) { VAR_3 . update ( VAR_1 ) ; VAR_3 . METHOD_3 ( ) ; <START> VAR_3 . METHOD_2 ( ) . METHOD_4 ( VAR_4 , VAR_4 ) ; <END> } } 
public TYPE_1 METHOD_1 ( TYPE_2 req , String name ) throws TYPE_3 , TYPE_4 { if ( ! name . equals ( VAR_1 ) ) throw new TYPE_3 ( name ) ; <START> final TYPE_1 <END> db = repo . VAR_2 ( ) ; db . VAR_3 ( ) ; return db ; } 
public String getMessage ( TYPE_1 VAR_1 , String value ) { TYPE_2 uri = <START> VAR_1 . METHOD_1 ( ) . METHOD_2 ( ) ; <END> if ( uri != null && uri . VAR_2 ( ) && uri . VAR_3 ( ) > 1 ) { TYPE_3 VAR_4 = TYPE_4 . METHOD_3 ( uri . VAR_5 ( 1 ) ) ; return TYPE_6 . TYPE_7 . getMessage ( VAR_4 , value ) ; } return value ; } 
protected void METHOD_1 ( ) throws Exception { <START> TYPE_1 . METHOD_2 ( ) ; <END> TYPE_1 . METHOD_3 ( VAR_1 ) ; VAR_2 = null ; VAR_3 = null ; VAR_4 = null ; super . METHOD_1 ( ) ; } 
protected TYPE_1 < String > METHOD_1 ( String VAR_1 ) { if ( STRING_1 . equals ( VAR_1 ) ) { return ( ) - > <START> VAR_2 ; <END> } return super . METHOD_1 ( VAR_1 ) ; } 
<START> protected String <END> METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { String VAR_4 = VAR_3 . getName ( ) ; TYPE_3 VAR_5 = new TYPE_3 ( VAR_6 , VAR_7 ) ; if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { String VAR_8 = VAR_5 . get ( VAR_2 , VAR_1 , String . VAR_9 ) ; if ( VAR_8 != null ) { VAR_4 = VAR_8 ; } } return VAR_4 ; } 
<START> protected int <END> METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { int VAR_4 = VAR_3 . METHOD_2 ( ) ; if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { TYPE_3 VAR_5 = new TYPE_3 ( VAR_6 , VAR_7 ) ; Integer VAR_8 = VAR_5 . get ( VAR_2 , VAR_1 , Integer . VAR_9 ) ; if ( VAR_8 != null && VAR_8 . METHOD_3 ( ) != VAR_4 ) { VAR_4 = VAR_8 ; } } return VAR_4 ; } 
<START> public static <END> boolean METHOD_1 ( TYPE_1 project ) { TYPE_2 VAR_1 = project . VAR_2 ( TYPE_3 . VAR_4 ) ; if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { return true ; } return false ; } 
<START> public static <END> boolean METHOD_1 ( TYPE_1 file ) { String VAR_1 = file . VAR_2 ( ) ; if ( ! VAR_1 . equals ( VAR_3 ) ) { return false ; } if ( file . exists ( ) && file . VAR_4 ( ) ) { String VAR_5 = file . VAR_6 ( ) . METHOD_2 ( ) ; if ( VAR_5 != null && ! VAR_5 . contains ( VAR_7 ) && ! VAR_5 . contains ( VAR_8 ) ) { return true ; } } return false ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 info ) { super ( VAR_2 ) ; METHOD_1 ( METHOD_2 ( ) | SWT . VAR_3 ) ; <START> VAR_4 = info != null ? info : new TYPE_2 ( TYPE_4 . VAR_6 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 req = new TYPE_1 ( TYPE_3 . VAR_2 ) ; for ( TYPE_2 item : TYPE_2 . values ( ) ) { <START> assertEquals ( item . VAR_3 ( ) , req . VAR_4 ( item . VAR_5 ( ) ) ) ; <END> } } 
public ANNOTATION_1 String toString ( ) { <START> return String . valueOf ( VAR_1 ) ; <END> } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = null ; try { VAR_1 = VAR_2 . getClass ( ) . METHOD_2 ( STRING_1 ) ; } catch ( TYPE_2 | TYPE_3 e ) { return false ; } return <START> ( VAR_1 != null ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_2 parent ) { final TYPE_2 VAR_1 = METHOD_2 ( parent ) ; <START> System . out . println ( VAR_1 . METHOD_3 ( ) ) ; <END> METHOD_4 ( VAR_1 ) ; METHOD_5 ( VAR_1 ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { METHOD_2 ( ) ; if ( METHOD_3 ( ) ) { return ; } if ( this . VAR_2 == null ) { this . VAR_2 = new <START> TYPE_3 < > ( ) ; <END> } this . VAR_2 . add ( VAR_1 ) ; } 
public ANNOTATION_1 String ANNOTATION_1 [ ] METHOD_1 ( ) { TYPE_1 < String > list = new TYPE_1 < > ( ) ; TYPE_2 VAR_1 = this ; while ( VAR_1 . parent != null ) { list . VAR_2 ( VAR_1 . getName ( ) ) ; VAR_1 = VAR_1 . parent ; } <START> return list . VAR_3 ( new ANNOTATION_1 String [ 0 ] ) ; <END> } 
private String METHOD_1 ( TYPE_1 VAR_1 , String path ) { String VAR_2 = METHOD_2 ( path ) ; try { TYPE_2 url = null ; if ( VAR_2 != null ) { url = VAR_1 . METHOD_3 ( VAR_2 ) ; } if ( url == null ) { url = VAR_1 . METHOD_3 ( path ) ; } if ( url != null ) { TYPE_2 VAR_3 = TYPE_3 . METHOD_4 ( url ) ; return VAR_3 . toString ( ) ; } <START> } catch ( IOException e ) { <END> } return null ; } 
public TYPE_3 ( TYPE_1 parent ) { super ( parent , Messages . TYPE_2 , Messages . TYPE_4 , Messages . TYPE_5 ) ; METHOD_1 ( VAR_5 ) ; <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( true ) ; <END> METHOD_2 ( ) . METHOD_5 ( ) . METHOD_4 ( false ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return VAR_1 . METHOD_1 ( ) != null ? VAR_1 . METHOD_1 ( ) : TYPE_2 . VAR_2 ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 . getId ( ) ) ; <START> METHOD_3 ( VAR_2 , VAR_3 ) ; <END> TYPE_3 . METHOD_4 ( VAR_1 , VAR_2 . METHOD_5 ( ) ) ; } 
public static TYPE_1 METHOD_1 ( Object object , TYPE_2 VAR_1 ) throws TYPE_3 { Object VAR_2 = METHOD_2 ( object , VAR_1 ) ; TYPE_1 VAR_3 = METHOD_3 ( VAR_2 ) ; if ( VAR_3 == null ) { VAR_2 = METHOD_2 ( object , VAR_4 , VAR_1 ) ; <START> if ( VAR_2 != null ) <END> VAR_3 = METHOD_3 ( VAR_2 ) ; } return VAR_3 ; } 
public TYPE_1 METHOD_1 ( ) { return <START> null ; <END> } 
public TYPE_2 ( String name ) { super ( name ) ; VAR_2 = TYPE_1 . METHOD_1 ( ) ; final String <START> VAR_3 = <END> STRING_1 ; String value = System . getProperty ( VAR_3 ) ; if ( value != null ) { if ( value . startsWith ( STRING_2 ) ) { VAR_4 = true ; } } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> VAR_1 . values ( ) . forEach ( VAR_2 - > { <END> VAR_2 . METHOD_2 ( ) ; } ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_2 ( ) ; } TYPE_1 . METHOD_3 ( ) . METHOD_4 ( this ) ; METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( VAR_4 ) ; } 
public TYPE_1 ( TYPE_2 VAR_1 , File VAR_2 , Set < TYPE_3 > VAR_3 ) { super ( TYPE_1 . class . getName ( ) ) ; <START> this . VAR_4 = Collections . VAR_5 ( ) ; <END> this . VAR_6 = VAR_2 ; this . VAR_7 = VAR_3 ; if ( this . VAR_7 == null ) { this . VAR_7 = new HashSet < > ( ) ; } METHOD_1 ( VAR_1 ) ; } 
private static ANNOTATION_1 Long METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <START> return VAR_1 == null ? null : Long . valueOf ( VAR_1 . METHOD_2 ( ) ) ; <END> } 
public ANNOTATION_1 String toString ( ) { TYPE_1 VAR_1 = VAR_2 . getValue ( ) ; TYPE_1 VAR_3 = VAR_4 . getValue ( ) ; if ( VAR_1 != null && VAR_3 != null ) { return STRING_1 + String . valueOf ( VAR_2 ) + STRING_2 + String . valueOf ( VAR_4 ) + STRING_3 ; } <START> return null ; <END> } 
private static ANNOTATION_1 Long METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return null ; } <START> <END> return Long . valueOf ( VAR_1 . METHOD_2 ( ) ) ; } 
<START> public static ArrayList < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <END> ArrayList < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_3 VAR_3 : VAR_1 . METHOD_2 ( ) ) { if ( VAR_3 instanceof TYPE_1 ) { VAR_2 . add ( ( TYPE_1 ) VAR_3 ) ; } } return VAR_2 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 result = null ; TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null ) { for ( TYPE_4 element : VAR_2 . METHOD_3 ( ) ) { if ( element instanceof TYPE_1 ) { final TYPE_1 VAR_3 = ( TYPE_1 ) element ; if <START> ( VAR_3 . METHOD_4 ( ) != null && VAR_3 . METHOD_4 ( ) . equals ( VAR_1 ) ) { <END> result = VAR_3 ; break ; } } } } return result ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 ) { <START> final Iterator < TYPE_2 . Entry > VAR_3 = VAR_2 . iterator ( ) ; List < TYPE_2 . Entry > VAR_4 = TYPE_3 . METHOD_2 ( ) ; while ( VAR_3 . hasNext ( ) ) { VAR_4 . add ( VAR_3 . next ( ) ) ; } <END> for ( TYPE_2 . Entry VAR_5 : VAR_4 ) { METHOD_3 ( VAR_1 , VAR_5 . METHOD_4 ( ) , VAR_5 . getValue ( ) ) ; } } 
public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = super . METHOD_1 ( ) ; result = VAR_1 * result + VAR_2 . METHOD_1 ( ) ; <START> result = VAR_1 * result + ( VAR_3 . equals ( TYPE_1 . VAR_5 ) ? INT_2 : INT_3 ) ; <END> result = VAR_1 * result + ( ( VAR_6 == null ) ? 0 : ( VAR_6 . METHOD_2 ( ) + 1 ) ) ; return result ; } 
public void METHOD_1 ( TYPE_1 parent ) { parent . VAR_1 ( new TYPE_2 ( SWT . VAR_2 ) ) ; TYPE_1 VAR_3 = new TYPE_1 ( parent , SWT . NONE ) ; VAR_3 . METHOD_2 ( new TYPE_3 ( 1 , false ) ) ; METHOD_3 ( VAR_3 ) ; <START> METHOD_4 ( ) ; <END> METHOD_5 ( ) ; } 
public long METHOD_1 ( ) { <START> if ( VAR_1 > 0 ) { <END> return VAR_1 ; } else { return Math . VAR_2 ( VAR_3 / 10 , TimeUnit . VAR_4 . METHOD_2 ( 10 ) ) ; } } 
public void METHOD_1 ( ) { try { VAR_1 = new TYPE_1 ( null , 0 ) ; METHOD_2 ( STRING_1 ) ; } catch ( IllegalArgumentException e ) { } int [ ] VAR_2 = { SWT . VAR_3 , SWT . VAR_4 , SWT . VAR_5 , SWT . VAR_6 , SWT . VAR_7 } ; <START> for ( int i = 0 ; i < VAR_2 . length ; i ++ ) <END> VAR_1 = new TYPE_1 ( VAR_8 , VAR_2 [ i ] ) ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( this ) ; TYPE_1 . METHOD_5 ( ) . METHOD_6 ( this ) ; TYPE_2 VAR_1 = ( TYPE_2 ) METHOD_2 ( ) . METHOD_7 ( TYPE_3 . class ) ; <START> VAR_1 . METHOD_8 ( VAR_2 ) ; <END> VAR_3 = null ; VAR_4 = null ; VAR_5 = null ; } 
private int METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , int VAR_3 ) { if ( VAR_1 instanceof TYPE_2 && VAR_2 instanceof TYPE_2 ) { TYPE_3 VAR_4 = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; TYPE_3 VAR_5 = ( ( TYPE_2 ) VAR_2 ) . METHOD_2 ( ) ; <START> return METHOD_3 ( VAR_4 . METHOD_4 ( ) , VAR_5 . METHOD_4 ( ) , VAR_3 ) ; <END> } return 0 ; } 
protected void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) { METHOD_2 ( VAR_1 ) ; } <END> } 
<START> public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <END> return STRING_1 ; } 
public boolean remove ( String id ) { <START> return this . VAR_1 . METHOD_1 ( id ) != null ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = null ; Collection < TYPE_2 > values = this . VAR_3 . values ( ) ; for ( TYPE_2 VAR_4 : values ) { if ( VAR_4 instanceof TYPE_3 ) { if ( VAR_1 != null && VAR_1 . equals ( VAR_4 . getId ( ) ) ) { <START> VAR_2 = ( ( TYPE_3 ) VAR_4 ) . METHOD_1 ( ) ; <END> } } } return VAR_2 ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_2 config = repo . VAR_1 ( ) ; TYPE_3 VAR_2 = config . VAR_3 ( TYPE_3 . values ( ) , TYPE_4 . VAR_5 , null , TYPE_4 . VAR_6 , null ) ; if ( VAR_2 == null ) { VAR_2 = config . VAR_3 ( TYPE_3 . values ( ) , TYPE_4 . VAR_7 , null , <START> TYPE_4 . VAR_6 , null ) ; <END> } return VAR_2 != null ? TYPE_1 . valueOf ( VAR_2 ) : null ; } 
protected void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( true ) ; VAR_1 . METHOD_3 ( ) ; <START> VAR_1 . METHOD_4 ( ) ; <END> VAR_1 . METHOD_5 ( ) ; TYPE_1 m = VAR_1 . METHOD_6 ( ) ; if ( m != null ) { m . VAR_2 ( ) ; } TYPE_2 VAR_3 = VAR_1 . METHOD_7 ( ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_8 ( ) ; } } finally { VAR_1 . METHOD_2 ( false ) ; } METHOD_9 ( ) . METHOD_10 ( ) ; } 
<START> public void <END> METHOD_1 ( TYPE_1 parent ) { VAR_1 = parent ; } 
public boolean METHOD_1 ( TYPE_1 trace ) { <START> return ! TYPE_2 . isEmpty ( METHOD_2 ( ) ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 data = VAR_1 . METHOD_2 ( ) ; boolean VAR_2 = data instanceof TYPE_3 && data . VAR_3 ( ) instanceof TYPE_4 ; return <START> VAR_2 ; <END> } 
private static Set < TYPE_1 > METHOD_1 ( Collection < TYPE_2 > VAR_1 ) { Set < TYPE_1 > VAR_2 = new HashSet < TYPE_1 > ( VAR_1 . size ( ) ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { if ( VAR_3 . METHOD_2 ( ) != null ) { VAR_2 . add ( VAR_3 . METHOD_2 ( ) ) ; } if ( VAR_3 . METHOD_3 ( ) != null ) { <START> VAR_2 . add ( VAR_3 . METHOD_3 ( ) ) ; <END> } } return VAR_2 ; } 
String METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_3 VAR_3 = ( TYPE_3 ) VAR_2 . METHOD_3 ( ) ; String VAR_4 = VAR_3 . METHOD_4 ( ) . get ( Constants . VAR_5 ) ; if ( VAR_4 == null ) { VAR_4 = VAR_1 . METHOD_5 ( ) ; } if ( VAR_4 . startsWith ( TYPE_4 ) ) { VAR_4 = VAR_4 . substring ( TYPE_4 . length ( ) ) ; } <START> return VAR_4 == null ? VAR_1 . METHOD_5 ( ) : VAR_4 ; <END> } 
public TYPE_1 < ANNOTATION_1 TYPE_2 , ANNOTATION_2 Long > METHOD_1 ( ) { <START> return ( o ) - > { <END> return o . VAR_1 ( ) ; } ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return METHOD_2 ( ImmutableList . VAR_1 ( VAR_2 ) ) ; <END> } 
public void METHOD_1 ( Object obj ) { for ( TYPE_1 VAR_1 : VAR_2 ) { VAR_1 . METHOD_1 ( obj ) ; <START> } <END> } 
public TYPE_3 ( TYPE_1 < Object > VAR_2 ) { VAR_3 = VAR_2 ; <START> VAR_4 = METHOD_1 ( TYPE_2 . create ( ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 id , boolean VAR_2 , HashSet < TYPE_3 > VAR_3 ) throws IOException { <START> if ( VAR_4 <= VAR_3 . size ( ) ) { return ; } <END> for ( TYPE_4 VAR_5 : VAR_1 . VAR_6 ) { if ( VAR_2 && VAR_5 . METHOD_2 ( ) ) { continue ; } VAR_5 . METHOD_3 ( this , VAR_3 , id , VAR_4 ) ; if ( VAR_4 <= VAR_3 . size ( ) ) { break ; } } } 
public boolean METHOD_1 ( final String r ) { <START> if ( VAR_1 && METHOD_2 ( ) == null ) { return METHOD_3 ( r , METHOD_4 ( ) ) ; } <END> return METHOD_3 ( r , METHOD_2 ( ) ) ; } 
<START> public String METHOD_1 ( ) { <END> String VAR_1 = METHOD_2 ( ) . trim ( ) ; if ( ! VAR_1 . startsWith ( VAR_2 ) || ! VAR_1 . METHOD_3 ( STRING_1 ) ) { throw new RuntimeException ( STRING_2 ) ; } int VAR_3 = VAR_1 . METHOD_4 ( CHAR_1 ) ; int VAR_4 = VAR_1 . METHOD_5 ( CHAR_2 ) ; return VAR_1 . substring ( VAR_3 + 1 , VAR_4 ) . trim ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { View VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null ) { TYPE_2 VAR_3 = VAR_2 . METHOD_3 ( ) ; if ( VAR_3 != null ) { TYPE_3 element = VAR_3 . METHOD_4 ( ) ; <START> if ( element instanceof TYPE_4 && ( ( TYPE_4 ) element ) . METHOD_5 ( ) ) { return true ; } <END> } } return false ; } 
private boolean METHOD_1 ( TYPE_1 ctx ) { assert ctx != null ; <START> TYPE_2 VAR_1 = METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; <END> return VAR_1 . METHOD_4 ( ctx ) ; } 
<START> protected void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( ) . METHOD_3 ( new TYPE_1 ( VAR_2 ) , VAR_1 . METHOD_4 ( ) ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 session , TYPE_3 VAR_1 ) { if ( METHOD_2 ( VAR_2 ) >= 0 || METHOD_2 ( STRING_1 ) >= 0 <START> ) { <END> return new TYPE_4 ( session , VAR_1 ) ; } return new TYPE_5 ( session , VAR_1 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { assert VAR_1 != null && VAR_2 != null ; if ( VAR_1 == null || VAR_2 == null ) { return null ; } int VAR_3 = 0 ; try { VAR_3 = Integer . parseInt ( VAR_2 ) ; } catch ( TYPE_3 e ) { TYPE_4 . log ( e ) ; } <START> return VAR_4 . METHOD_2 ( VAR_1 , VAR_3 ) ; <END> } 
public void update ( ) { TYPE_1 [ ] VAR_1 = METHOD_1 ( ) . METHOD_2 ( ) ; <START> METHOD_3 ( VAR_1 . length > 1 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 event ) { try { <START> TYPE_3 VAR_1 = TYPE_4 . get ( event . VAR_2 ( ) ) ; <END> if ( VAR_1 == null ) { return null ; } String VAR_3 = event . getName ( ) ; if ( VAR_1 . METHOD_2 ( ) . contains ( VAR_3 ) ) { return TYPE_1 . VAR_4 ; } else if ( VAR_1 . METHOD_3 ( ) . contains ( VAR_3 ) ) { return TYPE_1 . VAR_5 ; } } catch ( TYPE_5 e ) { } return null ; } 
public List < String > METHOD_1 ( ) { <START> if ( VAR_1 ) { <END> if ( VAR_2 == null ) { throw new TYPE_1 ( ) ; } return VAR_3 == null ? null : Collections . VAR_4 ( VAR_3 ) ; } else { throw new IllegalStateException ( ) ; } } 
protected boolean METHOD_1 ( final TYPE_1 element ) { <START> return TYPE_2 . METHOD_2 ( element ) != null ; <END> } 
private static String METHOD_1 ( String VAR_1 ) { <START> String VAR_2 = "" ; <END> String VAR_3 = VAR_1 ; TYPE_1 p = TYPE_1 . METHOD_2 ( STRING_1 ) ; TYPE_2 m = p . matcher ( VAR_3 ) ; if ( m . VAR_4 ( ) ) { int VAR_5 = Integer . parseInt ( m . group ( ) ) + 1 ; String VAR_6 = m . VAR_7 ( Integer . toString ( VAR_5 ) ) ; return VAR_6 + VAR_2 ; } return VAR_3 + STRING_2 + VAR_2 ; } 
public TYPE_2 ( String VAR_2 , String VAR_3 ) { <START> TYPE_1 . METHOD_1 ( VAR_2 ) ; VAR_4 = VAR_2 ; <END> VAR_5 = VAR_3 ; } 
public Object METHOD_1 ( Object object , TYPE_1 configuration ) { <START> return TYPE_2 . class . METHOD_2 ( object ) . METHOD_1 ( ) ; <END> } 
public Object [ ] METHOD_1 ( Object object , TYPE_1 configuration ) { <START> return TYPE_2 . class . METHOD_2 ( object ) . METHOD_1 ( <END> configuration . VAR_1 ( ) , configuration . VAR_2 ( ) ) ; } 
public boolean METHOD_1 ( Object object , TYPE_1 configuration ) { <START> return TYPE_2 . class . METHOD_2 ( object ) . METHOD_1 ( <END> configuration . VAR_1 ( ) , configuration . VAR_2 ( ) ) ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 parent , final TYPE_3 VAR_1 ) { final TYPE_4 VAR_2 = new TYPE_4 ( parent , VAR_1 , this , METHOD_2 ( ) ) ; final TYPE_5 VAR_3 = METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_3 ) ; <START> final TYPE_6 VAR_4 = new TYPE_7 ( <END> METHOD_5 ( ) , METHOD_6 ( ) , VAR_1 ) ; VAR_2 . METHOD_7 ( VAR_4 ) ; METHOD_8 ( VAR_2 ) ; return VAR_2 ; } 
public TYPE_9 ( ANNOTATION_1 ( VAR_2 ) List < TYPE_1 > VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 , TYPE_4 VAR_6 , TYPE_5 VAR_7 , TYPE_6 VAR_8 , TYPE_7 context , ANNOTATION_1 ( TYPE_9 . VAR_9 ) List < TYPE_8 > VAR_10 ) { this . VAR_11 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_12 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; this . VAR_8 = VAR_8 ; this . context = context ; <START> this . VAR_10 = VAR_10 ; <END> } 
public < T > T METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , T VAR_3 ) { T value = VAR_3 ; TYPE_3 < T > VAR_4 = null ; try { VAR_4 = METHOD_2 ( VAR_1 , VAR_2 ) ; } catch ( TYPE_4 ex ) { } <START> if ( VAR_4 != null ) { <END> value = VAR_4 . getValue ( ) ; } return value ; } 
public void METHOD_1 ( ) { when ( data . VAR_1 ( ) ) . METHOD_2 ( TYPE_1 . VAR_3 ) ; assertTrue ( VAR_4 . METHOD_3 ( ) ) ; when ( data . VAR_1 ( ) ) . METHOD_2 ( TYPE_1 . VAR_5 ) ; <START> assertTrue ( VAR_4 . METHOD_3 ( ) ) ; <END> when ( data . VAR_1 ( ) ) . METHOD_2 ( TYPE_1 . VAR_6 ) ; METHOD_4 ( VAR_4 . METHOD_3 ( ) ) ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . getStatus ( ) . equals ( TYPE_1 . VAR_3 ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { final TYPE_3 VAR_4 = VAR_2 . METHOD_2 ( ) ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . addAll ( VAR_4 . METHOD_3 ( ) ) ; <START> VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ; <END> VAR_3 . METHOD_6 ( ) . remove ( VAR_4 ) ; } 
protected void METHOD_1 ( ) { <START> String url = VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( TYPE_1 . bind ( Messages . TYPE_4 , url ) ) ; VAR_4 . METHOD_3 ( TYPE_1 . bind ( Messages . TYPE_4 , url ) ) ; VAR_5 . setText ( url + VAR_6 ) ; VAR_5 . METHOD_3 ( TYPE_1 . bind ( Messages . TYPE_3 , url ) ) ; VAR_5 . METHOD_4 ( TYPE_2 . METHOD_5 ( url + VAR_6 ) ) ; } 
protected void METHOD_1 ( ) throws Exception { <START> super . METHOD_1 ( ) ; <END> if ( project . exists ( ) ) { project . VAR_1 ( true , null ) ; } } 
private static TYPE_1 [ ] METHOD_1 ( String VAR_1 , TYPE_1 [ ] VAR_2 ) throws TYPE_2 { if ( null == VAR_1 ) return VAR_2 ; ArrayList < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_4 : VAR_2 ) { <START> if ( VAR_1 . equals ( METHOD_2 ( VAR_4 ) ) ) <END> VAR_3 . add ( VAR_4 ) ; } return VAR_3 . METHOD_3 ( new TYPE_1 [ VAR_3 . size ( ) ] ) ; } 
public Object METHOD_1 ( final Object object ) { TYPE_1 element = TYPE_2 . METHOD_2 ( object ) ; <START> if ( element == null ) { <END> return null ; } TYPE_3 VAR_1 = METHOD_3 ( element ) ; return ( VAR_1 == null ) ? null : VAR_1 . METHOD_1 ( element ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 , String ... VAR_3 ) { TYPE_2 VAR_4 = VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_4 ) ) ; TYPE_4 VAR_5 = TYPE_5 . METHOD_5 ( VAR_1 , VAR_4 , VAR_3 ) ; if ( VAR_2 ) { <START> VAR_5 . METHOD_6 ( ) ; <END> } else { VAR_5 . METHOD_7 ( ) ; } } 
<START> public TYPE_1 METHOD_1 ( TYPE_1 <END> VAR_1 , TYPE_1 VAR_2 , int count ) { VAR_1 = VAR_1 . METHOD_2 ( count ) ; return VAR_2 . append ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 event ) { final TYPE_2 VAR_1 = ( TYPE_2 ) VAR_2 . METHOD_2 ( ) ; <START> TYPE_3 . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; <END> } 
protected TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 model ) { super ( VAR_2 ) ; <START> VAR_3 = VAR_2 ; <END> VAR_4 = model ; } 
public void METHOD_1 ( TYPE_1 event ) { <START> event . VAR_1 = ! ( ( event . data instanceof TYPE_2 ) || ( event . data instanceof TYPE_3 ) ) ; <END> final TYPE_4 VAR_2 = ( TYPE_4 ) VAR_3 . METHOD_2 ( ) ; TYPE_5 . METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; } 
public void run ( ) { try { VAR_1 . METHOD_1 ( ) ; <START> METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_4 . VAR_3 ) ) ; <END> } catch ( TYPE_2 e ) { TYPE_1 . log ( new Status ( TYPE_3 . VAR_5 , TYPE_1 . VAR_6 , STRING_1 , e ) ) ; } } 
public void METHOD_1 ( TYPE_1 parent ) { super . METHOD_1 ( parent ) ; <START> VAR_1 = super . METHOD_2 ( ) ; <END> METHOD_3 ( ) ; METHOD_4 ( ) ; } 
public static boolean METHOD_1 ( TYPE_1 element ) { <START> return ( TYPE_2 . METHOD_2 ( element , TYPE_3 . class ) != null ) ? true : false ; <END> } 
public static String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 source , String content ) throws TYPE_3 { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; String VAR_3 = content ; TYPE_4 < String , TYPE_5 > VAR_4 = METHOD_3 ( content ) ; if ( ! VAR_4 . isEmpty ( ) ) { <START> VAR_3 = METHOD_4 ( VAR_2 , source , content , VAR_4 , true , null , null ) ; <END> } return VAR_3 ; } 
public void METHOD_1 ( TYPE_1 parent , TYPE_2 VAR_1 ) { <START> super . METHOD_1 ( parent , VAR_1 , ( METHOD_2 ( ) . VAR_2 == TYPE_3 . VAR_4 ? SWT . VAR_5 : SWT . NONE ) ) ; <END> if ( ! METHOD_3 ( ) && VAR_6 ) { METHOD_4 ( ) . METHOD_5 ( STRING_1 ) ; } } 
public String toString ( ) { if ( getName ( ) == null ) { return METHOD_1 ( ) ; } else { if ( METHOD_1 ( ) == null ) { <START> return "" ; <END> } else { if ( getName ( ) . equals ( METHOD_1 ( ) ) ) { return getName ( ) ; } else { return getName ( ) + STRING_1 + METHOD_1 ( ) + STRING_2 ; } } } } 
public String toString ( ) { <START> if ( getName ( ) == null ) { <END> return METHOD_1 ( ) ; } else { if ( METHOD_1 ( ) == null ) { return getName ( ) ; } else { if ( getName ( ) . equals ( METHOD_1 ( ) ) ) { return getName ( ) ; } else { return getName ( ) + STRING_1 + METHOD_1 ( ) + STRING_2 ; } } } } 
public void METHOD_1 ( String name , int VAR_1 ) { VAR_2 = name ; VAR_3 = "" ; METHOD_2 ( ) ; if ( ( VAR_1 == TYPE_1 . VAR_5 || VAR_1 == 0 ) && ! VAR_6 . METHOD_3 ( ) ) { VAR_6 . METHOD_4 ( ) ; } else { <START> VAR_6 . METHOD_1 ( VAR_1 ) ; <END> } if ( VAR_7 != null && ! VAR_7 . METHOD_3 ( ) ) { VAR_7 . METHOD_5 ( true ) ; VAR_7 . METHOD_6 ( ) ; } } 
public int METHOD_1 ( ) { <START> final int VAR_1 = INT_1 ; int result = 1 ; result = VAR_1 * result + ( ( this . VAR_2 == null ) ? 0 : this . VAR_2 . METHOD_1 ( ) ) ; return result ; <END> } 
public TYPE_5 ( ) { super ( TYPE_3 . TYPE_1 , TYPE_2 . VAR_5 ) ; <START> setText ( TYPE_3 . TYPE_1 ) ; <END> METHOD_1 ( TYPE_3 . TYPE_4 ) ; METHOD_2 ( METHOD_3 ( ) ) ; } 
public void run ( ) { boolean VAR_1 = ! METHOD_1 ( ) ; <START> METHOD_2 ( VAR_1 ) ; <END> TYPE_1 VAR_2 = TYPE_4 . TYPE_5 . METHOD_3 ( TYPE_6 . VAR_4 ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_4 ( TYPE_7 . VAR_6 , VAR_1 ) ; try { VAR_2 . METHOD_5 ( ) ; } catch ( TYPE_3 e ) { } } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { return <START> VAR_2 && <END> ( METHOD_2 ( VAR_1 ) || ( VAR_3 && VAR_4 . METHOD_3 ( VAR_1 ) && ( VAR_1 instanceof TYPE_2 ) ) ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 [ ] VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_2 VAR_3 = METHOD_3 ( VAR_2 ) ; if ( VAR_3 == null ) { return ; } for ( TYPE_2 VAR_4 : VAR_2 ) { boolean VAR_5 = VAR_4 . METHOD_4 ( ) ; <START> if ( VAR_4 != VAR_3 && VAR_5 ) { <END> VAR_4 . close ( ) ; } } } 
public TYPE_2 ( TYPE_1 [ ] VAR_2 ) { <START> VAR_3 = new HashSet < TYPE_1 > ( ) ; <END> VAR_3 . addAll ( Arrays . asList ( VAR_2 ) ) ; } 
private void METHOD_1 ( final TYPE_1 location , TYPE_2 db ) { synchronized ( METHOD_2 ( location ) ) { <START> if ( METHOD_3 ( db ) ) { <END> TYPE_2 VAR_1 = METHOD_4 ( location ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_5 ( ) ; } } } } 
protected TYPE_1 run ( TYPE_2 monitor ) { try { VAR_1 . run ( monitor ) ; } catch ( TYPE_3 e ) { TYPE_1 VAR_2 = e . getStatus ( ) ; return new Status ( VAR_2 . METHOD_1 ( ) , VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) , VAR_2 . getMessage ( ) , e ) ; <START> } finally { monitor . VAR_3 ( ) ; <END> } return Status . VAR_4 ; } 
public void METHOD_1 ( TYPE_1 monitor ) { TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( monitor , 1 ) ; TYPE_3 VAR_2 = TYPE_4 . METHOD_3 ( ) . METHOD_4 ( ) ; VAR_2 . METHOD_5 ( this ) ; VAR_3 = new TYPE_5 ( ) ; VAR_4 = new TYPE_6 ( VAR_5 , this ) ; boolean VAR_6 = VAR_2 . METHOD_6 ( TYPE_4 . VAR_7 ) ; if ( VAR_6 ) METHOD_7 ( VAR_6 , VAR_1 . split ( 1 ) ) ; <START> VAR_1 . METHOD_8 ( 0 ) ; <END> } 
public int METHOD_1 ( ) { if ( isEmpty ( ) ) { return <START> TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> } int r ; if ( VAR_1 != null ) { r = INT_1 + VAR_1 . METHOD_1 ( ) ; for ( Object e : VAR_2 ) { r = INT_1 * r + ( e == null ? 0 : VAR_1 . METHOD_1 ( e ) ) ; } } else { r = Arrays . VAR_3 ( VAR_2 ) ; } return r ; } 
public int METHOD_1 ( ) { if ( VAR_1 == null ) { return TYPE_1 . METHOD_2 ( VAR_2 ) ; } <START> int r = 1 ; <END> if ( VAR_2 != null ) { r = INT_1 + VAR_2 . METHOD_1 ( ) ; for ( Object e : VAR_1 ) { r = INT_1 * r + ( e == null ? 0 : VAR_2 . METHOD_1 ( e ) ) ; } } else { Arrays . VAR_3 ( VAR_1 ) ; } return r ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 parent ) { TYPE_2 VAR_1 = ( TYPE_2 ) super . METHOD_1 ( parent ) ; TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 , SWT . NONE ) ; VAR_2 . METHOD_2 ( new TYPE_3 ( 1 , false ) ) ; TYPE_4 . METHOD_3 ( ) . METHOD_4 ( SWT . VAR_3 , SWT . VAR_4 ) . METHOD_5 ( VAR_2 ) ; METHOD_6 ( VAR_2 ) ; VAR_2 . METHOD_7 ( ) ; <START> return parent ; <END> } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = <START> TYPE_3 . METHOD_2 ( TYPE_4 . class ) ; <END> return TYPE_5 . METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { <START> assertTrue ( VAR_1 . METHOD_2 ( METHOD_3 ( TYPE_1 . class ) ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { if ( VAR_2 == null ) <START> VAR_2 = new HashSet < TYPE_1 > ( ) ; <END> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { TYPE_1 VAR_3 = VAR_1 [ i ] ; VAR_2 . add ( VAR_3 ) ; } } 
public void start ( TYPE_1 context ) throws Exception { super . start ( context ) ; <START> TYPE_2 < String , String > properties = new TYPE_2 < String , String > ( 2 ) ; <END> properties . put ( TYPE_7 . VAR_2 , VAR_3 ) ; VAR_4 = context . VAR_5 ( TYPE_3 . class , TYPE_5 . VAR_7 , properties ) ; TYPE_4 . METHOD_1 ( ) . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( TYPE_6 . VAR_9 ) ) ; } 
private static Map < TYPE_1 , Long > METHOD_1 ( List < TYPE_2 > VAR_1 ) { Map < TYPE_1 , Long > map = new HashMap < TYPE_1 , Long > ( ) ; <START> for ( Iterator < TYPE_2 > VAR_2 = VAR_1 . iterator ( ) ; VAR_2 . hasNext ( ) ; ) { <END> TYPE_1 file = ( TYPE_1 ) VAR_2 . next ( ) ; map . put ( file , new Long ( file . VAR_3 ( ) ) ) ; } return map ; } 
TYPE_1 create ( ) { METHOD_1 ( ) ; try { return METHOD_2 ( ) ; <START> } catch ( RuntimeException VAR_1 ) { <END> throw TYPE_2 . METHOD_3 ( VAR_1 ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
protected static void METHOD_1 ( String ... path ) { String VAR_1 = TYPE_1 . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) . METHOD_4 ( path ) ; <START> VAR_3 = VAR_1 == null ? null : VAR_1 . isEmpty ( ) ? null : VAR_1 ; <END> VAR_4 = true ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . add ( VAR_1 ) ; if ( VAR_3 . size ( ) > 0 ) { new TYPE_2 ( VAR_1 ) . METHOD_2 ( ) ; <START> } <END> } 
protected TYPE_1 METHOD_1 ( ) { if ( size == null ) { size = new <START> TYPE_1 ( METHOD_2 ( ) . VAR_1 , <END> METHOD_2 ( ) . VAR_2 ) ; } return size ; } 
public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < TYPE_3 > VAR_2 ) { if ( TYPE_4 . class . METHOD_2 ( VAR_1 ) ) { final TYPE_4 VAR_3 = TYPE_4 . class . METHOD_3 ( VAR_1 ) ; if ( VAR_3 . METHOD_4 ( ) != null && <START> VAR_3 . METHOD_4 ( ) != this <END> && VAR_2 . contains ( VAR_3 . METHOD_4 ( ) ) ) { final TYPE_3 VAR_4 = VAR_2 . METHOD_5 ( VAR_3 . METHOD_4 ( ) ) ; return VAR_4 . getId ( ) + VAR_5 ; } } return null ; } 
private void METHOD_1 ( ) { <START> for ( int VAR_1 = 0 ; VAR_1 < 2 ; VAR_1 ++ ) { <END> for ( Iterator < Map . Entry < TYPE_1 , TYPE_2 < TYPE_3 > > > i = VAR_2 . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final Map . Entry < TYPE_1 , TYPE_2 < TYPE_3 > > e = i . next ( ) ; METHOD_2 ( e . getKey ( ) , null ) ; } } } 
public boolean METHOD_1 ( Object VAR_1 ) { if ( VAR_1 instanceof TYPE_1 ) { TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 ; <START> Object element = VAR_2 . METHOD_2 ( ) ; <END> if ( element instanceof TYPE_2 ) { return true ; } } return false ; } 
public Set < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { final Set < TYPE_1 > result = new TYPE_3 < TYPE_1 > ( ) ; final <START> TYPE_4 < TYPE_5 > <END> VAR_2 = VAR_1 . METHOD_2 ( ) ; for ( final TYPE_5 VAR_3 : VAR_2 . METHOD_3 ( ) ) { result . addAll ( VAR_3 . METHOD_1 ( ) ) ; } return result ; } 
public void METHOD_1 ( ) throws <START> IOException , InterruptedException { <END> TYPE_1 start = VAR_1 . start ( ) ; start . VAR_2 ( ) ; assertEquals ( STRING_1 , METHOD_2 ( start ) ) ; } 
protected TYPE_1 METHOD_1 ( String key , String value ) { if ( VAR_1 . containsKey ( key ) ) { String VAR_2 = VAR_1 . get ( key ) ; <START> if ( ( VAR_2 != null || value != null ) && ! TYPE_2 . METHOD_2 ( VAR_2 , value ) ) { <END> VAR_1 . put ( key , TYPE_2 . METHOD_3 ( VAR_3 , VAR_2 , value ) ) ; } } else { VAR_1 . put ( key , value ) ; } return this ; } 
public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 set ) { if ( METHOD_2 ( ) . contains ( VAR_1 . METHOD_3 ( ) ) ) { TYPE_3 VAR_2 = METHOD_4 ( ) . METHOD_5 ( VAR_1 . METHOD_3 ( ) , set ) ; METHOD_1 ( VAR_2 ) ; } <START> return null ; <END> } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = TYPE_2 . VAR_3 ; <END> if ( VAR_1 . METHOD_2 ( ) instanceof TYPE_3 ) { TYPE_3 VAR_4 = ( TYPE_3 ) VAR_1 . METHOD_2 ( ) ; return VAR_4 . METHOD_3 ( ) == TYPE_2 . VAR_5 ; } return false ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_2 ( ) ; try { TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) . run ( true , false , VAR_1 ) ; METHOD_4 ( STRING_1 ) ; } catch ( TYPE_4 e ) { } boolean <START> VAR_2 = <END> Thread . VAR_2 ( ) ; if ( VAR_2 ) { METHOD_4 ( STRING_2 ) ; } } 
private TYPE_1 METHOD_1 ( ) throws IOException { TYPE_2 c = TYPE_3 . getInstance ( ) . METHOD_2 ( null , VAR_1 . VAR_2 ) ; try { c . VAR_3 ( ) ; } catch ( TYPE_4 VAR_4 ) { IOException VAR_5 = new IOException ( TYPE_5 . format ( TYPE_6 . get ( ) . VAR_6 , c . VAR_7 ( ) . METHOD_3 ( ) , VAR_4 ) ) ; <START> VAR_5 . METHOD_4 ( VAR_4 ) ; <END> throw VAR_5 ; } return c ; } 
public boolean METHOD_1 ( ) { if ( METHOD_2 ( ) == null ) { return false ; } TYPE_1 ctx = TYPE_2 . getInstance ( ) . METHOD_3 ( ) ; long VAR_1 = ctx . VAR_2 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; long VAR_3 = ctx . VAR_2 ( ) . METHOD_6 ( ) . METHOD_5 ( ) ; <START> if ( METHOD_7 ( ) != VAR_1 || METHOD_8 ( ) != VAR_3 ) { <END> return true ; } return false ; } 
private static Object METHOD_1 ( long VAR_1 , long VAR_2 , TYPE_1 < ANNOTATION_1 TYPE_2 > VAR_3 , ANNOTATION_1 TYPE_3 < ANNOTATION_1 TYPE_2 > VAR_4 ) { Object VAR_5 = null ; for ( TYPE_2 VAR_6 : VAR_3 . METHOD_2 ( ( VAR_2 - VAR_1 ) / 2 , VAR_4 ) ) { VAR_5 = VAR_6 ; } <START> return VAR_5 ; <END> } 
<START> public TYPE_1 <END> METHOD_1 ( ) { return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { try { TYPE_2 . METHOD_2 ( ) ; METHOD_3 ( ) ; } finally { TYPE_2 . METHOD_4 ( ) ; } } if ( ! ( VAR_1 instanceof TYPE_3 ) ) { return VAR_1 ; } TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; if <START> ( VAR_2 . METHOD_5 ( ) <END> == null ) { TYPE_1 VAR_3 = METHOD_3 ( ) ; VAR_2 . METHOD_6 ( VAR_3 ) ; VAR_1 = VAR_2 ; } return VAR_2 . METHOD_5 ( ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 ) { METHOD_2 ( true ) ; return ; } if ( VAR_2 != null && VAR_2 . METHOD_3 ( ) <START> != null <END> && VAR_3 != null && ! VAR_3 . METHOD_4 ( ) ) { if ( TYPE_2 . VAR_5 ) { VAR_3 . METHOD_1 ( ) ; VAR_3 . update ( ) ; } else { TYPE_1 VAR_6 = new TYPE_1 ( VAR_3 ) ; METHOD_5 ( VAR_6 ) ; VAR_6 . METHOD_6 ( ) ; } } } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return new TYPE_3 < TYPE_2 > ( <END> TYPE_4 . METHOD_2 ( TYPE_4 . of ( this ) , METHOD_3 ( ) . stream ( ) . METHOD_4 ( TYPE_2 : : METHOD_5 ) ) . collect ( Collectors . VAR_1 ( ) ) ) ; } 
private static void METHOD_1 ( int size , int [ ] VAR_1 , TYPE_1 < ANNOTATION_1 TYPE_2 > VAR_2 , long count , TYPE_3 VAR_3 ) { for ( int i = 0 ; i < count ; i ++ ) { <START> long start = i + VAR_1 [ i % size ] ; <END> VAR_2 . add ( VAR_3 . METHOD_2 ( start , start + 10 , i ) ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 ; <START> METHOD_2 ( VAR_1 . METHOD_3 ( ) . VAR_3 ) ; <END> } 
public void METHOD_1 ( TYPE_1 event ) { if ( VAR_1 != null ) { try { METHOD_2 ( event . VAR_2 ) ; } catch ( IllegalStateException e ) { String VAR_3 = STRING_1 ; TYPE_2 log = TYPE_3 . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_3 ) ) ; log . log ( new Status ( TYPE_5 . VAR_5 , VAR_3 , <START> TYPE_4 . getString ( STRING_2 ) , <END> e ) ) ; return ; } } } 
public static int METHOD_1 ( Integer value , int VAR_1 ) { if ( value != null ) { return value . VAR_2 ( ) ; } <START> else { <END> return VAR_1 ; } } 
<START> public ANNOTATION_1 TYPE_1 METHOD_1 ( long start , long VAR_1 ) { <END> return new TYPE_2 ( start , VAR_1 ) ; } 
private static void METHOD_1 ( int size , int [ ] VAR_1 , TYPE_1 < ANNOTATION_1 TYPE_2 > VAR_2 , long VAR_3 , long VAR_4 ) { for ( int i = ( int ) VAR_3 ; i < VAR_4 ; i ++ ) { <START> long start = ( long ) i + VAR_1 [ i % size ] ; <END> VAR_2 . add ( new TYPE_3 ( start , start + 10 ) ) ; } } 
private static int [ ] METHOD_1 ( int size ) { int [ ] VAR_1 = new int [ VAR_2 ] ; TYPE_1 VAR_3 = new TYPE_1 ( 10 ) ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { <START> VAR_1 [ i ] = VAR_3 . METHOD_2 ( ) ; <END> } return VAR_1 ; } 
public Object execute ( TYPE_1 event ) throws <START> TYPE_2 { <END> VAR_1 . METHOD_1 ( ) ; VAR_1 . METHOD_2 ( ) ; return null ; } 
<START> protected synchronized void METHOD_1 ( boolean VAR_1 ) { <END> if ( ! VAR_1 ) { if ( VAR_2 != null ) { METHOD_2 ( VAR_2 ) ; VAR_2 = null ; } if ( VAR_3 != null ) { METHOD_3 ( VAR_3 ) ; VAR_3 = null ; } } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 model , TYPE_3 VAR_2 ) { return VAR_1 . METHOD_2 ( ) && model . VAR_3 ( ) && model . VAR_4 ( VAR_2 ) <START> && METHOD_3 ( VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) ? true : false ; <END> } 
protected int METHOD_1 ( ) { <START> int VAR_1 = Integer . parseInt ( TYPE_2 . TYPE_3 . getString ( STRING_1 ) ) ; return VAR_1 ; <END> } 
public org . VAR_1 . VAR_2 . VAR_3 . TYPE_1 METHOD_1 ( List VAR_5 ) { org . VAR_1 . VAR_2 . VAR_3 . TYPE_1 VAR_6 = super . METHOD_1 ( VAR_5 ) ; return new <START> org . VAR_1 . VAR_2 . VAR_3 . TYPE_1 ( VAR_6 . x , VAR_6 . y , METHOD_2 ( VAR_6 . VAR_7 ) , <END> METHOD_2 ( VAR_6 . VAR_8 ) ) ; } 
public String toString ( ) { <START> final TYPE_1 builder = new TYPE_1 ( this ) ; <END> builder . VAR_1 ( STRING_1 , VAR_2 ) . METHOD_1 ( STRING_2 , VAR_3 ) . METHOD_1 ( STRING_3 , VAR_4 ) . METHOD_1 ( STRING_4 , VAR_5 ) ; return builder . toString ( ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 listener = TYPE_1 . METHOD_2 ( event - > { <END> VAR_1 = true ; } ) ; VAR_2 . METHOD_3 ( listener ) ; VAR_1 = false ; VAR_2 . METHOD_4 ( SWT . TYPE_3 , new TYPE_2 ( ) ) ; assertTrue ( VAR_1 ) ; VAR_2 . METHOD_5 ( listener ) ; VAR_1 = false ; VAR_2 . METHOD_4 ( SWT . TYPE_3 , new TYPE_2 ( ) ) ; METHOD_6 ( VAR_1 ) ; } 
public <START> boolean METHOD_1 ( ) <END> { return VAR_1 ; } 
public <START> void METHOD_1 ( boolean <END> value ) { VAR_1 = value ; } 
protected void METHOD_1 ( final TYPE_1 output , final TYPE_2 ctx ) { final TYPE_3 session = TYPE_3 . METHOD_2 ( ctx . VAR_1 ( ) ) ; <START> session . VAR_2 ( ) . execute ( new TYPE_4 ( ) { <END> @Override public void run ( ) { int token = output . VAR_3 ( ) . METHOD_3 ( ) ; session . VAR_4 ( TYPE_5 . parse ( ctx , token , output . VAR_3 ( ) . METHOD_4 ( ) , output . VAR_5 ( ) ) , null ) ; } } ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , int VAR_3 ) { super ( VAR_2 ) ; this . VAR_4 = new ArrayList < TYPE_2 > ( ) ; this . VAR_5 = new TYPE_3 ( ) ; this . VAR_6 = new TYPE_3 ( ) ; this . VAR_3 = VAR_3 ; <START> VAR_2 . METHOD_1 ( this . VAR_5 ) ; <END> this . VAR_7 = TYPE_4 . METHOD_2 ( 0 , VAR_3 ) ; this . VAR_8 = TYPE_4 . METHOD_3 ( VAR_3 ) ; this . VAR_9 = true ; } 
<START> protected TYPE_1 <END> METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_1 VAR_2 = VAR_1 . METHOD_4 ( VAR_3 ) ; if ( VAR_2 == null ) { VAR_2 = VAR_1 . METHOD_5 ( VAR_3 ) ; } return VAR_2 ; } 
void METHOD_1 ( ) { while ( ! VAR_1 . isEmpty ( ) || METHOD_2 ( ) != null ) { TYPE_1 node = METHOD_2 ( ) ; while ( node != null ) { node . VAR_2 ( ) ; node = METHOD_2 ( ) ; } <START> if ( ! VAR_1 . isEmpty ( ) ) { <END> TYPE_2 VAR_3 = VAR_1 . iterator ( ) . next ( ) ; VAR_1 . remove ( VAR_3 ) ; VAR_3 . METHOD_3 ( ) ; } } } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 from , TYPE_2 to ) { if ( from . VAR_1 ( to ) > 0 ) { throw new IllegalArgumentException ( from . toString ( ) + STRING_1 + to . toString ( ) ) ; } <END> return new TYPE_3 < > ( max ( VAR_2 , from ) , METHOD_2 ( VAR_3 , to ) ) ; } 
public boolean close ( ) { <START> if ( VAR_1 != null ) <END> VAR_1 . METHOD_1 ( ) ; return super . close ( ) ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) ; if ( VAR_2 instanceof TYPE_3 ) { TYPE_4 VAR_3 = new TYPE_4 ( ( TYPE_3 ) VAR_2 ) ; VAR_1 . METHOD_5 ( ) . METHOD_7 ( VAR_3 ) ; <START> VAR_3 . METHOD_8 ( Arrays . asList ( ( TYPE_5 ) METHOD_9 ( ) ) , METHOD_9 ( ) ) ; <END> } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = false ; if <START> ( ! ( VAR_1 instanceof TYPE_2 ) ) { <END> VAR_2 = true ; } return VAR_2 ; } 
public void METHOD_1 ( String VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( VAR_2 != null ) <END> VAR_2 . setText ( VAR_1 ) ; } 
public void METHOD_1 ( String VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( VAR_2 != null ) <END> VAR_2 . METHOD_2 ( VAR_1 ) ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = ( VAR_1 == null ) ? null : TYPE_2 . getInstance ( VAR_1 ) ; <END> return ( VAR_2 != null ) && VAR_2 . METHOD_1 ( ) ; } 
public String toString ( ) { return new String ( this . VAR_1 ) + <START> STRING_1 + <END> new String ( this . VAR_2 ) ; } 
<START> public final String METHOD_1 ( ) { <END> return String . format ( STRING_1 , getId ( ) , getName ( ) ) ; } 
public static String METHOD_1 ( String name , boolean trim ) { if ( trim ) { <START> name = <END> name . trim ( ) ; } return name . VAR_1 ( STRING_1 , STRING_2 ) . METHOD_2 ( STRING_3 , STRING_4 ) . METHOD_2 ( STRING_5 , STRING_6 ) . METHOD_2 ( STRING_7 , STRING_6 ) . METHOD_2 ( STRING_8 , "" ) . METHOD_2 ( STRING_9 , "" ) ; } 
public void METHOD_1 ( int VAR_1 ) { <START> if ( 0 > VAR_1 || VAR_1 >= METHOD_2 ( ) . size ( ) ) { <END> METHOD_2 ( ) . remove ( VAR_1 ) ; } } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_2 cache ) { TYPE_1 VAR_3 = VAR_2 ; while ( VAR_3 != null ) { <START> for ( TYPE_3 VAR_4 : VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) ) { this . METHOD_4 ( VAR_4 , VAR_1 , VAR_3 , cache ) ; } <END> VAR_3 = METHOD_5 ( VAR_3 ) ; } } 
protected void METHOD_1 ( ) { VAR_1 = new TYPE_1 < > ( ) ; if ( VAR_2 != null ) { for ( TYPE_2 VAR_3 : VAR_2 . METHOD_2 ( ) ) { TYPE_3 VAR_4 = <START> TYPE_3 . getInstance ( VAR_3 ) ; <END> TYPE_4 VAR_5 = VAR_4 . getType ( ) ; if ( VAR_5 != null ) { VAR_1 . add ( VAR_5 ) ; } } } } 
public void run ( TYPE_1 action ) { try { TYPE_2 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_6 . VAR_2 ) ; } catch ( TYPE_3 e ) { TYPE_4 . log ( new Status ( TYPE_5 . VAR_4 , TYPE_7 . VAR_6 , STRING_1 , e ) ) ; <START> e . VAR_7 ( ) ; <END> } } 
<START> static int METHOD_1 ( ) { <END> return INT_1 * METHOD_2 ( ) . METHOD_3 ( ) . getInt ( TYPE_1 . VAR_2 ) ; } 
private static TYPE_1 < ANNOTATION_1 TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { double [ ] VAR_2 = VAR_1 . METHOD_2 ( ) ; assertNotNull ( VAR_2 ) ; TYPE_1 < ANNOTATION_1 TYPE_2 > VAR_3 = new TYPE_4 < > ( s - > s . VAR_4 ( ) ) ; for ( double item : VAR_2 ) { <START> VAR_3 . update ( new TYPE_2 ( 0 , ( long ) ( item - FLOAT_1 ) ) ) ; <END> } return VAR_3 ; } 
public Collection < TYPE_1 > METHOD_1 ( final String VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 ) ; return METHOD_1 ( new TYPE_3 < TYPE_6 . TYPE_5 > ( ) { @Override public boolean apply ( TYPE_5 input ) { return input != null <START> && input . VAR_2 ( ) != null ? VAR_1 . equals ( input . VAR_2 ( ) . getName ( ) ) <END> : false ; } } ) ; } 
<START> static void METHOD_1 ( long VAR_1 , double VAR_2 , double VAR_3 , long VAR_4 ) { <END> if ( OS . VAR_5 ( VAR_1 ) ) { double VAR_6 = OS . VAR_7 ( VAR_1 ) * 100 ; TYPE_1 VAR_8 = METHOD_2 ( VAR_4 ) ; VAR_8 . METHOD_3 ( 0 , SWT . VAR_9 , 0 , 0 , VAR_6 ) ; } } 
public Object METHOD_1 ( Object element ) { if ( element instanceof TYPE_1 && element != VAR_1 ) return VAR_1 ; Object res = VAR_2 . get ( element ) ; if ( res != null ) { return res ; } if <START> ( VAR_3 . contains ( res ) ) <END> { return VAR_4 ; } return null ; } 
private void METHOD_1 ( final int index ) { int VAR_1 = METHOD_2 ( ) ; <START> Assert . VAR_2 ( index < VAR_1 && index > 0 , VAR_3 . text . TYPE_1 . format ( <END> STRING_1 , index , VAR_1 ) ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( SWT . TYPE_2 ) ; METHOD_2 ( SWT . TYPE_4 ) ; METHOD_2 ( SWT . TYPE_5 ) ; METHOD_2 ( SWT . TYPE_3 ) ; METHOD_2 ( SWT . TYPE_7 ) ; METHOD_2 ( SWT . TYPE_6 ) ; <START> METHOD_2 ( SWT . TYPE_1 ) ; <END> METHOD_2 ( SWT . TYPE_9 ) ; METHOD_2 ( SWT . TYPE_3 ) ; METHOD_2 ( SWT . TYPE_10 ) ; METHOD_2 ( SWT . TYPE_8 ) ; METHOD_2 ( SWT . TYPE_11 ) ; } 
private TYPE_1 METHOD_1 ( final String VAR_1 , final TYPE_2 [ ] VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( ) { @Override public boolean METHOD_2 ( ) { return true ; } @Override public String getName ( ) { return VAR_1 ; } @Override public String METHOD_3 ( ) { return null ; <START> } <END> @Override public TYPE_2 [ ] METHOD_4 ( ) throws TYPE_3 { return VAR_2 ; } } ; return VAR_3 ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) VAR_1 . METHOD_2 ( ) ; <END> } 
private boolean METHOD_1 ( File file ) { String VAR_1 = file . getName ( ) ; return VAR_1 . startsWith ( STRING_1 ) && ( VAR_1 . METHOD_2 ( TYPE_4 . TYPE_5 . METHOD_3 ( ) ) || VAR_1 . METHOD_2 ( TYPE_4 . TYPE_6 . METHOD_3 ( ) ) ) && ! new File ( file . VAR_2 ( ) , <START> VAR_1 . substring ( 0 , VAR_1 . METHOD_4 ( STRING_2 ) + 1 ) <END> + TYPE_4 . TYPE_7 . METHOD_3 ( ) ) . exists ( ) ; } 
public boolean METHOD_1 ( String line , int VAR_1 ) { if ( VAR_1 == 0 ) { TYPE_1 m = VAR_2 . matcher ( line ) ; if ( m . VAR_3 ( ) ) { <START> matcher = m ; <END> return true ; } } matcher = null ; return false ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { boolean VAR_4 = false ; if ( null != VAR_3 ) { TYPE_1 VAR_5 = VAR_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; if <START> ( null != VAR_3 && <END> VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . contains ( VAR_5 ) ) { VAR_4 = true ; } } return VAR_4 ; } 
<START> public TYPE_1 <END> METHOD_1 ( int type , byte [ ] data , int VAR_1 , int VAR_2 , boolean VAR_3 ) throws IOException { TYPE_1 id = METHOD_2 ( type , data , VAR_1 , VAR_2 ) ; if ( ! VAR_3 && db . VAR_4 ( id ) ) { return id ; } else { File VAR_5 = METHOD_3 ( type , data , VAR_1 , VAR_2 ) ; return METHOD_4 ( VAR_5 , id , VAR_3 ) ; } } 
<START> protected String METHOD_1 ( ) { <END> return STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 ; } 
public void METHOD_1 ( TYPE_1 e ) { if ( this . VAR_1 ) { if ( ! e . VAR_2 . METHOD_2 ( ) && ! commit ( TYPE_3 . NONE , true ) ) { if ( e . VAR_2 instanceof TYPE_2 <START> && ! e . VAR_2 . METHOD_2 ( ) ) { <END> ( ( TYPE_2 ) e . VAR_2 ) . METHOD_3 ( ) ; } } else { if ( ! TYPE_4 . this . parent . VAR_5 ( ) ) TYPE_4 . VAR_6 . parent . VAR_7 ( ) ; } } } 
public void METHOD_1 ( TYPE_1 e ) { <START> if ( this . VAR_1 && ! e . VAR_2 . METHOD_2 ( ) ) { <END> if ( ! commit ( TYPE_3 . NONE , true ) ) { if ( e . VAR_2 instanceof TYPE_2 && ! e . VAR_2 . METHOD_2 ( ) ) { ( ( TYPE_2 ) e . VAR_2 ) . METHOD_3 ( ) ; } } else { if ( ! TYPE_4 . this . parent . VAR_5 ( ) ) TYPE_4 . VAR_6 . parent . VAR_7 ( ) ; } } } 
<START> public boolean METHOD_1 ( ) { <END> for ( TYPE_1 VAR_1 : VAR_2 ) { if ( ! VAR_1 . METHOD_1 ( ) ) { return false ; } } return true ; } 
<START> public boolean METHOD_1 ( ) { <END> for ( TYPE_1 VAR_1 : VAR_2 ) { if ( VAR_1 . METHOD_1 ( ) ) { return true ; } } return false ; } 
public Object [ ] METHOD_1 ( Object VAR_1 ) { if ( VAR_1 instanceof TYPE_1 ) { return METHOD_2 ( VAR_1 ) ; } <START> if ( VAR_1 instanceof String ) { <END> return new Object [ ] { VAR_1 } ; } return VAR_2 ; } 
public Object METHOD_1 ( Object element ) { if ( element instanceof TYPE_1 ) { return ( ( TYPE_1 ) element ) . METHOD_1 ( ) ; } <START> return VAR_1 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 . METHOD_2 ( ) , VAR_3 , VAR_4 , STRING_1 ) ; try { TYPE_2 VAR_5 = VAR_1 . call ( ) ; <START> System . out . println ( VAR_5 ) ; <END> } catch ( TYPE_3 e ) { e . VAR_6 ( ) ; } } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; VAR_2 = new TYPE_2 < > ( new TYPE_3 ( VAR_1 ) ) ; repo = VAR_2 . METHOD_2 ( ) ; VAR_3 = repo . VAR_4 ( ) ; VAR_5 = 0 ; VAR_6 = new TYPE_4 ( ) { @Override public long METHOD_3 ( ) { <START> return super . METHOD_3 ( ) + VAR_5 ++ ; <END> } } ; TYPE_5 . METHOD_4 ( VAR_6 ) ; } 
public boolean METHOD_1 ( Collection < ? > c ) { for ( Object <START> name : <END> c ) if ( ! VAR_1 . contains ( TYPE_1 . METHOD_2 ( name ) ) ) return false ; return true ; } 
public boolean METHOD_1 ( Collection < ? > c ) { boolean VAR_1 = false ; for ( Object <START> name : <END> c ) VAR_1 |= remove ( name ) ; return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 group , TYPE_2 info ) { Object [ ] VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> for ( Object element : VAR_1 ) { <END> TYPE_3 listener = ( TYPE_3 ) element ; if ( METHOD_3 ( info . VAR_3 ( ) , listener . VAR_4 ( ) ) ) continue ; if ( listener . VAR_4 ( ) || group . VAR_5 ( ) ) listener . VAR_6 ( group ) ; else listener . VAR_7 ( group ) ; } } 
public void METHOD_1 ( TYPE_1 info ) { Object [ ] VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> for ( Object element : VAR_1 ) { <END> ( ( TYPE_2 ) element ) . METHOD_1 ( info ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; Object [ ] VAR_1 = VAR_2 . METHOD_3 ( ) ; <START> for ( Object element : VAR_1 ) { <END> ( ( TYPE_1 ) element ) . METHOD_1 ( ) ; } } 
public void METHOD_1 ( TYPE_1 info ) { TYPE_2 job = info . VAR_1 ( ) ; VAR_2 . remove ( job ) ; VAR_3 . remove ( job ) ; Object [ ] VAR_4 = VAR_5 . METHOD_2 ( ) ; <START> for ( Object element : VAR_4 ) { <END> TYPE_3 listener = ( TYPE_3 ) element ; if ( ! METHOD_3 ( info . VAR_1 ( ) , listener . VAR_6 ( ) ) ) { listener . VAR_7 ( info ) ; } } } 
public void METHOD_1 ( TYPE_1 group ) { Object [ ] VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> for ( Object element : VAR_1 ) { <END> ( ( TYPE_2 ) element ) . METHOD_1 ( group ) ; } } 
protected void METHOD_1 ( Object VAR_1 ) { TYPE_1 [ ] VAR_2 = VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) ; for ( TYPE_1 element : VAR_2 ) { <START> TYPE_1 item = element ; <END> if ( ! ( item . VAR_4 ( ) . equals ( VAR_1 ) ) ) item . VAR_5 ( false ) ; } } 
protected void METHOD_1 ( Object input , Object VAR_1 ) { VAR_2 . clear ( ) ; Object [ ] VAR_3 = METHOD_2 ( METHOD_3 ( ) ) ; list . VAR_4 ( ) ; for ( Object <START> element : <END> VAR_3 ) { VAR_2 . add ( element ) ; METHOD_4 ( element , list ) ; } list . VAR_5 ( VAR_3 ) ; } 
public final void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { VAR_2 = VAR_1 ; VAR_3 = 0 ; for ( TYPE_1 <START> element : <END> VAR_1 ) { element . VAR_4 ( ( source , VAR_5 ) - > METHOD_2 ( VAR_5 ) ) ; } METHOD_3 ( ) ; } 
public void METHOD_1 ( boolean VAR_1 , TYPE_1 parent ) { super . METHOD_1 ( VAR_1 , parent ) ; group . VAR_2 ( VAR_1 ) ; for ( TYPE_2 <START> element : <END> group . VAR_3 ( ) ) { element . VAR_2 ( VAR_1 ) ; } } 
public TYPE_1 [ ] METHOD_1 ( ) { List VAR_1 = new ArrayList ( ) ; TYPE_2 [ ] VAR_2 = TYPE_3 . METHOD_2 ( ) ; if ( VAR_2 != null ) { for ( TYPE_2 VAR_3 : VAR_2 ) { <START> TYPE_4 [ ] VAR_4 = VAR_3 . METHOD_3 ( ) ; <END> for ( TYPE_4 VAR_5 : VAR_4 ) { VAR_1 . add ( new TYPE_1 ( VAR_5 ) ) ; } } } return ( TYPE_1 [ ] ) VAR_1 . METHOD_4 ( new TYPE_1 [ VAR_1 . size ( ) ] ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , SWT . NONE ) ; VAR_1 . METHOD_2 ( ) ; VAR_1 = new TYPE_1 ( VAR_2 , SWT . VAR_3 ) ; VAR_1 . METHOD_2 ( ) ; VAR_1 = new TYPE_1 ( null , SWT . NONE ) ; <START> METHOD_3 ( STRING_1 ) ; <END> } 
protected TYPE_1 [ ] METHOD_1 ( ) { <START> List list <END> = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; return ( TYPE_1 [ ] ) list . VAR_2 ( new TYPE_1 [ list . size ( ) ] ) ; } 
private static < T > List < T > METHOD_1 ( Collection < T > VAR_1 ) { <START> ArrayList < T > result = new ArrayList < > ( ) ; result . addAll ( VAR_1 ) ; <END> Collections . VAR_2 ( result ) ; return result ; } 
private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 , TYPE_2 position , TYPE_3 VAR_2 ) { TYPE_1 VAR_3 = null ; for ( TYPE_1 VAR_4 : VAR_1 ) { <START> System . out . println ( STRING_1 + VAR_4 . METHOD_2 ( ) ) ; <END> if ( VAR_4 . METHOD_2 ( ) . equals ( VAR_2 ) ) { VAR_3 = VAR_4 ; break ; } } assertNotNull ( STRING_2 + position . getName ( ) , VAR_3 ) ; return VAR_3 ; } 
<START> protected void METHOD_1 ( TYPE_1 action ) { <END> boolean VAR_1 = METHOD_2 ( ) ; action . VAR_2 ( VAR_1 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> TYPE_2 view = super . METHOD_2 ( ) ; return ( ( TYPE_3 ) view ) . METHOD_3 ( ) ; } 
public boolean METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; <START> TYPE_2 page = METHOD_3 ( ) ; <END> return VAR_1 . size ( ) > 0 && page != null && TYPE_3 . contains ( page . VAR_2 ( ) ) ; } 
public Object METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; <END> String uri = VAR_2 . METHOD_2 ( ) ; TYPE_3 object = new TYPE_3 ( ) ; object . VAR_3 ( uri ) ; return object ; } 
protected static TYPE_1 METHOD_1 ( TYPE_2 configuration ) { TYPE_3 VAR_1 = new TYPE_4 ( ) ; if ( configuration != null ) { VAR_1 . METHOD_2 ( configuration ) ; } <START> TYPE_1 parser = new <END> TYPE_1 ( VAR_1 ) ; return parser ; } 
protected boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> boolean VAR_2 = super . METHOD_1 ( VAR_1 ) ; return VAR_2 && VAR_1 instanceof TYPE_2 ; <END> } 
<START> private List < TYPE_1 > METHOD_1 ( ) { <END> List < TYPE_1 > VAR_1 = new TYPE_2 < > ( ) ; VAR_1 . addAll ( TYPE_3 . METHOD_2 ( TYPE_3 . get ( ) . METHOD_3 ( ) ) . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ) ; return VAR_1 ; } 
public boolean METHOD_1 ( T VAR_1 ) { try { <START> ANNOTATION_1 ( STRING_1 ) <END> Class < ? > VAR_2 = ( ( Class ) ( ( TYPE_1 ) this . getClass ( ) . METHOD_2 ( ) ) . METHOD_3 ( ) [ 0 ] ) ; return VAR_2 . METHOD_4 ( VAR_1 . getClass ( ) ) ; } catch ( TYPE_2 e ) { return false ; } } 
public synchronized void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { METHOD_2 ( ) . METHOD_1 ( ) ; } <START> ANNOTATION_1 <END> TYPE_1 < TYPE_2 > VAR_1 = METHOD_3 ( ) ; for ( TYPE_2 VAR_2 : VAR_1 ) { VAR_2 . METHOD_1 ( ) ; } VAR_3 . clear ( ) ; super . METHOD_1 ( ) ; } 
<START> protected <END> T METHOD_1 ( ) { if ( VAR_1 ) { return value ; } return METHOD_2 ( ) ; } 
<START> protected void METHOD_1 ( T value ) { <END> if ( this . value != value ) { METHOD_2 ( TYPE_1 . METHOD_3 ( this . value , this . value = value ) ) ; } } 
<START> protected void METHOD_1 ( ) { <END> if ( METHOD_2 ( ) . METHOD_3 ( ) ) { METHOD_4 ( ) ; } else { METHOD_2 ( ) . METHOD_5 ( ( ) - > { if ( VAR_1 && ! VAR_2 ) { METHOD_4 ( ) ; } } ) ; } VAR_1 = true ; super . METHOD_1 ( ) ; } 
private void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> VAR_1 = true ; value = METHOD_3 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; List < String > VAR_3 = VAR_1 . METHOD_3 ( STRING_1 ) . METHOD_4 ( ) ; <START> assertEquals ( STRING_2 , 3 , VAR_3 . size ( ) ) ; <END> METHOD_5 ( STRING_3 , VAR_4 , VAR_3 . METHOD_6 ( ) ) ; } 
private boolean METHOD_1 ( Set < TYPE_1 < ? > > VAR_1 , TYPE_1 < ? > VAR_2 ) { for ( TYPE_1 < ? > next : this . VAR_3 ) { if <START> ( VAR_1 . contains ( next ) ) { <END> continue ; } VAR_1 . add ( next ) ; if ( next . equals ( VAR_2 ) ) { return true ; } if ( next . VAR_4 ( VAR_1 , VAR_2 ) ) { return true ; } } return false ; } 
public Map < String , String > METHOD_1 ( String VAR_1 ) throws IOException { <START> HashMap < String , <END> String > map = new HashMap < > ( ) ; map . put ( VAR_1 + STRING_1 , METHOD_2 ( STRING_2 ) ) ; map . put ( VAR_1 + STRING_3 , METHOD_2 ( STRING_4 ) ) ; return map ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 , IOException { <START> if ( VAR_2 == null ) { throw new IllegalStateException ( STRING_1 ) ; } <END> String key = VAR_1 . toString ( ) ; if ( ! VAR_2 . containsKey ( key ) ) { throw new IllegalStateException ( STRING_2 + key ) ; } String VAR_3 = VAR_2 . get ( key ) ; return new TYPE_4 ( VAR_3 ) ; } 
public <START> HashMap < String , <END> String > METHOD_1 ( String VAR_1 ) throws IOException { HashMap < String , String > map = new HashMap < String , String > ( ) ; map . put ( VAR_1 + STRING_1 , METHOD_2 ( STRING_2 ) ) ; map . put ( VAR_1 + STRING_3 , METHOD_2 ( STRING_4 ) ) ; return map ; } 
private void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 VAR_2 = METHOD_3 ( ) ; for ( String VAR_3 : VAR_1 . METHOD_4 ( ) ) { VAR_4 = VAR_2 . METHOD_5 ( new File ( VAR_3 ) ) ; if ( ! TYPE_3 . METHOD_6 ( VAR_4 ) ) { <START> break ; <END> } TYPE_4 VAR_5 = METHOD_7 ( ) ; if ( VAR_5 != null ) { return ; } } VAR_4 = null ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 request ) { <START> TYPE_1 VAR_1 = super . METHOD_1 ( request ) ; <END> if ( request . VAR_2 ( ) . METHOD_2 ( ) ) { return TYPE_3 . VAR_4 ; } return VAR_1 ; } 
public boolean METHOD_1 ( Object VAR_1 ) { Object element ; TYPE_1 path ; if ( VAR_1 instanceof TYPE_1 ) { path = ( TYPE_1 ) VAR_1 ; element = path . VAR_2 ( ) ; } else { element = VAR_1 ; <START> path = null ; <END> } TYPE_2 VAR_3 = METHOD_2 ( ) ; if ( VAR_3 instanceof TYPE_3 ) { TYPE_3 VAR_4 = ( TYPE_3 ) VAR_3 ; return VAR_4 . METHOD_3 ( element ) ; } return false ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 parent ) { super . METHOD_1 ( parent ) ; <START> String name = METHOD_2 ( ) . METHOD_3 ( ) ; <END> if ( name != null ) { VAR_1 . METHOD_4 ( name ) ; } METHOD_5 ( ) ; } 
public static <START> synchronized TYPE_1 <END> getInstance ( ) { return container ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , Collection < String > VAR_2 , StringBuilder sb ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; String VAR_4 = TYPE_3 . getInstance ( ) . METHOD_3 ( VAR_1 ) ; <START> if ( VAR_3 != null ) { if ( VAR_3 instanceof TYPE_4 ) { <END> VAR_4 = ( ( TYPE_4 ) VAR_3 ) . getName ( ) ; } } METHOD_4 ( sb , VAR_4 , VAR_5 ) ; return ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , Collection < String > VAR_2 , StringBuilder sb ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; String VAR_4 = TYPE_3 . getInstance ( ) . METHOD_3 ( VAR_1 ) ; if ( VAR_3 != null ) { <START> try { VAR_4 = ( ( TYPE_4 ) VAR_3 ) . getName ( ) ; } catch ( TYPE_5 e ) { } <END> } METHOD_4 ( sb , VAR_4 , VAR_5 ) ; return ; } 
public long METHOD_1 ( ) { return <START> 0 ; <END> } 
public void METHOD_1 ( TYPE_1 model ) { <START> for ( TYPE_1 e : VAR_1 ) { model . VAR_2 ( e ) ; } <END> VAR_1 . add ( model ) ; } 
protected Map < String , TYPE_1 > METHOD_1 ( String VAR_1 ) { Map < String , TYPE_1 > VAR_2 = new TYPE_2 < > ( ) ; for ( TYPE_1 VAR_3 : TYPE_3 . METHOD_2 ( ) ) { if ( ! VAR_3 . METHOD_3 ( ) && ( VAR_3 . METHOD_4 ( ) || <START> ( VAR_1 != null && <END> VAR_3 . METHOD_5 ( ) . equals ( VAR_1 ) ) ) ) { VAR_2 . put ( VAR_3 . METHOD_6 ( ) , VAR_3 ) ; } } return VAR_2 ; } 
<START> private TYPE_1 <END> METHOD_1 ( TYPE_2 id ) throws TYPE_3 , IOException , TYPE_4 { if ( id instanceof TYPE_1 ) { return ( TYPE_1 ) id ; } try ( TYPE_5 VAR_1 = new TYPE_5 ( this ) ) { return VAR_1 . METHOD_1 ( id ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_1 , TYPE_2 . of ( TYPE_3 . VAR_3 ) ) ; <END> VAR_4 . METHOD_3 ( VAR_5 ) ; if ( VAR_1 . METHOD_4 ( ) ) { VAR_4 . METHOD_3 ( VAR_6 ) ; } else { VAR_4 . METHOD_5 ( ) ; VAR_4 . METHOD_6 ( ) ; VAR_1 . METHOD_7 ( ) . METHOD_8 ( VAR_7 ) ; VAR_4 . METHOD_9 ( ) ; } VAR_4 . METHOD_3 ( CHAR_1 ) ; METHOD_10 ( VAR_1 . METHOD_11 ( ) , true ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 config ) { TYPE_3 VAR_1 = config . VAR_2 ( <START> TYPE_5 . VAR_4 , null , <END> TYPE_5 . VAR_5 , TYPE_3 . VAR_6 ) ; return new TYPE_1 ( TYPE_4 . METHOD_2 ( VAR_1 ) ) ; } 
public synchronized TYPE_1 [ ] METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = VAR_2 . METHOD_2 ( location , VAR_3 - > { TYPE_1 [ ] VAR_4 = <START> METHOD_3 ( ) ; <END> return VAR_4 . length > 0 ? VAR_4 : VAR_5 ; } ) ; } return VAR_1 ; } 
<START> protected TYPE_1 <END> METHOD_1 ( TYPE_2 VAR_1 , String key , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = null ; if ( VAR_1 . contains ( key ) ) { if ( VAR_1 . METHOD_2 ( key ) ) VAR_3 = TYPE_5 . METHOD_3 ( VAR_1 , key ) ; else VAR_3 = TYPE_5 . METHOD_4 ( VAR_1 , key ) ; if ( VAR_3 != null ) return new TYPE_1 ( VAR_2 , VAR_3 ) ; } return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if <START> ( ( VAR_1 . METHOD_2 ( TYPE_2 . class ) <END> == TYPE_4 . VAR_3 ) ) { METHOD_3 ( ) ; } else { super . METHOD_1 ( VAR_1 ) ; Object object = VAR_1 . METHOD_4 ( ) ; TYPE_2 VAR_4 = METHOD_5 ( ) ; if ( ( object != null ) && ( VAR_4 != null ) ) { if ( VAR_1 . METHOD_6 ( ) == TYPE_4 . TYPE_3 . VAR_6 ) { METHOD_3 ( ) ; } } } } 
private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 ; if ( VAR_1 == null ) { VAR_1 = db != null ? new TYPE_2 ( db ) : new TYPE_2 ( ) ; } if ( reader != null ) { return new TYPE_1 ( VAR_1 , reader ) ; } final TYPE_3 VAR_3 = db . VAR_4 ( ) ; return new TYPE_1 ( VAR_1 , VAR_3 ) { @Override public void close ( ) { super . close ( ) ; <START> VAR_3 . close ( ) ; <END> } } ; } 
public synchronized void clear ( ) { for ( int i = 0 ; i < this . VAR_1 . length ; i ++ ) { <START> final TYPE_1 <END> VAR_2 = this . VAR_1 [ i ] ; if ( VAR_2 == null ) { continue ; } VAR_2 . VAR_3 = - 1 ; VAR_2 . VAR_4 . METHOD_1 ( VAR_2 ) ; this . VAR_1 [ i ] = null ; } this . VAR_5 = false ; this . VAR_6 = 0 ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_1 . size ( ) == 1 ) { <END> return ( TYPE_1 ) VAR_1 . METHOD_3 ( ) ; } return null ; } 
<START> public static <END> TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) ; TYPE_1 VAR_2 = VAR_1 . get ( TYPE_6 . VAR_4 ) ; if ( VAR_2 == null ) { return TYPE_4 . METHOD_3 ( TYPE_5 . METHOD_4 ( ) ) ; } return VAR_2 ; } 
private void METHOD_1 ( ) { project = ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; if ( project == null ) { throw new RuntimeException ( <START> TYPE_4 . VAR_2 + STRING_1 + METHOD_2 ( ) . toString ( ) ) ; <END> } METHOD_4 ( ) ; METHOD_5 ( Messages . TYPE_3 ) ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> VAR_1 . METHOD_1 ( ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 = true ; <START> TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; <END> } 
public void METHOD_1 ( ) { if <START> ( ! VAR_1 . METHOD_2 ( ) ) <END> { VAR_1 . METHOD_3 ( false ) ; } if ( ! VAR_2 . METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( false ) ; } } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = TYPE_2 . TYPE_6 . METHOD_2 ( ) ; <START> METHOD_3 ( VAR_1 instanceof TYPE_4 ) ; <END> TYPE_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , new String [ ] { STRING_1 } , TYPE_5 . METHOD_6 ( ) . name ( ) ) ; } 
<START> protected TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { <END> final TYPE_1 VAR_2 = TYPE_3 . create ( STRING_1 ) ; VAR_2 . set ( TYPE_2 . class , VAR_1 ) ; return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { VAR_2 = null ; if ( VAR_3 != null ) <START> VAR_3 . METHOD_2 ( ) ; <END> super . METHOD_1 ( VAR_1 ) ; } 
public TYPE_5 ( ANNOTATION_1 TYPE_1 VAR_2 ) { super ( VAR_2 ) ; METHOD_1 ( TYPE_2 . format ( Messages . TYPE_3 , VAR_2 . METHOD_2 ( ) . getName ( ) ) ) ; METHOD_3 ( true ) ; <START> METHOD_4 ( TYPE_2 . format ( Messages . TYPE_4 , STRING_1 , VAR_2 . METHOD_2 ( ) . getName ( ) ) ) ; <END> } 
protected boolean METHOD_1 ( TYPE_1 event ) { if ( ! ( event instanceof TYPE_2 ) ) { return false ; } Object VAR_1 = TYPE_3 . METHOD_2 ( event . VAR_2 ( ) , TYPE_4 . class , event ) ; if ( ! ( VAR_1 <START> instanceof <END> TYPE_5 ) ) { return false ; } return true ; } 
public boolean METHOD_1 ( Object VAR_1 ) { TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; if <START> ( VAR_2 != null && <END> VAR_2 instanceof TYPE_3 ) { return TYPE_4 . METHOD_3 ( ( TYPE_3 ) VAR_2 ) ; } return false ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ; TYPE_3 t = TYPE_3 . getInstance ( ) ; String text = METHOD_4 ( ( TYPE_4 ) VAR_1 . METHOD_5 ( ) ) ; if ( text == null ) { <START> return ; <END> } else { VAR_2 . METHOD_6 ( new Object [ ] { text } , new TYPE_5 [ ] { t } ) ; } VAR_2 . METHOD_7 ( ) ; } 
public TYPE_1 ( ) { <START> super ( ) ; this . VAR_2 = true ; <END> } 
private String METHOD_1 ( String location ) { final String [ ] VAR_1 = location . split ( VAR_2 ) ; return ( location . VAR_3 ( VAR_4 ) ) <START> ? VAR_1 [ 4 ] . substring ( 0 , <END> VAR_1 [ 4 ] . length ( ) - 4 ) : VAR_1 [ 4 ] . substring ( 0 ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 , Log logger ) { this . VAR_2 = VAR_2 ; this . logger = logger ; <START> this . VAR_3 = null ; <END> } 
public void METHOD_1 ( ) throws Exception { File VAR_1 = METHOD_2 ( STRING_1 , STRING_2 ) ; TYPE_1 VAR_2 = TYPE_2 . METHOD_3 ( TYPE_2 . METHOD_4 ( VAR_1 ) , null , new TYPE_3 ( ) ) ; Collection < TYPE_4 > VAR_3 = VAR_2 . METHOD_5 ( ) ; for ( TYPE_4 req : VAR_3 ) <START> System . out . println ( STRING_3 + req ) ; <END> METHOD_6 ( VAR_3 , VAR_4 , 0 , 1 , true ) ; assertEquals ( 1 , VAR_3 . size ( ) ) ; } 
public Collection < TYPE_1 > METHOD_1 ( ) { Collection < TYPE_1 > VAR_1 = VAR_2 ; if ( VAR_1 == null ) { TYPE_2 VAR_3 = METHOD_2 ( ) ; if ( VAR_3 == null ) { return <START> TYPE_3 . METHOD_3 ( Collections . VAR_4 ( ) ) ; <END> } VAR_1 = Collections . VAR_5 ( new TYPE_1 ( VAR_3 , VAR_6 , 0 , "" , METHOD_4 ( ) , new TYPE_1 . TYPE_5 ( 1 ) ) ) ; VAR_2 = VAR_1 ; } return VAR_1 ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 job = super . METHOD_1 ( ) ; job . VAR_1 ( new TYPE_2 ( ) { @Override public void METHOD_2 ( TYPE_3 event ) { TYPE_4 VAR_2 = METHOD_3 ( ) ; if ( VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) { return ; } VAR_2 . METHOD_6 ( ) ; <START> VAR_2 . METHOD_7 ( METHOD_8 ( ) ) ; <END> METHOD_9 ( ) ; } } ) ; return job ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( ) . METHOD_2 ( ) ; TYPE_1 VAR_2 = METHOD_3 ( TYPE_3 . METHOD_4 ( TYPE_4 . VAR_4 + STRING_1 + VAR_5 , true ) , true ) ; assertTrue ( STRING_2 , <START> VAR_2 == null || <END> VAR_1 . METHOD_5 ( VAR_2 ) > 0 ) ; } 
private static boolean METHOD_1 ( ) { boolean isEmpty = VAR_1 . METHOD_2 ( ) . isEmpty ( ) || VAR_2 . METHOD_2 ( ) . isEmpty ( ) ; return METHOD_3 ( ) && VAR_3 . METHOD_4 ( VAR_4 ) <= 0 && <START> ! isEmpty ; <END> } 
public ANNOTATION_1 T METHOD_1 ( TYPE_1 event ) { for ( TYPE_2 < ? > VAR_1 : VAR_2 ) { Object VAR_3 = VAR_1 . METHOD_1 ( event ) ; if ( VAR_3 != null && <START> VAR_3 . getClass ( ) . METHOD_2 ( VAR_4 . getClass ( ) ) ) { <END> return ( T ) VAR_3 ; } } return null ; } 
public static TYPE_1 < TYPE_2 < ? > > METHOD_1 ( TYPE_3 trace , Class < ? extends TYPE_2 < ? > > VAR_1 ) { <START> return TYPE_4 . stream ( TYPE_5 . METHOD_2 ( trace . VAR_2 ( ) , VAR_3 ) . METHOD_3 ( ) , false ) . filter ( VAR_4 - > VAR_1 . METHOD_4 ( VAR_4 . getClass ( ) ) ) . collect ( Collectors . VAR_5 ( ) ) ; <END> } 
public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; <START> int result = 1 ; <END> result = VAR_1 * result + ( ( resource == null ) ? 0 : resource . VAR_2 ( ) ) ; return result ; } 
<START> int METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <END> int VAR_3 ; VAR_3 = VAR_1 . VAR_2 - VAR_2 ; if ( VAR_2 - VAR_3 < 0 ) { return VAR_1 . VAR_2 ; } else { return VAR_2 ; } } 
<START> private void METHOD_1 ( ) { <END> for ( TYPE_1 VAR_1 : VAR_2 ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( VAR_3 == null ) { continue ; } for ( Integer VAR_4 : VAR_5 ) { METHOD_3 ( METHOD_4 ( VAR_3 , VAR_4 ) ) ; } } VAR_5 . clear ( ) ; } 
public void METHOD_1 ( ANNOTATION_1 Set < ANNOTATION_1 Integer > VAR_1 ) { METHOD_2 ( ) ; METHOD_3 ( ) ; <START> VAR_2 . addAll ( VAR_1 ) ; <END> METHOD_4 ( ) ; } 
protected ANNOTATION_1 TYPE_1 METHOD_1 ( TYPE_2 parent ) { TYPE_3 VAR_1 = new TYPE_3 ( parent ) ; VAR_1 . METHOD_2 ( new TYPE_4 ( ) ) ; TYPE_5 trace = TYPE_6 . getInstance ( ) . METHOD_3 ( ) ; if ( trace != null ) { TYPE_7 VAR_2 = new TYPE_7 ( this , trace ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; <START> METHOD_5 ( trace ) ; <END> } return VAR_1 ; } 
private void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( VAR_3 == null ) { continue ; } for ( Integer VAR_4 : VAR_5 ) { <START> METHOD_3 ( METHOD_4 ( VAR_3 , VAR_4 ) ) ; <END> } } VAR_5 = new TYPE_3 < > ( ) ; } 
public static ANNOTATION_1 TYPE_1 create ( TYPE_2 trace , ANNOTATION_1 TYPE_3 VAR_1 ) { if ( VAR_1 == null ) { return null ; } <START> if ( VAR_1 instanceof TYPE_4 ) { ( ( TYPE_4 ) VAR_1 ) . METHOD_1 ( ) ; } return new TYPE_1 ( trace , VAR_1 ) ; <END> } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { List < Integer > VAR_3 = VAR_1 . METHOD_2 ( ) ; <START> for ( Integer VAR_4 : VAR_3 ) { <END> if ( VAR_4 . equals ( VAR_2 ) ) { return true ; } } return false ; } 
protected void METHOD_1 ( String name ) { <START> VAR_1 = ( TYPE_1 ) METHOD_2 ( VAR_2 . METHOD_3 ( ) , VAR_3 + STRING_1 + name , name , TYPE_2 . class ) ; VAR_1 . METHOD_4 ( false ) ; VAR_1 . METHOD_5 ( TYPE_3 . VAR_5 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_2 . length == 0 ) { throw new IllegalStateException ( STRING_1 ) ; } <END> if ( VAR_2 . length != VAR_1 . METHOD_2 ( ) . length ) { throw new IllegalStateException ( STRING_2 + VAR_2 . length ) ; } VAR_3 . put ( VAR_1 . METHOD_3 ( ) , VAR_1 ) ; VAR_4 = null ; return this ; } 
public long METHOD_1 ( ) { return <START> VAR_1 [ VAR_1 . length ] ; <END> } 
public static ANNOTATION_1 TYPE_1 create ( TYPE_2 trace ) { TYPE_3 VAR_1 = TYPE_4 . METHOD_1 ( trace , <START> TYPE_3 . class , <END> TYPE_5 . VAR_2 ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; return new TYPE_1 ( trace , VAR_1 ) ; } return null ; } 
public TYPE_1 METHOD_1 ( TYPE_2 filter , ANNOTATION_1 TYPE_3 monitor ) { <START> if ( ! ( filter instanceof TYPE_4 ) ) { return TYPE_5 . METHOD_2 ( TYPE_6 . VAR_2 ) ; } return METHOD_1 ( ( TYPE_4 ) filter , monitor ) ; <END> } 
public boolean METHOD_1 ( String VAR_1 , boolean VAR_2 ) { if ( VAR_1 == null ) { return false ; } VAR_1 = <START> METHOD_2 ( VAR_1 , <END> TYPE_1 . VAR_4 ) ; if ( VAR_1 . length ( ) == 0 ) { return false ; } boolean VAR_5 = matcher . VAR_6 ( VAR_1 , VAR_2 ) ; return VAR_5 ; } 
public void METHOD_1 ( String text ) { <START> System . out . println ( STRING_1 + text ) ; <END> final boolean VAR_1 = TYPE_1 . METHOD_1 ( METHOD_2 ( ) , text ) ; if ( ! VAR_1 ) { METHOD_3 ( ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { VAR_2 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , false ) ; <START> VAR_2 . METHOD_5 ( ) ; <END> } } 
public void METHOD_1 ( ) throws TYPE_1 { long VAR_1 = Long . VAR_2 ; for ( TYPE_2 VAR_3 : VAR_4 ) { VAR_3 . METHOD_1 ( ) ; TYPE_3 VAR_5 = VAR_3 . METHOD_2 ( ) ; if ( VAR_5 != null ) { VAR_1 = Math . max ( VAR_5 . METHOD_3 ( ) , VAR_1 ) ; } } METHOD_4 ( VAR_6 . METHOD_5 ( VAR_1 ) ) ; <START> METHOD_6 ( VAR_6 . METHOD_7 ( METHOD_8 ( ) ) ) ; <END> } 
public Collection < TYPE_1 > METHOD_1 ( ) { Collection < TYPE_1 > result = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_2 VAR_1 : METHOD_2 ( ) ) { for ( TYPE_3 VAR_2 : VAR_1 . METHOD_3 ( ) ) { TYPE_4 view = ( TYPE_4 ) VAR_2 ; TYPE_1 VAR_3 = TYPE_1 . get ( view ) ; <START> if ( ! result . contains ( VAR_3 ) && null != VAR_3 ) { <END> result . add ( VAR_3 ) ; } } } return result ; } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) { <START> if ( VAR_2 != null ) <END> return VAR_2 ; if ( VAR_1 ) { VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( STRING_1 ) ; } else { VAR_2 = new TYPE_3 ( ) ; VAR_2 . METHOD_2 ( STRING_2 ) ; } VAR_2 . METHOD_3 ( true ) ; VAR_2 . METHOD_4 ( this ) ; return VAR_2 ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { return <START> null ; <END> } 
public static List < TYPE_1 > METHOD_1 ( ) { return Arrays . asList ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , <START> VAR_6 , VAR_7 , VAR_8 , VAR_9 , <END> VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = Collections . VAR_3 ( VAR_4 , VAR_1 , VAR_5 ) ; if ( VAR_2 < 0 ) { VAR_4 . add ( - VAR_2 - 1 , VAR_1 ) ; } else { <START> VAR_4 . add ( VAR_1 ) ; <END> } } 
private void METHOD_1 ( ) { int VAR_1 = TYPE_1 . METHOD_2 ( ) ; TYPE_2 VAR_2 = METHOD_3 ( ) ; if ( VAR_1 >= VAR_2 . METHOD_4 ( ) ) { return ; } int VAR_3 = 0 ; TYPE_3 VAR_4 = METHOD_5 ( ) ; TYPE_4 [ ] VAR_5 = VAR_2 . METHOD_6 ( ) ; <START> for ( TYPE_4 VAR_6 : VAR_5 ) { <END> TYPE_4 query = VAR_6 ; if ( ! VAR_4 . METHOD_7 ( query ) ) { if ( ++ VAR_3 >= VAR_1 ) { METHOD_8 ( query ) ; } } } } 
public boolean METHOD_1 ( String VAR_1 ) { if <START> ( TYPE_2 . TYPE_3 . equals ( VAR_1 ) ) { <END> return true ; } return false ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , long t , int VAR_2 , long VAR_3 ) { <START> ANNOTATION_1 <END> Object VAR_4 = VAR_1 . METHOD_2 ( VAR_2 ) ; long VAR_5 = 0 ; if ( VAR_4 != null && VAR_4 instanceof Long ) { VAR_5 = ( long ) VAR_4 ; } VAR_1 . METHOD_3 ( t , VAR_5 + VAR_3 , VAR_2 ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , long t , int VAR_2 , int VAR_3 ) throws TYPE_2 , TYPE_3 { Object VAR_4 = VAR_1 . METHOD_2 ( VAR_2 ) ; int VAR_5 = 0 ; if <START> ( VAR_4 != null && VAR_4 <END> instanceof Integer ) { VAR_5 = ( int ) VAR_4 ; } VAR_1 . METHOD_3 ( t , VAR_5 + VAR_3 , VAR_2 ) ; } 
<START> public void <END> METHOD_1 ( boolean VAR_1 ) { this . VAR_1 = VAR_1 ; } 
public boolean METHOD_1 ( final TYPE_1 table , final Object VAR_1 ) { <START> final String id = TYPE_2 . METHOD_2 ( VAR_1 ) ; return ( null != id && id . equals ( TYPE_3 ) ) ; <END> } 
protected boolean METHOD_1 ( TYPE_1 cmd ) { return cmd . VAR_1 ( ) != null ? <START> cmd . VAR_1 ( ) . METHOD_2 ( ) <END> : METHOD_1 ( ) ; } 
public <START> TYPE_1 METHOD_1 ( TYPE_1 <END> VAR_1 ) { TYPE_1 VAR_2 = VAR_3 ; VAR_3 = VAR_1 ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( long VAR_1 ) { Entry < Long , TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { return null ; } TYPE_1 VAR_4 = VAR_2 . getValue ( ) ; long VAR_5 = VAR_4 . METHOD_3 ( ) ; <START> if ( VAR_4 . METHOD_4 ( ) . METHOD_5 ( METHOD_6 ( ) ) && VAR_5 != VAR_1 ) { return null ; } return VAR_4 ; <END> } 
public TYPE_2 ( TYPE_1 name ) { this . name = name ; <START> this . VAR_2 = false ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 info ) { if ( map == null ) { return null ; } TYPE_1 VAR_1 = ( TYPE_1 ) map . remove ( info ) ; if ( VAR_1 != <START> null ) <END> VAR_1 . METHOD_2 ( TYPE_3 . VAR_3 , Boolean . VAR_4 ) ; return VAR_1 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { assert METHOD_2 ( VAR_1 ) ; String VAR_2 = VAR_1 . METHOD_3 ( ) ; boolean VAR_3 = VAR_2 != null && VAR_2 . contains ( STRING_1 ) ; <START> return VAR_3 ; <END> } 
private synchronized void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { METHOD_2 ( ) ; if ( METHOD_3 ( ) . METHOD_4 ( ) ) { return ; } int VAR_2 = VAR_3 != 0 ? VAR_3 : <START> ( int ) Math . VAR_4 ( METHOD_5 ( ) - METHOD_6 ( ) + 1 , ( long ) ( METHOD_3 ( ) . METHOD_7 ( ) . METHOD_8 ( ) . VAR_5 <END> * VAR_6 ) ) ; VAR_7 = new TYPE_2 ( VAR_2 , VAR_1 ) ; VAR_7 . start ( ) ; } 
protected void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> System . out . println ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( 0 , 0 ) . METHOD_5 ( ) . toString ( ) ) ; <END> VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_6 ( 0 , 0 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { if ( VAR_2 . size ( ) == 1 ) { return VAR_2 . get ( 0 ) . METHOD_1 ( VAR_1 ) ; } List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_2 VAR_4 : VAR_2 ) { TYPE_1 VAR_5 = VAR_4 . METHOD_1 ( VAR_1 ) ; if ( VAR_5 != null ) { VAR_3 . add ( VAR_5 ) ; } } <START> return new TYPE_3 ( VAR_3 ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_2 parent ) { <START> return new TYPE_3 ( parent , new TYPE_4 ( null , null , null , 1 ) , VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 trace ) { METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> super . METHOD_1 ( trace ) ; METHOD_4 ( ) ; } 
<START> private void METHOD_1 ( ) { <END> if ( VAR_1 . METHOD_2 ( ) ) { VAR_2 = METHOD_3 ( VAR_3 ) ; METHOD_4 ( VAR_2 , false ) ; } } 
public List < TYPE_1 > METHOD_1 ( Collection < String > VAR_1 , Collection < TYPE_2 > VAR_2 , TYPE_3 set ) { <START> List < TYPE_1 > VAR_3 = null ; <END> for ( TYPE_4 listener : VAR_4 ) { VAR_3 = listener . VAR_5 ( VAR_1 , VAR_2 , set ) ; } return VAR_3 ; } 
boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 < ? > parent = VAR_1 . METHOD_2 ( ) ; if ( parent == null ) { TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( VAR_2 == null ) { return false ; } parent = VAR_2 . METHOD_2 ( ) ; return parent instanceof TYPE_4 ? parent . VAR_3 ( ) == VAR_2 : parent != null ; } <START> return parent instanceof TYPE_4 ? parent . VAR_3 ( ) == VAR_1 <END> : true ; } 
protected void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; <START> TYPE_3 VAR_1 = METHOD_4 ( ) ; if ( VAR_1 . exists ( ) ) { VAR_1 . METHOD_5 ( true , null ) ; } <END> METHOD_6 ( VAR_2 ) ; VAR_3 . clear ( ) ; TYPE_4 . METHOD_7 ( VAR_3 ) ; super . METHOD_1 ( ) ; } 
public <START> synchronized TYPE_1 <END> METHOD_1 ( TYPE_2 config ) { synchronized ( VAR_1 ) { if ( VAR_2 != null && METHOD_2 ( ) ) return VAR_2 . get ( config ) ; return builder ; } } 
public boolean METHOD_1 ( TYPE_1 object , TYPE_2 VAR_1 ) { Object VAR_2 = METHOD_2 ( object . VAR_3 ( ) ) ; if ( ! METHOD_3 ( VAR_2 , <START> VAR_1 ) ) <END> { return false ; } final Set < TYPE_1 > VAR_4 = VAR_5 . METHOD_4 ( VAR_2 ) ; return VAR_4 != null && VAR_4 . contains ( object ) ; } 
<START> public void <END> METHOD_1 ( ) { for ( TYPE_1 listener : VAR_1 ) { listener . VAR_2 ( ) ; } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 filter ) { VAR_1 . METHOD_1 ( filter ) ; METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 event ) { String VAR_1 = event . VAR_2 ( ) . METHOD_2 ( String . VAR_3 , TYPE_2 . VAR_5 ) ; <START> return STRING_1 == VAR_1 || VAR_1 == STRING_2 ; <END> } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( ! ( obj instanceof TYPE_1 ) ) return false ; final TYPE_1 VAR_1 = ( TYPE_1 ) obj ; <START> if ( VAR_2 != VAR_1 . METHOD_1 ( ) ) <END> return false ; return METHOD_2 ( VAR_1 ) ; } 
public boolean hasNext ( ) { if ( VAR_1 ) { return true ; } if ( VAR_2 == null ) { return false ; } try { boolean VAR_3 = VAR_2 . execute ( VAR_4 ) ; while ( ( ! VAR_3 ) && VAR_5 . hasNext ( ) ) { VAR_3 = METHOD_1 ( ) && VAR_2 . execute ( VAR_4 ) ; } <START> if ( VAR_3 ) { <END> VAR_1 = true ; } return VAR_3 ; } catch ( TYPE_1 e ) { throw new RuntimeException ( e ) ; } } 
protected void METHOD_1 ( TYPE_1 e ) { TYPE_2 [ ] VAR_1 = VAR_2 . METHOD_2 ( TYPE_3 . class ) ; <START> if ( VAR_1 != null && VAR_1 . length > 0 ) { <END> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { ( ( TYPE_3 ) VAR_1 [ i ] ) . METHOD_3 ( e ) ; } } } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) { <END> throw new IllegalStateException ( STRING_1 ) ; } VAR_1 = new TYPE_1 ( ) ; METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; } 
protected boolean METHOD_1 ( TYPE_1 model ) { <START> if ( VAR_1 == null ) { return false ; } if ( model == null ) { return true ; } if ( model != VAR_1 ) { } return false ; <END> } 
public TYPE_1 ( long start , long VAR_2 , int n , Collection < Long > VAR_3 , boolean VAR_4 ) { <START> super ( start , VAR_2 , n , ImmutableList . VAR_5 ( VAR_3 ) ) ; <END> VAR_6 = VAR_4 ; } 
<START> private byte [ ] METHOD_1 ( int size , int VAR_1 ) { <END> byte [ ] data = new byte [ size ] ; for ( int i = 0 ; i < data . length ; i ++ ) { data [ i ] = ( byte ) ( ( i % INT_1 == 0 ) ? CHAR_1 : ( i % 10 ) + CHAR_2 ) ; } if ( VAR_1 >= 0 ) { data [ VAR_1 ] = CHAR_3 ; } return data ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < TYPE_3 > VAR_2 ) { <START> if ( VAR_1 instanceof TYPE_4 ) { <END> } else if ( VAR_1 instanceof TYPE_5 ) { TYPE_6 VAR_3 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; if ( VAR_3 != null ) { VAR_2 . METHOD_4 ( TYPE_7 . create ( VAR_3 , VAR_1 , METHOD_5 ( ( TYPE_5 ) VAR_1 ) ) ) ; } return false ; } return super . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
public Collection < TYPE_1 > get ( TYPE_1 VAR_1 ) { Object VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 instanceof TYPE_2 < ? > ) { <START> return ( Collection < TYPE_1 > ) VAR_2 ; <END> } else { if ( VAR_2 == null ) return null ; return Collections . VAR_4 ( ( TYPE_1 ) VAR_2 ) ; } } 
TYPE_1 METHOD_1 ( ) { <START> return ( TYPE_1 ) VAR_1 . get ( TYPE_2 . class ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return METHOD_2 ( ( ) - > this . VAR_1 . METHOD_1 ( ) ) ; } 
<START> static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> return TYPE_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } 
<START> static < TYPE_1 , TYPE_2 , TYPE_3 > TYPE_3 put ( Map < TYPE_1 , Map < TYPE_2 , TYPE_3 > > VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 value ) { <END> Map < TYPE_2 , TYPE_3 > map = VAR_1 . get ( VAR_2 ) ; if ( map == null ) { map = TYPE_4 . METHOD_1 ( ) ; VAR_1 . put ( VAR_2 , map ) ; } return map . put ( VAR_3 , value ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_2 . METHOD_2 ( VAR_1 . VAR_3 ) ; if ( VAR_1 . VAR_4 != null ) { for ( TYPE_3 . TYPE_4 req : VAR_1 . VAR_4 ) { if ( req == null || req . VAR_3 == null || req . VAR_3 == TYPE_5 . VAR_6 ) { continue ; <START> } <END> this . VAR_2 . METHOD_3 ( req . VAR_3 ) ; } } METHOD_4 ( VAR_1 . VAR_7 ) ; METHOD_4 ( VAR_1 . VAR_8 ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 file , Collection < String > VAR_1 ) throws IOException { final String path = file . VAR_2 ( ) . toString ( ) ; TYPE_1 view = METHOD_1 ( path ) ; if ( ! METHOD_2 ( view ) ) { view = METHOD_3 ( view , path , VAR_1 ) ; if ( METHOD_2 ( view ) ) { <START> return null ; <END> } } return view ; } 
<START> public TYPE_2 ( TYPE_1 <END> VAR_2 ) { this . VAR_2 = VAR_2 ; } 
public static < T extends org . VAR_1 . VAR_2 . VAR_3 . TYPE_6 > org . VAR_5 . TYPE_5 < T > METHOD_1 ( TYPE_2 . TYPE_3 . String key , TYPE_2 . TYPE_3 . String value ) { return org . VAR_1 . VAR_7 . VAR_2 . VAR_8 . VAR_9 . TYPE_4 . METHOD_1 ( key , <START> value ) ; <END> } 
public TYPE_1 METHOD_1 ( String key , Object value ) { TYPE_2 matcher = METHOD_2 ( METHOD_3 ( TYPE_3 . class ) , METHOD_4 ( key , value ) , METHOD_5 ( SWT . VAR_1 , STRING_1 ) ) ; return new TYPE_1 ( ( TYPE_3 ) METHOD_6 ( matcher ) , matcher ) ; <START> } <END> 
private void METHOD_1 ( boolean value ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; VAR_1 . put ( TYPE_2 . VAR_3 , value ) ; if ( value ) { VAR_1 . put ( TYPE_2 . VAR_4 , <START> 100 ) ; <END> } else { VAR_1 . put ( TYPE_2 . VAR_4 , 0 ) ; } } 
public int METHOD_1 ( TYPE_1 o ) { int x = METHOD_2 ( ) . METHOD_1 ( o . VAR_1 ( ) ) ; <START> if ( x != 0 ) { <END> return 0 ; } return ( int ) ( METHOD_3 ( ) - o . VAR_2 ( ) ) ; } 
public static <START> TYPE_1 METHOD_1 ( TYPE_2 <END> db , TYPE_3 VAR_1 ) throws IOException { TYPE_1 buffer = new TYPE_6 . TYPE_1 ( null ) ; TYPE_5 f = new TYPE_5 ( db , VAR_1 , buffer ) ; while ( f . run ( ) != - 1 ) { } return buffer ; } 
public TYPE_1 METHOD_1 ( TYPE_2 repo , TYPE_3 outputStream ) { if <START> ( METHOD_2 ( ) && <END> METHOD_3 ( repo ) ) { return new TYPE_4 ( repo , outputStream ) ; } return null ; } 
protected void METHOD_1 ( ) throws Exception { METHOD_2 ( TYPE_2 . VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , <START> VAR_7 ) ; <END> VAR_8 = new TYPE_1 ( VAR_9 , VAR_5 ) ; VAR_10 = VAR_11 . METHOD_3 ( VAR_8 , true ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Map < TYPE_2 , TYPE_3 > VAR_2 = VAR_3 ; if ( VAR_2 == null ) { VAR_2 = new HashMap < > ( ) ; <START> for ( TYPE_3 VAR_4 : VAR_5 ) { <END> TYPE_2 VAR_6 = VAR_4 . METHOD_2 ( ) ; if ( VAR_6 != null ) { VAR_2 . put ( VAR_6 , VAR_4 ) ; } } VAR_3 = VAR_2 ; } if ( VAR_2 . containsKey ( VAR_1 ) ) { return VAR_2 . get ( VAR_1 ) ; } return null ; } 
public TYPE_3 ( ANNOTATION_1 TYPE_1 project , ANNOTATION_2 TYPE_2 VAR_2 ) { this . VAR_3 = project ; this . VAR_4 = new HashSet < > ( ) ; this . VAR_2 = VAR_2 ; this . VAR_5 = VAR_2 . METHOD_1 ( ) ; <START> if ( this . VAR_5 == null ) { <END> throw new IllegalStateException ( Messages . TYPE_4 ) ; } this . VAR_7 = new HashMap < > ( ) ; } 
public TYPE_7 ( TYPE_1 VAR_2 ) { super ( VAR_2 , TYPE_2 . TYPE_4 ) ; <START> VAR_5 = TYPE_2 . TYPE_4 ; <END> VAR_6 = TYPE_2 . TYPE_5 ; VAR_8 = TYPE_2 . TYPE_3 ; VAR_10 = TYPE_2 . TYPE_6 ; METHOD_1 ( ) ; } 
private String METHOD_1 ( String VAR_1 ) { Integer VAR_2 = VAR_3 . METHOD_2 ( ) . get ( VAR_1 ) ; int index = 0 ; String VAR_4 = VAR_1 ; while ( VAR_2 != null ) <START> { VAR_4 = VAR_1 + CHAR_1 + index + CHAR_2 ; VAR_2 = VAR_3 . METHOD_2 ( ) . get ( VAR_4 ) ; <END> } return VAR_4 ; } 
public TYPE_2 ( int VAR_2 , char [ ] value , char [ ] VAR_3 ) { VAR_4 = VAR_2 ; <START> METHOD_1 ( VAR_2 , value ) ; <END> VAR_5 = ( VAR_3 == null ) ? TYPE_1 . VAR_7 : VAR_3 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , this . getValue ( ) ) ; VAR_2 . VAR_4 = <START> VAR_4 . METHOD_2 ( ) ; <END> VAR_2 . VAR_5 = VAR_5 ; VAR_2 . VAR_6 = VAR_6 ; VAR_2 . VAR_7 = VAR_7 ; VAR_2 . VAR_8 = VAR_8 == null ? null : VAR_8 . METHOD_2 ( ) ; return METHOD_1 ( VAR_2 , VAR_1 ) ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 == null || VAR_1 . METHOD_2 ( ) || VAR_2 != null ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 , TYPE_1 . class ) ; VAR_2 . METHOD_3 ( STRING_1 ) . METHOD_4 ( ) ; TYPE_2 . METHOD_5 ( STRING_2 ) ; try { VAR_2 . METHOD_3 ( STRING_1 ) . METHOD_6 ( ) . METHOD_7 ( STRING_3 , 0 ) . METHOD_8 ( ) . METHOD_9 ( VAR_3 ) ; METHOD_10 ( ) ; } catch ( TYPE_3 e ) { <START> assertTrue ( true ) ; <END> } } 
public void METHOD_1 ( TYPE_1 monitor ) { if ( monitor == null ) { <START> monitor = <END> TYPE_2 . VAR_2 ; } this . monitor = monitor ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; <START> VAR_2 . METHOD_2 ( ) ; TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = new TYPE_5 ( VAR_2 , VAR_1 . METHOD_2 ( ) , <START> VAR_1 . METHOD_3 ( ) - VAR_1 . METHOD_2 ( ) ) . METHOD_4 ( ) ; <END> if ( VAR_3 != null ) { TYPE_4 VAR_4 = TYPE_6 . METHOD_5 ( VAR_3 , TYPE_4 . VAR_5 ) ; if ( VAR_4 instanceof TYPE_1 ) { return ( TYPE_1 ) VAR_4 ; } } return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 != null && VAR_1 == null ) { <START> VAR_2 . METHOD_2 ( "" ) ; <END> } VAR_2 = VAR_1 ; } 
public Object METHOD_1 ( String key , Object value ) { if ( METHOD_2 ( ) . containsKey ( key ) ) { <START> final Object VAR_1 = METHOD_2 ( ) . get ( key ) ; <END> METHOD_2 ( ) . METHOD_3 ( key ) ; METHOD_4 ( ) . put ( key , value ) ; return VAR_1 ; } return METHOD_4 ( ) . put ( key , value ) ; } 
public <START> ANNOTATION_1 String <END> METHOD_1 ( ) { return VAR_1 ; } 
<START> public int METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public void METHOD_1 ( int VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
public static synchronized ANNOTATION_1 TYPE_1 <START> create ( TYPE_2 <END> trace , ANNOTATION_1 TYPE_3 VAR_1 ) { if ( VAR_1 == null ) { return null ; } TYPE_1 VAR_2 = TYPE_4 . get ( VAR_1 ) ; if ( VAR_2 != null ) { return VAR_2 ; } if ( VAR_1 instanceof TYPE_5 ) { ( ( TYPE_5 ) VAR_1 ) . METHOD_1 ( ) ; VAR_2 = new TYPE_1 ( trace , VAR_1 ) ; TYPE_4 . put ( VAR_1 , VAR_2 ) ; } return null ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; if ( VAR_2 != null ) { <START> ( ( TYPE_1 ) VAR_2 ) . METHOD_1 ( ) ; <END> } super . METHOD_1 ( ) ; } 
public int METHOD_1 ( String VAR_1 , String VAR_2 ) { String VAR_3 = VAR_4 . get ( VAR_1 ) ; String VAR_5 = VAR_4 . get ( VAR_2 ) ; if ( VAR_3 == null ) { return <START> - 1 ; <END> } if ( VAR_5 == null ) { return 1 ; } return TYPE_1 . getInstance ( ) . METHOD_1 ( VAR_3 , VAR_5 ) ; } 
private static void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( TYPE_5 . TYPE_6 . METHOD_3 ( ) ) ; TYPE_1 . METHOD_2 ( TYPE_5 . TYPE_7 . METHOD_3 ( ) ) ; <START> File VAR_1 = TYPE_1 . METHOD_4 ( ) . METHOD_5 ( ) . append ( TYPE_5 . TYPE_7 . METHOD_3 ( ) . getName ( ) ) . METHOD_6 ( ) ; TYPE_1 . METHOD_7 ( VAR_1 ) ; <END> TYPE_4 . METHOD_8 ( ) ; } 
public static int METHOD_1 ( TYPE_1 entry ) { return Arrays . stream ( entry . VAR_1 ( ) ) <START> . METHOD_2 ( p - > p . getName ( ) . equals ( TYPE_2 . VAR_3 ) && p . getValue ( ) . equals ( STRING_1 ) ) <END> ? TYPE_3 . VAR_5 : TYPE_3 . VAR_6 ; } 
public boolean METHOD_1 ( TYPE_1 target ) { <START> final TYPE_2 VAR_1 = target . VAR_2 ( ) ; <END> return VAR_1 != null && VAR_1 . METHOD_2 ( ) == TYPE_3 . VAR_4 ; } 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return <START> TYPE_2 . equals ( VAR_2 , <END> VAR_1 . VAR_2 ) && TYPE_2 . equals ( VAR_3 , VAR_1 . VAR_3 ) ; } 
protected void METHOD_1 ( ) { boolean VAR_1 = false ; <START> if ( VAR_2 != null ) { <END> VAR_1 = VAR_2 . METHOD_2 ( ) ; } TYPE_1 trace = METHOD_3 ( VAR_3 . METHOD_4 ( ) , VAR_1 ) ; if ( trace == null ) { return ; } METHOD_5 ( new TYPE_1 [ ] { trace } ) ; super . METHOD_1 ( ) ; } 
public TYPE_5 ( TYPE_1 trace , long VAR_2 , TYPE_2 field ) { super ( trace , VAR_2 , TYPE_3 . METHOD_1 ( field . VAR_3 ( ) ) , TYPE_4 . get ( field . getName ( ) ) , field . VAR_4 ( ) ) ; VAR_5 = field ; VAR_6 = field . getName ( ) ; <START> VAR_7 = Level . VAR_8 ; <END> VAR_9 = null ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( Object [ ] parameters ) { <START> return METHOD_2 ( parameters , METHOD_3 ( parameters ) ) . stream ( ) ; <END> } 
<START> private void <END> METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) ) throw new TYPE_2 ( ) ; } 
<START> private TYPE_1 <END> METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 < TYPE_5 > VAR_3 ) throws TYPE_6 { TYPE_7 VAR_4 = TYPE_8 . METHOD_2 ( ) ; for ( Iterator < TYPE_5 > VAR_5 = VAR_3 . iterator ( ) ; VAR_5 . hasNext ( ) ; ) { TYPE_5 type = VAR_5 . next ( ) ; VAR_4 . add ( type ) ; } return TYPE_8 . METHOD_3 ( VAR_4 , VAR_2 , VAR_1 ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) <END> throw new TYPE_2 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { String VAR_1 = VAR_2 . METHOD_2 ( TYPE_4 . TYPE_5 , STRING_1 ) ; <START> try { return TYPE_2 . METHOD_3 ( VAR_1 ) ; } catch ( Exception ex ) { throw new TYPE_3 ( STRING_2 , ex ) ; } <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { String [ ] VAR_2 = VAR_1 . METHOD_2 ( false ) ; if ( VAR_2 . length > 0 ) { <START> StringBuilder msg = new StringBuilder ( STRING_1 + VAR_2 ) ; <END> for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { msg . append ( CHAR_1 + VAR_2 [ i ] ) ; } METHOD_3 ( msg . toString ( ) ) ; } } 
public String getName ( ) { StringBuilder name = new StringBuilder ( ) ; for ( int i = 0 ; i < ( input . length - 1 ) ; i ++ ) { <START> name . append ( input [ i ] . getName ( ) + STRING_1 ) ; <END> } name . append ( input [ input . length - 1 ] . getName ( ) ) ; return name . toString ( ) ; } 
public boolean METHOD_1 ( Object element , boolean state ) { <START> TYPE_1 VAR_1 = VAR_2 ; <END> if ( VAR_1 != null && VAR_1 . METHOD_1 ( element , state ) ) { METHOD_2 ( element , false ) ; return false ; } METHOD_3 ( element , state ) ; return VAR_3 . METHOD_1 ( element , state ) ; } 
private TYPE_7 ( TYPE_1 parent , TYPE_2 VAR_2 , int VAR_3 , String id ) { super ( parent , VAR_2 . METHOD_1 ( ) ) ; TYPE_3 VAR_4 = VAR_2 . METHOD_1 ( ) ; VAR_4 . METHOD_2 ( VAR_5 ) ; if ( VAR_4 instanceof TYPE_4 ) { ( ( TYPE_4 ) VAR_4 ) . METHOD_3 ( new TYPE_5 ( ) ) ; } VAR_6 = VAR_2 ; VAR_7 = VAR_3 ; VAR_8 = id ; <START> VAR_2 . METHOD_4 ( new TYPE_6 ( VAR_2 ) ) ; <END> } 
<START> public boolean METHOD_1 ( ) { <END> return VAR_1 . METHOD_1 ( this ) ; } 
<START> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_2 . METHOD_1 ( VAR_1 ) ; } 
protected final Collection < TYPE_1 > METHOD_1 ( final String VAR_1 ) { final Collection < TYPE_1 > VAR_2 = <START> TYPE_3 . TYPE_4 . METHOD_2 ( session ) . stream ( ) . filter ( VAR_3 - > VAR_3 . getName ( ) . equals ( VAR_1 ) ) <END> . collect ( Collectors . VAR_4 ( ) ) ; return VAR_2 ; } 
public boolean METHOD_1 ( TYPE_1 trace ) { if ( ! ( trace instanceof TYPE_2 ) ) { throw new <START> IllegalStateException ( ) ; <END> } return super . METHOD_1 ( trace ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } 
public static TYPE_1 METHOD_1 ( final File VAR_1 ) throws IOException { try ( TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ) { <START> try { <END> return read ( VAR_2 ) ; } catch ( IOException VAR_3 ) { throw new IOException ( TYPE_3 . format ( TYPE_4 . get ( ) . VAR_4 , VAR_1 . METHOD_2 ( ) ) , VAR_3 ) ; } } } 
public ANNOTATION_1 String METHOD_1 ( String VAR_1 ) { String VAR_2 = <START> null ; <END> if ( VAR_3 != null ) { VAR_2 = VAR_3 . get ( VAR_1 ) ; } if ( VAR_2 == null && VAR_4 != null ) { VAR_2 = VAR_4 . get ( VAR_4 . METHOD_2 ( VAR_1 ) ) ; } return VAR_2 == null ? "" : VAR_2 ; } 
public <START> int METHOD_1 ( ) <END> { return VAR_1 ; } 
private static final TYPE_1 METHOD_1 ( TYPE_2 buffer ) { <START> short VAR_1 = buffer . VAR_2 ( ) ; byte [ ] VAR_3 = new byte [ VAR_1 ] ; buffer . get ( VAR_3 ) ; String host = new String ( VAR_3 , VAR_4 ) ; if ( buffer . get ( ) != 0 ) { throw new IllegalStateException ( STRING_1 ) ; } <END> int VAR_5 = buffer . getInt ( ) ; return new TYPE_1 ( host , VAR_5 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = <START> VAR_2 . METHOD_2 ( ) ; <END> if ( VAR_2 != null && VAR_1 != null && ! VAR_1 . METHOD_3 ( ) ) { VAR_1 . METHOD_1 ( ) ; } } 
private TYPE_1 METHOD_1 ( Class < ? > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 . METHOD_2 ( ) ) { if ( VAR_2 . getName ( ) . equals ( STRING_1 ) && ( VAR_2 . METHOD_3 ( ) & TYPE_2 . VAR_4 ) <START> != TYPE_2 . VAR_4 <END> && METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ) { return VAR_2 ; } } return null ; } 
default String VAR_1 ( ) { return <START> getClass ( ) . VAR_2 ( ) ; <END> } 
private static String getPath ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { String <START> VAR_3 = <END> String . valueOf ( VAR_1 . getId ( ) ) ; String VAR_4 = VAR_2 . METHOD_1 ( ) ; if ( METHOD_2 ( VAR_2 ) ) { return VAR_5 + VAR_3 + VAR_6 + VAR_7 + VAR_4 ; } return VAR_5 + VAR_3 + VAR_6 + VAR_4 ; } 
<START> public static boolean METHOD_1 ( String VAR_1 ) { <END> return VAR_1 != null && TYPE_1 . matcher ( VAR_1 ) . METHOD_2 ( ) ; } 
public void <START> METHOD_1 ( final boolean <END> VAR_1 ) { this . VAR_2 = Optional . of ( VAR_1 ) ; } 
protected void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = null ; Set < Entry < TYPE_4 , TYPE_3 > > entrySet = VAR_3 . entrySet ( ) ; <START> for ( Entry < TYPE_4 , TYPE_3 > entry : entrySet ) { <END> TYPE_4 VAR_4 = entry . getKey ( ) ; VAR_2 = entry . getValue ( ) ; if ( VAR_2 != null ) { final TYPE_5 VAR_5 = VAR_2 . METHOD_2 ( true ) ; if ( VAR_5 != null ) VAR_1 . METHOD_3 ( VAR_4 , VAR_5 ) ; } } } 
public void METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) ; VAR_2 = VAR_1 ; if ( VAR_3 != null && VAR_1 != null && <START> VAR_1 . length ( ) > 0 ) { <END> TYPE_1 VAR_4 = TYPE_2 . METHOD_3 ( VAR_3 , TYPE_3 . VAR_6 , TYPE_3 . VAR_7 ) ; VAR_4 . METHOD_4 ( VAR_1 ) ; } else { METHOD_5 ( TYPE_3 . VAR_6 , TYPE_3 . VAR_7 ) ; } } 
public void METHOD_1 ( String name ) { VAR_1 = name ; if ( VAR_2 != null ) { if ( name != null && <START> name . length ( ) > 0 ) { <END> VAR_2 . METHOD_2 ( TYPE_1 . VAR_4 , name ) ; } else { VAR_2 . METHOD_3 ( TYPE_1 . VAR_4 ) ; } } } 
static void METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) ; <START> for ( ; ; ) { <END> if ( ! VAR_1 . METHOD_3 ( ) ) { break ; } } } 
private static boolean METHOD_1 ( ANNOTATION_1 Object element ) { if ( element instanceof TYPE_1 ) { return true ; } if ( ! ( element instanceof TYPE_2 ) ) { return false ; } TYPE_2 trace = ( TYPE_2 ) element ; List < TYPE_3 > VAR_1 = trace . VAR_2 ( ) ; if ( VAR_1 . isEmpty ( ) ) { return false ; } for ( TYPE_3 child : VAR_1 ) { if ( ! METHOD_1 ( child ) ) { <START> return false ; <END> } } return true ; } 
private void METHOD_1 ( ) { if ( ! VAR_1 . isEmpty ( ) ) { METHOD_2 ( ) ; <START> } <END> VAR_1 . add ( VAR_2 . METHOD_3 ( VAR_3 ) ) ; } 
public TYPE_1 build ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( METHOD_1 ( ) , METHOD_2 ( ) , METHOD_3 ( ) , METHOD_4 ( ) , METHOD_5 ( ) , METHOD_6 ( ) ) ; <START> TYPE_2 . METHOD_7 ( VAR_1 , METHOD_4 ( ) . METHOD_8 ( ) ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 event ) { int VAR_1 = event . getType ( ) ; synchronized ( this ) { if ( VAR_1 == TYPE_1 . VAR_2 ) { <START> VAR_3 . split ( 4 ) ; <END> String VAR_4 = event . VAR_5 ( ) . METHOD_2 ( ) ; String VAR_6 = TYPE_2 . bind ( TYPE_3 . TYPE_4 , VAR_4 ) ; VAR_3 . METHOD_3 ( VAR_6 ) ; } } } 
<START> final public TYPE_1 <END> METHOD_1 ( String name ) throws IOException { return METHOD_2 ( ) . METHOD_1 ( name ) ; } 
public File METHOD_1 ( File VAR_1 , String name ) { final File VAR_2 = METHOD_2 ( name ) ; <START> if ( VAR_2 . METHOD_3 ( ) ) <END> return VAR_2 ; return METHOD_2 ( VAR_1 , name ) ; } 
private static void METHOD_1 ( StringBuilder buffer , TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { StringBuilder VAR_3 = new StringBuilder ( ) ; METHOD_2 ( VAR_3 , VAR_1 ) ; StringBuilder VAR_4 = new StringBuilder ( ) ; <START> METHOD_2 ( VAR_4 , VAR_2 ) ; <END> buffer . append ( STRING_1 ) ; METHOD_2 ( buffer , VAR_1 ) ; buffer . append ( STRING_2 ) ; METHOD_2 ( buffer , VAR_2 ) ; buffer . append ( STRING_3 ) ; } 
private String METHOD_1 ( ) { StringBuilder b = new StringBuilder ( VAR_1 ) ; b . append ( STRING_1 ) ; String VAR_2 = STRING_2 ; while <START> ( b . length ( ) < <END> VAR_1 ) { b . append ( VAR_2 ) ; } return b . toString ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , final TYPE_1 VAR_2 ) { try { <START> if ( METHOD_2 ( VAR_2 , VAR_1 ) ) { <END> return VAR_2 ; } } catch ( final IOException ex ) { TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( new TYPE_4 ( new Status ( TYPE_5 . VAR_4 , TYPE_3 . VAR_5 , ex . getMessage ( ) , ex ) ) ) ; } return null ; } 
public static boolean <START> METHOD_1 ( String <END> VAR_1 ) { if ( TYPE_1 . equals ( VAR_1 ) ) { return true ; } if ( ( VAR_2 + TYPE_1 ) . equals ( VAR_1 ) ) { return true ; } return VAR_1 . startsWith ( STRING_1 ) ; } 
protected void METHOD_1 ( ) { VAR_1 = false ; <START> VAR_2 = <END> null ; if ( VAR_3 instanceof TYPE_1 ) { ( ( TYPE_1 ) VAR_3 ) . VAR_4 . METHOD_2 ( ) ; } VAR_3 = null ; } 
public TYPE_1 [ ] METHOD_1 ( ) { if ( ! VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( ) ; Collection < String > VAR_3 = VAR_2 . METHOD_3 ( ) ; for ( String VAR_4 : VAR_3 ) { METHOD_4 ( VAR_4 ) ; } VAR_1 = true ; } return <START> VAR_5 . values ( ) . METHOD_5 ( <END> new TYPE_1 [ VAR_5 . values ( ) . size ( ) ] ) ; } 
public static final int METHOD_1 ( final byte [ ] b , int VAR_1 ) { final int VAR_2 = b . length ; while ( VAR_1 < VAR_2 ) { final byte c = b [ VAR_1 ++ ] ; <START> if ( c == CHAR_1 && ( VAR_1 == VAR_2 || b [ VAR_1 ] != CHAR_2 ) ) <END> return VAR_1 - 1 ; } return VAR_1 - 1 ; } 
public File METHOD_1 ( String VAR_1 , TYPE_1 config ) { if <START> ( config != null && METHOD_2 ( config ) ) { <END> return new TYPE_2 ( VAR_1 , config ) ; } return new File ( VAR_1 ) ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) ; VAR_1 . METHOD_3 ( SWT . VAR_4 ) ; <START> VAR_1 . update ( ) ; <END> VAR_5 = true ; } 
private void METHOD_1 ( ) { if ( VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( VAR_4 , null ) ; VAR_3 . METHOD_4 ( SWT . VAR_5 ) ; <START> VAR_3 . update ( ) ; <END> if ( VAR_2 . equals ( VAR_3 . METHOD_2 ( ) ) ) { VAR_3 . METHOD_5 ( null ) ; } VAR_1 = false ; } } 
private boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { Collection < TYPE_1 > VAR_3 = METHOD_2 ( VAR_1 , VAR_4 ) ; <START> if ( ! METHOD_3 ( VAR_3 , VAR_2 ) ) { <END> return false ; } return true ; } 
private boolean METHOD_1 ( Set < Object > VAR_1 , Set < Object > VAR_2 , int VAR_3 ) { <START> return ! VAR_1 . METHOD_2 ( VAR_2 ) && ( TYPE_1 . VAR_5 == VAR_3 || TYPE_1 . VAR_6 == VAR_3 ) ; <END> } 
protected void METHOD_1 ( TYPE_1 event ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } 
<START> TYPE_1 ( ) { <END> } 
<START> public Collection < TYPE_1 > METHOD_1 ( ) { <END> return Collections . VAR_1 ( configuration . VAR_2 ( ) ) ; } 
<START> public void METHOD_1 ( String id , TYPE_1 VAR_1 ) { <END> if ( VAR_2 . containsKey ( id ) ) { throw new IllegalArgumentException ( TYPE_2 . format ( STRING_1 , id ) ) ; } VAR_2 . put ( id , VAR_1 ) ; } 
<START> public TYPE_1 < ? <END> extends TYPE_2 > METHOD_1 ( ) { return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 a = commit ( ) ; TYPE_1 b = commit ( a ) ; METHOD_2 ( b ) ; <START> VAR_1 = METHOD_3 ( ) ; <END> b = VAR_1 . METHOD_4 ( b ) ; METHOD_5 ( b ) ; METHOD_6 ( b , VAR_1 . next ( ) ) ; METHOD_7 ( VAR_1 . next ( ) ) ; } 
private void METHOD_1 ( TYPE_1 ... VAR_1 ) throws IOException { <START> VAR_2 = METHOD_2 ( ) ; <END> StringBuilder builder = new StringBuilder ( ) ; for ( TYPE_1 commit : VAR_1 ) { builder . append ( commit . getName ( ) + STRING_1 ) ; } TYPE_2 . write ( new File ( db . VAR_3 ( ) , STRING_2 ) , builder . toString ( ) ) ; } 
private boolean METHOD_1 ( ) { return <START> ( TYPE_1 . METHOD_2 ( VAR_1 , <END> TYPE_1 . VAR_2 ) >= 0 ) ; } 
public void METHOD_1 ( TYPE_1 event ) { if ( event . VAR_1 ( ) == VAR_2 && event . getProperty ( ) == TYPE_3 . VAR_4 ) { String VAR_5 = TYPE_2 . METHOD_2 ( ( String ) event . VAR_6 ( ) ) . METHOD_3 ( ) ; <START> if ( VAR_5 != null ) { <END> VAR_7 . METHOD_4 ( VAR_5 ) ; } } } 
<START> public TYPE_2 ( ) <END> { super ( new TYPE_1 [ 0 ] ) ; } 
public TYPE_2 ( ) { <START> VAR_2 = new TYPE_1 ( ) ; <END> } 
public static void METHOD_1 ( ) { VAR_1 = System . getProperty ( STRING_1 , "" ) ; <START> System . VAR_2 ( STRING_1 , STRING_2 ) ; <END> VAR_3 = System . getProperty ( STRING_3 , "" ) ; System . VAR_2 ( STRING_3 , STRING_4 ) ; } 
public void <START> METHOD_1 ( ) <END> { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; TYPE_2 VAR_3 = new TYPE_2 ( STRING_1 , STRING_2 , System . getProperty ( STRING_3 ) ) ; VAR_1 . METHOD_2 ( Arrays . asList ( VAR_3 ) , Arrays . asList ( VAR_3 ) ) ; assertEquals ( null , VAR_2 . METHOD_3 ( STRING_1 ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; TYPE_2 VAR_4 = new TYPE_2 ( ) ; TYPE_3 VAR_5 = VAR_1 . METHOD_3 ( ) . get ( 0 ) ; String VAR_6 = VAR_4 . METHOD_4 ( ( TYPE_4 ) VAR_5 ) ; <START> METHOD_5 ( VAR_6 ) ; <END> VAR_6 = METHOD_6 ( VAR_6 ) ; String VAR_7 = METHOD_6 ( VAR_8 ) ; assertEquals ( VAR_7 , VAR_6 ) ; } 
public TYPE_1 METHOD_1 ( ) { for ( TYPE_1 trace : TYPE_2 . getInstance ( ) . METHOD_2 ( ) ) { <START> for ( TYPE_1 t : TYPE_2 . METHOD_3 ( trace ) ) { <END> if ( METHOD_4 ( ) . equals ( t . VAR_1 ( ) ) && ( t instanceof TYPE_3 ) ) { return t ; } } } return null ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_3 ) ; VAR_2 . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ; <START> METHOD_7 ( VAR_1 . METHOD_8 ( ) ) ; <END> METHOD_7 ( VAR_1 . METHOD_9 ( ) ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { return VAR_1 . METHOD_2 ( ) . equals ( VAR_2 . METHOD_2 ( ) ) <START> && ! METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_2 . METHOD_4 ( ) ) <END> && METHOD_5 ( VAR_1 . METHOD_4 ( ) . METHOD_6 ( ) , VAR_2 . METHOD_4 ( ) . METHOD_6 ( ) ) && METHOD_5 ( VAR_2 . METHOD_4 ( ) . METHOD_7 ( ) , VAR_1 . METHOD_4 ( ) . METHOD_7 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> TYPE_2 . this . METHOD_2 ( VAR_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( int offset ) throws TYPE_2 { if ( offset >= METHOD_2 ( ) ) { METHOD_3 ( TYPE_6 . TYPE_5 , new <START> TYPE_3 ( ) ) ; <END> } return new TYPE_4 ( METHOD_4 ( ) , METHOD_5 ( ) , offset , VAR_3 ) ; } 
<START> protected void METHOD_1 ( ) throws Exception { <END> TYPE_1 value = getValue ( ) ; assertEquals ( value , TYPE_2 . VAR_2 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( METHOD_2 ( VAR_1 - 1 ) == INT_1 ) { return TYPE_1 . VAR_2 ; } return TYPE_1 . VAR_3 ; } 
public static TYPE_1 METHOD_1 ( Path VAR_1 ) throws IOException , TYPE_2 { <START> if ( VAR_1 . METHOD_2 ( ) . toString ( ) . METHOD_3 ( VAR_2 ) ) { try ( TYPE_1 VAR_3 = new TYPE_3 ( VAR_1 ) ) { return VAR_3 ; } } try ( TYPE_1 VAR_3 = new TYPE_4 ( VAR_1 ) ) { return VAR_3 ; } <END> } 
public <START> ANNOTATION_1 ByteBuffer <END> METHOD_1 ( ) { return VAR_1 ; } 
protected static String METHOD_1 ( TYPE_1 file ) { TYPE_2 [ ] VAR_1 ; if ( file != null ) { TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( ) ; TYPE_5 buffer = VAR_2 . METHOD_3 ( file . VAR_3 ( ) , TYPE_8 . VAR_5 ) ; return TYPE_6 . METHOD_4 ( buffer . VAR_6 ( ) ) ; } VAR_1 = new TYPE_2 [ ] { <START> TYPE_9 . VAR_8 } ; <END> return TYPE_7 . METHOD_5 ( ) . getString ( TYPE_7 . VAR_9 , TYPE_7 . VAR_10 , null , VAR_1 ) ; } 
private void METHOD_1 ( ) { boolean VAR_1 = METHOD_2 ( VAR_2 ) . METHOD_3 ( ) ; if ( VAR_1 ) { boolean VAR_3 = METHOD_2 ( VAR_4 ) . METHOD_3 ( ) ; METHOD_2 ( VAR_5 ) . METHOD_4 ( VAR_3 ) ; METHOD_2 ( VAR_6 ) . METHOD_4 ( VAR_3 ) ; METHOD_2 ( VAR_7 ) . METHOD_4 ( VAR_3 ) ; boolean <START> VAR_8 = METHOD_2 ( VAR_9 ) . METHOD_3 ( ) ; <END> } else { VAR_10 . METHOD_4 ( false ) ; VAR_11 . METHOD_4 ( false ) ; } } 
private void METHOD_1 ( TYPE_1 event ) { if ( VAR_1 == null ) { return ; } <START> if ( VAR_2 != null && VAR_2 . METHOD_2 ( event , false ) ) { <END> if ( METHOD_3 ( ) ) { METHOD_4 ( ) ; } else { METHOD_5 ( ) ; } } } 
<START> public static <END> TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 ) { TYPE_1 resource = null ; try { resource = VAR_1 . METHOD_1 ( VAR_2 , true ) ; } catch ( TYPE_4 e ) { TYPE_5 . METHOD_2 ( ) . METHOD_3 ( ) . log ( new Status ( TYPE_6 . VAR_4 , TYPE_5 . VAR_5 , e . getMessage ( ) , e ) ) ; } return resource ; } 
public int METHOD_1 ( ) { return <START> 2 ; <END> } 
protected boolean METHOD_1 ( ) throws IOException { if ( VAR_1 ) { VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; } if ( ! VAR_3 ) { VAR_4 = new HashMap < > ( ) ; } try { return METHOD_4 ( METHOD_5 ( ) , VAR_5 [ 0 ] , VAR_5 [ 1 ] , false ) ; } finally { if ( VAR_1 ) { VAR_2 . METHOD_6 ( ) ; } <START> VAR_4 = null ; <END> } } 
<START> public static Set < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { return Arrays . stream ( VAR_1 . METHOD_2 ( ) ) . filter ( VAR_3 - > VAR_3 . METHOD_3 ( TYPE_3 . class ) . METHOD_4 ( ) . equals ( VAR_2 ) ) . collect ( METHOD_5 ( ) ) ; } <END> 
private TYPE_1 METHOD_1 ( boolean VAR_1 , TYPE_2 VAR_2 , TYPE_3 connection ) { TYPE_1 channel = VAR_3 . METHOD_2 ( ) . get ( VAR_2 ) ; if <START> ( channel == null ) { <END> if ( connection instanceof TYPE_4 ) { channel = new TYPE_1 ( ) ; channel . VAR_4 ( VAR_2 ) ; channel . VAR_5 ( VAR_1 ) ; VAR_3 . METHOD_2 ( ) . put ( VAR_2 , channel ) ; } } else if ( ! VAR_1 ) { channel . VAR_5 ( false ) ; } return channel ; } 
File METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_1 . class ) ; TYPE_3 VAR_2 = VAR_1 . METHOD_5 ( ) ; <START> if ( VAR_2 == null ) <END> return null ; TYPE_4 VAR_3 = VAR_2 . METHOD_6 ( ) ; return TYPE_5 . METHOD_7 ( VAR_3 , File . VAR_4 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_1 VAR_2 = TYPE_1 . create ( TYPE_4 . METHOD_2 ( VAR_3 ) ) ; if <START> ( ! VAR_2 . METHOD_3 ( ) ) <END> { boolean VAR_4 = TYPE_5 . METHOD_4 ( ) . METHOD_5 ( TYPE_6 . VAR_6 , TYPE_6 . VAR_7 , false , null ) ; if ( VAR_4 ) { VAR_3 . METHOD_6 ( TYPE_7 . VAR_9 , VAR_1 ) ; VAR_2 = TYPE_1 . create ( TYPE_4 . METHOD_2 ( VAR_3 ) ) ; } } return VAR_2 ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) != 0 ) return false ; int VAR_2 = METHOD_3 ( VAR_1 ) ; int VAR_3 = VAR_1 . METHOD_4 ( VAR_2 ) ; <START> if ( VAR_3 + 1 < VAR_1 . METHOD_5 ( ) ) <END> return false ; int VAR_4 = METHOD_6 ( VAR_1 , VAR_3 + 1 ) - 1 ; return VAR_4 <= VAR_2 ; } 
public static void METHOD_1 ( View view ) { TYPE_1 VAR_1 = view . VAR_2 ( TYPE_4 . VAR_4 ) ; <START> if ( VAR_1 == null ) { VAR_1 = TYPE_3 . VAR_6 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( TYPE_4 . VAR_4 ) ; VAR_1 . METHOD_4 ( ) . put ( TYPE_2 . VAR_8 , null ) ; view . VAR_9 ( ) . add ( VAR_1 ) ; } else { VAR_1 . METHOD_4 ( ) . put ( TYPE_2 . VAR_8 , null ) ; } <END> } 
protected void METHOD_1 ( View VAR_1 , View view , TYPE_1 VAR_2 , String VAR_3 , int index , boolean VAR_4 ) { TYPE_2 element = view . VAR_5 ( ) ; if ( element instanceof TYPE_3 ) { METHOD_2 ( view ) ; } <START> super . METHOD_1 ( VAR_1 , view , VAR_2 , VAR_3 , index , VAR_4 ) ; <END> } 
public void run ( ) { <START> count -- ; <END> TYPE_1 [ ] VAR_1 = VAR_2 . METHOD_1 ( new TYPE_1 [ ] { } ) ; VAR_2 . clear ( ) ; for ( TYPE_1 it : VAR_1 ) { it . VAR_3 ( ) ; } } 
private TYPE_1 METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; if ( StringUtils . VAR_2 ( VAR_1 ) ) return null ; List < String > VAR_3 = METHOD_3 ( ) ; <START> if ( VAR_3 == null ) <END> return null ; return new TYPE_1 ( VAR_4 , VAR_1 , VAR_3 ) ; } 
private void METHOD_1 ( Map < TYPE_1 , TYPE_2 > results ) { <START> TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( new TYPE_4 ( ) { <END> @Override public void run ( ) { TYPE_5 VAR_1 = TYPE_3 . METHOD_2 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ; new TYPE_6 ( VAR_1 , results ) . METHOD_7 ( ) ; } } ) ; } 
private boolean METHOD_1 ( final ANNOTATION_1 Map < TYPE_1 , TYPE_2 > results ) { return <START> results . entrySet ( ) . stream ( ) . map ( Map . Entry : : getValue ) . METHOD_2 ( r <END> - > r . getStatus ( ) == TYPE_2 . Status . VAR_1 ) ; } 
private boolean METHOD_1 ( final ANNOTATION_1 Map < TYPE_1 , TYPE_2 > results ) { return <START> results . entrySet ( ) . stream ( ) . map ( Map . Entry : : getKey ) . METHOD_2 ( TYPE_3 : : METHOD_3 ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( String ... VAR_1 ) throws IOException { List < TYPE_1 > result = new ArrayList < > ( ) ; <START> if ( VAR_1 . length == 0 ) { <END> result . addAll ( METHOD_1 ( VAR_2 ) ) ; } else { for ( String VAR_3 : VAR_1 ) { result . addAll ( METHOD_1 ( VAR_3 ) ) ; } } return Collections . VAR_4 ( result ) ; } 
<START> public void METHOD_1 ( ) throws IOException { <END> List < TYPE_1 > VAR_1 = db . VAR_2 ( ) . METHOD_2 ( STRING_1 , STRING_2 ) ; assertEquals ( 3 , VAR_1 . size ( ) ) ; METHOD_3 ( VAR_1 , db . VAR_3 ( STRING_3 ) ) ; METHOD_3 ( VAR_1 , db . VAR_3 ( STRING_4 ) ) ; METHOD_3 ( VAR_1 , db . VAR_3 ( STRING_2 ) ) ; } 
public void METHOD_1 ( String message ) { METHOD_2 ( ) ; if ( message == null ) error ( SWT . VAR_1 ) ; this . message = message ; <START> if ( TYPE_1 . VAR_2 >= OS . VAR_3 ( 3 , 4 , 0 ) ) { <END> if ( ( VAR_4 & SWT . VAR_5 ) != 0 ) { byte [ ] buffer = TYPE_2 . METHOD_3 ( message , true ) ; TYPE_1 . METHOD_4 ( VAR_6 , buffer ) ; return ; } } METHOD_5 ( false ) ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( TYPE_4 . VAR_2 , new TYPE_1 ( ) ) ; METHOD_2 ( TYPE_5 . VAR_4 , new TYPE_2 ( ) ) ; <START> METHOD_2 ( TYPE_6 . VAR_6 , new TYPE_3 ( this , METHOD_3 ( ) ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 configuration , boolean VAR_1 ) { configuration . VAR_2 ( TYPE_3 . VAR_4 , <START> ! VAR_1 ) ; <END> boolean VAR_5 = ! VAR_1 || TYPE_2 . METHOD_2 ( ) ; configuration . VAR_2 ( TYPE_3 . VAR_6 , VAR_5 ) ; String location ; if ( VAR_1 && ! VAR_5 ) { location = TYPE_2 . METHOD_3 ( ) ; } else { location = VAR_7 + configuration . getName ( ) ; } configuration . VAR_2 ( TYPE_3 . VAR_8 , location ) ; } 
private static List < ? extends TYPE_1 > METHOD_1 ( Throwable e ) { String VAR_1 = STRING_1 ; TYPE_2 log = TYPE_3 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_1 ) ) ; log . log ( new Status ( TYPE_4 . VAR_3 , VAR_1 , TYPE_4 . VAR_4 , e . getMessage ( ) , e ) ) ; <START> return new ArrayList < > ( ) ; <END> } 
public static Collection < TYPE_1 > METHOD_1 ( TYPE_1 VAR_1 ) { Set < TYPE_1 > result = new <START> HashSet < > ( ) ; <END> if ( VAR_1 != null ) { METHOD_1 ( VAR_1 , result ) ; } return result ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( SWT . TYPE_4 , new TYPE_2 ( ) { @Override public void METHOD_3 ( final TYPE_3 event ) { if <START> ( 0 <= event . index && event . index <= 5 ) <END> event . VAR_3 &= ~ SWT . VAR_4 ; } } ) ; VAR_1 . METHOD_2 ( SWT . TYPE_5 , new TYPE_2 ( ) { @Override public void METHOD_3 ( final TYPE_3 event ) { METHOD_4 ( event ) ; } } ) ; } 
<START> public int METHOD_1 ( int index ) { <END> METHOD_2 ( ) ; if ( index < 0 || index > content . VAR_1 ( ) ) { SWT . error ( SWT . VAR_2 ) ; } return METHOD_3 ( VAR_3 . TYPE_1 ) ? 0 : VAR_5 . METHOD_1 ( index , VAR_6 ) ; } 
<START> private String METHOD_1 ( String host , int VAR_1 ) { <END> if ( VAR_1 == VAR_2 ) { return host ; } return String . format ( STRING_1 , host , VAR_1 ) ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( true ) ; <START> if ( VAR_2 != null ) VAR_2 . METHOD_2 ( true ) ; <END> VAR_3 . METHOD_2 ( true ) ; VAR_4 . METHOD_2 ( true ) ; VAR_5 . METHOD_2 ( true ) ; } 
public synchronized void METHOD_1 ( TYPE_1 child , TYPE_2 VAR_1 ) { <START> VAR_2 -= VAR_1 . METHOD_2 ( ) ; <END> if ( child . VAR_3 ( ) >= 0 ) { VAR_1 . METHOD_3 ( ) . update ( child ) ; } TYPE_2 node = VAR_4 . get ( VAR_1 . METHOD_4 ( ) ) ; if ( node == null ) { VAR_4 . put ( VAR_1 . METHOD_4 ( ) , VAR_1 ) ; } else { METHOD_5 ( node , VAR_1 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { if ( VAR_1 == null ) { VAR_1 = TYPE_3 . VAR_3 ; } TYPE_1 VAR_4 = new TYPE_1 ( ) ; if ( ! VAR_5 ) { METHOD_2 ( VAR_1 , VAR_4 ) ; } METHOD_3 ( VAR_1 , VAR_4 ) ; <START> VAR_6 . METHOD_4 ( ) ; <END> return VAR_4 ; } 
public static void METHOD_1 ( String uri ) throws TYPE_1 { if ( uri . startsWith ( STRING_1 ) ) { throw new TYPE_1 ( TYPE_2 . format ( TYPE_3 . get ( ) . VAR_1 , uri ) , <START> TYPE_4 . TYPE_5 . VAR_4 ) ; <END> } } 
Object METHOD_1 ( TYPE_1 input ) throws TYPE_2 { if ( input instanceof TYPE_3 ) { String value = ( ( TYPE_3 ) input ) . getValue ( ) ; <START> if ( value . equals ( STRING_1 ) || value . equals ( STRING_2 ) ) { <END> return Double . VAR_1 ; } if ( value . equals ( STRING_3 ) ) { return Double . VAR_2 ; } } return TYPE_4 . METHOD_2 ( input ) ; } 
protected ANNOTATION_1 String METHOD_1 ( ANNOTATION_2 TYPE_1 VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; <START> TYPE_3 trace = TYPE_4 . getInstance ( ) . METHOD_2 ( ) ; <END> if ( trace != null ) { Object VAR_3 = VAR_2 . METHOD_3 ( ) ; return String . valueOf ( VAR_3 ) ; } } return null ; } 
public void METHOD_1 ( ) throws TYPE_1 { List < String > VAR_1 = Arrays . asList ( STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , STRING_8 , STRING_9 , STRING_10 , STRING_11 , STRING_12 , <START> STRING_13 ) ; <END> for ( String VAR_2 : VAR_1 ) { TYPE_2 r = TYPE_2 . METHOD_2 ( METHOD_3 ( VAR_2 ) ) ; assertEquals ( r . VAR_3 ( ) . size ( ) , 1 ) ; assertTrue ( r . VAR_3 ( ) . contains ( VAR_2 ) ) ; } } 
public TYPE_5 ( TYPE_1 trace , String VAR_2 , String VAR_3 , String VAR_4 ) { this . VAR_5 = trace ; this . VAR_6 = VAR_2 ; this . VAR_7 = VAR_3 ; this . VAR_8 = VAR_3 . substring ( VAR_3 . METHOD_1 ( TYPE_4 . VAR_10 ) + 1 ) ; this . VAR_4 = VAR_4 ; try { METHOD_2 ( ) ; } catch ( TYPE_2 e ) { <START> TYPE_3 . METHOD_3 ( VAR_11 , e ) ; <END> } } 
public void METHOD_1 ( ) { if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) && ! VAR_2 ) { VAR_2 = true ; try { VAR_1 . METHOD_3 ( ) ; } catch ( TYPE_1 e ) { <START> TYPE_2 . METHOD_4 ( VAR_3 , <END> e ) ; } VAR_1 = null ; } } 
public void METHOD_1 ( ) { VAR_1 = <START> METHOD_2 ( Collections . VAR_2 ( ) ) ; <END> VAR_3 = null ; VAR_4 = null ; } 
public int METHOD_1 ( String line , int VAR_1 ) { if ( VAR_2 == null ) { <START> return METHOD_1 ( line , VAR_1 ) ; <END> } return VAR_2 . METHOD_1 ( line , VAR_1 ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> this . VAR_2 = TYPE_4 . METHOD_4 ( VAR_1 , STRING_1 , null , null ) ; this . VAR_2 . METHOD_5 ( false ) ; this . VAR_2 . METHOD_6 ( ) ; return ( TYPE_1 ) this . VAR_2 . METHOD_7 ( ) ; } 
Builder METHOD_1 ( Collection < String > VAR_1 ) { for ( String VAR_2 : VAR_1 ) { if ( VAR_2 . startsWith ( STRING_1 ) ) { METHOD_2 ( VAR_2 . substring ( STRING_1 . length ( ) ) ) ; } else { VAR_3 . add ( VAR_2 ) ; } } <START> VAR_3 . addAll ( VAR_1 ) ; <END> return this ; } 
private static boolean METHOD_1 ( final TYPE_1 event ) { TYPE_2 content = event . VAR_1 ( ) ; return <START> ( ( content . VAR_2 ( Long . VAR_3 , TYPE_3 . VAR_5 ) == null ) || ( content . VAR_2 ( Long . VAR_3 , TYPE_3 . VAR_6 ) == null ) || ( content . VAR_2 ( Long . VAR_3 , TYPE_3 . VAR_7 ) == null ) ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 column ) { if ( column . VAR_1 ( TYPE_3 . VAR_3 ) == TYPE_2 . VAR_5 ) { return false ; } return <START> ( ! column . VAR_6 ( ) && column . VAR_7 ( ) == 0 ) ; <END> } 
protected boolean METHOD_1 ( TYPE_1 parent , int index , TYPE_1 child ) { return <START> ( parent . VAR_1 ( index ) != child . VAR_2 ( ) && parent . VAR_3 ( index ) != child . VAR_4 ( ) ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 != VAR_1 . VAR_2 ) { return false ; } if ( VAR_3 != VAR_1 . VAR_3 ) { return false ; } if ( VAR_4 != VAR_1 . VAR_4 ) { return false ; } <START> return ! ( VAR_3 == VAR_5 ) && VAR_6 . equals ( VAR_1 . VAR_6 ) ; <END> } 
private static boolean METHOD_1 ( final TYPE_1 event ) { TYPE_2 content = event . VAR_1 ( ) ; <START> return ( ( content . VAR_2 ( Long . VAR_3 , TYPE_3 . VAR_5 ) != null ) || <END> ( content . VAR_2 ( Long . VAR_3 , TYPE_3 . VAR_6 ) != null ) || ( content . VAR_2 ( Long . VAR_3 , TYPE_3 . VAR_7 ) != null ) ) ; } 
protected boolean METHOD_1 ( int VAR_1 ) { <START> return ! ( VAR_1 < VAR_2 . size ( ) || VAR_1 >= 0 ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 column ) { if ( column . VAR_1 ( TYPE_3 . VAR_3 ) == TYPE_2 . VAR_5 ) { return false ; } <START> return ( column . VAR_6 ( ) && column . VAR_7 ( ) > 0 ) ; <END> } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( VAR_2 != VAR_1 . VAR_2 ) { return false ; } <START> return ( VAR_2 == 0 && Arrays . equals ( VAR_3 , VAR_1 . VAR_3 ) ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_1 VAR_3 = <START> VAR_2 . METHOD_3 ( String . valueOf ( STRING_1 ) ) ; <END> return VAR_3 ; } 
protected TYPE_1 METHOD_1 ( Object item ) { for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <START> if ( ( ( TYPE_2 ) item ) . equals ( VAR_1 [ i ] ) ) { <END> return new Status ( TYPE_1 . VAR_2 , TYPE_3 . VAR_4 , 0 , "" , null ) ; } } return new Status ( TYPE_1 . VAR_5 , TYPE_3 . VAR_4 , 0 , "" , null ) ; } 
<START> private TYPE_1 <END> METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( ) ; } return VAR_1 ; } 
public long METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { return <START> ( int ) METHOD_2 ( ) . METHOD_1 ( ) ; <END> } return super . METHOD_1 ( ) ; } 
public long METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { <START> return ( int ) <END> METHOD_2 ( ) . METHOD_1 ( ) ; } return super . METHOD_1 ( ) ; } 
private static List < String > METHOD_1 ( String VAR_1 , Map < String , List < String > > m ) { List < String > VAR_2 = new TYPE_1 < > ( ) ; m . entrySet ( ) . stream ( ) . filter ( e - > VAR_1 . equalsIgnoreCase ( e . getKey ( ) ) ) <START> . forEach ( e - > VAR_2 . addAll ( e . getValue ( ) ) ) ; <END> return VAR_2 ; } 
private void METHOD_1 ( String <START> VAR_1 , int <END> VAR_2 , int VAR_3 ) { switch ( VAR_2 ) { case TYPE_1 . VAR_5 : assertEquals ( STRING_1 , TYPE_1 . VAR_5 , VAR_3 ) ; break ; case TYPE_1 . VAR_6 : assertEquals ( STRING_1 , TYPE_1 . VAR_6 , VAR_3 ) ; break ; case TYPE_1 . VAR_7 : assertEquals ( STRING_1 , TYPE_1 . VAR_7 , VAR_3 ) ; break ; default : break ; } ; } 
public TYPE_8 ( TYPE_1 element , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 , boolean VAR_5 ) throws TYPE_5 , TYPE_6 { super ( element , VAR_3 , VAR_4 , null ) ; this . VAR_5 = VAR_5 ; <START> action = e - > new TYPE_7 ( VAR_2 ) . run ( element ) ; <END> } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> if ( VAR_1 > 0 ) { return action ; } return null ; } 
public TYPE_8 ( TYPE_1 element , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 , boolean VAR_5 ) throws TYPE_5 , TYPE_6 { <START> super ( element , VAR_3 , VAR_4 , e - > new TYPE_7 ( VAR_2 ) . run ( element ) ) ; <END> this . VAR_5 = VAR_5 ; } 
private void METHOD_1 ( final TYPE_1 p ) { METHOD_2 ( SWT . TYPE_3 ) ; METHOD_2 ( SWT . TYPE_4 ) ; METHOD_2 ( SWT . TYPE_5 ) ; <START> METHOD_2 ( SWT . TYPE_6 ) ; <END> METHOD_2 ( SWT . TYPE_7 , METHOD_3 ( p . x , p . y , 1 , SWT . NONE , 1 ) ) ; METHOD_2 ( SWT . TYPE_2 , METHOD_3 ( p . x , p . y , 1 , SWT . VAR_7 , 1 ) ) ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> assertTrue ( STRING_1 . equals ( VAR_1 . METHOD_1 ( ) ) ) ; <END> } 
private static TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; TYPE_1 VAR_3 = Thread . VAR_4 ( ) . METHOD_3 ( ) ; TYPE_1 VAR_5 = TYPE_3 . class . METHOD_4 ( ) ; <START> return new TYPE_4 ( VAR_2 , new TYPE_5 ( VAR_3 . METHOD_5 ( ) ) , <END> VAR_5 ) ; } 
public synchronized void METHOD_1 ( ) { <START> synchronized ( this ) { <END> if ( VAR_1 != null ) { try { VAR_1 . close ( ) ; } catch ( IOException e ) { TYPE_1 . getInstance ( ) . METHOD_2 ( STRING_1 + getPath ( ) , e ) ; } } } super . METHOD_1 ( ) ; } 
public Object run ( Object object ) throws Exception { String [ ] args = TYPE_1 . METHOD_1 ( ) ; String VAR_1 = METHOD_2 ( args , STRING_1 ) ; if ( VAR_1 != null ) { TYPE_2 . METHOD_3 ( VAR_1 ) ; } <START> return Integer . valueOf ( TYPE_3 . run ( args ) ) ; <END> } 
public void run ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; for ( Object obj : METHOD_1 ( ) ) { if ( obj instanceof TYPE_2 ) { <START> TYPE_3 cmd ; cmd = new TYPE_3 ( ( ( TYPE_2 ) obj ) . METHOD_2 ( ) , entry ) ; <END> if ( cmd . VAR_2 ( ) ) { VAR_1 . add ( cmd ) ; } } } execute ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( String uri ) throws IOException { TYPE_2 url = new TYPE_2 ( METHOD_2 ( uri ) ) ; <START> if ( VAR_1 != null ) <END> return ( TYPE_1 ) url . VAR_2 ( VAR_1 ) ; return ( TYPE_1 ) url . VAR_2 ( ) ; } 
private TYPE_1 METHOD_1 ( String name ) throws TYPE_2 { TYPE_1 result = null ; for ( final TYPE_1 user : VAR_1 . METHOD_2 ( ) ) { if ( user . getName ( ) . equals ( name ) ) { <START> result = user ; <END> } } return result ; } 
public String getName ( ) { return <START> VAR_1 . get ( 0 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 context ) throws TYPE_3 { TYPE_4 VAR_1 = VAR_2 . METHOD_2 ( context ) ; return VAR_1 == null ? null : new <START> TYPE_5 ( VAR_2 . METHOD_2 ( context ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) ; int VAR_3 = <START> 1 ; <END> while ( METHOD_3 ( VAR_1 ) ) { String VAR_4 = VAR_2 + STRING_1 + VAR_3 + CHAR_1 ; VAR_1 . METHOD_4 ( VAR_4 ) ; VAR_3 ++ ; } } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = db . VAR_2 ( STRING_1 ) ; Set < TYPE_2 > VAR_3 = db . VAR_4 ( ) . METHOD_2 ( VAR_1 ) ; <START> assertEquals ( VAR_3 . size ( ) , 2 ) ; <END> METHOD_3 ( VAR_3 , db . VAR_5 ( STRING_1 ) ) ; METHOD_3 ( VAR_3 , db . VAR_5 ( STRING_2 ) ) ; assertEquals ( db . VAR_4 ( ) . METHOD_2 ( TYPE_1 . METHOD_4 ( ) ) . size ( ) , 0 ) ; } 
public void METHOD_1 ( String name ) { Assert . VAR_1 ( VAR_2 ) ; VAR_2 = name ; <START> VAR_3 = ! VAR_2 . isEmpty ( ) ; <END> } 
public TYPE_1 write ( String item , TYPE_2 monitor ) throws IOException { File file = METHOD_1 ( item ) ; <START> return new TYPE_3 ( new TYPE_4 ( file ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) instanceof TYPE_2 ) { TYPE_2 VAR_2 = ( TYPE_2 ) ( VAR_1 . METHOD_2 ( ) ) ; if ( VAR_3 == null || ! VAR_3 . equals ( VAR_2 ) ) { VAR_3 = VAR_2 ; <START> VAR_4 . METHOD_3 ( true ) ; <END> METHOD_4 ( ) ; } } super . METHOD_1 ( VAR_1 ) ; } 
public TYPE_11 ( ) { VAR_2 = new TYPE_1 ( TYPE_10 . TYPE_12 ) { @Override protected TYPE_2 run ( TYPE_3 monitor ) { return METHOD_1 ( monitor ) ; } } ; VAR_5 = new TYPE_4 ( ) ; <START> VAR_2 . METHOD_2 ( true ) ; <END> VAR_6 = new TYPE_5 ( ) ; TYPE_6 . METHOD_3 ( ) . METHOD_4 ( VAR_6 , TYPE_9 . VAR_8 ) ; VAR_9 = new TYPE_7 ( ) ; TYPE_8 . METHOD_5 ( VAR_9 , TYPE_13 . VAR_8 ) ; } 
public <START> int METHOD_1 ( TYPE_1 <END> resource ) { return cache . VAR_1 ( resource , 0 ) . METHOD_2 ( ) ; } 
public String METHOD_1 ( final Object element ) { if ( element == null ) { return "" ; <START> } <END> return ( ( TYPE_1 ) element ) . METHOD_2 ( element ) ; } 
public TYPE_1 [ ] METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 instanceof TYPE_2 && ! METHOD_2 ( ) ) { return null ; } <END> TYPE_1 [ ] VAR_2 = { VAR_1 } ; return VAR_2 ; } 
long METHOD_1 ( long VAR_1 , int VAR_2 , double x , double y , long VAR_3 ) { <START> long event = TYPE_1 . METHOD_2 ( ) ; <END> long result = 0 ; switch ( ( int ) VAR_3 ) { case VAR_4 : result = METHOD_3 ( VAR_1 , VAR_2 , x , y ) ; break ; case VAR_5 : result = METHOD_4 ( VAR_1 , VAR_2 , x , y ) ; break ; } METHOD_5 ( event ) ; return result ; } 
public TYPE_3 ( ) { <START> this . VAR_2 <END> = new TYPE_1 ( this ) ; this . VAR_3 = new TYPE_2 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_3 . TYPE_4 ; <START> <END> List < String > VAR_4 = new ArrayList < > ( ) ; VAR_4 . add ( STRING_1 ) ; VAR_4 . add ( STRING_2 ) ; VAR_4 . add ( STRING_3 ) ; List < TYPE_2 > VAR_5 = VAR_6 . METHOD_1 ( VAR_7 , TYPE_6 . TYPE_5 , VAR_1 , VAR_4 ) ; Assert . VAR_10 ( VAR_5 . isEmpty ( ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 . getId ( ) ) ; if ( VAR_2 == null ) { VAR_2 = session . VAR_4 ( VAR_1 . getId ( ) ) ; TYPE_1 <START> VAR_5 = <END> VAR_3 . METHOD_2 ( VAR_1 . getId ( ) , VAR_2 ) ; } return VAR_2 ; } 
private void METHOD_1 ( TYPE_1 parent ) { VAR_1 = new TYPE_2 ( parent , SWT . VAR_2 ) ; <START> VAR_1 . setText ( String . format ( STRING_1 + VAR_3 ) ) ; <END> VAR_1 . METHOD_2 ( SWT . TYPE_6 , new TYPE_3 ( ) { @Override public void METHOD_3 ( TYPE_4 event ) { METHOD_4 ( event ) ; METHOD_5 ( event ) ; } } ) ; VAR_1 . METHOD_6 ( new TYPE_5 ( TYPE_5 . VAR_5 ) ) ; } 
private void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; VAR_1 = null ; } <START> if ( VAR_2 != null ) { <END> METHOD_3 ( ) ; VAR_2 = new ArrayList < > ( ) ; } METHOD_4 ( VAR_3 ) ; VAR_4 . run ( ) ; } 
public String METHOD_1 ( int VAR_1 ) { try { final TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; return VAR_3 . get ( VAR_2 . METHOD_3 ( ) , VAR_2 . METHOD_4 ( ) ) ; } catch ( TYPE_2 e ) { TYPE_3 . log ( e ) ; <START> return null ; <END> } } 
static long METHOD_1 ( String VAR_1 ) { int length = VAR_1 . length ( ) ; char [ ] VAR_2 = new char [ length ] ; VAR_1 . METHOD_2 ( 0 , length , VAR_2 , 0 ) ; byte [ ] buffer = TYPE_1 . METHOD_3 ( VAR_2 , true ) ; <START> long VAR_3 = TYPE_2 . METHOD_1 ( buffer , null ) ; return VAR_3 ; <END> } 
public void METHOD_1 ( ) throws Exception { File VAR_1 = METHOD_2 ( STRING_1 , STRING_2 . METHOD_3 ( ) ) ; File VAR_2 = METHOD_2 ( STRING_3 , STRING_4 . METHOD_3 ( ) ) ; <START> long VAR_3 = System . currentTimeMillis ( ) ; <END> VAR_1 . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ; TYPE_1 VAR_4 = TYPE_1 . METHOD_6 ( VAR_1 ) ; Thread . VAR_5 ( INT_1 ) ; assertEquals ( VAR_4 . METHOD_5 ( ) , VAR_2 . METHOD_5 ( ) ) ; assertTrue ( VAR_4 . METHOD_7 ( VAR_2 ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 parent , TYPE_1 VAR_1 ) { <START> TYPE_1 VAR_2 = METHOD_1 ( VAR_1 ) ; <END> METHOD_2 ( parent , VAR_2 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; VAR_1 = TYPE_2 . VAR_3 ; <START> METHOD_3 ( new TYPE_1 ( TYPE_3 . VAR_5 , STRING_1 . METHOD_4 ( ) ) ) ; <END> } 
public boolean METHOD_1 ( boolean VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 != null ) { <START> return TYPE_2 . METHOD_3 ( VAR_2 . getType ( ) . METHOD_4 ( ) ) ; <END> } return VAR_3 . METHOD_1 ( VAR_1 ) && VAR_4 . METHOD_1 ( VAR_1 ) ; } 
public boolean METHOD_1 ( boolean VAR_1 ) { if ( VAR_2 == VAR_3 ) return false ; TYPE_1 VAR_4 = METHOD_2 ( ) ; if ( VAR_4 != null ) { <START> return TYPE_2 . METHOD_3 ( VAR_4 . getType ( ) . METHOD_4 ( ) ) ; <END> } return VAR_5 . METHOD_1 ( VAR_1 ) ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) return false ; else { TYPE_2 v = ( TYPE_2 ) VAR_1 . getValue ( ) ; <START> return v . VAR_2 ( ) . METHOD_2 ( ) == 1 ; <END> } } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { <START> TYPE_2 v = ( TYPE_2 ) VAR_1 . getValue ( ) ; <END> if ( v . VAR_2 ( ) != null ) return v . VAR_2 ( ) . METHOD_2 ( ) == 1 ; } return false ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 monitor ) throws TYPE_4 { String VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; for ( int VAR_3 = 0 ; ; VAR_3 ++ ) { try { return METHOD_4 ( VAR_2 , monitor ) ; } catch ( TYPE_4 e ) { if ( VAR_3 < 3 ) { VAR_2 = VAR_1 . METHOD_2 ( ) . getName ( ) ; continue ; <START> } <END> } } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 method ) { if ( ! METHOD_2 ( method ) ) { List < TYPE_2 > VAR_2 = VAR_3 . get ( VAR_1 ) ; <START> if ( VAR_2 == null ) { <END> VAR_2 = new ArrayList < > ( ) ; VAR_2 . add ( method ) ; VAR_3 . put ( VAR_1 , VAR_2 ) ; } else { VAR_2 . add ( method ) ; } } } 
public < T > T METHOD_1 ( Object VAR_1 , Class < T > VAR_2 ) { if ( VAR_2 == TYPE_1 . class && VAR_1 instanceof TYPE_2 <START> || VAR_1 instanceof TYPE_3 ) { <END> return ( T ) new TYPE_4 ( ) ; } return null ; } 
<START> public static void METHOD_1 ( ) throws TYPE_1 { <END> project = TYPE_2 . METHOD_2 ( STRING_1 + System . currentTimeMillis ( ) ) ; VAR_1 = TYPE_2 . METHOD_3 ( project , STRING_2 ) ; TYPE_3 VAR_2 = TYPE_4 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( STRING_3 ) ; if ( VAR_2 instanceof TYPE_5 ) { VAR_3 = ( TYPE_5 ) VAR_2 ; } Assert . assertNotNull ( VAR_3 ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> try ( TYPE_1 obj = ( TYPE_1 ) trace . VAR_1 ( ) ; ) { assertNotNull ( obj ) ; TYPE_2 VAR_2 = new TYPE_2 ( new TYPE_3 ( 1 , 0 ) ) ; obj . VAR_3 ( VAR_2 ) ; obj . VAR_4 ( ) ; boolean result = iterator . equals ( obj ) ; assertTrue ( result ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { List < ? > VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( ! VAR_2 . isEmpty ( ) ) { TYPE_2 VAR_3 = <START> VAR_1 . METHOD_3 ( ) ; <END> TYPE_3 method = METHOD_4 ( VAR_3 ) ; METHOD_5 ( method , VAR_2 , VAR_3 . METHOD_6 ( ) ) ; } return super . METHOD_1 ( VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { List < ? > VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( ! VAR_2 . isEmpty ( ) ) { TYPE_2 VAR_3 = <START> VAR_1 . METHOD_3 ( ) ; <END> TYPE_3 method = METHOD_3 ( VAR_3 ) ; METHOD_4 ( method , VAR_2 , VAR_3 . METHOD_5 ( ) ) ; } return super . METHOD_1 ( VAR_1 ) ; } 
public static void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ) ; Thread . VAR_1 ( ) . METHOD_3 ( STRING_1 ) ; TYPE_4 . VAR_3 = INT_1 ; TYPE_4 . VAR_4 = STRING_2 ; TYPE_2 VAR_5 = new TYPE_2 ( ) ; TYPE_1 . METHOD_4 ( STRING_3 , VAR_5 ) ; <START> METHOD_5 ( ) ; <END> TYPE_3 . METHOD_6 ( ) ; TYPE_1 . METHOD_7 ( VAR_6 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; TYPE_1 . METHOD_3 ( VAR_2 , VAR_1 ) ; <END> } 
<START> public static void METHOD_1 ( ) { <END> TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 . METHOD_3 ( ) , VAR_3 ) ; VAR_4 = TYPE_1 . METHOD_4 ( VAR_5 , VAR_2 . getName ( ) ) ; } 
<START> private static int METHOD_1 ( int VAR_1 , int VAR_2 ) { <END> return ( INT_1 * VAR_1 + VAR_2 - 1 ) / VAR_2 ; } 
private boolean METHOD_1 ( TYPE_1 info ) { <START> if ( info . VAR_1 != null ) <END> return info . VAR_1 ; info . VAR_1 = TYPE_2 . METHOD_1 ( info . method ) ; return info . VAR_1 ; } 
protected TYPE_1 METHOD_1 ( Object VAR_1 ) { Object input = VAR_1 ; if ( input instanceof TYPE_2 ) { final TYPE_3 VAR_2 = ( ( TYPE_2 ) input ) . METHOD_2 ( ) ; <START> if ( VAR_2 . METHOD_3 ( ) != null ) { <END> input = VAR_2 . METHOD_3 ( ) ; } else { input = VAR_2 ; } } if ( ! TYPE_1 . class . METHOD_4 ( input ) ) { throw new IllegalStateException ( STRING_1 ) ; } return ( TYPE_1 ) input ; } 
<START> private org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_1 METHOD_1 ( TYPE_1 VAR_6 ) { <END> return new org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_1 ( TYPE_2 . create ( VAR_6 . METHOD_2 ( ) ) , VAR_6 . getName ( ) , TYPE_3 . VAR_8 , VAR_6 . METHOD_3 ( ) ? TYPE_3 . VAR_9 : TYPE_3 . NONE ) ; } 
private Set < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { final Set < TYPE_1 > VAR_2 = new TYPE_3 < > ( ) ; <START> for ( int <END> i = 0 ; i < VAR_1 . VAR_3 . length ; i ++ ) { final TYPE_4 VAR_4 = VAR_1 . VAR_3 [ i ] ; VAR_4 . METHOD_2 ( VAR_2 ) ; } return VAR_2 ; } 
<START> private boolean METHOD_1 ( ) throws IOException { ANNOTATION_1 ( STRING_1 ) TYPE_1 err = new TYPE_1 ( TYPE_1 . VAR_1 , TYPE_1 . VAR_2 , VAR_3 ) ; err . write ( Constants . VAR_4 ( TYPE_2 . get ( ) . VAR_5 ) ) ; err . VAR_6 ( ) ; return true ; } <END> 
public TYPE_4 ( final Class < ? extends TYPE_1 > type , final String path , final TYPE_2 [ ] VAR_2 , final int VAR_3 , final ANNOTATION_1 TYPE_3 resource ) { METHOD_1 ( type , path , VAR_2 , VAR_3 , resource , <START> null ) ; <END> } 
<START> public boolean contains ( Object o ) { <END> return VAR_1 . METHOD_1 ( o ) ; } 
protected void METHOD_1 ( Collection < T > VAR_1 ) { <START> if ( VAR_1 == null ) { <END> result = null ; } else { result = VAR_1 ; } } 
<START> public T METHOD_1 ( ) { <END> Collection < T > list = METHOD_2 ( ) ; if ( list == null ) { return null ; } Iterator < T > iterator = list . iterator ( ) ; if ( iterator . hasNext ( ) ) { return iterator . next ( ) ; } return null ; } 
protected void METHOD_1 ( Collection < T > VAR_1 ) { <START> if ( VAR_1 == null ) { <END> result = Collections . VAR_2 ( ) ; } else { result = VAR_1 ; } } 
protected void METHOD_1 ( T ... VAR_1 ) { if ( VAR_1 == null ) { <START> result = Collections . VAR_2 ( ) ; <END> } else { result = Arrays . asList ( VAR_1 ) ; } } 
public boolean METHOD_1 ( ) { if ( VAR_1 == TYPE_1 . VAR_3 ) { METHOD_2 ( ) ; <START> if ( VAR_1 == TYPE_1 . VAR_3 ) { VAR_1 = TYPE_1 . VAR_4 ; } <END> } return VAR_1 == TYPE_1 . VAR_4 ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { if ( VAR_1 == null || VAR_1 . METHOD_2 ( ) != VAR_2 ) { return ; } VAR_2 = null ; <START> TYPE_2 r = this : : METHOD_3 ; <END> if ( TYPE_3 . METHOD_4 ( ) == null ) { TYPE_3 d = TYPE_3 . METHOD_5 ( ) ; if ( ! d . VAR_3 ( ) ) { d . VAR_4 ( r ) ; } } else { r . run ( ) ; } } 
private TYPE_1 [ ] METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( ) { @Override public TYPE_3 METHOD_2 ( TYPE_4 parent , TYPE_5 VAR_2 , TYPE_6 VAR_3 , TYPE_7 VAR_4 ) { return new TYPE_3 ( parent , VAR_2 , VAR_3 , VAR_4 ) ; } @Override public boolean METHOD_3 ( ) { return false ; } } ; TYPE_8 VAR_5 = TYPE_9 : : new ; return TYPE_10 . build ( this , repo , commit . VAR_6 ( ) , VAR_1 , <START> VAR_5 ) ; <END> } 
private TYPE_1 METHOD_1 ( ANNOTATION_1 String value ) { switch ( value ) { case STRING_1 : return TYPE_1 . VAR_1 ; case STRING_2 : return TYPE_1 . VAR_2 ; case STRING_3 : return TYPE_1 . VAR_3 ; case STRING_4 : return TYPE_1 . VAR_4 ; default : <START> break ; <END> } return null ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } <START> if ( obj == null ) { return false ; } <END> if ( ! ( obj instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return Arrays . equals ( VAR_2 , VAR_1 . VAR_2 ) && VAR_3 == VAR_1 . VAR_3 ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) && VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; if ( VAR_2 == null && VAR_1 != null ) { TYPE_2 VAR_3 = <START> TYPE_3 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; <END> if ( VAR_3 == null || VAR_3 . METHOD_6 ( ) == null ) { } else { VAR_2 = TYPE_1 . METHOD_7 ( VAR_3 . METHOD_6 ( ) ) ; METHOD_2 ( ) . put ( VAR_1 , VAR_2 ) ; } } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = <START> TYPE_3 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; <END> if ( VAR_1 == null || VAR_1 . METHOD_4 ( ) == null ) { return null ; } return TYPE_1 . METHOD_5 ( VAR_1 . METHOD_4 ( ) ) ; } 
public boolean METHOD_1 ( ) { return VAR_1 instanceof TYPE_1 ? ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) : <START> true ; <END> } 
<START> public long METHOD_1 ( long VAR_1 ) { <END> TYPE_1 trace = VAR_2 ; if ( trace != null ) { return trace . VAR_3 ( VAR_1 - trace . VAR_4 ( ) . METHOD_2 ( ) ) + trace . VAR_5 ( ) ; } return 0 ; } 
private void METHOD_1 ( TYPE_1 result , TYPE_2 VAR_1 ) { String value = METHOD_2 ( VAR_1 . METHOD_3 ( STRING_1 ) ) ; <START> if ( null == value ) { <END> return ; } else switch ( value ) { case VAR_2 : result . VAR_3 ( TYPE_4 . VAR_5 ) ; break ; case VAR_6 : result . VAR_3 ( TYPE_4 . VAR_7 ) ; break ; default : throw new TYPE_3 ( STRING_2 + value ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = null ; try { <START> try ( TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_4 ) ) { <END> VAR_2 . write ( new byte [ 1 ] ) ; } } catch ( TYPE_1 e ) { VAR_1 = e ; } assertThat ( VAR_1 , is ( METHOD_3 ( TYPE_1 . class ) ) ) ; assertThat ( VAR_1 . getStatus ( ) . METHOD_4 ( ) , is ( TYPE_1 . VAR_5 ) ) ; } 
public static synchronized void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 ; if ( VAR_1 != null ) { TYPE_2 . METHOD_2 ( VAR_1 ) ; VAR_1 . VAR_3 . clear ( ) ; } <START> VAR_2 = null ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 = METHOD_2 ( VAR_2 ) ; if ( VAR_3 == null ) { return ; } VAR_1 . remove ( VAR_3 ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> METHOD_4 ( VAR_2 , VAR_3 ) ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; TYPE_1 VAR_3 = METHOD_3 ( VAR_4 ) ; <START> assertTrue ( VAR_3 . METHOD_4 ( ) == 0 ) ; <END> TYPE_2 VAR_5 = VAR_6 . METHOD_5 ( TYPE_3 . class ) ; VAR_4 . METHOD_6 ( ) . add ( VAR_5 ) ; assertTrue ( VAR_3 . METHOD_4 ( ) == 1 ) ; } 
public TYPE_3 ( TYPE_1 repo , TYPE_2 VAR_2 , boolean VAR_3 ) { <START> this . VAR_2 = VAR_2 ; this . repo = repo ; this . VAR_3 = VAR_3 ; this . VAR_4 = true ; <END> } 
public void execute ( TYPE_1 monitor ) throws TYPE_2 { TYPE_3 VAR_1 = TYPE_3 . METHOD_1 ( monitor , 2 ) ; VAR_1 . METHOD_2 ( TYPE_4 . bind ( TYPE_7 . TYPE_6 , VAR_4 . METHOD_3 ( ) ) ) ; TYPE_5 VAR_5 = <START> ! VAR_6 ? VAR_4 . METHOD_4 ( ) : METHOD_5 ( ) ; <END> VAR_1 . METHOD_6 ( 1 ) ; METHOD_7 ( VAR_5 ) ; VAR_1 . METHOD_6 ( 1 ) ; } 
public int getInt ( String key ) throws TYPE_1 { String VAR_1 = VAR_2 . get ( key ) ; if ( VAR_1 == null ) { throw new TYPE_1 ( STRING_1 + key + STRING_2 ) ; } <START> return Integer . valueOf ( VAR_1 ) . METHOD_1 ( ) ; <END> } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws InterruptedException , TYPE_3 { try { if ( VAR_1 != null ) { VAR_1 . run ( VAR_2 ) ; } } catch ( TYPE_3 | InterruptedException | TYPE_4 e ) { throw e ; <START> } catch ( TYPE_5 e ) { <END> throw new InterruptedException ( ) ; } catch ( RuntimeException | TYPE_6 e ) { throw new TYPE_3 ( e ) ; } } 
public static boolean METHOD_1 ( String VAR_1 ) { if ( VAR_1 . length ( ) == 0 ) { return false ; } TYPE_1 VAR_2 = null ; try { VAR_2 = new TYPE_1 ( VAR_1 ) ; <START> } catch ( TYPE_2 | IOException VAR_3 ) { <END> return false ; } finally { if ( VAR_2 != null ) { try { VAR_2 . close ( ) ; } catch ( IOException e ) { } } } return true ; } 
public TYPE_1 create ( TYPE_2 VAR_1 , TYPE_3 element ) { String name = element . getName ( ) ; <START> if ( name == null ) <END> return null ; switch ( name ) { case TYPE_4 . TAG : return new TYPE_4 ( element ) ; case TYPE_5 . TAG : return new TYPE_5 ( element ) ; case TYPE_6 . TAG : return new TYPE_6 ( element ) ; case TYPE_7 . TAG : return new TYPE_7 ( element ) ; default : break ; } return null ; } 
private void METHOD_1 ( File VAR_1 , File VAR_2 ) throws IOException { <START> TYPE_1 VAR_3 ; <END> try ( TYPE_2 VAR_4 = new TYPE_2 ( VAR_1 ) ) { VAR_3 = new TYPE_1 ( VAR_2 ) ; byte [ ] buffer = new byte [ INT_1 ] ; int length ; while ( ( length = VAR_4 . read ( buffer ) ) > 0 ) { VAR_3 . write ( buffer , 0 , length ) ; } } VAR_3 . close ( ) ; } 
public static int METHOD_1 ( int VAR_1 ) { switch ( VAR_1 ) { case SWT . VAR_2 : return VAR_2 ; case SWT . VAR_3 : return VAR_3 ; case SWT . VAR_4 : return VAR_4 ; case SWT . VAR_5 : return VAR_5 ; case SWT . VAR_6 : return <START> VAR_6 ; <END> } return VAR_7 ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> super . METHOD_1 ( ) ; } 
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null ) { return false ; } if ( obj instanceof TYPE_1 ) { TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return <START> METHOD_1 ( this . VAR_2 , <END> VAR_1 . VAR_2 ) ; } return false ; } 
private boolean contains ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) return false ; TYPE_2 <START> url = <END> VAR_1 . METHOD_1 ( ) ; if ( url == null ) return false ; for ( TYPE_2 VAR_2 : VAR_3 ) { if ( VAR_2 == url ) { return true ; } } return false ; } 
private void METHOD_1 ( TYPE_1 out , String [ ] list ) throws IOException { if ( list == null ) { out . VAR_1 ( 0 ) ; } else { out . VAR_1 ( list . length ) ; for ( String <START> VAR_2 : <END> list ) { METHOD_2 ( VAR_2 , out ) ; } } } 
public String toString ( ) { <START> TYPE_1 buffer <END> = new TYPE_1 ( ) ; for ( int i = 0 ; i < this . size ; i ++ ) { buffer . append ( TYPE_2 . toString ( this . VAR_1 [ i ] ) ) . append ( STRING_1 ) ; } return buffer . toString ( ) ; } 
public TYPE_1 <START> METHOD_1 ( ) <END> { return METHOD_2 ( new TYPE_2 < TYPE_1 > ( ) { @Override public TYPE_1 run ( ) { VAR_1 . METHOD_3 ( ) ; int offset = VAR_1 . METHOD_4 ( ) . x ; int line = VAR_1 . METHOD_5 ( ) . METHOD_6 ( offset ) ; int VAR_2 = VAR_1 . METHOD_5 ( ) . METHOD_7 ( line ) ; int column = offset - VAR_2 ; return new TYPE_1 ( line , column ) ; } } ) ; } 
protected static TYPE_1 METHOD_1 ( String name ) throws TYPE_2 { TYPE_3 VAR_1 = TYPE_4 . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_1 [ ] VAR_2 = VAR_1 . METHOD_4 ( ) ; for ( TYPE_1 <START> VAR_3 : <END> VAR_2 ) { if ( VAR_3 . getName ( ) . equals ( name ) ) { return VAR_3 ; } } return null ; } 
public TYPE_1 METHOD_1 ( Object element , int VAR_1 ) { String VAR_2 = ( String ) element ; <START> if ( VAR_2 . equals ( STRING_1 ) | VAR_2 . equals ( STRING_2 ) ) { <END> return TYPE_2 . METHOD_2 ( ) . METHOD_3 ( SWT . VAR_3 ) ; } return null ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( ) . METHOD_4 ( this ) ; <END> VAR_1 . METHOD_3 ( ) . METHOD_5 ( this ) ; VAR_1 . METHOD_3 ( ) . METHOD_6 ( this ) ; VAR_2 . METHOD_7 ( VAR_1 . METHOD_3 ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( ( VAR_1 != null ) && ! VAR_1 . METHOD_3 ( ) ) { <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( this ) ; <END> VAR_1 . METHOD_4 ( ) . METHOD_6 ( this ) ; VAR_1 . METHOD_4 ( ) . METHOD_7 ( this ) ; VAR_2 . METHOD_8 ( VAR_1 . METHOD_4 ( ) ) ; } } 
public TYPE_1 [ ] METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) { TYPE_2 VAR_1 = METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; <START> return VAR_1 instanceof TYPE_3 ? ( ( TYPE_3 ) VAR_1 ) . METHOD_1 ( ) <END> : new TYPE_1 [ ] { new TYPE_4 ( VAR_1 ) } ; } return super . METHOD_1 ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { String VAR_2 = METHOD_2 ( ) ; <START> StringBuilder builder = new StringBuilder ( VAR_2 ) ; <END> String VAR_3 = VAR_1 . METHOD_3 ( ) ; builder . append ( VAR_3 ) ; String VAR_4 = builder . toString ( ) ; if ( VAR_4 . contains ( STRING_1 ) ) { VAR_4 = VAR_4 . METHOD_4 ( STRING_2 , STRING_3 ) ; VAR_4 = VAR_4 . METHOD_5 ( STRING_4 , "" ) ; } File file = new File ( VAR_4 ) ; return file . VAR_5 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) ; if ( ( VAR_2 & SWT . VAR_3 ) != 0 ) return ; if ( VAR_1 != null && VAR_1 . METHOD_3 ( ) ) error ( SWT . VAR_4 ) ; this . VAR_1 = VAR_1 ; <START> METHOD_4 ( false ) ; <END> OS . TYPE_2 ( VAR_6 , null , true ) ; } 
<START> public TYPE_1 ( long id , long VAR_2 , String name , long start , long VAR_3 , int VAR_4 ) { <END> super ( id , VAR_2 , name , start , VAR_3 , true ) ; VAR_5 = VAR_4 ; } 
public void METHOD_1 ( final boolean VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = VAR_1 ; if ( VAR_1 ) { <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ( ) - > METHOD_6 ( ) ) ; <END> } else { METHOD_7 ( ) . METHOD_8 ( null ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 context = TYPE_2 . METHOD_2 ( ) ; <START> VAR_1 = context . get ( TYPE_3 . class ) ; <END> VAR_2 = VAR_1 . METHOD_3 ( TYPE_4 . class ) ; VAR_2 . METHOD_4 ( VAR_3 ) ; VAR_2 . METHOD_5 ( ) . add ( STRING_1 ) ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) { return ( ( TYPE_2 ) VAR_1 ) . METHOD_1 ( ) ; } TYPE_3 VAR_2 = <START> TYPE_4 . METHOD_2 ( ( VAR_1 ) , <END> TYPE_3 . class ) ; if ( VAR_2 instanceof TYPE_5 ) { return ( ( TYPE_5 ) VAR_2 ) . getPath ( ) ; } return null ; } 
<START> private boolean METHOD_1 ( TYPE_1 a , TYPE_1 b ) { <END> return a == b ; } 
private void METHOD_1 ( Object VAR_1 ) { List VAR_2 = new ArrayList ( ) ; <START> VAR_3 . VAR_4 . Collections . addAll ( VAR_2 , VAR_5 . METHOD_2 ( VAR_1 ) ) ; <END> VAR_6 . put ( VAR_1 , VAR_2 ) ; } 
public TYPE_3 ( TYPE_1 element ) throws TYPE_2 { String VAR_2 = element . VAR_3 ( VAR_4 ) ; METHOD_1 ( VAR_2 . isEmpty ( ) ? <START> VAR_2 : <END> null ) ; String VAR_5 = element . VAR_3 ( VAR_6 ) ; METHOD_2 ( VAR_5 . isEmpty ( ) ? null : VAR_5 ) ; } 
public void METHOD_1 ( ) { TYPE_1 node = TYPE_4 . TYPE_5 . METHOD_2 ( TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ) ; <START> node . VAR_1 ( TYPE_6 . VAR_3 , true ) ; <END> node . VAR_1 ( TYPE_6 . VAR_4 , true ) ; node . VAR_1 ( TYPE_6 . VAR_5 , true ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 ; <START> METHOD_1 ( new ArrayList < Object > ( Arrays . asList ( VAR_3 . METHOD_2 ( ) ) ) , VAR_2 ) ; <END> } else { super . METHOD_1 ( VAR_1 , VAR_2 ) ; } } 
public void METHOD_1 ( ) throws Exception { int VAR_1 = INT_1 ; int VAR_2 = <START> 2 ; <END> for ( int i = 0 ; i < VAR_1 ; ++ i ) { METHOD_2 ( VAR_2 ) ; } } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> for ( TYPE_2 VAR_3 : VAR_4 ) { <END> VAR_1 . METHOD_3 ( ) . add ( VAR_2 . METHOD_4 ( VAR_3 . getName ( ) ) ) ; } VAR_1 . METHOD_5 ( METHOD_6 ( VAR_5 ) ) ; VAR_1 . METHOD_7 ( VAR_2 . METHOD_4 ( VAR_6 ) ) ; return VAR_1 ; } 
private void METHOD_1 ( File file ) { if ( file . VAR_1 ( ) ) { for ( File <START> VAR_2 : <END> file . VAR_3 ( ) ) { METHOD_1 ( VAR_2 ) ; } } file . VAR_4 ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 [ ] VAR_1 , TYPE_3 [ ] VAR_2 ) throws TYPE_4 { TYPE_1 result = new TYPE_1 ( ) ; TYPE_2 [ ] VAR_3 = METHOD_2 ( VAR_1 ) ; for ( TYPE_3 <START> t : <END> VAR_2 ) { result . VAR_4 ( TYPE_5 . METHOD_3 ( VAR_3 , t ) ) ; } return result ; } 
private static void METHOD_1 ( TYPE_1 resource , List < TYPE_1 > VAR_1 ) throws TYPE_2 { if ( resource instanceof TYPE_3 ) { VAR_1 . add ( resource ) ; return ; } if ( resource instanceof TYPE_4 ) { for ( TYPE_1 <START> VAR_2 : <END> ( ( TYPE_4 ) resource ) . METHOD_2 ( ) ) { METHOD_1 ( VAR_2 , VAR_1 ) ; } } } 
private static String METHOD_1 ( String VAR_1 , String VAR_2 , Boolean VAR_3 ) { String VAR_4 = STRING_1 ; TYPE_1 VAR_5 = new TYPE_1 ( VAR_4 , VAR_4 , VAR_4 ) ; VAR_5 . add ( VAR_1 ) ; String VAR_6 = VAR_3 ? STRING_2 : STRING_3 ; VAR_5 . add ( VAR_6 ) ; VAR_5 . add ( VAR_2 ) ; <START> return VAR_5 . toString ( ) ; <END> } 
public int METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 , IOException { int VAR_2 = 0 ; for ( int index = 0 ; index < VAR_3 . length ; index ++ ) { TYPE_4 filter = VAR_3 [ index ] ; if ( filter != null ) { try { boolean VAR_4 = filter . VAR_5 ( VAR_1 ) ; if ( VAR_4 ) <START> VAR_2 |= ( int ) ( INT_1 < < index ) ; <END> } catch ( TYPE_5 e ) { VAR_3 [ index ] = null ; } } } return VAR_2 ; } 
public boolean METHOD_1 ( Object element , TYPE_1 context ) { <START> if ( VAR_1 . get ( ) ) { <END> return METHOD_2 ( element , context ) != null ; } return false ; } 
public void METHOD_1 ( long id , File VAR_1 ) throws TYPE_1 { final File file = VAR_1 ; if ( file == null ) { throw new TYPE_1 ( STRING_1 ) ; } <START> TYPE_2 stream = VAR_2 . METHOD_2 ( id , VAR_3 - > new TYPE_3 ( this ) ) ; <END> if ( stream instanceof TYPE_3 ) { TYPE_3 VAR_4 = ( TYPE_3 ) stream ; VAR_4 . METHOD_3 ( new TYPE_4 ( stream , file ) ) ; } else { throw new TYPE_1 ( STRING_2 ) ; } } 
public TYPE_3 ( String name , String VAR_2 , int VAR_3 , int VAR_4 , TYPE_1 parent ) { <START> METHOD_1 ( name , VAR_2 ) ; <END> VAR_5 = VAR_3 ; METHOD_2 ( VAR_4 ) ; VAR_6 = false ; VAR_7 = TYPE_2 . getString ( STRING_1 ) ; METHOD_3 ( parent ) ; } 
public static void METHOD_1 ( Path f ) throws IOException { try ( TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( f , TYPE_5 . VAR_3 , TYPE_5 . VAR_4 , TYPE_5 . VAR_5 ) ) { TYPE_2 . METHOD_3 ( f , <START> TYPE_3 . from ( TYPE_4 . METHOD_4 ( ) ) ) ; <END> } } 
protected void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( VAR_2 ) ; <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> } } 
private static List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; if ( VAR_1 instanceof TYPE_3 ) { for ( Object element : ( ( TYPE_4 ) VAR_1 ) . METHOD_2 ( ) ) { if <START> ( element instanceof TYPE_5 ) { <END> VAR_2 . add ( ( ( TYPE_5 ) element ) . METHOD_3 ( ) ) ; } } } return VAR_2 ; } 
public static boolean METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { Map < String , Object > VAR_3 = Collections . VAR_4 ( ) ; <START> VAR_3 . put ( VAR_5 , VAR_1 ) ; <END> return METHOD_2 ( VAR_6 , VAR_2 , VAR_3 ) ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; <END> } 
private boolean METHOD_1 ( Object VAR_1 ) { boolean VAR_2 = VAR_1 != VAR_3 && ! VAR_1 . equals ( VAR_4 ) ; <START> LOG . debug ( STRING_1 , file , VAR_4 , VAR_1 ) ; <END> return VAR_2 ; } 
private void start ( ) { <START> if ( ! VAR_1 . METHOD_1 ( ) ) { <END> if ( VAR_1 instanceof TYPE_1 ) { ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( this ) ; } else if ( VAR_1 instanceof TYPE_2 ) { ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( this ) ; } } } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; VAR_1 = null ; } for ( TYPE_1 VAR_2 : VAR_3 ) { VAR_2 . METHOD_1 ( ) ; <START> } <END> super . METHOD_1 ( ) ; } 
private void METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) { VAR_2 . METHOD_2 ( false ) ; VAR_2 . METHOD_3 ( false ) ; VAR_3 . METHOD_4 ( ) . METHOD_5 ( true ) ; } else { boolean VAR_4 = VAR_5 . METHOD_6 ( VAR_1 ) ; VAR_2 . METHOD_2 ( VAR_4 ) ; VAR_2 . METHOD_3 ( true ) ; VAR_3 . METHOD_4 ( ) . METHOD_5 ( ! VAR_4 ) ; } <START> VAR_6 . METHOD_7 ( ) ; <END> } 
private void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_3 ( TYPE_4 . TYPE_3 ) ; <END> VAR_6 . add ( VAR_1 ) ; } 
public void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> for ( TYPE_1 action : this . VAR_1 ) { action . VAR_2 ( listener ) ; } } 
public static Set < String > METHOD_1 ( List < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) { Set < String > VAR_3 = new HashSet < > ( ) ; for ( int i = 0 ; i < <START> VAR_1 . size ( ) ; <END> i ++ ) { TYPE_1 VAR_4 = VAR_1 . get ( i ) ; if ( VAR_4 == VAR_2 ) { return VAR_3 ; } VAR_3 . add ( CHAR_1 + VAR_4 . getName ( ) . METHOD_2 ( ) + CHAR_2 ) ; } return VAR_3 ; } 
public void METHOD_1 ( ) throws IOException { <START> TYPE_1 id = <END> db . VAR_1 ( STRING_1 ) ; TYPE_2 r = db . VAR_2 ( STRING_1 , STRING_2 ) ; assertEquals ( VAR_3 , r . VAR_4 ( ) ) ; } 
private static TYPE_1 METHOD_1 ( byte [ ] ... <START> table ) throws IOException { <END> List < TYPE_2 > VAR_1 = new ArrayList < > ( table . length ) ; for ( byte [ ] b : table ) { VAR_1 . add ( read ( b ) ) ; } return new TYPE_1 ( VAR_1 ) ; } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) ; <START> TYPE_2 page = new TYPE_2 ( VAR_1 ) ; METHOD_4 ( page ) ; <END> } 
public TYPE_6 ( TYPE_1 resource , String VAR_2 ) { <START> super ( new TYPE_2 ( new TYPE_3 ( resource ) ) , VAR_3 ) ; <END> TYPE_3 VAR_4 = ( TYPE_3 ) ( ( TYPE_2 ) super . METHOD_1 ( ) ) . METHOD_2 ( ) ; VAR_4 . METHOD_3 ( VAR_2 ) ; METHOD_4 ( TYPE_7 . TYPE_5 ) ; METHOD_5 ( TYPE_7 . TYPE_4 ) ; } 
public TYPE_6 ( TYPE_1 resource , String VAR_2 ) { this ( resource ) ; TYPE_2 VAR_3 = ( TYPE_2 ) ( ( TYPE_3 ) super . METHOD_1 ( ) ) . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; METHOD_4 ( TYPE_7 . TYPE_5 ) ; <START> METHOD_5 ( TYPE_7 . TYPE_4 ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { this . VAR_2 . METHOD_2 ( VAR_1 ) ; super . METHOD_3 ( true ) ; <START> super . METHOD_4 ( true ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { this . VAR_2 . METHOD_2 ( VAR_1 ) ; super . METHOD_3 ( true ) ; super . METHOD_4 ( true ) ; <START> System . out . println ( STRING_1 ) ; <END> } 
<START> private <END> TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_1 ; while ( VAR_2 instanceof TYPE_2 ) { VAR_2 = ( ( TYPE_2 ) VAR_2 ) . METHOD_2 ( ) ; } return VAR_2 ; } 
public boolean METHOD_1 ( ) { <START> try { <END> if ( TYPE_1 . METHOD_2 ( ( TYPE_2 ) METHOD_3 ( ) , TYPE_6 . TYPE_8 , TYPE_7 . TYPE_9 , METHOD_4 ( ) ) ) { METHOD_5 ( ) ; METHOD_6 ( ) ; return true ; } return false ; } catch ( Exception ex ) { TYPE_3 . log ( TYPE_4 . class , TYPE_5 . VAR_6 , ex ) ; } return false ; } 
public Map < String , TYPE_1 > METHOD_1 ( String VAR_1 ) throws IOException { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> TYPE_2 . Builder builder = new TYPE_2 . Builder ( VAR_2 . size ( ) ) ; <END> for ( TYPE_1 r : VAR_2 ) { builder . add ( r ) ; } return new TYPE_3 ( VAR_1 , builder . VAR_4 ( ) , TYPE_2 . METHOD_3 ( ) , TYPE_2 . METHOD_3 ( ) ) ; } 
private void METHOD_1 ( boolean value ) { TYPE_1 VAR_1 = null ; try { VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) ; METHOD_3 ( VAR_1 , value ) ; } catch ( IOException | TYPE_3 e ) { LOG . error ( TYPE_4 . format ( TYPE_5 . get ( ) . VAR_2 , <START> VAR_1 , e ) ) ; <END> } } 
public TYPE_8 ( TYPE_1 uri ) { TYPE_2 VAR_2 = TYPE_3 . getInstance ( ) . METHOD_1 ( ) ; try { <START> VAR_2 . METHOD_2 ( ) ; <END> } catch ( IOException | TYPE_4 e ) { LOG . error ( TYPE_5 . format ( TYPE_6 . get ( ) . VAR_3 , VAR_2 , e ) ) ; METHOD_3 ( new TYPE_7 ( ) , uri ) ; return ; } METHOD_3 ( VAR_2 , uri ) ; } 
<START> public static TYPE_1 getInstance ( ) { <END> return TYPE_2 . get ( ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 . METHOD_2 ( ) ) { try { LOG . debug ( STRING_1 , VAR_1 ) ; VAR_1 . METHOD_3 ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( TYPE_2 e ) { throw new RuntimeException ( TYPE_3 . format ( TYPE_4 . get ( ) . VAR_2 , VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) , e ) , e ) ; } } return VAR_1 ; } 
private void add ( String ... VAR_1 ) { if ( VAR_1 != null ) { for ( String VAR_2 : VAR_1 ) { if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { <START> return ; <END> } TYPE_1 node = VAR_3 ; for ( char c : VAR_2 . METHOD_1 ( ) ) { node = node . add ( c ) ; } node . VAR_4 = VAR_2 ; } } } 
protected TYPE_1 METHOD_1 ( Object input ) { <START> if ( input instanceof TYPE_2 ) { input = ( ( TYPE_2 ) input ) . METHOD_2 ( ) ; } if ( input instanceof TYPE_1 ) { return ( TYPE_1 ) input ; } <END> return null ; } 
<START> public TYPE_1 [ ] getParameters ( ) { <END> return VAR_1 . values ( ) . METHOD_1 ( new TYPE_1 [ VAR_1 . values ( ) . size ( ) ] ) ; } 
public TYPE_3 ( Map < String , Object > VAR_2 ) { Map < String , Object > VAR_3 = new HashMap < > ( ) ; VAR_3 . METHOD_1 ( VAR_2 ) ; VAR_4 = TYPE_1 . METHOD_2 ( VAR_3 ) ; VAR_5 = <START> TYPE_2 . METHOD_3 ( TYPE_1 . METHOD_2 ( VAR_3 ) ) ; <END> } 
private void commit ( boolean VAR_1 ) { boolean VAR_2 = false ; METHOD_1 ( false ) ; try { boolean VAR_3 = <START> ! METHOD_2 ( VAR_1 , <END> ( ) - > METHOD_1 ( true ) ) ; VAR_2 = ! VAR_3 ; } catch ( RuntimeException e ) { VAR_2 = true ; TYPE_1 . METHOD_3 ( e . VAR_4 ( ) , e , true ) ; } finally { if ( VAR_2 ) { METHOD_1 ( true ) ; } } } 
private String METHOD_1 ( TYPE_1 obj ) { TYPE_2 VAR_1 = obj . VAR_2 ( ) ; String name = METHOD_2 ( VAR_1 . getId ( ) ) ; <START> if ( TYPE_3 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ) { <END> return name ; } return name + CHAR_1 + METHOD_5 ( VAR_1 . METHOD_4 ( ) ) ; } 
public void METHOD_1 ( ) { if ( Thread . VAR_1 ( ) == VAR_2 ) { throw new IllegalStateException ( STRING_1 ) ; } try { synchronized ( VAR_3 ) { VAR_4 = true ; <START> VAR_3 . METHOD_2 ( ) ; <END> while ( ! VAR_3 . isEmpty ( ) ) { if ( ! VAR_5 ) throw new IllegalStateException ( STRING_2 ) ; VAR_3 . METHOD_3 ( ) ; } VAR_4 = false ; } } catch ( InterruptedException e ) { Thread . VAR_1 ( ) . METHOD_4 ( ) ; } } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { return ! ( VAR_1 instanceof TYPE_3 ) && TYPE_4 . METHOD_2 ( VAR_1 ) instanceof TYPE_5 <START> && ! VAR_2 . METHOD_3 ( ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 . equals ( VAR_2 ) ) { return false ; } else if ( VAR_1 instanceof TYPE_2 && VAR_2 instanceof TYPE_2 ) { <START> if ( ! VAR_1 . METHOD_2 ( ) . isEmpty ( ) && ! VAR_2 . METHOD_2 ( ) . isEmpty ( ) ) { <END> if ( VAR_1 . METHOD_2 ( ) . contains ( VAR_2 ) || VAR_2 . METHOD_2 ( ) . contains ( VAR_1 ) ) { return true ; } } } return false ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 . equals ( VAR_2 ) ) { return false ; } else if ( VAR_1 instanceof TYPE_2 && VAR_2 instanceof TYPE_2 ) { <START> if ( VAR_1 . METHOD_2 ( ) . contains ( VAR_2 ) || VAR_2 . METHOD_2 ( ) . contains ( VAR_1 ) ) { <END> return true ; } } return false ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( this ) ; <START> if ( VAR_2 != null ) <END> VAR_2 . close ( ) ; } 
public boolean METHOD_1 ( Set < TYPE_1 > VAR_1 ) { for ( TYPE_1 filter : VAR_1 ) { if ( filter . VAR_2 ( ) ) { <START> if ( ! VAR_3 . contains ( filter ) ) <END> return false ; } else { if ( VAR_3 . contains ( filter ) ) return false ; } } return true ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; <START> TYPE_1 [ ] VAR_1 = this . VAR_2 . METHOD_3 ( new TYPE_1 [ 0 ] ) ; <END> for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_3 . METHOD_4 ( this ) ; } this . VAR_2 . close ( ) ; VAR_4 . METHOD_1 ( ) ; if ( VAR_5 != null ) VAR_5 . METHOD_1 ( ) ; VAR_6 . METHOD_5 ( this ) ; VAR_7 . METHOD_1 ( ) ; super . METHOD_1 ( ) ; } 
private File METHOD_1 ( TYPE_1 VAR_1 , ANNOTATION_1 String VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) ) { return VAR_1 . METHOD_3 ( ) ; <START> } else { <END> switch ( VAR_2 ) { case STRING_1 : case STRING_2 : case STRING_3 : case STRING_4 : case STRING_5 : return VAR_1 . METHOD_3 ( ) ; default : return VAR_1 . METHOD_4 ( ) ; } } } 
private static void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 ) { TYPE_3 column = VAR_1 . METHOD_2 ( VAR_3 ) ; String [ ] VAR_4 = { <START> VAR_5 , VAR_6 , VAR_7 } ; <END> TYPE_4 VAR_8 = METHOD_3 ( VAR_3 , VAR_9 , VAR_4 , VAR_2 , false ) ; METHOD_4 ( VAR_1 , column , VAR_8 ) ; String [ ] VAR_10 = { VAR_7 , VAR_6 , VAR_5 } ; VAR_8 = METHOD_3 ( VAR_3 , VAR_9 , VAR_10 , VAR_2 , false ) ; METHOD_4 ( VAR_1 , column , VAR_8 ) ; } 
public void log ( TYPE_1 status ) { log ( 0 , status ) ; if ( status . VAR_1 ( ) ) { TYPE_1 [ ] VAR_2 = status . VAR_3 ( ) ; for ( TYPE_1 <START> VAR_4 : <END> VAR_2 ) { log ( 1 , VAR_4 ) ; } } } 
public void log ( TYPE_1 status ) { int VAR_1 = status . VAR_2 ( ) ; log ( status . getMessage ( ) , VAR_1 ) ; if ( status . VAR_3 ( ) != null ) log ( status . VAR_3 ( ) . getMessage ( ) , VAR_1 ) ; TYPE_1 [ ] VAR_4 = status . VAR_5 ( ) ; if ( VAR_4 != null ) for ( TYPE_1 <START> VAR_6 : <END> VAR_4 ) { log ( VAR_6 ) ; } } 
protected void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { if ( VAR_1 == null || VAR_1 . length == 0 ) return ; start ( VAR_2 ) ; METHOD_2 ( VAR_3 , VAR_1 . length ) ; for ( TYPE_1 <START> VAR_4 : <END> VAR_1 ) { METHOD_3 ( VAR_4 ) ; } METHOD_4 ( VAR_2 ) ; } 
private boolean METHOD_1 ( File file ) { if ( file . VAR_1 ( ) ) { File [ ] VAR_2 = file . VAR_3 ( ) ; if ( VAR_2 != null ) { for ( File <START> VAR_4 : <END> VAR_2 ) { METHOD_1 ( new File ( file , VAR_4 . getName ( ) ) ) ; } } } if ( file . VAR_5 ( ) ) { return true ; } return ! file . exists ( ) ; } 
public static void METHOD_1 ( File file ) throws IOException { if ( file . VAR_1 ( ) ) { if ( ! file . VAR_2 ( ) ) throw new IOException ( STRING_1 + file . VAR_3 ( ) + STRING_2 ) ; return ; } File [ ] VAR_4 = file . VAR_5 ( ) ; for ( File <START> VAR_6 : <END> VAR_4 ) { METHOD_1 ( VAR_6 ) ; } if ( ! file . VAR_2 ( ) ) throw new IOException ( STRING_3 + file . VAR_3 ( ) + STRING_2 ) ; return ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 ) { boolean exists = false ; List < TYPE_3 > TYPE_4 = new ArrayList < > ( ) ; VAR_4 . METHOD_2 ( ) . METHOD_3 ( TYPE_5 . TYPE_6 , VAR_1 , VAR_2 , VAR_3 , TYPE_4 : : add ) ; <START> if ( ! TYPE_4 . isEmpty ( ) ) { <END> exists = true ; } return exists ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return false ; } TYPE_2 model = ( TYPE_2 ) METHOD_2 ( ) ; String text = VAR_1 . get ( ) ; try ( TYPE_3 stream = new TYPE_4 ( text . VAR_2 ( TYPE_6 . VAR_4 ) ) ) { model . VAR_5 ( stream , false ) ; } catch ( TYPE_5 e ) { return false ; <START> } catch ( IOException e ) { <END> } return true ; } 
public void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { for ( TYPE_1 group : VAR_1 ) { VAR_2 . remove ( VAR_3 + <START> group . VAR_4 ( ) . toString ( ) ) ; <END> VAR_5 . remove ( group . VAR_4 ( ) ) ; } METHOD_2 ( ) ; } 
protected void METHOD_1 ( ) { if ( VAR_1 != null ) { Iterator < TYPE_1 > e = VAR_1 . iterator ( ) ; TYPE_2 VAR_2 = METHOD_2 ( ) ; while ( e . hasNext ( ) ) { TYPE_1 VAR_3 = e . next ( ) ; VAR_3 . METHOD_3 ( this ) ; VAR_3 . METHOD_4 ( this ) ; if ( VAR_3 . METHOD_2 ( ) == null ) { <START> VAR_3 . METHOD_5 ( VAR_2 ) ; <END> } VAR_3 . METHOD_6 ( ) ; } } } 
public TYPE_2 ( TYPE_1 VAR_2 ) { super ( STRING_1 ) ; <START> METHOD_1 ( true ) ; <END> VAR_3 = VAR_2 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_3 job = new TYPE_3 ( VAR_1 ) ; return job ; <END> } 
private static TYPE_1 METHOD_1 ( Map < TYPE_2 , TYPE_1 > map ) { assertEquals ( 1 , map . size ( ) ) ; <START> for ( TYPE_1 result : map . values ( ) ) { <END> return result ; } throw new TYPE_3 ( STRING_1 ) ; } 
protected boolean METHOD_1 ( TYPE_1 value ) { if ( value . VAR_1 ( ) == TYPE_1 . VAR_2 ) { TYPE_2 VAR_3 = ( TYPE_2 ) value ; String VAR_4 = VAR_3 . METHOD_2 ( ) ; <START> if ( STRING_1 . equals ( VAR_4 ) ) { <END> return true ; } if ( STRING_2 . equals ( VAR_4 ) ) { return true ; } if ( STRING_3 . equals ( VAR_4 ) ) { return true ; } } return false ; } 
public void METHOD_1 ( ) { <START> Object VAR_1 = VAR_2 != null ? VAR_2 : new Object ( ) ; synchronized ( VAR_1 ) { <END> VAR_3 = null ; VAR_2 . clear ( ) ; try { VAR_4 . close ( ) ; } catch ( IOException e ) { } } } 
public boolean METHOD_1 ( ) { final boolean VAR_1 = <START> VAR_2 != null && <END> VAR_2 . size ( ) > 0 ; return VAR_1 ; } 
public void METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { synchronized ( VAR_2 ) { <END> VAR_2 . METHOD_2 ( ) ; } VAR_3 . METHOD_3 ( ) ; VAR_4 . METHOD_3 ( ) ; VAR_5 = null ; VAR_6 = null ; VAR_7 = null ; VAR_2 . clear ( ) ; VAR_8 = 0 ; VAR_1 . clear ( ) ; } } 
public void METHOD_1 ( ) { if <START> ( VAR_1 != null ) { <END> VAR_1 . METHOD_2 ( - 1 ) ; VAR_1 . METHOD_3 ( ) ; } } 
protected void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> synchronized ( this ) { List < TYPE_1 > list = new ArrayList < > ( VAR_1 ) ; for ( TYPE_1 VAR_2 : list ) { try { VAR_2 . close ( ) ; } catch ( IOException e ) { } } VAR_3 = null ; } final TYPE_2 VAR_4 = VAR_5 . METHOD_2 ( ) ; VAR_4 . METHOD_3 ( null ) ; VAR_5 . METHOD_4 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == VAR_2 ) { return ; } synchronized ( VAR_3 ) { <START> METHOD_2 ( ) ; <END> if ( VAR_1 != null ) { VAR_4 = new ArrayList < > ( ) ; VAR_2 = VAR_1 ; VAR_5 = TYPE_2 . create ( VAR_2 . METHOD_3 ( ) ) ; } } } 
<START> protected TYPE_1 <END> METHOD_1 ( ) { final String [ ] VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null && VAR_1 . length > 0 ) { return ( ) - > VAR_1 ; } return null ; } 
<START> public boolean METHOD_1 ( Object element ) { <END> TYPE_1 < Object > VAR_1 = TYPE_2 . of ( VAR_2 . METHOD_2 ( ) ) . map ( filter - > METHOD_3 ( filter , element ) ) . METHOD_4 ( t - > true , TYPE_1 : : and ) ; return TYPE_2 . of ( METHOD_5 ( element ) ) . filter ( VAR_1 ) . METHOD_6 ( ) . isPresent ( ) ; } 
private void METHOD_1 ( ) { <START> if ( VAR_1 . get ( ) != null ) { <END> return ; } if ( ! METHOD_2 ( ) ) { return ; } if ( ! VAR_2 . METHOD_3 ( false , true ) ) { return ; } METHOD_4 ( ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 ) { List < TYPE_3 > TYPE_4 = new ArrayList < > ( ) ; VAR_4 . METHOD_2 ( ) . METHOD_3 ( TYPE_5 . TYPE_6 , VAR_1 , VAR_2 , VAR_3 , <START> TYPE_4 : : add ) ; <END> return ( ! TYPE_4 . isEmpty ( ) ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 configuration ) throws TYPE_3 { TYPE_1 VAR_1 = null ; if ( configuration . VAR_2 ( ) ) { <START> VAR_1 = ( TYPE_1 ) configuration ; <END> } else { VAR_1 = configuration . VAR_3 ( ) ; } return VAR_1 ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) && METHOD_4 ( <END> VAR_1 . METHOD_2 ( ) ) ) || ( VAR_1 . METHOD_5 ( ) . equals ( TYPE_2 . VAR_3 ) && VAR_1 . METHOD_6 ( ) . METHOD_3 ( ) && METHOD_4 ( VAR_1 . METHOD_6 ( ) ) && VAR_1 . METHOD_7 ( ) . METHOD_8 ( ) . equals ( TYPE_3 . VAR_5 ) ) ; } 
private TYPE_1 get ( final TYPE_2 VAR_1 ) { try { return this . VAR_2 . execute ( VAR_1 , this . context ) ; } catch ( IOException e ) { <START> throw new IllegalArgumentException ( ) ; <END> } } 
private TYPE_1 put ( final TYPE_2 VAR_1 ) { try { return this . VAR_2 . execute ( VAR_1 , this . context ) ; } catch ( IOException e ) { <START> throw new IllegalArgumentException ( ) ; <END> } } 
<START> private static TYPE_1 METHOD_1 ( TYPE_2 element ) { TYPE_1 VAR_1 ; TYPE_3 type = METHOD_2 ( element ) ; if ( type instanceof TYPE_4 ) { VAR_1 = TYPE_10 . TYPE_13 . METHOD_3 ( ) ; } else if ( type instanceof TYPE_6 ) { VAR_1 = TYPE_10 . TYPE_12 . METHOD_3 ( ) ; } else if ( type instanceof TYPE_8 ) { VAR_1 = TYPE_10 . TYPE_11 . METHOD_3 ( ) ; } else { VAR_1 = METHOD_4 ( element ) ; } return VAR_1 ; } <END> 
public void METHOD_1 ( Collection < TYPE_1 > VAR_1 , Collection < TYPE_1 > VAR_2 ) throws Exception { List < TYPE_2 > VAR_3 = METHOD_2 ( VAR_1 ) ; <START> for ( TYPE_2 VAR_4 : VAR_3 ) { <END> String VAR_5 = VAR_4 . METHOD_3 ( ) ; VAR_6 . execute ( VAR_7 , VAR_8 , VAR_5 ) ; } String VAR_9 = METHOD_4 ( ) ; METHOD_5 ( VAR_1 , VAR_2 , VAR_9 ) ; METHOD_6 ( VAR_9 ) ; } 
public void start ( TYPE_1 context ) throws Exception { super . start ( context ) ; VAR_1 = this ; try { VAR_2 = TYPE_2 . getInstance ( ) . parse ( TYPE_3 . METHOD_1 ( ) ) ; } catch ( TYPE_4 e ) { METHOD_2 ( STRING_1 , e ) ; <START> throw e ; <END> } } 
<START> public static void run ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { try ( TYPE_3 VAR_3 = new TYPE_3 ( VAR_1 ) ) { VAR_2 . execute ( ) ; <END> } } 
<START> public static <END> String METHOD_1 ( TYPE_1 VAR_1 , int offset ) throws TYPE_2 { int VAR_2 = ( offset == VAR_1 . METHOD_2 ( ) ? offset - 1 : offset ) ; TYPE_3 line = VAR_1 . METHOD_3 ( VAR_2 ) ; int start = line . VAR_3 ( ) ; int VAR_4 = METHOD_4 ( VAR_1 , start , offset + line . VAR_5 ( ) ) ; return VAR_1 . get ( start , VAR_4 - start ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = null ; <START> VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> if ( VAR_2 == null ) { VAR_2 = new TYPE_1 ( ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; } return VAR_2 ; } 
public ANNOTATION_1 TYPE_1 METHOD_1 ( ) { return <START> this . VAR_1 ; <END> } 
public void <START> METHOD_1 ( ANNOTATION_1 <END> TYPE_1 VAR_1 ) { this . VAR_2 = VAR_1 ; this . METHOD_2 ( ) ; } 
public List < ANNOTATION_1 Object > METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; try { <START> return Collections . VAR_2 ( VAR_3 ) ; <END> } finally { VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; } } 
public TYPE_1 [ ] METHOD_1 ( TYPE_2 VAR_1 ) { if ( METHOD_2 ( ) ) { List < TYPE_1 > list = new ArrayList < > ( ) ; for ( Object <START> VAR_2 : <END> VAR_3 ) { TYPE_1 container = ( TYPE_1 ) VAR_2 ; if ( container . contains ( VAR_1 ) ) { list . add ( container ) ; } } return list . VAR_4 ( new TYPE_1 [ list . size ( ) ] ) ; } return null ; } 
private void METHOD_1 ( String string ) { if <START> ( VAR_1 == null ) { <END> VAR_1 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; } VAR_1 . METHOD_3 ( string ) ; VAR_2 . METHOD_4 ( false ) ; METHOD_5 ( string ) ; } 
public void run ( ) { if ( VAR_1 != null ) { for ( TYPE_1 <START> VAR_2 : <END> VAR_1 ) { VAR_2 . container . METHOD_1 ( ) . METHOD_2 ( VAR_2 . VAR_3 , VAR_2 . container . METHOD_3 ( ) ) ; } } } 
public boolean METHOD_1 ( TYPE_1 item ) { for ( TYPE_1 element : VAR_1 ) { <START> TYPE_1 VAR_2 = element ; <END> while ( VAR_2 != null ) { if ( item . equals ( VAR_2 ) ) { return true ; } VAR_2 = VAR_2 . METHOD_2 ( ) ; } } return false ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( ) , SWT . NONE ) ; <END> event = new TYPE_3 ( VAR_1 , STRING_1 , STRING_2 , 0 ) ; VAR_2 = new TYPE_4 ( ) ; } 
public synchronized TYPE_1 [ ] METHOD_1 ( ) { List < TYPE_1 > result = new ArrayList < > ( ) ; for ( Object element : VAR_1 . keySet ( ) ) { <START> TYPE_1 path = ( TYPE_1 ) element ; <END> TYPE_2 node = METHOD_2 ( path ) ; if ( node . VAR_2 ( ) != null ) result . add ( path ) ; } return result . VAR_3 ( new TYPE_1 [ result . size ( ) ] ) ; } 
public synchronized Collection < Object > values ( ) { List < Object > result = new ArrayList < > ( ) ; for ( Object element : VAR_1 . keySet ( ) ) { <START> TYPE_1 path = ( TYPE_1 ) element ; <END> TYPE_2 node = METHOD_1 ( path ) ; if ( node . VAR_2 ( ) != null ) result . add ( node . VAR_2 ( ) ) ; } return result ; } 
public boolean METHOD_1 ( TYPE_1 resource ) { for ( Object element : VAR_1 ) { <START> TYPE_2 VAR_2 = ( TYPE_2 ) element ; <END> if ( VAR_2 != VAR_3 && VAR_2 . contains ( resource ) ) { return true ; } } return false ; } 
private boolean METHOD_1 ( TYPE_1 resource ) { for ( Object element : VAR_1 ) { <START> TYPE_1 VAR_2 = ( TYPE_1 ) element ; <END> if ( METHOD_2 ( VAR_2 , resource ) ) { return true ; } } return false ; } 
private void METHOD_1 ( TYPE_1 < ? extends TYPE_2 , ? extends TYPE_3 > VAR_1 , Map < TYPE_2 , TYPE_3 > map ) { for ( TYPE_2 <START> name : <END> VAR_1 . METHOD_2 ( ) ) map . remove ( name ) ; for ( TYPE_2 key : VAR_1 . METHOD_3 ( ) ) { map . put ( key , VAR_1 . METHOD_4 ( key ) ) ; } for ( TYPE_2 key : VAR_1 . METHOD_5 ( ) ) { map . put ( key , VAR_1 . METHOD_4 ( key ) ) ; } } 
public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { if ( VAR_2 == null ) { String name = TYPE_3 . TYPE_4 ; VAR_2 = METHOD_2 ( VAR_1 , name , true , true , VAR_5 ) ; } else { VAR_2 . METHOD_3 ( ) ; for ( TYPE_1 <START> VAR_6 : <END> VAR_1 ) { VAR_2 . METHOD_4 ( new TYPE_2 ( VAR_6 , VAR_2 ) ) ; } } } 
public void METHOD_1 ( ) { <START> assertTrue ( new File ( db . VAR_1 ( ) , STRING_1 ) . METHOD_2 ( ) ) ; <END> assertTrue ( TYPE_2 . TYPE_3 . METHOD_1 ( db . VAR_1 ( ) , db . VAR_2 ( ) ) ) ; } 
public void METHOD_1 ( ) <START> throws IOException { <END> assertTrue ( new File ( db . VAR_1 ( ) , STRING_1 ) . METHOD_2 ( ) ) ; assertTrue ( TYPE_2 . TYPE_3 . METHOD_1 ( db . VAR_1 ( ) , db . VAR_2 ( ) ) ) ; } 
public long METHOD_1 ( ) { return VAR_1 . map ( VAR_2 - > <START> VAR_2 . METHOD_1 ( ) ) . METHOD_2 ( INT_1 ) ; <END> } 
private static void METHOD_1 ( String VAR_1 , Map < String , String > VAR_2 ) { for ( Object <START> element : <END> System . VAR_3 ( ) . keySet ( ) ) { String VAR_4 = ( String ) element ; if ( VAR_4 . startsWith ( VAR_1 ) && ! VAR_2 . containsKey ( VAR_4 ) ) { VAR_2 . put ( VAR_4 , null ) ; } } } 
public void start ( ANNOTATION_1 TYPE_1 context ) throws Exception { super . start ( context ) ; VAR_1 = this ; try { <START> Class . VAR_2 ( STRING_1 ) ; <END> } catch ( TYPE_2 e ) { return ; } } 
public TYPE_4 ( TYPE_1 VAR_2 , List < ? > VAR_3 , int x , int y ) { super ( VAR_2 , TYPE_5 . VAR_5 . METHOD_1 ( ) , x , y ) ; METHOD_2 ( ) . METHOD_3 ( TYPE_5 . VAR_5 . METHOD_4 ( ) ) ; <START> TYPE_2 . METHOD_5 ( VAR_3 ) ; <END> VAR_6 = new TYPE_3 ( METHOD_2 ( ) , VAR_3 ) ; METHOD_6 ( VAR_3 ) ; } 
protected TYPE_1 [ ] METHOD_1 ( Object [ ] VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( Object element : VAR_1 ) { <START> if ( element instanceof TYPE_2 ) VAR_2 . add ( ( ( TYPE_2 ) element ) . METHOD_2 ( ) ) ; <END> } return VAR_2 . METHOD_3 ( new TYPE_1 [ VAR_2 . size ( ) ] ) ; } 
protected List < Object > METHOD_1 ( ) { <START> ArrayList < Object > <END> VAR_1 = new ArrayList < > ( ) ; VAR_1 . add ( new TYPE_1 ( METHOD_2 ( ) ) ) ; VAR_1 . addAll ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) ; return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { if <START> ( VAR_1 == null ) { <END> VAR_1 = METHOD_2 ( ) ; } return VAR_1 ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { switch ( VAR_2 ) { case TYPE_2 . VAR_4 : case TYPE_2 . VAR_5 : <START> if ( VAR_1 . METHOD_2 ( ) < TYPE_1 . VAR_6 ) { <END> return false ; } break ; case TYPE_2 . VAR_7 : return VAR_1 . METHOD_3 ( ) ; } return true ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { switch ( VAR_2 ) { case TYPE_2 . VAR_4 : case TYPE_2 . VAR_5 : if ( VAR_1 . METHOD_2 ( ) < TYPE_1 . VAR_6 ) { return false ; } break ; case TYPE_2 . VAR_7 : <START> if ( ! VAR_1 . METHOD_3 ( ) ) { <END> return false ; } } return true ; } 
public boolean METHOD_1 ( ) { <START> if ( this . VAR_1 == VAR_2 . TYPE_1 && this . VAR_4 ) { <END> return true ; } return false ; } 
public boolean METHOD_1 ( String VAR_1 ) { String [ ] VAR_2 = METHOD_2 ( ) ; for ( String <START> VAR_3 : <END> VAR_2 ) { if ( VAR_3 . equals ( VAR_1 ) ) return true ; } return false ; } 
void METHOD_1 ( ) { if ( VAR_1 == null ) return ; VAR_2 = new HashMap < > ( ) ; for ( String <START> element : <END> VAR_1 ) { File file = new File ( element ) ; if ( file . exists ( ) ) { if ( ! file . VAR_3 ( ) ) { if ( file . VAR_4 ( ) . METHOD_2 ( STRING_1 ) ) { VAR_2 . put ( file , METHOD_3 ( file ) ) ; } } else { METHOD_4 ( file ) ; } } } } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 { if ( VAR_4 != null && VAR_4 . length > 0 ) { for ( TYPE_5 <START> VAR_5 : <END> VAR_4 ) { if ( VAR_2 . METHOD_2 ( VAR_5 ) ) { VAR_1 . add ( VAR_5 , VAR_2 ) ; } } } } 
private TYPE_1 < List < ? extends TYPE_2 > > METHOD_1 ( ANNOTATION_1 TYPE_3 VAR_1 ) { TYPE_4 VAR_2 = TYPE_5 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null ) { TYPE_6 VAR_3 = new TYPE_6 ( new TYPE_7 ( VAR_2 . toString ( ) ) ) ; return TYPE_8 . METHOD_3 ( VAR_1 , VAR_4 - > VAR_4 . METHOD_4 ( ) != null ) . METHOD_5 ( VAR_5 - > METHOD_6 ( VAR_5 , VAR_1 , VAR_3 ) ) ; <START> } else { <END> return null ; } } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 monitor ) { super ( TYPE_3 . class , TYPE_7 . VAR_4 , 0 , TYPE_8 . VAR_6 , TYPE_8 . TYPE_5 . VAR_8 ) ; VAR_9 = VAR_2 ; long VAR_10 = VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) ; VAR_11 = VAR_10 / VAR_12 ; <START> VAR_13 = TYPE_4 . METHOD_3 ( monitor , VAR_12 + 2 ) ; <END> } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 monitor ) { super ( TYPE_3 . class , TYPE_7 . VAR_4 , 0 , TYPE_8 . VAR_6 , TYPE_8 . TYPE_5 . VAR_8 ) ; VAR_9 = VAR_2 ; long VAR_10 = VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) ; <START> VAR_11 = Math . max ( VAR_12 , VAR_10 / VAR_12 ) ; <END> VAR_13 = TYPE_4 . METHOD_3 ( monitor , VAR_12 + 2 ) ; } 
<START> protected TYPE_1 METHOD_1 ( int VAR_1 ) { <END> TYPE_1 data = new TYPE_1 ( TYPE_1 . VAR_2 | TYPE_1 . VAR_3 | TYPE_1 . VAR_4 | TYPE_1 . VAR_5 ) ; data . VAR_6 = VAR_1 ; return data ; } 
public TYPE_1 < TYPE_2 > stream ( ) { return <START> Arrays . stream ( METHOD_1 ( ) . METHOD_2 ( ) ) . map ( VAR_1 - > METHOD_3 ( VAR_1 ) ) ; <END> } 
public <START> ANNOTATION_1 Long <END> METHOD_1 ( int x ) { return TYPE_1 . METHOD_2 ( ( TYPE_2 < ANNOTATION_1 Long > ) ( ) - > { TYPE_3 VAR_1 = VAR_2 . METHOD_3 ( ) ; TYPE_4 p = new TYPE_4 ( x , VAR_1 . y + VAR_1 . VAR_3 / 2 ) ; if ( ! VAR_1 . contains ( p ) ) { return null ; } return VAR_2 . METHOD_4 ( x ) ; } ) ; } 
public TYPE_8 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 results , TYPE_4 VAR_4 , TYPE_5 VAR_5 , TYPE_6 VAR_6 , boolean VAR_7 , TYPE_7 VAR_8 ) { this . results = results ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_4 = VAR_4 ; this . VAR_9 = new HashMap < > ( ) ; <START> VAR_9 . put ( VAR_5 . METHOD_1 ( ) , this . VAR_4 ) ; <END> } 
int METHOD_1 ( ) { <START> return VAR_1 + 2 * 4 ; <END> } 
protected void METHOD_1 ( TYPE_1 project , TYPE_2 monitor , boolean VAR_1 ) throws TYPE_3 { if ( METHOD_2 ( ) instanceof TYPE_4 ) { TYPE_4 VAR_2 = ( TYPE_4 ) METHOD_2 ( ) ; <START> if ( VAR_2 . METHOD_3 ( ) != null ) { <END> TYPE_5 . METHOD_4 ( ) . METHOD_5 ( project , VAR_2 . METHOD_3 ( ) , monitor ) ; } else { TYPE_5 . METHOD_4 ( ) . METHOD_6 ( project , monitor , VAR_2 . METHOD_7 ( ) ) ; } } } 
public void METHOD_1 ( TYPE_1 monitor , String VAR_1 ) throws TYPE_2 { Object [ ] VAR_2 = METHOD_2 ( ) ; int VAR_3 = VAR_2 . length ; if ( VAR_3 > 0 ) { if ( monitor == null ) { monitor = new TYPE_3 ( ) ; } TYPE_4 VAR_4 = TYPE_4 . METHOD_3 ( monitor , 1 ) ; <START> VAR_4 . METHOD_4 ( TYPE_5 . METHOD_5 ( VAR_5 ) ) ; <END> METHOD_6 ( VAR_2 , VAR_4 . split ( 1 ) , VAR_1 ) ; } } 
public TYPE_1 METHOD_1 ( int index ) { METHOD_2 ( ) ; if <START> ( 0 > index || <END> index >= VAR_1 . size ( ) ) { SWT . error ( SWT . VAR_2 ) ; } return VAR_1 . get ( index ) . VAR_3 ; } 
public static < T > T run ( TYPE_1 < T > VAR_1 ) { Assert . VAR_2 ( VAR_1 ) ; try { return VAR_1 . METHOD_1 ( ) ; } catch ( Exception | TYPE_2 | TYPE_3 e ) { METHOD_2 ( VAR_1 , e ) ; } <START> return null ; <END> } 
<START> protected StringBuilder METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , <END> TYPE_3 VAR_3 ) { return METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , null ) ; } 
public TYPE_1 ( ) { <START> super ( ) ; <END> } 
public Optional < String > METHOD_1 ( ) { <START> return Optional . VAR_1 ( VAR_2 ) ; <END> } 
private void METHOD_1 ( File VAR_1 ) throws IOException { try ( TYPE_1 is = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_5 . VAR_3 ) . METHOD_5 ( ) ) { <START> TYPE_3 VAR_4 = new TYPE_4 ( VAR_1 ) ; <END> byte [ ] buf = new byte [ INT_1 ] ; while ( true ) { int VAR_5 = is . read ( buf ) ; if ( VAR_5 <= 0 ) break ; VAR_4 . write ( buf , 0 , VAR_5 ) ; } VAR_4 . close ( ) ; } } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( ) ; for ( String [ ] element : VAR_1 ) { VAR_2 . add ( element [ 0 ] ) ; } VAR_2 . METHOD_4 ( ) . METHOD_5 ( ( ) - > { VAR_2 . METHOD_6 ( 0 ) ; METHOD_7 ( ) ; } ) ; <START> VAR_3 . METHOD_8 ( null ) ; <END> } 
public boolean METHOD_1 ( ) { TYPE_1 . getInstance ( ) . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <START> VAR_1 . METHOD_1 ( null ) ; <END> return super . METHOD_1 ( ) ; } 
public boolean METHOD_1 ( Object VAR_1 , String VAR_2 , Object [ ] args , Object VAR_3 ) { if ( VAR_2 == null ) <START> return false ; <END> switch ( VAR_2 ) { case STRING_1 : return STRING_1 . equals ( VAR_3 ) ; case STRING_2 : return STRING_3 . equals ( VAR_3 ) ; case STRING_4 : return STRING_3 . equals ( VAR_3 ) ; case STRING_5 : return STRING_3 . equals ( VAR_3 ) ; default : break ; } Assert . VAR_4 ( false ) ; return false ; } 
private String METHOD_1 ( ) { StringBuilder VAR_1 = new StringBuilder ( ) ; for ( TYPE_1 uri : result . VAR_2 ( ) ) { String VAR_3 = result . VAR_4 ( uri ) ; if ( VAR_3 != null && VAR_3 . length ( ) > 0 ) { <START> if ( VAR_1 . length ( ) > 0 ) <END> VAR_1 . append ( System . VAR_5 ( ) ) ; VAR_1 . append ( VAR_3 ) ; } } return VAR_1 . toString ( ) ; } 
public TYPE_2 ( final TYPE_1 VAR_2 ) { <START> this . VAR_2 = VAR_2 ; this . index = VAR_2 . METHOD_1 ( ) . size ( ) - 1 ; this . name = VAR_3 ; <END> } 
public TYPE_3 ( final TYPE_1 VAR_2 ) { <START> this . VAR_3 = TYPE_2 . getInstance ( ) . getType ( STRING_1 ) ; this . VAR_2 = VAR_2 ; this . name = VAR_4 ; this . index = VAR_2 . METHOD_1 ( ) . size ( ) - 1 ; <END> } 
protected void METHOD_1 ( ) { METHOD_2 ( ) ; TYPE_1 VAR_1 = ( TYPE_1 ) this . VAR_2 [ this . VAR_3 ] ; <START> VAR_1 . VAR_4 |= TYPE_3 . TYPE_2 ; <END> } 
public boolean METHOD_1 ( ) { <START> return ( this . VAR_1 & ( TYPE_1 . TYPE_2 | TYPE_1 . TYPE_3 | TYPE_1 . TYPE_4 | TYPE_1 . TYPE_5 | TYPE_7 . TYPE_6 ) ) == 0 ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 . size ( ) == 0 ) { <END> return null ; } return new TYPE_1 ( VAR_1 . get ( 0 ) . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) , VAR_2 . METHOD_5 ( 0 , 0 ) , METHOD_6 ( ) ) ; } 
public static TYPE_1 [ ] METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) TYPE_2 . METHOD_2 ( ) ; switch ( VAR_1 ) { case VAR_3 : return new TYPE_1 [ 0 ] ; case VAR_4 : return METHOD_3 ( VAR_2 . METHOD_1 ( ) ) ; case VAR_5 : return METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; default : break ; } <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> } 
private int METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) return 0 ; <START> <END> switch ( VAR_1 ) { case VAR_2 : return VAR_3 ; case VAR_4 : return VAR_5 ; case VAR_6 : return VAR_7 ; case VAR_8 : return VAR_9 ; default : break ; } return 0 ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; <START> <END> for ( Iterator < Long > iterator = VAR_4 . METHOD_2 ( ) . METHOD_3 ( TYPE_4 . TYPE_5 , VAR_1 , VAR_2 . getId ( ) ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Long VAR_7 = iterator . next ( ) ; VAR_3 . add ( TYPE_1 . valueOf ( VAR_7 ) ) ; } return VAR_3 ; } 
public synchronized void METHOD_1 ( ) { super . METHOD_1 ( ) ; while <START> ( VAR_1 . size ( ) >= 1 ) { <END> VAR_2 . next ( ) ; } VAR_1 . put ( VAR_3 ) ; VAR_1 . METHOD_2 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if <START> ( VAR_1 != null ) { <END> VAR_1 . put ( VAR_2 , VAR_3 ) ; VAR_1 . put ( VAR_4 , VAR_5 ) ; } } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if <START> ( VAR_1 != null ) { <END> VAR_2 = VAR_1 . METHOD_3 ( VAR_3 ) ; VAR_4 = VAR_1 . METHOD_3 ( VAR_5 ) ; } } 
public static void error ( int VAR_1 , Throwable VAR_2 ) { <START> error ( VAR_1 , VAR_2 , STRING_1 ) ; <END> } 
private void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( VAR_2 ) ) ; <START> VAR_2 . METHOD_4 ( e - > { <END> VAR_1 . METHOD_5 ( ) ; } ) ; } 
public TYPE_2 ( String text , List < TYPE_1 > VAR_2 , List < String > VAR_3 ) { this . text = text ; <START> this . VAR_2 = VAR_2 ; <END> this . VAR_4 = VAR_3 ; } 
public TYPE_1 < ? > METHOD_1 ( TYPE_2 p , TYPE_3 VAR_1 ) throws IOException , <START> TYPE_4 { <END> return VAR_2 . get ( ) . METHOD_2 ( p . VAR_3 ( String . VAR_4 ) ) ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( this ) ; <START> VAR_2 . remove ( VAR_3 ) ; <END> VAR_4 . clear ( ) ; VAR_3 = null ; } 
private static boolean METHOD_1 ( ) { synchronized ( VAR_1 ) { return VAR_1 . size ( ) <START> >= 2 ; <END> } } 
protected void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 , TYPE_3 { METHOD_2 ( VAR_2 , name - > { if <START> ( name . equals ( TYPE_6 . TYPE_7 ) ) <END> { TYPE_5 VAR_3 = METHOD_3 ( ) ; TYPE_5 VAR_4 = METHOD_4 ( VAR_1 , VAR_3 . getName ( ) , true ) ; if ( null != VAR_4 ) { VAR_4 . METHOD_5 ( VAR_3 . getValue ( ) ) ; } return true ; } return false ; } ) ; } 
protected < T extends TYPE_1 > void METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 < T > VAR_2 , String VAR_3 ) throws TYPE_4 , TYPE_5 { METHOD_2 ( VAR_3 , name - > { if <START> ( name . equals ( TYPE_7 . TYPE_8 ) ) { <END> T connection = METHOD_3 ( VAR_1 ) ; if ( null != connection ) { VAR_2 . add ( connection ) ; } METHOD_4 ( TYPE_7 . TYPE_8 ) ; return true ; } return false ; } ) ; } 
private void METHOD_1 ( final TYPE_1 type ) throws TYPE_2 , TYPE_3 { TYPE_4 VAR_1 = TYPE_8 . VAR_3 . METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; METHOD_4 ( TYPE_6 . VAR_5 , name - > { if <START> ( name . equals ( TYPE_6 . TYPE_7 ) ) { <END> METHOD_5 ( VAR_1 , type ) ; return true ; } return false ; } ) ; type . VAR_6 ( ) . METHOD_6 ( ) . add ( VAR_1 ) ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { String text = METHOD_2 ( TYPE_5 . VAR_3 ) ; if <START> ( text != null ) { <END> VAR_1 . setText ( text ) ; } else { throw new TYPE_2 ( Messages . TYPE_4 ) ; } METHOD_3 ( TYPE_5 . VAR_5 ) ; } 
private void METHOD_1 ( final TYPE_1 type ) throws TYPE_2 , TYPE_3 { METHOD_2 ( TYPE_6 . VAR_2 , name - > { if <START> ( name . equals ( TYPE_6 . TYPE_7 ) ) <END> { TYPE_5 v = METHOD_3 ( ) ; type . VAR_3 ( ) . add ( v ) ; return true ; } return false ; } ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { METHOD_2 ( TYPE_5 . VAR_3 , name - > { if <START> ( name . equals ( TYPE_5 . TYPE_6 ) ) <END> { if ( METHOD_3 ( ) ) { METHOD_4 ( VAR_1 ) ; } else { METHOD_5 ( VAR_1 ) ; } METHOD_6 ( TYPE_5 . TYPE_6 ) ; return true ; } return false ; } ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_2 VAR_4 , int VAR_5 , int VAR_6 ) { VAR_7 = VAR_2 ; VAR_8 = VAR_6 ; if ( VAR_3 == null ) { VAR_9 = VAR_10 ; <START> } else if ( VAR_3 . METHOD_1 ( ) != VAR_5 ) { <END> VAR_9 = new TYPE_2 ( VAR_3 . METHOD_2 ( ) , VAR_3 . METHOD_3 ( ) , VAR_3 . METHOD_4 ( ) , VAR_5 ) ; } else { VAR_9 = VAR_3 ; } VAR_11 = VAR_4 ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( VAR_2 . x - 1 , VAR_2 . y - 1 , VAR_2 . VAR_3 + 2 , VAR_2 . VAR_4 + 2 , VAR_5 , <END> VAR_5 ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 != <START> null ) <END> VAR_1 . VAR_2 = VAR_1 . buf . length ; } 
public <START> TYPE_1 ( org . VAR_2 . VAR_3 . TYPE_2 <END> VAR_5 ) { VAR_6 = VAR_5 ; } 
public TYPE_7 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final TYPE_3 VAR_4 , TYPE_4 VAR_5 ) { super ( VAR_2 . METHOD_1 ( ) , VAR_4 , VAR_3 ) ; this . VAR_5 = VAR_5 ; this . VAR_2 = VAR_2 ; <START> VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( new TYPE_5 ( ) { @Override public void METHOD_4 ( TYPE_6 e ) { VAR_6 = METHOD_1 ( ) . METHOD_2 ( ) . METHOD_5 ( e . x , e . y ) ; } } ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( TYPE_2 . class ) ; <START> TYPE_3 VAR_3 = METHOD_3 ( ) ; for ( String id : VAR_4 ) { <END> METHOD_4 ( VAR_2 , VAR_3 , id ) ; } super . METHOD_1 ( VAR_1 ) ; } 
protected void METHOD_1 ( ) { VAR_1 = TYPE_1 . VAR_2 ; for ( TYPE_1 VAR_3 : TYPE_1 . values ( ) ) { <START> if ( VAR_3 . METHOD_2 ( ) . equals ( VAR_4 . VAR_5 ) ) { <END> VAR_1 = VAR_3 ; } } } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = METHOD_2 ( ) ; <END> TYPE_3 VAR_2 = METHOD_3 ( ) ; if ( VAR_2 != null && VAR_1 != null ) { TYPE_4 VAR_3 = VAR_2 . METHOD_1 ( VAR_1 ) ; if ( VAR_3 instanceof TYPE_1 ) { return ( TYPE_1 ) VAR_3 ; } } return null ; } 
public void METHOD_1 ( ) throws IOException { <START> try ( TYPE_1 VAR_1 = response . VAR_2 ( ) ) { <END> try ( TYPE_2 is = METHOD_2 ( ) ) { if ( is != null ) { Utils . VAR_3 ( is , VAR_1 ) ; } VAR_1 . METHOD_3 ( ) ; } } } 
switch ( VAR_1 ) { case STRING_1 : VAR_2 = 4 ; break ; case STRING_2 : VAR_2 = INT_1 ; break ; <START> case STRING_3 : <END> default : VAR_2 = 3 ; break ; } 
public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 == null ) { <END> TYPE_2 VAR_2 = METHOD_3 ( ) ; return VAR_2 != null ? VAR_2 . METHOD_1 ( ) : false ; } return VAR_1 . METHOD_1 ( ) ; } 
int METHOD_1 ( int VAR_1 ) { TYPE_1 line = METHOD_2 ( VAR_1 ) ; if ( line . VAR_2 ( ) ) { if ( METHOD_3 ( VAR_1 ) ) { <START> return Math . VAR_3 ( VAR_4 ) ; <END> } else { line . VAR_5 = METHOD_1 ( ) + METHOD_4 ( VAR_1 ) ; } } return line . VAR_5 ; } 
public TYPE_4 ( final TYPE_1 repo , final TYPE_2 c , final TYPE_3 entry ) { VAR_2 = repo ; VAR_3 = entry ; commit = c ; VAR_4 = null ; <START> } <END> 
public static void METHOD_1 ( TYPE_1 configuration ) throws TYPE_2 { <START> TYPE_1 VAR_1 = METHOD_2 ( configuration ) ; <END> METHOD_3 ( VAR_1 , TYPE_3 . VAR_3 , TYPE_3 . VAR_4 ) ; METHOD_3 ( VAR_1 , TYPE_3 . VAR_5 , TYPE_3 . VAR_6 ) ; METHOD_3 ( VAR_1 , TYPE_3 . VAR_7 , TYPE_3 . VAR_8 ) ; } 
protected void METHOD_1 ( String VAR_1 ) { <START> boolean VAR_2 = VAR_3 <= 1 ; <END> if ( METHOD_2 ( VAR_1 ) ) { } else if ( VAR_2 ) { METHOD_3 ( ) ; } } 
public Object METHOD_1 ( Object element ) { <START> if ( element instanceof TYPE_1 || element instanceof TYPE_2 ) { <END> return VAR_1 . get ( element ) ; } return null ; } 
private TYPE_1 METHOD_1 ( String path ) { return VAR_1 . METHOD_2 ( path , <START> key - > { TYPE_1 VAR_2 = new TYPE_1 ( key ) ; return VAR_2 ; } ) ; <END> } 
public static synchronized void METHOD_1 ( String message , Throwable ex ) { <START> if ( TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) && VAR_1 ) { <END> METHOD_2 ( ) . METHOD_4 ( ) . warn ( message , ex ) ; } } 
public static synchronized void METHOD_1 ( String message ) { <START> if ( TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) && VAR_1 ) { <END> METHOD_2 ( ) . METHOD_4 ( ) . info ( message ) ; } } 
public TYPE_3 ( TYPE_1 parent , int VAR_2 , TYPE_2 filter , boolean VAR_3 ) { <START> super ( parent , VAR_2 , filter , VAR_3 ) ; <END> } 
private TYPE_1 ( ) { VAR_2 = new Thread ( this : : METHOD_1 ) ; VAR_2 . METHOD_2 ( true ) ; VAR_2 . start ( ) ; <START> } <END> 
public void set ( TYPE_1 node , String filter ) { try { <START> VAR_1 . METHOD_1 ( ) ; <END> } catch ( InterruptedException e ) { Thread . VAR_2 ( ) . METHOD_2 ( ) ; return ; } cache . VAR_3 ( node . VAR_4 ( ) . METHOD_3 ( ) , VAR_5 - > new TYPE_2 < > ( ) ) . put ( node . getType ( ) , filter ) ; node . VAR_6 ( filter ) ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = ( TYPE_2 ) VAR_2 . METHOD_2 ( ) . METHOD_1 ( TYPE_5 . VAR_4 , Messages . TYPE_4 ) ; VAR_1 . METHOD_3 ( true ) ; VAR_1 . METHOD_4 ( 0 ) ; <START> TYPE_3 VAR_6 = METHOD_5 ( VAR_7 ) ; VAR_1 . METHOD_6 ( VAR_6 ) ; <END> return VAR_1 ; } 
public boolean METHOD_1 ( TYPE_1 node ) { TYPE_2 VAR_1 = node . VAR_2 ( ) ; if ( VAR_1 == null ) return false ; TYPE_3 VAR_3 = METHOD_2 ( ) ; int VAR_4 = VAR_1 . METHOD_3 ( ) ; int VAR_5 = VAR_4 + VAR_1 . METHOD_4 ( ) ; if <START> ( ( ( VAR_4 >= VAR_3 . METHOD_5 ( ) ) || ( VAR_3 . METHOD_6 ( ) >= VAR_5 ) ) ) <END> return false ; return super . METHOD_1 ( node ) ; } 
private void METHOD_1 ( ) { if <START> ( ( null != VAR_1 ) && <END> ( null != VAR_1 . METHOD_2 ( ) ) && ! VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) { VAR_2 . setText ( VAR_1 . METHOD_2 ( ) ) ; } VAR_2 . setText ( STRING_1 ) ; METHOD_3 ( ) ; METHOD_4 ( ) ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 request ) { if <START> ( METHOD_2 ( ) instanceof <END> TYPE_3 ) { return new TYPE_4 ( ( TYPE_3 ) METHOD_2 ( ) . METHOD_3 ( ) ) ; } return null ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 info = null ; try { final TYPE_3 VAR_2 = TYPE_5 . VAR_4 . METHOD_2 ( ) ; final Object obj = VAR_1 . execute ( VAR_2 ) ; if ( obj instanceof TYPE_1 ) info = ( TYPE_1 ) obj ; } catch ( Exception e ) { <START> return ( TYPE_1 ) TYPE_4 . METHOD_3 ( e ) ; <END> } return info ; } 
private static void write ( String content , File file , TYPE_1 VAR_1 ) throws IOException { <START> TYPE_2 writer = new TYPE_3 ( new TYPE_4 ( file ) , VAR_1 ) ; <END> writer . write ( content ) ; writer . close ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { VAR_1 . METHOD_2 ( true ) ; <START> VAR_1 . METHOD_3 ( new TYPE_3 ( ) { <END> @Override public void run ( boolean VAR_2 , boolean VAR_3 , TYPE_4 VAR_4 ) throws TYPE_5 , InterruptedException { VAR_4 . run ( new TYPE_6 ( ) ) ; } } ) ; return VAR_1 . METHOD_4 ( TYPE_10 . VAR_6 , new TYPE_7 ( new TYPE_8 ( VAR_1 . METHOD_5 ( ) , TYPE_8 . VAR_7 ) , TYPE_9 . VAR_9 ) , true ) ; } 
public TYPE_1 ( ) { <START> this . VAR_2 = true ; <END> } 
private static void METHOD_1 ( ) { File VAR_1 = new File ( VAR_2 ) ; <START> VAR_1 . METHOD_2 ( ) ; <END> File file = new File ( VAR_2 + STRING_1 ) ; file . VAR_3 ( ) ; } 
public void METHOD_1 ( ) throws Exception { <START> server = METHOD_2 ( false ) ; <END> TYPE_1 VAR_1 = METHOD_3 ( VAR_2 ) ; String VAR_3 = STRING_1 ; METHOD_4 ( null , - 1 , VAR_1 , VAR_3 ) ; } 
public Set < String > METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public Builder METHOD_1 ( int VAR_1 ) throws IllegalArgumentException { <START> METHOD_2 ( STRING_1 , VAR_1 ) ; <END> if ( VAR_1 < - 1 ) { throw VAR_2 . METHOD_3 ( VAR_1 ) ; } this . VAR_1 = VAR_1 ; return this ; } 
public static void METHOD_1 ( ) throws Exception { File VAR_1 = new File ( VAR_2 ) ; if ( VAR_1 . exists ( ) == false ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } TYPE_1 . METHOD_3 ( TYPE_2 . get ( VAR_1 + VAR_3 + STRING_1 ) , TYPE_2 . get ( VAR_1 + VAR_3 ) , TYPE_3 . VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 url ) { if ( ! METHOD_2 ( url ) ) { return null ; } <START> Map < String , TYPE_3 > VAR_2 = VAR_3 . get ( url ) ; <END> if ( VAR_2 == null ) { return null ; } TYPE_1 VAR_4 = VAR_2 . get ( VAR_1 ) ; if ( VAR_4 == null ) { log . warn ( STRING_1 + VAR_1 ) ; return null ; } return VAR_4 ; } 
public TYPE_3 ( ) { this . VAR_2 = new TYPE_1 < > ( ) ; <START> this . VAR_3 = true ; <END> this . VAR_4 = true ; this . VAR_5 = TYPE_2 . NONE ; } 
public boolean equals ( Object VAR_1 ) { if ( ! ( VAR_1 instanceof TYPE_1 ) ) return false ; TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 ; return VAR_2 == this || Arrays . equals ( VAR_3 , VAR_2 . VAR_3 ) && VAR_4 == VAR_2 . VAR_4 && Arrays . equals ( VAR_5 , VAR_2 . VAR_5 ) <START> && VAR_6 == VAR_2 . VAR_6 ; <END> } 
public TYPE_4 ( TYPE_1 client , TYPE_2 VAR_2 ) { <START> super ( ) ; <END> this . client = client ; this . VAR_2 = VAR_2 ; VAR_3 = new TYPE_3 ( ) ; } 
public void METHOD_1 ( ) throws Exception { <START> assertTrue ( <END> new TYPE_1 ( 1 , STRING_1 , STRING_2 , STRING_3 ) . equals ( new TYPE_1 ( 1 , STRING_1 , STRING_2 , STRING_3 ) ) ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 properties = new TYPE_1 ( ) ; try { properties . VAR_2 ( new TYPE_2 ( VAR_1 ) ) ; } catch ( IOException e ) { e . VAR_3 ( ) ; } <START> return properties ; <END> } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 state : VAR_1 . METHOD_2 ( ) ) { TYPE_3 VAR_2 = VAR_1 . get ( state . getId ( ) ) ; for ( TYPE_4 VAR_3 : VAR_2 . METHOD_3 ( ) ) { if ( VAR_3 . getName ( ) . equals ( VAR_4 ) ) return VAR_2 . getId ( ) ; } } <START> throw new RuntimeException ( STRING_1 ) ; <END> } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 . list ( ) ) { if ( VAR_2 . getName ( ) . equals ( VAR_3 ) ) return VAR_2 . getId ( ) ; } <START> throw new RuntimeException ( STRING_1 ) ; <END> } 
public static void METHOD_1 ( String [ ] args ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; try { <START> VAR_1 . METHOD_2 ( args ) ; <END> VAR_1 . METHOD_3 ( args [ 2 ] , args [ 3 ] ) ; VAR_1 . METHOD_4 ( args [ 3 ] ) ; } catch ( Exception e ) { e . VAR_2 ( ) ; } finally { VAR_1 . close ( ) ; } } 
public TYPE_1 call ( ) throws Exception { TYPE_2 VAR_1 = VAR_2 . METHOD_1 ( VAR_3 . METHOD_2 ( ) ) . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) <START> . METHOD_5 ( "" ) <END> . build ( ) ; String VAR_4 = VAR_2 . METHOD_6 ( container , VAR_1 ) ; TYPE_1 VAR_5 = new TYPE_1 ( VAR_3 . METHOD_2 ( ) , VAR_3 . METHOD_4 ( ) , VAR_4 ) ; return VAR_5 ; } 
private void METHOD_1 ( File VAR_1 , String VAR_2 , List < TYPE_1 > VAR_3 ) { for ( File VAR_4 : VAR_1 . METHOD_2 ( ) ) { if ( VAR_4 . METHOD_3 ( ) ) { <START> String VAR_5 = VAR_2 + VAR_4 . getName ( ) ; <END> VAR_3 . add ( new TYPE_1 ( VAR_5 , VAR_4 ) ) ; } else { METHOD_1 ( VAR_4 , VAR_2 + VAR_4 . getName ( ) + STRING_1 , VAR_3 ) ; } } } 
public static void METHOD_1 ( String [ ] args ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; try { VAR_1 . METHOD_2 ( args ) ; TYPE_2 instance = VAR_1 . getInstance ( ) ; VAR_1 . METHOD_3 ( instance ) ; <START> } <END> catch ( Exception e ) { e . VAR_2 ( ) ; } finally { VAR_1 . close ( ) ; } } 
public void METHOD_1 ( int VAR_1 , int VAR_2 ) { super . METHOD_1 ( VAR_1 , VAR_2 ) ; METHOD_2 ( ) ; if ( METHOD_3 ( ) ) { METHOD_4 ( ) ; <START> METHOD_5 ( ) ; <END> } } 
public void METHOD_1 ( final TYPE_1 e ) { final TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( ) ; final TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . class ) ; final TYPE_4 model = VAR_1 . METHOD_5 ( ) ; <START> VAR_2 . METHOD_6 ( model , TYPE_3 . VAR_3 , TYPE_3 . VAR_4 ) ; <END> } 
public static String toString ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { String output = STRING_1 ; for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { Object VAR_2 = VAR_1 . get ( i ) ; output += VAR_2 . toString ( ) ; <START> if ( i + 1 != VAR_1 . size ( ) ) <END> output += STRING_2 ; else output += STRING_3 ; } return output ; } else return STRING_4 ; } 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 != null ) { <START> return ( TYPE_1 ) VAR_2 . METHOD_2 ( VAR_1 ) ; <END> } return null ; } 
public void update ( ) { VAR_1 . METHOD_1 ( METHOD_2 ( ) ) ; if ( VAR_2 . METHOD_3 ( ) != VAR_3 ) { VAR_3 = VAR_2 . METHOD_3 ( ) ; VAR_4 = TYPE_1 . METHOD_4 ( VAR_2 . METHOD_3 ( ) , VAR_2 . METHOD_5 ( ) , INT_1 ) ; METHOD_6 ( ) ; <START> } <END> } 
protected boolean METHOD_1 ( int VAR_1 ) { TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { if ( TYPE_4 . VAR_4 ) <START> TYPE_3 . logger . warn ( STRING_1 + VAR_1 ) ; <END> return false ; } return TYPE_2 . METHOD_3 ( VAR_2 ) . METHOD_4 ( VAR_6 ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , int x , int y ) { TYPE_2 . METHOD_2 ( ) ; <START> TYPE_2 . METHOD_3 ( ) ; <END> VAR_2 . METHOD_4 ( VAR_3 . VAR_4 , VAR_1 , x , y ) ; VAR_2 . METHOD_5 ( VAR_3 . VAR_5 , VAR_1 , x , y , null ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 == null ? super . METHOD_1 ( ) : TYPE_2 . METHOD_2 ( METHOD_3 ( ) , VAR_1 ) ; <END> } 
protected final void METHOD_1 ( int VAR_1 , int VAR_2 ) { METHOD_2 ( ) ; TYPE_1 . METHOD_3 ( - VAR_3 , - VAR_4 , 0 ) ; VAR_5 . METHOD_4 ( VAR_1 , VAR_2 ) ; <START> <END> for ( TYPE_2 element : VAR_6 ) { element . VAR_7 ( ) ; } VAR_8 . METHOD_5 ( ) ; TYPE_1 . METHOD_3 ( VAR_3 , VAR_4 , 0 ) ; } 
public void clear ( ) { for ( TYPE_1 p : properties ) { <START> if ( p != null ) <END> p . clear ( ) ; } properties . clear ( ) ; } 
private boolean METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 ) { TYPE_1 VAR_4 = VAR_5 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <START> return ! TYPE_2 . METHOD_3 ( VAR_4 , VAR_5 , VAR_1 , VAR_2 , VAR_3 ) || <END> TYPE_3 . METHOD_4 ( VAR_4 , VAR_5 , VAR_1 , VAR_2 , VAR_3 ) || ( VAR_4 . METHOD_5 ( VAR_5 , VAR_1 , VAR_2 , VAR_3 ) > VAR_6 ) ; } 
private void METHOD_1 ( int x , int y , int VAR_1 ) { this . VAR_2 = x ; this . VAR_3 = y ; this . VAR_4 = VAR_1 ; TYPE_1 b = VAR_5 . METHOD_2 ( x , y - 1 , VAR_1 ) ; this . VAR_6 = VAR_7 + <START> ( b . VAR_8 ( null , 0 , 0 , 0 ) * VAR_9 ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final Object key , final TYPE_3 VAR_1 ) { final String VAR_2 = METHOD_2 ( METHOD_3 ( key ) ) ; <START> final Response < String > VAR_3 ; VAR_3 = VAR_1 . get ( VAR_2 ) ; <END> VAR_1 . METHOD_4 ( VAR_2 , VAR_4 ) ; return new TYPE_4 ( VAR_3 ) ; } 
public List METHOD_1 ( ) { List < String > VAR_1 = new ArrayList < String > ( ) ; <START> synchronized ( VAR_2 ) { <END> VAR_1 . addAll ( VAR_2 . keySet ( ) ) ; } return VAR_1 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return VAR_1 . values ( ) ; <END> } 
public TYPE_4 ( ) { <START> context = new TYPE_1 ( ) ; <END> context . VAR_2 ( new TYPE_2 ( ) ) ; context . VAR_3 ( new TYPE_3 ( ) ) ; } 
private void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( ) ; } catch ( IOException e ) { <START> throw new TYPE_1 ( e ) ; <END> } catch ( InterruptedException e ) { e . VAR_3 ( System . err ) ; } } 
public static String METHOD_1 ( float VAR_1 ) { int VAR_2 = ( int ) ( VAR_1 * TYPE_1 . VAR_4 ) ; float VAR_5 = VAR_1 * TYPE_1 . VAR_6 ; String VAR_7 = String . valueOf ( VAR_5 ) . substring ( 0 , 3 ) ; <START> return VAR_2 + STRING_1 + VAR_7 + STRING_2 ; <END> } 
public void METHOD_1 ( int VAR_1 , int VAR_2 ) { <START> METHOD_2 ( METHOD_3 ( ) . getString ( R . string . VAR_3 ) + STRING_1 + VAR_1 + STRING_2 + VAR_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 , TYPE_2 data ) { data . VAR_2 ( ) ; VAR_3 . METHOD_2 ( data , TYPE_3 . getInstance ( ) ) ; <START> data . close ( ) ; <END> VAR_4 = VAR_3 . METHOD_3 ( ) ; int VAR_5 = VAR_6 . METHOD_4 ( ) ; VAR_7 . METHOD_5 ( VAR_5 , VAR_4 . get ( VAR_5 ) . METHOD_6 ( ) ) ; METHOD_7 ( ( ArrayList ) VAR_3 . METHOD_8 ( ) , false ) ; } 
<START> public TYPE_1 ( String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 ) { <END> if ( VAR_2 == null ) { VAR_2 = "" ; } if ( VAR_3 == null ) { VAR_3 = "" ; } if ( VAR_4 == null ) { VAR_4 = "" ; } if ( VAR_5 == null ) { VAR_5 = "" ; } VAR_6 = VAR_2 ; VAR_7 = VAR_3 ; VAR_8 = VAR_4 ; VAR_9 = VAR_5 ; } 
<START> public static void METHOD_1 ( ) throws TYPE_1 , TYPE_2 , TYPE_3 { <END> TYPE_4 VAR_1 = new TYPE_4 ( ) ; VAR_1 . METHOD_2 ( true ) ; System . out . println ( STRING_1 ) ; } 
public double get ( int i , int j ) { <START> METHOD_1 ( i , j ) ; <END> return METHOD_2 ( i , j , FLOAT_1 ) ; } 
public double max ( ) { double max = Double . VAR_1 ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { for ( int j = 0 ; j < VAR_3 ; j ++ ) { <START> if ( get ( i , j ) > max ) { <END> max = get ( i , j ) ; } } } return max ; } 
public void METHOD_1 ( int j , TYPE_1 VAR_1 ) { <START> int VAR_2 = VAR_3 [ j ] , i = VAR_2 ; <END> while ( i < VAR_3 [ j + 1 ] ) { VAR_1 . apply ( VAR_4 [ i ] , j , values [ i ] ) ; i ++ ; } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> for ( int i = 0 ; i < VAR_2 ; i ++ ) { if ( Math . VAR_3 ( values [ i ] ) > TYPE_2 . VAR_5 ) VAR_1 . apply ( VAR_6 [ i ] , values [ i ] ) ; } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( null ) ; assertEquals ( STRING_1 , VAR_1 . METHOD_2 ( STRING_2 ) ) ; <START> assertEquals ( STRING_1 , VAR_1 . METHOD_2 ( STRING_3 ) ) ; <END> assertEquals ( STRING_1 , VAR_1 . METHOD_2 ( STRING_4 ) ) ; assertEquals ( STRING_5 , VAR_1 . METHOD_2 ( STRING_5 ) ) ; assertEquals ( STRING_5 , VAR_1 . METHOD_2 ( STRING_6 ) ) ; } 
<START> public String METHOD_1 ( final String VAR_1 ) { <END> if ( VAR_1 == null || VAR_1 . length ( ) <= 2 ) { return VAR_1 ; } String result = VAR_1 . startsWith ( STRING_1 ) ? VAR_1 . substring ( 1 ) : VAR_1 ; return result . VAR_2 ( STRING_1 ) ? result . substring ( 0 , result . length ( ) - 1 ) : result ; } 
private static < TYPE_1 extends TYPE_2 > TYPE_3 METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_3 method : VAR_1 . getClass ( ) . METHOD_2 ( ) ) { if ( method . VAR_2 ( TYPE_4 . class ) ) { <START> method . VAR_3 ( true ) ; <END> return method ; } } return null ; } 
private static TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 element ) { return TYPE_3 . METHOD_2 ( TYPE_4 . METHOD_3 ( element , TYPE_1 . class ) , <START> VAR_1 - > VAR_1 == null || <END> ! VAR_1 . METHOD_4 ( ) || ! METHOD_5 ( VAR_1 ) ) ; } 
protected void METHOD_1 ( ANNOTATION_1 TYPE_1 file , ANNOTATION_1 TYPE_2 VAR_1 ) { super . METHOD_1 ( file , VAR_1 ) ; <START> TYPE_3 . METHOD_2 ( ) ; <END> if ( ! TYPE_4 . METHOD_3 ( file ) ) return ; for ( TYPE_5 VAR_2 : file . VAR_3 ( ) ) { if ( VAR_2 . METHOD_4 ( ) ) { VAR_1 . METHOD_5 ( VAR_2 , STRING_1 , new TYPE_6 ( ) ) ; } } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 o , ANNOTATION_2 TYPE_2 VAR_1 ) { <START> super . METHOD_1 ( o , VAR_1 ) ; <END> if ( o == null ) return ; Set < String > VAR_2 = METHOD_2 ( o ) ; TYPE_3 result = o . VAR_3 ( ) ; if ( result == null ) return ; TYPE_4 parameters = result . getParameters ( ) ; if ( parameters == null ) return ; METHOD_3 ( VAR_1 , parameters , VAR_2 ) ; } 
protected void METHOD_1 ( ANNOTATION_1 TYPE_1 file , ANNOTATION_1 TYPE_2 VAR_1 ) { <START> super . METHOD_1 ( file , VAR_1 ) ; <END> if ( ! TYPE_3 . METHOD_2 ( file ) ) return ; for ( TYPE_4 VAR_2 : file . VAR_3 ( ) ) { if ( VAR_2 . METHOD_3 ( ) ) { VAR_1 . METHOD_4 ( VAR_2 , STRING_1 , new TYPE_5 ( ) ) ; } } } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 project , ANNOTATION_1 String name , ANNOTATION_1 String text , ANNOTATION_2 String VAR_1 ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = "" ; } else { VAR_1 += STRING_1 ; } TYPE_3 file = METHOD_2 ( project , STRING_2 + name + STRING_3 + text + STRING_4 + VAR_1 + STRING_5 ) ; return TYPE_4 . METHOD_3 ( file . VAR_2 ( ) ) ; } 
protected TYPE_1 METHOD_1 ( ANNOTATION_1 final TYPE_2 VAR_1 , ANNOTATION_1 TYPE_3 session ) { return new TYPE_1 ( ) { @Override public void METHOD_2 ( ANNOTATION_1 TYPE_4 o ) { TYPE_5 parent = TYPE_6 . METHOD_3 ( o , TYPE_7 . class , <START> TYPE_8 . class , TYPE_9 . class , TYPE_10 . class , TYPE_11 . class ) ; <END> if ( parent instanceof TYPE_7 ) { VAR_1 . METHOD_4 ( o , STRING_1 , TYPE_12 . VAR_3 ) ; } } } ; } 
public String METHOD_1 ( TYPE_1 element , TYPE_1 VAR_1 ) { if ( element instanceof TYPE_2 ) { String result = METHOD_2 ( element ) ; <START> if ( result != "" ) { <END> return result ; } } return super . METHOD_1 ( element , VAR_1 ) ; } 
public static boolean METHOD_1 ( ANNOTATION_1 String VAR_1 ) { <START> return VAR_1 != null && VAR_1 . length ( ) > TYPE_2 . TYPE_3 . length ( ) && VAR_1 . METHOD_2 ( TYPE_2 . TYPE_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 element , ANNOTATION_1 TYPE_3 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) != null ) { <END> VAR_1 . METHOD_2 ( ) . VAR_2 = true ; VAR_1 . METHOD_2 ( ) . VAR_3 = false ; } TYPE_4 VAR_4 = new TYPE_5 ( element . VAR_5 ( ) , null , TYPE_6 . METHOD_3 ( ) , null , VAR_1 , METHOD_4 ( VAR_1 ) ) ; return TYPE_7 . METHOD_5 ( element . VAR_6 ( ) , VAR_4 , VAR_1 ) ; } 
public static void METHOD_1 ( Set < TYPE_1 > VAR_1 , String msg ) { <START> Iterator < TYPE_1 > it = VAR_1 . iterator ( ) ; <END> while ( it . hasNext ( ) ) { METHOD_2 ( it . next ( ) , msg ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) ; TYPE_3 VAR_2 = new TYPE_3 ( ) ; TYPE_4 VAR_3 = new TYPE_4 ( ) ; <START> VAR_2 . METHOD_3 ( VAR_3 ) ; <END> Set < TYPE_5 < TYPE_3 > > VAR_4 = VAR_1 . METHOD_4 ( TYPE_3 . class , STRING_1 , Collections . VAR_5 ( VAR_3 ) ) ; METHOD_5 ( VAR_4 , 0 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) <START> . METHOD_4 ( new TYPE_3 ( ) ) <END> . METHOD_4 ( new TYPE_4 ( ) ) . METHOD_4 ( new TYPE_5 ( ) ) . METHOD_4 ( new TYPE_6 ( ) ) . METHOD_4 ( new TYPE_7 ( ) ) . METHOD_4 ( new TYPE_8 ( ) ) . METHOD_5 ( ) . METHOD_6 ( ) ; VAR_1 . METHOD_7 ( new TYPE_9 ( null ) ) ; } 
<START> public Optional < ANNOTATION_1 ANNOTATION_2 String > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( new TYPE_1 ( INT_1 ) ) ; METHOD_3 ( STRING_1 ) ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( new TYPE_1 ( STRING_1 ) ) ; <START> METHOD_3 ( STRING_2 ) ; <END> } 
protected TYPE_1 ( ) { <START> this ( null ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 instanceof TYPE_3 && VAR_1 . METHOD_2 ( TYPE_6 . VAR_4 , VAR_2 ) ) { <START> TYPE_4 VAR_5 = ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( TYPE_5 . METHOD_4 ( VAR_2 ) ) ; <END> if ( VAR_5 == null ) return false ; return true ; } return false ; } 
public int METHOD_1 ( ) { if ( VAR_1 == null ) { METHOD_2 ( ) ; } <START> if ( VAR_1 . size ( ) == 0 ) <END> return 1 ; return VAR_1 . size ( ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> if ( VAR_1 instanceof TYPE_3 && VAR_1 . METHOD_2 ( TYPE_4 . VAR_4 , VAR_2 ) ) { <END> return true ; } return false ; } 
public boolean METHOD_1 ( TYPE_1 < ? > VAR_1 , ANNOTATION_1 TYPE_2 VAR_2 ) { if ( VAR_1 == TYPE_3 . VAR_4 ) { return true ; } <START> if ( VAR_1 != null && ( VAR_1 == VAR_5 || VAR_1 == VAR_6 ) ) { <END> return true ; } return super . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
public < T > T METHOD_1 ( TYPE_1 < T > VAR_1 , ANNOTATION_1 TYPE_2 VAR_2 ) { <START> if ( VAR_1 == TYPE_3 . VAR_4 ) { <END> return ( T ) VAR_5 ; } if ( VAR_1 != null && ( VAR_1 == VAR_6 || VAR_1 == VAR_7 ) ) { return ( T ) VAR_8 ; } return super . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
private char METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( 0 , INT_1 ) ; <START> if ( VAR_1 < 10 ) <END> return ( char ) ( INT_2 + VAR_1 ) ; else return ( char ) ( INT_3 + VAR_1 - 10 ) ; } 
public static TYPE_1 METHOD_1 ( String value ) { if ( TYPE_2 . isEmpty ( value ) ) <START> return null ; <END> for ( int i = 0 ; i < values ( ) . length ; i ++ ) { if ( value . equals ( values ( ) [ i ] . getValue ( ) ) ) return values ( ) [ i ] ; } return null ; } 
public static void METHOD_1 ( final Response response , TYPE_1 VAR_1 ) { response . write ( VAR_2 ) ; if ( VAR_1 != null ) { <START> response . write ( STRING_1 + VAR_1 . toString ( ) ) ; <END> } response . write ( STRING_2 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; return this ; } 
public void METHOD_1 ( final Class < ? > VAR_1 , final TYPE_1 VAR_2 , final String VAR_3 ) throws Exception { <START> assert ( VAR_2 != null ) ; <END> log . info ( STRING_1 + VAR_1 . getName ( ) + STRING_2 + VAR_2 . toString ( ) + STRING_3 ) ; METHOD_1 ( VAR_2 ) ; METHOD_2 ( VAR_1 , VAR_3 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 . METHOD_2 ( ) . METHOD_3 ( new TYPE_1 ( ) <END> { @Override public TYPE_2 METHOD_4 ( TYPE_2 response ) { return new TYPE_3 ( new TYPE_4 ( response ) ) ; } } ) ; METHOD_5 ( TYPE_5 . class , STRING_1 ) ; } 
public void METHOD_1 ( String ... values ) { if ( VAR_1 == null ) { VAR_1 = new ArrayList < > ( ) ; } <START> VAR_1 . clear ( ) ; <END> VAR_1 . addAll ( Arrays . asList ( values ) ) ; } 
public void METHOD_1 ( String ... VAR_1 ) { if ( this . VAR_1 == null ) { this . VAR_1 = new ArrayList < > ( ) ; } <START> this . VAR_1 . clear ( ) ; <END> this . VAR_1 . addAll ( Arrays . asList ( VAR_1 ) ) ; } 
protected void METHOD_1 ( final TYPE_1 VAR_1 , TYPE_2 < ? > VAR_2 ) { <START> if ( VAR_2 != null ) <END> { VAR_1 . put ( STRING_1 , VAR_2 . METHOD_2 ( ) . toString ( ) ) ; } } 
public TYPE_2 ( String name , Path path ) { <START> super ( TYPE_1 . METHOD_1 ( name , STRING_1 ) ) ; <END> TYPE_1 . METHOD_1 ( path , STRING_2 ) ; this . path = path ; } 
<START> public TYPE_3 ( final String VAR_2 , final TYPE_1 VAR_3 ) <END> { TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( VAR_2 ) ; <START> TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; <END> VAR_3 . METHOD_3 ( ) . METHOD_4 ( "" ) ; } 
protected TYPE_1 < Integer > METHOD_1 ( final String id , TYPE_2 < Integer > model , Class < Integer > type ) { <START> TYPE_1 < Integer > VAR_1 = new TYPE_1 < Integer > ( id , model , type ) ; <END> VAR_1 . add ( METHOD_2 ( ) == INT_1 ? TYPE_3 . METHOD_3 ( 0 , INT_2 ) : TYPE_3 . METHOD_3 ( 1 , INT_3 ) ) ; VAR_1 . METHOD_4 ( new TYPE_4 < > ( VAR_2 ) ) ; return VAR_1 ; } 
public void add ( final TYPE_1 VAR_1 ) { synchronized ( buffer ) { buffer . add ( VAR_1 ) ; VAR_2 = true ; <START> TYPE_2 . METHOD_1 ( buffer ) ; <END> } } 
public TYPE_1 METHOD_1 ( TYPE_1 result ) { <START> if ( VAR_1 == null ) { <END> return new TYPE_2 ( ) ; } TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( VAR_3 , result ) ; TYPE_2 VAR_4 = new TYPE_2 ( ) ; VAR_1 . METHOD_3 ( ) . forEach ( ( key , value ) - > VAR_4 . METHOD_2 ( key , new TYPE_3 ( value ) ) ) ; VAR_2 . METHOD_2 ( VAR_5 , VAR_4 ) ; return VAR_2 ; } 
private boolean METHOD_1 ( TYPE_1 value ) { if ( value . isEmpty ( ) && STRING_1 . equals ( METHOD_2 ( ) ) ) { return true ; } <START> boolean VAR_1 = Arrays . stream ( value . VAR_2 ( ) ) <END> . METHOD_3 ( VAR_3 - > ( VAR_3 == null && METHOD_4 ( ) ) || METHOD_5 ( VAR_3 ) ) ; return VAR_1 || METHOD_5 ( value ) ; } 
private static String METHOD_1 ( String VAR_1 ) { <START> String VAR_2 = "" ; <END> if ( VAR_1 != null ) { TYPE_1 m = VAR_3 . matcher ( VAR_1 ) ; VAR_2 = m . VAR_4 ( "" ) ; } return VAR_2 ; } 
public void METHOD_1 ( String name , String value ) { <START> if ( name != null && name . equalsIgnoreCase ( STRING_1 ) ) { <END> this . VAR_1 = value ; } else if ( name != null && ! TYPE_1 . contains ( name ) ) { VAR_2 . put ( name , value ) ; } } 
public boolean METHOD_1 ( String VAR_1 ) { <START> if ( TYPE_2 . TYPE_3 . equals ( VAR_1 ) ) <END> return VAR_2 . METHOD_2 ( ) ; else return true ; } 
<START> private static String METHOD_1 ( TYPE_1 conf ) { <END> Set < String > VAR_1 = METHOD_2 ( conf ) ; try { for ( String VAR_2 : VAR_1 ) { if ( METHOD_3 ( VAR_2 ) ) { return VAR_2 ; } } } catch ( IOException e ) { LOG . error ( STRING_1 , e ) ; } return "" ; } 
public static TYPE_1 from ( Context context ) { TYPE_2 VAR_1 = ( TYPE_2 ) context . VAR_2 ( ) . METHOD_1 ( Context . VAR_3 ) ; TYPE_3 VAR_4 = new TYPE_3 ( ) ; TYPE_4 VAR_5 = new TYPE_4 . TYPE_11 ( ) ; <START> TYPE_6 VAR_6 = TYPE_6 . METHOD_2 ( TYPE_7 . from ( VAR_7 ) , VAR_5 ) ; <END> TYPE_8 VAR_8 = new TYPE_8 ( TYPE_7 . METHOD_3 ( ) , new TYPE_6 . TYPE_10 ( ) , VAR_5 ) ; return new TYPE_1 ( VAR_1 , VAR_4 , VAR_6 , VAR_8 ) ; } 
public void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_2 ( ) ; VAR_1 = null ; } } 
private static TYPE_1 < TYPE_5 . TYPE_6 > METHOD_1 ( TYPE_3 VAR_1 ) { return TYPE_1 . create ( new TYPE_4 ( VAR_1 ) , TYPE_7 . TYPE_8 . VAR_4 ) <START> . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; TYPE_2 VAR_2 = TYPE_3 . from ( VAR_1 ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( ) ; <START> METHOD_5 ( VAR_1 , METHOD_6 ( 1 ) ) . METHOD_7 ( ) ; <END> } 
public boolean METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_1 == TYPE_2 . VAR_4 ) { <END> TYPE_1 VAR_5 = VAR_6 . METHOD_3 ( TYPE_3 . VAR_8 ) ; return VAR_5 != null && VAR_5 . METHOD_4 ( ) ; } return false ; } 
public String METHOD_1 ( ) { if ( VAR_1 == null ) { return "" ; } <START> String VAR_2 = STRING_1 + VAR_1 . METHOD_2 ( ) + STRING_2 ; <END> return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) ; <START> if ( ! VAR_2 . contains ( VAR_1 ) ) { <END> VAR_2 . add ( VAR_1 ) ; } log . trace ( STRING_1 + VAR_1 + STRING_2 + VAR_2 . size ( ) ) ; } 
private void METHOD_1 ( ) { <START> VAR_1 = VAR_2 . VAR_3 . field ( TYPE_2 . VAR_5 , METHOD_2 ( ) . VAR_6 , STRING_1 + TYPE_1 . METHOD_3 ( ) ) ; <END> } 
private TYPE_7 . TYPE_8 METHOD_1 ( ) { final TYPE_7 . TYPE_8 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_7 . TYPE_8 . class ) ; METHOD_3 ( new TYPE_3 < TYPE_4 > ( ) { <START> public TYPE_4 METHOD_4 ( TYPE_5 VAR_2 ) { <END> VAR_1 . VAR_3 = true ; return null ; } } ) . when ( VAR_1 ) . METHOD_5 ( METHOD_6 ( ) , METHOD_7 ( TYPE_6 . class ) ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; assertThat ( VAR_2 . VAR_3 ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_1 ) ; assertThat ( VAR_2 . VAR_3 ) . METHOD_5 ( ) ; <START> assertThat ( VAR_2 . VAR_4 ) . METHOD_6 ( VAR_1 ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) throws Exception { super ( VAR_2 , VAR_3 ) ; <START> VAR_4 = new ArrayList < > ( ) ; <END> METHOD_1 ( ) ; METHOD_2 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( VAR_1 ) . METHOD_3 ( TYPE_5 . VAR_3 ) ; <START> TYPE_2 a = ( TYPE_2 ) TYPE_3 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; <END> a . VAR_4 ( TYPE_1 . METHOD_2 ( VAR_1 ) . get ( ) , TYPE_6 . VAR_6 , new TYPE_4 ( ) ) ; assertThat ( VAR_1 . VAR_7 ) . METHOD_6 ( ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( VAR_2 . getString ( R . string . VAR_3 ) ) ; <END> Boolean VAR_4 = new Boolean ( true ) ; VAR_1 . METHOD_3 ( ) . METHOD_4 ( VAR_1 , VAR_4 ) ; assertThat ( VAR_2 . VAR_1 ) . METHOD_5 ( VAR_1 ) ; assertThat ( VAR_2 . VAR_4 ) . METHOD_5 ( VAR_4 ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( TYPE_1 . class , STRING_1 ) ; <END> TYPE_2 result = METHOD_3 ( TYPE_3 . class ) ; File VAR_1 = METHOD_4 ( TYPE_3 . class ) ; METHOD_5 ( result ) ; METHOD_6 ( VAR_1 , VAR_2 ) ; } 
private void METHOD_1 ( ) throws TYPE_1 { <START> VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_3 | VAR_4 , STRING_1 + TYPE_2 . METHOD_4 ( ) ) ; <END> VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ; VAR_2 . METHOD_7 ( VAR_1 ) ; VAR_5 = METHOD_8 ( STRING_2 ) ; VAR_6 = METHOD_8 ( STRING_3 ) ; } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 ( ) . VAR_2 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ; TYPE_1 VAR_3 = TYPE_2 ( ) . VAR_4 . METHOD_2 ( VAR_1 , TYPE_2 ( ) . VAR_5 ) ; <START> METHOD_5 ( ) . VAR_6 = METHOD_6 ( ) . field ( TYPE_5 . VAR_8 , VAR_3 , STRING_1 + TYPE_3 . METHOD_7 ( ) ) ; <END> METHOD_5 ( ) . VAR_6 . METHOD_8 ( TYPE_4 . METHOD_9 ( VAR_3 ) ) ; } 
private String METHOD_1 ( TYPE_1 element ) { TYPE_2 VAR_1 = element . VAR_2 ( TYPE_2 . class ) ; String VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( TYPE_2 . TYPE_4 . equals ( VAR_3 ) ) { VAR_3 = element . VAR_4 ( ) . METHOD_3 ( ) . toString ( ) ; <START> VAR_3 += STRING_1 + element . VAR_5 ( ) . toString ( ) ; <END> } return VAR_3 ; } 
<START> private boolean METHOD_1 ( String msg ) { <END> List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( ) ; boolean VAR_2 = false ; for ( TYPE_1 VAR_3 : VAR_1 ) { if ( VAR_3 . msg . startsWith ( msg ) ) VAR_2 = true ; } return VAR_2 ; } 
private String METHOD_1 ( ) { try { return properties . getProperty ( VAR_1 ) ; } <START> catch ( TYPE_1 e ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( ) ; <START> if ( VAR_1 ) { <END> logger . info ( STRING_1 + METHOD_3 ( ) ) ; VAR_2 . METHOD_4 ( METHOD_3 ( ) , METHOD_5 ( METHOD_3 ( ) , VAR_3 , TYPE_3 . VAR_5 ) ) ; VAR_2 . METHOD_6 ( METHOD_3 ( ) , METHOD_7 ( TYPE_1 . class , METHOD_3 ( ) ) ) ; VAR_2 . METHOD_6 ( METHOD_3 ( ) , METHOD_7 ( TYPE_2 . class , METHOD_3 ( ) ) ) ; } } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 ) { <END> return METHOD_2 ( ) ; } else { return STRING_1 + VAR_1 . toString ( ) . METHOD_3 ( CHAR_1 , CHAR_2 ) ; } } 
public String getString ( final Object key ) { <START> return String . valueOf ( METHOD_1 ( ) . get ( key ) ) ; <END> } 
public void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 , final int VAR_3 , final int VAR_4 ) { TYPE_2 VAR_5 = METHOD_2 ( ) . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_1 ) ) ; if ( VAR_5 instanceof TYPE_4 ) { ( ( TYPE_4 ) VAR_5 ) . METHOD_1 ( VAR_2 , VAR_3 , VAR_4 ) ; <START> } <END> } 
public < T > boolean METHOD_1 ( T VAR_1 , TYPE_1 < T > VAR_2 , TYPE_2 < TYPE_3 > action ) { try { return ( VAR_3 . get ( ) ) ? VAR_2 . METHOD_2 ( new TYPE_4 ( VAR_1 , VAR_2 . METHOD_3 ( ) , action ) ) : false ; } catch ( Exception e ) { LOGGER . warn ( STRING_1 , VAR_1 , e ) ; <START> return false ; <END> } } 
<START> private TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 , List < TYPE_2 > VAR_2 ) { <END> return TYPE_3 . METHOD_2 ( VAR_1 ) . METHOD_3 ( VAR_2 ) . METHOD_1 ( ) ; } 
public void call ( Object obj ) throws TYPE_1 , IllegalArgumentException , TYPE_2 { <START> LOG . info ( STRING_1 , description ) ; <END> method . VAR_1 ( obj ) ; } 
public List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> TYPE_2 VAR_2 = new TYPE_2 ( ) ; <END> for ( TYPE_3 VAR_3 : TYPE_4 . METHOD_2 ( VAR_1 ) ) { LOG . debug ( STRING_1 , VAR_3 ) ; } return VAR_1 ; } 
protected String METHOD_1 ( TYPE_1 element ) { Object source = element . VAR_1 ( ) ; TYPE_2 VAR_2 = null ; <START> while ( source != null && source instanceof TYPE_2 ) { <END> VAR_2 = ( TYPE_2 ) source ; source = VAR_2 . METHOD_2 ( ) ; } if ( VAR_2 != null ) { return VAR_2 . METHOD_3 ( ) . toString ( ) ; } return null ; } 
private Class < ? > METHOD_1 ( String name ) { try { <START> return Class . VAR_1 ( name . VAR_2 ( CHAR_1 , CHAR_2 ) , true , VAR_3 ) ; <END> } catch ( TYPE_1 e ) { throw new IllegalStateException ( e ) ; } } 
public void METHOD_1 ( File file ) throws Exception { TYPE_1 out = new TYPE_1 ( file , STRING_1 ) ; try { out . write ( METHOD_2 ( ) ) ; } finally { <START> TYPE_2 . close ( out , false ) ; <END> } } 
protected TYPE_3 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; <START> this . logger = TYPE_2 . METHOD_1 ( getClass ( ) ) ; <END> } 
public TYPE_7 ( Map < String , String > VAR_2 ) { <START> super ( new TYPE_1 ( ) ) ; <END> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 ) ; this . VAR_3 = TYPE_3 . METHOD_2 ( ) ; this . VAR_4 = TYPE_4 . getInstance ( ) ; this . VAR_5 = new TYPE_5 ( ) { @Override public boolean METHOD_3 ( TYPE_6 key , Map < String , String > VAR_6 ) { return VAR_3 . containsKey ( key . getKey ( VAR_6 ) ) ; } } ; } 
public TYPE_3 ( TYPE_1 properties , Map < String , String > VAR_2 ) { <START> this ( properties , VAR_2 , new TYPE_2 ( ) ) ; <END> } 
public TYPE_2 ( Map < String , String > VAR_2 ) { <START> this ( VAR_2 , new TYPE_1 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , boolean VAR_3 ) throws TYPE_2 { METHOD_2 ( VAR_1 , TYPE_5 . VAR_5 , VAR_2 , new TYPE_3 ( ) { <START> @Override <END> public void METHOD_3 ( TYPE_1 VAR_1 , String key ) throws TYPE_2 { if ( ! TYPE_4 . isEmpty ( VAR_6 . METHOD_4 ( TYPE_5 . VAR_5 , key ) ) ) { throw new TYPE_2 ( STRING_1 ) ; } } } , VAR_3 ) ; } 
public Map < String , String > METHOD_1 ( Optional < TYPE_1 > VAR_1 ) { Map < String , String > map = <START> VAR_1 . METHOD_2 ( ( ) - > new TYPE_1 ( ) ) . METHOD_3 ( this , new TYPE_2 < Map < String , String > > ( ) { } ) ; <END> if ( ! Boolean . VAR_2 ( map . get ( STRING_1 ) ) ) { map . remove ( STRING_1 ) ; } return map ; } 
public static TYPE_1 METHOD_1 ( Map < String , String > VAR_1 , Optional < TYPE_2 > VAR_2 ) { <START> return VAR_2 . METHOD_2 ( ( ) - > new TYPE_2 ( ) ) . METHOD_3 ( VAR_1 , TYPE_1 . class ) ; <END> } 
<START> public TYPE_3 . TYPE_4 . Optional < String > METHOD_1 ( ANNOTATION_1 String VAR_1 , ANNOTATION_1 TYPE_2 VAR_2 ) { <END> return Optional . VAR_3 ( VAR_4 . get ( Pair . of ( VAR_1 , VAR_2 . getName ( ) ) ) ) ; } 
public boolean METHOD_1 ( String value , String VAR_1 ) { return value != null && ( VAR_1 == null || <START> ! TYPE_1 . equals ( StringUtils . trim ( VAR_1 ) , StringUtils . trim ( value ) ) <END> ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_2 == null ) { return true ; } TYPE_3 VAR_3 = VAR_1 . getClass ( ) . METHOD_2 ( TYPE_3 . class ) ; if ( null == VAR_3 ) { return false ; } TYPE_2 [ ] VAR_4 = VAR_3 . METHOD_3 ( ) ; if ( TYPE_4 . contains ( VAR_4 , VAR_2 ) ) { <START> return true ; <END> } return false ; } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> return true ; } return VAR_1 . METHOD_2 ( ) ; } 
public Set < String > METHOD_1 ( String VAR_1 , String VAR_2 ) { Set < String > VAR_3 = VAR_4 . get ( VAR_1 + STRING_1 + VAR_2 ) ; if ( null == VAR_3 ) { <START> VAR_3 = TYPE_1 . METHOD_2 ( ) ; <END> } return VAR_3 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; TYPE_2 VAR_2 = METHOD_2 ( ) ; <START> VAR_1 = VAR_2 . METHOD_1 ( ) ; <END> return VAR_1 ; } 
public boolean METHOD_1 ( ) { try { <START> final TYPE_1 VAR_1 = VAR_2 == null ? null : TYPE_2 . METHOD_2 ( VAR_2 ) ; <END> return VAR_3 && VAR_1 != null && VAR_1 . METHOD_3 ( VAR_4 . METHOD_4 ( VAR_5 , cluster ) ) ; } catch ( TYPE_3 e ) { throw new TYPE_4 ( STRING_1 , e ) ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_3 ) { <START> if ( VAR_1 != null ) { <END> if ( VAR_1 . equals ( VAR_2 . METHOD_2 ( ) ) ) { return VAR_2 . METHOD_3 ( ) ; } } else { if ( VAR_2 . METHOD_2 ( ) == null ) { return VAR_2 . METHOD_3 ( ) ; } } } return null ; } 
public Boolean METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 : false ; <END> } 
private TYPE_1 METHOD_1 ( ANNOTATION_1 String value ) { boolean VAR_1 = true ; String VAR_2 = STRING_1 ; if ( StringUtils . VAR_3 ( value ) ) { VAR_1 = false ; } else { try { <START> if ( Double . VAR_4 ( value . trim ( ) ) < 0 ) { <END> VAR_1 = false ; } } catch ( TYPE_2 e ) { VAR_1 = false ; } } return VAR_1 ? TYPE_1 . METHOD_2 ( ) : TYPE_1 . error ( VAR_2 ) ; } 
public void METHOD_1 ( ) { TYPE_1 . execute ( VAR_1 ) <START> . filter ( request ( ) . uri ( ) . METHOD_2 ( STRING_1 ) . build ( ) ) <END> . METHOD_3 ( VAR_2 ) ; } 
public TYPE_2 ( ) { VAR_2 = new HashSet < > ( ) ; VAR_2 . add ( Long . VAR_3 . METHOD_1 ( ) ) ; VAR_2 . add ( TYPE_1 . VAR_3 . METHOD_1 ( ) ) ; <START> VAR_2 . add ( Double . VAR_3 . METHOD_1 ( ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> final boolean VAR_1 = true ; <END> METHOD_2 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> final boolean VAR_1 = false ; <END> METHOD_2 ( VAR_1 ) ; } 
<START> protected File METHOD_1 ( final String VAR_1 ) { <END> return METHOD_1 ( new File ( VAR_1 ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> when ( req . VAR_1 ( ) ) . METHOD_2 ( STRING_1 ) ; <END> when ( req . VAR_2 ( STRING_2 ) ) . METHOD_2 ( null ) ; when ( req . VAR_3 ( ) ) . METHOD_2 ( STRING_3 ) ; final String VAR_4 = VAR_5 . METHOD_3 ( req ) ; METHOD_4 ( req , METHOD_5 ( 1 ) ) . METHOD_6 ( ) ; assertThat ( VAR_4 ) . METHOD_7 ( STRING_4 ) ; } 
private TYPE_1 METHOD_1 ( ) { final TYPE_2 < String > VAR_1 = new TYPE_2 < String > ( ) ; <START> return new TYPE_3 ( METHOD_2 ( STRING_1 ) , METHOD_2 ( STRING_2 ) , <END> new TYPE_4 ( new TYPE_5 ( TYPE_6 . VAR_3 , VAR_1 ) ) ) ; } 
public TYPE_1 create ( final TYPE_2 session ) { TYPE_3 VAR_1 ; <START> TYPE_4 VAR_2 ; <END> try { VAR_1 = TYPE_5 . METHOD_1 ( session ) ; VAR_2 = TYPE_5 . METHOD_2 ( session ) ; return new TYPE_1 ( session , VAR_1 , VAR_2 , new TYPE_6 ( ) ) ; } catch ( final Exception e ) { throw new TYPE_7 ( e ) ; } } 
public void METHOD_1 ( final int VAR_1 , final String response , final Map < String , String > VAR_2 ) { final TYPE_1 page = TYPE_2 . METHOD_2 ( response , TYPE_3 . get ( ) ) ; METHOD_3 ( new TYPE_4 ( VAR_3 , page . VAR_4 ( ) ) ) ; VAR_5 -- ; <START> if ( VAR_5 == 0 ) { <END> METHOD_3 ( new TYPE_5 ( METHOD_4 ( STRING_1 ) ) ) ; METHOD_3 ( new TYPE_6 ( METHOD_4 ( STRING_2 ) ) ) ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 t = null ; try { t = ( TYPE_1 ) Class . VAR_1 ( METHOD_2 ( ) ) . METHOD_3 ( new Class [ ] { TYPE_2 . class } ) . METHOD_4 ( config ) ; } catch ( TYPE_3 | TYPE_4 | IllegalArgumentException | TYPE_5 | TYPE_6 | TYPE_7 | TYPE_8 e ) { <START> e . VAR_2 ( ) ; <END> } return t ; } 
private void METHOD_1 ( final String VAR_1 , final String VAR_2 ) throws TYPE_1 { VAR_3 . set ( STRING_1 , VAR_2 ) ; t . VAR_4 ( VAR_3 ) ; String s = ( String ) VAR_3 . get ( STRING_2 ) ; <START> Assert . assertEquals ( STRING_3 + s + STRING_4 + VAR_1 + STRING_5 + VAR_2 + STRING_6 , VAR_1 , s ) ; <END> } 
public TYPE_2 ( Collection < ? > VAR_2 ) { <START> this . VAR_3 = new ArrayList < Object > ( VAR_2 == null ? 0 : VAR_2 . size ( ) ) ; <END> if ( VAR_2 != null ) { for ( Object o : VAR_2 ) { this . VAR_3 . add ( TYPE_1 . METHOD_1 ( o ) ) ; } } } 
public String getString ( String key ) throws TYPE_1 { Object object = this . get ( key ) ; <START> return object . toString ( ) ; <END> } 
public void METHOD_1 ( Map < String , String > VAR_1 ) { try { metadata . update ( metadata . VAR_2 TYPE_1 ( ) { @Override public void METHOD_2 ( TYPE_2 VAR_3 ) { VAR_3 . METHOD_3 ( VAR_1 ) ; } } ) ; <START> } catch ( InterruptedException e ) { <END> throw new RuntimeException ( e ) ; } catch ( TYPE_3 e ) { throw new RuntimeException ( e ) ; } } 
<START> public void run ( ) { <END> if ( TYPE_1 . contains ( VAR_1 . getPath ( ) . getName ( ) ) ) { return ; } if ( ! VAR_1 . METHOD_1 ( ) ) { return ; } try { METHOD_2 ( ) ; } catch ( IOException e ) { this . exception = e ; } } 
public final ANNOTATION_1 TYPE_1 METHOD_1 ( ) { if ( VAR_1 != null && ! METHOD_2 ( ) ) { <START> VAR_1 . VAR_2 = false ; <END> VAR_1 = null ; METHOD_3 ( ) ; } return VAR_1 ; } 
public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; <START> return TYPE_2 . isEmpty ( VAR_1 ) || METHOD_3 ( VAR_1 ) < INT_1 ; <END> } 
public void METHOD_1 ( TYPE_1 data ) { super . METHOD_1 ( data ) ; <START> if ( METHOD_2 ( ) ) { <END> VAR_1 = data . VAR_2 ( STRING_1 ) ; } VAR_3 = data . VAR_4 ( STRING_2 ) ; VAR_5 = TYPE_2 . METHOD_3 ( data , STRING_3 ) ; VAR_6 = data . VAR_7 ( STRING_4 ) ; VAR_8 = data . VAR_7 ( STRING_5 ) ; VAR_9 = data . VAR_7 ( STRING_6 ) ; } 
public float METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { TYPE_4 VAR_4 = TYPE_5 . METHOD_2 ( VAR_1 , VAR_3 ) ; if ( VAR_4 instanceof TYPE_6 ) <START> return ( ( TYPE_6 ) VAR_4 ) . METHOD_3 ( ) . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , ( ( TYPE_6 ) VAR_4 ) . METHOD_4 ( ) ) ; <END> return FLOAT_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 entity ) { if ( entity instanceof TYPE_3 ) { TYPE_3 VAR_1 = ( ( TYPE_3 ) entity ) ; TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( TYPE_8 . VAR_4 ) ; <START> if ( VAR_2 != TYPE_4 . METHOD_3 ( ) && TYPE_6 . TYPE_7 . METHOD_4 ( VAR_2 ) && ! ( ( TYPE_3 ) entity ) . VAR_5 . VAR_6 ) <END> return VAR_2 ; } return TYPE_4 . METHOD_3 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> TYPE_3 VAR_3 = VAR_4 . get ( VAR_2 . METHOD_2 ( VAR_4 . size ( ) ) ) . METHOD_3 ( 2 ) ; <END> if ( VAR_3 == null ) return ; VAR_1 . add ( new TYPE_4 ( VAR_3 , null , new TYPE_3 ( TYPE_6 . VAR_6 , TYPE_5 . METHOD_4 ( VAR_2 , 1 , 3 ) ) ) ) ; } 
public TYPE_3 ( ) { <START> super ( TYPE_2 . VAR_3 , true , true , TYPE_1 . METHOD_1 ( VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 ) ) ; <END> METHOD_2 ( 1 ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> VAR_1 . METHOD_2 ( STRING_1 , METHOD_3 ( ) ) ; <END> } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) METHOD_2 ( ) ; if ( VAR_2 != null ) { <START> VAR_2 . VAR_1 = VAR_1 ; <END> } this . VAR_1 = VAR_1 ; TYPE_3 . METHOD_3 ( VAR_3 , METHOD_4 ( ) , METHOD_5 ( ) . METHOD_6 ( TYPE_4 . VAR_5 , VAR_1 ) ) ; } 
<START> private static boolean METHOD_1 ( Type type ) { <END> return ( type instanceof Class ) && ( ( Class ) type ) . METHOD_2 ( ) ; } 
static TYPE_1 METHOD_1 ( String VAR_1 , <START> Object [ ] args , <END> long [ ] VAR_2 , TYPE_1 e ) { final String message = STRING_1 + STRING_2 + STRING_3 ; return new TYPE_1 ( String . format ( message , VAR_1 , e . getMessage ( ) == null ? STRING_4 : STRING_5 + e . getMessage ( ) + STRING_6 , Arrays . VAR_3 ( args ) , Arrays . toString ( VAR_2 ) ) , e ) ; } 
ANNOTATION_1 public void METHOD_1 ( ) { assertThat ( METHOD_2 ( TYPE_1 . class ) , METHOD_3 ( <START> String . format ( STRING_1 , new TYPE_2 ( 0 ) , new TYPE_2 ( 1 ) ) ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 status ) { int size = status . size ( ) ; TYPE_1 properties = new TYPE_1 ( ) ; for ( int i = 0 ; i < size ; ++ i ) { properties . VAR_2 ( <START> VAR_3 . METHOD_1 ( VAR_1 , status ) , <END> VAR_3 . METHOD_1 ( VAR_1 , status ) ) ; } return properties ; } 
public String toString ( ) { return STRING_1 <START> + STRING_2 + VAR_1 + CHAR_1 <END> + STRING_3 + VAR_2 + CHAR_1 + STRING_4 + VAR_3 + CHAR_1 + STRING_5 + VAR_4 + CHAR_1 + STRING_6 + VAR_5 + CHAR_1 + STRING_7 + VAR_6 + CHAR_1 + STRING_8 + VAR_7 + CHAR_1 + STRING_9 + VAR_8 + CHAR_1 + STRING_10 + VAR_9 + CHAR_1 + STRING_11 + VAR_10 + CHAR_1 + STRING_12 + VAR_11 + CHAR_1 + STRING_13 + VAR_12 + CHAR_1 + STRING_14 + VAR_13 + CHAR_1 + CHAR_2 ; } 
<START> TYPE_2 ( List < TYPE_1 > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
<START> public HashSet < TYPE_1 < TYPE_2 , ? > > METHOD_1 ( ) <END> { return VAR_1 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) throws Exception { <START> final TYPE_1 < TYPE_2 > VAR_1 = VAR_2 . METHOD_2 ( ( TYPE_3 ) null , String . valueOf ( STRING_1 ) , null , null ) ; <END> TYPE_4 . METHOD_3 ( VAR_1 ) ; } 
public String toString ( ) { TYPE_1 buffer = new TYPE_1 ( ) ; if ( VAR_1 != null ) { for ( TYPE_2 VAR_2 : VAR_1 ) { buffer . append ( VAR_2 ) ; buffer . append ( STRING_1 ) ; } } buffer . append ( STRING_2 ) ; buffer . append ( VAR_3 ) ; <START> buffer . append ( STRING_3 ) ; <END> buffer . append ( VAR_4 ) ; return buffer . toString ( ) ; } 
public String toString ( ) { <START> TYPE_1 buffer = new TYPE_1 ( ) ; <END> buffer . append ( super . toString ( ) ) ; buffer . append ( STRING_1 ) ; buffer . append ( value == null ? "" : value ) ; buffer . append ( STRING_2 ) ; buffer . append ( VAR_1 ) ; return buffer . toString ( ) ; } 
public String toString ( ) { <START> TYPE_1 buffer = new TYPE_1 ( ) ; <END> if ( VAR_1 != null ) { for ( TYPE_2 VAR_2 : VAR_1 ) { buffer . append ( VAR_2 ) . append ( STRING_1 ) ; } } buffer . append ( STRING_2 ) . append ( VAR_3 ) . append ( STRING_3 ) . append ( VAR_4 ) ; return buffer . toString ( ) ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> TYPE_2 result = new TYPE_2 ( ) ; result . add ( STRING_1 , METHOD_2 ( VAR_1 ) ) ; return result . VAR_2 ( STRING_1 ) ; } 
void METHOD_1 ( ) throws Exception { this . VAR_1 . METHOD_2 ( get ( TYPE_1 . format ( new Object [ ] { STRING_1 , STRING_2 } ) ) ) . METHOD_3 ( status ( ) . METHOD_4 ( ) ) <START> . METHOD_5 ( ) ; <END> } 
private String METHOD_1 ( TYPE_1 < Object > response , String VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) response . VAR_3 ( STRING_1 , STRING_2 ) ; <START> Object VAR_4 = VAR_2 . METHOD_2 ( VAR_1 , null ) ; <END> if ( VAR_4 != null ) { return VAR_4 . toString ( ) ; } else { throw new RuntimeException ( STRING_3 + VAR_1 + STRING_4 ) ; } } 
<START> public void METHOD_1 ( String VAR_1 ) { <END> TYPE_3 . TYPE_4 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; try ( TYPE_2 VAR_4 = new TYPE_2 ( VAR_2 . VAR_5 ) ) { VAR_4 . METHOD_3 ( ) . forEach ( p - > VAR_6 . METHOD_4 ( VAR_1 , p , VAR_4 . stream ( p ) ) ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_3 != null && VAR_3 != "" ) { <START> Iterator < TYPE_3 > VAR_4 = VAR_5 . iterator ( ) ; <END> while ( VAR_4 . hasNext ( ) ) { TYPE_3 p = VAR_4 . next ( ) ; p . VAR_6 ( VAR_7 * VAR_8 ) ; VAR_1 . METHOD_1 ( VAR_3 , VAR_2 . x , VAR_2 . y , p ) ; } } } 
public void METHOD_1 ( View view ) { TYPE_1 i = new TYPE_1 ( this , TYPE_2 . class ) ; i . VAR_1 ( STRING_1 , VAR_2 ) ; i . VAR_1 ( STRING_2 , VAR_3 ) ; <START> i . VAR_1 ( STRING_3 , VAR_4 . getPath ( ) ) ; <END> i . VAR_1 ( STRING_4 , METHOD_2 ( ) . METHOD_3 ( ) . getString ( STRING_4 ) ) ; METHOD_4 ( i ) ; } 
public void METHOD_1 ( View view ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; <START> <END> VAR_2 = VAR_3 . METHOD_3 ( ) . toString ( ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; ( ( TYPE_2 ) this . METHOD_5 ( R . id . VAR_4 ) ) . setText ( STRING_1 ) ; ( ( TYPE_3 ) METHOD_5 ( R . id . VAR_5 ) ) . setText ( VAR_2 ) ; METHOD_6 ( ) ; } 
public void start ( TYPE_1 VAR_1 , int VAR_2 ) throws TYPE_2 { <START> System . out . println ( STRING_1 + Thread . VAR_3 ( ) . getName ( ) + STRING_2 + VAR_4 + STRING_3 + VAR_1 + STRING_4 + VAR_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) throws TYPE_2 { <START> System . out . println ( STRING_1 + Thread . VAR_3 ( ) . getName ( ) + STRING_2 + VAR_4 + STRING_3 + VAR_1 + STRING_4 + VAR_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> System . out . println ( STRING_1 + Thread . VAR_2 ( ) . getName ( ) + STRING_2 + VAR_3 + STRING_3 + VAR_1 + STRING_4 ) ; <END> } 
public void commit ( TYPE_1 VAR_1 , boolean VAR_2 ) throws TYPE_2 { if ( LOG . VAR_3 ( ) ) { <START> LOG . trace ( STRING_1 + VAR_1 + STRING_2 + VAR_2 + STRING_3 ) ; <END> } VAR_4 . METHOD_1 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( LOG . VAR_2 ( ) ) { <START> LOG . trace ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } } 
public TYPE_1 [ ] METHOD_1 ( int VAR_1 ) throws TYPE_2 { if ( LOG . VAR_2 ( ) ) { <START> LOG . trace ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } return null ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 result = null ; TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_1 != null ) { result = VAR_1 . METHOD_4 ( ) ; } <START> if ( result != null ) { <END> } return result ; } 
private void METHOD_1 ( TYPE_1 context ) { <START> TYPE_2 < ? > VAR_1 = context . VAR_2 ( ) ; <END> if ( ! VAR_1 . isEmpty ( ) ) { METHOD_2 ( VAR_1 . get ( ) ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_1 VAR_2 = METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_2 ) ; <START> METHOD_5 ( VAR_2 ) ; <END> } 
public boolean METHOD_1 ( ) { <START> return this . VAR_1 != 0 ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> TYPE_1 VAR_4 = METHOD_3 ( VAR_2 ) ; return VAR_4 != null ? VAR_4 : VAR_5 ; } 
public boolean METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; TYPE_2 VAR_4 = VAR_5 . get ( VAR_1 ) ; <START> return ( VAR_2 != null && VAR_2 . METHOD_2 ( ) . size ( ) == 0 ) && <END> ( VAR_4 != null && VAR_4 . size ( ) == 0 ) ; } 
public void execute ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = METHOD_1 ( VAR_1 ) ; boolean VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; <START> if ( VAR_3 ) <END> METHOD_3 ( VAR_1 , VAR_2 ) ; super . execute ( VAR_1 ) ; } 
<START> public void METHOD_1 ( Map < String , Object > VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
public void METHOD_1 ( TYPE_1 event ) { <START> if ( event . getType ( ) . equals ( TYPE_6 . VAR_2 ) ) { <END> if ( event instanceof TYPE_2 && TYPE_3 . class . METHOD_2 ( ( ( TYPE_2 ) event ) . METHOD_3 ( ) . getClass ( ) ) ) { VAR_3 . from ( ( TYPE_2 ) event ) . METHOD_4 ( VAR_4 - > { for ( TYPE_4 < TYPE_5 > listener : VAR_5 ) { listener . VAR_6 ( VAR_4 ) ; } } ) ; } } } 
public Optional < TYPE_1 > from ( TYPE_2 VAR_1 ) { TYPE_3 event = new TYPE_3 ( VAR_2 . from ( VAR_1 ) ) ; <START> if ( event != null ) { <END> event . VAR_3 ( VAR_1 . METHOD_1 ( ) ) ; event . VAR_4 ( VAR_1 . METHOD_2 ( ) ) ; } return Optional . of ( event ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> final TYPE_1 [ ] VAR_1 = new TYPE_1 [ ] { new TYPE_2 ( VAR_2 ) } ; TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_3 . METHOD_3 ( VAR_4 , VAR_1 , VAR_5 ) ; assertEquals ( 1 , VAR_5 . METHOD_4 ( ) . count ( ) ) ; METHOD_2 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 task ; try { <START> task = task ( VAR_1 . METHOD_2 ( ) ) ; <END> } catch ( IllegalStateException ex ) { throw new IllegalStateException ( STRING_1 + VAR_1 . METHOD_2 ( ) + STRING_2 ) ; } if ( VAR_1 . METHOD_3 ( ) != null && ! VAR_1 . METHOD_3 ( ) . isEmpty ( ) ) { for ( String VAR_2 : VAR_1 . METHOD_3 ( ) ) { VAR_3 . METHOD_4 ( task . getId ( ) , VAR_2 ) ; } } } 
public void METHOD_1 ( ) throws IOException { VAR_1 . start ( TYPE_1 . start ( ) . METHOD_2 ( VAR_2 ) . METHOD_3 ( STRING_1 , STRING_1 ) . METHOD_3 ( STRING_2 , STRING_2 ) . METHOD_3 ( STRING_3 , true ) <START> . build ( ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { <START> VAR_1 . start ( TYPE_1 . start ( ) <END> . METHOD_2 ( VAR_2 ) . METHOD_3 ( STRING_1 , true ) . build ( ) ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws Exception { List < TYPE_1 > VAR_2 = METHOD_2 ( VAR_1 ) ; <START> assertThat ( VAR_2 , METHOD_3 ( 1 ) ) ; <END> return VAR_2 . get ( 0 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; <START> assertThat ( VAR_2 ) . METHOD_2 ( ) ; <END> assertThat ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_1 . class ) ; VAR_2 . execute ( VAR_1 ) ; METHOD_5 ( VAR_3 ) . METHOD_6 ( VAR_1 ) ; METHOD_5 ( VAR_4 ) . METHOD_7 ( TYPE_4 < TYPE_2 < TYPE_3 > > METHOD_8 ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 , STRING_2 ) ; <START> assertThat ( VAR_2 ) . METHOD_2 ( ) ; <END> assertThat ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_1 . class ) ; VAR_2 . execute ( VAR_1 ) ; METHOD_5 ( VAR_3 ) . METHOD_6 ( VAR_1 ) ; METHOD_5 ( VAR_4 ) . METHOD_7 ( TYPE_4 < TYPE_2 < TYPE_3 > > METHOD_8 ( ) ) ; } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 String id ) { try ( final TYPE_2 VAR_1 = VAR_2 . METHOD_1 ( id ) ) { <START> String VAR_3 = new String ( TYPE_3 . METHOD_2 ( VAR_1 , null ) , TYPE_6 . VAR_5 ) ; <END> return VAR_6 . METHOD_3 ( new TYPE_4 ( id , VAR_3 ) ) ; } catch ( IOException e ) { throw new TYPE_5 ( STRING_1 + id + STRING_2 + e . getMessage ( ) , e ) ; } } 
public synchronized void METHOD_1 ( TYPE_1 event ) { <START> System . out . println ( STRING_1 + event ) ; <END> System . out . println ( STRING_2 + event . VAR_1 ( ) + STRING_3 + event . VAR_2 ( ) ) ; System . out . println ( STRING_4 + event . getClass ( ) . METHOD_2 ( ) ) ; VAR_3 . METHOD_3 ( event ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> System . out . println ( STRING_1 + VAR_1 ) ; <END> VAR_2 . METHOD_1 ( TYPE_2 . METHOD_2 ( VAR_1 ) . build ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( ) ; assertNotNull ( VAR_1 ) ; <START> TYPE_1 VAR_2 = METHOD_3 ( VAR_1 ) ; <END> METHOD_4 ( VAR_2 ) ; METHOD_5 ( VAR_2 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( ) ; assertNotNull ( STRING_1 , VAR_1 ) ; TYPE_1 VAR_2 = METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_2 ) ; <START> METHOD_5 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( ) ; assertNotNull ( VAR_1 ) ; METHOD_3 ( VAR_1 ) ; <START> VAR_1 = METHOD_4 ( VAR_1 ) ; <END> METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_2 ( ) ; <START> assertNotNull ( VAR_1 ) ; <END> VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_1 . METHOD_3 ( new Date ( ) ) ; VAR_3 . METHOD_4 ( STRING_1 ) ; listener . VAR_4 ( ) ; TYPE_3 task = VAR_5 . METHOD_5 ( ) . METHOD_6 ( ) ; VAR_5 . METHOD_7 ( task . getId ( ) ) ; METHOD_8 ( 1 , TYPE_4 . VAR_7 ) ; } 
public TYPE_2 ( ANNOTATION_1 TYPE_1 VAR_2 , int index ) { if ( VAR_2 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } this . index = index ; String VAR_3 = VAR_2 . getName ( ) ; if ( VAR_3 == null ) { <START> throw new IllegalStateException ( STRING_2 ) ; <END> } this . name = VAR_3 ; this . VAR_4 = VAR_2 . METHOD_1 ( ) ; this . VAR_5 = VAR_2 . METHOD_2 ( ) ; } 
<START> public String METHOD_1 ( ) { return VAR_1 != null ? VAR_1 . METHOD_1 ( ) : "" ; } <END> 
<START> public String METHOD_1 ( ) { return VAR_1 != null ? VAR_1 . METHOD_1 ( ) . toString ( ) : "" ; } <END> 
private boolean METHOD_1 ( ANNOTATION_1 String path ) { <START> TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ; <END> return path . VAR_2 ( STRING_2 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 request = VAR_1 . METHOD_2 ( ) ; TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) ; <START> LOG . info ( STRING_1 + request . VAR_3 ( ) <END> + STRING_2 + TYPE_5 . VAR_5 . METHOD_4 ( ) + STRING_3 + VAR_2 ) ; TYPE_4 VAR_6 = ( TYPE_4 ) VAR_1 . METHOD_5 ( ) ; if ( request . VAR_3 ( ) . equals ( TYPE_2 . VAR_7 ) ) METHOD_6 ( VAR_6 , request , VAR_2 ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = null ; <START> synchronized ( VAR_3 ) { <END> for ( TYPE_2 listener : VAR_3 ) { TYPE_1 VAR_4 = listener . VAR_5 ( VAR_1 ) ; if ( VAR_4 != null && VAR_4 . METHOD_2 ( ) . equals ( VAR_1 ) ) { VAR_2 = VAR_4 ; break ; } } } return VAR_2 ; } 
public static TYPE_1 create ( ) throws Exception { <START> TYPE_1 VAR_1 = new TYPE_2 ( "" ) ; return METHOD_1 ( VAR_1 ) ; <END> } 
public static TYPE_1 . Builder METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 ) { <START> return new TYPE_1 . Builder ( VAR_1 , VAR_2 ) . start ( VAR_2 - 1 ) ; <END> } 
public TYPE_1 . Builder start ( int start ) { <START> this . VAR_1 = start + 1 ; <END> return this ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { if ( VAR_1 . VAR_4 . size ( ) == 0 ) { return ; } final int VAR_5 = VAR_3 . METHOD_2 ( VAR_1 . VAR_4 . size ( ) ) ; final TYPE_4 VAR_6 = VAR_1 . VAR_4 . get ( VAR_5 ) ; <START> VAR_2 . VAR_7 . set ( VAR_6 . x ( ) , VAR_6 . y ( ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { T VAR_2 = METHOD_2 ( ) . getValue ( ) ; if ( VAR_2 instanceof TYPE_2 || VAR_2 instanceof Double ) { return ; } <START> VAR_1 . METHOD_3 ( FLOAT_1 ) ; <END> VAR_1 . METHOD_4 ( 0 ) ; } 
public String METHOD_1 ( ) { String VAR_1 = "" ; <START> if ( VAR_2 != null ) VAR_1 = String . VAR_3 ( STRING_1 , VAR_2 ) ; <END> if ( text . get ( ) != "" ) return text . get ( ) + STRING_1 + VAR_1 ; return text . get ( ) + VAR_1 ; } 
public void setText ( String val ) { String VAR_1 = METHOD_1 ( ) ; boolean VAR_2 = ! VAR_1 . equals ( val ) ; text . set ( val != null ? val : "" ) ; <START> VAR_3 = null ; <END> METHOD_2 ( ) ; if ( VAR_2 ) { for ( TYPE_1 listener : VAR_4 ) { listener . VAR_5 ( VAR_1 , val ) ; } } } 
private void METHOD_1 ( float VAR_1 ) { <START> float VAR_2 = TYPE_1 . METHOD_2 ( getValue ( ) + VAR_1 , 0 , METHOD_3 ( ) + METHOD_4 ( ) ) ; <END> METHOD_5 ( VAR_2 ) ; } 
public String METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) { return VAR_1 ; } <START> if ( VAR_2 || ( TYPE_1 . VAR_4 != null && TYPE_1 . VAR_4 . equals ( this ) ) ) { <END> return VAR_5 ; } else if ( VAR_6 . METHOD_3 ( ) ) { return VAR_7 ; } return VAR_8 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , VAR_3 ) ; TYPE_3 size = METHOD_1 ( ) . size ( ) ; <START> this . data = new ArrayList < > ( Collections . VAR_4 ( size . x * size . y , Optional . empty ( ) ) ) ; <END> } 
public static boolean METHOD_1 ( ) { if ( VAR_1 != null ) { boolean VAR_2 = false ; for ( TYPE_1 VAR_3 : VAR_1 ) { if ( VAR_3 instanceof TYPE_2 ) { <START> TYPE_3 . METHOD_2 ( "" ) . info ( STRING_1 ) ; <END> VAR_2 = true ; } } return VAR_2 ; } return false ; } 
private boolean METHOD_1 ( String name ) { Path VAR_1 = TYPE_1 . getInstance ( ) . METHOD_2 ( name ) ; <START> if ( VAR_1 == TYPE_1 . getInstance ( ) . METHOD_2 ( "" ) ) { <END> return false ; } return ! StringUtils . VAR_2 ( name ) ; } 
public void METHOD_1 ( ) { int size = VAR_1 . size ( ) ; int VAR_2 = index ; if ( size > 0 ) { if ( index == size - 1 ) { if ( VAR_3 ) { index = 0 ; } else { METHOD_2 ( ) ; } } else { index ++ ; } if ( VAR_2 != index ) { <START> VAR_4 . set ( VAR_1 . get ( index ) ) ; <END> } } } 
public void METHOD_1 ( ANNOTATION_1 ( STRING_1 ) float x , ANNOTATION_1 ( STRING_2 ) float y , ANNOTATION_1 ( STRING_3 ) float VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_3 . METHOD_2 ( TYPE_2 . class ) ) { TYPE_2 VAR_4 = VAR_2 . METHOD_3 ( TYPE_2 . class ) ; <START> if ( VAR_4 != null ) { <END> VAR_4 . VAR_5 . set ( x , y , VAR_1 ) ; } } } 
<START> void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( ! VAR_1 . exists ( ) ) { return ; } METHOD_2 ( VAR_1 ) ; } 
<START> TYPE_2 ( TYPE_1 ... VAR_2 ) { <END> super ( VAR_2 ) ; } 
<START> private String METHOD_1 ( ) { <END> return VAR_1 . getName ( ) ; } 
<START> private TYPE_1 METHOD_1 ( TYPE_1 out ) { <END> TYPE_2 VAR_1 = METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; if ( VAR_1 == null ) { return out ; } TYPE_3 location = VAR_1 . VAR_2 . METHOD_3 ( TYPE_3 . class ) ; if ( location == null ) { return METHOD_4 ( ) ; } return location . VAR_3 ( out ) ; } 
public void METHOD_1 ( ) { boolean VAR_1 = false ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> if ( METHOD_2 ( ) . contains ( VAR_2 ) ) { <END> METHOD_3 ( VAR_2 ) ; VAR_1 = true ; } if ( ! METHOD_2 ( ) . contains ( VAR_3 ) ) { METHOD_4 ( VAR_3 ) ; VAR_1 = true ; } if ( VAR_1 ) { VAR_4 . METHOD_5 ( ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; TYPE_1 node = METHOD_3 ( VAR_1 ) ; <START> if ( ! VAR_2 . METHOD_4 ( ) . contains ( node ) ) { <END> throw new RuntimeException ( STRING_2 + VAR_1 + STRING_3 ) ; } if ( VAR_2 . METHOD_5 ( node ) . size ( ) != 0 ) { throw new RuntimeException ( STRING_4 + VAR_1 + STRING_5 ) ; } VAR_3 . remove ( VAR_1 ) ; return VAR_3 . remove ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 . METHOD_2 ( VAR_1 ) ) { TYPE_2 VAR_3 = VAR_4 . METHOD_3 ( VAR_1 ) ; <START> if ( VAR_3 == null ) { <END> logger . warn ( STRING_1 ) ; } else { VAR_5 . add ( VAR_3 ) ; Collections . VAR_6 ( VAR_5 , new TYPE_3 ( ) ) ; } } } 
public String get ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_1 ( ) . METHOD_2 ( TYPE_1 . class ) ; for ( TYPE_2 VAR_3 : METHOD_3 ( TYPE_2 . class ) ) { <START> if ( VAR_3 . METHOD_4 ( ) . METHOD_2 ( TYPE_3 . class ) != null && VAR_3 . METHOD_5 ( ) == VAR_1 . VAR_4 ) <END> return VAR_3 . METHOD_4 ( ) . METHOD_2 ( TYPE_3 . class ) . name ; } return "" ; } 
public TYPE_5 ( int VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 , TYPE_4 VAR_6 , String VAR_7 ) { this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; this . VAR_8 = VAR_5 . get ( VAR_3 ) ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; this . VAR_9 = METHOD_1 ( VAR_6 ) ; METHOD_2 ( null ) ; <START> VAR_5 . METHOD_3 ( this ) ; <END> } 
public void update ( ) { if ( VAR_1 . METHOD_1 ( ) ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) ; VAR_4 . METHOD_3 ( VAR_2 . METHOD_4 ( TYPE_2 . METHOD_4 ( ) ) , VAR_2 . METHOD_5 ( TYPE_2 . METHOD_5 ( ) ) ) ; METHOD_6 ( ) ; VAR_5 = true ; } else if ( VAR_5 ) { METHOD_7 ( ) ; METHOD_6 ( ) ; <START> VAR_5 = false ; <END> } } 
public void update ( ) { if ( ! VAR_1 . METHOD_1 ( ) ) { if ( VAR_2 ) { TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( ) ; VAR_5 . METHOD_3 ( VAR_3 . METHOD_4 ( TYPE_2 . METHOD_4 ( ) ) , VAR_3 . METHOD_5 ( TYPE_2 . METHOD_5 ( ) ) ) ; METHOD_6 ( ) ; <START> VAR_2 = true ; <END> } } else { METHOD_7 ( ) ; METHOD_6 ( ) ; VAR_2 = false ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = new TYPE_3 ( context ) ; VAR_1 . METHOD_2 ( VAR_2 , STRING_1 ) ; TYPE_2 VAR_3 = new TYPE_4 ( context ) ; VAR_1 . METHOD_2 ( VAR_3 , STRING_2 ) ; TYPE_2 VAR_4 = VAR_1 . METHOD_3 ( new TYPE_5 ( STRING_3 ) ) ; VAR_1 . METHOD_4 ( VAR_4 , VAR_2 ) ; <START> VAR_1 . METHOD_4 ( VAR_2 , VAR_3 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( STRING_1 ) ; VAR_1 . METHOD_3 ( STRING_2 , VAR_2 . METHOD_4 ( ) , true ) ; <START> VAR_1 . METHOD_3 ( STRING_3 , VAR_2 . METHOD_5 ( ) , true ) ; <END> METHOD_6 ( 0 , 0 , TYPE_2 . METHOD_7 ( ) , TYPE_2 . METHOD_8 ( ) ) ; METHOD_9 ( ) ; TYPE_1 . METHOD_10 ( ) ; } 
public boolean equals ( Object obj ) { return ( obj instanceof TYPE_1 ) <START> && VAR_1 == ( ( TYPE_1 ) obj ) . VAR_1 <END> && VAR_2 == ( ( TYPE_1 ) obj ) . VAR_2 && VAR_3 == ( ( TYPE_1 ) obj ) . VAR_3 && VAR_4 == ( ( TYPE_1 ) obj ) . VAR_4 ; } 
public TYPE_1 create ( String VAR_1 , TYPE_2 position ) { if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { <START> TYPE_3 VAR_2 = VAR_3 . METHOD_1 ( ) . METHOD_2 ( VAR_1 ) ; <END> return create ( VAR_2 , position ) ; } return create ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { long VAR_2 = VAR_1 . getId ( ) ; VAR_3 . remove ( VAR_2 ) ; VAR_4 . remove ( VAR_2 ) ; <START> if ( VAR_1 instanceof TYPE_2 ) { <END> ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; } VAR_5 . remove ( VAR_2 ) ; } 
private static boolean METHOD_1 ( ) throws IOException , InterruptedException { TYPE_1 VAR_1 = new TYPE_2 ( STRING_1 , STRING_2 ) . start ( ) ; <START> TYPE_3 VAR_2 = new TYPE_3 ( new TYPE_4 ( VAR_1 . METHOD_2 ( ) ) ) ; <END> VAR_1 . METHOD_3 ( ) ; boolean result = VAR_2 . METHOD_4 ( ) . METHOD_5 ( STRING_3 ) ; VAR_2 . close ( ) ; return result ; } 
public boolean equals ( Object obj ) { <START> return ( obj instanceof TYPE_1 ) && this . VAR_1 == ( ( TYPE_1 ) obj ) . VAR_1 ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_2 . METHOD_2 ( ) ; <START> } else { <END> VAR_1 . METHOD_3 ( ) ; } } 
public void update ( ) { <START> TYPE_1 VAR_1 = VAR_2 . get ( VAR_3 ) ; <END> VAR_4 = VAR_1 . METHOD_1 ( ) ; VAR_5 = VAR_1 . METHOD_2 ( ) ; } 
public TYPE_5 ( Context context ) { TYPE_1 VAR_2 = context . get ( TYPE_1 . class ) ; VAR_3 = context . get ( TYPE_2 . class ) ; <START> METHOD_1 ( ( ) - > VAR_2 . METHOD_2 ( ) == VAR_4 || VAR_2 . METHOD_2 ( ) == VAR_5 ) ; <END> METHOD_3 ( new TYPE_3 ( VAR_6 , VAR_3 ) ) ; update ( ) ; VAR_3 . METHOD_4 ( this ) ; METHOD_3 ( new TYPE_4 ( VAR_7 ) ) ; } 
public TYPE_5 ( Context context ) { <START> VAR_2 = context . get ( TYPE_1 . class ) ; <END> TYPE_2 VAR_3 = context . get ( TYPE_2 . class ) ; METHOD_1 ( ( ) - > VAR_3 . METHOD_2 ( ) == VAR_4 || VAR_3 . METHOD_2 ( ) == VAR_5 ) ; METHOD_3 ( new TYPE_3 ( VAR_6 , VAR_2 ) ) ; update ( ) ; VAR_2 . METHOD_4 ( this ) ; METHOD_3 ( new TYPE_4 ( VAR_7 ) ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( ( ) - > VAR_1 . METHOD_3 ( ) == VAR_2 || VAR_1 . METHOD_3 ( ) == VAR_3 ) ; METHOD_4 ( new TYPE_1 ( VAR_4 , VAR_5 ) ) ; update ( ) ; METHOD_4 ( new TYPE_2 ( STRING_1 ) ) ; <START> VAR_5 . METHOD_5 ( this ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 = VAR_2 . METHOD_2 ( ) ; METHOD_3 ( new TYPE_1 ( TYPE_2 . toString ( ) ) ) ; VAR_3 = METHOD_4 ( TYPE_2 ) ; METHOD_3 ( new TYPE_3 ( ) ) ; METHOD_3 ( new TYPE_4 ( ) ) ; METHOD_3 ( new TYPE_5 ( VAR_4 , VAR_5 ) ) ; METHOD_3 ( new TYPE_6 ( VAR_6 , VAR_7 ) ) ; update ( ) ; METHOD_5 ( ) ; <START> VAR_7 . METHOD_6 ( this ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( true ) ; VAR_2 = config . VAR_3 ( ) . METHOD_2 ( ) ; new TYPE_2 ( VAR_2 , this ) ; VAR_4 = VAR_5 . METHOD_3 ( ) ; METHOD_4 ( new TYPE_3 ( VAR_4 ) ) ; METHOD_4 ( new TYPE_4 ( VAR_6 , VAR_7 ) ) ; METHOD_4 ( new TYPE_5 ( VAR_6 , VAR_7 ) ) ; update ( ) ; <START> VAR_7 . METHOD_5 ( this ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 = VAR_2 . METHOD_2 ( ) ; METHOD_3 ( new TYPE_1 ( VAR_1 ) ) ; VAR_3 = METHOD_4 ( new TYPE_2 ( VAR_4 , VAR_5 , VAR_6 . Type . VAR_7 ) . METHOD_5 ( ) , VAR_8 ) ; METHOD_3 ( new TYPE_3 ( VAR_4 , VAR_8 ) ) ; <START> VAR_9 = VAR_8 . get ( VAR_10 ) ; <END> METHOD_3 ( new TYPE_4 ( TYPE_5 . toString ( ) ) ) ; VAR_11 = METHOD_6 ( TYPE_5 ) ; VAR_8 . METHOD_7 ( this ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return data . VAR_2 ( VAR_1 ) && VAR_1 != null ; <END> } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( STRING_1 ) ; TYPE_2 VAR_1 = VAR_2 . get ( new TYPE_3 ( STRING_2 ) ) ; <START> VAR_1 . bind ( ) ; <END> VAR_1 . METHOD_3 ( true , false , false ) ; METHOD_4 ( VAR_3 ) ; VAR_1 . METHOD_3 ( true , true , true ) ; TYPE_1 . METHOD_5 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; <START> if ( VAR_3 == null ) { <END> logger . error ( STRING_1 + VAR_1 + STRING_2 ) ; } return VAR_2 ; } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( STRING_1 ) ; VAR_1 . bind ( ) ; VAR_1 . METHOD_3 ( true , true , true ) ; METHOD_4 ( VAR_2 | VAR_3 ) ; METHOD_5 ( ) ; <START> VAR_4 . METHOD_6 ( ) ; <END> VAR_5 . METHOD_7 ( VAR_6 ) ; TYPE_1 . METHOD_8 ( ) ; } 
<START> private String METHOD_1 ( ) { <END> return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) return VAR_2 . get ( VAR_3 ) ; <START> return VAR_1 . METHOD_1 ( ) ; <END> } 
TYPE_2 ( String VAR_2 , int index , TYPE_1 VAR_3 ) { <START> this . VAR_2 = String . format ( VAR_2 + STRING_1 , VAR_3 . METHOD_1 ( ) , VAR_3 . METHOD_2 ( ) , VAR_3 . METHOD_3 ( ) ) ; <END> this . index = index ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; String VAR_2 = STRING_1 + VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) + STRING_2 ; <START> METHOD_4 ( STRING_3 , TYPE_2 . class ) . setText ( STRING_4 ) ; <END> METHOD_4 ( STRING_5 , TYPE_2 . class ) . setText ( VAR_2 ) ; } 
public void METHOD_1 ( ) { <START> logger . info ( STRING_1 ) ; <END> TYPE_1 i = VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( null ) ; VAR_2 . clear ( ) ; VAR_1 . METHOD_3 ( i ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 == null ) { return ; } if ( TYPE_3 . TYPE_4 == null ) { return ; <START> } <END> for ( int VAR_2 = 0 ; VAR_2 < 2 ; VAR_2 ++ ) { TYPE_3 . TYPE_4 . apply ( VAR_2 , VAR_3 [ VAR_2 ] , null , TYPE_6 . TYPE_8 . TYPE_7 ) ; } if ( TYPE_3 . TYPE_5 != null ) { TYPE_3 . TYPE_5 . apply ( ) ; } } 
private void METHOD_1 ( ) { <START> VAR_1 . get ( TYPE_4 . TYPE_3 . getName ( ) ) . METHOD_2 ( true , true , true ) ; <END> TYPE_2 . METHOD_3 ( VAR_2 ) ; TYPE_2 . METHOD_4 ( VAR_3 , VAR_4 ) ; TYPE_2 . METHOD_5 ( false ) ; } 
public TYPE_1 ( int VAR_2 ) { <START> if ( VAR_2 != VAR_3 <END> && VAR_2 != VAR_4 && VAR_2 != VAR_5 ) { throw new IllegalArgumentException ( STRING_1 ) ; } this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( STRING_1 ) ; <START> VAR_1 = VAR_2 . get ( VAR_3 ) ; <END> METHOD_3 ( VAR_4 | VAR_5 ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; METHOD_6 ( TYPE_2 ) ; VAR_2 . METHOD_7 ( ) ; TYPE_2 . METHOD_8 ( VAR_1 ) ; TYPE_1 . METHOD_9 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( STRING_1 ) ; METHOD_3 ( VAR_1 | VAR_2 ) ; METHOD_4 ( ) ; <START> METHOD_5 ( ) ; <END> TYPE_1 . METHOD_6 ( ) ; } 
public TYPE_1 ( String VAR_2 ) { this . VAR_2 = VAR_2 ; <START> if ( VAR_2 . equals ( VAR_3 ) ) { <END> VAR_4 = VAR_5 ; } else { VAR_4 = VAR_6 . METHOD_1 ( VAR_2 ) . VAR_4 ; } } 
public TYPE_1 ( String VAR_2 ) { this . VAR_2 = VAR_2 ; if ( ! VAR_2 . equals ( VAR_3 ) ) { VAR_4 = VAR_5 . METHOD_1 ( VAR_2 ) ; <START> } <END> } 
public TYPE_1 ( String VAR_2 ) { this . VAR_2 = VAR_2 ; if ( ! VAR_2 . equals ( VAR_3 ) ) { VAR_4 = VAR_5 . METHOD_1 ( VAR_2 ) . VAR_4 ; } else { <START> VAR_4 = VAR_6 ; <END> } } 
public String METHOD_1 ( TYPE_1 node , String VAR_1 ) { VAR_2 . add ( node ) ; <START> return null ; <END> } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( STRING_1 ) ; <END> if ( VAR_1 . METHOD_3 ( ) ) { VAR_2 = VAR_3 . METHOD_4 ( STRING_2 ) ; VAR_4 = VAR_3 . METHOD_4 ( STRING_3 ) ; VAR_5 = VAR_3 . METHOD_4 ( STRING_4 ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; } TYPE_1 . METHOD_7 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( STRING_1 ) ; <START> boolean VAR_1 = VAR_2 . METHOD_3 ( ) ; <END> METHOD_4 ( VAR_1 ) ; VAR_2 . METHOD_5 ( VAR_3 . VAR_4 , TYPE_2 . TYPE_4 . VAR_7 , VAR_8 , TYPE_5 . TYPE_3 . VAR_11 ) ; METHOD_6 ( VAR_1 ) ; TYPE_1 . METHOD_7 ( ) ; } 
<START> public void METHOD_1 ( TYPE_1 t ) <END> { time = t ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . value = 3 ; VAR_2 = new ArrayList < Integer > ( Arrays . asList ( 3 ) ) ; long VAR_3 = time . VAR_4 ( ) ; <START> VAR_5 . METHOD_2 ( METHOD_3 ( VAR_1 ) , <END> STRING_1 , ( ( VAR_3 + INT_1 ) - VAR_3 ) ) ; VAR_6 ++ ; } 
public float METHOD_1 ( float v ) { <START> return ( float ) Math . VAR_1 ( v , VAR_2 ) * ( VAR_3 - start ) + start ; <END> } 
<START> void METHOD_1 ( ) { <END> if ( ! VAR_1 . METHOD_2 ( ) . exists ( ) ) { TYPE_1 VAR_2 = VAR_1 . METHOD_3 ( ) . METHOD_4 ( TYPE_1 . class ) ; TYPE_2 builder = VAR_3 . METHOD_5 ( STRING_1 ) ; builder . VAR_4 ( false ) ; VAR_2 . VAR_5 = builder . build ( ) ; VAR_1 . METHOD_3 ( ) . METHOD_6 ( VAR_2 ) ; METHOD_7 ( ) ; } } 
public Set < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , Object ... VAR_2 ) { Collection < TYPE_3 > VAR_3 = VAR_4 . METHOD_2 ( ) ; Set < TYPE_1 > VAR_5 = TYPE_4 . METHOD_3 ( VAR_3 . size ( ) ) ; <START> VAR_5 . addAll ( VAR_3 . stream ( ) . map ( TYPE_3 : : getName ) . collect ( Collectors . VAR_6 ( ) ) ) ; <END> return VAR_5 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( ) . stream ( ) . filter ( VAR_2 - > VAR_2 . exists ( ) ) . forEach ( TYPE_2 : : METHOD_3 ) ; <END> } 
public static synchronized List < TYPE_1 > METHOD_1 ( List < TYPE_1 > output , boolean VAR_1 ) { TYPE_2 . METHOD_2 ( output , STRING_1 ) ; output . clear ( ) ; <START> output . addAll ( TYPE_3 . values ( ) . stream ( ) . filter ( entry - > ! VAR_1 || entry . VAR_2 ( ) ) . collect ( Collectors . VAR_3 ( ) ) ) ; <END> return output ; } 
public void METHOD_1 ( Object target , Map < TYPE_1 < ? , ? > , TYPE_2 > values , TYPE_3 context , TYPE_4 VAR_1 ) { <START> values . entrySet ( ) . stream ( ) . filter ( field - > VAR_1 . METHOD_2 ( VAR_2 , field . getKey ( ) ) ) . forEach ( field - > { <END> METHOD_1 ( target , field . getKey ( ) , field . getValue ( ) , context ) ; } ) ; } 
public TYPE_1 METHOD_1 ( Collection < T > value , TYPE_2 context ) { List < TYPE_1 > VAR_1 = TYPE_3 . METHOD_2 ( ) ; <START> VAR_1 . addAll ( value . stream ( ) . map ( item - > METHOD_3 ( item , context ) ) . collect ( Collectors . VAR_2 ( ) ) ) ; <END> return context . create ( VAR_1 ) ; } 
public static void METHOD_1 ( Path VAR_1 ) { String VAR_2 = TYPE_1 . format ( new Date ( ) ) ; VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) ; String VAR_4 = VAR_3 . toString ( ) ; System . VAR_5 ( VAR_6 , VAR_4 ) ; try { <START> METHOD_4 ( VAR_1 , ( ( int ) TYPE_2 . METHOD_5 ( 5 ) . METHOD_6 ( ) ) ) ; <END> } catch ( IOException e ) { e . VAR_7 ( ) ; } } 
public static < T , TYPE_1 extends T > TYPE_1 put ( Class < T > type , TYPE_1 object ) { <START> if ( context == null ) <END> return null ; context . put ( type , object ) ; return object ; } 
public TYPE_1 METHOD_1 ( String name ) { if ( ! name . isEmpty ( ) ) { <START> TYPE_2 . METHOD_2 ( ! TYPE_3 . METHOD_3 ( name ) ) ; <END> return VAR_1 . METHOD_4 ( name , TYPE_1 . class ) . METHOD_5 ( null ) ; } return null ; } 
public boolean exists ( String name ) { <START> TYPE_1 . METHOD_1 ( ! TYPE_2 . METHOD_2 ( name ) ) ; <END> return VAR_1 . METHOD_3 ( name , TYPE_3 . class ) . isPresent ( ) ; } 
public TYPE_1 get ( ) { switch ( config . VAR_1 ( ) ) { <START> case VAR_2 : <END> return VAR_2 ; case VAR_3 : return VAR_3 ; default : return VAR_2 ; } } 
public TYPE_1 METHOD_1 ( ) { if ( exists ( ) ) { TYPE_2 info = METHOD_2 ( TYPE_2 . class ) ; <START> if ( info != null && ! info . VAR_1 . exists ( ) ) { <END> return new TYPE_1 ( TYPE_3 . VAR_3 , info . VAR_1 . getName ( ) ) ; } } return null ; } 
public TYPE_2 ( ) { METHOD_1 ( new TYPE_1 ( ) { @Override public void METHOD_2 ( int VAR_2 , int VAR_3 ) { <START> if ( VAR_4 == null ) <END> return ; VAR_4 . METHOD_3 ( ) ; } } ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 element ) { if ( element != null && element . VAR_1 ( ) instanceof TYPE_3 ) { TYPE_3 result = ( TYPE_3 ) element . VAR_1 ( ) ; <START> if ( ! result . equals ( VAR_2 . METHOD_2 ( ) ) ) { <END> result . VAR_3 ( element . VAR_4 ( ) . METHOD_3 ( ) ) ; METHOD_1 ( result , element . VAR_4 ( ) ) ; } return result ; } return null ; } 
public void METHOD_1 ( TYPE_1 event , TYPE_2 entity ) { <START> if ( event . VAR_1 ( ) . length ( ) > 0 ) { <END> VAR_2 . METHOD_2 ( entity ) . METHOD_3 ( event . VAR_1 ( ) ) ; } if ( event . VAR_3 ( ) . length ( ) > 0 ) { VAR_2 . METHOD_2 ( entity ) . METHOD_4 ( event . VAR_3 ( ) ) ; } } 
public static int METHOD_1 ( int val ) { <START> if ( val == Integer . VAR_1 ) <END> return 0 ; int result = val - 1 ; result = ( result > > 1 ) | result ; result = ( result > > 2 ) | result ; result = ( result > > 4 ) | result ; result = ( result > > INT_1 ) | result ; result = ( result > > INT_2 ) | result ; result ++ ; return result ; } 
public void METHOD_1 ( TYPE_1 event , TYPE_2 entity ) { TYPE_3 VAR_1 = entity . VAR_2 ( TYPE_3 . class ) ; <START> VAR_3 . remove ( VAR_1 . METHOD_2 ( ) , new TYPE_4 ( entity , VAR_1 . METHOD_3 ( ) ) ) ; <END> entity . VAR_4 ( TYPE_3 . class ) ; } 
public void update ( float VAR_1 ) { if ( VAR_2 > 0 ) { VAR_2 -= VAR_1 ; return ; } VAR_2 = FLOAT_1 ; <START> for ( TYPE_1 VAR_3 : VAR_4 . METHOD_1 ( TYPE_2 . class ) ) { <END> METHOD_2 ( VAR_3 , VAR_3 . METHOD_3 ( TYPE_2 . class ) ) ; } for ( Map . Entry < TYPE_3 , List < TYPE_4 > > entry : VAR_5 . entrySet ( ) ) { for ( TYPE_4 VAR_6 : entry . getValue ( ) ) { VAR_6 . METHOD_4 ( FLOAT_1 ) ; } } } 
<START> public void METHOD_1 ( TYPE_1 output ) { <END> TYPE_2 location = entity . VAR_1 ( TYPE_2 . class ) ; if ( location == null ) { output . x = 0 ; output . y = 0 ; output . VAR_2 = 0 ; } else { location . VAR_3 ( output ) ; } } 
public void METHOD_1 ( Throwable VAR_1 ) { LOGGER . info ( STRING_1 + VAR_1 . toString ( ) ) ; VAR_2 = null ; METHOD_2 ( ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> } 
public Map < String , Map < String , Integer > > METHOD_1 ( ) { <START> Map < String , Map < String , Integer > > VAR_1 = new HashMap < String , Map < String , Integer > > ( ) ; <END> if ( VAR_2 != null ) { VAR_1 . put ( VAR_2 . name , VAR_2 . METHOD_2 ( ) ) ; } if ( VAR_3 != null ) { VAR_1 . put ( VAR_3 . name , VAR_3 . METHOD_2 ( ) ) ; } return VAR_1 ; } 
public Map < String , Map < String , Integer > > METHOD_1 ( ) { <START> Map < String , Map < String , Integer > > VAR_1 = new HashMap < String , Map < String , Integer > > ( ) ; <END> if ( VAR_2 != null ) { VAR_1 . put ( VAR_2 . name , VAR_2 . METHOD_2 ( ) ) ; } return VAR_1 ; } 
public Map < String , Map < String , Integer > > METHOD_1 ( final TYPE_1 VAR_1 ) { <START> Map < String , Map < String , Integer > > VAR_2 = new HashMap < String , Map < String , Integer > > ( ) ; <END> for ( TYPE_1 o : VAR_1 . METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( METHOD_1 ( o ) ) ; } VAR_2 . METHOD_3 ( VAR_1 . METHOD_1 ( ) ) ; return VAR_2 ; } 
public Map < String , Map < String , Integer > > METHOD_1 ( ) { <START> Map < String , Map < String , Integer > > VAR_1 = new HashMap < String , Map < String , Integer > > ( ) ; <END> for ( TYPE_1 t : VAR_2 ) { VAR_1 . METHOD_2 ( t . VAR_3 ( t . VAR_4 ( ) ) ) ; } return VAR_1 ; } 
public boolean METHOD_1 ( ) { <START> try { <END> return VAR_1 . METHOD_2 ( ) . METHOD_1 ( 1 ) ; } catch ( TYPE_1 e ) { LOGGER . warn ( STRING_1 , e ) ; return false ; } } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { TYPE_1 VAR_1 = null ; try { if ( VAR_2 . get ( TYPE_4 . VAR_4 ) == null ) { if ( METHOD_2 ( ) instanceof TYPE_3 ) { VAR_1 = ( ( TYPE_3 ) METHOD_2 ( ) ) . METHOD_3 ( ) . METHOD_1 ( ) ; } } } catch ( Exception e ) { LOGGER . debug ( STRING_1 ) ; <START> VAR_1 = null ; <END> } return VAR_1 ; } 
<START> public static int METHOD_1 ( Type type ) { <END> int VAR_1 = INT_1 * 10 ; if ( type == Type . VAR_2 ) { VAR_1 = 1 ; } return VAR_1 ; } 
public TYPE_4 ( ) { data = new TYPE_1 ( ) ; VAR_2 = 0 ; TYPE_2 VAR_3 = new TYPE_2 ( Arrays . asList ( Type . VAR_4 ) ) ; <START> int VAR_5 = TYPE_3 . METHOD_1 ( VAR_3 ) ; <END> VAR_6 = VAR_5 ; } 
public static void METHOD_1 ( final String [ ] args ) throws Exception { <START> TYPE_1 run = run ( args ) ; <END> LOGGER . info ( STRING_1 + run ) ; } 
public TYPE_3 ( ANNOTATION_1 ( value = STRING_1 , VAR_2 = true ) final Integer index ) { super ( null ) ; <START> this . index = VAR_3 . VAR_4 . TYPE_1 . METHOD_1 ( index , STRING_2 ) ; <END> TYPE_2 . METHOD_2 ( this . index >= 0 , STRING_3 , this . index ) ; } 
public TYPE_1 METHOD_1 ( ) throws IOException { TYPE_2 VAR_1 = TYPE_2 . create ( uri ) ; <START> return VAR_1 . METHOD_2 ( ) . equals ( STRING_1 ) || VAR_1 . METHOD_2 ( ) . equals ( STRING_2 ) <END> ? VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_1 ( ) : METHOD_5 ( VAR_1 ) ; } 
public TYPE_1 ( final int value ) { <START> VAR_2 = Type . VAR_3 ; <END> this . value = String . valueOf ( value ) ; } 
public static synchronized TYPE_1 METHOD_1 ( final TYPE_2 < String , Object > VAR_1 ) { if ( instance == null ) { try { instance = new TYPE_1 ( VAR_1 ) ; } catch ( TYPE_3 e ) { <START> if ( LOGGER . VAR_2 ( ) ) { <END> LOGGER . error ( STRING_1 , e ) ; } } } TYPE_4 . METHOD_2 ( instance . VAR_3 == ( TYPE_5 ) VAR_1 . get ( TYPE_6 . VAR_5 ) , STRING_2 ) ; return instance ; } 
<START> public void METHOD_1 ( ) { <END> boolean VAR_1 = false ; try { TYPE_1 . get ( ) . METHOD_2 ( TYPE_2 . class ) ; } catch ( TYPE_3 ex ) { if ( ex . getMessage ( ) . contains ( STRING_1 ) ) { VAR_1 = true ; } } assertTrue ( VAR_1 ) ; } 
<START> public void METHOD_1 ( ) { <END> try { TYPE_1 . get ( ) . METHOD_2 ( TYPE_2 . class ) ; } catch ( TYPE_3 ex ) { METHOD_3 ( STRING_1 ) ; } } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> TYPE_1 VAR_2 = new TYPE_1 ( this ) ; <END> this . VAR_1 = VAR_2 ; return VAR_2 ; } else { return this . VAR_1 ; } } 
protected boolean METHOD_1 ( Object VAR_1 ) { if ( VAR_1 == null ) return false ; Class c = VAR_1 . getClass ( ) ; return ( VAR_1 instanceof Collection ) <START> || ( c . VAR_2 ( ) && ! ( c . VAR_3 ( ) == TYPE_1 . VAR_5 ) ) <END> || METHOD_2 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > VAR_2 = new ArrayList < TYPE_2 > ( VAR_3 ) ; VAR_2 . addAll ( VAR_1 . METHOD_2 ( ) ) ; <START> TYPE_3 VAR_4 = VAR_5 == TYPE_3 . VAR_6 <END> && VAR_1 . VAR_5 == TYPE_3 . VAR_6 ? TYPE_3 . VAR_6 : TYPE_3 . VAR_7 ; return new TYPE_1 ( VAR_4 , VAR_2 ) ; } 
private static void METHOD_1 ( TYPE_1 in ) throws Exception { byte [ ] buffer = new byte [ INT_1 ] ; try { for ( int i = in . read ( buffer ) ; i != - 1 ; i = in . read ( buffer ) ) System . err . write ( buffer , 0 , i ) ; } finally { <START> in . close ( ) ; <END> } } 
public TYPE_1 < TYPE_2 > METHOD_1 ( File file ) throws IOException { TYPE_3 input = new TYPE_4 ( file ) ; <START> TYPE_5 output = new TYPE_6 ( file , true ) ; <END> try { return METHOD_1 ( input , output ) ; } finally { input . close ( ) ; } } 
private void METHOD_1 ( TYPE_1 field , TYPE_5 . TYPE_1 VAR_1 ) { <START> if ( field . VAR_2 ( TYPE_3 . class ) ) { <END> TYPE_3 VAR_3 = field . VAR_4 ( TYPE_3 . class ) ; if ( ! VAR_3 . METHOD_2 ( ) . equals ( TYPE_3 . VAR_5 ) ) { throw new TYPE_4 ( STRING_1 + STRING_2 + VAR_1 . name ( ) ) ; } VAR_1 . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ; } } 
<START> public Object METHOD_1 ( Object record , TYPE_1 VAR_1 ) { return null ; } <END> 
public void put ( String VAR_1 , TYPE_1 VAR_2 ) { try { <START> VAR_3 . METHOD_1 ( VAR_1 ) ; <END> VAR_3 . put ( new TYPE_2 ( new TYPE_3 ( VAR_1 , VAR_4 ) , VAR_2 ) ) ; } finally { VAR_3 . METHOD_2 ( VAR_1 ) ; } } 
public TYPE_7 ( TYPE_1 VAR_2 ) { if ( VAR_2 == null ) { conf = new TYPE_2 ( ) ; } else { conf = METHOD_1 ( ( ) - > { TYPE_2 VAR_3 = new TYPE_3 ( ) ; VAR_3 . METHOD_2 ( STRING_1 ) ; TYPE_4 < TYPE_5 , String > VAR_4 = ( is , VAR_5 ) - > <START> { <END> VAR_3 . METHOD_2 ( is , VAR_5 ) ; } ; TYPE_6 . METHOD_3 ( VAR_2 , VAR_4 ) ; return VAR_3 ; } ) ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( ) ; METHOD_3 ( VAR_2 ) ; TYPE_3 VAR_3 = VAR_2 . METHOD_4 ( TYPE_4 . VAR_5 ) ; VAR_3 . METHOD_5 ( VAR_6 , VAR_1 ) ; try { List VAR_7 = VAR_3 . METHOD_6 ( ) ; <START> if ( VAR_7 . size ( ) > 0 ) { <END> return ( TYPE_1 ) VAR_7 . get ( 0 ) ; } else { return null ; } } finally { METHOD_7 ( VAR_2 ) ; } } 
public Response METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 ) { METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; TYPE_1 result = new TYPE_1 ( ) ; try { <START> result . put ( VAR_2 , METHOD_4 ( VAR_1 ) ) ; <END> return Response . VAR_3 ( result ) . build ( ) ; } catch ( Throwable e ) { throw TYPE_2 . METHOD_5 ( e , Response . Status . VAR_4 ) ; } } 
public void METHOD_1 ( TYPE_1 entity ) throws TYPE_2 { if ( entity . VAR_1 ( ) != TYPE_3 . VAR_3 ) { return ; } <START> synchronized ( this ) { <END> VAR_4 . METHOD_2 ( entity . getName ( ) ) ; VAR_5 . remove ( entity ) ; } } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_1 { TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_2 ( VAR_1 ) ; <START> VAR_3 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <END> TYPE_3 VAR_4 = METHOD_5 ( ) ; try { METHOD_6 ( VAR_4 ) ; VAR_4 . METHOD_7 ( VAR_3 ) ; } finally { METHOD_8 ( VAR_4 ) ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { TYPE_2 VAR_4 = new TYPE_3 ( ) . path ( TYPE_4 . VAR_6 . path , VAR_1 , VAR_2 ) . METHOD_2 ( VAR_7 , VAR_3 ) . call ( TYPE_4 . VAR_6 ) ; METHOD_3 ( VAR_4 ) ; METHOD_4 ( VAR_4 ) ; TYPE_1 result = VAR_4 . METHOD_5 ( TYPE_1 . class ) ; <START> if ( result == null || result . VAR_8 ( ) == null ) { <END> return new TYPE_1 ( ) ; } return result ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 cluster , TYPE_3 VAR_1 ) { final TYPE_1 VAR_2 = cluster . VAR_3 ( ) ; if ( VAR_2 != null ) { return VAR_2 ; } final TYPE_1 VAR_4 = VAR_1 . METHOD_2 ( ) ; <START> return VAR_4 == null ? null : VAR_4 ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> File VAR_1 = new File ( STRING_1 ) ; <END> File file = new File ( VAR_1 , VAR_2 ) ; file . VAR_3 ( ) ; file = new File ( VAR_1 , STRING_1 + VAR_2 + STRING_2 ) ; file . VAR_3 ( ) ; } 
public static String METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , String VAR_3 ) throws TYPE_2 { List < TYPE_3 > VAR_4 = VAR_1 . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) ; for ( TYPE_3 VAR_5 : VAR_4 ) { if ( VAR_5 . getName ( ) . contains ( VAR_3 ) ) { <START> if ( VAR_5 . METHOD_4 ( ) != null ) { <END> return VAR_5 . METHOD_4 ( ) ; } } } return "" ; } 
public TYPE_5 ( TYPE_1 cluster , TYPE_2 table ) throws TYPE_3 { this ( TYPE_4 . METHOD_1 ( cluster , TYPE_6 . VAR_3 ) . METHOD_2 ( ) , table ) ; <START> METHOD_3 ( METHOD_4 ( ) ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; TYPE_2 VAR_3 = METHOD_3 ( ) ; METHOD_4 ( VAR_3 ) ; VAR_3 . METHOD_5 ( VAR_2 ) ; <START> METHOD_6 ( VAR_3 ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( TYPE_5 . VAR_4 ) ; List result = VAR_2 . METHOD_4 ( ) ; if ( TYPE_4 . isEmpty ( result ) ) { return null ; } VAR_1 . close ( ) ; <START> return result ; <END> } 
protected void METHOD_1 ( ) { <START> VAR_1 = new Date ( ) ; <END> VAR_2 = new Date ( ) ; } 
public void METHOD_1 ( ) throws Exception { <START> System . out . println ( STRING_1 ) ; <END> TYPE_1 . get ( ) . METHOD_2 ( TYPE_5 . VAR_2 , url ) ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_4 . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_3 ) , VAR_3 ) ; VAR_4 . METHOD_5 ( new Path ( VAR_5 ) ) ; METHOD_6 ( VAR_6 ) ; VAR_7 . METHOD_7 ( ) ; this . VAR_8 = TYPE_4 . METHOD_8 ( STRING_2 ) ; this . conf = VAR_8 . METHOD_9 ( ) ; } 
private void METHOD_1 ( String cluster , String VAR_1 , String VAR_2 , String VAR_3 ) throws TYPE_1 { try { <START> TYPE_2 . get ( cluster ) . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; <END> METHOD_2 ( cluster , VAR_1 , Status . VAR_4 , Status . VAR_5 , Status . VAR_6 ) ; LOG . info ( STRING_1 , VAR_1 , VAR_3 , cluster ) ; } catch ( TYPE_3 e ) { throw new TYPE_1 ( e ) ; } } 
public void add ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 ) { TYPE_4 VAR_2 = METHOD_1 ( ) . METHOD_2 ( VAR_3 , VAR_4 ) ; try { TYPE_5 . METHOD_3 ( VAR_2 , VAR_1 ) ; } catch ( IOException e ) { throw new IllegalStateException ( STRING_1 + STRING_2 ) ; } catch ( TYPE_6 VAR_5 ) { throw new IllegalStateException ( STRING_3 + <START> VAR_1 . METHOD_4 ( ) + STRING_4 ) ; <END> } VAR_3 = VAR_2 . METHOD_5 ( ) ; VAR_4 = VAR_2 . METHOD_6 ( ) ; ++ VAR_6 ; } 
<START> <END> <END> public TYPE_1 METHOD_1 <END> <END> <END> ( <END> <END> ) <END> { TYPE_1 <END> <END> VAR_1 <END> = <END> new <END> TYPE_1 <END> ( <END> 0 <END> ) <END> ; <END> for <END> ( <END> TYPE_2 < <END> TYPE_3 <END> , <END> TYPE_4 <END> , TYPE_5 , TYPE_6 , <END> <END> TYPE_7 , 
protected boolean METHOD_1 ( T VAR_1 ) { try { return buffer . VAR_2 ( VAR_1 , VAR_3 , TimeUnit . VAR_4 ) ; } catch ( InterruptedException e ) { <START> logger . error ( STRING_1 ) ; <END> return false ; } } 
private boolean METHOD_1 ( ) { try { long VAR_1 ; if ( VAR_2 == 1 && VAR_3 != null && VAR_3 instanceof TYPE_1 ) { VAR_1 = VAR_4 ; } else { VAR_1 = VAR_5 [ VAR_2 ] ; } Thread . VAR_6 ( VAR_1 ) ; return true ; } catch ( InterruptedException e ) { <START> logger . error ( STRING_1 ) ; <END> return false ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { try { byte VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 == TYPE_3 . VAR_4 ) { int length = VAR_1 . METHOD_2 ( ) ; if ( length > 0 ) { byte [ ] data = VAR_1 . METHOD_3 ( length + 1 ) ; TYPE_2 VAR_5 = new TYPE_2 ( ) ; VAR_5 . parse ( data ) ; VAR_6 . add ( VAR_5 ) ; } } } catch ( Exception e ) { <START> logger . error ( STRING_1 , e ) ; <END> } } 
public synchronized boolean METHOD_1 ( ) { logger . trace ( STRING_1 ) ; <START> TYPE_1 VAR_1 = this . METHOD_2 ( ) . METHOD_3 ( ) ; <END> VAR_1 . METHOD_4 ( this . VAR_2 . METHOD_5 ( ) . VAR_3 ) ; if ( METHOD_6 ( VAR_1 , false ) ) { logger . trace ( STRING_2 ) ; if ( VAR_1 . METHOD_7 ( ) ) { logger . trace ( STRING_3 ) ; VAR_4 = VAR_1 . METHOD_8 ( ) ; return true ; } } return false ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { logger . trace ( STRING_1 , VAR_2 ) ; TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_3 . METHOD_4 ( VAR_2 ) ; <START> if ( ( VAR_1 . METHOD_5 ( VAR_3 ) ) && ( VAR_3 . METHOD_6 ( ) ) ) { <END> logger . debug ( STRING_2 ) ; return true ; } else { logger . trace ( STRING_3 ) ; return false ; } } 
public boolean execute ( TYPE_1 VAR_1 , int VAR_2 ) { logger . trace ( STRING_1 , VAR_2 ) ; TYPE_2 VAR_3 = VAR_1 . METHOD_1 ( ) . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; <START> if ( ( VAR_1 . METHOD_4 ( VAR_3 ) ) && ( VAR_3 . METHOD_5 ( ) ) ) { <END> logger . debug ( STRING_2 ) ; return true ; } else { logger . trace ( STRING_3 ) ; return false ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , boolean VAR_3 ) { logger . trace ( STRING_1 , VAR_2 , VAR_3 ) ; TYPE_2 VAR_4 = VAR_1 . METHOD_2 ( ) . METHOD_1 ( ) ; VAR_4 . METHOD_3 ( VAR_2 , VAR_3 ) ; <START> if ( ( VAR_1 . METHOD_4 ( VAR_4 ) ) && ( VAR_4 . METHOD_5 ( ) ) ) { <END> logger . info ( STRING_2 ) ; return true ; } logger . trace ( STRING_3 ) ; return false ; } 
public void METHOD_1 ( String VAR_1 ) { logger . trace ( STRING_1 , VAR_1 ) ; request . params . VAR_2 = VAR_1 ; <START> return ; <END> } 
private static boolean METHOD_1 ( Logger logger , String VAR_1 , int VAR_2 , int VAR_3 ) { logger . trace ( STRING_1 , VAR_1 , VAR_2 , VAR_1 , VAR_3 ) ; if ( VAR_2 != VAR_3 ) { logger . warn ( STRING_2 , VAR_1 , VAR_2 , VAR_1 , VAR_3 ) ; return false ; <START> } else { <END> logger . trace ( STRING_3 , true ) ; return true ; } } 
public TYPE_1 METHOD_1 ( ) { <START> logger . error ( <END> STRING_1 ) ; return null ; } 
public void METHOD_1 ( String VAR_1 , TYPE_1 command ) { logger . trace ( STRING_1 , VAR_1 , command . toString ( ) ) ; if ( this . VAR_2 == null ) { <START> logger . error ( STRING_2 ) ; <END> return ; } super . METHOD_1 ( VAR_1 , command ) ; } 
public void METHOD_1 ( TYPE_1 c ) throws IOException , Exception { try { VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( c ) , 1 ) ; } catch ( TYPE_3 ex ) { <START> logger . error ( STRING_1 , ex . getMessage ( ) ) ; <END> } } 
public void run ( ) { try { while ( ! Thread . VAR_1 ( ) ) { METHOD_1 ( ) ; Thread . VAR_2 ( INT_1 ) ; } } catch ( InterruptedException VAR_3 ) { logger . error ( STRING_1 + VAR_3 . getMessage ( ) ) ; } catch ( Exception VAR_3 ) { <START> logger . error ( STRING_2 , VAR_3 . getMessage ( ) ) ; <END> } finally { VAR_4 . METHOD_2 ( ) ; logger . info ( STRING_3 ) ; } logger . info ( STRING_4 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_3 ) { try { VAR_2 . METHOD_2 ( VAR_1 ) ; } catch ( Exception VAR_4 ) { <START> logger . error ( STRING_1 , VAR_4 . getMessage ( ) ) ; <END> } } } 
public void start ( TYPE_1 VAR_1 ) throws Exception { context = VAR_1 ; <START> logger . info ( STRING_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 item , TYPE_2 state ) { if ( VAR_1 != null && VAR_1 . contains ( item . getName ( ) ) ) { <START> logger . debug ( STRING_1 , item . getName ( ) , state . toString ( ) ) ; <END> VAR_2 . METHOD_2 ( item . getName ( ) , state . toString ( ) ) ; } } 
public Object METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> return null ; } else { return VAR_1 ; } } 
public void start ( ) throws Exception { logger . trace ( STRING_1 ) ; VAR_1 = new TYPE_1 ( this ) ; <START> VAR_1 . METHOD_1 ( VAR_2 ) ; <END> VAR_3 = new TYPE_2 ( true ) ; VAR_3 . METHOD_2 ( VAR_1 , 0 , VAR_4 ) ; logger . trace ( STRING_2 ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; <START> VAR_3 = 0 ; <END> } 
public static String METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 , int value ) throws IllegalArgumentException { int id = TYPE_2 . TYPE_3 . METHOD_2 ( VAR_1 ) ; if ( id != - 1 ) { <START> int VAR_2 = id |= INT_1 ; <END> int VAR_3 = ( value > > INT_2 ) & INT_3 ; int VAR_4 = value & INT_3 ; return String . format ( STRING_1 , VAR_2 , VAR_3 , VAR_4 ) ; } throw new IllegalArgumentException ( ) ; } 
public void METHOD_1 ( TYPE_1 < String , ? > config ) throws TYPE_2 { if ( config == null ) { return ; } METHOD_2 ( config ) ; VAR_1 = METHOD_3 ( config ) ; if ( VAR_1 != null ) { METHOD_4 ( config ) ; METHOD_5 ( true ) ; } else { <START> logger . error ( STRING_1 ) ; <END> } } 
private void METHOD_1 ( ) { String result = STRING_1 + STRING_2 + STRING_3 + 0 + STRING_4 + STRING_5 ; try { VAR_1 . write ( result . VAR_2 ( ) ) ; VAR_1 . METHOD_2 ( ) ; } catch ( IOException e ) { <START> e . VAR_3 ( ) ; <END> } } 
private void METHOD_1 ( ) { String result = STRING_1 + STRING_2 + STRING_3 + 0 + STRING_4 + STRING_5 ; try { VAR_1 . write ( result . VAR_2 ( ) ) ; VAR_1 . METHOD_2 ( ) ; } catch ( IOException e ) { <START> logger . debug ( STRING_6 + e . getMessage ( ) ) ; <END> } } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . length == 0 ; <END> } 
private static boolean METHOD_1 ( final String line ) { <START> return null != line && STRING_1 . equals ( line . trim ( ) ) ; <END> } 
private static int METHOD_1 ( final TYPE_1 node ) { int start = 0 ; final TYPE_1 VAR_1 = node . VAR_2 ( ) ; <START> if ( null != VAR_1 ) { <END> start = VAR_1 . METHOD_2 ( ) ; } return start ; } 
public TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 ) { final TYPE_1 result = new TYPE_1 ( ) ; final Iterator < TYPE_2 > iterator = VAR_1 . METHOD_2 ( ) ; <START> while ( iterator . hasNext ( ) ) { <END> final TYPE_2 next = iterator . next ( ) ; for ( final TYPE_2 line : this . VAR_2 . METHOD_3 ( ) ) { if ( next . VAR_3 ( line ) ) { result . add ( line ) ; } } } return result ; } 
public void METHOD_1 ( ) throws Exception { <START> final String file = STRING_1 ; <END> new TYPE_1 ( file , TYPE_2 . is ( false ) , TYPE_2 . METHOD_2 ( String . format ( TYPE_3 . VAR_2 , STRING_2 ) ) ) . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_1 . TYPE_5 ( ) . METHOD_2 ( STRING_1 , STRING_2 ) ; final TYPE_3 VAR_2 = new TYPE_4 ( true ) ; <START> VAR_2 . METHOD_3 ( VAR_1 ) ; <END> } 
private static String METHOD_1 ( String VAR_1 ) { final TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> return VAR_2 . getName ( ) . METHOD_3 ( CHAR_1 , CHAR_2 ) + CHAR_2 + VAR_2 . METHOD_4 ( ) + CHAR_2 ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = METHOD_2 ( ) ; <END> if ( VAR_1 instanceof TYPE_3 ) { return ( ( TYPE_3 ) VAR_1 ) . METHOD_1 ( ) ; } else if ( VAR_1 instanceof TYPE_4 ) { return ( TYPE_1 ) ( ( TYPE_4 ) VAR_1 ) . METHOD_1 ( ) ; } throw new IllegalArgumentException ( STRING_1 ) ; } 
public void METHOD_1 ( ) { ANNOTATION_1 ( STRING_1 ) <START> TYPE_1 p = METHOD_2 ( INT_1 , 10 ) ; <END> } 
List < String > METHOD_1 ( ) { if ( node . VAR_1 ( VAR_2 ) && ! TYPE_1 . matcher ( node . VAR_3 ( VAR_2 ) ) . METHOD_2 ( ) ) { <START> return Arrays . asList ( node . VAR_3 ( VAR_2 ) . split ( STRING_1 ) ) . stream ( ) . filter ( VAR_4 - > ! VAR_4 . isEmpty ( ) ) . collect ( Collectors . VAR_5 ( ) ) ; <END> } else { return Collections . VAR_6 ( ) ; } } 
private static boolean METHOD_1 ( TYPE_1 node ) { if ( node . VAR_1 ( ) . stream ( ) . METHOD_2 ( TYPE_2 : : METHOD_3 ) ) { return true ; } else { return node . VAR_1 ( ) . stream ( ) . filter ( child - > ! METHOD_4 ( child ) ) . METHOD_2 ( TYPE_2 : : METHOD_1 ) ; <START> } <END> } 
private static boolean METHOD_1 ( TYPE_1 node ) { String VAR_1 = node . VAR_2 ( STRING_1 ) ; <START> return VAR_1 != null && ( STRING_2 . equalsIgnoreCase ( VAR_1 ) || STRING_3 . equalsIgnoreCase ( VAR_1 ) ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 node ) { String VAR_1 = node . VAR_2 ( STRING_1 ) ; <START> return VAR_1 != null && STRING_2 . equalsIgnoreCase ( VAR_1 ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 node ) { if ( node . VAR_1 ( ) . stream ( ) . METHOD_2 ( TYPE_2 : : METHOD_3 ) ) { return true ; } else { <START> return node . VAR_1 ( ) . stream ( ) . filter ( child - > ! METHOD_4 ( child ) ) . METHOD_2 ( TYPE_2 : : METHOD_1 ) ; <END> } } 
private static boolean METHOD_1 ( TYPE_1 node ) { if ( node . VAR_1 ( ) . stream ( ) . METHOD_2 ( TYPE_2 : : METHOD_3 ) ) { return true ; } else { <START> return node . VAR_1 ( ) . stream ( ) . filter ( child - > ! METHOD_4 ( child ) ) . METHOD_2 ( TYPE_2 : : METHOD_1 ) ; <END> } } 
public TYPE_1 ( String VAR_2 , String VAR_3 , Class VAR_4 , String VAR_5 ) { this ( VAR_2 , VAR_3 , VAR_4 ) ; if ( VAR_5 == null ) { this . VAR_5 = true ; } else { <START> this . VAR_5 = Boolean . VAR_6 ( VAR_5 ) ; <END> } } 
public boolean apply ( TYPE_1 VAR_1 , TYPE_2 source ) { TYPE_3 VAR_2 = VAR_1 . METHOD_1 ( VAR_3 . METHOD_2 ( VAR_1 , source ) ) ; if ( VAR_2 == null ) { return true ; } int count = VAR_2 . METHOD_3 ( VAR_2 . METHOD_4 ( ) , source , VAR_1 ) . size ( ) ; VAR_2 . METHOD_5 ( count , source . VAR_4 ( ) , VAR_1 ) ; <START> return false ; <END> } 
public boolean apply ( TYPE_1 VAR_1 , TYPE_2 source ) { TYPE_3 VAR_2 = VAR_1 . METHOD_1 ( source . VAR_3 ( ) ) ; if ( VAR_2 != null ) { <START> VAR_2 . METHOD_2 ( VAR_2 . METHOD_3 ( ) , source , VAR_1 ) ; <END> } return false ; } 
public TYPE_5 ( String name ) { super ( name ) ; <START> this . add ( TYPE_1 . METHOD_1 ( TYPE_3 . TYPE_4 . METHOD_2 ( ) ) ) ; <END> } 
public TYPE_10 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , VAR_3 , new TYPE_3 [ ] { TYPE_3 . VAR_4 } , STRING_1 ) ; this . METHOD_1 ( ) . METHOD_2 ( new TYPE_4 ( new TYPE_5 ( INT_1 ) , new TYPE_5 ( 3 ) , <START> new TYPE_6 ( TYPE_9 . instance ) , <END> STRING_2 ) ) ; this . METHOD_1 ( ) . METHOD_3 ( new TYPE_7 ( ) ) ; this . METHOD_1 ( ) . METHOD_4 ( new TYPE_8 ( ) ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return this . VAR_1 . METHOD_2 ( ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 event , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( event . VAR_3 ( ) ) ; if ( VAR_2 != null ) { for ( TYPE_4 VAR_4 : VAR_2 . METHOD_4 ( ) ) { <START> if ( VAR_4 instanceof TYPE_5 && ( ( TYPE_5 ) VAR_4 ) . METHOD_5 ( VAR_1 , VAR_2 . METHOD_6 ( ) ) > 0 ) { <END> return true ; } } } return false ; } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , VAR_3 , new TYPE_3 [ ] { TYPE_3 . VAR_4 } , STRING_1 ) ; <START> this . VAR_5 . add ( TYPE_6 . VAR_7 ) ; <END> this . METHOD_1 ( ) . METHOD_2 ( new TYPE_4 ( ) ) ; this . METHOD_1 ( ) . METHOD_3 ( new TYPE_5 ( ) ) ; } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , VAR_3 , new TYPE_3 [ ] { TYPE_3 . VAR_4 } , STRING_1 ) ; <START> this . METHOD_1 ( new TYPE_4 ( new TYPE_5 ( new TYPE_6 ( ) , 1 , true , false ) , filter , false ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 event , TYPE_2 VAR_1 ) { if ( event . getType ( ) == TYPE_1 . TYPE_3 . VAR_3 ) { VAR_4 . METHOD_2 ( event . VAR_5 ( ) , 0 ) ; <START> VAR_4 . METHOD_3 ( event . VAR_5 ( ) , ( VAR_6 , VAR_7 ) - > VAR_7 += 1 ) ; <END> } } 
public boolean METHOD_1 ( TYPE_1 input , TYPE_2 VAR_1 ) { <START> if ( ! input . VAR_2 ( ) . contains ( TYPE_5 . VAR_4 ) ) { <END> return false ; } for ( TYPE_3 VAR_5 : ( ( TYPE_4 ) input ) . METHOD_2 ( ) ) { TYPE_4 VAR_6 = VAR_1 . METHOD_3 ( VAR_5 ) ; if ( VAR_6 != null && VAR_6 . METHOD_4 ( ) . contains ( TYPE_5 . VAR_7 ) ) { return true ; } } return false ; } 
public boolean apply ( TYPE_1 VAR_1 , TYPE_2 source ) { TYPE_3 VAR_2 = VAR_1 . METHOD_1 ( VAR_1 . METHOD_2 ( ) ) ; <START> return VAR_2 != null && VAR_1 . METHOD_1 ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( source . VAR_3 ( ) , VAR_1 ) && VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) . getType ( ) . METHOD_6 ( ) < 5 ; <END> } 
public boolean METHOD_1 ( TYPE_1 req , TYPE_2 VAR_1 ) throws TYPE_3 { <START> this . VAR_2 = null ; <END> this . VAR_3 = false ; this . VAR_4 = false ; this . VAR_5 = null ; this . VAR_6 = null ; this . VAR_7 = false ; this . VAR_8 = false ; this . VAR_9 = false ; req . VAR_10 ( this , VAR_1 ) ; METHOD_2 ( ) ; return true ; } 
<START> public String METHOD_1 ( ) { <END> if ( ( VAR_1 == null ) || ( VAR_1 . trim ( ) . isEmpty ( ) ) ) { return null ; } else { return VAR_1 ; } } 
public TYPE_6 ( String VAR_2 , String VAR_3 , String VAR_4 , boolean VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> VAR_6 = TYPE_1 . getInstance ( ) ; <END> VAR_7 = new TYPE_2 ( ) ; VAR_8 = new TYPE_3 ( VAR_2 , new TYPE_4 ( ) , new TYPE_5 ( VAR_3 , VAR_4 ) ) ; } 
public void METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) . getValue ( ) ) VAR_2 . get ( ) . METHOD_3 ( TYPE_1 . VAR_4 , STRING_1 , STRING_2 ) ; <START> else if ( VAR_5 == VAR_6 ) <END> VAR_2 . get ( ) . METHOD_3 ( TYPE_1 . VAR_4 , STRING_1 , STRING_3 + VAR_6 + STRING_4 ) ; else METHOD_4 ( ) ; } 
public boolean equals ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 . equals ( VAR_1 . VAR_2 ) ) <END> return true ; return false ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; <START> VAR_2 = <END> VAR_1 . METHOD_3 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) ) ; VAR_1 . METHOD_6 ( ) ; VAR_1 . METHOD_7 ( VAR_4 ) ; METHOD_8 ( false ) ; } 
protected TYPE_1 METHOD_1 ( ) { VAR_1 = new TYPE_1 ( STRING_1 ) ; <START> VAR_1 . METHOD_2 ( VAR_2 = <END> VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ) ; VAR_1 . METHOD_2 ( VAR_3 . METHOD_5 ( ) . METHOD_4 ( ) ) ; VAR_1 . METHOD_2 ( VAR_3 . METHOD_6 ( ) . METHOD_4 ( ) ) ; VAR_1 . METHOD_7 ( VAR_3 . METHOD_8 ( ) . METHOD_4 ( ) ) ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 command , TYPE_3 column ) { for ( TYPE_1 cmd : VAR_1 ) { <START> if ( cmd . VAR_2 ( ) == command && <END> cmd . VAR_3 ( ) == column . getName ( ) ) return cmd ; } TYPE_1 VAR_4 = new TYPE_1 ( command , column . getName ( ) , this ) ; VAR_1 . add ( VAR_4 ) ; return VAR_4 ; } 
public void METHOD_1 ( String name ) { if ( TYPE_1 . METHOD_2 ( name ) ) { <START> TYPE_2 . METHOD_3 ( STRING_1 ) ; <END> if ( VAR_1 != null ) { VAR_1 . METHOD_4 ( "" ) ; VAR_1 = null ; } return ; } TYPE_3 column = METHOD_5 ( name ) ; if ( column == null ) column = METHOD_5 ( VAR_2 ) ; METHOD_1 ( column ) ; } 
void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( new TYPE_1 ( ) { <END> @Override public void execute ( ) { METHOD_3 ( new TYPE_2 < String > ( ) { @Override public void execute ( String VAR_2 ) { METHOD_4 ( STRING_1 + VAR_2 + STRING_2 ) ; } } ) ; } } , new TYPE_1 ( ) { public void execute ( ) { } } , STRING_3 ) ; } 
public TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 ) { return new TYPE_1 ( ) { @Override public void execute ( ) { METHOD_2 ( new ArrayList < TYPE_2 > ( ) , VAR_1 ) ; } } ; <START> } <END> 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ( ) - > { VAR_2 . METHOD_3 ( new TYPE_1 ( getPath ( ) , VAR_3 . METHOD_4 ( ) . getValue ( ) ? TYPE_3 . VAR_5 : TYPE_3 . VAR_6 , METHOD_5 ( ) ) ) ; } , new TYPE_2 ( ) { public void execute ( ) { <START> } <END> } , STRING_1 ) ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( new TYPE_1 ( ) { @Override public void execute ( ) { VAR_2 . METHOD_3 ( new TYPE_2 ( getPath ( ) ) ) ; } } , new TYPE_1 ( ) { public void execute ( ) { <START> } <END> } , STRING_1 ) ; } 
public void METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( VAR_2 ) ) { VAR_1 . METHOD_3 ( VAR_2 , true ) ; VAR_1 . METHOD_4 ( ) . METHOD_5 ( VAR_3 , new TYPE_1 < String > ( ) { @Override public void METHOD_6 ( String results ) { VAR_1 . METHOD_7 ( ) ; } @Override public void METHOD_8 ( TYPE_2 error ) { <START> TYPE_3 . METHOD_9 ( error ) ; <END> } } ) ; } } 
public void METHOD_1 ( ) { VAR_1 = true ; <START> TYPE_1 . get ( ) . METHOD_2 ( ( ) - > METHOD_3 ( ) ) ; <END> } 
public boolean METHOD_1 ( ) { switch ( VAR_1 ) { case VAR_2 : <START> return false ; <END> case VAR_3 : return false ; default : return true ; } } 
public boolean METHOD_1 ( ) { <START> TYPE_1 VAR_1 = VAR_2 . get ( VAR_2 . size ( ) - 1 ) ; <END> return TYPE_2 . equals ( VAR_1 . METHOD_2 ( ) , STRING_1 ) && VAR_1 . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) { VAR_1 . forEach ( VAR_2 - > { if ( VAR_2 . METHOD_2 ( ) ) { <START> VAR_2 . METHOD_1 ( ) ; <END> } } ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 ) { <START> super ( ) ; <END> TYPE_3 . TYPE_4 . METHOD_1 ( this ) ; VAR_3 = VAR_2 ; } 
private void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) <START> VAR_1 . METHOD_3 ( ) ; <END> if ( VAR_2 . METHOD_4 ( ) . getValue ( ) == TYPE_1 . VAR_4 ) VAR_1 . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ; } 
<START> public boolean contains ( ANNOTATION_1 TYPE_1 user ) { <END> return user . getProperty ( TYPE_2 . class ) != null ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 description = super . METHOD_1 ( ) ; <START> description . VAR_1 ( STRING_1 ) ; <END> description . VAR_1 ( STRING_2 ) ; return description ; } 
public String METHOD_1 ( ) { <START> return TYPE_1 . VAR_2 ; <END> } 
public long METHOD_1 ( ) { <START> return 1 ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { Context . VAR_2 ( ) . METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) ) ; <START> return VAR_1 ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) { return "" ; } else { <START> if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) != null ) <END> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . getName ( ) . getName ( ) ; return VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { TYPE_1 description = new TYPE_1 ( ) ; description . VAR_1 ( STRING_1 ) ; description . VAR_1 ( STRING_2 ) ; description . VAR_1 ( STRING_3 ) ; description . VAR_1 ( STRING_4 ) ; description . VAR_1 ( STRING_5 ) ; description . VAR_1 ( STRING_6 ) ; description . VAR_1 ( STRING_7 ) ; <START> description . VAR_1 ( STRING_8 ) ; <END> return description ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { TYPE_1 description = new TYPE_1 ( ) ; description . VAR_1 ( STRING_1 ) ; description . VAR_1 ( STRING_2 ) ; <START> description . VAR_1 ( STRING_3 ) ; <END> description . VAR_1 ( STRING_4 ) ; description . VAR_1 ( STRING_5 ) ; description . VAR_1 ( STRING_6 ) ; description . VAR_1 ( STRING_7 ) ; return description ; } 
public void METHOD_1 ( ) { log . info ( STRING_1 ) ; <START> new TYPE_1 ( STRING_2 ) . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 task ) throws TYPE_2 { if ( Context . VAR_1 ( ) . METHOD_2 ( task . getName ( ) ) . METHOD_3 ( ) ) { <START> Context . VAR_1 ( ) . METHOD_4 ( task ) ; <END> } } 
public void METHOD_1 ( TYPE_1 task ) throws TYPE_2 { for ( String VAR_1 : VAR_2 ) { <START> if ( VAR_1 . equals ( task . getName ( ) ) ) { <END> VAR_2 . remove ( VAR_1 ) ; break ; } } } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_2 ( VAR_1 ) ; <START> return Context . VAR_3 ( ) . METHOD_3 ( VAR_1 . getName ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 task ) throws TYPE_2 { <START> if ( Context . VAR_1 ( ) . METHOD_2 ( task . getName ( ) ) . METHOD_3 ( ) ) { <END> Context . VAR_1 ( ) . METHOD_4 ( task ) ; } Context . VAR_1 ( ) . METHOD_1 ( task . getId ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . VAR_2 . add ( VAR_3 ) ; METHOD_2 ( METHOD_3 ( METHOD_4 ( METHOD_5 ( ) , STRING_1 + METHOD_6 ( ) + STRING_2 ) ) ) ; assertThat ( VAR_1 . VAR_2 , METHOD_7 ( METHOD_8 ( VAR_3 ) ) ) ; <START> } <END> 
public boolean equals ( Object o ) { if ( this == o ) return true ; <START> if ( o == null || getClass ( ) != o . getClass ( ) ) <END> return false ; TYPE_1 that = ( TYPE_1 ) o ; if ( ! name . equals ( that . name ) ) return false ; return value != null ? value . equals ( that . value ) : that . value == null ; } 
private boolean METHOD_1 ( TYPE_1 o ) { boolean VAR_1 = false ; for ( TYPE_2 p : o . getParameters ( ) ) { if ( p . getName ( ) . equals ( STRING_1 ) ) { <START> VAR_1 = true ; <END> } } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = Context . VAR_2 ( ) . METHOD_2 ( TYPE_2 . VAR_4 ) ; <END> return VAR_1 ; } 
<START> public TYPE_1 getValue ( TYPE_2 VAR_1 ) { <END> if ( VAR_1 . METHOD_1 ( ) == null ) return null ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . put ( STRING_1 , TYPE_3 . METHOD_2 ( VAR_1 . METHOD_1 ( ) , TYPE_4 . VAR_4 ) ) ; return VAR_2 ; } 
private List < String > METHOD_1 ( ) { <START> int index = VAR_1 . METHOD_2 ( METHOD_3 ( TYPE_1 . VAR_3 ) ) ; <END> return this . METHOD_4 ( index ) ; } 
public TYPE_1 ( String VAR_2 , String description ) { <START> super ( VAR_2 ) ; this . description = description ; this . VAR_3 = Integer . VAR_4 ; <END> } 
public Object METHOD_1 ( ) { <START> if ( Boolean . VAR_1 . METHOD_2 ( this . getType ( ) ) ) <END> { return false ; } else return null ; } 
public static TYPE_1 METHOD_1 ( String location ) { <START> VAR_1 = Thread . VAR_2 ( ) . METHOD_2 ( ) ; <END> TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . location = location ; return VAR_3 ; } 
public void METHOD_1 ( TYPE_1 event , TYPE_2 context ) { METHOD_2 ( event , context ) ; TYPE_3 VAR_1 = METHOD_3 ( event , METHOD_4 ( ) ) ; if ( VAR_1 instanceof TYPE_4 ) { METHOD_1 ( event , context , ( ( TYPE_4 ) VAR_1 ) . METHOD_5 ( ) ) ; } else { <START> METHOD_1 ( event , context ) ; <END> } } 
<START> public TYPE_1 ( Class < T > type ) <END> { this . type = type ; } 
public void METHOD_1 ( ) { TYPE_1 < Integer > d = METHOD_2 ( List . VAR_1 ( 0 , INT_1 ) ) ; <START> assertThat ( d . VAR_2 ( ) , is ( d . run ( ) . METHOD_3 ( ) ) ) ; <END> } 
<START> private TYPE_3 ( TYPE_1 < TYPE_2 > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
<START> private TYPE_3 ( TYPE_1 < TYPE_2 > start ) { <END> this . start = start ; } 
<START> private TYPE_6 ( TYPE_1 < TYPE_2 , TYPE_3 < TYPE_4 > > f , TYPE_5 < TYPE_2 > next ) { <END> this . next = next ; this . f = f ; } 
<START> public < TYPE_1 > TYPE_2 < TYPE_1 > METHOD_1 ( final TYPE_3 < TYPE_4 , TYPE_2 < TYPE_1 > > f ) { <END> return bind ( f ) ; } 
<START> TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return this ; } 
public static < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_1 , TYPE_2 > METHOD_1 ( TYPE_4 < TYPE_1 > e , TYPE_5 < TYPE_1 , TYPE_6 < TYPE_1 , TYPE_2 > > VAR_1 ) { <START> return new TYPE_3 < TYPE_1 , TYPE_2 > ( e , VAR_1 ) ; <END> } 
public static < TYPE_1 > TYPE_2 < Integer , TYPE_1 > METHOD_1 ( ) { <START> return METHOD_2 ( TYPE_5 . VAR_2 , TYPE_3 . empty ( TYPE_6 . VAR_4 , ( TYPE_4 < Integer , TYPE_1 > p ) - > p . VAR_5 ( ) ) ) ; <END> } 
<START> public TYPE_1 < TYPE_2 > println ( final String s ) { <END> return ( ) - > { result = s ; return TYPE_2 . METHOD_1 ( ) ; } ; } 
public < TYPE_1 > List < TYPE_2 < TYPE_3 , TYPE_1 > > METHOD_1 ( TYPE_4 < T , List < TYPE_1 > > f ) { return METHOD_2 ( ) ? f . f ( METHOD_3 ( ) ) . map ( c - > TYPE_5 < TYPE_3 , TYPE_1 > METHOD_3 ( c ) ) : list ( TYPE_5 < TYPE_3 , TYPE_1 > METHOD_4 ( e . VAR_2 ( ) . value ( ) ) ) ; <START> } <END> 
public final < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_2 > METHOD_1 ( TYPE_3 < TYPE_1 > VAR_1 , final TYPE_4 < TYPE_2 , TYPE_1 > f ) { return b - > { <START> VAR_1 . f ( f . f ( b ) ) ; <END> } ; } 
public String toString ( ) { <START> final TYPE_1 sb = new TYPE_1 ( INT_1 ) . append ( STRING_1 ) . append ( VAR_1 ) ; <END> if ( VAR_2 != null && VAR_2 . length > 0 ) { sb . append ( STRING_2 ) ; for ( TYPE_2 d : ( TYPE_2 [ ] ) VAR_2 ) { sb . append ( d ) ; } sb . append ( CHAR_1 ) ; } return sb . append ( CHAR_2 ) . toString ( ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> if ( ! METHOD_2 ( VAR_1 ) ) <END> throw new TYPE_1 ( STRING_1 + VAR_1 + STRING_2 ) ; METHOD_1 ( VAR_1 != null ? new TYPE_2 ( VAR_1 ) : null ) ; } 
public String METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; String VAR_2 = VAR_3 != null ? VAR_3 . VAR_2 : null ; if ( VAR_1 != null && ! TYPE_2 . isEmpty ( VAR_2 ) && ! VAR_2 . contains ( STRING_1 ) ) VAR_2 = VAR_2 . METHOD_3 ( STRING_2 + VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; <START> return VAR_2 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( "" , false ) ; TYPE_2 VAR_1 = METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ) ; <START> Assert . assertEquals ( STRING_1 , TYPE_1 . METHOD_5 ( ) ) ; <END> TYPE_1 . close ( ) ; } 
public static List < String > METHOD_1 ( String key , List < String > values ) { if ( key == null ) throw new TYPE_1 ( ) ; if ( key . length ( ) == 0 ) throw new IllegalArgumentException ( ) ; List < String > VAR_1 = VAR_2 . get ( key ) ; if ( VAR_1 == null ) VAR_1 = new TYPE_2 < String > ( ) ; <START> VAR_1 . addAll ( values ) ; <END> return VAR_2 . put ( key , VAR_1 ) ; } 
public static List < String > METHOD_1 ( String key , List < String > values ) { if ( key == null ) throw new TYPE_1 ( ) ; if ( key . length ( ) == 0 ) throw new IllegalArgumentException ( ) ; List < String > VAR_1 = VAR_2 . get ( key ) ; synchronized ( VAR_2 ) { if ( VAR_1 == null ) VAR_1 = new TYPE_2 < String > ( ) ; VAR_1 . addAll ( values ) ; } <START> return VAR_2 . put ( key , VAR_1 ) ; <END> } 
public static List < String > METHOD_1 ( String key ) { final List < String > v ; <START> v = VAR_1 . get ( key ) ; <END> return v ; } 
private boolean METHOD_1 ( ) { if ( VAR_1 == null ) VAR_1 = Boolean . valueOf ( STRING_1 . equals ( TYPE_1 . getProperty ( STRING_2 ) ) ) ; return Utils . VAR_2 ( this , STRING_3 , VAR_1 . METHOD_2 ( ) , true ) ; <START> } <END> 
public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( METHOD_4 ( STRING_1 ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; METHOD_7 ( ) ; Assert . assertTrue ( METHOD_4 ( STRING_2 ) . exists ( ) ) ; METHOD_7 ( ) ; METHOD_3 ( METHOD_4 ( STRING_3 ) ) ; METHOD_7 ( ) ; METHOD_3 ( METHOD_4 ( STRING_4 ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; METHOD_7 ( ) ; Assert . assertTrue ( METHOD_4 ( STRING_2 ) . exists ( ) ) ; <START> METHOD_7 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! TYPE_2 . equals ( VAR_2 , VAR_1 ) ) { VAR_2 = VAR_1 ; if ( METHOD_2 ( ) == null ) { <START> if ( STRING_1 . equals ( VAR_1 . toString ( ) ) ) { <END> METHOD_3 ( STRING_2 ) ; } else { METHOD_3 ( METHOD_4 ( ) ) ; } } METHOD_5 ( ) ; } } 
private String getName ( TYPE_1 url ) { String name = url . getPath ( ) ; if ( name != null ) { <START> { <END> final int j = name . VAR_1 ( File . VAR_2 ) ; if ( j >= 0 ) name = name . substring ( j + 1 ) ; } if ( File . VAR_2 != CHAR_1 ) { final int j = name . VAR_1 ( CHAR_1 ) ; if ( j >= 0 ) name = name . substring ( j + 1 ) ; } } return name ; } 
protected void METHOD_1 ( org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_4 VAR_6 ) throws TYPE_2 . TYPE_3 . IOException { super . METHOD_1 ( VAR_6 ) ; if ( VAR_7 > 0 ) VAR_6 . METHOD_2 ( STRING_1 , VAR_7 ) ; if ( VAR_7 > 0 && VAR_8 > 0 ) VAR_6 . METHOD_2 ( STRING_2 , VAR_8 ) ; <START> VAR_6 . METHOD_2 ( STRING_3 , METHOD_3 ( ) ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 item ) { if ( ! super . METHOD_1 ( item ) ) { if ( item . VAR_1 ( ) == R . id . VAR_2 ) { TYPE_2 . METHOD_2 ( ) ; <START> return true ; <END> } return false ; } else { return true ; } } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( 10 , 0 , false ) ; List < String > VAR_2 = TYPE_2 . METHOD_3 ( ) ; assertNotNull ( VAR_2 ) ; <START> assertEquals ( VAR_2 . size ( ) , VAR_1 . size ( ) ) ; <END> for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { assertEquals ( VAR_2 . get ( i ) , VAR_1 . get ( i ) . METHOD_4 ( ) ) ; } } 
public void METHOD_1 ( final TYPE_1 db , final int VAR_1 , final int VAR_2 ) { Log . VAR_3 ( STRING_1 , STRING_2 + VAR_1 + STRING_3 + VAR_2 + STRING_4 ) ; TYPE_2 . METHOD_2 ( db , VAR_1 , VAR_2 ) ; <START> if ( VAR_1 == INT_1 ) { <END> db . VAR_4 ( STRING_5 + VAR_5 + STRING_6 + VAR_6 + STRING_7 ) ; db . VAR_4 ( STRING_5 + VAR_5 + STRING_6 + VAR_7 + STRING_7 ) ; } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; TYPE_1 . METHOD_2 ( ) . METHOD_3 ( this ) ; <START> VAR_1 = VAR_2 . getString ( VAR_3 , VAR_4 ) ; <END> VAR_5 = VAR_2 . getString ( VAR_6 , VAR_4 ) ; VAR_7 = VAR_2 . getString ( VAR_8 , VAR_4 ) ; METHOD_4 ( ) ; } 
public String METHOD_1 ( ) { <START> return VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_1 . METHOD_2 ( description ) ; <END> } 
private static boolean METHOD_1 ( String VAR_1 ) { final String VAR_2 = STRING_1 ; TYPE_1 VAR_3 = TYPE_2 . isEmpty ( VAR_2 ) ? null : TYPE_1 . METHOD_2 ( VAR_2 ) ; boolean VAR_4 = VAR_3 . matcher ( VAR_1 ) . METHOD_3 ( ) ; <START> return VAR_4 ; <END> } 
public static String METHOD_1 ( String VAR_1 ) { <START> if ( ! TYPE_1 . isEmpty ( VAR_1 ) && METHOD_2 ( VAR_1 ) ) { <END> TYPE_2 VAR_2 = new TYPE_2 ( ) ; TYPE_3 VAR_3 = TYPE_4 . parse ( VAR_1 ) ; VAR_1 = StringUtils . trim ( VAR_2 . METHOD_1 ( VAR_3 ) ) ; } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = TYPE_2 . METHOD_2 ( ) ; if ( VAR_2 ) { <START> TYPE_2 . METHOD_3 ( VAR_1 ) ; <END> } TYPE_3 . METHOD_4 ( VAR_1 , true ) ; } 
void METHOD_1 ( ) { if ( VAR_1 == null ) { return ; } <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( ) ; <START> new Thread ( ( ) - > VAR_1 . METHOD_3 ( ) ) . start ( ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 params ) { Log . d ( TAG , STRING_1 ) ; TYPE_2 . METHOD_2 ( METHOD_3 ( ) ) ; <START> <END> new Thread ( ( ) - > { TYPE_3 . METHOD_4 ( METHOD_3 ( ) , true ) ; TYPE_4 . METHOD_5 ( false ) ; METHOD_6 ( params , false ) ; } ) . start ( ) ; return true ; } 
public static void METHOD_1 ( final Context context , final List < TYPE_1 > VAR_1 ) { <START> new Thread ( ( ) - > METHOD_2 ( context , VAR_1 ) ) . start ( ) ; <END> } 
<START> private static String METHOD_1 ( TYPE_1 VAR_1 ) { <END> String VAR_2 = null ; if ( VAR_1 != null ) { VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 == null ) { if ( VAR_1 instanceof TYPE_2 ) { VAR_2 = TYPE_3 . METHOD_3 ( ( ( TYPE_2 ) VAR_1 ) . METHOD_4 ( ) ) ; } } } return VAR_2 ; } 
public static String METHOD_1 ( TYPE_1 item ) { String VAR_1 = null ; if ( item != null ) { VAR_1 = item . VAR_2 ( ) ; if ( VAR_1 == null ) { TYPE_2 VAR_3 = item . VAR_4 ( ) ; if ( VAR_3 != null ) { VAR_1 = VAR_3 . METHOD_2 ( ) ; } } } <START> return VAR_1 ; <END> } 
public String METHOD_1 ( ) { String result = this . VAR_1 + STRING_1 + this . VAR_2 + STRING_1 + this . VAR_3 + STRING_1 + this . action + STRING_1 + this . VAR_4 . METHOD_2 ( ) + STRING_1 + String . valueOf ( this . VAR_5 ) + STRING_1 + String . valueOf ( this . position ) + STRING_1 + String . valueOf ( this . VAR_6 ) ; <START> return result ; <END> } 
private String METHOD_1 ( int size ) { if ( size == 1 ) { return STRING_1 ; } String builder = STRING_2 + TYPE_1 . METHOD_2 ( STRING_3 , Collections . VAR_1 ( size , STRING_4 ) ) + STRING_5 ; <START> return builder ; <END> } 
public void METHOD_1 ( int VAR_1 , int VAR_2 , TYPE_1 VAR_3 ) { <START> if ( VAR_1 == VAR_4 && VAR_2 == VAR_5 && VAR_3 != null ) { <END> TYPE_2 uri = VAR_3 . METHOD_2 ( ) ; METHOD_3 ( uri ) ; } else if ( VAR_1 == VAR_6 && VAR_2 == VAR_5 && VAR_3 != null ) { TYPE_2 uri = VAR_3 . METHOD_2 ( ) ; METHOD_4 ( uri ) ; } } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( INT_1 , INT_2 , INT_3 , INT_2 , INT_4 , INT_4 ) ; <END> VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( STRING_1 ) ) ; Date VAR_2 = new Date ( VAR_1 . METHOD_4 ( ) ) ; Date VAR_3 = TYPE_3 . parse ( STRING_2 ) ; assertEquals ( VAR_2 , VAR_3 ) ; } 
public static String METHOD_1 ( String url ) { <START> if ( url != null ) { <END> String VAR_1 = TYPE_1 . METHOD_2 ( url ) ; if ( VAR_1 != null ) { return TYPE_2 . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; } } return null ; } 
<START> static protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> return VAR_1 . VAR_2 ; } 
private void METHOD_1 ( ) { if ( VAR_1 == null ) { return ; } <START> if ( VAR_2 == null || ! ( this instanceof TYPE_1 ) ) { <END> VAR_1 . METHOD_2 ( View . VAR_3 ) ; return ; } METHOD_3 ( ) ; TYPE_2 . METHOD_4 ( VAR_1 , VAR_2 . METHOD_5 ( ) ? FLOAT_1 : FLOAT_2 ) ; VAR_1 . METHOD_2 ( View . VAR_4 ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 token ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = TYPE_3 . getInstance ( ) . METHOD_2 ( token ) ; } return VAR_1 ; } 
void METHOD_1 ( List < TYPE_1 > result ) { this . VAR_1 = result ; VAR_2 . clear ( ) ; if ( result != null && result . size ( ) > 0 ) { VAR_3 . METHOD_2 ( View . VAR_4 ) ; VAR_5 . METHOD_2 ( View . VAR_6 ) ; <START> VAR_2 . addAll ( result ) ; <END> VAR_2 . METHOD_3 ( ) ; } else { VAR_3 . METHOD_2 ( View . VAR_6 ) ; VAR_5 . METHOD_2 ( View . VAR_4 ) ; } } 
public static boolean METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( VAR_2 , false ) ; <END> } 
public TYPE_1 < T > build ( ) { <START> return new TYPE_1 < T > ( TYPE_2 . VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { TYPE_3 VAR_3 = VAR_1 . METHOD_2 ( ) ; TYPE_4 VAR_4 = ( ( TYPE_4 ) VAR_3 ) . get ( VAR_5 ) ; if ( VAR_4 != null ) return VAR_4 . METHOD_3 ( ) ; else if ( VAR_3 . METHOD_4 ( ) && VAR_3 instanceof TYPE_5 ) { return ( ( TYPE_4 ) VAR_3 ) . METHOD_5 ( ) ; } else <START> return VAR_3 . toString ( ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 == null ) { throw new TYPE_1 ( STRING_1 ) ; } <END> if ( StringUtils . VAR_2 ( VAR_1 ) ) { this . VAR_1 = TYPE_2 . METHOD_2 ( VAR_1 ) ; } } 
<START> public void METHOD_1 ( ) throws TYPE_1 { <END> TYPE_2 VAR_1 = new TYPE_2 ( 10 ) ; VAR_1 . add ( STRING_1 ) ; assertEquals ( VAR_1 . METHOD_2 ( ) , 10 ) ; assertEquals ( VAR_1 . get ( 0 ) , STRING_1 ) ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { if ( StringUtils . VAR_2 ( METHOD_2 ( ) ) ) { return METHOD_2 ( ) ; } if ( VAR_1 != null && VAR_1 . containsKey ( VAR_3 ) ) { <START> return VAR_1 . METHOD_3 ( VAR_3 ) . METHOD_4 ( "" ) ; <END> } return null ; } 
public void METHOD_1 ( ) throws Exception { exception . VAR_1 ( TYPE_1 . class ) ; <START> VAR_2 . METHOD_2 ( null ) ; <END> session . put ( STRING_1 , STRING_2 ) ; TYPE_2 res = METHOD_3 ( VAR_2 , null , session ) ; assertEquals ( res . VAR_3 ( ) . toString ( ) , STRING_3 ) ; } 
public TYPE_1 ( Object request ) { if ( request instanceof TYPE_1 ) { <START> this . request = ( ( TYPE_1 ) request ) . METHOD_1 ( ) ; <END> } else { this . request = request ; } } 
private ArrayList < String > METHOD_1 ( Class VAR_1 ) { ArrayList < String > VAR_2 = new ArrayList < String > ( ) ; int index = 0 ; while ( VAR_1 . METHOD_2 ( ) != null ) { String VAR_3 = Integer . toString ( index ) ; <START> VAR_2 . add ( VAR_1 . METHOD_3 ( ) + VAR_3 ) ; <END> VAR_1 = VAR_1 . METHOD_2 ( ) ; index ++ ; } return VAR_2 ; } 
public void add ( String message , Throwable t ) { String VAR_1 = message ; if ( t . getMessage ( ) != null ) { VAR_1 += STRING_1 + t . getMessage ( ) ; } add ( VAR_1 ) ; <START> log . error ( VAR_1 , t ) ; <END> } 
protected int METHOD_1 ( File file ) { int result = 0 ; if ( file != null ) { try ( TYPE_1 VAR_1 = new TYPE_2 ( file ) ) { TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 ) ; result = VAR_2 . METHOD_2 ( ) . size ( ) ; <START> System . out . println ( STRING_1 + result ) ; <END> } catch ( IOException e ) { System . out . println ( e ) ; } } return result ; } 
private TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , String message ) { TYPE_1 result ; StringBuilder msg = new StringBuilder ( ) ; if ( VAR_1 != null ) { msg . append ( VAR_1 ) ; } msg . append ( STRING_1 + message ) ; <START> LOGGER . info ( STRING_2 + msg . toString ( ) ) ; <END> result = TYPE_1 . METHOD_1 ( VAR_2 , VAR_3 , VAR_1 , msg . toString ( ) ) ; return result ; } 
public TYPE_2 ( final TYPE_1 next , final String VAR_2 ) { <START> this ( next , VAR_2 , null , false ) ; <END> } 
public String METHOD_1 ( ) { String VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> if ( VAR_1 == null ) { <END> return VAR_2 . METHOD_2 ( ) . METHOD_4 ( ) ; } return VAR_1 ; } 
public Long METHOD_1 ( ) { try { if ( TYPE_1 . METHOD_2 ( file ) && TYPE_1 . METHOD_3 ( file ) ) { <START> return INT_1 ; <END> } return TYPE_1 . size ( file ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 < ? > action , Object object ) throws TYPE_3 { String VAR_1 = action . VAR_2 ( ) ; if ( VAR_1 != null ) { List < TYPE_4 > VAR_3 = action . VAR_4 ( ) ; TYPE_5 VAR_5 = METHOD_2 ( VAR_1 , VAR_3 ) ; if ( VAR_5 != null ) { <START> try { <END> return METHOD_3 ( VAR_5 , object , VAR_1 , VAR_3 ) ; } catch ( TYPE_6 e ) { throw new TYPE_7 ( e ) ; } } } throw new TYPE_7 ( STRING_1 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; String value = VAR_2 . METHOD_3 ( VAR_1 ) ; <START> assertThat ( value ) . METHOD_4 ( VAR_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { String VAR_1 = METHOD_2 ( ) + VAR_2 ; TYPE_3 VAR_3 = METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) , VAR_1 ) ; if ( VAR_3 != null ) { try { METHOD_6 ( VAR_1 , VAR_3 ) ; METHOD_7 ( ) ; } finally { VAR_3 . close ( ) ; <START> } <END> } else { METHOD_8 ( ) . debug ( STRING_1 ) ; } return METHOD_9 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 action , TYPE_3 result , TYPE_4 < TYPE_5 > VAR_1 , TYPE_6 < TYPE_2 , TYPE_3 > VAR_2 ) { VAR_2 . METHOD_1 ( action , result , VAR_1 ) ; <START> return new TYPE_7 ( ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return action ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 action , TYPE_4 < R > VAR_4 ) { this . action = action ; this . VAR_4 = VAR_4 ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> METHOD_1 ( ) ; <END> } 
<START> protected < T > TYPE_1 < T > METHOD_1 ( Class < T > VAR_1 ) { <END> TYPE_2 < T > VAR_2 = bind ( VAR_1 ) ; if ( VAR_3 != null ) { return VAR_2 . METHOD_2 ( VAR_3 ) ; } return VAR_2 ; } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( ) == null ? null : METHOD_2 ( ) . METHOD_1 ( ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> assert parent != null : STRING_1 ; parent . VAR_1 ( VAR_2 , this ) ; } 
<START> public TYPE_4 ( Logger logger , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> super ( TYPE_3 . class ) ; this . logger = logger ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
protected TYPE_1 METHOD_1 ( ) { super . METHOD_1 ( ) ; try { TYPE_2 VAR_1 = METHOD_2 ( ) ; return new TYPE_3 ( VAR_1 . METHOD_3 ( ) ) ; <START> } catch ( TYPE_4 | TYPE_5 e ) { <END> METHOD_4 ( e ) ; } return new TYPE_6 ( ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 . equals ( TYPE_2 . TYPE_3 ) ) { <END> VAR_2 . METHOD_2 ( VAR_1 ) ; } else { VAR_2 . METHOD_3 ( VAR_1 ) ; } } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( ) . METHOD_2 ( ) ; } 
protected void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( this , false ) ; if ( ! TYPE_2 . METHOD_3 ( METHOD_4 ( ) ) ) { METHOD_5 ( ) ; } if ( ! VAR_1 . METHOD_6 ( ) && ! METHOD_7 ( ) ) { <START> TYPE_3 p = new Builder ( ) . METHOD_8 ( TYPE_4 . VAR_3 ) . METHOD_9 ( VAR_4 , METHOD_10 ( ) ) . build ( ) ; <END> VAR_5 . METHOD_11 ( p ) ; } } 
<START> public TYPE_1 ( ANNOTATION_1 String VAR_2 , <END> ANNOTATION_2 String key , Logger log ) { this . VAR_2 = VAR_2 ; this . key = key ; this . log = log ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> VAR_3 = METHOD_2 ( TYPE_3 . class ) ; <END> METHOD_3 ( VAR_1 . create ( METHOD_4 ( TYPE_4 . class ) , METHOD_5 ( ) ) ) . METHOD_6 ( VAR_3 ) ; METHOD_3 ( VAR_2 . METHOD_7 ( VAR_4 ) ) . METHOD_6 ( VAR_5 ) ; METHOD_3 ( VAR_2 . METHOD_7 ( VAR_6 ) ) . METHOD_6 ( VAR_7 ) ; METHOD_3 ( VAR_2 . METHOD_7 ( VAR_8 ) ) . METHOD_6 ( VAR_9 ) ; } 
TYPE_7 ( ANNOTATION_1 String VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> if ( TYPE_4 . METHOD_1 ( ) ) { <END> TYPE_5 . get ( ) . METHOD_2 ( new TYPE_6 ( ) { @Override public void execute ( ) { METHOD_3 ( ) ; } } ) ; } } 
<START> public TYPE_7 ( <END> TYPE_1 VAR_2 , Logger logger , TYPE_2 < TYPE_3 > VAR_3 , TYPE_4 VAR_4 , TYPE_5 VAR_5 , TYPE_6 VAR_6 ) { super ( VAR_2 , logger , VAR_3 , VAR_4 , VAR_5 ) ; VAR_6 . METHOD_1 ( this ) ; } 
<START> public TYPE_4 ( Logger logger , <END> TYPE_1 VAR_2 , TYPE_2 VAR_3 ) throws TYPE_3 { this . logger = logger ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; METHOD_1 ( ) ; } 
public void METHOD_1 ( Throwable VAR_1 ) { if ( METHOD_2 ( ) ) { <START> TYPE_1 . log ( STRING_1 + METHOD_3 ( ) . METHOD_4 ( ) + STRING_2 + METHOD_3 ( ) . METHOD_5 ( ) ) ; <END> } TYPE_2 message = new TYPE_2 ( METHOD_6 ( VAR_1 ) , TYPE_4 . VAR_3 ) ; TYPE_3 . METHOD_7 ( VAR_4 , message ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( new TYPE_1 ( TYPE_2 . METHOD_3 ( ) ) ) ; <END> } 
short METHOD_1 ( ) { <START> return ( short ) System . currentTimeMillis ( ) ; <END> } 
public void METHOD_1 ( String VAR_1 , String type ) { <START> final TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> VAR_3 . put ( VAR_2 , type ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = 0 ; while ( true ) { <START> final String VAR_3 = VAR_1 . getProperty ( TYPE_1 . VAR_4 + VAR_2 ) ; <END> if ( null == VAR_3 ) { break ; } final int index = VAR_3 . METHOD_2 ( CHAR_1 ) ; if ( - 1 != index ) { String field = VAR_3 . substring ( 0 , index ) ; String type = VAR_3 . substring ( index + 1 ) ; METHOD_3 ( field , type ) ; } VAR_2 ++ ; } } 
private String METHOD_1 ( String VAR_1 ) { String VAR_2 = null ; <START> for ( final Map . Entry < TYPE_1 , String > entry : VAR_3 . entrySet ( ) ) { <END> if ( entry . getKey ( ) . matcher ( VAR_1 ) . METHOD_2 ( ) ) { VAR_2 = entry . getValue ( ) ; break ; } } return VAR_2 ; } 
protected boolean METHOD_1 ( ) throws IOException { <START> if ( METHOD_2 ( ) ) { <END> return false ; } if ( super . METHOD_1 ( ) ) { this . VAR_1 = VAR_2 . METHOD_3 ( ) ; this . VAR_1 . METHOD_4 ( true ) ; this . VAR_3 = VAR_1 . METHOD_5 ( ) ; VAR_1 . METHOD_6 ( ) ; METHOD_7 ( channel ( ) , VAR_1 , ByteBuffer . VAR_4 ( VAR_3 . METHOD_8 ( ) ) , ByteBuffer . VAR_4 ( VAR_3 . METHOD_8 ( ) ) ) ; } return false ; } 
public static void METHOD_1 ( boolean VAR_1 , String VAR_2 , String ... args ) { if ( ! VAR_1 ) { if ( args != null && args . length > 0 ) { <START> String message = String . format ( STRING_1 , args ) ; <END> throw new IllegalArgumentException ( message ) ; } else { throw new IllegalArgumentException ( VAR_2 ) ; } } } 
public String toString ( ) { return STRING_1 + config + STRING_2 + VAR_1 + STRING_3 + count + STRING_4 + max + STRING_5 + VAR_2 + <START> STRING_6 + VAR_3 + <END> CHAR_1 ; } 
public int METHOD_1 ( ) { int result = config . VAR_1 ( ) ; result = INT_1 * result + VAR_2 . METHOD_1 ( ) ; result = INT_1 * result + count . VAR_1 ( ) ; result = INT_1 * result + max . VAR_1 ( ) ; result = INT_1 * result + VAR_3 . METHOD_1 ( ) ; <START> result = INT_1 * result + VAR_4 . METHOD_1 ( ) ; <END> return result ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || ! ( obj instanceof TYPE_1 ) ) { return false ; } TYPE_1 m = ( TYPE_1 ) obj ; return config . equals ( m . VAR_1 ( ) ) ; <START> } <END> 
public < T > String METHOD_1 ( Type VAR_1 , T value ) throws TYPE_1 { <START> if ( VAR_1 == null && value != null ) { <END> return METHOD_2 ( value . getClass ( ) ) . METHOD_1 ( value ) ; } else { return METHOD_2 ( VAR_1 ) . METHOD_1 ( value ) ; } } 
public boolean METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public TYPE_1 ( ) { super ( ) ; <START> VAR_2 = null ; <END> } 
<START> public void METHOD_1 ( int VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 ) { try { VAR_1 . get ( VAR_2 , TimeUnit . VAR_3 ) ; } catch ( TYPE_2 VAR_4 ) { <START> System . out . println ( STRING_1 ) ; <END> return false ; } catch ( InterruptedException | TYPE_3 e ) { METHOD_2 ( ) ; } return true ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { try { TYPE_3 . logger . debug ( STRING_1 ) ; TYPE_2 . METHOD_2 ( ) ; } catch ( Throwable t ) { <START> TYPE_3 . logger . debug ( STRING_2 , t ) ; <END> } } 
<START> private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_2 type = VAR_1 . METHOD_2 ( ) ; return TYPE_4 . TYPE_5 . equals ( type . getId ( ) ) ; } 
public int METHOD_1 ( ) { <START> return VAR_1 ? 1 : 0 ; <END> } 
private static int METHOD_1 ( ) throws IOException { <START> try ( TYPE_1 VAR_1 = new TYPE_1 ( 0 ) ; ) { <END> return VAR_1 . METHOD_2 ( ) ; } } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = VAR_2 ; String VAR_3 = VAR_4 . METHOD_2 ( ) ; <START> TYPE_1 . METHOD_3 ( ) ; <END> TYPE_2 VAR_5 = TYPE_1 . METHOD_4 ( VAR_1 , VAR_3 ) ; assertTrue ( VAR_5 instanceof TYPE_3 ) ; VAR_5 . execute ( new TYPE_4 < Object > ( ) { @Override public Object run ( ) throws Exception { throw new IOException ( ) ; } } ) ; } 
private TYPE_8 ( Context context , TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; <START> VAR_3 = TYPE_2 . valueOf ( <END> context . getString ( VAR_4 , TYPE_2 . TYPE_5 . toString ( ) ) . METHOD_1 ( TYPE_7 . VAR_6 ) ) ; if ( VAR_3 == TYPE_2 . TYPE_6 ) { logger . warn ( VAR_4 + STRING_1 + TYPE_2 . TYPE_6 . toString ( ) + STRING_2 + STRING_3 + STRING_4 + STRING_5 ) ; } } 
public TYPE_5 ( File VAR_2 ) throws IOException { System . out . println ( String . format ( STRING_1 , VAR_2 ) ) ; index = new TYPE_1 ( VAR_2 , STRING_2 ) ; <START> VAR_3 = new TYPE_2 ( new TYPE_3 ( new TYPE_4 ( new File ( VAR_2 , STRING_3 ) ) , STRING_4 ) ) ; <END> VAR_3 . println ( STRING_5 ) ; VAR_3 . println ( STRING_6 ) ; } 
public String getString ( String key , String VAR_1 ) { Object value = METHOD_1 ( key ) ; if ( value == null ) { return METHOD_2 ( key , VAR_1 != null ? VAR_2 . create ( METHOD_3 ( ) ) . METHOD_4 ( VAR_1 ) : null ) ; } if ( value instanceof String ) { <START> return METHOD_4 ( value . toString ( ) ) ; <END> } else { return value . toString ( ) ; } } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
public TYPE_2 ( String VAR_2 , boolean VAR_3 ) { super ( VAR_2 , Boolean . valueOf ( VAR_3 ) ) ; this . VAR_4 = METHOD_1 ( ) ; <START> this . VAR_5 . METHOD_2 ( new TYPE_1 ( ) { <END> @Override public void run ( ) { VAR_4 = METHOD_1 ( ) ; } } ) ; } 
public String getValue ( TYPE_1 key ) { if ( VAR_1 == null ) { <START> LOG . debug ( STRING_1 + key ) ; <END> return null ; } return VAR_1 . getValue ( key ) ; } 
public void close ( ) { try { TYPE_1 . close ( VAR_1 , true ) ; } catch ( IOException VAR_2 ) { <START> logger . warn ( STRING_1 , VAR_2 ) ; <END> } } 
protected void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> METHOD_2 ( ) ; } 
void METHOD_1 ( ) { METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> } 
private boolean METHOD_1 ( long VAR_1 , TYPE_1 VAR_2 , boolean VAR_3 ) { if ( VAR_2 == null || VAR_2 . getType ( ) == TYPE_3 . VAR_5 ) { throw new RuntimeException ( STRING_1 + VAR_1 + STRING_2 ) ; } if ( VAR_2 . METHOD_2 ( ) ) { if ( VAR_3 ) { <START> throw new TYPE_2 ( Collections . VAR_6 ( VAR_1 ) ) ; <END> } return false ; } return true ; } 
public void start ( ) { this . VAR_1 . add ( new TYPE_1 ( VAR_2 ) ) ; this . VAR_3 . METHOD_1 ( this : : run ) ; <START> METHOD_2 ( ) ; <END> } 
TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 , TYPE_3 VAR_2 ) { VAR_3 = VAR_1 . get ( VAR_1 . size ( ) - 1 ) . METHOD_2 ( ) ; <START> <END> TYPE_1 VAR_4 = new TYPE_1 ( VAR_5 , VAR_6 , VAR_2 , VAR_3 , VAR_7 , VAR_8 , VAR_9 , VAR_1 ) ; VAR_7 = VAR_3 ; VAR_9 ++ ; log . trace ( STRING_1 , VAR_4 . METHOD_3 ( ) , VAR_1 . size ( ) ) ; return VAR_4 ; } 
<START> boolean METHOD_1 ( TYPE_1 entry ) { <END> Set < TYPE_2 > VAR_1 = entry . VAR_2 ( ) . keySet ( ) ; if ( VAR_3 . METHOD_2 ( VAR_1 ) ) { return true ; } VAR_1 . METHOD_3 ( VAR_3 ) ; if ( VAR_1 . isEmpty ( ) ) { return false ; } log . error ( STRING_1 , entry . VAR_2 ( ) . keySet ( ) , VAR_3 ) ; VAR_4 = true ; return false ; } 
public TYPE_2 . TYPE_3 METHOD_1 ( ) { return VAR_1 . METHOD_1 ( <START> VAR_2 . METHOD_2 ( 0 ) . getId ( ) ) ; <END> } 
<START> long query ( TYPE_3 . TYPE_4 VAR_1 , TYPE_2 key ) { <END> long val = - 1 ; String VAR_2 = METHOD_1 ( VAR_1 , key ) ; if ( VAR_2 != null ) { val = Long . VAR_3 ( VAR_2 ) ; } return val ; } 
<START> long METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( null ) ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( VAR_2 ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 message ) { message . VAR_1 ( ) . METHOD_2 ( VAR_2 ++ ) ; VAR_3 . append ( message ) ; <START> log . info ( STRING_1 , message . VAR_1 ( ) ) ; <END> TYPE_1 < TYPE_2 > VAR_4 = VAR_5 . METHOD_3 ( message ) ; METHOD_4 ( message , VAR_4 ) ; return VAR_4 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { log . debug ( STRING_1 ) ; VAR_2 = TYPE_3 . VAR_4 ; VAR_5 . METHOD_2 ( VAR_1 ) ; <START> VAR_6 = new TYPE_2 ( VAR_7 , VAR_8 , VAR_9 , <END> VAR_5 . METHOD_3 ( ) , this ) ; log . info ( STRING_2 , VAR_1 , VAR_2 ) ; } 
<START> private TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) throws InterruptedException { <END> log . info ( STRING_1 ) ; TYPE_1 < TYPE_2 > VAR_2 = new TYPE_1 < > ( ) ; this . VAR_3 = METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; VAR_4 = new TYPE_4 ( VAR_1 , VAR_3 , VAR_2 ) ; return VAR_2 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return null ; <END> } 
public void METHOD_1 ( ) { log . info ( STRING_1 ) ; VAR_1 = true ; <START> VAR_2 . close ( ) ; VAR_3 . METHOD_2 ( ) ; VAR_4 . METHOD_2 ( ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 ) { this . VAR_3 = VAR_2 . METHOD_1 ( ) ; this . VAR_4 = VAR_2 . METHOD_2 ( ) ; VAR_5 = new HashMap < > ( ) ; for ( TYPE_2 VAR_6 : VAR_2 . METHOD_3 ( ) ) { TYPE_3 VAR_7 = new TYPE_3 ( VAR_6 ) ; <START> if ( VAR_6 . METHOD_4 ( ) == TYPE_5 . VAR_9 ) { VAR_10 = VAR_7 ; <END> } else if ( VAR_6 . METHOD_4 ( ) == TYPE_5 . VAR_11 ) { METHOD_5 ( VAR_7 ) ; } } } 
private TYPE_1 METHOD_1 ( ) { return METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_2 : : METHOD_5 ) . METHOD_6 ( ) ; <START> } <END> 
public int METHOD_1 ( ) { byte [ ] VAR_1 = data ; if ( VAR_1 != null ) { <START> return VAR_1 . length + VAR_2 . size ( ) + TYPE_1 . values ( ) . length ; <END> } else if ( VAR_3 != VAR_4 ) { return VAR_3 ; } log . warn ( STRING_1 + STRING_2 ) ; return 1 ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 - > { VAR_1 . METHOD_3 ( VAR_2 - > { <START> VAR_2 . METHOD_4 ( ) . METHOD_5 ( 3 ) ; <END> } ) ; VAR_1 . METHOD_6 ( ) ; try { METHOD_7 ( VAR_1 ) ; } catch ( Exception e ) { TYPE_1 . METHOD_8 ( STRING_1 + e ) ; } } ) ; } 
public void METHOD_1 ( final TYPE_1 ctx ) throws Exception { <START> log . trace ( STRING_1 , <END> ctx . channel ( ) . METHOD_2 ( ) ) ; ctx . VAR_1 ( ) . METHOD_3 ( ctx . name ( ) , VAR_2 , new TYPE_2 ( this . VAR_3 ) ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { TYPE_2 data = VAR_1 . METHOD_1 ( ) ; <START> <END> if ( data != null && data . VAR_2 ( ) ) { throw new TYPE_3 ( ) ; } if ( data == null || data . getType ( ) != TYPE_5 . VAR_4 || ! ( data . VAR_5 ( VAR_6 ) instanceof TYPE_4 ) ) { return Collections . VAR_7 ( ) ; } return ( ( TYPE_4 ) data . VAR_5 ( VAR_6 ) ) . METHOD_2 ( VAR_1 . getId ( ) ) ; } 
private void METHOD_1 ( final TYPE_1 data ) { <START> if ( ( data . VAR_1 ( ) && ! data . VAR_2 ( ) ) || ( data . VAR_3 ( ) && ( data . VAR_4 ( ) . isEmpty ( ) || data . VAR_5 ( METHOD_2 ( ) . id ) ) ) ) { <END> METHOD_2 ( ) . METHOD_3 ( data . VAR_6 ( ) ) ; } } 
public void METHOD_1 ( TYPE_1 server ) { VAR_1 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( true ) ; <END> VAR_1 . METHOD_4 ( server ) ; } 
default void VAR_1 ( TYPE_1 msg , TYPE_3 ctx ) { VAR_4 ( ctx , msg , new TYPE_2 < > ( TYPE_4 . VAR_7 , VAR_8 ( ) ) ) ; <START> log . warn ( STRING_1 , <END> msg . VAR_9 ( ) , VAR_8 ( ) , msg ) ; } 
public TYPE_1 < Entry < TYPE_2 , TYPE_3 > > METHOD_1 ( ) { final TYPE_4 VAR_1 = new TYPE_4 ( ) ; <START> <END> VAR_1 . METHOD_2 ( null ) ; final TYPE_5 TYPE_6 = new TYPE_5 ( VAR_2 . METHOD_3 ( VAR_1 ) , VAR_3 ) ; TYPE_1 < Entry < TYPE_2 , TYPE_3 > > VAR_4 = TYPE_7 . stream ( TYPE_6 ) ; VAR_4 . METHOD_4 ( TYPE_6 : : close ) ; return VAR_4 ; } 
<START> long METHOD_1 ( ) { <END> if ( VAR_1 . METHOD_2 ( ) == null ) return TYPE_1 . VAR_3 ; ; return VAR_1 . METHOD_2 ( ) . VAR_4 ; } 
private long METHOD_1 ( ) { <START> if ( VAR_1 . METHOD_2 ( ) == null ) <END> return TYPE_1 . VAR_3 ; return VAR_1 . METHOD_2 ( ) . VAR_4 ; } 
public long METHOD_1 ( ) { if ( VAR_1 . isEmpty ( ) ) <START> return TYPE_1 . VAR_3 ; <END> return VAR_1 . METHOD_2 ( ) . VAR_4 ; } 
public static TYPE_1 parse ( Map < String , Object > VAR_1 ) { int VAR_2 = ( int ) ( VAR_1 . containsKey ( STRING_1 ) ? <START> Long . VAR_3 ( ( String ) VAR_1 . get ( STRING_1 ) ) : VAR_4 ) ; <END> return TYPE_1 . builder ( ) . METHOD_1 ( VAR_2 ) . build ( ) ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; <START> VAR_1 . getParameters ( ) . METHOD_3 ( false ) <END> . METHOD_4 ( false ) ; return VAR_1 ; } 
public boolean METHOD_1 ( ) { <START> if ( METHOD_2 ( ) != null || METHOD_3 ( ) != null ) { <END> return false ; } else { return true ; } } 
<START> void METHOD_1 ( TYPE_1 msg , TYPE_2 ctx , TYPE_3 r ) { <END> METHOD_2 ( ) . METHOD_3 ( msg , ctx , r ) ; } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 ) ; TYPE_4 . Builder VAR_4 = TYPE_4 . builder ( ) . METHOD_3 ( VAR_5 ) . METHOD_4 ( TYPE_5 . class ) <START> . METHOD_5 ( VAR_2 ) <END> . METHOD_6 ( VAR_3 ) ; METHOD_7 ( VAR_3 , VAR_4 ) ; } 
public void METHOD_1 ( ) { <START> if ( ! VAR_1 . get ( ) ) { <END> log . info ( STRING_1 ) ; return ; } VAR_2 . METHOD_2 ( ) ; log . info ( STRING_2 ) ; VAR_1 . set ( false ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> return METHOD_2 ( VAR_1 ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) throws Exception { <START> VAR_1 . METHOD_2 ( ) ; <END> TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; VAR_1 . METHOD_5 ( ) . METHOD_6 ( VAR_2 , request . VAR_3 ( ) ) ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) . size ( ) == 1 ) { return false ; } else { <START> int VAR_2 = 0 ; int VAR_3 = 1 ; <END> return TYPE_2 . METHOD_3 ( VAR_1 . METHOD_2 ( ) . get ( VAR_3 ) . METHOD_4 ( ) , VAR_1 . METHOD_2 ( ) . get ( VAR_2 ) . METHOD_4 ( ) ) . isEmpty ( ) ; } } 
public TYPE_2 ( ) { <START> VAR_2 = TYPE_1 . METHOD_1 ( ) ; <END> VAR_3 = VAR_2 . METHOD_2 ( VAR_4 + STRING_1 ) ; VAR_5 = VAR_2 . METHOD_2 ( VAR_4 + STRING_2 ) ; } 
<START> String getKey ( ) { <END> return keySet . get ( VAR_1 . METHOD_1 ( keySet . size ( ) ) ) ; } 
<START> String METHOD_1 ( ) { <END> return TYPE_1 . METHOD_2 ( VAR_1 , true , true ) ; } 
public Entry < TYPE_1 , TYPE_2 > next ( ) { <START> METHOD_1 ( ) ; <END> if ( hasNext ( ) ) { VAR_1 = next ; next = null ; return VAR_1 ; } else { throw new TYPE_3 ( ) ; } } 
private static TYPE_1 METHOD_1 ( String VAR_1 ) { return TYPE_1 . METHOD_2 ( TYPE_1 . TYPE_3 . builder ( ) . METHOD_3 ( false ) . METHOD_4 ( true ) . METHOD_5 ( true ) <START> . METHOD_6 ( STRING_1 ) . METHOD_7 ( STRING_2 ) . METHOD_8 ( STRING_3 ) . METHOD_9 ( STRING_4 ) <END> . build ( ) ) . METHOD_10 ( VAR_1 ) . METHOD_11 ( ) ; } 
public static < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_4 < TYPE_1 , TYPE_2 > > METHOD_1 ( ) { return new TYPE_3 < TYPE_4 < TYPE_1 , TYPE_2 > > ( ) { } ; <START> <END> } 
<START> private void METHOD_1 ( TYPE_1 ... VAR_1 ) { <END> for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_2 != null ) { VAR_2 . close ( ) ; } } } 
public boolean contains ( long VAR_1 ) { int VAR_2 = 0 ; while ( true ) { try { TYPE_1 VAR_3 = VAR_4 . METHOD_1 ( VAR_1 ) ; return VAR_3 . contains ( VAR_1 ) ; } catch ( TYPE_2 e ) { log . warn ( STRING_1 ) ; if ( VAR_2 ++ == VAR_5 ) { throw e ; } } } <START> } <END> 
void METHOD_1 ( ) { for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_2 . execute ( ( ) - > { try { long start = System . VAR_3 ( ) ; TYPE_1 VAR_4 = VAR_5 . METHOD_2 ( ) ; VAR_4 . execute ( ) ; long VAR_6 = System . VAR_3 ( ) - start ; <START> System . out . println ( STRING_1 + VAR_6 ) ; <END> } catch ( Exception e ) { log . error ( STRING_2 , e ) ; } } ) ; } } 
TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( ANNOTATION_1 final String VAR_1 , ANNOTATION_1 final TYPE_4 key ) { <START> return get ( VAR_1 , null , key ) ; <END> } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { <START> return STRING_1 + VAR_1 . METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) . clear ( ) ; VAR_1 . METHOD_6 ( ) . METHOD_7 ( ) . clear ( ) ; METHOD_8 ( ) ; <START> METHOD_9 ( ) ; <END> VAR_2 = VAR_3 ; METHOD_10 ( ) ; log . info ( STRING_1 + VAR_3 + STRING_2 + VAR_4 ) ; } 
private boolean METHOD_1 ( TYPE_1 options ) { if ( VAR_1 . getParameters ( ) . METHOD_2 ( ) && options . VAR_2 ( ) ) { <START> if ( VAR_1 . getParameters ( ) . METHOD_3 ( ) != TYPE_2 . VAR_4 ) { <END> log . warn ( STRING_1 ) ; } } return ! VAR_1 . getParameters ( ) . METHOD_2 ( ) && options . VAR_2 ( ) ; } 
<START> public int METHOD_1 ( long VAR_1 ) { <END> return VAR_2 . values ( ) . stream ( ) . METHOD_2 ( VAR_3 - > VAR_3 . values ( ) . stream ( ) ) . map ( VAR_4 - > VAR_4 . METHOD_3 ( ) ) . METHOD_4 ( 0 , ( a , b ) - > a + b ) ; } 
default Long VAR_1 ( ) { if ( VAR_2 ( ) == null ) { <START> return TYPE_1 . VAR_4 ; <END> } return Optional . VAR_5 ( ( Long ) VAR_2 ( ) . get ( TYPE_2 . VAR_7 ) ) . VAR_8 ( TYPE_1 . VAR_4 ) ; } 
protected List < TYPE_1 > METHOD_1 ( T context , long VAR_1 , TYPE_2 < TYPE_1 , Boolean > VAR_2 ) { final List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; TYPE_1 VAR_4 ; <START> while ( ( VAR_4 = METHOD_2 ( ( ) - > METHOD_3 ( context , VAR_1 ) , VAR_1 ) ) != null ) { <END> VAR_3 . add ( VAR_4 ) ; METHOD_4 ( VAR_4 ) ; if ( VAR_2 . apply ( VAR_4 ) ) { break ; } } return VAR_3 ; } 
public synchronized TYPE_1 METHOD_1 ( ) { final TYPE_2 context = METHOD_2 ( ) ; if ( TYPE_3 . METHOD_3 ( context . VAR_1 ( ) ) ) { return null ; } <START> return read ( context . VAR_1 ( ) ) ; <END> } 
public void METHOD_1 ( ) { while ( VAR_1 . size ( ) < VAR_2 ) { List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; <START> int VAR_4 = VAR_5 . METHOD_2 ( VAR_3 , VAR_6 ) ; <END> TYPE_2 VAR_7 = new TYPE_2 ( METHOD_3 ( VAR_3 ) ) ; VAR_1 . METHOD_4 ( VAR_7 ) ; if ( VAR_4 < VAR_6 ) { break ; } } log . debug ( STRING_1 ) ; METHOD_5 ( ) ; } 
protected List < Object > METHOD_1 ( Object VAR_1 , TYPE_1 key ) { List < Object > VAR_2 = new ArrayList < > ( ) ; <START> VAR_2 . addAll ( VAR_3 . METHOD_2 ( key , ( TYPE_2 ) VAR_1 ) ) ; <END> return VAR_2 ; } 
protected List < Object > METHOD_1 ( Object VAR_1 ) { List < Object > VAR_2 = new ArrayList < > ( ) ; <START> VAR_2 . addAll ( VAR_3 . METHOD_2 ( ) ) ; <END> return VAR_2 ; } 
<START> public List < Object > METHOD_1 ( Object VAR_1 , TYPE_1 key , TYPE_2 value ) { <END> List < Object > VAR_2 = new ArrayList < > ( ) ; VAR_2 . addAll ( VAR_3 . METHOD_2 ( key , ( TYPE_3 ) VAR_1 ) ) ; return VAR_2 ; } 
protected void METHOD_1 ( ) { VAR_1 . clear ( ) ; VAR_2 . clear ( ) ; <START> VAR_3 = true ; <END> } 
static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 , long VAR_3 ) { if ( VAR_2 ) { return VAR_1 . METHOD_2 ( ) . read ( VAR_3 ) ; } else { <START> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_3 , false ) ; <END> } } 
protected TYPE_1 read ( final long VAR_1 , long VAR_2 ) { try { if ( System . currentTimeMillis ( ) - VAR_2 < VAR_3 . getParameters ( ) . METHOD_1 ( ) . METHOD_2 ( ) ) { return VAR_3 . METHOD_3 ( ) . read ( VAR_1 ) ; } return VAR_3 . METHOD_3 ( ) <START> . read ( Collections . VAR_4 ( VAR_1 ) ) <END> . get ( VAR_1 ) ; } catch ( TYPE_2 VAR_5 ) { METHOD_4 ( VAR_5 ) ; throw VAR_5 ; } } 
public TYPE_3 ( TYPE_1 VAR_2 ) { VAR_3 = VAR_2 ; try { <START> VAR_4 = ( TYPE_2 < Integer , Long > ) <END> ( VAR_2 . METHOD_1 ( ) . build ( ) . METHOD_2 ( TYPE_2 . class ) . METHOD_3 ( VAR_5 ) . METHOD_4 ( ) ) ; } catch ( Exception e ) { log . error ( STRING_1 , e ) ; throw e ; } } 
<START> public TYPE_4 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_2 , Map < TYPE_2 , TYPE_3 > VAR_3 ) { <END> VAR_2 . forEach ( index - > { VAR_4 . put ( index . getName ( ) . get ( ) , new HashMap < > ( ) ) ; VAR_5 . add ( index ) ; } ) ; log . info ( STRING_1 , VAR_4 . keySet ( ) . toString ( ) ) ; VAR_6 = VAR_3 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 type ) { if ( type <= VAR_1 ) { if ( VAR_2 . containsKey ( type ) ) { return VAR_2 . get ( type ) ; } } else { <START> if ( VAR_3 . containsKey ( type ) ) { <END> return VAR_3 . get ( type ) ; } } log . error ( STRING_1 + STRING_2 , type . VAR_4 ( ) ) ; throw new TYPE_3 ( type ) ; } 
public TYPE_2 ( ) { this . VAR_2 = TYPE_1 . VAR_4 ; this . VAR_5 = new HashMap ( ) ; <START> this . VAR_6 = new HashMap ( ) ; <END> } 
<START> public Long METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; } 
private void METHOD_1 ( TYPE_1 < TYPE_2 > msg , TYPE_3 ctx , TYPE_4 r ) { try { TYPE_2 req = msg . VAR_1 ( ) ; <START> VAR_2 . METHOD_1 ( new TYPE_5 ( msg . VAR_3 ( ) , req . VAR_4 ( ) . METHOD_2 ( ) ) ) ; <END> r . VAR_5 ( ctx , msg , TYPE_9 . TYPE_11 . msg ( ) ) ; } catch ( TYPE_7 ex ) { r . VAR_5 ( ctx , msg , TYPE_9 . TYPE_10 . msg ( ) ) ; } } 
public synchronized void METHOD_1 ( TYPE_1 < Long > msg , TYPE_2 ctx , TYPE_3 r ) { log . info ( STRING_1 ) ; if ( VAR_1 < msg . VAR_2 ( ) ) { VAR_1 = msg . VAR_2 ( ) ; } <START> cache . VAR_3 ( VAR_1 ) ; <END> r . VAR_4 ( ctx , msg , TYPE_5 . TYPE_6 . msg ( ) ) ; } 
public long METHOD_1 ( ) { if ( VAR_1 . get ( ) == TYPE_1 . VAR_3 ) { <START> long VAR_4 = Optional . VAR_5 ( VAR_6 . get ( VAR_7 ) ) . METHOD_2 ( VAR_8 ) ; <END> VAR_1 . set ( VAR_4 ) ; } return VAR_1 . get ( ) ; } 
public TYPE_4 ( ) { TYPE_1 . VAR_2 = this : : METHOD_1 ; final TYPE_2 VAR_3 = TYPE_2 . METHOD_2 ( 5 ) ; VAR_4 = TYPE_1 . METHOD_3 ( TYPE_3 . builder ( ) . METHOD_4 ( VAR_5 ) <START> . METHOD_5 ( VAR_3 ) <END> . build ( ) ) ; VAR_4 . getParameters ( ) . METHOD_6 ( 0 ) ; } 
public void METHOD_1 ( long VAR_1 ) { <START> TYPE_1 . Context VAR_2 = TYPE_2 . METHOD_2 ( ) ; <END> long VAR_3 = VAR_4 . METHOD_3 ( ) ; try { VAR_5 . METHOD_4 ( e - > e < VAR_1 ) ; VAR_6 . entrySet ( ) . METHOD_4 ( e - > e . getKey ( ) < VAR_1 ) ; VAR_7 . METHOD_1 ( VAR_1 ) ; } finally { VAR_4 . METHOD_5 ( VAR_3 ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_6 ( ) ; } } } 
<START> private void METHOD_1 ( long VAR_1 , TYPE_1 entry , TYPE_2 VAR_2 ) { <END> log . trace ( STRING_1 , VAR_1 , VAR_2 ) ; VAR_3 . METHOD_2 ( VAR_1 , ( TYPE_3 ) entry ) ; } 
private long METHOD_1 ( ) { final TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( TYPE_2 . VAR_4 ) ; <START> return VAR_1 == null ? <END> 0 : VAR_1 . METHOD_3 ( ) ; } 
<START> public synchronized void METHOD_1 ( long VAR_1 ) { <END> VAR_2 . METHOD_2 ( VAR_1 ) ; log . info ( STRING_1 , VAR_1 ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return ImmutableList . VAR_1 ( VAR_2 ) ; <END> } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> if ( ! VAR_1 . METHOD_3 ( ) . contains ( METHOD_4 ( ) ) ) { <END> return false ; } return true ; } 
public TYPE_2 ( ) { this ( TYPE_1 . empty ( ) ) ; <START> log . warn ( STRING_1 <END> + STRING_2 ) ; } 
private void METHOD_1 ( ) { for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_2 . execute ( ( ) - > { <START> while ( ! VAR_3 && ! VAR_4 . isEmpty ( ) ) { <END> try { TYPE_1 VAR_5 = VAR_4 . METHOD_2 ( ) ; VAR_5 . execute ( ) ; } catch ( Exception e ) { log . error ( STRING_1 , e ) ; } } } ) ; } } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; try { VAR_1 . METHOD_3 ( TYPE_3 . TYPE_4 . METHOD_4 ( ) , TimeUnit . VAR_2 ) ; } catch ( InterruptedException VAR_3 ) { log . debug ( STRING_1 , VAR_3 ) ; Thread . VAR_4 ( ) . METHOD_5 ( ) ; } <START> VAR_5 . METHOD_6 ( TYPE_2 : : METHOD_1 ) ; <END> log . info ( STRING_2 ) ; } 
private void METHOD_1 ( ) { <START> METHOD_2 ( ( ) - > { <END> TYPE_1 VAR_1 = VAR_2 . METHOD_3 ( ) ; if ( VAR_1 == null ) { return ; } VAR_3 = new TYPE_2 ( TYPE_3 . METHOD_4 ( METHOD_5 ( ) ) , METHOD_6 ( VAR_1 ) ) ; } ) ; } 
protected TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_4 VAR_2 = VAR_1 . METHOD_2 ( VAR_3 ) ; <START> log . debug ( STRING_1 , <END> VAR_3 , VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) , VAR_1 . METHOD_3 ( ) . METHOD_5 ( ) ) ; return VAR_2 . METHOD_6 ( ) ; } 
public boolean hasNext ( ) { if ( VAR_1 < VAR_2 ) { return true ; <START> } else { <END> return false ; } } 
public synchronized < T > void put ( Class < T > VAR_1 , String VAR_2 , String key , T value ) { <START> String VAR_3 = TYPE_2 . parser . METHOD_1 ( value , VAR_1 ) ; <END> T VAR_5 = TYPE_2 . parser . METHOD_2 ( VAR_3 , VAR_1 ) ; TYPE_1 VAR_6 = new TYPE_1 ( getKey ( VAR_2 , key ) , VAR_1 ) ; cache . put ( VAR_6 , VAR_5 ) ; } 
public TYPE_8 ( TYPE_1 request ) { this . id = TYPE_2 . METHOD_1 ( ) ; this . request = ( TYPE_3 ) request ; <START> VAR_2 = Arrays . asList ( new TYPE_4 ( ) , <END> new TYPE_5 ( ) , new TYPE_6 ( ) , new TYPE_7 ( ) ) ; } 
void METHOD_1 ( TYPE_1 < TYPE_2 > msg , TYPE_3 ctx , TYPE_4 r ) { TYPE_5 req = ( TYPE_5 ) msg . VAR_1 ( ) . METHOD_2 ( ) ; Response VAR_2 ; if ( VAR_3 . contains ( req . getId ( ) ) ) { VAR_2 = new TYPE_6 ( true ) ; <START> } else { <END> VAR_2 = new TYPE_6 ( false ) ; } r . VAR_4 ( ctx , msg , TYPE_9 . TYPE_10 . METHOD_3 ( new TYPE_8 ( VAR_2 ) ) ) ; } 
public TYPE_1 METHOD_1 ( ) { while ( true ) { try { return VAR_1 . VAR_2 . get ( ) ; <START> } catch ( TYPE_2 VAR_3 ) { <END> throw VAR_3 ; } catch ( Exception ex ) { log . warn ( STRING_1 , VAR_1 . VAR_4 , ex ) ; VAR_1 . METHOD_2 ( ) ; try { Thread . VAR_5 ( VAR_1 . VAR_4 * INT_1 ) ; } catch ( InterruptedException VAR_6 ) { throw new TYPE_3 ( STRING_2 , VAR_6 ) ; } } } } 
public Collection < Object > METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , TYPE_2 index ) { return VAR_1 . METHOD_2 ( ) . METHOD_3 ( index , VAR_2 <START> . METHOD_4 ( VAR_1 , TYPE_3 . of ( ) ) . get ( index ) ) ; <END> } 
public TYPE_1 put ( ANNOTATION_1 TYPE_2 key , TYPE_1 value ) { TYPE_1 VAR_1 = VAR_2 . put ( key , value ) ; <START> if ( VAR_3 . isEmpty ( ) ) { <END> METHOD_1 ( key , VAR_1 ) ; METHOD_2 ( key , value ) ; } return VAR_1 ; } 
public TYPE_1 ( ) { <START> VAR_2 = - 1 ; <END> } 
public TYPE_1 ( ) { <START> super ( STRING_1 ) ; <END> } 
<START> public synchronized long METHOD_1 ( ) { <END> Long VAR_1 = VAR_2 . get ( Long . VAR_3 , VAR_4 , VAR_5 ) ; return VAR_1 == null ? 0 : VAR_1 ; } 
private synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) return ; if ( VAR_2 == null || VAR_1 . METHOD_2 ( ) > VAR_2 . METHOD_2 ( ) || <START> ! VAR_1 . METHOD_3 ( ) . equals ( VAR_2 . METHOD_3 ( ) ) ) { <END> VAR_2 = VAR_1 ; METHOD_4 ( VAR_2 ) ; } } 
public < R > R METHOD_1 ( TYPE_1 < R , T > VAR_1 , Object [ ] VAR_2 ) { R value ; <START> boolean VAR_3 = TYPE_2 . METHOD_2 ( ) ; <END> TYPE_3 . Context context = TYPE_2 . METHOD_3 ( VAR_3 , VAR_4 ) ; try { value = METHOD_4 ( VAR_1 , VAR_2 , VAR_3 ) ; } finally { TYPE_2 . METHOD_5 ( VAR_3 , context ) ; } return value ; } 
public TYPE_1 < Boolean > METHOD_1 ( long VAR_1 , Map < TYPE_2 , Long > VAR_2 , Object object ) { TYPE_3 . Context context = METHOD_2 ( STRING_1 ) ; TYPE_4 VAR_3 = TYPE_7 . TYPE_8 . buffer ( ) ; TYPE_9 . TYPE_10 . METHOD_3 ( object , VAR_3 ) ; TYPE_1 < Boolean > VAR_4 = METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; <START> return context == null ? VAR_4 : VAR_4 . METHOD_4 ( x - > { context . VAR_5 ( ) ; return x ; } ) ; <END> } 
<START> public synchronized void METHOD_1 ( TYPE_1 msg , TYPE_2 ctx , TYPE_3 r ) { <END> TYPE_4 VAR_1 = TYPE_4 . METHOD_2 ( ) ; r . VAR_2 ( ctx , msg , new TYPE_5 < > ( TYPE_6 . VAR_4 , VAR_1 . METHOD_3 ( ) ) ) ; } 
public synchronized long METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( ) ; <END> if ( VAR_1 != null && VAR_1 != this ) { return VAR_1 . METHOD_3 ( ) ; } else { long VAR_2 = builder . VAR_3 . METHOD_4 ( ) . METHOD_5 ( Collections . VAR_4 ( ) , 0 ) . METHOD_6 ( ) ; log . trace ( STRING_1 , VAR_5 , VAR_2 ) ; return VAR_2 ; } } 
public void METHOD_1 ( ) { VAR_1 = true ; VAR_2 . METHOD_2 ( ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_1 ( ) ; } try { <START> VAR_2 . METHOD_3 ( 5 , TimeUnit . VAR_4 ) ; <END> } catch ( InterruptedException VAR_5 ) { log . debug ( STRING_1 , VAR_5 ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> if ( ! VAR_1 . isEmpty ( ) ) { <END> return METHOD_2 ( VAR_1 ) ; } return null ; } 
public String toString ( ) { <START> return element . VAR_1 ( ) . toString ( ) + STRING_1 ; <END> } 
public Set < Type > METHOD_1 ( ) { Set < Type > VAR_1 = new HashSet < Type > ( ) ; for ( TYPE_1 VAR_2 : VAR_3 ) { <START> VAR_1 . add ( VAR_2 . getType ( ) ) ; <END> } for ( TYPE_2 VAR_4 : VAR_5 ) { VAR_1 . add ( VAR_4 . getType ( ) ) ; } return VAR_1 ; } 
TYPE_4 ( T element ) { this . element = element ; <START> if ( element . VAR_2 ( ) . METHOD_1 ( ) == TYPE_3 . VAR_4 ) { <END> TYPE_1 VAR_5 = element . VAR_2 ( ) ; boolean VAR_6 = VAR_5 . METHOD_2 ( ) . METHOD_1 ( ) == TYPE_3 . VAR_4 && TYPE_2 . METHOD_3 ( VAR_5 . METHOD_2 ( ) ) != null ; this . VAR_7 = VAR_6 ? VAR_5 . METHOD_4 ( ) : null ; } else { this . VAR_7 = null ; } } 
<START> public boolean METHOD_1 ( ) { <END> return VAR_1 != null && VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) && VAR_1 . METHOD_4 ( ) . contains ( TYPE_1 . VAR_3 ) ; } 
<START> public boolean METHOD_1 ( ) { <END> return ( VAR_1 != null && VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) || VAR_2 . METHOD_5 ( ) . contains ( TYPE_1 . VAR_4 ) ; } 
<START> public TYPE_1 ( String name , Type type , boolean VAR_2 , boolean VAR_3 , boolean VAR_4 ) { <END> this . name = STRING_1 . equals ( name ) ? STRING_2 : name ; this . VAR_5 = name ; this . type = type ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
private String getName ( Type VAR_1 , Type VAR_2 ) { String VAR_3 = getName ( VAR_1 ) ; String VAR_4 = getName ( VAR_2 ) ; String VAR_5 = VAR_6 != null ? <START> STRING_1 + METHOD_1 ( VAR_6 ) : "" ; <END> return TYPE_1 . METHOD_2 ( VAR_3 + STRING_2 + VAR_4 + VAR_5 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) == TYPE_3 . VAR_3 && VAR_1 instanceof TYPE_2 ; <END> } 
public static void METHOD_1 ( ) { Integer VAR_1 = TYPE_1 . get ( ) ; METHOD_2 ( VAR_1 , STRING_1 , null , null ) ; if ( VAR_1 . METHOD_3 ( ) == 1 ) { TYPE_2 . set ( null ) ; TYPE_1 . set ( null ) ; } else { <START> TYPE_1 . set ( VAR_1 . METHOD_3 ( ) - 1 ) ; <END> } } 
public Set < Type > METHOD_1 ( ) { <START> Set < Type > VAR_1 = new HashSet < Type > ( METHOD_2 ( ) . METHOD_1 ( ) . size ( ) + 1 ) ; <END> VAR_1 . addAll ( METHOD_2 ( ) . METHOD_1 ( ) ) ; VAR_1 . add ( VAR_2 ) ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 method ) { TYPE_4 VAR_2 = ( TYPE_4 ) METHOD_2 ( VAR_3 , VAR_1 ) . METHOD_3 ( ) ; <START> TYPE_5 VAR_4 = TYPE_6 . METHOD_4 ( VAR_2 , method , VAR_5 , VAR_3 ) ; <END> TYPE_1 VAR_6 = VAR_4 . METHOD_5 ( new TYPE_7 ( ) , null ) ; return VAR_6 ; } 
protected List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) { return Arrays . asList ( METHOD_3 ( ) , METHOD_4 ( ) ) ; } else { <START> return Collections . VAR_2 ( METHOD_5 ( VAR_1 ) ) ; <END> } } 
public void METHOD_1 ( ) { <START> for ( TYPE_1 node : VAR_1 . values ( ) ) { <END> METHOD_2 ( node ) ; } } 
private List < String > METHOD_1 ( TYPE_1 start ) { List < String > VAR_1 = new ArrayList < String > ( ) ; boolean VAR_2 = false ; for ( TYPE_1 n : VAR_3 ) { <START> if ( n . getName ( ) . equals ( start . getName ( ) ) ) { <END> VAR_2 = true ; } if ( VAR_2 ) { VAR_1 . add ( n . getName ( ) ) ; } } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( TYPE_1 . class ) ; <END> } 
public boolean execute ( TYPE_1 VAR_1 ) { try { for ( TYPE_2 c : VAR_1 . values ( ) ) { if ( c . VAR_2 ( ) ) { <START> c . VAR_3 ( VAR_4 ) ; <END> } } } catch ( Exception e ) { TYPE_3 . METHOD_1 ( ) . log ( Level . VAR_5 , STRING_1 , e ) ; } return true ; } 
<START> public synchronized TYPE_1 get ( ) { <END> TYPE_1 VAR_1 = VAR_2 . get ( Thread . VAR_3 ( ) ) ; if ( VAR_1 == null ) { VAR_1 = ( TYPE_1 ) VAR_4 . METHOD_1 ( ) ; VAR_2 . put ( Thread . VAR_3 ( ) , VAR_1 ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws TYPE_1 { String id = STRING_1 ; TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( id , TYPE_3 . VAR_3 ) ; assertEquals ( STRING_1 , VAR_1 . getId ( ) ) ; assertEquals ( STRING_2 , VAR_1 . getName ( ) ) ; <START> assertEquals ( STRING_3 , VAR_1 . METHOD_3 ( ) ) ; <END> assertEquals ( STRING_4 , VAR_1 . METHOD_4 ( ) ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { TYPE_2 < TYPE_3 < ? > , TYPE_1 > VAR_1 = TYPE_3 . METHOD_2 ( ) ; return VAR_1 . stream ( ) . filter ( VAR_2 - > VAR_2 . METHOD_3 ( TYPE_4 . class ) ) <START> . collect ( Collectors . VAR_3 ( ) ) ; <END> } 
public boolean filter ( ANNOTATION_1 Object context , ANNOTATION_2 TYPE_1 VAR_1 ) { <START> return ! ( VAR_1 instanceof TYPE_4 . TYPE_3 ) ; <END> } 
private static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final String VAR_2 ) throws TYPE_3 , TYPE_4 , IOException , InterruptedException { final TYPE_5 VAR_3 = VAR_1 . METHOD_2 ( ) ; final TYPE_6 VAR_4 = VAR_3 . METHOD_3 ( VAR_2 , TYPE_7 . METHOD_4 ( ) ) ; <START> TYPE_8 . get ( ) . METHOD_5 ( VAR_4 ) ; <END> return VAR_4 ; } 
public Map < String , Object > METHOD_1 ( ) { <START> return Collections . VAR_1 ( this . data ) ; <END> } 
public String toString ( ) { <START> return STRING_1 + this . name + STRING_2 + from + STRING_3 + to ; <END> } 
public void METHOD_1 ( String VAR_1 , Object VAR_2 ) { if ( this . data == null ) { <START> this . data = new HashMap < String , Object > ( ) ; <END> } this . data . put ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( String VAR_1 , Object VAR_2 ) { if ( this . VAR_3 == null ) { <START> this . VAR_3 = new HashMap < String , Object > ( ) ; <END> } this . VAR_3 . put ( VAR_1 , VAR_2 ) ; } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 , int count ) throws InterruptedException { List < TYPE_1 > VAR_3 = new ArrayList < TYPE_1 > ( ) ; for ( int i = 0 ; i < count ; i ++ ) { <START> TimeUnit . VAR_4 . METHOD_2 ( INT_1 ) ; <END> TYPE_1 VAR_5 = VAR_1 . METHOD_1 ( VAR_2 ) ; if ( VAR_5 != null ) { VAR_3 . add ( VAR_5 ) ; } } return VAR_3 ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { METHOD_2 ( VAR_1 ) ; VAR_1 . METHOD_1 ( ) ; VAR_1 = null ; } <START> if ( VAR_2 != null ) { VAR_2 . METHOD_1 ( ) ; VAR_2 = null ; } <END> } 
private int METHOD_1 ( Map < String , Object > params , TYPE_1 query ) { METHOD_2 ( params , query ) ; query . getParameters ( ) . stream ( ) . filter ( e - > params . containsKey ( e . getName ( ) ) ) <START> . forEach ( p - > query . VAR_1 ( p . getName ( ) , params . get ( p . getName ( ) ) ) ) ; <END> return query . VAR_2 ( ) ; } 
public void METHOD_1 ( ) { System . VAR_1 ( STRING_1 , STRING_2 ) ; <START> logger . info ( STRING_3 , ( VAR_2 ? STRING_4 : STRING_2 ) ) ; <END> } 
<START> static void METHOD_1 ( ) { <END> File VAR_1 = new File ( System . getProperty ( STRING_1 ) ) ; if ( VAR_1 . exists ( ) ) { String [ ] VAR_2 = VAR_1 . list ( new TYPE_1 ( ) { @Override public boolean METHOD_2 ( File VAR_3 , String name ) { return name . VAR_4 ( STRING_2 ) ; } } ) ; for ( String file : VAR_2 ) { new File ( VAR_1 , file ) . METHOD_3 ( ) ; } } } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { for ( TYPE_1 VAR_2 : VAR_1 ) { try { VAR_3 . METHOD_3 ( VAR_2 ) ; } catch ( Exception e ) { logger . error ( STRING_1 + e . VAR_4 ( ) ) ; <START> logger . error ( STRING_2 + VAR_2 . METHOD_4 ( ) ) ; <END> } } VAR_1 . clear ( ) ; } close ( ) ; } 
public Object METHOD_1 ( String name ) { Object result = this . data . get ( name ) ; <START> if ( result == null && name != null && name . equalsIgnoreCase ( STRING_1 ) ) { <END> result = METHOD_2 ( ) ; } return result ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , Object data ) throws TYPE_1 { <START> VAR_4 . METHOD_2 ( VAR_1 ) ; <END> TYPE_2 VAR_5 = METHOD_3 ( VAR_1 ) ; METHOD_1 ( VAR_5 . getId ( ) , VAR_2 , VAR_3 , data ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { try { VAR_2 . METHOD_2 ( VAR_1 . getId ( ) , null ) ; } catch ( Throwable VAR_3 ) { METHOD_3 ( VAR_3 ) ; <START> VAR_2 . METHOD_4 ( VAR_1 . getId ( ) ) ; <END> } } 
public static List < String > METHOD_1 ( TYPE_1 VAR_1 ) { <START> List < String > VAR_2 = VAR_1 != null ? VAR_1 . METHOD_2 ( ) : new ArrayList < > ( ) ; <END> if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { VAR_2 = new ArrayList < > ( ) ; VAR_2 . add ( "" ) ; } return VAR_2 ; } 
public Object METHOD_1 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
<START> public Collection < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <END> Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( STRING_1 , VAR_2 ) ; METHOD_2 ( params , VAR_1 ) ; METHOD_3 ( params ) ; List < TYPE_1 > VAR_3 = VAR_4 . execute ( new TYPE_3 < List < TYPE_1 > > ( STRING_2 , params ) ) ; return VAR_3 ; } 
public static TYPE_1 get ( ) { if ( VAR_1 == null ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( int status ) { try { VAR_1 . METHOD_2 ( VAR_2 ) ; } catch ( Throwable e ) { <START> logger . warn ( STRING_1 , e ) ; <END> } } 
private static void METHOD_1 ( TYPE_1 channel ) { TYPE_2 . METHOD_2 ( 1 , 10 ) . forEach ( i - > { channel . VAR_1 ( TYPE_3 . METHOD_3 ( METHOD_4 ( ) ) . build ( ) ) ; <START> } ) ; <END> } 
public String METHOD_1 ( String VAR_1 ) { <START> Map < String , String > VAR_2 = new HashMap < > ( ) ; <END> TYPE_1 version = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( version . containsKey ( STRING_1 ) ) { return version . getString ( STRING_1 ) ; } return null ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { this . VAR_2 = VAR_1 . VAR_2 ; this . VAR_3 = VAR_1 . METHOD_2 ( ) ; <END> this . VAR_1 = VAR_1 ; return this ; } 
<START> public void METHOD_1 ( ) { <END> TYPE_1 message = new TYPE_1 ( new TYPE_2 ( ) , STRING_1 , STRING_2 , STRING_3 , new TYPE_3 ( ) , new TYPE_4 ( ) , STRING_4 , STRING_5 , INT_1 , STRING_6 , new TYPE_5 ( STRING_7 , INT_2 ) ) ; assertEquals ( message . VAR_1 ( ) , INT_2 ) ; } 
public void METHOD_1 ( ) { <START> LOG . debug ( STRING_1 ) ; <END> VAR_1 . METHOD_1 ( ) ; try { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; } catch ( IllegalStateException e ) { LOG . debug ( STRING_2 , e ) ; } LOG . debug ( STRING_3 ) ; } 
private TYPE_1 METHOD_1 ( ) throws TYPE_2 { return TYPE_3 . METHOD_2 ( ) . METHOD_3 ( TYPE_4 . METHOD_4 ( ) ) . METHOD_5 ( true ) <START> . build ( ) ; <END> } 
public void METHOD_1 ( int VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> VAR_3 = VAR_4 + VAR_1 ; } 
public void METHOD_1 ( ) { if ( VAR_1 == null ) { throw new IllegalStateException ( STRING_1 ) ; } VAR_1 . METHOD_2 ( ) ; <START> TYPE_1 . METHOD_3 ( ) ; <END> } 
protected static TYPE_1 METHOD_1 ( String name , TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_1 VAR_2 = METHOD_2 ( TYPE_1 . class ) ; when ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( name ) ; when ( VAR_2 . METHOD_5 ( ) ) . METHOD_4 ( VAR_1 ) ; <START> when ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( STRING_1 ) ; <END> when ( VAR_2 . METHOD_6 ( ) ) . METHOD_4 ( true ) ; when ( VAR_2 . METHOD_7 ( STRING_2 ) ) . METHOD_4 ( true ) ; return VAR_2 ; } 
public String METHOD_1 ( Set < String > VAR_1 ) { String VAR_2 = METHOD_2 ( ) ; if ( METHOD_3 ( ) == null ) { if ( ! VAR_2 . contains ( STRING_1 ) ) { VAR_2 = METHOD_4 ( VAR_1 , VAR_2 ) ; } else { VAR_2 = VAR_1 . contains ( VAR_2 ) ? VAR_2 : null ; } } <START> return VAR_2 ; <END> } 
<START> private boolean METHOD_1 ( File file ) { <END> if ( file . VAR_1 ( ) . contains ( STRING_1 ) ) { String VAR_2 = file . getName ( ) ; return VAR_2 . METHOD_2 ( STRING_1 ) ; } return false ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 config ) { <START> synchronized ( this ) { <END> VAR_2 . add ( config . getName ( ) ) ; } } 
public TYPE_2 ( final TYPE_1 VAR_2 , final String VAR_3 , final String VAR_4 , final String VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> this . VAR_6 = VAR_3 ; <END> } 
public int METHOD_1 ( ) { <START> TYPE_1 builder = new TYPE_1 ( VAR_1 , VAR_2 ) ; <END> builder . append ( path ) ; builder . append ( type ) ; return builder . VAR_3 ( ) ; } 
public static String METHOD_1 ( String string ) { <START> String content = string ; <END> if ( content . length ( ) > 0 ) { return content ; } return null ; } 
public TYPE_1 add ( ANNOTATION_1 ANNOTATION_2 TYPE_2 VAR_1 , TYPE_3 result ) throws org . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_5 , InterruptedException { METHOD_1 ( ) ; METHOD_2 ( VAR_1 , result ) ; if ( result . VAR_7 ( ) || result . VAR_8 ( ) ) { return new TYPE_1 ( TYPE_6 . VAR_10 , result . VAR_11 ( ) ) ; } <START> TYPE_4 VAR_12 = TYPE_4 . METHOD_3 ( VAR_1 ) ; <END> return METHOD_4 ( result , VAR_12 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( INT_1 ) ) ; Set < TYPE_2 < TYPE_1 > > VAR_2 = VAR_3 . METHOD_5 ( VAR_1 ) ; <START> Assert . assertEquals ( VAR_2 . size ( ) , 1 ) ; <END> } 
public TYPE_3 ( TYPE_1 group ) { this . id = group . getId ( ) ; this . name = group . getName ( ) ; <START> this . VAR_2 = TYPE_2 . METHOD_1 ( group . VAR_3 ( ) , TYPE_2 . VAR_4 , VAR_5 ) ; <END> } 
public TYPE_3 ( TYPE_1 group ) { this . id = group . getId ( ) ; this . name = group . getName ( ) ; <START> this . VAR_2 = TYPE_2 . METHOD_1 ( group . VAR_3 ( ) ) ; <END> } 
<START> TYPE_2 ( TYPE_1 user ) { <END> this . VAR_2 = user . VAR_3 ( ) ; this . VAR_4 = user . VAR_5 ( ) ; this . id = user . getId ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 ; TYPE_3 context = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; Object VAR_3 = METHOD_4 ( VAR_1 . METHOD_2 ( ) ) ; if ( VAR_3 != null ) { try { <START> VAR_2 = METHOD_5 ( context , TYPE_2 . class , STRING_1 ) ; <END> VAR_2 . METHOD_6 ( VAR_3 ) ; } catch ( Exception ex ) { logger . warn ( STRING_2 + ex . getMessage ( ) ) ; } } } 
public void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; <START> METHOD_3 ( VAR_2 ) ; <END> } 
private boolean METHOD_1 ( List < TYPE_1 > VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , boolean VAR_4 ) { Object VAR_5 = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_5 instanceof TYPE_4 ) { <END> List < Long > VAR_6 = ( ( TYPE_4 ) VAR_5 ) . METHOD_3 ( ) ; for ( TYPE_1 VAR_7 : VAR_1 ) { if ( VAR_6 . contains ( VAR_7 . METHOD_4 ( ) ) ) { if ( METHOD_1 ( VAR_7 , VAR_3 , VAR_4 ) ) { return true ; } } } } return false ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 = TYPE_1 . METHOD_2 ( VAR_2 ) . build ( ) ; <START> METHOD_3 ( VAR_3 , VAR_3 , null ) . METHOD_4 ( model ( ) <END> . METHOD_5 ( STRING_1 ) ) . METHOD_4 ( view ( ) . name ( STRING_2 ) ) . METHOD_4 ( status ( ) . METHOD_6 ( ) ) ; METHOD_7 ( VAR_4 ) . METHOD_8 ( METHOD_9 ( ) ) ; } 
public void METHOD_1 ( ) { long VAR_1 = VAR_2 . METHOD_2 ( ) . getId ( ) ; <START> VAR_2 . METHOD_3 ( VAR_1 ) ; <END> VAR_3 . METHOD_4 ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> when ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( user ) ; <END> METHOD_5 ( VAR_1 ) ; TYPE_3 VAR_3 = METHOD_6 ( ) ; TYPE_3 VAR_4 = VAR_5 . METHOD_6 ( VAR_3 , VAR_6 ) ; TYPE_4 VAR_7 = VAR_4 . METHOD_7 ( ) ; METHOD_8 ( VAR_1 , VAR_4 , VAR_7 ) ; METHOD_9 ( VAR_4 ) ; } 
public void METHOD_1 ( ) <START> throws TYPE_1 , TYPE_2 { <END> TYPE_3 VAR_1 = new TYPE_4 ( ) ; TYPE_5 VAR_2 = new TYPE_6 ( ) ; TYPE_7 VAR_3 = new TYPE_7 ( STRING_1 , STRING_2 , true , STRING_3 ) ; when ( VAR_4 . METHOD_2 ( VAR_3 , VAR_1 , VAR_2 ) ) . METHOD_3 ( TYPE_8 . VAR_5 ) ; TYPE_8 result = VAR_6 . METHOD_4 ( VAR_3 , VAR_1 , VAR_2 ) ; assertEquals ( result , TYPE_8 . VAR_5 , STRING_4 ) ; } 
public boolean METHOD_1 ( ) { for ( TYPE_1 VAR_1 : METHOD_2 ( ) ) { <START> if ( VAR_1 . METHOD_3 ( ) . getId ( ) != VAR_2 . getId ( ) ) { <END> return false ; } } return true ; } 
public TYPE_1 METHOD_1 ( ) { <START> return Optional . VAR_1 ( VAR_2 ) . METHOD_2 ( VAR_3 ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 instanceof TYPE_2 && <END> ( VAR_2 == null || VAR_2 . size ( ) == 0 || VAR_2 . contains ( VAR_1 . getType ( ) ) ) ) { return true ; } return false ; } 
private TYPE_6 ( int VAR_2 , TYPE_1 VAR_3 , TYPE_2 in ) throws IOException { super ( new TYPE_3 ( in , TYPE_5 . VAR_5 ) ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> System . VAR_6 ( new TYPE_4 ( System . out , true , STRING_1 ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { <START> if ( VAR_1 != null ) { <END> in = new TYPE_1 ( new TYPE_2 ( VAR_1 . METHOD_2 ( ) , VAR_2 ) ) ; } } 
public void METHOD_1 ( double i ) { List < T > VAR_1 = new ArrayList < > ( ) ; for ( Entry < T , Double > entry : map . entrySet ( ) ) { <START> final T VAR_2 = entry . getKey ( ) ; <END> Double VAR_3 = entry . getValue ( ) ; if ( VAR_3 == null ) VAR_3 = FLOAT_1 ; if ( VAR_3 < i ) VAR_1 . add ( VAR_2 ) ; } for ( T VAR_2 : VAR_1 ) { map . remove ( VAR_2 ) ; } } 
public void METHOD_1 ( ) throws IOException { <START> TYPE_1 VAR_1 = getClass ( ) . METHOD_2 ( <END> STRING_1 ) ; Map < String , TYPE_2 < ? > > VAR_2 = TYPE_3 . METHOD_3 ( VAR_1 ) ; Assert . assertTrue ( VAR_2 . get ( STRING_2 ) instanceof TYPE_4 ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 ) { <START> VAR_3 = TYPE_2 . METHOD_1 ( TYPE_1 . VAR_4 ) ; <END> } 
public TYPE_2 ( ) { <START> VAR_2 = new ArrayList < TYPE_1 > ( ) ; <END> } 
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( obj instanceof TYPE_1 ) { TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return Arrays . equals ( params , VAR_1 . params ) && VAR_2 == VAR_1 . VAR_2 && VAR_3 == VAR_1 . VAR_3 && VAR_4 == VAR_1 . VAR_4 && VAR_5 == VAR_1 . VAR_5 ; } else { return false ; <START> } <END> } 
private TYPE_1 [ ] METHOD_1 ( TYPE_1 [ ] VAR_1 ) { for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { TYPE_1 n = VAR_1 [ i ] ; if ( TYPE_2 . METHOD_2 ( n . getType ( ) ) ) { VAR_1 [ i ] = new TYPE_1 ( n . VAR_2 ( ) , n . VAR_3 ( ) , this . VAR_4 , n . VAR_5 ( ) ) ; } } return VAR_1 ; <START> } <END> 
public final TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 ) throws IOException { if ( ! METHOD_2 ( ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } TYPE_4 VAR_2 = new TYPE_4 ( VAR_1 ) ; TYPE_5 VAR_3 = METHOD_3 ( VAR_2 ) ; <START> TYPE_1 model = METHOD_4 ( VAR_3 ) ; <END> parameters . VAR_4 ( STRING_2 , VAR_2 . METHOD_5 ( ) . toString ( INT_1 ) ) ; parameters . VAR_4 ( TYPE_7 . VAR_6 , TYPE_6 . VAR_8 ) ; return model ; } 
public int METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) { int VAR_3 = this . VAR_4 ++ ; if ( VAR_4 < VAR_5 ) VAR_4 = VAR_5 ; VAR_6 . put ( Integer . valueOf ( VAR_3 ) , new TYPE_2 ( VAR_1 , VAR_2 . METHOD_2 ( ) ) ) ; <START> TYPE_3 . log ( TYPE_4 . VAR_8 , null , STRING_1 + VAR_3 ) ; <END> return VAR_3 ; } 
<START> public void METHOD_1 ( ) <END> { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; assertNotNull ( VAR_1 ) ; assertEquals ( 2 , VAR_1 . size ( ) ) ; assertEquals ( 2 , VAR_1 . iterator ( ) . next ( ) . METHOD_3 ( ) . size ( ) ) ; assertEquals ( 2 , VAR_1 . iterator ( ) . next ( ) . METHOD_3 ( ) . size ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_1 VAR_2 = Optional . of ( VAR_1 ) . map ( a - > a . VAR_3 ( ) ) . METHOD_2 ( VAR_1 ) ; <END> VAR_4 . remove ( VAR_2 ) ; VAR_4 . add ( VAR_2 ) ; } 
public Collection < String > METHOD_1 ( ) { <START> return Collections . VAR_1 ( TYPE_1 . METHOD_2 ( STRING_1 ) ) ; <END> } 
public void METHOD_1 ( ANNOTATION_1 ( VAR_1 = VAR_2 , VAR_3 = TYPE_1 . class ) TYPE_2 VAR_4 , ANNOTATION_2 ( VAR_1 = VAR_2 , id = STRING_1 , VAR_5 = STRING_2 ) <START> Path path ) <END> throws Exception { METHOD_2 ( VAR_4 , path ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 != null && VAR_1 . getName ( ) != null && VAR_1 . METHOD_2 ( ) != null && VAR_1 . METHOD_3 ( ) != null && VAR_1 . METHOD_4 ( ) != null && VAR_1 . getType ( ) != null && VAR_1 . getId ( ) != null ; <END> } 
public void METHOD_1 ( String VAR_1 , int max ) { if ( max > 0 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; VAR_3 . METHOD_3 ( VAR_2 , max ) ; } else { <START> LOGGER . warn ( STRING_1 , max ) ; <END> } } 
protected void METHOD_1 ( Thread t , TYPE_1 r ) { try { TYPE_2 VAR_1 = METHOD_2 ( r ) ; Optional . VAR_2 ( VAR_1 ) . METHOD_3 ( this : : METHOD_4 ) ; } catch ( Exception e ) { <START> LOGGER . error ( STRING_1 , r , e ) ; <END> } } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { return TYPE_2 . of ( values ( ) ) <START> . filter ( e - > e . VAR_1 . equalsIgnoreCase ( VAR_1 ) ) <END> . METHOD_2 ( ) . METHOD_3 ( null ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( STRING_1 ) <END> . METHOD_3 ( TYPE_5 . VAR_3 ) . when ( ) . get ( STRING_2 ) . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( TYPE_3 . TYPE_4 . value ( ) ) . METHOD_2 ( STRING_1 ) . METHOD_7 ( STRING_3 , TYPE_2 . METHOD_8 ( STRING_4 ) ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 , TYPE_2 response ) { String VAR_3 = String . format ( STRING_1 , VAR_1 . METHOD_2 ( ) , VAR_2 - INT_1 , VAR_2 ) ; response . VAR_4 ( TYPE_4 . VAR_6 , VAR_3 ) ; <START> response . VAR_4 ( TYPE_4 . VAR_7 , STRING_2 ) ; <END> response . VAR_8 ( TYPE_3 . value ( ) ) ; } 
private static void METHOD_1 ( TYPE_1 response ) { response . VAR_1 ( STRING_1 + VAR_2 ) ; <START> response . VAR_3 ( TYPE_3 . VAR_5 , STRING_2 ) ; <END> response . VAR_6 ( TYPE_2 . value ( ) ) ; } 
public Set < TYPE_1 > METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 : new TYPE_2 < > ( ) ; <END> } 
private void METHOD_1 ( Map . Entry < TYPE_1 , Path > e ) { try ( TYPE_2 is = TYPE_3 . METHOD_2 ( e . getValue ( ) ) ) { VAR_1 . METHOD_1 ( e . getKey ( ) , is ) ; } catch ( IOException VAR_2 ) { throw new TYPE_4 ( VAR_2 ) ; } <START> TYPE_5 . METHOD_3 ( TYPE_3 : : METHOD_4 ) . METHOD_5 ( e . getValue ( ) ) ; <END> } 
private Object METHOD_1 ( ) { TYPE_1 configuration ; try { configuration = VAR_1 . read ( ) ; METHOD_2 ( configuration ) ; METHOD_3 ( ) ; } catch ( IOException e ) { <START> throw new org . VAR_2 . VAR_3 . VAR_4 . TYPE_2 ( e ) ; <END> } return null ; } 
<START> private Path METHOD_1 ( String id , <END> String version ) throws IOException { try { return METHOD_2 ( id , version ) ; } catch ( TYPE_1 | TYPE_2 | TYPE_3 e ) { throw new IOException ( e ) ; } } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( VAR_1 ) ; <START> return VAR_2 != null ? new TYPE_1 ( VAR_2 ) : null ; <END> } 
public Path METHOD_1 ( TYPE_1 uri , int size ) throws IOException { <START> TYPE_2 VAR_1 = TYPE_2 . parse ( TYPE_3 . getName ( uri . getPath ( ) ) ) ; <END> return METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { String query = STRING_1 ; TYPE_1 VAR_1 = new TYPE_1 ( query ) ; Map < Pair < Integer , Integer > , String > VAR_2 = null ; try { VAR_1 . METHOD_2 ( ) ; } catch ( TYPE_2 e ) { <START> VAR_2 = VAR_1 . METHOD_3 ( ) ; <END> } logger . info ( String . format ( STRING_2 , query , VAR_1 ) ) ; METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; METHOD_6 ( VAR_2 ) ; } 
public void METHOD_1 ( ) { String query = STRING_1 ; TYPE_1 VAR_1 = new TYPE_1 ( query ) ; Map < Pair < Integer , Integer > , String > VAR_2 = null ; VAR_1 . METHOD_2 ( ) ; logger . info ( String . format ( STRING_2 , query , VAR_1 ) ) ; METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; <START> METHOD_5 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { String query = STRING_1 ; TYPE_1 VAR_1 = new TYPE_1 ( query ) ; <START> Map < Pair < Integer , Integer > , String > VAR_2 = null ; <END> VAR_1 . METHOD_2 ( ) ; logger . info ( String . format ( STRING_2 , query , VAR_1 ) ) ; METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; } 
public final void run ( ) { try ( TYPE_1 response = VAR_1 . get ( url ) ) { } catch ( Exception e ) { <START> LOGGER . error ( e . getMessage ( ) , e ) ; <END> } } 
public T read ( ) { TYPE_1 resource ; resource = METHOD_1 ( ) ; if ( ! resource . exists ( ) ) { return null ; } try ( TYPE_2 VAR_1 = new TYPE_3 ( resource . VAR_2 ( ) ) ) { TYPE_4 type = VAR_3 . METHOD_2 ( ) . METHOD_3 ( VAR_4 ) ; <START> return VAR_3 . METHOD_4 ( VAR_1 , type ) ; <END> } catch ( IOException e ) { throw new TYPE_5 ( e ) ; } } 
public void METHOD_1 ( Path path , boolean VAR_1 ) throws IOException { logger . debug ( STRING_1 + path + STRING_2 ) ; if ( ! TYPE_1 . exists ( path ) ) { logger . warn ( String . format ( STRING_3 , path ) ) ; return ; } TYPE_2 VAR_2 = ( TYPE_2 ) path ; <START> METHOD_2 ( VAR_2 ) ; <END> super . METHOD_1 ( path , VAR_1 ) ; VAR_3 . METHOD_3 ( path ) ; logger . debug ( String . format ( STRING_4 , path ) ) ; } 
public void METHOD_1 ( Path path , boolean VAR_1 ) throws IOException { TYPE_1 VAR_2 = ( TYPE_1 ) path ; logger . debug ( STRING_1 + VAR_2 + STRING_2 ) ; if ( TYPE_2 . METHOD_2 ( VAR_2 ) ) { METHOD_3 ( VAR_2 . METHOD_4 ( ) , VAR_1 ) ; } <START> METHOD_5 ( VAR_2 ) ; <END> super . METHOD_1 ( VAR_2 , VAR_1 ) ; } 
<START> public void commit ( ) throws IOException <END> { commit ( ( TYPE_1 ) METHOD_1 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws IOException , TYPE_2 , TYPE_3 { <START> synchronized ( TYPE_4 . METHOD_2 ( VAR_1 ) ) <END> { METHOD_3 ( VAR_1 , VAR_2 ) ; METHOD_4 ( VAR_1 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> if ( VAR_1 != null ) <END> { if ( ! METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) { TYPE_3 . METHOD_4 ( VAR_3 , VAR_1 , VAR_2 , TYPE_6 . TYPE_7 . class ) ; } if ( ! METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ) { TYPE_3 . METHOD_4 ( VAR_3 , VAR_1 , VAR_2 , TYPE_8 . TYPE_9 . class ) ; } TYPE_3 . METHOD_4 ( VAR_3 , VAR_1 , VAR_2 ) ; } } 
<START> protected TYPE_1 < TYPE_2 > METHOD_1 ( ) <END> { return new TYPE_1 < > ( VAR_1 ) ; } 
public void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; TYPE_2 VAR_3 = TYPE_2 . METHOD_3 ( VAR_1 ) ; try { VAR_4 . METHOD_4 ( VAR_2 ) ; VAR_4 . METHOD_1 ( VAR_3 ) ; } <START> catch ( TYPE_3 e ) <END> { logger . error ( String . format ( STRING_1 , VAR_3 ) ) ; } logger . debug ( STRING_2 + VAR_1 + STRING_3 ) ; } 
public void METHOD_1 ( TYPE_1 event ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; for ( TYPE_3 VAR_2 : VAR_1 . METHOD_3 ( ) ) { if ( VAR_2 . METHOD_4 ( ) ) { <START> continue ; <END> } VAR_3 . METHOD_5 ( VAR_2 ) ; if ( VAR_2 . METHOD_6 ( ) ) { VAR_3 . METHOD_7 ( VAR_2 ) ; } } } 
public void METHOD_1 ( ) { <START> VAR_1 . stream ( ) . forEach ( VAR_2 - > METHOD_2 ( VAR_2 . METHOD_3 ( ) , VAR_2 ) ) ; <END> logger . info ( STRING_1 ) ; } 
protected abstract TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException ; protected TYPE_3 METHOD_2 ( TYPE_2 VAR_1 , TYPE_1 is ) throws IOException { if ( is == null || is instanceof TYPE_3 ) { return ( TYPE_3 ) is ; } try { is = new TYPE_4 ( is ) ; } catch ( TYPE_5 e ) { <START> throw new IOException ( ) ; <END> } return new TYPE_3 ( VAR_1 , is ) ; } 
public TYPE_1 call ( ) throws Exception { <START> VAR_1 . METHOD_1 ( VAR_2 , is ) ; <END> return null ; } 
public TYPE_1 METHOD_1 ( ) { final TYPE_1 config = new TYPE_1 ( ) <START> . METHOD_2 ( STRING_1 ) <END> . METHOD_3 ( METHOD_4 ( TYPE_4 . TYPE_3 . VAR_3 ) ) . METHOD_3 ( METHOD_4 ( TYPE_4 . TYPE_3 . VAR_4 ) ) . METHOD_3 ( METHOD_4 ( TYPE_4 . TYPE_2 . VAR_6 ) ) . METHOD_3 ( METHOD_4 ( TYPE_4 . TYPE_5 . VAR_8 ) ) ; config . VAR_9 ( ) . METHOD_5 ( STRING_2 ) . METHOD_6 ( STRING_3 ) ; return config ; } 
public Date METHOD_1 ( ) { <START> return VAR_1 != null ? new Date ( VAR_1 . METHOD_2 ( ) ) : null ; <END> } 
public void METHOD_1 ( final TYPE_1 configuration ) { try { TYPE_2 VAR_1 = METHOD_2 ( ) ; if ( ! VAR_1 . METHOD_3 ( ) ) { <START> LOGGER . warn ( String . format ( STRING_1 , VAR_1 ) ) ; <END> return ; } parser . VAR_2 ( configuration , VAR_1 . METHOD_4 ( ) ) ; } catch ( TYPE_3 | IOException e ) { throw new TYPE_4 ( e ) ; } } 
public TYPE_1 METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) { <START> return METHOD_3 ( TYPE_2 . TYPE_3 . VAR_4 , TYPE_4 . VAR_6 ) ; <END> } return TYPE_1 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; } 
private boolean METHOD_1 ( ) throws IOException { <START> if ( in . VAR_1 ( ) > 0 ) <END> return true ; else return false ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String path ) throws IOException , <START> IllegalArgumentException <END> { TYPE_3 VAR_2 = METHOD_2 ( VAR_1 ) . METHOD_2 ( path ) ; if ( TYPE_4 . METHOD_3 ( VAR_2 ) ) { TYPE_5 c = TYPE_4 . METHOD_4 ( VAR_2 ) ; return c . VAR_3 ( ) ; } return TYPE_1 . create ( path ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , TYPE_1 value ) { <START> logger . debug ( <END> STRING_1 , this , VAR_1 , value ) ; return VAR_2 . put ( VAR_1 , value ) ; } 
public List < TYPE_1 > METHOD_1 ( Map < String , String > VAR_1 ) { if ( VAR_1 == null || VAR_1 . keySet ( ) . isEmpty ( ) ) { return METHOD_2 ( ) . METHOD_3 ( Collections . VAR_2 ) ; } String VAR_3 = METHOD_4 ( VAR_1 ) ; TYPE_2 < TYPE_1 > query = new TYPE_2 < > ( VAR_3 ) ; logger . info ( STRING_1 + VAR_3 ) ; List < TYPE_1 > VAR_4 = METHOD_5 ( ) . query ( query ) ; <START> return VAR_4 ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_1 source , TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = source . VAR_3 ( ) . METHOD_2 ( ) ; TYPE_2 VAR_4 = VAR_1 . METHOD_3 ( ) . METHOD_2 ( ) ; String VAR_5 = source . VAR_6 ( ) <START> . METHOD_4 ( source . VAR_3 ( ) ) <END> . toString ( ) ; String VAR_7 = VAR_5 . METHOD_5 ( VAR_2 . METHOD_6 ( ) , VAR_4 . METHOD_6 ( ) ) ; TYPE_1 target = VAR_1 . METHOD_7 ( VAR_7 ) ; return target ; } 
public boolean equals ( Object o ) { <START> if ( this == o ) return true ; <END> if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 VAR_1 = ( TYPE_1 ) o ; return TYPE_2 . METHOD_1 ( name , VAR_1 . name ) ; } 
public boolean METHOD_1 ( String path ) { String url = METHOD_2 ( ) + ( path . startsWith ( STRING_1 ) ? path : CHAR_1 + path ) ; logger . debug ( STRING_2 + url ) ; TYPE_1 resource = METHOD_3 ( ) . target ( url ) ; METHOD_4 ( resource ) ; Response response = resource . request ( TYPE_2 . VAR_2 ) . get ( ) ; <START> System . out . println ( response . getStatus ( ) ) ; <END> return response . getStatus ( ) == INT_1 ; } 
void METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = TYPE_3 . METHOD_2 ( TYPE_2 . class ) ; assertEquals ( STRING_1 , VAR_1 . type ( ) ) ; assertEquals ( STRING_2 , VAR_1 . METHOD_3 ( new TYPE_2 ( ) ) ) ; <START> assertEquals ( STRING_3 , VAR_1 . METHOD_4 ( ) ) ; <END> } 
public Builder TYPE_1 ( TYPE_2 < ? super TYPE_3 < ? > > TYPE_1 ) { <START> TYPE_1 ( TYPE_1 : : METHOD_1 ) ; <END> return this ; } 
public Object METHOD_1 ( TYPE_1 < ? extends TYPE_2 < ? > > VAR_1 , TYPE_3 VAR_2 ) throws Exception { return TYPE_4 . METHOD_2 ( VAR_2 , ( ) - > { if ( ! VAR_3 . METHOD_3 ( VAR_1 . getMessage ( ) ) ) { return VAR_2 . METHOD_4 ( ) ; } return VAR_3 . METHOD_1 ( VAR_1 . getMessage ( ) , target ) ; <START> <END> } ) ; } 
<START> private TYPE_2 ( Builder builder ) { <END> this . VAR_2 = builder . VAR_2 ; this . VAR_3 = builder . VAR_3 ; this . VAR_4 = builder . VAR_5 . get ( ) ; this . VAR_6 = new TYPE_1 ( VAR_4 ) ; } 
private void METHOD_1 ( TYPE_1 < ? > message , T target ) { <START> METHOD_2 ( message , target ) . METHOD_3 ( VAR_1 - > { <END> try { VAR_1 . METHOD_4 ( message , target ) ; } catch ( Exception e ) { throw new TYPE_2 ( format ( STRING_1 , message . VAR_2 ( ) ) , e ) ; } } ) ; VAR_3 . forEach ( i - > i . VAR_4 ( message , target ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Object VAR_2 = VAR_1 . get ( VAR_3 ) ; <START> if ( VAR_2 instanceof String ) return TYPE_1 . parse ( VAR_2 . toString ( ) ) ; <END> return TYPE_1 . METHOD_2 ( ( long ) VAR_2 ) ; } 
public Object METHOD_1 ( TYPE_1 < ? > command ) throws Exception { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( command ) ; TYPE_3 < T > VAR_3 = VAR_4 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , VAR_5 ) ; Object result = VAR_3 . METHOD_1 ( command ) ; assertThat ( VAR_3 . METHOD_6 ( ) , id - > id != null && id . equals ( VAR_1 . METHOD_4 ( ) ) , STRING_1 ) ; <START> return result ; <END> } 
public void METHOD_1 ( ) { Map < String , TYPE_1 > VAR_1 = new HashMap < > ( ) ; VAR_1 . put ( STRING_1 , new TYPE_2 ( 0 ) ) ; VAR_1 . put ( STRING_2 , new TYPE_2 ( 0 ) ) ; assertTrue ( VAR_2 . METHOD_1 ( new TYPE_3 ( VAR_1 ) ) ) ; <START> VAR_1 . put ( STRING_2 , null ) ; <END> TYPE_3 VAR_3 = new TYPE_3 ( VAR_1 ) ; assertTrue ( VAR_2 . METHOD_1 ( VAR_3 ) ) ; assertTrue ( VAR_3 . METHOD_1 ( VAR_3 ) ) ; } 
<START> private TYPE_1 ( Builder builder ) { <END> super ( builder ) ; builder . VAR_2 ( ) ; this . VAR_3 = builder . VAR_3 ; } 
<START> public void METHOD_1 ( ) { <END> Map < String , TYPE_1 > VAR_1 = new HashMap < > ( ) ; VAR_1 . put ( STRING_1 , new TYPE_2 ( 1 ) ) ; Map < String , TYPE_1 > VAR_2 = new HashMap < > ( ) ; VAR_2 . put ( STRING_1 , new TYPE_2 ( 0 ) ) ; VAR_2 . put ( STRING_2 , new TYPE_2 ( 0 ) ) ; ; TYPE_3 VAR_3 = ( TYPE_3 ) VAR_4 . METHOD_2 ( new TYPE_3 ( VAR_1 ) ) ; } 
<START> public TYPE_1 ( Builder builder ) { <END> this . VAR_2 = builder . VAR_3 ( ) ; this . VAR_4 = builder . VAR_4 ; } 
public Builder METHOD_1 ( String VAR_1 , TYPE_1 < TYPE_2 < ? > > VAR_2 ) { <START> TYPE_3 . assertThat ( VAR_1 , VAR_3 - > ! VAR_4 . containsKey ( VAR_3 ) , <END> STRING_1 ) ; VAR_4 . put ( VAR_1 , VAR_2 ) ; return this ; } 
public TYPE_6 ( TYPE_1 command , TYPE_2 VAR_2 ) { <START> this . command = command ; <END> this . VAR_3 = new TYPE_3 < > ( new TYPE_4 ( command . VAR_4 ( ) ) , VAR_2 ) ; this . VAR_5 = new TYPE_5 ( command . VAR_6 ( ) , VAR_2 ) ; } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_2 VAR_4 ) { <START> this . query = VAR_2 ; <END> this . VAR_5 = new TYPE_3 < > ( new TYPE_4 ( VAR_2 . METHOD_1 ( ) ) , VAR_3 ) ; this . VAR_6 = new TYPE_3 < > ( new TYPE_4 ( VAR_2 . METHOD_2 ( ) ) , VAR_4 ) ; this . VAR_7 = new TYPE_5 ( VAR_2 . METHOD_3 ( ) , VAR_3 ) ; } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_4 = <END> new TYPE_3 < > ( new TYPE_4 ( VAR_2 . METHOD_1 ( ) ) , VAR_3 ) ; this . VAR_5 = new TYPE_5 ( VAR_2 . METHOD_2 ( ) , VAR_3 ) ; } 
public TYPE_1 build ( ) { <START> METHOD_1 ( ) ; <END> return new TYPE_1 ( this ) ; } 
public TYPE_2 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_2 ) TYPE_1 VAR_3 ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = false ; this . VAR_5 = false ; } 
<START> public TYPE_1 < TYPE_2 < ? > > METHOD_1 ( ) { <END> return VAR_1 ; } 
protected void METHOD_1 ( ) throws TYPE_1 { <START> METHOD_2 ( VAR_1 , STRING_1 ) ; <END> METHOD_2 ( VAR_2 , STRING_2 ) ; if ( VAR_3 == null ) { METHOD_2 ( VAR_4 , STRING_3 ) ; return ; } METHOD_2 ( VAR_3 , STRING_4 ) ; } 
<START> TYPE_1 < T > METHOD_1 ( ) { <END> if ( VAR_1 == null ) { return METHOD_2 ( ) ; } else { return VAR_1 ; } } 
<START> default Set < TYPE_2 < ? super TYPE_1 < ? > > > VAR_3 ( ) { <END> throw new TYPE_3 ( STRING_1 ) ; } 
private boolean METHOD_1 ( int VAR_1 ) { if ( VAR_2 . containsKey ( VAR_1 ) && VAR_2 . get ( VAR_1 ) > System . currentTimeMillis ( ) ) { return false ; } <START> VAR_2 . remove ( VAR_1 ) ; <END> return true ; } 
public TYPE_5 ( TYPE_1 VAR_2 , Class < T > VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 , TYPE_4 < String , ? > VAR_6 ) { <START> this ( VAR_2 , VAR_3 , VAR_4 , null , null , VAR_5 , VAR_6 ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 ) { <START> this ( VAR_2 , TYPE_2 . METHOD_1 ( ) , TYPE_3 . VAR_4 ) ; <END> } 
protected static TYPE_1 getInstance ( ) { TYPE_1 instance = TYPE_2 . METHOD_1 ( ) ; <START> if ( TYPE_3 . METHOD_2 ( ) ) { <END> TYPE_4 < ? > VAR_1 = TYPE_3 . get ( ) ; Set < TYPE_1 > VAR_2 = VAR_1 . METHOD_3 ( STRING_1 ) ; if ( VAR_2 != null && VAR_2 . size ( ) == 1 ) { instance = VAR_2 . iterator ( ) . next ( ) ; } } return instance ; } 
public TYPE_7 ( Class < T > VAR_2 ) { VAR_3 = new TYPE_1 ( ) ; VAR_4 = new TYPE_2 ( ) ; VAR_5 . add ( VAR_3 ) ; VAR_5 . add ( VAR_4 ) ; this . VAR_2 = VAR_2 ; METHOD_1 ( ) ; VAR_6 = TYPE_3 . METHOD_2 ( new TYPE_4 ( VAR_5 ) , TYPE_5 . METHOD_3 ( VAR_2 ) ) ; <START> VAR_7 = new TYPE_6 ( Thread . VAR_8 ( ) . METHOD_4 ( ) ) ; <END> } 
<START> public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 < TYPE_3 > VAR_3 , <END> TYPE_2 < TYPE_4 > VAR_4 ) { super ( VAR_2 , VAR_3 ) ; this . VAR_4 = VAR_4 ; } 
public boolean METHOD_1 ( TYPE_1 update ) { <START> return true ; <END> } 
<START> public boolean METHOD_1 ( ) { <END> return true ; } 
<START> public boolean error ( Throwable error ) { <END> return true ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> } 
public double METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , String VAR_3 , String VAR_4 , long VAR_5 , long VAR_6 ) throws Exception { long VAR_7 = METHOD_2 ( VAR_2 , VAR_3 , VAR_4 ) ; <START> long VAR_8 = METHOD_2 ( VAR_2 , VAR_3 , VAR_4 ) ; <END> long VAR_9 = METHOD_3 ( VAR_2 , VAR_3 , VAR_4 ) ; long VAR_10 = METHOD_3 ( VAR_2 , VAR_3 , VAR_4 ) ; if ( VAR_9 == VAR_10 ) return 0 ; return ( VAR_7 - VAR_8 ) / ( VAR_9 - VAR_10 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 action = METHOD_2 ( TYPE_4 . VAR_3 , VAR_1 ) ; <START> VAR_1 . METHOD_3 ( TYPE_5 . VAR_5 ) ; <END> METHOD_4 ( action ) ; } 
public void METHOD_1 ( ) { try { METHOD_2 ( ) ; TYPE_1 VAR_1 = ( TYPE_1 ) VAR_2 . METHOD_3 ( METHOD_4 ( VAR_3 ) ) ; VAR_1 . execute ( ) ; METHOD_5 ( ) ; <START> } catch ( TYPE_2 e ) { <END> e . VAR_4 ( ) ; Assert . VAR_5 ( e . getMessage ( ) ) ; } catch ( TYPE_3 e ) { e . VAR_4 ( ) ; Assert . VAR_5 ( e . getMessage ( ) ) ; } } 
<START> public TYPE_4 ( TYPE_1 VAR_2 , boolean VAR_3 ) throws TYPE_2 , TYPE_3 { <END> this . VAR_2 = VAR_2 ; VAR_4 = null ; VAR_5 = 0 ; VAR_6 = METHOD_1 ( ) ; } 
<START> public Map < String , TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> List < TYPE_1 > result = new ArrayList < TYPE_1 > ( size ( ) ) ; for ( TYPE_2 entry : this ) { result . add ( entry . VAR_1 ( ) ) ; } return result ; } 
<START> public static TYPE_1 getInstance ( ) throws TYPE_2 { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { <START> int VAR_1 = INT_1 ; <END> } 
protected void METHOD_1 ( TYPE_1 parent ) { <START> if ( ! ( parent instanceof TYPE_2 ) || parent == null ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } super . METHOD_1 ( parent ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> TYPE_2 < T > VAR_1 = new TYPE_2 < > ( ) ; for ( T v : this ) { VAR_1 . add ( v ) ; } return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } 
private List < String > METHOD_1 ( TYPE_1 VAR_1 ) { List < String > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_2 VAR_3 : VAR_1 . METHOD_2 ( ) ) { <START> if ( VAR_1 instanceof TYPE_3 && ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) ) { <END> TYPE_4 VAR_4 = ( TYPE_4 ) VAR_3 ; VAR_2 . add ( VAR_4 . getName ( ) ) ; VAR_3 = VAR_4 . METHOD_4 ( ) ; } VAR_3 . METHOD_5 ( this ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { try { return METHOD_2 ( ) . METHOD_3 ( type ) ; } catch ( TYPE_2 | TYPE_3 e ) { <START> throw new TYPE_4 ( e ) ; <END> } } 
public boolean METHOD_1 ( String method ) { Object obj = properties . get ( method ) ; <START> if ( obj != null ) { <END> return ( obj instanceof TYPE_1 ) ; } else { return false ; } } 
public TYPE_3 ( String name , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . name = name ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = this . name . equals ( STRING_1 ) ; <END> } 
public static void METHOD_1 ( TYPE_1 p , String VAR_1 , String VAR_2 , String VAR_3 ) { TYPE_2 o = new TYPE_2 ( ) ; o . VAR_4 ( p ) ; o . VAR_5 ( TYPE_3 . METHOD_2 ( VAR_1 ) ) ; o . VAR_6 ( TYPE_3 . METHOD_2 ( VAR_2 ) ) ; o . VAR_7 ( TYPE_4 . METHOD_3 ( VAR_3 ) ) ; <START> TYPE_2 VAR_8 = Context . VAR_9 ( ) . METHOD_4 ( o , null ) ; <END> } 
private String METHOD_1 ( TYPE_1 t ) { <START> TYPE_2 input = t . VAR_1 ( ) ; String VAR_2 = null ; if ( input != null ) { VAR_2 = input . VAR_3 ( ) ; if ( VAR_2 != null ) VAR_2 = TYPE_3 . METHOD_2 ( VAR_2 ) ; } return VAR_2 ; <END> } 
<START> public < T > TYPE_1 < ? super T > METHOD_1 ( Class < ? extends T > VAR_1 ) { <END> if ( VAR_2 == null ) { return null ; } return VAR_2 . get ( VAR_1 ) ; } 
public String toString ( Object o , String VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 == null ) return o . toString ( ) ; TYPE_2 f = new TYPE_2 ( VAR_2 ) ; f . format ( VAR_1 , o ) ; <START> String VAR_3 = f . toString ( ) ; <END> f . close ( ) ; return VAR_3 ; } 
public String toString ( Object o , String VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 == null ) return o . toString ( ) ; <START> TYPE_2 f = null ; <END> String VAR_3 = "" ; try { f = new TYPE_2 ( VAR_2 ) ; f . format ( VAR_1 , o ) ; VAR_3 = f . toString ( ) ; } finally { if ( f != null ) f . close ( ) ; } return VAR_3 ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( VAR_1 != null ) VAR_1 . METHOD_2 ( ) ; final View VAR_2 = ( View ) METHOD_3 ( R . id . VAR_2 ) ; <START> VAR_2 . METHOD_4 ( new TYPE_1 ( ) { <END> @Override public void run ( ) { VAR_3 = VAR_2 . METHOD_5 ( ) ; METHOD_6 ( ) ; } } ) ; } 
public TYPE_6 ( TYPE_1 db , String name ) { super ( db , name ) ; this . VAR_2 = db ; this . VAR_3 = name . startsWith ( STRING_1 ) ; this . VAR_4 = new TYPE_2 ( ) ; this . VAR_5 = new TYPE_3 ( ) ; this . VAR_6 = VAR_4 . METHOD_1 ( true ) ; <START> this . VAR_7 = new TYPE_4 ( STRING_2 , new TYPE_5 ( STRING_2 , 1 ) , true ) ; <END> this . VAR_8 . put ( Collections . VAR_9 ( STRING_2 ) , VAR_7 ) ; } 
public synchronized void METHOD_1 ( Map < String , Object > state , Set < String > VAR_1 ) { if ( state . get ( STRING_1 ) != STRING_2 ) { if ( ( VAR_2 && ! METHOD_2 ( state . get ( STRING_3 ) ) ) <START> || ( METHOD_2 ( state . get ( STRING_4 ) ) <END> && ! METHOD_2 ( state . get ( STRING_5 ) ) && METHOD_3 ( VAR_1 ) ) ) { METHOD_4 ( state ) ; } } VAR_2 = METHOD_2 ( state . get ( STRING_3 ) ) ; } 
public void METHOD_1 ( TYPE_1 s ) { synchronized ( VAR_1 ) { if ( s . getId ( ) != getId ( ) ) { return ; } if ( METHOD_2 ( ) != s . VAR_2 ( ) ) { set ( TYPE_3 . VAR_4 , s . VAR_2 ( ) ) ; <START> METHOD_3 ( TYPE_2 . VAR_6 ) . METHOD_4 ( ) ; <END> } } } 
String getPath ( TYPE_1 p ) { String path = "" ; if ( p . VAR_1 ( ) != null ) { path = getPath ( p . VAR_1 ( ) ) + STRING_1 ; } path = path + p . VAR_2 ( ) ; <START> if ( ! "" . equals ( p . VAR_3 ( ) ) && p . VAR_3 ( ) != null ) { <END> path = path + STRING_2 + p . VAR_3 ( ) + STRING_3 ; } return path ; } 
public static TYPE_1 getInstance ( ) { <START> if ( instance == null ) { <END> instance = new TYPE_1 ( ) ; } return instance ; } 
<START> public void METHOD_1 ( TYPE_1 client ) { <END> VAR_1 . add ( client ) ; } 
public void METHOD_1 ( ) { synchronized ( VAR_1 ) { METHOD_2 ( VAR_2 ) ; <START> METHOD_3 ( ) ; <END> METHOD_4 ( ) ; METHOD_5 ( ) ; TYPE_1 . METHOD_6 ( ) ; } } 
public void METHOD_1 ( int n ) { <START> synchronized ( this ) { <END> while ( VAR_1 . size ( ) < n ) { TYPE_1 VAR_2 = new TYPE_2 ( VAR_1 . size ( ) + 1 ) ; VAR_2 . METHOD_2 ( this ) ; VAR_1 . add ( VAR_2 ) ; } } } 
protected void METHOD_1 ( File VAR_1 ) { Iterator < File > VAR_2 = Arrays . asList ( VAR_1 . METHOD_2 ( ( TYPE_1 ) VAR_3 ) ) . iterator ( ) ; while ( VAR_2 . hasNext ( ) ) METHOD_3 ( VAR_1 . getName ( ) , VAR_2 . next ( ) ) ; synchronized ( VAR_4 ) { <START> update ( METHOD_4 ( VAR_1 . getName ( ) ) ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = null ; int VAR_2 = 0 ; while ( VAR_1 == null && VAR_2 < VAR_3 ) { <START> VAR_1 = VAR_4 . METHOD_1 ( ) ; <END> VAR_2 ++ ; } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 source ) throws TYPE_3 { if ( ! source . VAR_1 ( ) ) throw new TYPE_3 ( STRING_1 ) ; final String VAR_2 = source . VAR_3 ( ) . METHOD_2 ( STRING_2 , STRING_3 ) ; final String VAR_4 = source . getName ( ) . METHOD_2 ( STRING_2 , STRING_3 ) ; <START> return METHOD_3 ( new TYPE_4 ( STRING_4 + VAR_2 + STRING_5 + VAR_4 ) ) ; <END> } 
public synchronized void METHOD_1 ( ) throws TYPE_1 { try { if ( VAR_1 != null ) { <START> this . VAR_1 . METHOD_1 ( INT_1 , TimeUnit . VAR_2 ) ; <END> this . VAR_1 = null ; } } catch ( InterruptedException e ) { log . error ( STRING_1 ) ; } if ( VAR_3 != null ) { this . VAR_3 . close ( ) ; this . VAR_3 = null ; } } 
private TYPE_1 METHOD_1 ( TYPE_1 a , TYPE_1 b ) { <START> if ( a == null ) { <END> return b ; } else if ( b == null ) { return a ; } return a . offset ( ) > b . offset ( ) ? a : b ; } 
public TYPE_5 ( String VAR_2 , TYPE_1 < ? , ? > VAR_3 ) { this . VAR_3 = VAR_3 ; this . VAR_2 = VAR_2 ; TYPE_3 . TYPE_4 parser = new TYPE_3 . TYPE_4 ( ) ; <START> this . VAR_4 = parser . parse ( <END> STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 + STRING_7 ) ; } 
public String getString ( String name , String VAR_1 ) { String value = ( String ) VAR_2 . get ( name ) ; <START> return TYPE_1 . METHOD_1 ( value ) ? VAR_1 : value ; <END> } 
public TYPE_3 ( String ... command ) { VAR_2 = command ; <START> VAR_3 = new TYPE_1 ( new TYPE_2 ( ) , VAR_2 ) ; <END> } 
private void METHOD_1 ( Map action ) { String msg = ( String ) action . get ( STRING_1 ) ; <START> if ( msg != null ) { <END> VAR_1 . METHOD_2 ( new Exception ( STRING_2 + msg ) ) ; } } 
<START> ANNOTATION_1 public TYPE_1 METHOD_1 ( String value ) { <END> if ( value == null ) { return null ; } String [ ] VAR_1 = value . split ( STRING_1 ) ; if ( VAR_1 . length != 2 ) { return null ; } try { return new TYPE_1 ( Double . valueOf ( VAR_1 [ 0 ] ) , Double . valueOf ( VAR_1 [ 1 ] ) ) ; } catch ( TYPE_2 e ) { return null ; } } 
protected byte [ ] METHOD_1 ( TYPE_1 query ) throws TYPE_2 { String VAR_1 = query . VAR_2 ( ) ; <START> if ( VAR_1 . length ( ) > 0 ) <END> return client . VAR_3 ( STRING_1 + VAR_4 + STRING_2 + VAR_1 , true ) ; else return client . VAR_3 ( STRING_1 + VAR_4 , true ) ; } 
public void run ( ) { VAR_1 -- ; if ( VAR_1 == 0 ) { <START> System . out . println ( STRING_1 ) ; <END> Thread . VAR_2 ( ) . METHOD_1 ( ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 in = new TYPE_1 ( ) ; <START> try ( TYPE_2 out = new TYPE_2 ( in ) ) { <END> out . write ( VAR_1 ) ; } TYPE_3 VAR_2 = ( TYPE_3 ) new TYPE_4 ( STRING_1 , null ) . METHOD_2 ( TYPE_6 . VAR_4 ) . METHOD_3 ( getClass ( ) . METHOD_4 ( ) ) . METHOD_5 ( in , new TYPE_5 ( ) ) ; METHOD_6 ( VAR_2 ) ; } 
private TYPE_1 METHOD_1 ( ) throws IOException { TYPE_1 s = VAR_1 . get ( ) ; <START> if ( s == null ) throw ( IOException ) new IOException ( STRING_1 , VAR_2 ) ; <END> return s ; } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_2 ( new TYPE_1 ( ) { @Override public void write ( int b ) throws IOException { System . VAR_2 ( ) ; <START> throw ( IOException ) new IOException ( VAR_3 , ( Exception ) TYPE_3 . apply ( TYPE_4 . class ) ) ; <END> } } ) ; channel . call ( new TYPE_5 ( VAR_1 ) ) ; } 
protected void METHOD_1 ( ) throws Throwable { super . METHOD_1 ( ) ; <START> if ( channel != null ) { <END> channel . VAR_1 ( new TYPE_1 ( channel . VAR_2 ( ) , VAR_3 ) ) ; VAR_3 = - 1 ; } } 
public TYPE_2 ( ANNOTATION_1 File VAR_2 , boolean VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; if ( VAR_2 == null ) throw new IllegalArgumentException ( STRING_1 ) ; try { TYPE_1 . METHOD_1 ( VAR_2 ) ; } catch ( IOException ex ) { <START> throw new IllegalArgumentException ( STRING_2 + VAR_2 ) ; <END> } } 
<START> public synchronized Object getProperty ( Object key ) { <END> return properties . get ( key ) ; } 
static TYPE_1 METHOD_1 ( ) { List < TYPE_2 > VAR_1 = METHOD_2 ( ) ; try { if ( VAR_1 != null ) { LOGGER . log ( Level . VAR_2 , STRING_1 ) ; return new TYPE_3 ( VAR_1 ) ; } else { LOGGER . log ( Level . VAR_2 , STRING_2 ) ; return new TYPE_3 ( VAR_3 ) ; } } catch ( TYPE_4 e ) { <START> LOGGER . log ( Level . VAR_4 , STRING_3 , e ) ; <END> throw e ; } } 
public void METHOD_1 ( String url , String VAR_1 , String VAR_2 , int id , TYPE_1 model , TYPE_2 response ) throws TYPE_3 { TYPE_4 [ ] VAR_3 = { METHOD_2 ( VAR_1 , VAR_2 ) } ; <START> String VAR_4 = model . VAR_5 ( ) . toString ( ) . substring ( 0 ) ; <END> put ( url , id , new ArrayList < TYPE_4 > ( Arrays . asList ( VAR_3 ) ) , VAR_4 , response ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( METHOD_2 ( ) , METHOD_3 ( ) ) ; } return VAR_1 ; <START> } <END> 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { ArrayList < String > name = new ArrayList < String > ( 1 ) ; name . add ( STRING_1 ) ; VAR_1 = new TYPE_1 ( name ) ; } return VAR_1 ; <START> } <END> 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_1 v = VAR_2 . get ( VAR_1 ) ; if ( v == null ) { if ( VAR_3 == null ) { throw new TYPE_3 ( VAR_1 ) ; } <START> return VAR_3 . METHOD_1 ( VAR_1 ) ; <END> } else { return v ; } } 
public static boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) . values ( ) . stream ( ) . filter ( i - > i . VAR_2 ( ) . METHOD_3 ( ) ) . collect ( Collectors . VAR_3 ( ) ) . size ( ) == 0 ; <END> } 
private TYPE_1 event ( TYPE_1 entity ) { String VAR_1 = entity . getKey ( ) . METHOD_1 ( ) ; final TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null ) { Map < String , Object > event = METHOD_3 ( entity , VAR_2 ) ; try { return TYPE_3 . METHOD_4 ( event , new Date ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } <START> return entity ; <END> } 
void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_2 ( ) ; File VAR_2 = METHOD_2 ( STRING_1 ) ; Map < Integer , String > VAR_3 = VAR_1 . METHOD_3 ( VAR_2 ) ; for ( Integer i : VAR_3 . keySet ( ) ) { <START> System . out . METHOD_4 ( STRING_2 , i , VAR_3 . get ( i ) ) ; <END> } assertEquals ( 0 , VAR_3 . size ( ) ) ; } 
<START> public void METHOD_1 ( String VAR_1 ) { <END> String [ ] VAR_2 = VAR_1 . split ( STRING_1 ) ; if ( VAR_2 == null || VAR_2 . length < 2 || VAR_2 [ 0 ] == null || VAR_2 [ 1 ] == null ) return ; this . VAR_3 = Double . VAR_4 ( VAR_2 [ 0 ] ) ; this . VAR_5 = Double . VAR_4 ( VAR_2 [ 1 ] ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { final TYPE_1 VAR_2 = new TYPE_1 ( ) ; TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 ) ; <START> VAR_2 . METHOD_3 ( TYPE_4 . METHOD_4 ( STRING_1 , VAR_1 . METHOD_5 ( ) ) ) ; <END> VAR_2 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ; VAR_2 . METHOD_8 ( VAR_1 . METHOD_9 ( ) ) ; return VAR_2 ; } 
protected List < TYPE_1 > METHOD_1 ( String response ) throws Exception { final TYPE_2 TYPE_3 = new TYPE_2 ( ) ; List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; final TYPE_4 VAR_2 = TYPE_3 . METHOD_2 ( response ) . get ( STRING_1 ) ; final List < TYPE_1 > VAR_3 = TYPE_3 . METHOD_3 ( VAR_2 , new TYPE_5 < List < TYPE_1 > > ( ) { } ) ; <START> VAR_1 . addAll ( VAR_3 ) ; <END> return VAR_1 ; } 
public static Map < String , Object > METHOD_1 ( String VAR_1 ) { <START> Map < String , Object > VAR_2 = new HashMap < String , Object > ( ) ; <END> try { VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 , Map . VAR_3 ) ; } catch ( IOException e ) { log . error ( STRING_1 ) ; } if ( VAR_2 != null ) { return VAR_2 ; } else { return Collections . VAR_4 ( ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , Long VAR_2 , List < TYPE_2 > VAR_3 ) { if ( VAR_3 . size ( ) == 0 ) { <START> return true ; <END> } else { TYPE_2 VAR_4 = VAR_3 . get ( 0 ) ; List < TYPE_2 > VAR_5 = VAR_1 . METHOD_2 ( VAR_2 , VAR_4 . getKey ( ) . getId ( ) ) ; return VAR_5 . size ( ) == 0 ; } } 
public List < TYPE_1 > METHOD_1 ( Long VAR_1 ) { <START> VAR_1 = VAR_1 < 0 ? null : VAR_1 ; <END> return super . METHOD_2 ( STRING_1 , VAR_1 , STRING_2 ) ; } 
private String [ ] METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) throw new TYPE_1 ( STRING_1 ) ; String [ ] VAR_2 = VAR_1 . split ( STRING_2 ) ; if ( VAR_2 . length != 2 ) throw new TYPE_1 ( STRING_1 ) ; <START> return VAR_2 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = TYPE_1 . of ( new TYPE_2 ( STRING_1 , STRING_2 , - 1 ) ) ; <START> TYPE_3 . create ( VAR_2 . METHOD_2 ( VAR_1 ) ) . METHOD_3 ( 0 ) . METHOD_4 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return TYPE_3 . METHOD_1 ( TYPE_4 . METHOD_2 ( ) ? VAR_2 . METHOD_3 ( ) : null , VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = query ( METHOD_2 ( STRING_1 ) . is ( Long . VAR_2 ) ) ; <START> METHOD_3 ( VAR_3 . METHOD_4 ( VAR_1 , TYPE_2 . class ) , METHOD_5 ( ) ) ; <END> VAR_3 . METHOD_6 ( VAR_1 , TYPE_3 . update ( STRING_2 , STRING_3 ) , TYPE_2 . class ) ; assertThat ( VAR_3 . METHOD_4 ( VAR_1 , TYPE_2 . class ) , METHOD_5 ( ) ) ; } 
public String METHOD_1 ( ) { if ( METHOD_2 ( ) != TYPE_1 . VAR_2 ) { return VAR_3 ; } <START> String version = VAR_4 . METHOD_1 ( ) ; <END> return version == null ? STRING_1 : version ; } 
public TYPE_1 [ ] METHOD_1 ( ) { <START> return new TYPE_1 [ ] { TYPE_1 . VAR_1 , TYPE_1 . VAR_2 } ; <END> } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( StringUtils . VAR_2 ( VAR_1 ) && VAR_1 . contains ( STRING_1 ) ) { <END> TYPE_2 VAR_3 = TYPE_2 . valueOf ( StringUtils . VAR_4 ( VAR_1 , STRING_1 ) ) ; Long VAR_5 = Long . valueOf ( StringUtils . VAR_6 ( VAR_1 , STRING_1 ) ) ; return new TYPE_1 ( VAR_3 , VAR_5 ) ; } return null ; } 
private TYPE_1 METHOD_1 ( Class VAR_1 , String VAR_2 ) { try { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( STRING_1 , String . VAR_4 ) ; <START> if ( VAR_3 != null ) { <END> TYPE_1 e = ( TYPE_1 ) VAR_3 . METHOD_3 ( null , VAR_2 ) ; return e ; } } catch ( TYPE_3 | TYPE_4 | TYPE_5 | IllegalArgumentException | TYPE_6 VAR_5 ) { } return null ; } 
protected String METHOD_1 ( TYPE_1 VAR_1 ) { Long VAR_2 = VAR_1 . METHOD_2 ( ) != null ? VAR_1 . METHOD_2 ( ) . getId ( ) : null ; Long VAR_3 = VAR_1 . METHOD_3 ( ) != null ? VAR_1 . METHOD_3 ( ) . getId ( ) : null ; if ( ( VAR_2 != null ) && ( VAR_3 != null ) ) <START> return VAR_4 . METHOD_4 ( VAR_2 , VAR_3 ) ; <END> else return null ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { Set < TYPE_2 > VAR_3 = VAR_4 . METHOD_2 ( VAR_1 . METHOD_3 ( ) . getId ( ) ) ; if ( VAR_3 != null ) <START> return VAR_3 . contains ( VAR_2 ) ; <END> return false ; } 
public static TYPE_1 METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( ) ; TYPE_1 VAR_3 = null ; for ( TYPE_1 VAR_4 : VAR_1 ) { if ( VAR_3 == null || VAR_2 . METHOD_2 ( VAR_4 , VAR_3 ) > 0 ) <START> VAR_3 = VAR_4 ; <END> } return VAR_3 ; } 
public TYPE_1 [ ] METHOD_1 ( ) { <START> return new TYPE_1 [ ] { TYPE_1 . VAR_1 , TYPE_1 . VAR_2 , TYPE_1 . VAR_3 } ; <END> } 
private void execute ( TYPE_1 < TYPE_2 > VAR_1 , boolean VAR_2 ) { query ( db - > { VAR_1 . execute ( db ) ; <START> return Optional . empty ( ) ; <END> } , VAR_2 ) ; } 
public TYPE_1 ( int VAR_2 , int VAR_3 , long VAR_4 , long VAR_5 ) { <START> VAR_6 = System . currentTimeMillis ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; } 
public T get ( ) { if ( VAR_1 == null ) { <START> synchronized ( this ) { <END> this . VAR_1 = build ( VAR_2 , VAR_3 ) ; } } if ( VAR_4 ) { VAR_1 . METHOD_1 ( ) ; } return VAR_1 ; } 
<START> public TYPE_2 ( ) { <END> this ( new TYPE_1 ( STRING_1 ) ) ; } 
private boolean METHOD_1 ( Context context ) { int VAR_1 = 0 ; Iterator < Context > iterator = context . VAR_2 ( ) . METHOD_2 ( ) . iterator ( ) ; while ( VAR_1 <= 1 ) { <START> if ( ! iterator . hasNext ( ) ) break ; <END> if ( context . getPath ( ) . equals ( iterator . next ( ) . getPath ( ) ) ) { ++ VAR_1 ; } } return VAR_1 > 1 ; } 
public void METHOD_1 ( ) { TYPE_1 < String > [ ] VAR_1 = null ; <START> Object o = null ; <END> String message = STRING_1 ; METHOD_2 ( ) . METHOD_3 ( ( ) - > assertThat ( VAR_2 ) . METHOD_4 ( VAR_1 ) ) . METHOD_5 ( message ) ; } 
public TYPE_1 < ? > METHOD_1 ( ) { VAR_1 . assertNotNull ( info , VAR_2 ) ; <START> return TYPE_2 . assertThat ( TYPE_3 . METHOD_2 ( VAR_2 ) ) ; <END> } 
<START> private short METHOD_1 ( int value ) { <END> return ( short ) value ; } 
public final boolean equals ( Object obj ) { <START> if ( this == obj ) return true ; <END> if ( ! ( obj instanceof TYPE_1 ) ) return false ; TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return Arrays . VAR_2 ( values . VAR_3 ( ) , VAR_1 . values . METHOD_1 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 info , Class < ? > VAR_1 , Class < ? > VAR_2 ) { assertNotNull ( info , VAR_1 ) ; Class < ? > VAR_3 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_3 == null && VAR_2 != null || VAR_3 != null && ! VAR_3 . equals ( VAR_2 ) ) { <END> throw VAR_4 . METHOD_3 ( info , METHOD_4 ( VAR_1 , VAR_2 ) ) ; } } 
private TYPE_2 ( Throwable VAR_2 , String VAR_3 ) { super ( STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_3 + STRING_1 + STRING_5 + <START> STRING_1 + TYPE_1 . METHOD_1 ( METHOD_2 ( VAR_2 ) ) , <END> VAR_3 , VAR_2 . getMessage ( ) ) ; } 
<START> private boolean METHOD_1 ( int VAR_1 , int VAR_2 ) { <END> return ( VAR_1 & VAR_2 ) == VAR_2 ; } 
public Object METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) . getType ( ) == TYPE_3 . class ) { return METHOD_3 ( VAR_2 ) . METHOD_4 ( TYPE_3 . class ) ; } <START> return METHOD_3 ( VAR_2 ) . METHOD_4 ( TYPE_4 . class ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> TYPE_3 . instance ( ) . assertNotNull ( info , VAR_2 ) ; METHOD_2 ( VAR_1 ) ; VAR_3 . METHOD_3 ( info , VAR_2 , VAR_1 ) ; return VAR_4 ; } 
public < T extends TYPE_1 < ? super T > > void METHOD_1 ( TYPE_2 info , T VAR_1 , T VAR_2 ) { <START> this . METHOD_1 ( info , VAR_1 , VAR_2 , TYPE_3 : : METHOD_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { try { VAR_1 . run ( ) ; } catch ( TYPE_2 error ) { VAR_2 . METHOD_2 ( error ) ; } catch ( Exception e ) { <START> throw new RuntimeException ( e ) ; <END> } } 
public void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . class ) . METHOD_3 ( ( ) - > VAR_1 . METHOD_4 ( METHOD_5 ( ) , null , <START> Arrays . asList ( STRING_1 ) ) ) <END> . METHOD_6 ( METHOD_7 ( ) ) ; } 
private TYPE_1 METHOD_1 ( String message ) { try { Object o = VAR_1 . METHOD_2 ( STRING_1 , VAR_2 , message , VAR_3 , <START> VAR_4 ) ; <END> if ( o instanceof TYPE_1 ) { TYPE_1 VAR_5 = ( TYPE_1 ) o ; TYPE_2 . instance ( ) . METHOD_3 ( VAR_5 ) ; return VAR_5 ; } return null ; } catch ( Throwable e ) { return null ; } } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 ) . METHOD_3 ( info ( ) , METHOD_4 ( METHOD_5 ( ) ) , VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { Iterator < String > VAR_1 = asList ( STRING_1 , STRING_2 ) . iterator ( ) ; <START> TYPE_1 < String > VAR_2 = ( TYPE_1 < String > ) assertThat ( VAR_1 ) . METHOD_2 ( ) . VAR_2 ; <END> assertThat ( VAR_2 ) . METHOD_3 ( STRING_2 , STRING_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 . instance ( ) . assertNotNull ( info , VAR_2 ) ; <START> METHOD_2 ( VAR_1 ) ; <END> return super . METHOD_1 ( METHOD_3 ( VAR_1 ) ) ; } 
public void METHOD_1 ( ) { Exception exception = new Exception ( STRING_1 ) ; TYPE_1 VAR_1 = METHOD_2 ( exception ) ; <START> VAR_2 . METHOD_3 ( TYPE_2 . METHOD_4 ( exception ) ) ; <END> METHOD_5 ( VAR_1 ) . METHOD_6 ( ) ; } 
public void METHOD_1 ( ) { final Exception VAR_1 = new RuntimeException ( STRING_1 ) ; Exception VAR_2 = null ; try { VAR_2 = METHOD_2 ( METHOD_3 ( VAR_1 ) , Exception . VAR_3 ) ; } catch ( TYPE_1 a ) { <START> TYPE_2 . METHOD_4 ( STRING_2 , a ) ; <END> } assertThat ( VAR_2 ) . METHOD_5 ( VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { for ( int i = 0 ; i < VAR_1 . length ( ) ; i ++ ) { <START> if ( ! TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( i ) ) ) return false ; <END> } return true ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ( VAR_1 == null || VAR_1 . length ( ) == 0 ) ; <END> } 
private static List < Object > METHOD_1 ( Collection < ? extends Object > list ) { List < Object > result = new ArrayList < > ( ) ; TYPE_1 < Object > VAR_1 = new TYPE_1 < > ( list ) ; while ( ! VAR_1 . isEmpty ( ) ) { Object e = VAR_1 . METHOD_2 ( ) ; if ( e instanceof List < ? > ) VAR_1 . addAll ( 0 , ( List < ? > ) e ) ; else <START> result . add ( e ) ; <END> } return result ; } 
<START> protected String METHOD_1 ( TYPE_1 description , TYPE_2 VAR_1 ) { <END> if ( METHOD_2 ( ) ) { return METHOD_3 ( description , VAR_1 ) ; } return VAR_2 . METHOD_4 ( ) ? VAR_3 . format ( description , VAR_1 , VAR_4 , VAR_5 , VAR_6 ) : VAR_3 . format ( description , VAR_1 , VAR_7 , VAR_5 , VAR_6 , VAR_2 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> when ( VAR_1 . METHOD_2 ( METHOD_3 ( String . VAR_2 ) , METHOD_3 ( Class [ ] . class ) , METHOD_4 ( ) ) ) . METHOD_5 ( null ) ; <END> TYPE_1 error = factory . VAR_3 ( description , new TYPE_2 ( ) ) ; METHOD_6 ( error ) ; } 
public void METHOD_1 ( TYPE_1 info , Class < ? > VAR_1 , String ... VAR_2 ) { assertNotNull ( info , VAR_1 ) ; <START> METHOD_2 ( info , VAR_1 , VAR_1 . METHOD_3 ( ) , VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( METHOD_3 ( ) , VAR_2 , METHOD_4 ( STRING_1 , STRING_2 , STRING_3 ) ) ; VAR_2 . add ( null ) ; <START> VAR_1 . METHOD_2 ( METHOD_3 ( ) , VAR_2 , METHOD_4 ( STRING_1 , STRING_2 , STRING_3 , null ) ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( METHOD_3 ( ) , VAR_2 , VAR_2 , METHOD_4 ( valueOf ( 1 ) ) ) ; <START> VAR_1 . METHOD_2 ( METHOD_3 ( ) , VAR_2 , VAR_3 , METHOD_4 ( valueOf ( INT_1 ) ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 . METHOD_2 ( METHOD_3 ( ) , VAR_2 , STRING_1 , STRING_2 ) ; <END> } 
public TYPE_2 ( String name , String VAR_2 , Set < String > VAR_3 ) { TYPE_1 . METHOD_1 ( name ) ; TYPE_1 . METHOD_1 ( VAR_2 ) ; <START> TYPE_1 . METHOD_1 ( VAR_4 ) ; <END> this . name = name ; this . VAR_2 = VAR_2 ; for ( String VAR_5 : VAR_3 ) { this . VAR_3 . add ( VAR_5 ) ; } } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 project = METHOD_2 ( ) ; <START> METHOD_3 ( project , STRING_1 ) ; <END> METHOD_4 ( project , STRING_2 ) ; return project ; } 
protected TYPE_1 METHOD_1 ( final int VAR_1 ) throws IOException { Collection < TYPE_1 > VAR_2 = new TYPE_2 ( ) . parse ( METHOD_2 ( STRING_1 ) ) ; <START> Iterator < TYPE_1 > iterator = VAR_2 . iterator ( ) ; <END> TYPE_1 VAR_3 = iterator . next ( ) ; for ( int i = 1 ; i < VAR_1 ; i ++ ) { VAR_3 = iterator . next ( ) ; } return VAR_3 ; } 
public TYPE_1 ( ) { super ( Messages . VAR_2 ( ) , Messages . VAR_3 ( ) , Messages . VAR_4 ( ) , VAR_5 , <START> false ) ; <END> } 
public TYPE_1 ( ) { super ( Messages . VAR_2 ( ) , Messages . VAR_3 ( ) , Messages . VAR_4 ( ) , <START> VAR_5 , true ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 request = new TYPE_1 ( ) ; request . VAR_1 ( INT_1 ) ; request . VAR_2 ( true ) ; request . VAR_3 ( STRING_1 ) ; request . VAR_4 ( STRING_2 ) ; request . VAR_5 ( STRING_3 ) ; <START> request . VAR_6 ( STRING_3 ) ; <END> request . VAR_7 ( STRING_4 ) ; return request ; } 
private Set < TYPE_1 > METHOD_1 ( ) { if ( StringUtils . isEmpty ( VAR_1 ) ) { return Collections . VAR_2 ( ) ; } try { <START> return METHOD_2 ( TYPE_2 . METHOD_3 ( METHOD_4 ( VAR_1 ) , INT_1 , INT_1 , 0 ) ) ; <END> } catch ( Exception ex ) { log . error ( STRING_1 ) ; return Collections . VAR_2 ( ) ; } } 
public TYPE_1 build ( ) { <START> TYPE_2 < TYPE_3 > VAR_1 = METHOD_1 ( ) ; <END> VAR_2 . METHOD_2 ( VAR_1 ) ; return new TYPE_1 ( VAR_1 ) ; } 
TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_3 VAR_1 = new TYPE_4 ( this . VAR_2 ) ; TYPE_5 < TYPE_2 > VAR_3 = METHOD_2 ( VAR_1 ) ; TYPE_6 < TYPE_2 > VAR_4 = new TYPE_7 < > ( ) ; VAR_4 . METHOD_3 ( METHOD_4 ( VAR_3 ) ) ; VAR_4 . METHOD_5 ( ( VAR_5 , context ) - > { } ) ; <START> VAR_6 . METHOD_6 ( VAR_4 ) ; <END> return VAR_4 ; } 
public TYPE_6 ( TYPE_1 VAR_2 , String VAR_3 , ANNOTATION_1 String VAR_4 ) { Assert . VAR_5 ( VAR_2 , STRING_1 ) ; Assert . VAR_5 ( VAR_3 , STRING_2 ) ; this . VAR_2 = VAR_2 ; this . VAR_6 = new TYPE_2 ( VAR_3 ) ; <START> this . VAR_7 = Optional . VAR_8 ( VAR_4 ) . <END> map ( TYPE_3 : : new ) . METHOD_1 ( null ) ; this . VAR_9 = new TYPE_4 ( ) ; this . VAR_10 = new TYPE_5 ( ) ; } 
<START> protected TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 , TYPE_4 VAR_2 ) { <END> final TYPE_5 VAR_3 = VAR_2 . METHOD_2 ( ) ; final TYPE_6 VAR_4 = new TYPE_6 ( VAR_1 ) ; return VAR_5 . METHOD_3 ( VAR_3 , VAR_4 ) . METHOD_4 ( this . VAR_6 . METHOD_1 ( VAR_2 , VAR_1 ) ) . METHOD_5 ( TYPE_7 . METHOD_6 ( TYPE_1 . METHOD_7 ( VAR_4 ) ) ) ; } 
protected TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { Assert . VAR_3 ( VAR_2 , STRING_1 ) ; if ( this . logger . VAR_4 ( ) ) { this . logger . debug ( STRING_2 + VAR_2 + STRING_3 ) ; } <START> <END> return VAR_5 . METHOD_2 ( VAR_2 ) . METHOD_3 ( TYPE_1 . error ( this : : METHOD_4 ) ) . METHOD_5 ( TYPE_3 : : METHOD_6 ) . map ( VAR_6 - > METHOD_7 ( VAR_6 , VAR_1 ) ) ; } 
<START> default Map < String , Object > VAR_1 ( ) { <END> return Collections . VAR_2 ( ) ; } 
<START> default < VAR_1 > VAR_1 VAR_2 ( String name ) { <END> return ( VAR_1 ) VAR_3 ( ) . get ( name ) ; } 
<START> @Override public boolean METHOD_1 ( ) { <END> return true ; } 
@Override public Object METHOD_1 ( Object parent ) { if ( parent == null ) { return this ; } <START> if ( parent instanceof TYPE_1 ) { <END> this . VAR_1 = ( TYPE_2 ) parent ; return this . VAR_1 ; } else { throw new IllegalArgumentException ( STRING_1 + parent . getClass ( ) . getName ( ) + STRING_2 ) ; } } 
private void METHOD_1 ( TYPE_1 builder ) { TYPE_2 VAR_1 = METHOD_2 ( builder ) ; builder . VAR_2 ( METHOD_3 ( VAR_1 ) ) ; TYPE_3 VAR_3 = METHOD_4 ( builder ) ; <START> TYPE_4 VAR_4 = builder . VAR_5 ( TYPE_4 . class ) ; <END> if ( VAR_4 != null ) { VAR_3 . METHOD_5 ( VAR_4 ) ; } builder . VAR_2 ( METHOD_3 ( VAR_3 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 url ) { <START> String VAR_1 = cache . get ( url . toString ( ) , ( ) - > VAR_2 . METHOD_1 ( url ) . METHOD_2 ( ) ) ; <END> return new TYPE_1 ( VAR_1 , STRING_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <START> this . VAR_3 = VAR_1 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( ) { Map < Class < ? extends TYPE_1 > , Class < ? extends TYPE_2 > > VAR_1 = new HashMap < > ( ) ; VAR_2 = new TYPE_3 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; <START> TYPE_4 VAR_3 = METHOD_3 ( TYPE_4 . class ) ; <END> VAR_2 . METHOD_4 ( VAR_3 ) ; } 
<START> protected TYPE_1 METHOD_1 ( T VAR_1 , TYPE_1 VAR_2 ) { <END> if ( TYPE_2 . isEmpty ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ) ) { Set < String > VAR_3 = METHOD_4 ( VAR_1 ) ; VAR_2 = TYPE_1 . METHOD_5 ( VAR_2 ) . METHOD_6 ( VAR_3 ) . build ( ) ; } return VAR_2 ; } 
private TYPE_4 ( TYPE_1 < T > VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; Context VAR_4 = this . VAR_2 . METHOD_1 ( ) ; Context context ; <START> if ( VAR_4 . METHOD_2 ( VAR_5 ) ) { <END> context = VAR_4 ; } else { context = VAR_4 . put ( VAR_5 , new TYPE_3 ( VAR_3 ) ) ; } this . context = context ; } 
private boolean METHOD_1 ( TYPE_1 request ) { TYPE_2 VAR_1 = this . VAR_2 . METHOD_2 ( request ) ; if ( VAR_1 == null ) { return false ; } TYPE_3 < String , String > params = TYPE_4 . METHOD_3 ( request . VAR_3 ( ) ) ; <START> if ( METHOD_4 ( request , VAR_1 . METHOD_5 ( ) ) && <END> TYPE_4 . METHOD_6 ( params ) ) { return true ; } return false ; } 
public Collection < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { Collection < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( String VAR_3 : METHOD_2 ( VAR_1 ) ) { <START> VAR_2 . add ( new TYPE_3 ( VAR_4 + VAR_3 ) ) ; <END> } return VAR_2 ; } 
<START> public TYPE_4 ( ANNOTATION_1 TYPE_1 request , <END> ANNOTATION_1 TYPE_2 response , ANNOTATION_1 TYPE_3 VAR_2 ) { this . request = request ; this . response = response ; this . VAR_2 = VAR_2 ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return request ; } 
private List < String > METHOD_1 ( String [ ] VAR_1 ) { <START> final List < String > list = new ArrayList < > ( ) ; <END> if ( ! ( VAR_2 instanceof TYPE_1 ) ) { return Collections . VAR_3 ( ) ; } for ( String VAR_4 : VAR_1 ) { if ( ( ( TYPE_1 ) VAR_2 ) . METHOD_2 ( ) . METHOD_3 ( VAR_4 ) . METHOD_4 ( ) ) { list . add ( VAR_4 ) ; } } return list ; } 
private static Map < String , TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { final TYPE_2 < String , TYPE_1 > result = new TYPE_2 < > ( ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { <START> if ( result . containsKey ( VAR_2 . METHOD_2 ( ) ) ) { <END> throw new IllegalStateException ( String . format ( STRING_1 , VAR_2 . METHOD_2 ( ) ) ) ; } result . put ( VAR_2 . METHOD_2 ( ) , VAR_2 ) ; } return Collections . VAR_3 ( result ) ; } 
private TYPE_1 < String > METHOD_1 ( String ... VAR_1 ) { <START> final TYPE_1 < String > result = new TYPE_1 < > ( ) ; <END> Collections . addAll ( result , VAR_1 ) ; return result ; } 
private TYPE_1 < String , TYPE_2 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { <START> final TYPE_1 < String , TYPE_2 > result = new TYPE_1 < > ( ) ; <END> for ( TYPE_2 VAR_2 : VAR_1 ) { result . put ( VAR_2 . METHOD_2 ( ) , VAR_2 ) ; } return result ; } 
public TYPE_1 METHOD_1 ( TYPE_2 context ) { Assert . VAR_1 ( context , STRING_1 ) ; for ( TYPE_3 VAR_2 : VAR_3 ) { <START> final TYPE_1 VAR_4 = VAR_2 . METHOD_1 ( context ) ; <END> if ( VAR_4 != null ) { return VAR_4 ; } } return null ; } 
private void METHOD_1 ( TYPE_1 request ) { String VAR_1 = request . VAR_2 ( ) ; <START> if ( this . VAR_3 != null && ! this . VAR_3 . METHOD_2 ( VAR_1 ) ) { <END> throw new TYPE_2 ( STRING_1 + VAR_1 + STRING_2 ) ; } } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 key ) { <END> Assert . VAR_3 ( VAR_2 , STRING_1 ) ; Assert . VAR_3 ( key , STRING_2 ) ; this . keySet = Arrays . asList ( key ) ; this . VAR_2 = VAR_2 ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 request = METHOD_2 ( ) . METHOD_3 ( STRING_1 , STRING_2 , STRING_3 ) . METHOD_4 ( VAR_1 ) ; TYPE_2 token = ( TYPE_2 ) request . VAR_2 ( TYPE_4 . TYPE_3 . VAR_5 ) ; assertThat ( request . VAR_6 ( ) ) . METHOD_5 ( STRING_4 ) ; assertThat ( request . VAR_7 ( token . VAR_8 ( ) ) ) . METHOD_5 ( token . VAR_9 ( ) ) ; assertThat ( request . VAR_10 ( ) ) . METHOD_5 ( STRING_5 ) ; } 
public TYPE_2 ( Object VAR_2 , Class VAR_3 , String VAR_4 , Class [ ] VAR_5 , Object [ ] VAR_6 ) throws TYPE_1 { <START> this . method = VAR_3 . METHOD_1 ( VAR_4 , VAR_5 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_6 = VAR_6 ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { if ( this . VAR_2 != null && this . VAR_3 != null ) { TYPE_2 VAR_4 = new TYPE_2 ( this . VAR_2 , this . VAR_3 ) ; <START> if ( VAR_5 != null ) { <END> VAR_4 . METHOD_2 ( VAR_5 ) ; } VAR_1 . add ( VAR_4 ) ; } } 
public TYPE_1 < TYPE_2 . Builder > METHOD_1 ( ) { <START> TYPE_3 . METHOD_2 ( VAR_1 , TYPE_4 . METHOD_3 ( ( s , VAR_2 ) - > METHOD_4 ( VAR_2 ) ) ) ; <END> return builder - > builder . VAR_3 ( METHOD_5 ( ) ) . filter ( this ) ; } 
public void METHOD_1 ( ) throws Exception { this . response . put ( STRING_1 , Arrays . asList ( STRING_2 ) ) ; TYPE_1 VAR_1 = METHOD_2 ( "" ) <START> . METHOD_3 ( TYPE_2 . NONE ) <END> . build ( ) ; assertThat ( VAR_1 . METHOD_4 ( ) ) . METHOD_5 ( TYPE_2 . NONE ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( Collections . VAR_2 ( STRING_1 ) ) ; <END> TYPE_2 writer = new TYPE_2 ( VAR_1 ) ; writer . VAR_3 ( this . request , this . response ) ; assertThat ( this . response . VAR_4 ( TYPE_2 . VAR_5 ) ) . METHOD_2 ( STRING_2 ) ; } 
public void METHOD_1 ( TYPE_1 request , TYPE_2 response ) { <START> VAR_1 . forEach ( VAR_2 - > VAR_2 . METHOD_1 ( request , response ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 ... VAR_1 ) { <START> if ( ! TYPE_3 . equals ( VAR_1 [ 0 ] , TYPE_4 . VAR_3 ) ) { <END> Assert . state ( ! this . VAR_4 , STRING_1 ) ; } return METHOD_2 ( Arrays . asList ( VAR_1 ) ) ; } 
public TYPE_3 ( TYPE_1 token , Map < String , Object > VAR_2 , Collection < ? extends TYPE_2 > VAR_3 ) { this ( token , VAR_2 , VAR_3 , null ) ; <START> METHOD_1 ( true ) ; <END> } 
public void METHOD_1 ( String name , ANNOTATION_1 Object value ) { <START> if ( name == null ) <END> throw new IllegalArgumentException ( STRING_1 ) ; else super . METHOD_1 ( name , value ) ; } 
public TYPE_1 ( String VAR_2 ) { <START> Assert . VAR_3 ( VAR_2 , STRING_1 ) ; <END> Assert . VAR_4 ( VAR_2 , STRING_2 ) ; this . VAR_2 = VAR_2 ; } 
<START> protected TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { Assert . VAR_4 ( VAR_2 , STRING_1 ) ; <START> Assert . VAR_4 ( VAR_3 , STRING_2 ) ; <END> this . VAR_5 = new TYPE_3 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_6 = new TYPE_4 ( ) ; } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> if ( this . VAR_1 == null ) { TYPE_2 VAR_2 = METHOD_2 ( ) ; TYPE_1 VAR_1 = new TYPE_3 ( VAR_2 ) ; return VAR_1 ; } return this . VAR_1 ; } 
public static TYPE_1 . Builder request ( ) { String VAR_1 = STRING_1 ; String VAR_2 = STRING_2 ; Map < String , Object > VAR_3 = new HashMap < > ( ) ; VAR_3 . put ( TYPE_2 . VAR_5 , VAR_1 ) ; return TYPE_1 . METHOD_1 ( ) . METHOD_2 ( STRING_3 ) . METHOD_3 ( VAR_2 ) <START> . METHOD_4 ( STRING_4 ) <END> . METHOD_5 ( STRING_5 ) . state ( STRING_6 ) . METHOD_6 ( VAR_3 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( this . VAR_1 == null ) { TYPE_2 context = this . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; this . VAR_1 = new TYPE_1 ( context ) ; } return this . VAR_1 ; } 
private String getKey ( ) { <START> if ( this . key == null && this . VAR_1 instanceof TYPE_1 ) { <END> this . key = ( ( TYPE_1 ) VAR_1 ) . getKey ( ) ; } if ( this . key == null ) { this . key = TYPE_2 . METHOD_1 ( ) . toString ( ) ; } return this . key ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { <START> VAR_1 . METHOD_2 ( ) <END> . METHOD_3 ( new TYPE_2 ( STRING_1 , METHOD_4 ( ) ) ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == null ) { <END> return false ; } return TYPE_2 . METHOD_2 ( VAR_1 . getClass ( ) , TYPE_3 . class ) != null ; } 
TYPE_1 METHOD_1 ( ) { if ( this . VAR_1 != null ) { return this . VAR_1 ; } <START> TYPE_1 VAR_2 = METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) ; <END> return VAR_2 == null ? TYPE_1 . VAR_3 : VAR_2 ; } 
public TYPE_4 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_2 , TYPE_3 VAR_3 ) { Assert . VAR_4 ( VAR_2 , STRING_1 ) ; Assert . VAR_5 ( VAR_3 , STRING_2 ) ; <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( ) throws Exception { <END> if ( this . VAR_1 == null ) { this . METHOD_2 ( ) ; } return this . VAR_1 ; } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( ) throws Exception { <END> return METHOD_2 ( new TYPE_1 < > ( ) ) ; } 
<START> public Object METHOD_1 ( ) throws Exception { <END> return METHOD_2 ( new TYPE_1 < TYPE_2 > ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { VAR_2 . METHOD_1 ( VAR_1 ) ; <START> return null ; <END> } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 uri , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) { this . VAR_2 = VAR_2 ; this . uri = uri ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_3 . buffer ( 0 , 0 ) ; <START> this . VAR_6 = false ; <END> } 
public void METHOD_1 ( Context context ) throws Exception { <START> if ( ! name . equals ( VAR_1 ) ) { <END> METHOD_2 ( context , name ) ; } else { METHOD_3 ( context ) ; } } 
public Boolean METHOD_1 ( ) { <START> return TYPE_2 . TYPE_3 . equals ( VAR_1 . get ( TYPE_2 . VAR_3 ) ) ; <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final Object message ) throws Exception { VAR_2 . execute ( new TYPE_2 < TYPE_3 > ( ) { @Override public void execute ( TYPE_3 VAR_3 ) { <START> TYPE_4 VAR_4 = new TYPE_5 ( false ) ; <END> TYPE_6 VAR_5 = new TYPE_7 ( VAR_4 ) ; VAR_3 . METHOD_1 ( TYPE_8 . VAR_7 , VAR_5 , VAR_1 . size ( ) , message ) ; } } ) ; } 
public String METHOD_1 ( ) { final TYPE_1 VAR_1 = context . get ( TYPE_1 . class ) ; <START> return VAR_1 . METHOD_2 ( context ) . toString ( ) + context . VAR_2 ( ) . METHOD_3 ( ) ; <END> } 
public TYPE_7 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = TYPE_2 . METHOD_1 ( ) <END> . METHOD_2 ( 5 , TimeUnit . VAR_4 ) . build ( new TYPE_3 < String , TYPE_5 . TYPE_6 . VAR_5 . VAR_2 . TYPE_8 > ( ) { @Override public TYPE_5 . TYPE_6 . VAR_5 . VAR_2 . TYPE_8 METHOD_3 ( String key ) throws Exception { return TYPE_7 . VAR_7 . VAR_2 . METHOD_4 ( key ) ; } } ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( state == VAR_1 ) return TYPE_1 . VAR_1 ; else if ( state == VAR_2 ) return TYPE_1 . VAR_2 ; <START> return null ; <END> } 
public TYPE_2 ( View VAR_2 ) { this . VAR_2 = VAR_2 ; TYPE_1 . METHOD_1 ( this , VAR_2 ) ; <START> VAR_2 . METHOD_2 ( this ) ; <END> } 
ANNOTATION_1 public TYPE_2 ( ANNOTATION_2 boolean VAR_2 , ANNOTATION_3 TYPE_1 VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
@Override protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; VAR_1 . add ( VAR_2 . METHOD_2 ( VAR_3 ) <START> . map ( new TYPE_1 ( ) ) , <END> VAR_4 ) ; VAR_2 . METHOD_3 ( VAR_5 . METHOD_4 ( VAR_6 . METHOD_5 ( ) ) ) ; } 
@Override public String toString ( ) { <START> return VAR_1 == null ? "" : STRING_1 + TYPE_1 . METHOD_1 ( VAR_1 ) ; <END> } 
protected boolean METHOD_1 ( TYPE_1 context ) { if ( filter == null ) return true ; <START> int i = 0 ; <END> TYPE_1 VAR_1 = context ; while ( i < VAR_2 ) { VAR_1 = VAR_1 . METHOD_2 ( ) ; i ++ ; } return filter . VAR_3 ( VAR_1 . METHOD_3 ( ) ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { super ( VAR_2 , VAR_3 ) ; <START> this . VAR_3 = VAR_3 ; <END> this . VAR_4 = VAR_4 ; } 
private boolean METHOD_1 ( TYPE_1 request ) { String VAR_1 = request . VAR_2 ( ) . METHOD_2 ( TYPE_2 . VAR_4 ) ; <START> if ( VAR_1 != null && VAR_1 . contains ( TYPE_3 . VAR_6 ) ) return true ; <END> else if ( request . VAR_7 ( ) . get ( STRING_1 ) != null && request . VAR_7 ( ) . get ( STRING_1 ) . equals ( TYPE_3 . VAR_6 ) ) return true ; else return false ; } 
public TYPE_7 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; VAR_3 = TYPE_2 . METHOD_1 ( ) . METHOD_2 ( 10 ) <START> . METHOD_3 ( 1 ) <END> . METHOD_4 ( INT_1 , TimeUnit . VAR_4 ) . build ( new TYPE_3 < TYPE_4 , TYPE_5 > ( ) { @Override public TYPE_5 METHOD_5 ( TYPE_4 key ) { TYPE_6 resource = VAR_2 . get ( key . VAR_5 ( ) , key . getPath ( ) ) ; TYPE_5 VAR_6 = new TYPE_5 ( resource ) ; return VAR_6 ; } } ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , double VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) == null && VAR_1 . METHOD_3 ( ) == null ) return true ; <START> if ( VAR_1 . METHOD_2 ( ) != null ) <END> if ( VAR_2 < VAR_1 . METHOD_2 ( ) ) return false ; if ( VAR_1 . METHOD_3 ( ) != null ) if ( VAR_2 > VAR_1 . METHOD_3 ( ) ) return false ; return true ; } 
protected String METHOD_1 ( String url , TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return url ; } File VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> File f = TYPE_2 . METHOD_4 ( TYPE_2 . METHOD_5 ( TYPE_3 . METHOD_6 ( VAR_2 ) , url ) , true ) ; <END> return f == null ? url : STRING_1 + TYPE_4 . METHOD_7 ( VAR_2 , f ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 response = METHOD_2 ( STRING_1 + STRING_2 ) ; <START> METHOD_3 ( response ) ; <END> METHOD_4 ( response ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { return new TYPE_1 < > ( <START> TYPE_3 . METHOD_1 ( ) . stream ( ) . collect ( Collectors . VAR_1 ( ) ) , <END> TYPE_2 . class , this , STRING_1 , null ) ; } 
<START> public static String toString ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> TYPE_3 VAR_2 = TYPE_3 . METHOD_1 ( ) ; TYPE_4 VAR_3 = VAR_2 . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( TYPE_8 . VAR_5 , STRING_1 ) ; TYPE_5 writer = new TYPE_5 ( ) ; VAR_3 . METHOD_4 ( new TYPE_6 ( VAR_1 ) , new TYPE_7 ( writer ) ) ; return writer . VAR_6 ( ) . toString ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 filter ) { try { TYPE_3 source = reader . VAR_1 ( reader . VAR_2 ( ) [ 0 ] , true ) ; TYPE_4 query = new TYPE_4 ( null , filter ) ; <START> if ( filter != null ) { <END> query . VAR_3 ( filter ) ; } TYPE_5 VAR_4 = source . VAR_1 ( query ) ; return VAR_4 . METHOD_1 ( ) ; } catch ( Exception exception ) { throw new RuntimeException ( STRING_1 , exception ) ; } } 
private static TYPE_1 METHOD_1 ( String s , Class VAR_1 ) throws TYPE_2 { if ( Date . VAR_2 . METHOD_2 ( VAR_1 ) ) { long VAR_3 = TYPE_3 . METHOD_3 ( s ) ; <START> return VAR_3 ; <END> } else { throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; } } 
public TYPE_2 ( String path ) { <START> this . path = TYPE_1 . METHOD_1 ( path ) ; <END> this . file = TYPE_1 . METHOD_2 ( VAR_2 , path ) ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { if ( VAR_1 == null ) { this . VAR_1 = new ArrayList < > ( ) ; } <START> this . VAR_1 = VAR_1 ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 + VAR_2 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 + STRING_7 + STRING_8 , TYPE_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <START> METHOD_5 ( VAR_1 ) ; <END> assertEquals ( STRING_9 , VAR_1 . METHOD_6 ( ) . METHOD_7 ( ) ) ; assertTrue ( VAR_1 . METHOD_6 ( ) . METHOD_8 ( ) . contains ( STRING_10 ) ) ; } 
public boolean METHOD_1 ( String VAR_1 ) { try { if ( logger . VAR_2 ( Level . VAR_3 ) ) { logger . log ( Level . VAR_3 , STRING_1 + VAR_1 + STRING_2 + VAR_4 . METHOD_2 ( ) + STRING_3 ) ; } return VAR_4 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) != null ; } catch ( IOException e ) { <START> logger . log ( Level . VAR_5 , STRING_4 + VAR_1 + STRING_5 , e ) ; <END> return false ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_1 . get ( ) ; int VAR_2 = 0 ; <START> while ( VAR_2 <= INT_1 && TYPE_1 . get ( ) . METHOD_2 ( ) . get ( VAR_3 ) == null ) { <END> Thread . VAR_4 ( 100 ) ; VAR_2 += 100 ; } assertThat ( VAR_1 . METHOD_2 ( ) . get ( VAR_3 ) , METHOD_3 ( ) ) ; assertThat ( VAR_1 . METHOD_4 ( VAR_3 ) , is ( true ) ) ; } 
public TYPE_3 ( TYPE_1 source , List < String > VAR_2 , List < Object > VAR_3 , List < Object > VAR_4 , TYPE_2 VAR_5 ) { super ( source , VAR_2 , VAR_3 , VAR_4 ) ; <START> this . VAR_5 = VAR_5 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { synchronized ( this ) { TYPE_2 VAR_2 = VAR_1 . get ( VAR_3 ) ; if ( TYPE_3 . exists ( VAR_2 ) ) { VAR_4 = new TYPE_4 ( VAR_2 ) ; <START> VAR_4 . METHOD_2 ( System . currentTimeMillis ( ) ) ; <END> } } } 
public List < TYPE_1 > METHOD_1 ( ) throws IOException { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; <START> TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( TYPE_2 . class ) ; <END> if ( VAR_2 != null ) { TYPE_1 f = METHOD_3 ( VAR_2 ) ; VAR_1 . add ( f ) ; } else if ( VAR_3 != null && VAR_3 . METHOD_4 ( ) != null ) { VAR_1 . add ( VAR_3 . METHOD_4 ( ) ) ; } return VAR_1 ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { VAR_1 . METHOD_2 ( ) ; System . VAR_2 ( STRING_1 , STRING_2 ) ; <START> System . VAR_2 ( STRING_3 , STRING_4 ) ; <END> File VAR_3 = VAR_1 . METHOD_3 ( ) ; File VAR_4 = new File ( VAR_3 , STRING_5 ) ; File VAR_5 = new File ( STRING_6 ) ; TYPE_2 . METHOD_4 ( VAR_5 , VAR_4 ) ; } 
public boolean METHOD_1 ( final String VAR_1 ) { METHOD_2 ( VAR_1 ) ; if ( STRING_1 . equalsIgnoreCase ( VAR_1 ) ) { return METHOD_3 ( ) ; } if ( STRING_2 . equalsIgnoreCase ( VAR_1 ) ) { <START> throw new TYPE_1 ( STRING_3 ) ; <END> } if ( STRING_4 . equalsIgnoreCase ( VAR_1 ) ) { return METHOD_4 ( ) ; } return true ; } 
public Optional < String > METHOD_1 ( ) { if ( VAR_1 . contains ( STRING_1 ) ) { <START> return version . VAR_2 ( System . getProperty ( STRING_2 ) ) ; <END> } else { return version . empty ( ) ; } } 
public void METHOD_1 ( ) { <START> METHOD_2 ( TYPE_1 . class , ( TYPE_2 VAR_1 , final TYPE_3 < TYPE_4 > VAR_2 ) - > { <END> if ( VAR_1 instanceof TYPE_1 ) { TYPE_1 VAR_3 = ( TYPE_1 ) VAR_1 ; VAR_3 . METHOD_3 ( ) ; } } ) ; METHOD_4 ( new TYPE_5 ( VAR_4 ) ) ; } 
public TYPE_1 value ( Object value ) { if ( value instanceof TYPE_5 . TYPE_6 . Date || value instanceof TYPE_3 ) { value = TYPE_4 . METHOD_1 ( value , String . VAR_1 ) ; } <START> if ( value instanceof Double ) { <END> value = METHOD_2 ( ( Double ) value ) ; } super . value ( value ) ; return this ; } 
void METHOD_1 ( TYPE_1 res , File file ) throws IOException { assert res . getType ( ) == Type . VAR_1 ; <START> TYPE_2 out = new TYPE_3 ( file ) ; <END> try { TYPE_4 in = res . in ( ) ; try { TYPE_5 . METHOD_2 ( in , out ) ; } finally { in . close ( ) ; } } finally { out . close ( ) ; } } 
public int METHOD_1 ( TYPE_1 query ) { <START> try ( TYPE_2 c = VAR_1 . METHOD_2 ( ) ) { <END> LOGGER . log ( Level . VAR_2 , query . toString ( ) ) ; TYPE_3 VAR_3 = query . VAR_4 ( c ) ; try { return VAR_3 . METHOD_3 ( ) ; } finally { VAR_3 . close ( ) ; } } catch ( TYPE_4 ex ) { throw new IllegalStateException ( STRING_1 , ex ) ; } } 
public void METHOD_1 ( String path ) throws Exception { TYPE_1 res = METHOD_2 ( path ) ; METHOD_3 ( res , is ( resource ( ) ) ) ; TYPE_2 result = res . in ( ) ; try { assertThat ( result , METHOD_4 ( ) ) ; } finally { <START> result . close ( ) ; <END> } } 
public TYPE_6 ( TYPE_1 path ) throws TYPE_2 , IOException { if ( ! TYPE_3 . exists ( path ) ) { throw new IllegalArgumentException ( STRING_1 + path + STRING_2 ) ; } this . path = path ; TYPE_4 in = path . in ( ) ; try { this . VAR_2 = TYPE_5 . toString ( in ) ; } finally { in . close ( ) ; <START> } <END> } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = METHOD_2 ( ) ; String VAR_2 = STRING_1 + STRING_2 + STRING_3 + VAR_1 + STRING_4 + STRING_5 + STRING_6 + STRING_7 + STRING_8 + STRING_9 + STRING_10 + STRING_11 + STRING_12 ; TYPE_1 VAR_3 = METHOD_3 ( STRING_13 , VAR_2 ) ; <START> METHOD_4 ( VAR_3 ) ; <END> assertEquals ( STRING_14 , VAR_3 . METHOD_5 ( ) . METHOD_6 ( ) ) ; METHOD_7 ( STRING_15 , STRING_16 , VAR_3 ) ; METHOD_7 ( STRING_17 , STRING_18 , VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( ) throws IOException { TYPE_2 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == null || ! TYPE_3 . exists ( VAR_1 ) ) { return null ; } TYPE_4 is = VAR_1 . in ( ) ; String VAR_2 = TYPE_5 . toString ( is ) ; <START> is . close ( ) ; <END> try { return TYPE_6 . METHOD_3 ( VAR_2 ) ; } catch ( Exception e ) { throw ( IOException ) new IOException ( ) . METHOD_4 ( e ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { if ( VAR_1 . getName ( ) == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } TYPE_2 file = METHOD_2 ( VAR_1 . getName ( ) ) ; TYPE_3 VAR_2 = null ; try { VAR_2 = file . out ( ) ; VAR_3 . METHOD_3 ( VAR_1 , VAR_2 ) ; } finally { <START> TYPE_4 . METHOD_4 ( VAR_2 ) ; <END> } VAR_4 . put ( VAR_1 , file ) ; } 
public static ANNOTATION_1 TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { TYPE_3 f = VAR_1 . get ( STRING_1 ) ; if ( f != null ) { TYPE_4 VAR_2 = new TYPE_5 ( ) . METHOD_2 ( ) ; <START> TYPE_6 in = new TYPE_6 ( f . in ( ) ) ; <END> try { TYPE_1 VAR_3 = VAR_2 . METHOD_3 ( in , TYPE_1 . class ) ; return VAR_3 ; } finally { in . close ( ) ; } } else { return null ; } } 
public void METHOD_1 ( ) throws IOException { METHOD_2 ( ) ; <START> TYPE_1 VAR_1 = METHOD_3 ( ) . out ( ) ; <END> char [ ] VAR_2 = VAR_3 . METHOD_4 ( ) ; try { VAR_4 . METHOD_5 ( VAR_1 , VAR_2 ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } finally { VAR_3 . METHOD_6 ( VAR_2 ) ; } VAR_1 . close ( ) ; } 
public boolean METHOD_1 ( TYPE_1 event ) throws Exception { <START> TYPE_2 VAR_1 = null ; <END> try { VAR_1 = event . getPath ( ) . out ( ) ; VAR_2 . METHOD_2 ( event . VAR_3 ( ) , VAR_1 ) ; return true ; } catch ( IllegalStateException e ) { if ( LOGGER . VAR_4 ( VAR_5 . VAR_6 . VAR_7 . Level . VAR_8 ) ) LOGGER . VAR_9 ( e . VAR_10 ( ) ) ; throw e ; } finally { TYPE_3 . METHOD_3 ( VAR_1 ) ; } } 
public String METHOD_1 ( Object object , int index ) { switch ( ( TYPE_1 ) object ) { case VAR_1 : <START> return STRING_1 ; <END> case VAR_2 : return STRING_2 ; case VAR_3 : return STRING_3 ; case VAR_4 : return STRING_4 ; case VAR_5 : return STRING_5 ; default : return "" ; } } 
<START> private TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; if ( VAR_1 == null ) { TYPE_3 VAR_2 = TYPE_2 . METHOD_2 ( TYPE_3 . class ) ; VAR_1 = new TYPE_4 ( INT_1 ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_3 ( ( TYPE_5 ) VAR_1 ) ; } else { LOGGER . VAR_3 ( STRING_1 ) ; } } return VAR_1 ; } 
public synchronized void METHOD_1 ( File file , String path , TYPE_1 listener ) { if ( VAR_1 == null ) { <START> TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( TYPE_2 . class ) ; <END> VAR_1 = new TYPE_4 ( ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_3 ( VAR_1 ) ; } else { LOGGER . VAR_3 ( STRING_1 ) ; } } VAR_1 . METHOD_1 ( file , path , listener ) ; } 
public TYPE_5 ( ) { <START> TYPE_1 VAR_2 = ( TYPE_1 ) TYPE_2 . METHOD_1 ( STRING_1 ) ; <END> TYPE_3 VAR_3 = VAR_2 . get ( VAR_4 ) ; VAR_5 = new TYPE_4 ( VAR_3 ) ; } 
TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException { File file = new File ( VAR_1 ) ; TYPE_1 resource ; <START> if ( file . VAR_2 ( ) ) { <END> if ( file . VAR_3 ( ) ) { return TYPE_2 . METHOD_2 ( file ) ; } else { throw new IOException ( STRING_1 + file . VAR_4 ( ) ) ; } } return null ; } 
private static void METHOD_1 ( TYPE_1 . Builder builder ) { builder . VAR_1 ( TYPE_5 . VAR_3 , TYPE_2 . instance ( ) , ( TYPE_3 ) ( name , VAR_4 , parent , VAR_5 , VAR_6 , metadata ) <START> - > new TYPE_4 ( name , VAR_4 , parent , VAR_5 , VAR_6 , metadata ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 , List < String > VAR_2 ) { if ( this . VAR_3 != ( ( TYPE_2 ) VAR_1 ) . VAR_3 ) { VAR_2 . add ( STRING_1 + name ( ) + STRING_2 ) ; } if ( TYPE_3 . equals ( this . VAR_4 , ( ( TYPE_2 ) VAR_1 ) . VAR_4 ) == false ) { VAR_2 . add ( STRING_1 + name ( ) + STRING_3 ) ; <START> } <END> this . VAR_5 = ( ( TYPE_2 ) VAR_1 ) . VAR_5 ; } 
public TYPE_3 ( TYPE_1 in ) throws IOException { VAR_2 = in . VAR_3 ( ) ; VAR_4 = in . VAR_5 ( ) ; <START> if ( in . VAR_6 ( ) . METHOD_1 ( TYPE_2 . VAR_8 ) ) { <END> VAR_9 = in . VAR_3 ( ) ; } else { VAR_9 = VAR_2 ; } } 
public void METHOD_1 ( TYPE_1 out ) throws IOException { out . VAR_1 ( VAR_2 ) ; out . VAR_3 ( VAR_4 ) ; <START> if ( out . VAR_5 ( ) . METHOD_2 ( TYPE_2 . VAR_7 ) ) { <END> out . VAR_1 ( VAR_8 ) ; } } 
public void METHOD_1 ( ) { assertEquals ( STRING_1 , error ( STRING_2 ) ) ; <START> assertEquals ( STRING_3 , error ( STRING_4 ) ) ; <END> } 
<START> protected Object METHOD_1 ( Object value ) { <END> return value . toString ( ) ; } 
public void METHOD_1 ( final int VAR_1 ) { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( new TYPE_2 ( ) { @Override public void run ( ) { if ( VAR_2 . METHOD_4 ( ) >= 100 ) { VAR_2 . METHOD_5 ( 0 ) ; System . out . println ( STRING_1 ) ; } else { VAR_2 . METHOD_5 ( VAR_2 . METHOD_4 ( ) + VAR_1 ) ; <START> System . out . println ( STRING_2 + VAR_2 . METHOD_4 ( ) + VAR_1 ) ; <END> } } } ) ; } 
public TYPE_1 < T > METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { <START> return METHOD_2 ( new Path ( VAR_1 ) , VAR_2 , VAR_3 , TYPE_2 . METHOD_3 ( ) ) ; <END> } 
public boolean METHOD_1 ( int VAR_1 , TYPE_1 value ) { if ( value . getValue ( ) > 3 ) { return true ; } <START> else <END> return false ; } 
public static final int METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , int VAR_3 , int VAR_4 , int VAR_5 ) { final byte [ ] VAR_6 = VAR_1 . VAR_7 ; final byte [ ] VAR_8 = VAR_2 . VAR_7 ; int val = 0 ; for ( int VAR_9 = 0 ; VAR_9 < VAR_5 && ( val = ( VAR_6 [ VAR_3 + VAR_9 ] & INT_1 ) - ( VAR_8 [ VAR_4 + VAR_9 ] & INT_1 ) ) == 0 ; VAR_9 ++ ) { <START> ; <END> } return val ; } 
public static void METHOD_1 ( Object o , TYPE_1 config , String key ) throws IOException { TYPE_2 VAR_1 = new TYPE_2 ( ) ; TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 ) ; VAR_2 . METHOD_2 ( o ) ; byte [ ] VAR_3 = VAR_1 . METHOD_3 ( ) ; config . VAR_4 ( key , VAR_3 ) ; <START> VAR_2 . close ( ) ; <END> } 
public int METHOD_1 ( TYPE_1 o ) { <START> return ( new Long ( offset ) ) . METHOD_1 ( o . VAR_1 ( ) ) ; <END> } 
public Path METHOD_1 ( ) { <START> return new Path ( METHOD_2 ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_2 ( STRING_1 ) ; <END> VAR_1 . METHOD_3 ( STRING_1 ) ; VAR_1 . METHOD_4 ( STRING_2 ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_5 ( STRING_3 ) ; VAR_3 . METHOD_6 ( VAR_1 , VAR_2 ) ; } 
public static String METHOD_1 ( final String VAR_1 ) { final String VAR_2 = TYPE_1 . getProperty ( STRING_1 , VAR_1 ) ; <START> if ( VAR_2 . equals ( STRING_2 ) ) return STRING_3 ; <END> return VAR_2 ; } 
public TYPE_1 build ( ) { <START> return new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; <END> } 
private static TYPE_1 < TYPE_2 > METHOD_1 ( ) { return new TYPE_1 < TYPE_2 > ( ) { @Override public boolean apply ( TYPE_2 input ) { TYPE_3 VAR_1 = input . VAR_2 ( ) ; <START> if ( VAR_1 == null ) { <END> return false ; } return TYPE_5 . TYPE_6 . equals ( VAR_1 . METHOD_2 ( ) ) ; } } ; } 
public String METHOD_1 ( TYPE_1 item , TYPE_2 version ) { String VAR_1 = VAR_2 . METHOD_1 ( item , version ) ; Optional < String > value = VAR_3 . METHOD_2 ( version . VAR_4 ( ) ) ; if ( ! value . isPresent ( ) || ! VAR_1 . equals ( value . get ( ) ) ) { <START> VAR_3 . METHOD_3 ( version . VAR_4 ( ) , VAR_1 ) ; <END> } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( Optional . VAR_3 ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_4 ) ) ; VAR_2 . METHOD_5 ( Optional . VAR_3 ( VAR_1 . METHOD_6 ( ) ) . METHOD_4 ( VAR_5 ) ) ; TYPE_3 VAR_6 = new TYPE_3 ( ) ; <START> VAR_6 . METHOD_7 ( TYPE_4 . METHOD_8 ( VAR_1 . METHOD_9 ( ) , VAR_7 ) ) ; <END> VAR_2 . METHOD_10 ( ) . add ( VAR_6 ) ; return VAR_2 ; } 
<START> private TYPE_1 < TYPE_2 , TYPE_3 < TYPE_4 > > METHOD_1 ( ) { <END> return new TYPE_1 < TYPE_2 , TYPE_3 < TYPE_4 > > ( ) { @Override public TYPE_3 < TYPE_4 > apply ( TYPE_2 input ) { return input . VAR_1 ( ) ; } } ; } 
protected void METHOD_1 ( View view ) { TYPE_1 VAR_1 = ( TYPE_1 ) view . VAR_2 ( R . id . VAR_3 ) ; VAR_1 . METHOD_2 ( ( int ) ( METHOD_3 ( TYPE_2 . VAR_5 ) * 100 ) ) ; VAR_1 . METHOD_4 ( this ) ; <START> super . METHOD_1 ( view ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_1 ( ) ; <END> } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( ( METHOD_2 ( ) . METHOD_3 ( ) & TYPE_2 . VAR_2 ) == 0 && <START> METHOD_2 ( ) . METHOD_4 ( ) == TYPE_1 ) { <END> Log . d ( TAG , STRING_1 ) ; METHOD_5 ( ) ; } VAR_3 = VAR_4 && VAR_3 ; } 
public TYPE_1 ( String VAR_2 ) { <START> METHOD_1 ( VAR_2 ) ; this . VAR_2 = VAR_2 ; <END> } 
<START> protected String METHOD_1 ( ) { return VAR_1 ; } <END> 
<START> protected void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( ! VAR_1 . METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( ) ; } } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof TYPE_1 ) ) return false ; TYPE_1 VAR_1 = ( TYPE_1 ) o ; if ( ! TYPE_2 . equals ( VAR_2 , VAR_1 . VAR_2 ) ) return false ; <START> return TYPE_2 . equals ( VAR_3 , VAR_1 . VAR_3 ) ; <END> } 
public Builder METHOD_1 ( Map < String , String > options ) { <START> options . forEach ( ( key , value ) - > METHOD_2 ( key , value ) ) ; <END> return this ; } 
public static String METHOD_1 ( String path ) { Path p = new Path ( path ) ; if ( p . VAR_1 ( ) . METHOD_2 ( ) == null ) { throw new IllegalArgumentException ( STRING_1 + path ) ; } <START> return path ; <END> } 
public static void METHOD_1 ( TYPE_1 context ) throws Exception { try { METHOD_2 ( TYPE_3 . TYPE_4 . VAR_3 , context ) ; } catch ( TYPE_2 ex ) { <START> } <END> System . out . println ( ) ; METHOD_2 ( TYPE_3 . TYPE_4 . VAR_4 , context ) ; System . out . println ( ) ; METHOD_2 ( TYPE_3 . TYPE_4 . VAR_5 , context ) ; } 
public TYPE_2 ( byte [ ] buf , int VAR_2 ) { <START> TYPE_1 . METHOD_1 ( buf , STRING_1 ) ; this . buffer = buf ; <END> this . VAR_3 = 0 ; this . max = VAR_2 ; } 
Collection < String > METHOD_1 ( List < Path > VAR_1 ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 , input - > input . getName ( ) ) ; <END> } 
private static boolean METHOD_1 ( byte [ ] params ) { <START> byte [ ] VAR_1 = TYPE_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ; <END> return Arrays . equals ( params , VAR_1 ) ; } 
String METHOD_1 ( TYPE_1 req ) { final String VAR_1 = METHOD_2 ( req , STRING_1 , null ) ; <START> return TYPE_2 . matcher ( VAR_1 ) . METHOD_3 ( ) ? VAR_1 : null ; <END> } 
protected void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; try { long VAR_2 = System . currentTimeMillis ( ) ; if ( ( VAR_3 + VAR_4 ) < VAR_2 ) { VAR_5 = METHOD_3 ( ) ; VAR_3 = VAR_2 ; } <START> METHOD_4 ( ) ; <END> } finally { VAR_1 . METHOD_5 ( ) ; } } 
TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; <START> this . count = new TYPE_3 ( 1 ) ; <END> this . VAR_3 = VAR_3 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_2 ( VAR_1 . VAR_3 , ( key , value ) - > { <START> TYPE_2 . METHOD_3 ( value ) ; <END> TYPE_3 . METHOD_4 ( value . count . METHOD_5 ( ) > 0 ) ; final int VAR_4 = value . count . METHOD_6 ( ) ; return ( VAR_4 > 0 ) ? value : null ; } ) ; } 
public static boolean METHOD_1 ( String key ) { return VAR_1 . contains ( key ) <START> && METHOD_2 ( key ) . getType ( ) . equals ( TYPE_1 . VAR_3 ) ; <END> } 
public String METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . VAR_2 = VAR_2 ; <START> return TYPE_2 . METHOD_1 ( VAR_1 ) . METHOD_2 ( STRING_1 , STRING_2 ) ; <END> } 
public String getMessage ( ) { StringBuilder message = new StringBuilder ( ) ; message . append ( STRING_1 ) . append ( VAR_1 ) ; message . append ( STRING_2 ) . append ( user ) ; <START> if ( ! VAR_2 . isEmpty ( ) ) { <END> message . append ( STRING_3 ) . append ( VAR_2 ) ; } message . append ( STRING_4 ) . append ( super . getMessage ( ) ) ; return message . toString ( ) ; } 
VAR_1 ( ANNOTATION_1 ( STRING_1 ) ANNOTATION_2 ( VAR_2 = VAR_3 ) String table ) { Map < String , Object > model = METHOD_1 ( ) ; model . put ( STRING_2 , STRING_3 ) ; model . put ( STRING_4 , STRING_5 ) ; model . put ( STRING_6 , STRING_7 ) ; <START> if ( ! table . VAR_4 ( ) ) { <END> model . put ( STRING_1 , table ) ; } return model ; } 
public TYPE_5 . TYPE_6 METHOD_1 ( TYPE_5 . TYPE_7 VAR_1 , long VAR_2 ) { TYPE_3 . METHOD_2 ( VAR_3 , STRING_1 ) ; <START> TYPE_4 VAR_4 = new TYPE_4 ( Long . toString ( VAR_2 ) . METHOD_3 ( ) ) ; <END> VAR_5 . put ( TYPE_9 . TYPE_8 . VAR_8 , VAR_1 . METHOD_4 ( ) , VAR_4 ) ; return this ; } 
public TYPE_1 build ( ) { return new TYPE_1 ( VAR_1 , VAR_2 , <START> Collections . VAR_3 ( VAR_4 ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 < String , String > VAR_1 = new TYPE_2 < > ( ) ; VAR_1 . put ( STRING_1 , STRING_2 ) ; VAR_1 . put ( STRING_3 , STRING_4 ) ; VAR_1 . put ( STRING_5 , STRING_6 ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; TYPE_1 < String , String > VAR_3 = VAR_2 . METHOD_3 ( ) ; <START> assertEquals ( VAR_3 . toString ( ) , VAR_1 . toString ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = super . METHOD_1 ( ) ; VAR_2 = new TYPE_2 ( STRING_1 , STRING_2 , true , STRING_3 ) ; VAR_3 = new TYPE_2 ( STRING_4 , STRING_5 , false , STRING_6 ) ; <START> VAR_4 = new TYPE_2 ( STRING_7 , STRING_8 , true , <END> STRING_9 ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_2 ( VAR_4 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) { throw new IllegalStateException ( STRING_1 ) ; } VAR_1 ++ ; <START> VAR_2 = false ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { try { return ( TYPE_1 ) VAR_2 . get ( VAR_1 ) ; } catch ( IllegalArgumentException | TYPE_3 e ) { <START> throw new RuntimeException ( e ) ; <END> } } 
public void close ( ) { try { for ( TYPE_1 source : VAR_1 . in . METHOD_1 ( ) ) { source . VAR_2 ( ) . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } try { if ( this . VAR_3 != null ) { this . VAR_3 . METHOD_2 ( ) ; } <START> } catch ( RuntimeException VAR_4 ) { <END> throw new RuntimeException ( VAR_4 ) ; } } 
public void close ( ) { try { for ( TYPE_1 source : VAR_1 . in . METHOD_1 ( ) ) { source . VAR_2 ( ) . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } try { if ( this . VAR_3 != null ) { this . VAR_3 . METHOD_2 ( ) ; } } catch ( TYPE_2 VAR_4 ) { <START> throw new TYPE_2 ( VAR_4 ) ; <END> } } 
public void METHOD_1 ( ) { byte [ ] VAR_1 = { INT_1 , INT_2 } ; byte [ ] VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_1 , TYPE_1 . METHOD_4 ( VAR_2 ) ) ; byte [ ] VAR_3 = { INT_3 , INT_3 , INT_3 } ; METHOD_3 ( VAR_3 , TYPE_1 . METHOD_4 ( VAR_3 ) ) ; exception . VAR_4 ( IllegalArgumentException . VAR_5 ) ; byte [ ] VAR_6 = { INT_2 } ; <START> METHOD_3 ( VAR_6 , TYPE_1 . METHOD_4 ( VAR_6 ) ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 c , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws TYPE_4 { String VAR_3 = METHOD_2 ( VAR_1 ) ; try { boolean result = super . METHOD_1 ( c , VAR_1 , VAR_2 ) ; <START> METHOD_3 ( c , result , VAR_4 , VAR_3 ) ; <END> return result ; } catch ( TYPE_4 ex ) { METHOD_3 ( c , ex , VAR_4 , VAR_3 ) ; throw ex ; } } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( VAR_1 . METHOD_1 ( ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { try ( TYPE_1 client = METHOD_2 ( ) ) { VAR_1 = STRING_1 ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_3 ( TYPE_3 . VAR_4 ) ; client . VAR_5 ( ) . create ( VAR_1 , VAR_2 ) ; <START> VAR_6 = METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ; <END> VAR_7 = METHOD_4 ( ) . METHOD_7 ( ) ; VAR_8 = cluster . VAR_9 ( ) . toString ( ) ; METHOD_8 ( client , false , true ) ; } } 
public TYPE_4 . TYPE_5 < T > METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; this . VAR_2 . put ( VAR_1 . getName ( ) , VAR_1 ) ; <START> VAR_3 . get ( VAR_4 ) . METHOD_3 ( new ArrayList < > ( this . VAR_2 . values ( ) ) ) ; <END> return this ; } 
public T build ( ) { <START> return VAR_1 . build ( this ) ; <END> } 
public TYPE_4 . TYPE_5 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; return this ; } 
public Collection < TYPE_1 > METHOD_1 ( ) { <START> return VAR_1 . entrySet ( ) . stream ( ) . map ( Map . Entry : : getValue ) . collect ( Collectors . VAR_2 ( ) ) ; <END> } 
private void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( ! VAR_1 , STRING_1 ) ; <END> } 
public boolean METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) throws TYPE_2 , TYPE_3 { try { <START> if ( ! exists ( VAR_1 ) ) { <END> create ( VAR_1 , VAR_2 ) ; return true ; } else { return false ; } } catch ( TYPE_4 e ) { throw new TYPE_5 ( e ) ; } } 
public synchronized String METHOD_1 ( ) { if ( VAR_1 == null ) { <START> TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( ) ; <END> VAR_1 = VAR_2 . METHOD_3 ( ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( String user , String VAR_1 ) throws TYPE_2 , TYPE_3 { <START> return ( TYPE_1 ) VAR_2 . METHOD_2 ( user , new TYPE_4 ( VAR_1 ) ) ; <END> } 
private static TYPE_1 METHOD_1 ( File f ) { try { return f . VAR_1 ( ) . METHOD_1 ( ) ; } catch ( TYPE_2 e ) { <START> throw new IllegalStateException ( e ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ) ; TYPE_1 VAR_1 = TYPE_1 . getInstance ( ) ; <START> VAR_1 . set ( TYPE_4 . VAR_3 , TYPE_2 . class . getName ( ) ) ; <END> VAR_1 . set ( STRING_1 , STRING_2 ) ; VAR_1 . set ( STRING_3 , STRING_4 ) ; TYPE_3 . METHOD_3 ( ) ; } 
public TYPE_6 ( TYPE_4 . TYPE_5 VAR_2 , TYPE_2 context ) { this . VAR_3 = TYPE_7 . VAR_5 ; <START> this . context = context ; <END> this . VAR_2 = TYPE_3 . METHOD_1 ( VAR_2 ) ; VAR_6 = null ; } 
synchronized public TYPE_1 getInstance ( ) { if ( VAR_1 == null ) { if ( VAR_2 ) { <START> VAR_1 = TYPE_2 . METHOD_1 ( instance ) ; <END> } else { try { VAR_1 = METHOD_2 ( ) . getInstance ( ) ; } catch ( TYPE_3 | TYPE_4 e ) { throw new RuntimeException ( e ) ; } } } return VAR_1 ; } 
<START> public void METHOD_1 ( TYPE_1 options ) { <END> METHOD_2 ( options ) ; METHOD_3 ( options ) ; METHOD_4 ( options ) ; } 
private void put ( byte b [ ] , int length ) { buffer . VAR_1 ( length ) ; buffer . add ( b , 0 , length ) ; <START> VAR_2 += length + VAR_3 ; <END> } 
public long METHOD_1 ( ) { <START> return Math . max ( parent . VAR_1 ( ) , METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( ) ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( byte [ ] VAR_1 , int VAR_2 ) { <END> VAR_3 = VAR_1 ; VAR_4 = VAR_2 ; return this ; } 
int count ( String VAR_1 , TYPE_1 VAR_2 ) throws Exception { TYPE_2 s = VAR_2 . METHOD_1 ( VAR_1 , TYPE_4 . VAR_4 ) ; <START> s . close ( ) ; <END> return TYPE_3 . size ( s . iterator ( ) ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { <END> return METHOD_1 ( VAR_1 , TYPE_4 . METHOD_2 ( TYPE_5 . class ) ) ; } 
public String METHOD_1 ( TYPE_1 id ) { <START> return id . VAR_1 ( ) ; <END> } 
<START> private static void METHOD_1 ( byte [ ] VAR_1 , int i ) { <END> VAR_1 [ i ] ++ ; if ( VAR_1 [ i ] == 0 ) { if ( i != 0 ) { METHOD_1 ( VAR_1 , i - 1 ) ; } else return ; } } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { TYPE_2 conf = METHOD_2 ( VAR_1 ) ; byte [ ] VAR_2 = METHOD_3 ( conf , new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , INT_1 , INT_2 , INT_3 , INT_4 , 10 , INT_5 } ) ; Integer result = METHOD_4 ( conf , VAR_2 ) ; <START> assert ( result . equals ( 1 ) ) ; <END> } 
public static String get ( TYPE_1 VAR_1 ) { <START> if ( config . containsKey ( VAR_1 . getKey ( ) ) ) { <END> return config . get ( VAR_1 . getKey ( ) ) ; } return null ; } 
private String METHOD_1 ( ) { StringBuilder VAR_1 = new StringBuilder ( ) ; TYPE_1 VAR_2 = TYPE_1 . VAR_3 ; if ( TYPE_2 . getInstance ( ) . get ( VAR_2 ) . equals ( VAR_2 . METHOD_2 ( ) ) ) VAR_1 . append ( STRING_1 ) ; else VAR_1 . append ( STRING_2 ) ; <START> return VAR_1 . toString ( ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 , int VAR_3 ) throws IOException { this ( VAR_2 , VAR_3 , ( int ) TYPE_2 . getInstance ( ) . METHOD_1 ( TYPE_3 . VAR_5 ) , null , null ) ; long VAR_6 = TYPE_2 . getInstance ( ) . METHOD_1 ( TYPE_3 . VAR_5 ) ; <START> if ( VAR_6 > Integer . VAR_7 || VAR_6 < 0 ) { <END> throw new IllegalArgumentException ( STRING_1 + Integer . VAR_7 ) ; } } 
public void write ( byte b [ ] , int VAR_1 , int VAR_2 ) throws IOException { count += VAR_2 ; if ( count > VAR_3 ) { throw new IOException ( STRING_1 + count + STRING_2 + VAR_3 + STRING_3 ) ; } <START> VAR_4 = VAR_5 . update ( b , VAR_1 , VAR_2 ) ; <END> if ( VAR_4 != null ) { output . write ( VAR_4 ) ; VAR_4 = null ; } } 
TYPE_4 ( TYPE_1 instance ) { this . instance = instance ; VAR_2 = TYPE_2 . METHOD_1 ( instance ) + Constants . VAR_3 + STRING_1 ; <START> VAR_4 = VAR_2 . length ( ) ; <END> VAR_5 = new TYPE_3 ( instance ) ; } 
public TYPE_1 ( ) { <START> VAR_2 = VAR_3 = VAR_4 = VAR_5 = VAR_6 = VAR_7 = INT_1 ; <END> } 
public Builder METHOD_1 ( String key , long value ) { <START> return METHOD_1 ( key , value + "" ) ; <END> } 
protected String METHOD_1 ( ) { try { return TYPE_1 . METHOD_1 ( VAR_1 , VAR_2 ) ; } catch ( TYPE_2 e ) { <START> return null ; <END> } } 
private boolean METHOD_1 ( ) throws IOException { if ( ! source . VAR_1 ( ) ) { source = source . VAR_2 ( ) ; try { if ( VAR_3 != null ) { VAR_3 . close ( ) ; } } catch ( Exception e ) { <START> throw new IOException ( e ) ; <END> } VAR_3 = source . iterator ( ) ; return true ; } return false ; } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 ) throw new IllegalStateException ( ) ; if ( ! METHOD_2 ( ) ) { VAR_1 = true ; try { if ( VAR_2 != null ) { VAR_2 . close ( ) ; } VAR_2 = null ; iterator ( ) ; } catch ( Exception e ) { <START> throw new RuntimeException ( e ) ; <END> } } return this ; } 
<START> public TYPE_1 ( byte row [ ] , int VAR_2 , int VAR_3 , byte VAR_4 [ ] , int VAR_5 , int VAR_6 , byte VAR_7 [ ] , int VAR_8 , int VAR_9 , byte VAR_10 [ ] , int VAR_11 , int VAR_12 , long VAR_13 , boolean VAR_14 , boolean VAR_15 ) { <END> METHOD_1 ( row , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 ) ; } 
public int METHOD_1 ( ) throws IOException { final TYPE_1 VAR_1 = in ; synchronized ( VAR_1 ) { <START> int VAR_2 = in . VAR_3 ( ) ; <END> if ( VAR_4 + VAR_2 > VAR_5 ) { VAR_2 = ( int ) ( VAR_5 - VAR_4 ) ; } return VAR_2 ; } } 
public int METHOD_1 ( ) throws IOException { final TYPE_1 VAR_1 = in ; synchronized ( VAR_1 ) { <START> int VAR_2 = VAR_1 . METHOD_1 ( ) ; <END> if ( VAR_3 + VAR_2 > VAR_4 ) { VAR_2 = ( int ) ( VAR_4 - VAR_3 ) ; } return VAR_2 ; } } 
public void METHOD_1 ( ) throws IOException { <START> if ( ! VAR_1 ) { <END> synchronized ( in ) { if ( ! VAR_1 ) { try { in . close ( ) ; } finally { VAR_1 = true ; if ( VAR_2 != null ) { try { VAR_3 . METHOD_2 ( VAR_2 ) ; } finally { VAR_2 = null ; } } } } } } } 
<START> public TYPE_1 ( ) throws IOException { } <END> 
static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_1 VAR_3 ) { if ( VAR_1 . METHOD_2 ( VAR_3 ) >= 0 ) { <START> TYPE_2 . METHOD_3 ( TYPE_3 . class ) . warn ( STRING_1 + VAR_1 + STRING_2 + VAR_3 ) ; <END> return null ; } if ( VAR_2 . METHOD_2 ( VAR_3 ) <= 0 ) { TYPE_2 . METHOD_3 ( TYPE_3 . class ) . warn ( STRING_1 + VAR_2 + STRING_3 + VAR_3 ) ; return null ; } return VAR_3 ; } 
private List METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> List < Integer > VAR_2 = new ArrayList < Integer > ( ) ; <END> for ( TYPE_1 m : VAR_1 ) { VAR_2 . add ( m . VAR_3 ( ) ) ; } return TYPE_2 . METHOD_2 ( VAR_2 ) . asList ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 conf ; <START> if ( VAR_1 . METHOD_2 ( ) || VAR_1 . METHOD_3 ( ) ) { <END> conf = VAR_2 . METHOD_4 ( TYPE_6 . VAR_4 ) ; } else { conf = VAR_2 . METHOD_4 ( TYPE_5 . VAR_4 ) ; } TYPE_1 VAR_6 = TYPE_4 . METHOD_5 ( conf . get ( TYPE_7 . VAR_8 ) ) ; return VAR_6 ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null ) { <START> if ( VAR_2 != null && ! new TYPE_2 ( VAR_2 ) . equals ( new TYPE_2 ( VAR_1 ) ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } return VAR_1 ; } return VAR_2 ; } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 config ) { if ( VAR_2 == TYPE_1 . VAR_3 ) throw new IllegalArgumentException ( STRING_1 ) ; this . VAR_2 = VAR_2 ; this . VAR_4 = null ; this . config = config ; this . VAR_5 = false ; this . VAR_6 = TYPE_6 . VAR_8 ; <START> this . VAR_9 = new ArrayList < TYPE_3 < TYPE_4 , TYPE_5 > > ( ) ; <END> } 
<START> protected static boolean METHOD_1 ( TYPE_1 context ) { <END> return TYPE_2 . METHOD_2 ( VAR_1 , context . VAR_2 ( ) ) ; } 
private List < String > METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( STRING_1 ) ; <END> TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; VAR_2 . METHOD_3 ( ) ; List < String > VAR_3 = new ArrayList < String > ( ) ; VAR_3 . addAll ( VAR_2 . METHOD_4 ( ) ) ; log . debug ( STRING_2 ) ; for ( String i : VAR_3 ) { log . debug ( STRING_3 + i ) ; } return VAR_3 ; } 
public static void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; <START> VAR_1 . METHOD_4 ( ) ; <END> new TYPE_3 ( new TYPE_4 ( ) , VAR_3 ) . METHOD_5 ( ) ; new TYPE_5 ( VAR_3 ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { new TYPE_2 ( ) . METHOD_2 ( STRING_1 ) . METHOD_3 ( ) ; <START> new TYPE_3 ( new TYPE_4 ( STRING_2 ) ) ; <END> new TYPE_5 ( STRING_2 ) ; return new TYPE_1 ( ) ; } 
public boolean METHOD_1 ( Object item ) { TYPE_1 VAR_1 = ( TYPE_1 ) item ; <START> for ( int i = 0 ; i < INT_1 ; i ++ ) { <END> if ( VAR_1 . METHOD_2 ( i ) . contains ( text ) ) { return true ; } } return false ; } 
public String toString ( ) { return STRING_1 + STRING_2 + id + STRING_3 + description + CHAR_1 + STRING_4 + VAR_1 + CHAR_1 + STRING_5 + VAR_2 + STRING_6 + VAR_3 . stream ( ) . map ( Arrays : : toString ) . collect ( Collectors . VAR_4 ( ) ) + <START> STRING_7 + VAR_5 + CHAR_1 + <END> STRING_8 + Arrays . toString ( VAR_6 ) + CHAR_1 + CHAR_2 ; } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; <START> return VAR_1 . equals ( that . VAR_1 ) && name . equals ( that . name ) ; <END> } 
public TYPE_4 ( ) { VAR_2 = VAR_3 ; <START> VAR_4 = TYPE_1 . METHOD_1 ( VAR_2 , TimeUnit . VAR_5 ) ; <END> VAR_6 = new TYPE_2 < > ( ) ; VAR_7 = TYPE_3 . VAR_9 ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 params ) { <START> METHOD_2 ( params ) ; <END> Map < String , String > map = METHOD_3 ( params ) ; METHOD_1 ( VAR_1 , map ) ; } 
<START> protected static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , String VAR_3 , TYPE_1 uri ) <END> throws TYPE_4 { TYPE_5 VAR_4 = new TYPE_5 ( 1 ) ; VAR_4 . add ( VAR_2 . data ( ) ) ; TYPE_6 VAR_5 = METHOD_2 ( VAR_1 ) ; return TYPE_7 . METHOD_3 ( uri , VAR_3 , VAR_4 , VAR_5 , VAR_1 . METHOD_4 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 , TYPE_3 uri , <START> TYPE_3 VAR_4 ) throws TYPE_4 <END> { TYPE_3 VAR_5 = TYPE_5 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , uri ) ; Assert . assertEquals ( VAR_5 . toString ( ) , VAR_4 . toString ( ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 token ) { VAR_1 = token ; <START> if ( VAR_1 == VAR_2 ) <END> { if ( VAR_3 > 0 ) { VAR_4 . METHOD_2 ( VAR_3 ) ; } VAR_3 = VAR_5 < < 1 ; } else if ( VAR_1 == VAR_6 ) { if ( VAR_3 > 0 ) { VAR_4 . METHOD_2 ( VAR_3 ) ; } VAR_3 = VAR_5 ; } else if ( VAR_1 != VAR_7 ) { VAR_3 -- ; } return VAR_1 ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) <END> { this ( VAR_2 , false ) ; } 
protected void METHOD_1 ( Object object , TYPE_1 VAR_1 ) throws IOException { try ( TYPE_3 . TYPE_4 VAR_2 = METHOD_2 ( VAR_1 ) ) { TYPE_3 . METHOD_3 ( object , VAR_2 ) ; <START> VAR_1 . METHOD_4 ( ) ; <END> } } 
public TYPE_4 ( TYPE_1 VAR_2 ) { for ( TYPE_2 VAR_3 : VAR_4 ) { TYPE_3 VAR_5 = new TYPE_3 ( VAR_3 ) ; <START> VAR_5 . METHOD_1 ( STRING_1 + VAR_3 . METHOD_2 ( ) ) ; <END> METHOD_3 ( VAR_5 ) ; } VAR_6 = VAR_2 ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> int VAR_4 = METHOD_2 ( VAR_5 . METHOD_3 ( ) ) ; <END> return VAR_6 . METHOD_4 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; } 
protected TYPE_5 . TYPE_6 METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 ) { <START> return VAR_2 ? new TYPE_3 ( VAR_1 ) : new TYPE_4 ( VAR_1 ) ; <END> } 
private static TYPE_1 METHOD_1 ( Class < ? > type ) { if ( type == TYPE_2 . class || type == TYPE_3 . class || type == TYPE_4 . class <START> || ( ! TYPE_5 . METHOD_2 ( type ) && TYPE_6 . METHOD_3 ( type ) ) ) <END> { return null ; } try { return TYPE_6 . METHOD_4 ( type ) ; } catch ( TYPE_7 e ) { return null ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) . METHOD_2 ( INT_1 , INT_2 , 4 ) . METHOD_3 ( INT_3 , INT_4 , INT_5 , 0 ) ; <START> try { <END> METHOD_4 ( STRING_1 , VAR_1 , STRING_2 ) ; } catch ( IOException e ) { Assert . VAR_2 ( STRING_3 ) ; } } 
public TYPE_1 ( String VAR_2 , Object [ ] args , Map < String , String > VAR_3 , List < String > VAR_4 ) { super ( ) ; <START> METHOD_1 ( VAR_2 , args , VAR_4 , VAR_3 ) ; <END> } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 != null ) { <END> return VAR_1 . METHOD_2 ( ) ; } return null ; } 
public void METHOD_1 ( ) throws IOException { Path VAR_1 = ( new File ( STRING_1 ) ) . METHOD_2 ( ) . METHOD_3 ( STRING_2 ) ; try { TYPE_1 VAR_2 = new TYPE_2 ( VAR_1 ) ; <START> } catch ( TYPE_3 e ) { <END> Assert . assertTrue ( true ) ; return ; } Assert . assertTrue ( STRING_3 , false ) ; } 
public void start ( TYPE_1 VAR_1 ) throws Exception { <START> if ( VAR_2 == null ) { <END> VAR_2 = TYPE_2 . getInstance ( ) ; } VAR_2 . METHOD_1 ( VAR_1 ) ; VAR_2 . start ( ) ; } 
<START> public TYPE_2 ( TYPE_1 model ) { <END> super ( model ) ; } 
public Boolean METHOD_1 ( String id ) { try { List < TYPE_1 > list = VAR_1 . METHOD_2 ( TYPE_2 . of ( Constants . VAR_2 , id ) ) ; <START> if ( list . isEmpty ( ) ) { <END> return false ; } return true ; } catch ( TYPE_3 e ) { throw new RuntimeException ( e ) ; } } 
public void METHOD_1 ( ) { <START> VAR_1 = TYPE_1 . getInstance ( null ) ; <END> VAR_2 = METHOD_2 ( TYPE_2 . class ) ; VAR_1 . METHOD_3 ( new TYPE_3 ( ) ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; } 
private Boolean METHOD_1 ( TYPE_1 event ) { if ( event . getType ( ) != TYPE_1 . VAR_1 && event . getType ( ) != TYPE_1 . VAR_2 ) { return false ; } String VAR_3 = event . VAR_4 ( ) . METHOD_2 ( ) ; <START> if ( VAR_3 . equals ( STRING_1 ) ) { <END> return false ; } if ( VAR_3 . equals ( STRING_2 ) ) { return false ; } return true ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( STRING_1 ) ; VAR_1 . METHOD_3 ( STRING_2 ) ; VAR_1 . METHOD_3 ( STRING_3 ) ; int i = 0 ; for ( TYPE_1 event : VAR_2 . METHOD_4 ( ) ) { VAR_1 . METHOD_5 ( STRING_4 + i + STRING_5 , event . getName ( ) ) ; i ++ ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( System . in , System . out , System . err ) ; VAR_2 . execute ( STRING_1 ) ; <START> METHOD_4 ( STRING_2 ) ; <END> VAR_2 . close ( ) ; } 
<START> static List < TYPE_1 > METHOD_1 ( Object ... value ) { <END> List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; for ( Object o : value ) { Class < ? > type = TYPE_2 . METHOD_2 ( o . getClass ( ) ) ; TYPE_1 VAR_2 = new TYPE_1 ( type . getName ( ) , o . toString ( ) ) ; VAR_1 . add ( VAR_2 ) ; } return VAR_1 ; } 
<START> static < T > Collection < T > METHOD_1 ( Collection < ? extends TYPE_1 > data ) { <END> return TYPE_2 . METHOD_2 ( data , new TYPE_3 < T > ( ) ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return TYPE_2 . METHOD_2 ( STRING_1 ) ; } 
<START> public void METHOD_1 ( ) throws <END> TYPE_1 , IOException , TYPE_2 { TYPE_3 VAR_1 = METHOD_2 ( ) ; TYPE_4 VAR_2 = new TYPE_4 ( ) ; String VAR_3 = VAR_2 . METHOD_3 ( VAR_1 ) ; TYPE_3 VAR_4 = VAR_2 . METHOD_4 ( VAR_3 ) ; METHOD_5 ( VAR_1 . METHOD_6 ( ) , VAR_4 . METHOD_6 ( ) ) ; } 
public < T > List < T > METHOD_1 ( Class < T > VAR_1 , String VAR_2 ) throws TYPE_1 { TYPE_2 filter = METHOD_2 ( VAR_1 , VAR_2 ) ; TYPE_3 VAR_3 = new TYPE_3 ( VAR_4 , filter , null ) ; return METHOD_3 ( VAR_3 ) ; <START> <END> } 
<START> public TYPE_1 METHOD_1 ( String value ) { <END> TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; when ( VAR_1 . getString ( METHOD_3 ( TYPE_2 . class ) ) ) . METHOD_4 ( value ) ; return VAR_1 ; } 
public static String METHOD_1 ( String s , int VAR_1 ) { s = s . trim ( ) ; <START> if ( s . length ( ) > INT_1 ) { <END> s = s . substring ( 0 , VAR_1 - 3 ) . trim ( ) + STRING_1 ; } return s ; } 
public static String METHOD_1 ( int n ) { String s = STRING_1 + ( n / 100 ) + STRING_2 ; <START> if ( ( ( n % 100 ) / 10 ) == 0 ) { <END> s += STRING_3 ; } s += ( n % 100 ) ; return s ; } 
void METHOD_1 ( ) { final TYPE_1 < TYPE_2 > VAR_1 = new TYPE_1 < > ( ) ; TYPE_3 builder = new TYPE_3 ( ) ; TYPE_4 VAR_2 = new TYPE_4 ( VAR_1 , "" , TYPE_5 . METHOD_2 ( ) ) ; String VAR_3 = VAR_2 . getProperty ( ) ; assertThat ( VAR_3 ) . isEmpty ( ) ; <START> } <END> 
void METHOD_1 ( ) { final TYPE_1 < TYPE_2 > VAR_1 = new TYPE_1 < > ( ) ; TYPE_3 builder = new TYPE_3 ( ) ; <START> TYPE_4 VAR_2 = new TYPE_4 ( VAR_1 , STRING_1 , TYPE_5 . METHOD_2 ( ) ) ; <END> String VAR_3 = VAR_2 . METHOD_3 ( "" ) ; assertThat ( VAR_3 ) . isEmpty ( ) ; } 
void METHOD_1 ( ) { final TYPE_1 < TYPE_2 > VAR_1 = new TYPE_1 < > ( ) ; TYPE_3 builder = new TYPE_3 ( ) ; TYPE_4 VAR_2 = new TYPE_4 ( VAR_1 , STRING_1 , TYPE_5 . METHOD_2 ( ) ) ; <START> METHOD_3 ( TYPE_6 . class , ( ) - > VAR_2 . METHOD_4 ( STRING_2 ) ) ; <END> } 
void METHOD_1 ( ) { <START> final TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> final String VAR_2 = VAR_1 . METHOD_2 ( new TYPE_2 ( ) , "" ) ; assertThat ( VAR_2 ) . isEmpty ( ) ; } 
void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; final TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . put ( VAR_3 , VAR_4 ) ; <START> final String VAR_5 = STRING_1 ; <END> final String VAR_6 = VAR_1 . METHOD_2 ( VAR_2 , VAR_5 ) ; final String VAR_7 = STRING_2 ; assertThat ( VAR_6 ) . METHOD_3 ( VAR_7 ) ; } 
void METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 , 0 , VAR_1 , VAR_2 , VAR_3 ) ; <END> METHOD_2 ( VAR_1 , 1 , VAR_2 , VAR_1 , VAR_3 ) ; METHOD_2 ( VAR_1 , 2 , VAR_3 , VAR_2 , VAR_1 ) ; } 
void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; assertThat ( VAR_1 . toString ( ) ) . METHOD_2 ( <START> STRING_2 ) ; <END> } 
<START> public TYPE_1 ( String VAR_2 ) { <END> this . VAR_2 = STRING_1 + VAR_2 + STRING_2 ; } 
public void METHOD_1 ( ) { <START> Set < TYPE_1 > VAR_1 = TYPE_2 . VAR_3 ; <END> assertThat ( VAR_4 . METHOD_2 ( ) , METHOD_3 ( VAR_1 ) ) ; } 
public String METHOD_1 ( ) { <START> return VAR_1 . get ( 0 ) ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_2 run ) { return Optional . VAR_1 ( run . get ( TYPE_4 . TYPE_1 . class . getName ( ) ) ) <START> . map ( s - > valueOf ( s ) ) <END> . METHOD_2 ( VAR_2 ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 run , TYPE_2 VAR_1 ) { run . set ( TYPE_4 . TYPE_2 . class . getName ( ) , VAR_1 . name ( ) ) ; <START> return run ; <END> } 
protected void METHOD_1 ( List < TYPE_1 > VAR_1 , String VAR_2 ) throws TYPE_2 { <START> METHOD_2 ( VAR_1 . iterator ( ) . next ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) , VAR_2 ) ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_2 configuration ) throws TYPE_3 { String target = METHOD_2 ( configuration ) ; <START> <END> TYPE_1 VAR_1 = TYPE_4 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( target ) ; return VAR_1 ; } 
private String METHOD_1 ( ) { if ( params . VAR_1 == null ) { return TYPE_1 . VAR_3 ; } <START> if ( params . VAR_1 . METHOD_2 ( CHAR_1 ) == - 1 ) { <END> return STRING_1 + params . VAR_1 ; } return params . VAR_1 ; } 
public void METHOD_1 ( boolean val ) { if ( VAR_1 . METHOD_2 ( ) ) VAR_1 . METHOD_3 ( ) . METHOD_4 ( val ) ; else VAR_1 . METHOD_5 ( ) . METHOD_4 ( val ) ; <START> } <END> 
boolean METHOD_1 ( ) throws IOException { <START> try { <END> VAR_1 . close ( ) ; } finally { } return true ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , int index ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; TYPE_3 column = null ; int VAR_4 = VAR_3 . METHOD_3 ( ) . size ( ) - 1 ; for ( int i = VAR_4 ; VAR_4 < index ; i ++ ) { column = VAR_3 . METHOD_4 ( ) ; column . VAR_5 ( i ) ; ++ VAR_4 ; <START> } <END> column = VAR_3 . METHOD_5 ( index ) ; column . VAR_6 ( VAR_2 ) ; } 
public static TYPE_1 METHOD_1 ( int VAR_1 , String VAR_2 , int VAR_3 , int VAR_4 , int VAR_5 , TYPE_2 version ) { TYPE_1 instance = new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , TYPE_4 . TYPE_3 , version ) ; <START> return instance ; <END> } 
<START> public void METHOD_1 ( int n ) { <END> int VAR_1 = METHOD_2 ( ) + n ; String msg = STRING_1 + METHOD_2 ( ) + STRING_2 + STRING_3 ; for ( TYPE_1 c : this ) { ( ( TYPE_2 ) c ) . METHOD_3 ( msg ) ; } METHOD_4 ( VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 url ) { <START> return url . VAR_1 ( ) . equals ( STRING_1 ) && url . VAR_2 ( ) . METHOD_2 ( STRING_2 ) ; <END> } 
public boolean METHOD_1 ( boolean VAR_1 ) { VAR_2 = VAR_1 ; <START> return VAR_1 ; <END> } 
public void METHOD_1 ( ) { Assert . VAR_1 ( VAR_2 , STRING_1 ) ; Assert . VAR_1 ( VAR_3 , STRING_2 ) ; Assert . VAR_1 ( VAR_4 , STRING_3 ) ; Assert . VAR_1 ( VAR_5 , STRING_4 ) ; <START> Assert . VAR_6 ( ! ( VAR_7 != null && VAR_8 != null ) , STRING_5 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ) { METHOD_3 ( VAR_2 , VAR_1 ) ; } else { <START> METHOD_4 ( VAR_2 , VAR_1 ) ; <END> } return this ; } 
public boolean METHOD_1 ( ) { <START> return TYPE_2 . TYPE_3 . equals ( getStatus ( ) ) ? true : false ; <END> } 
public void METHOD_1 ( ) { Assert . VAR_1 ( VAR_2 , STRING_1 ) ; TYPE_1 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_2 ( VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_4 ) ; VAR_3 . METHOD_4 ( VAR_5 ) ; VAR_3 . METHOD_5 ( VAR_6 ) ; VAR_3 . METHOD_1 ( ) ; this . VAR_7 = VAR_3 ; <START> } <END> 
public String METHOD_1 ( TYPE_1 request , TYPE_2 response ) { TYPE_3 VAR_1 = this . VAR_2 . METHOD_2 ( request ) ; <START> final boolean VAR_3 = VAR_1 == null ; <END> if ( VAR_3 ) { VAR_1 = this . VAR_2 . METHOD_3 ( request ) ; this . VAR_2 . METHOD_4 ( VAR_1 , request , response ) ; } return VAR_1 . METHOD_5 ( ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = null ; for ( TYPE_2 VAR_3 : METHOD_2 ( ) ) { <START> if ( VAR_3 . METHOD_3 ( ) . getName ( ) . equalsIgnoreCase ( VAR_1 ) || VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) . equalsIgnoreCase ( VAR_1 ) ) { <END> VAR_2 = VAR_3 ; break ; } } if ( VAR_2 != null ) { VAR_2 . METHOD_5 ( ) ; } else { throw new IllegalStateException ( STRING_1 ) ; } return this ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; Assert . VAR_3 ( TYPE_6 . TYPE_7 . VAR_4 . TYPE_2 . class , VAR_1 , STRING_2 + VAR_6 ) ; TYPE_8 . TYPE_9 . VAR_7 . VAR_8 . VAR_4 . TYPE_10 VAR_10 = new TYPE_8 . TYPE_9 . VAR_7 . VAR_8 . VAR_4 . TYPE_10 ( VAR_1 ) ; <START> return ( TYPE_1 ) TYPE_5 . METHOD_2 ( VAR_11 ) . METHOD_1 ( VAR_10 ) ; <END> } 
public void METHOD_1 ( boolean VAR_1 ) { VAR_2 = VAR_1 ; <START> METHOD_2 ( STRING_1 , VAR_2 ? STRING_2 : STRING_3 ) ; <END> } 
public static void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . get ( ) . METHOD_2 ( ) ; TYPE_3 . METHOD_3 ( VAR_1 ) ; for ( TYPE_5 . TYPE_6 type : TYPE_5 . TYPE_6 . values ( ) ) { System . out . println ( type ) ; <START> System . out . println ( type . toString ( ) ) ; <END> } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . VAR_2 . METHOD_2 ( TYPE_3 . VAR_4 ) . METHOD_3 ( ) instanceof TYPE_2 ) <END> VAR_1 . VAR_2 . VAR_5 = 0 ; } 
public List < TYPE_1 > METHOD_1 ( ANNOTATION_1 TYPE_2 state , ANNOTATION_1 TYPE_3 VAR_1 , long VAR_2 ) { <START> if ( VAR_1 == null ) return VAR_3 ; <END> return ImmutableList . of ( ) ; } 
public void update ( ) { if ( METHOD_1 ( ) ) { return ; } if ( ! METHOD_2 ( ) ) { if ( VAR_1 == 0 ) { METHOD_3 ( ) ; } } else { if ( VAR_1 % 4 == 0 ) { METHOD_4 ( ) ; <START> METHOD_5 ( ) ; <END> } if ( VAR_2 ) { METHOD_6 ( ) ; } } VAR_1 = ( VAR_1 + 1 ) % INT_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { <START> return new TYPE_5 ( ( TYPE_6 ) METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) , this ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 state , TYPE_3 target , TYPE_4 VAR_1 , TYPE_5 VAR_2 , TYPE_6 VAR_3 ) { <START> if ( VAR_4 ) { <END> return new TYPE_1 ( TYPE_7 . VAR_6 , 1 , TYPE_9 . TYPE_8 . VAR_9 . METHOD_2 ( ) ) ; } return null ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( ) ; VAR_1 = TYPE_2 . builder ( TYPE_1 . VAR_2 , TYPE_1 . VAR_3 , VAR_4 ) . METHOD_3 ( true ) . METHOD_4 ( null , TYPE_1 . VAR_5 ) . build ( ) ; <START> VAR_1 . METHOD_5 ( TYPE_3 . TYPE_4 . VAR_8 , new Long ( VAR_9 ) ) ; <END> VAR_1 . METHOD_6 ( ) ; } 
public static Object METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 instanceof TYPE_3 ) { TYPE_3 VAR_3 = ( TYPE_3 ) VAR_2 ; TYPE_4 value = VAR_3 . getValue ( ) ; if ( value instanceof TYPE_5 ) { return ( ( TYPE_5 ) value ) . METHOD_3 ( ) ; } else { try { <START> TYPE_3 . METHOD_4 ( VAR_3 ) ; <END> } catch ( Exception ex ) { } } } return null ; } 
<START> public synchronized void METHOD_1 ( ) { <END> VAR_1 = false ; } 
public boolean METHOD_1 ( boolean VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 != null ) { return VAR_1 && VAR_2 . METHOD_1 ( ) ; <START> } else { <END> return VAR_1 ; } } 
protected TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 ) ; <END> VAR_1 . METHOD_2 ( 10 * INT_1 * INT_2 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( VAR_2 ) ) { return ; } if ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) { VAR_1 . METHOD_3 ( ) . debug ( STRING_1 + VAR_1 . METHOD_5 ( ) ) ; } <START> METHOD_6 ( VAR_1 . METHOD_5 ( ) , ( ) - > METHOD_7 ( ) , VAR_3 ) ; <END> } 
public TYPE_1 ( String msg ) { <START> super ( STRING_1 + msg ) ; <END> } 
public void put ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , long VAR_3 , String VAR_4 ) { if ( TYPE_1 . TYPE_5 . equals ( VAR_1 ) ) { <START> VAR_5 . METHOD_1 ( new Pair < TYPE_2 , Long > ( VAR_2 , VAR_3 ) ) ; <END> return ; } if ( TYPE_1 . TYPE_6 . equals ( VAR_1 ) ) { VAR_6 . put ( VAR_4 , new Pair < TYPE_2 , Long > ( VAR_2 , VAR_3 ) ) ; return ; } return ; } 
private void METHOD_1 ( int VAR_1 , boolean VAR_2 ) { for ( int VAR_3 = 0 ; VAR_3 < VAR_1 ; VAR_3 ++ ) { <START> TYPE_1 VAR_4 = new TYPE_1 ( ) ; <END> int VAR_5 = VAR_6 . METHOD_2 ( ) + 1 ; int VAR_7 ; do { VAR_7 = VAR_4 . METHOD_3 ( VAR_5 ) ; } while ( ! VAR_6 . containsKey ( VAR_7 ) ) ; METHOD_4 ( VAR_7 , METHOD_5 ( ) , Math . VAR_8 ( VAR_4 . METHOD_6 ( ) ) , VAR_2 ) ; } } 
<START> public static TYPE_1 METHOD_1 ( final Context context ) { <END> return new TYPE_1 ( ) { public TYPE_2 create ( TYPE_3 cluster , TYPE_4 VAR_1 ) { return new TYPE_5 ( context , cluster , VAR_1 ) ; } } ; } 
public TYPE_2 ( TYPE_1 type ) { super ( type ) ; VAR_2 = STRING_1 ; <START> VAR_3 = STRING_2 ; <END> } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> return TYPE_1 . METHOD_2 ( Integer . parseInt ( VAR_1 ) ) ; } else { return false ; } } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = true ; TYPE_2 < TYPE_3 > VAR_3 = TYPE_4 . METHOD_2 ( VAR_1 ) ; if ( ! TYPE_4 . METHOD_3 ( VAR_3 ) ) { VAR_4 . info ( STRING_1 ) ; return ; } TYPE_5 VAR_5 = VAR_6 . get ( ) ; TYPE_6 . METHOD_4 ( VAR_5 != null , STRING_2 ) ; VAR_5 . METHOD_1 ( ) ; <START> METHOD_5 ( ) ; <END> } 
<START> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_1 VAR_2 , TYPE_1 VAR_3 , String VAR_4 ) { <END> return new TYPE_3 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) , VAR_2 , VAR_3 , VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_6 ( ) , VAR_1 . METHOD_7 ( ) , ImmutableList . VAR_5 ( VAR_1 . METHOD_8 ( ) ) , VAR_1 . METHOD_9 ( ) , VAR_4 ) ; } 
private int METHOD_1 ( Set < Integer > VAR_1 ) { <START> if ( this instanceof TYPE_1 ) { <END> return - 1 ; } List < TYPE_2 > VAR_2 = METHOD_2 ( ) ; for ( TYPE_2 VAR_3 : VAR_2 ) { assert ( VAR_3 instanceof TYPE_3 ) ; if ( VAR_1 . contains ( ( ( TYPE_3 ) VAR_3 ) . METHOD_3 ( ) ) ) { return ( ( TYPE_3 ) VAR_3 ) . METHOD_3 ( ) ; } } return - 1 ; } 
public void METHOD_1 ( TYPE_1 table , long VAR_1 ) { VAR_2 . execute ( new TYPE_2 ( ) { public void run ( ) { <START> if ( VAR_1 != VAR_3 ) { <END> assert ( VAR_1 > VAR_3 ) ; TYPE_3 VAR_4 = new TYPE_3 ( table , table . VAR_5 ( ) , VAR_1 ) ; try { VAR_6 . METHOD_2 ( VAR_4 ) ; } catch ( IOException e ) { TYPE_4 . METHOD_3 ( STRING_1 , true , e ) ; } VAR_3 = VAR_1 ; } } } ) ; } 
static void METHOD_1 ( ) throws IOException { <START> File f = new File ( STRING_1 + System . getProperty ( STRING_2 ) ) ; <END> TYPE_1 . METHOD_2 ( f ) ; f . VAR_1 ( ) ; } 
void METHOD_1 ( ) { VAR_1 = false ; if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( ) ; VAR_2 = null ; } if ( VAR_3 != null ) { VAR_3 . METHOD_2 ( ) ; VAR_3 = null ; } VAR_4 . METHOD_1 ( ) ; <START> VAR_4 . METHOD_1 ( ) ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 , ByteBuffer VAR_2 , ByteBuffer VAR_3 , int size , int VAR_4 ) { VAR_1 . update ( size ) ; VAR_1 . update ( VAR_4 ) ; VAR_1 . update ( VAR_3 ) ; VAR_2 . clear ( ) ; VAR_2 . METHOD_2 ( TYPE_2 . VAR_6 ) ; <START> VAR_2 . METHOD_3 ( VAR_1 . getValue ( ) ) ; <END> VAR_2 . METHOD_4 ( size ) ; VAR_2 . METHOD_4 ( VAR_4 ) ; VAR_2 . METHOD_2 ( TYPE_2 . VAR_7 ) ; } 
public static void METHOD_1 ( File file , boolean VAR_1 ) { try { TYPE_1 view = METHOD_2 ( file ) ; view . write ( VAR_2 , TYPE_2 . METHOD_3 ( ) . METHOD_4 ( new Boolean ( VAR_1 ) . toString ( ) ) ) ; <START> } catch ( Exception e ) { <END> } } 
<START> @Override void METHOD_1 ( TYPE_1 row ) throws IOException { <END> assert ( row . getString ( STRING_1 ) . equals ( METHOD_2 ( ) ) ) ; METHOD_3 ( row ) ; VAR_1 . add ( ( int ) row . VAR_2 ( STRING_2 ) ) ; } 
<START> TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> super ( VAR_2 , STRING_1 + VAR_3 . name ( ) ) ; VAR_4 = VAR_3 ; } 
public TYPE_1 METHOD_1 ( boolean value ) { value = VAR_1 . METHOD_2 ( ) == 1 && value ; <START> if ( VAR_2 ^ value ) { <END> VAR_2 = value ; METHOD_3 ( ) ; } return this ; } 
TYPE_1 ( int val ) { assert ( this . METHOD_1 ( ) == val ) : STRING_1 + this . name ( ) + STRING_2 + this . METHOD_1 ( ) + STRING_3 + val ; <START> VAR_2 = val ; <END> } 
public TYPE_8 ( TYPE_1 cluster , TYPE_2 VAR_2 , TYPE_3 input , TYPE_4 offset , TYPE_4 VAR_3 ) { super ( cluster , VAR_2 , input ) ; <START> assert TYPE_6 . TYPE_7 . equals ( METHOD_1 ( ) ) ; <END> VAR_4 = offset ; VAR_5 = VAR_3 ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 , boolean VAR_2 , boolean VAR_3 , TYPE_2 VAR_4 ) { TYPE_1 VAR_5 = null ; try { VAR_5 = VAR_6 . METHOD_2 ( TYPE_3 . VAR_8 , VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; assertNotNull ( VAR_5 ) ; } catch ( Exception ex ) { <START> METHOD_3 ( ex . getMessage ( ) ) ; <END> } return VAR_5 ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 parent , int i , TYPE_1 child ) { <START> child . VAR_1 ( this ) ; <END> parent . VAR_2 ( ) . METHOD_2 ( VAR_3 ) ; return parent ; } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 parent , String name , Class < T > VAR_3 , int VAR_4 ) { <END> VAR_5 = VAR_2 ; VAR_6 = parent ; VAR_7 = name ; VAR_8 = VAR_3 ; VAR_9 = VAR_4 ; if ( VAR_4 <= 3 ) { VAR_10 = getPath ( ) ; } } 
protected void METHOD_1 ( String name , boolean append ) throws TYPE_1 { File VAR_1 = new File ( VAR_2 ) ; if ( ! VAR_1 . exists ( ) ) { append = false ; } <START> TYPE_2 VAR_3 = new TYPE_2 ( new TYPE_3 ( new TYPE_4 ( VAR_1 , append ) ) ) ; <END> VAR_3 . METHOD_2 ( name ) ; VAR_3 . close ( ) ; } 
public Object getValue ( TYPE_1 session ) { if ( VAR_1 != TYPE_2 . VAR_3 ) { return super . getValue ( session ) ; } Object VAR_4 = VAR_5 [ VAR_6 ] . getValue ( session ) ; Object VAR_7 = VAR_5 [ VAR_8 ] . getValue ( session ) ; if ( VAR_9 . VAR_10 ) { <START> synchronized ( VAR_9 ) { <END> VAR_9 . METHOD_1 ( session , VAR_7 ) ; return VAR_9 . METHOD_2 ( session , VAR_4 ) ; } } return VAR_9 . METHOD_2 ( session , VAR_4 ) ; } 
public Object getValue ( TYPE_1 session ) { if ( VAR_1 != TYPE_2 . VAR_3 ) { return super . getValue ( session ) ; } Object VAR_4 = VAR_5 [ VAR_6 ] . getValue ( session ) ; Object VAR_7 = VAR_5 [ VAR_8 ] . getValue ( session ) ; if ( VAR_9 . VAR_10 ) { VAR_9 . METHOD_1 ( session , VAR_7 ) ; <START> return VAR_9 . METHOD_2 ( session , VAR_4 ) ; <END> } return VAR_9 . METHOD_2 ( session , VAR_4 ) ; } 
String METHOD_1 ( String VAR_1 ) { assert ( VAR_2 ) ; String VAR_3 = "" ; if ( VAR_4 ) { VAR_3 = STRING_1 + TYPE_1 . instance ( ) . METHOD_2 ( ) . METHOD_3 ( ) + STRING_2 ; } <START> return VAR_5 . getPath ( ) + File . VAR_6 + VAR_1 + VAR_7 + STRING_3 + VAR_8 . get ( ) . format ( start ) + VAR_3 ; <END> } 
void METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = 0 ; for ( TYPE_2 VAR_3 : VAR_4 ) { VAR_3 . METHOD_2 ( VAR_2 ) ; ++ VAR_2 ; Collection < TYPE_3 > VAR_5 = TYPE_4 . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ; for ( TYPE_3 VAR_6 : VAR_5 ) { VAR_6 . METHOD_5 ( VAR_1 ) ; <START> assert ( VAR_6 . METHOD_6 ( ) >= 0 || VAR_6 . METHOD_6 ( ) < VAR_1 . size ( ) ) ; <END> } } } 
public TYPE_1 METHOD_1 ( ) { <START> assert ( VAR_1 != null && VAR_1 instanceof TYPE_1 ) ; <END> return ( TYPE_1 ) VAR_1 ; } 
<START> private synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_2 ) return ; final TYPE_2 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_4 , VAR_3 ) ; Pair < TYPE_2 , TYPE_1 > VAR_5 = Pair . of ( VAR_3 , VAR_1 ) ; VAR_6 . add ( VAR_5 ) ; final TYPE_3 < TYPE_4 > VAR_7 = VAR_8 . METHOD_4 ( ) ; METHOD_5 ( VAR_8 , VAR_7 , VAR_3 ) ; } 
public void METHOD_1 ( ) { try { METHOD_2 ( ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; } } catch ( Exception ex ) { <START> VAR_2 . error ( STRING_1 , ex ) ; <END> } } 
public TYPE_1 < ? > METHOD_1 ( final boolean VAR_1 ) { <START> return VAR_2 . METHOD_2 ( new TYPE_2 ( ) { <END> @Override public void run ( ) { new TYPE_3 ( VAR_1 ) . run ( ) ; } } ) ; } 
<START> private synchronized void METHOD_1 ( long VAR_1 , Exception VAR_2 ) { <END> if ( VAR_1 == Long . VAR_3 && VAR_4 != null ) { if ( ! VAR_5 ) VAR_6 = true ; VAR_7 = new Exception ( STRING_1 + VAR_1 , VAR_2 ) ; VAR_4 . run ( ) ; return ; } if ( VAR_1 > 0 ) { try { METHOD_2 ( VAR_1 ) ; } catch ( IOException e ) { TYPE_1 . METHOD_3 ( STRING_2 , true , e ) ; return ; } } } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { String VAR_3 = VAR_2 . METHOD_2 ( ) ; <START> if ( "" . equals ( VAR_3 ) ) { <END> VAR_3 = STRING_1 ; } String VAR_4 = VAR_1 . METHOD_3 ( ) ; if ( ! VAR_3 . contains ( STRING_1 + VAR_4 + STRING_1 ) ) { VAR_3 += VAR_4 + STRING_1 ; VAR_2 . METHOD_4 ( VAR_3 ) ; } } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { String VAR_4 = VAR_1 . METHOD_2 ( ) ; <START> if ( "" . equals ( VAR_4 ) ) { <END> VAR_4 = STRING_1 ; } String VAR_5 = VAR_2 . METHOD_3 ( ) + STRING_2 + VAR_3 . METHOD_3 ( ) ; if ( ! VAR_4 . contains ( STRING_1 + VAR_5 + STRING_1 ) ) { VAR_4 = VAR_4 + VAR_5 + STRING_1 ; VAR_1 . METHOD_4 ( VAR_4 ) ; } } 
<START> public static void METHOD_1 ( ) { <END> for ( String name : TYPE_1 . VAR_1 ) { TYPE_1 VAR_2 = TYPE_1 . VAR_3 . get ( name ) ; TYPE_1 . VAR_3 . remove ( name ) ; VAR_4 . put ( name , VAR_2 ) ; } TYPE_1 . VAR_1 . clear ( ) ; } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> switch ( VAR_2 ) { case VAR_3 : VAR_4 . info ( STRING_1 ) ; close ( ) ; VAR_4 . info ( STRING_2 ) ; break ; case VAR_5 : VAR_4 . info ( STRING_3 ) ; METHOD_3 ( ) ; VAR_4 . info ( STRING_4 ) ; break ; default : break ; } } 
public TYPE_1 ( long VAR_2 , long VAR_3 , long VAR_4 , boolean VAR_5 , int VAR_6 , boolean VAR_7 , boolean VAR_8 , boolean VAR_9 , boolean VAR_10 ) { super ( VAR_2 , VAR_3 , VAR_4 , 0 , VAR_5 , VAR_10 ) ; VAR_11 = VAR_6 ; METHOD_1 ( VAR_12 , VAR_7 ) ; METHOD_1 ( VAR_13 , VAR_8 ) ; METHOD_1 ( VAR_14 , VAR_9 ) ; <START> VAR_15 = true ; <END> VAR_16 = false ; } 
private TYPE_1 METHOD_1 ( boolean VAR_1 , boolean VAR_2 , boolean VAR_3 ) { TYPE_1 msg = new TYPE_1 ( INT_1 , INT_1 , VAR_4 . METHOD_2 ( ) , VAR_1 , 0 , VAR_2 , false , VAR_3 , false ) ; <START> msg . VAR_5 ( false ) ; <END> return msg ; } 
public void close ( ) throws InterruptedException , TYPE_1 { while ( VAR_1 . get ( ) != VAR_2 . get ( ) ) { VAR_3 . METHOD_1 ( ) ; Thread . VAR_4 ( ) ; } <START> VAR_5 . METHOD_2 ( ) ; <END> VAR_5 . METHOD_3 ( INT_1 , TimeUnit . VAR_6 ) ; } 
public void METHOD_1 ( ) throws IOException , TYPE_1 , InterruptedException { <START> VAR_1 = STRING_1 ; <END> VAR_2 = STRING_2 ; if ( METHOD_2 ( ) || METHOD_3 ( ) ) { return ; } TYPE_2 client ; VAR_1 = STRING_1 ; VAR_2 = STRING_2 ; client = METHOD_4 ( ) ; METHOD_5 ( client , true ) ; VAR_1 = STRING_3 ; VAR_2 = STRING_2 ; client = METHOD_4 ( ) ; METHOD_5 ( client , false ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_1 > VAR_2 ) { <START> int VAR_3 = TYPE_4 . TYPE_5 . METHOD_2 ( ) ; <END> VAR_4 . add ( VAR_3 ) ; TYPE_3 VAR_5 = new TYPE_3 ( VAR_3 , VAR_1 ) ; VAR_2 . add ( VAR_5 ) ; } 
private void METHOD_1 ( TYPE_1 message ) { VAR_1 = message . VAR_2 ; METHOD_2 ( message . VAR_3 ( ) ) ; long VAR_4 = VAR_5 . METHOD_3 ( message . VAR_6 ( ) , message . VAR_7 ( ) ) ; TYPE_1 msg = new TYPE_1 ( VAR_8 . METHOD_4 ( ) , - 1 , VAR_4 ) ; VAR_8 . METHOD_5 ( VAR_1 , msg ) ; VAR_9 . METHOD_6 ( this ) ; <START> VAR_9 . METHOD_7 ( new TYPE_2 ( VAR_10 ) ) ; <END> TYPE_3 . info ( STRING_1 + VAR_10 + STRING_2 ) ; } 
private void METHOD_1 ( TYPE_1 message ) { VAR_1 = message . VAR_2 ; METHOD_2 ( message . VAR_3 ( ) ) ; long VAR_4 = VAR_5 . METHOD_3 ( message . VAR_6 ( ) , message . VAR_7 ( ) ) ; TYPE_1 msg = new TYPE_1 ( VAR_8 . METHOD_4 ( ) , - 1 , VAR_4 ) ; VAR_8 . METHOD_5 ( VAR_1 , msg ) ; <START> VAR_9 . METHOD_6 ( new TYPE_2 ( VAR_10 ) ) ; <END> VAR_9 . METHOD_7 ( this ) ; TYPE_3 . info ( STRING_1 + VAR_10 + STRING_2 ) ; } 
public String METHOD_1 ( TYPE_3 . TYPE_4 path ) { if ( METHOD_2 ( ) ) { return path . getPath ( ) ; } <START> try { <END> return VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ; } catch ( IOException e ) { throw new TYPE_2 ( STRING_1 ) ; } } 
static public TYPE_1 METHOD_1 ( ) throws IOException { TYPE_2 builder = new TYPE_2 ( TYPE_3 . class ) ; TYPE_4 project = METHOD_2 ( ) ; boolean VAR_1 ; TYPE_5 config = new TYPE_5 ( true , STRING_1 , 2 , 3 , 0 , TYPE_6 . VAR_3 ) ; VAR_1 = config . VAR_4 ( project ) ; assertTrue ( VAR_1 ) ; <START> <END> builder . VAR_5 ( config ) ; return builder ; } 
public boolean equals ( Object o ) { <START> if ( ! ( o instanceof TYPE_1 ) ) { <END> return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) o ; return VAR_2 . equals ( VAR_1 . VAR_2 ) && VAR_3 . equals ( VAR_1 . VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( ) ) { <START> debug ( null , STRING_1 + ( VAR_2 . trim ( ) . isEmpty ( ) ? STRING_2 : VAR_2 ) <END> + STRING_3 + VAR_1 . METHOD_3 ( ) . name ( ) ) ; } if ( TYPE_3 . TYPE_4 . equals ( VAR_1 . METHOD_3 ( ) ) ) { METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; } } 
void close ( ) { try { VAR_1 . close ( ) ; <START> } catch ( IOException e ) { } <END> } 
<START> public static int get ( String token ) { <END> int type = VAR_1 . get ( token , - 1 ) ; if ( type == - 1 ) { return VAR_2 . get ( token , - 1 ) ; } return type ; } 
public int METHOD_1 ( ) throws InterruptedException , TYPE_1 { <START> TYPE_3 . TYPE_4 VAR_1 = new TYPE_3 . TYPE_4 ( ) ; <END> return ByteBuffer . VAR_2 ( VAR_3 . METHOD_2 ( VAR_4 , VAR_1 , null ) ) . getInt ( ) ; } 
TYPE_2 ( TYPE_1 table , int VAR_2 , int VAR_3 ) { System . out . METHOD_1 ( STRING_1 , VAR_2 , VAR_3 , table . VAR_4 ( ) ) ; <START> System . out . METHOD_2 ( ) ; <END> if ( VAR_2 == VAR_3 ) { VAR_5 = null ; return ; } assert ( VAR_2 < VAR_3 ) ; VAR_5 = table . VAR_6 ( VAR_2 ) ; VAR_7 = VAR_3 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { assert ( VAR_3 != null ) ; if ( ! VAR_4 ) { return ; } <START> assert ( VAR_3 instanceof TYPE_3 ) ; <END> ( ( TYPE_3 ) VAR_3 ) . METHOD_2 ( VAR_5 , VAR_1 . cluster , VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; VAR_6 = VAR_2 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 config ) { TYPE_1 client = null ; synchronized ( TYPE_3 . class ) { if ( ! VAR_1 && ++ VAR_2 == 1 ) { TYPE_4 . METHOD_2 ( ) ; TYPE_5 . start ( ) ; TYPE_6 . start ( ) ; } } <START> config . VAR_3 ( ) ; <END> client = new TYPE_7 ( config , config . VAR_4 ( ) ) ; return client ; } 
public void METHOD_1 ( boolean VAR_1 ) { <START> if ( VAR_1 ) { <END> this . VAR_1 = true ; } } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { <START> <END> if ( ! METHOD_2 ( ) ) { TYPE_2 client = METHOD_3 ( ) ; client . VAR_1 ( TYPE_3 . class . METHOD_4 ( ) ) ; } } 
public void METHOD_1 ( TYPE_1 c ) { VAR_1 = false ; if ( ! VAR_2 ) { <START> if ( METHOD_2 ( ) ) { <END> if ( ! VAR_3 . METHOD_3 ( ) ) { TYPE_2 . METHOD_4 ( STRING_1 + METHOD_5 ( ) ) ; VAR_4 . warn ( STRING_1 + METHOD_5 ( ) ) ; } VAR_3 . METHOD_6 ( VAR_5 ) ; } } } 
public String METHOD_1 ( int VAR_1 ) { if ( VAR_1 == VAR_2 ) { return TYPE_1 . METHOD_2 ( ) ; } Iterator < TYPE_2 > it = VAR_3 . get ( VAR_1 ) . iterator ( ) ; if ( it . hasNext ( ) ) { TYPE_2 VAR_4 = it . next ( ) ; return VAR_4 . METHOD_3 ( ) ; <START> } else { <END> return STRING_1 ; } } 
public void METHOD_1 ( ) throws TYPE_1 { <START> TYPE_2 VAR_1 = METHOD_2 ( 5 , INT_1 , 1 , 2 , 1 ) ; <END> METHOD_3 ( VAR_1 , false ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 table , TYPE_3 VAR_1 ) { <START> TYPE_1 VAR_2 ; <END> if ( ! VAR_1 . METHOD_2 ( ) ) { String VAR_3 = VAR_1 . METHOD_3 ( ) ; String VAR_4 = VAR_1 . METHOD_4 ( ) . METHOD_3 ( ) ; String VAR_5 = METHOD_5 ( VAR_3 , VAR_4 ) ; VAR_2 = new TYPE_1 ( VAR_3 ) ; VAR_2 . METHOD_6 ( VAR_5 ) ; if ( ! VAR_6 . contains ( VAR_4 ) ) { VAR_2 . METHOD_7 ( VAR_4 ) ; } return VAR_2 ; } return null ; } 
public synchronized void close ( ) throws IOException { if ( VAR_1 ) { return ; } VAR_2 . clear ( ) ; for ( TYPE_1 VAR_3 : VAR_4 . values ( ) ) { VAR_3 . close ( ) ; } <START> VAR_4 . clear ( ) ; <END> VAR_1 = true ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { synchronized ( this ) { if ( VAR_2 ) { VAR_1 . METHOD_2 ( ) ; return ; } METHOD_3 ( ) ; if ( VAR_3 ) { Iterator < TYPE_1 > VAR_4 = new TYPE_2 ( VAR_5 , VAR_1 ) ; while ( VAR_4 . hasNext ( ) ) { <START> VAR_6 . METHOD_4 ( VAR_4 . next ( ) ) ; <END> } } else { VAR_6 . METHOD_4 ( VAR_1 ) ; } VAR_7 . METHOD_5 ( TYPE_3 . VAR_9 , 0 ) ; } } 
public TYPE_4 ( ) throws TYPE_1 { <START> super ( null , null , new TYPE_2 ( TYPE_3 . METHOD_1 ( STRING_1 ) , INT_1 ) , VAR_2 , null ) ; <END> } 
private TYPE_1 METHOD_1 ( final ByteBuffer buf ) { return new TYPE_1 ( ) { @Override public ByteBuffer METHOD_2 ( final ByteBuffer VAR_1 ) throws IOException { VAR_1 . put ( buf ) ; <START> return null ; <END> } @Override public void METHOD_3 ( ) { } @Override public int METHOD_4 ( ) { return buf . VAR_2 ( ) ; } } ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { this . VAR_3 = VAR_2 ; <START> this . VAR_4 = ByteBuffer . VAR_5 ( Constants . VAR_6 + INT_1 ) ; <END> this . VAR_7 = ByteBuffer . VAR_5 ( Constants . VAR_6 + INT_1 ) ; this . VAR_8 = ByteBuffer . VAR_9 ( 4 ) ; } 
public final void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { <START> ByteBuffer VAR_2 = ByteBuffer . VAR_3 ( VAR_1 . METHOD_3 ( ) ) ; <END> VAR_1 . position ( 0 ) ; VAR_2 . put ( VAR_1 ) ; VAR_2 . position ( VAR_2 . METHOD_3 ( ) ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( TYPE_2 . VAR_3 == VAR_2 || TYPE_2 . VAR_4 == VAR_2 ) { return true ; <START> } else if ( TYPE_2 . VAR_5 == VAR_2 ) { <END> assert ( VAR_1 . METHOD_3 ( ) == 1 ) ; return METHOD_1 ( VAR_1 . METHOD_4 ( 0 ) ) ; } return false ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> List < Integer > VAR_2 = new ArrayList < Integer > ( ) ; <END> while ( VAR_1 . METHOD_2 ( ) ) { if ( VAR_1 . METHOD_3 ( ) == 2 ) { Integer key = ( int ) ( VAR_1 . METHOD_4 ( STRING_1 ) ) ; VAR_2 . add ( key ) ; } } VAR_3 . set ( TYPE_2 . METHOD_5 ( VAR_2 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { if ( VAR_1 . getStatus ( ) == TYPE_1 . VAR_2 ) { <START> synchronized ( TYPE_3 . this ) { <END> TYPE_2 results [ ] = VAR_1 . METHOD_2 ( ) ; if ( results != null && results . length > 0 ) { METHOD_3 ( results [ 0 ] ) ; } } } VAR_4 . set ( VAR_1 ) ; if ( VAR_5 != null ) { VAR_5 . METHOD_4 ( ) ; } } 
default File VAR_1 ( File path ) { <START> return path . VAR_2 ( ) ? path : new TYPE_1 ( VAR_4 ( ) , path . getPath ( ) ) ; <END> } 
public String METHOD_1 ( String VAR_1 ) { if ( ! VAR_2 . containsKey ( VAR_1 ) ) { <START> throw new RuntimeException ( STRING_1 ) ; <END> } return VAR_2 . get ( VAR_1 ) + STRING_2 ; } 
void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null ) { <START> VAR_2 . METHOD_3 ( VAR_1 . VAR_3 ) ; <END> } if ( VAR_4 != null ) { VAR_4 . METHOD_4 ( METHOD_5 ( ) ) ; } } 
public void METHOD_1 ( int VAR_1 ) { assert ( VAR_2 == Thread . VAR_3 ( ) . getId ( ) ) ; if ( VAR_1 < 1 ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; } VAR_4 += VAR_1 ; VAR_5 ++ ; METHOD_2 ( ) ; if ( VAR_4 > VAR_6 || VAR_5 > VAR_7 ) { if ( ! VAR_8 ) { <START> VAR_9 . info ( STRING_2 ) ; <END> VAR_8 = true ; for ( TYPE_1 m : VAR_10 ) { m . VAR_11 ( ) ; } } } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 item , long VAR_2 ) { if ( item . VAR_3 ( ) <= VAR_2 ) { VAR_1 . METHOD_2 ( item . VAR_4 ( ) , item . getMessage ( ) ) ; } else { VAR_5 . add ( item ) ; <START> METHOD_3 ( VAR_1 , VAR_2 ) ; <END> } } 
public boolean METHOD_1 ( ) throws IOException { if ( VAR_1 ) throw new IOException ( STRING_1 ) ; if ( VAR_2 . size ( ) == 0 ) return false ; <START> for ( String VAR_3 : VAR_2 . keySet ( ) ) { <END> TYPE_1 reader = VAR_2 . get ( VAR_3 ) ; if ( reader . VAR_4 < VAR_5 ) { return false ; } } return true ; } 
<START> private TYPE_1 METHOD_1 ( ) { <END> Map . Entry < Long , TYPE_1 > entry = VAR_1 . METHOD_2 ( ) ; return ( entry != null ) ? entry . getValue ( ) : null ; } 
public TYPE_1 ( String VAR_2 ) { <START> VAR_3 = VAR_2 ; <END> } 
public boolean METHOD_1 ( ) { <START> return VAR_1 == true ; <END> } 
public synchronized void close ( ) throws IOException { if ( VAR_1 ) { return ; } VAR_1 = true ; <START> for ( TYPE_1 VAR_2 : VAR_3 . values ( ) ) { <END> VAR_2 . close ( ) ; } VAR_3 . clear ( ) ; for ( TYPE_2 VAR_4 : VAR_5 . values ( ) ) { VAR_4 . close ( ) ; } VAR_6 . close ( ) ; VAR_1 = true ; } 
public static byte [ ] METHOD_1 ( File path ) throws IOException { byte [ ] VAR_1 = null ; try { VAR_1 = TYPE_1 . METHOD_2 ( path . VAR_2 ( ) ) ; } catch ( IOException VAR_3 ) { <START> throw new IOException ( STRING_1 + path . VAR_4 ( ) + STRING_2 ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 msg , boolean VAR_1 , long VAR_2 ) { long VAR_3 = VAR_4 ; if ( VAR_1 ) { VAR_3 = VAR_2 ; } <START> if ( msg . VAR_5 ( ) >= VAR_3 || VAR_3 == Long . VAR_6 ) { <END> VAR_7 . METHOD_2 ( msg . VAR_8 ( ) , msg ) ; } else { VAR_9 . add ( new TYPE_2 ( msg ) ) ; } METHOD_3 ( VAR_3 , VAR_10 ) ; } 
private void METHOD_1 ( TYPE_1 config ) { File VAR_1 = new TYPE_2 ( config . VAR_2 , TYPE_3 . VAR_3 ) ; try ( TYPE_4 VAR_4 = new TYPE_4 ( new TYPE_5 ( VAR_1 ) , true ) ) { VAR_5 . METHOD_2 ( VAR_4 , STRING_1 ) ; <START> VAR_4 . METHOD_3 ( ) ; <END> VAR_4 . close ( ) ; } catch ( IOException e ) { TYPE_3 . METHOD_4 ( STRING_2 , false , e ) ; } } 
private void METHOD_1 ( TYPE_1 config ) { File VAR_1 = new TYPE_2 ( config . VAR_2 , TYPE_3 . VAR_3 ) ; try ( TYPE_4 is = new TYPE_4 ( VAR_1 ) ) { VAR_4 . info ( STRING_1 + VAR_1 . METHOD_2 ( ) ) ; VAR_5 . METHOD_3 ( is ) ; <START> is . close ( ) ; <END> } catch ( IOException e ) { TYPE_3 . METHOD_4 ( STRING_2 , false , e ) ; } } 
<START> public static TYPE_1 < String > METHOD_1 ( int ... VAR_1 ) { <END> if ( VAR_1 . length == 0 ) { return TYPE_1 . of ( TYPE_2 . METHOD_2 ( "" , VAR_2 ) . toString ( ) ) ; } TYPE_1 . Builder < String > VAR_3 = TYPE_1 . METHOD_3 ( ) ; for ( int p : VAR_1 ) { VAR_3 . add ( TYPE_2 . METHOD_2 ( "" , p ) . toString ( ) ) ; } return VAR_3 . build ( ) ; } 
public static boolean METHOD_1 ( long VAR_1 ) { if ( VAR_1 == - 1 ) return true ; int VAR_2 = METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 >= 0 && VAR_2 < VAR_3 ) { <END> return ! ( ( VAR_1 > > > INT_1 ) == INT_2 ) && ( METHOD_3 ( VAR_1 ) == VAR_4 ) ; } return false ; } 
public static boolean METHOD_1 ( long VAR_1 ) { <START> return ( ( VAR_1 > > > INT_1 ) == INT_2 ) && ! ( VAR_1 == - 1 ) ; <END> } 
<START> private void METHOD_1 ( TYPE_1 client ) <END> throws TYPE_2 , IOException , TYPE_3 { TYPE_4 VAR_1 ; VAR_1 = client . VAR_2 ( STRING_1 , STRING_2 , 1 ) . METHOD_2 ( ) [ 0 ] ; System . out . println ( VAR_1 . toString ( ) ) ; } 
public void METHOD_1 ( ) throws InterruptedException { for ( TYPE_1 VAR_1 : VAR_2 ) { VAR_1 . METHOD_1 ( ) ; } <START> TYPE_2 . VAR_4 . METHOD_1 ( ) ; <END> } 
static private void METHOD_1 ( TYPE_1 project , int VAR_1 , boolean VAR_2 ) { try { project . VAR_3 ( String . format ( VAR_4 , VAR_1 ) ) ; <START> project . VAR_5 ( STRING_1 + VAR_1 , STRING_2 + VAR_1 + STRING_3 ) ; <END> if ( VAR_2 ) { project . VAR_3 ( String . format ( VAR_6 , VAR_1 ) ) ; } } catch ( IOException e ) { METHOD_2 ( true ) ; } } 
public boolean METHOD_1 ( ) { return VAR_1 == TYPE_1 . VAR_3 && <START> ( VAR_4 == null ? true : VAR_4 . METHOD_1 ( ) ) && <END> ( VAR_5 == null ? true : VAR_5 . METHOD_1 ( ) ) ; } 
public static byte [ ] METHOD_1 ( String data ) throws IOException { <START> TYPE_1 VAR_1 = new TYPE_1 ( data . length ( ) ) ; <END> TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; VAR_2 . write ( data . VAR_3 ( TYPE_3 . VAR_5 ) ) ; VAR_2 . close ( ) ; byte [ ] VAR_6 = VAR_1 . METHOD_2 ( ) ; VAR_1 . close ( ) ; return VAR_6 ; } 
public void METHOD_1 ( boolean VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , TYPE_1 config ) { <START> METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , config , null ) ; <END> } 
void METHOD_1 ( ) { METHOD_1 ( VAR_1 , false ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { <START> if ( VAR_2 . size ( ) > VAR_3 ) { <END> String msg = STRING_1 + VAR_3 + STRING_2 + VAR_2 . size ( ) + STRING_3 + VAR_3 ; throw new TYPE_2 ( msg , "" , TYPE_3 . VAR_5 ) ; } } METHOD_1 ( VAR_6 , false ) ; } 
private TYPE_1 ( TYPE_1 VAR_1 ) { super ( TYPE_2 . VAR_3 ) ; this . VAR_4 = VAR_1 . VAR_4 ; this . VAR_5 = VAR_1 . VAR_5 ; <START> this . VAR_6 = true ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) . equals ( TYPE_3 . TYPE_4 ) ) { <END> METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; } } 
public void METHOD_1 ( ) { <START> VAR_1 = true ; <END> METHOD_2 ( ) ; } 
public TYPE_5 ( ) { final TYPE_1 r = new TYPE_1 ( TYPE_4 . VAR_3 , new TYPE_2 [ 0 ] , STRING_1 ) ; VAR_4 = r . VAR_5 ( ) ; <START> VAR_6 = TYPE_3 . METHOD_1 ( STRING_2 ) ; <END> VAR_7 = METHOD_2 ( ) . METHOD_3 ( ) ; VAR_8 = VAR_7 != null && ! VAR_7 . isEmpty ( ) ; } 
TYPE_3 ( String name , TYPE_1 VAR_2 ) { if ( ! ( STRING_1 . equalsIgnoreCase ( name ) || STRING_2 . equalsIgnoreCase ( name ) ) ) { <START> throw new RuntimeException ( STRING_3 + name + STRING_4 ) ; <END> } VAR_3 = new TYPE_2 ( STRING_1 . equalsIgnoreCase ( name ) ? CHAR_1 : CHAR_2 ) ; } 
public void METHOD_1 ( ) { VAR_1 = Long . VAR_2 ; <START> VAR_3 = Long . VAR_2 ; <END> VAR_4 = Long . VAR_2 ; } 
private void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { try { TYPE_2 . METHOD_2 ( VAR_2 , 10 ) ; } catch ( TYPE_3 ex ) { <START> TYPE_4 . METHOD_3 ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . VAR_2 ) { METHOD_3 ( ) ; METHOD_4 ( ) ; <START> METHOD_5 ( ) . METHOD_6 ( false ) ; <END> } if ( VAR_1 . e != null ) { throw new TYPE_2 ( STRING_1 , VAR_1 . e ) ; } } 
public synchronized void METHOD_1 ( int VAR_1 ) { <START> Integer TYPE_1 = VAR_1 ; <END> if ( ! VAR_3 . containsKey ( TYPE_1 ) ) { int [ ] val = new int [ 1 ] ; val [ 0 ] = 0 ; VAR_3 . put ( TYPE_1 , val ) ; } VAR_3 . get ( TYPE_1 ) [ 0 ] ++ ; } 
public void METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> TYPE_1 key = new TYPE_1 ( STRING_2 . METHOD_2 ( ) ) ; List < TYPE_2 < byte [ ] > > VAR_1 = METHOD_3 ( key ) ; if ( VAR_1 . size ( ) == 0 ) { Assert . VAR_2 ( STRING_3 ) ; } METHOD_4 ( key , VAR_1 . get ( 0 ) . METHOD_5 ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 type ) { <START> for ( TYPE_1 VAR_1 : VAR_2 ) <END> if ( VAR_1 . getType ( ) . equals ( type ) ) return VAR_1 ; throw new IllegalStateException ( type . VAR_3 ( ) + STRING_1 ) ; } 
public static String METHOD_1 ( TYPE_1 props ) { String VAR_1 = new String ( ) ; <START> Boolean VAR_2 = true ; <END> for ( String key : props . VAR_3 ( ) ) { if ( VAR_2 ) { VAR_2 = false ; } else { VAR_1 = VAR_1 + STRING_1 ; } VAR_1 = VAR_1 + STRING_2 + key + STRING_3 + props . getProperty ( key ) + STRING_4 ; } if ( VAR_1 . isEmpty ( ) ) { return STRING_5 ; } else { return STRING_6 + VAR_1 + STRING_7 ; } } 
private TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( VAR_1 , VAR_2 ) ; <END> } 
public < T > TYPE_1 < TYPE_2 < T > > METHOD_1 ( T item , TYPE_3 VAR_1 , TYPE_4 options ) { final TYPE_4 VAR_2 = options == null ? new TYPE_4 ( ) : options ; <START> TYPE_5 . METHOD_2 ( options , VAR_1 ) ; <END> return METHOD_3 ( context - > METHOD_4 ( item , VAR_2 , context ) ) ; } 
private void METHOD_1 ( TYPE_1 method ) { <START> if ( METHOD_2 ( method ) && this . state . VAR_1 ( TYPE_2 . VAR_3 , TYPE_2 . VAR_4 ) ) { <END> if ( logger . VAR_5 ( ) ) { logger . debug ( STRING_1 ) ; } this . METHOD_3 ( ) . METHOD_4 ( VAR_6 - > { } ) . METHOD_5 ( VAR_6 - > { } , ex - > { } ) ; } } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 count ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . count = count ; <START> logger = TYPE_4 . METHOD_1 ( this . getClass ( ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = this . VAR_2 . METHOD_2 ( VAR_3 ) ; <START> TYPE_3 . create ( VAR_1 ) . METHOD_3 ( VAR_4 - > true ) . METHOD_4 ( ) . METHOD_5 ( ) ; <END> TYPE_1 < TYPE_4 > VAR_5 = this . VAR_2 . METHOD_6 ( VAR_3 ) ; TYPE_3 . create ( VAR_5 ) . METHOD_7 ( ) ; TYPE_1 < Long > VAR_6 = VAR_2 . count ( ) ; TYPE_3 . create ( VAR_6 ) . METHOD_8 ( INT_1 ) . METHOD_7 ( ) ; } 
<START> public static Object METHOD_1 ( Object VAR_1 ) { <END> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; if ( VAR_1 instanceof String ) { Assert . VAR_3 ( VAR_1 . toString ( ) , STRING_2 ) ; return VAR_1 ; } else if ( VAR_1 instanceof Integer ) { return Integer . toString ( ( Integer ) VAR_1 ) ; } else if ( VAR_1 instanceof Long ) { return Long . toString ( ( Long ) VAR_1 ) ; } else { throw new TYPE_1 ( STRING_3 ) ; } } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 ... VAR_1 ) { <END> this . VAR_1 = Arrays . asList ( VAR_1 ) ; return this ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 , TYPE_4 options ) { if ( options == null ) { options = new TYPE_4 ( ) ; } TYPE_5 VAR_2 = new TYPE_5 ( ) ; VAR_2 . METHOD_2 ( VAR_1 . getId ( ) ) ; <START> final TYPE_4 VAR_3 = options ; <END> return METHOD_3 ( context - > METHOD_4 ( VAR_2 , VAR_3 , context ) ) ; } 
TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 options ) { return TYPE_4 . METHOD_2 ( VAR_1 - > { <START> String VAR_2 = STRING_1 ; VAR_1 . METHOD_3 ( this . VAR_3 , VAR_2 , this . VAR_4 , null ) ; <END> METHOD_4 ( VAR_1 , options ) ; return METHOD_5 ( ) . METHOD_6 ( options ) . map ( response - > TYPE_5 . METHOD_7 ( TYPE_6 . METHOD_8 ( response . VAR_5 ( ) ) , response . VAR_6 ( ) ) ) ; } ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { <START> return new TYPE_1 ( ) . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ; <END> } else { return new TYPE_1 ( ) ; } } 
void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( this ) ; when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_2 ) ; when ( VAR_1 . METHOD_5 ( ) ) . METHOD_4 ( VAR_3 ) ; when ( VAR_1 . METHOD_6 ( ) ) . METHOD_4 ( new TYPE_2 ( TYPE_4 . VAR_5 , 1 , VAR_6 ) ) ; <START> when ( VAR_7 ) . METHOD_4 ( VAR_8 ) ; <END> client = new TYPE_3 ( VAR_1 , VAR_9 ) ; } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { if ( this . equals ( VAR_1 ) ) { return 0 ; } <START> if ( ( this . VAR_2 < this . VAR_2 ) || ( ( this . VAR_2 == VAR_1 . VAR_2 ) && ( this . VAR_3 < VAR_1 . VAR_3 ) ) ) { <END> return - 1 ; } return 1 ; } 
public TYPE_2 ( String VAR_2 , String VAR_3 ) { <START> TYPE_1 . METHOD_1 ( VAR_2 , STRING_1 ) ; <END> TYPE_1 . METHOD_1 ( VAR_3 , STRING_2 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 context , TYPE_4 next ) { <START> String VAR_1 = this . VAR_2 . METHOD_2 ( context . VAR_3 ( ) . METHOD_3 ( ) , <END> context . VAR_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ) ; context . VAR_3 ( ) . METHOD_6 ( STRING_1 , VAR_1 ) ; return next . VAR_4 ( ) ; } 
void METHOD_1 ( ) { String VAR_1 = VAR_2 . METHOD_2 ( STRING_1 , INT_1 ) ; TYPE_1 VAR_3 = new TYPE_1 ( ) . METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_1 ) ; String VAR_4 = VAR_2 . METHOD_5 ( ) ; TYPE_2 . create ( VAR_5 . METHOD_6 ( ) . METHOD_7 ( VAR_3 , VAR_4 , TYPE_7 . VAR_7 , null , Context . NONE ) ) <START> . METHOD_8 ( TYPE_5 . TYPE_6 . data . VAR_8 . VAR_9 . VAR_10 . TYPE_4 . class ) <END> . METHOD_9 ( ) ; } 
public TYPE_2 ( final List < TYPE_1 > VAR_2 ) { if ( VAR_2 == null ) { this . VAR_2 = null ; } else { <START> this . VAR_2 = Collections . VAR_3 ( new ArrayList < > ( VAR_2 ) ) ; <END> } } 
public TYPE_3 ( final TYPE_1 VAR_2 , final Map < String , TYPE_2 > VAR_3 , final String VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 == null ? null : Collections . VAR_5 ( new HashMap < > ( VAR_3 ) ) ; <END> this . VAR_4 = VAR_4 ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public Response < TYPE_1 > METHOD_1 ( TYPE_2 options , TYPE_3 VAR_1 , Context context ) { return TYPE_4 . METHOD_2 ( VAR_2 . <START> METHOD_1 ( options , context ) , options == null ? null : VAR_1 ) ; <END> } 
private TYPE_1 < TYPE_2 > METHOD_1 ( ) { return VAR_1 . METHOD_2 ( connection - > { <START> String VAR_2 = VAR_3 ; <END> if ( ! TYPE_3 . METHOD_3 ( VAR_4 ) ) { VAR_2 = STRING_1 . METHOD_4 ( VAR_4 ) ; return connection . VAR_5 ( VAR_2 , VAR_4 , VAR_6 , VAR_3 ) ; } else { return connection . VAR_5 ( VAR_2 , VAR_3 , VAR_6 , null ) ; } } ) . METHOD_5 ( next - > VAR_2 . METHOD_6 ( null , next . VAR_7 ( ) ) ) ; } 
<START> public float METHOD_1 ( ) { <END> return this . VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( ) . METHOD_2 ( STRING_1 ) . METHOD_3 ( ) ; VAR_1 . METHOD_1 ( STRING_2 ) . METHOD_4 ( TYPE_3 - > { } , <START> error - > logger . error ( STRING_3 + error ) , <END> ( ) - > logger . info ( STRING_4 ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( ) . METHOD_2 ( STRING_1 ) . METHOD_3 ( ) ; <START> TYPE_3 VAR_2 = new TYPE_3 ( ) ; <END> VAR_2 . METHOD_4 ( STRING_2 ) ; VAR_1 . METHOD_5 ( VAR_2 ) . METHOD_6 ( VAR_3 - > { logger . info ( VAR_3 . getName ( ) ) ; } , error - > { logger . error ( STRING_3 + error ) ; } ) ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 == true || ( ! VAR_2 && METHOD_2 ( ) ) ; <END> } 
public TYPE_3 ( TYPE_1 session , TYPE_2 VAR_2 ) { METHOD_1 ( session ) ; <START> METHOD_2 ( VAR_2 == null ? METHOD_3 ( ) : VAR_2 ) ; <END> } 
public static TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( STRING_1 + METHOD_2 ( ) , STRING_2 + METHOD_2 ( ) ) ; <END> } 
public synchronized < T > T METHOD_1 ( Class < T > VAR_1 , String ... VAR_2 ) { METHOD_2 ( VAR_1 ) ; TYPE_1 VAR_3 = VAR_1 . METHOD_3 ( ) ; TYPE_2 VAR_4 = new TYPE_2 ( VAR_2 ) ; return VAR_1 . METHOD_4 ( TYPE_3 . METHOD_5 ( VAR_3 , new Class < ? > [ ] { VAR_1 } , VAR_4 ) ) ; <START> } <END> 
public void execute ( TYPE_1 VAR_1 ) { if ( VAR_2 . METHOD_1 ( false , true ) ) { VAR_3 . METHOD_2 ( group , ( ) - > { <START> VAR_1 . run ( ) ; <END> VAR_2 . set ( false ) ; } ) ; } } 
public TYPE_1 < TYPE_4 . TYPE_5 > METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_3 { <START> String VAR_3 = STRING_1 ; <END> return METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , ( VAR_4 , VAR_5 , VAR_6 ) - > VAR_4 . METHOD_2 ( VAR_5 , Optional . of ( VAR_6 ) , Optional . empty ( ) ) ) ; } 
private int METHOD_1 ( String VAR_1 ) throws TYPE_1 { try { return VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; } catch ( TYPE_2 | TYPE_3 e ) { <START> throw new TYPE_1 ( e . status ( ) , e , "" ) ; <END> } } 
private int [ ] METHOD_1 ( String [ ] VAR_1 ) throws TYPE_1 { int [ ] VAR_2 = new int [ VAR_1 . length ] ; for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { try { VAR_2 [ i ] = VAR_3 . METHOD_2 ( ) . METHOD_3 ( VAR_1 [ i ] ) ; } catch ( TYPE_2 e ) { <START> throw new TYPE_1 ( e . status ( ) , e , "" ) ; <END> } } return VAR_2 ; } 
boolean METHOD_1 ( ) { <START> return VAR_1 == VAR_2 ; <END> } 
TYPE_1 ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 . VAR_2 ; type = VAR_1 . type ; <START> VAR_3 = VAR_1 . VAR_3 ; <END> VAR_4 = VAR_1 . VAR_4 ; } 
public static void METHOD_1 ( String [ ] args ) throws InterruptedException , IOException { TYPE_1 VAR_1 = new TYPE_2 ( ) ; <START> File VAR_2 = new File ( STRING_1 ) ; <END> TYPE_3 . METHOD_2 ( ) . METHOD_3 ( new Thread ( ( ) - > VAR_1 . METHOD_4 ( VAR_2 ) ) ) ; new TYPE_4 ( VAR_1 , VAR_2 ) . run ( ) ; } 
private void METHOD_1 ( ) { VAR_1 . values ( ) . forEach ( index - > { try { index . VAR_2 ( ) ; } catch ( Exception e ) { try { index . close ( ) ; } catch ( IOException VAR_3 ) { <START> e . VAR_4 ( VAR_3 ) ; <END> } } } ) ; VAR_1 . clear ( ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . type ( ) == TYPE_1 . TYPE_4 . VAR_3 ) { TYPE_1 . TYPE_3 VAR_4 = ( TYPE_1 . TYPE_3 ) VAR_1 ; return METHOD_2 ( VAR_4 . value ( ) ) ; } else return VAR_1 . type ( ) == TYPE_1 . TYPE_4 . VAR_5 && <START> ( VAR_1 . METHOD_3 ( ) == TYPE_5 . VAR_7 || VAR_1 . METHOD_3 ( ) == TYPE_5 . VAR_8 ) ; <END> } 
void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = METHOD_2 ( ) ; try { <START> VAR_2 . METHOD_3 ( METHOD_4 ( 0 , 0 ) , STRING_1 ) ; <END> METHOD_5 ( STRING_2 ) ; } catch ( IllegalArgumentException e ) { } } 
public void METHOD_1 ( long VAR_1 , String VAR_2 ) { boolean VAR_3 = TYPE_1 . equals ( VAR_4 , VAR_5 . METHOD_2 ( ) ) && VAR_1 == VAR_5 . METHOD_3 ( ) ; if ( VAR_3 ) { <START> log . info ( String . format ( STRING_1 + <END> STRING_2 , VAR_4 , VAR_5 . METHOD_3 ( ) ) ) ; TYPE_2 . METHOD_4 ( VAR_6 , VAR_5 . METHOD_5 ( ) , VAR_2 , log ) ; } } 
public void METHOD_1 ( ) throws Throwable { <START> server . VAR_1 ( ) ; <END> server . VAR_2 ( ) ; } 
public void METHOD_1 ( ) throws Throwable { server = METHOD_2 ( ) ; server . VAR_1 ( ) ; <START> METHOD_3 ( METHOD_4 ( server . VAR_2 ( ) , VAR_3 ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) ) ; boolean VAR_3 = VAR_1 . METHOD_4 ( ) ; if ( VAR_3 ) { VAR_2 . METHOD_5 ( ) ; } <START> <END> for ( TYPE_3 listener : VAR_4 ) { if ( VAR_3 ) { listener . VAR_5 ( VAR_2 ) ; } listener . VAR_6 ( VAR_2 ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 . METHOD_2 ( TYPE_7 . VAR_4 ) ) { return METHOD_3 ( TYPE_3 . of ( VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , VAR_2 ) ) ; } else { if ( VAR_2 instanceof TYPE_4 ) { return time ( TYPE_5 . of ( VAR_1 . METHOD_5 ( ) , ( TYPE_4 ) VAR_2 ) ) ; } else { <START> throw new TYPE_6 ( STRING_1 ) ; <END> } } } 
public static TYPE_1 parse ( TYPE_2 text , TYPE_3 < TYPE_4 > VAR_1 , TYPE_5 VAR_2 ) { if ( VAR_2 != null ) { if ( ! ( VAR_2 instanceof TYPE_6 ) ) { <START> throw new TYPE_7 ( STRING_1 + VAR_2 ) ; <END> } VAR_1 = ( ( TYPE_6 ) VAR_2 ) . METHOD_1 ( VAR_1 ) ; } return parse ( TYPE_1 . class , VAR_3 , TYPE_1 : : parse , text , VAR_1 ) ; } 
TYPE_1 METHOD_1 ( ) { <START> throw new TYPE_2 ( STRING_1 + this ) ; <END> } 
<START> private String METHOD_1 ( Map . Entry < String , String > VAR_1 ) <END> { return VAR_2 . contains ( VAR_1 . getKey ( ) ) ? TYPE_1 . VAR_4 : VAR_1 . getValue ( ) ; } 
public TYPE_5 . TYPE_6 METHOD_1 ( TYPE_2 index , TYPE_5 . TYPE_6 target ) throws TYPE_3 { VAR_1 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_2 ( ) ; <END> return VAR_2 . METHOD_3 ( TYPE_4 . METHOD_4 ( index . VAR_3 ( ) , index . properties ( ) ) , target ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { boolean VAR_3 = VAR_1 instanceof TYPE_2 ; <START> boolean VAR_4 = VAR_2 instanceof TYPE_2 ; <END> if ( VAR_3 && VAR_4 ) { return VAR_1 . equals ( VAR_2 ) ; } else if ( ! VAR_3 && ! VAR_4 ) { return TYPE_3 . map ( VAR_1 . getId ( ) ) == TYPE_3 . map ( VAR_2 . getId ( ) ) ; } return false ; } 
private TYPE_1 [ ] METHOD_1 ( List < TYPE_2 > VAR_1 ) { return VAR_1 . stream ( ) . map ( VAR_2 - > VAR_2 . file ( ) . METHOD_2 ( ) ) . METHOD_3 ( ) . METHOD_4 ( VAR_3 - > TYPE_1 . METHOD_5 ( VAR_4 , VAR_3 ) ) <START> . METHOD_6 ( ) <END> . METHOD_7 ( TYPE_1 [ ] : : new ) ; } 
public int METHOD_1 ( final long VAR_1 ) throws TYPE_1 { final TYPE_2 count = new TYPE_2 ( ) ; TYPE_3 VAR_2 = new TYPE_3 ( VAR_3 - > { VAR_4 . METHOD_2 ( ) ; METHOD_3 ( VAR_3 ) ; <START> count . VAR_5 ( ) ; <END> } ) ; VAR_2 . METHOD_4 ( VAR_1 , VAR_4 ) ; VAR_4 . METHOD_2 ( ) ; METHOD_5 ( VAR_1 ) ; return count . VAR_6 ( ) ; } 
<START> public synchronized void METHOD_1 ( ) throws Throwable <END> { VAR_1 . METHOD_2 ( ) ; } 
private synchronized TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 channel = null ; TYPE_3 < TYPE_1 > VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 != null ) { channel = VAR_2 . METHOD_2 ( ) ; if ( channel != null && ! channel . VAR_4 ( ) ) { <START> METHOD_3 ( channel ) ; <END> channel = null ; } if ( VAR_2 . isEmpty ( ) ) { VAR_3 . remove ( VAR_1 ) ; } } return channel ; } 
private static TYPE_1 METHOD_1 ( int index , int VAR_1 ) { TYPE_2 VAR_2 = <START> index % 2 == 0 ? <END> VAR_1 == 2 ? VAR_3 : VAR_4 : VAR_1 == 2 ? TYPE_3 : TYPE_4 ; return METHOD_2 ( VAR_2 , METHOD_3 ( ) . METHOD_4 ( VAR_1 , Double . VAR_7 , Double . VAR_8 ) . METHOD_5 ( ) ) ; } 
<START> public static TYPE_1 parse ( TYPE_2 text , TYPE_3 [ ] VAR_1 ) <END> { TYPE_3 [ ] VAR_2 = METHOD_1 ( text ) ; if ( VAR_1 != null ) { for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { if ( VAR_2 [ i ] == null ) { VAR_2 [ i ] = VAR_1 [ i ] ; } } } return METHOD_2 ( VAR_2 ) ; } 
public boolean METHOD_1 ( TYPE_1 value ) { if ( value == null ) { return false ; } if ( value instanceof TYPE_2 ) { TYPE_2 VAR_1 = ( TYPE_2 ) value ; <START> if ( VAR_1 . METHOD_2 ( ) == VAR_2 ) <END> { return VAR_1 . METHOD_3 ( from , VAR_3 , to , VAR_4 ) ; } } return false ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_1 . class ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; <START> TYPE_2 result = db ( ) . execute ( STRING_2 ) ; <END> } 
void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { try { <START> Thread . VAR_3 ( INT_1 ) ; <END> VAR_1 . METHOD_2 ( ) ; VAR_2 . remove ( VAR_1 ) ; } catch ( Throwable t ) { METHOD_3 ( VAR_1 , t ) ; } } } 
public static TYPE_1 METHOD_1 ( TYPE_2 map ) { <START> TYPE_3 [ ] VAR_1 = new TYPE_4 [ TYPE_5 . VAR_2 . METHOD_2 ( ) ] ; <END> for ( TYPE_5 f : TYPE_5 . values ( ) ) { if ( f != TYPE_5 . VAR_2 ) { TYPE_3 VAR_3 = map . get ( f . name ( ) . METHOD_3 ( ) ) ; VAR_1 [ f . VAR_4 ( ) ] = VAR_3 != TYPE_6 . VAR_6 ? VAR_3 : null ; } } return METHOD_4 ( VAR_1 ) ; } 
public static int METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 group , int type ) { VAR_1 . METHOD_2 ( group ) ; int count = 0 ; while ( group . next ( ) ) { if ( group . type ( ) == type ) { <START> count += group . VAR_2 ( ) + group . VAR_3 ( ) ; <END> } } return count ; } 
public TYPE_1 create ( TYPE_2 channel , Log log ) throws Exception { TYPE_3 VAR_1 = channel . VAR_1 ( ) ; TYPE_1 builder = TYPE_1 . METHOD_1 ( VAR_1 , log ) ; int i = 0 ; for ( TYPE_4 VAR_2 : VAR_3 . METHOD_2 ( channel ) ) { <START> builder . add ( String . format ( STRING_1 , VAR_3 . name ( ) , i ) , VAR_2 ) ; <END> } return builder ; } 
public Iterator < T > iterator ( ) { if ( count == - 1 ) { throw new IllegalStateException ( STRING_1 ) ; } return new Iterator < T > ( ) { private int VAR_1 = count ; @Override public boolean hasNext ( ) { return VAR_1 > 0 ; } @Override ANNOTATION_1 ( STRING_2 ) public T next ( ) { if ( ! hasNext ( ) ) { throw new TYPE_1 ( ) ; } -- VAR_1 ; <START> return ( T ) VAR_2 [ VAR_1 ] ; <END> } } ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , int VAR_3 ) { int VAR_4 = VAR_1 . METHOD_2 ( ) ; try { VAR_2 . VAR_5 = new byte [ VAR_3 ] ; VAR_1 . METHOD_3 ( VAR_2 . VAR_5 ) ; } <START> catch ( TYPE_3 e ) <END> { throw TYPE_4 . METHOD_4 ( e , e . getMessage ( ) + STRING_1 + VAR_3 + STRING_2 + VAR_4 + STRING_3 + VAR_1 . METHOD_5 ( ) ) ; } } 
public void close ( ) { read = null ; VAR_1 = TYPE_1 . VAR_3 ; VAR_4 = METHOD_1 ( ) ; METHOD_2 ( ) ; if ( VAR_5 != null ) { VAR_5 . close ( ) ; VAR_5 = null ; } if ( VAR_6 != null ) { VAR_6 . close ( ) ; VAR_6 = null ; <START> if ( VAR_7 != null ) <END> { VAR_7 . METHOD_3 ( this ) ; } } } 
private static TYPE_1 METHOD_1 ( int VAR_1 ) { <START> if ( VAR_1 < VAR_2 . length ) <END> { return VAR_2 [ VAR_1 ] ; } else { return VAR_3 ; } } 
public final boolean METHOD_1 ( Object VAR_1 ) { if ( VAR_1 == null ) { return false ; } if ( VAR_1 instanceof TYPE_1 ) { return this . equals ( ( TYPE_1 ) VAR_1 ) ; } <START> return VAR_1 instanceof TYPE_2 && equals ( ( TYPE_2 ) VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws IOException { if ( index != null ) { <START> index . close ( ) ; <END> } } 
public TYPE_1 METHOD_1 ( long VAR_1 , int VAR_2 ) throws TYPE_2 { VAR_3 . METHOD_2 ( ) ; if ( VAR_2 == TYPE_6 . VAR_5 ) { return TYPE_5 . VAR_7 ; } try ( TYPE_3 < TYPE_4 > node = METHOD_3 ( ) . METHOD_4 ( VAR_3 , VAR_1 ) ) { <START> if ( METHOD_5 ( VAR_2 ) ) <END> { return METHOD_3 ( ) . METHOD_1 ( VAR_3 , node . get ( ) , VAR_2 ) ; } else { return TYPE_5 . VAR_7 ; } } } 
public void run ( ) { <START> List < Throwable > VAR_1 = new TYPE_1 < > ( ) ; <END> for ( TYPE_2 o : VAR_2 ) { try { o . run ( ) ; } catch ( RuntimeException e ) { VAR_1 . add ( e ) ; } } if ( ! VAR_1 . isEmpty ( ) ) { RuntimeException exception = new RuntimeException ( ) ; VAR_1 . forEach ( exception : : METHOD_1 ) ; throw exception ; } } 
public void METHOD_1 ( ) throws TYPE_1 { long VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( METHOD_3 ( VAR_3 , VAR_1 ) ) { VAR_4 ++ ; } <START> VAR_3 = VAR_1 ; <END> if ( VAR_4 >= VAR_5 ) { throw new TYPE_1 ( STRING_1 + VAR_5 ) ; } } 
public void METHOD_1 ( ) { try { <START> VAR_1 . create ( ) ; <END> VAR_2 . METHOD_1 ( VAR_1 . METHOD_2 ( ) , a - > { } ) ; } catch ( IOException e ) { METHOD_3 ( ) ; } VAR_3 = VAR_2 . METHOD_4 ( ) ; session = VAR_3 . METHOD_5 ( TYPE_1 . VAR_5 ) ; System . VAR_6 ( STRING_1 , STRING_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 > 0 ) { if ( VAR_3 ) { VAR_4 . remove ( VAR_1 ) ; } <START> VAR_2 -- ; <END> } } 
void METHOD_1 ( long VAR_1 , TYPE_1 read ) { if ( getId ( ) != VAR_2 ) { METHOD_2 ( ) ; } if ( VAR_3 == null ) { VAR_3 = read . VAR_4 ( VAR_1 ) ; } this . next = VAR_1 ; this . VAR_5 = VAR_2 ; this . read = read ; this . VAR_6 = TYPE_2 . VAR_8 ; this . VAR_9 = METHOD_3 ( ) ; <START> this . VAR_10 = true ; <END> } 
<START> int length ( ) <END> { return ( int ) Math . VAR_1 ( 2 , VAR_2 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , Type type ) { int VAR_3 = METHOD_2 ( VAR_2 , type ) ; VAR_1 . METHOD_3 ( VAR_3 ) ; int VAR_4 = METHOD_4 ( VAR_1 ) ; if ( VAR_4 > VAR_5 ) { <START> VAR_1 . METHOD_5 ( STRING_1 + VAR_4 + STRING_2 + VAR_5 ) ; <END> } VAR_1 . METHOD_3 ( VAR_4 ) ; } 
<START> public synchronized void close ( ) <END> { VAR_1 = false ; } 
public void METHOD_1 ( ) throws Exception { File VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; VAR_3 = new TYPE_1 ( VAR_4 , VAR_5 . get ( ) , VAR_1 , false ) ; <START> index = TYPE_2 . create ( VAR_6 , TYPE_3 . METHOD_3 ( ) , VAR_4 ) <END> . METHOD_4 ( VAR_3 ) . build ( ) ; VAR_7 = VAR_6 . METHOD_5 ( ) ; } 
private int METHOD_1 ( long VAR_1 , int VAR_2 ) throws IOException { <START> int VAR_3 = VAR_4 - VAR_2 ; <END> if ( VAR_3 < 4 ) { return METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; } METHOD_3 ( VAR_1 , VAR_2 ) ; int val ; do { val = VAR_5 . getInt ( VAR_2 ) ; } while ( VAR_5 . METHOD_4 ( ) ) ; if ( VAR_5 . METHOD_5 ( ) ) { throw METHOD_6 ( STRING_1 ) ; } return val ; } 
public TYPE_1 METHOD_1 ( ) { Map < TYPE_2 , TYPE_1 > VAR_1 = new HashMap < > ( ) ; for ( Map . Entry < TYPE_2 , TYPE_3 > index : VAR_2 . entrySet ( ) ) { try { <START> VAR_1 . put ( index . getKey ( ) , index . getValue ( ) . METHOD_2 ( VAR_3 , VAR_4 ) . METHOD_1 ( ) ) ; <END> } catch ( IOException e ) { e . VAR_5 ( ) ; } } return new TYPE_4 ( VAR_1 , VAR_3 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( VAR_2 , VAR_3 ) . METHOD_3 ( VAR_4 , TYPE_2 . of ( STRING_1 ) ) . METHOD_3 ( VAR_5 , TYPE_2 . of ( INT_1 ) ) <START> . METHOD_3 ( VAR_6 , TYPE_2 . of ( TYPE_2 . METHOD_4 ( TYPE_3 . VAR_8 , FLOAT_1 , FLOAT_2 ) ) ) <END> . build ( ) ; assertThat ( VAR_1 . METHOD_5 ( VAR_9 , METHOD_6 ( ) ) , METHOD_7 ( ) ) ; } 
public void close ( ) throws Exception { writer . close ( ) ; <START> super . close ( ) ; <END> } 
public boolean METHOD_1 ( String [ ] VAR_1 ) { METHOD_2 ( ) ; <START> for ( String VAR_2 : VAR_1 ) <END> { this . VAR_1 . add ( VAR_2 ) ; } return VAR_3 . METHOD_1 ( VAR_1 ) ; } 
public boolean append ( TYPE_1 < TYPE_2 > VAR_1 , TYPE_2 [ ] VAR_2 , long id , int index ) { TYPE_2 record = VAR_2 [ index ] ; if ( ! VAR_1 . next ( id , record , TYPE_3 . VAR_4 ) || ( filter != null && ! filter . VAR_5 ( record ) ) ) { return false ; } <START> return true ; <END> } 
private void METHOD_1 ( ) { <START> int VAR_1 = ( int ) ( VAR_2 * 100 / size ) ; <END> if ( VAR_1 > VAR_3 ) { VAR_3 = VAR_1 ; listener . VAR_4 ( VAR_1 ) ; } } 
public void METHOD_1 ( Path VAR_1 , TYPE_1 monitor ) throws IOException { long size = VAR_2 . METHOD_2 ( source ) ; TYPE_2 in = VAR_2 . METHOD_3 ( source ) ; <START> TYPE_3 VAR_3 = new TYPE_3 ( in , size , monitor : : METHOD_4 ) ; <END> TYPE_4 . METHOD_5 ( VAR_3 , VAR_1 ) ; } 
public synchronized void METHOD_1 ( ) throws Throwable { VAR_1 = true ; if ( VAR_2 != null ) { VAR_2 . METHOD_1 ( ) ; } if ( VAR_3 != null ) { <START> VAR_3 . METHOD_2 ( false ) ; <END> try { VAR_3 . METHOD_3 ( ) ; } catch ( TYPE_1 VAR_4 ) { } } } 
<START> protected void METHOD_1 ( TYPE_1 resource , long VAR_1 ) <END> { VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_2 . METHOD_5 ( ) , resource , VAR_1 ) ; } 
void METHOD_1 ( TYPE_1 read ) { if ( getId ( ) != VAR_1 ) { METHOD_2 ( ) ; } if ( VAR_2 == null ) { VAR_2 = read . VAR_3 ( 0 ) ; } this . next = 0 ; this . VAR_4 = read . VAR_5 ( ) ; this . read = read ; <START> if ( VAR_6 != null ) <END> { VAR_6 = read . VAR_6 ( ) ; } } 
<START> public void METHOD_1 ( ) throws Throwable <END> { if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; } } 
private void METHOD_1 ( TYPE_1 config , File file ) { try { TYPE_2 VAR_1 = new TYPE_3 ( new TYPE_4 ( file ) ) ; for ( Map . Entry < String , String > entry : config . VAR_2 ( ) . entrySet ( ) ) { VAR_1 . write ( String . format ( STRING_1 , entry . getKey ( ) , entry . getValue ( ) ) ) ; } VAR_1 . close ( ) ; } catch ( IOException e ) { <START> e . VAR_3 ( ) ; <END> } } 
private String METHOD_1 ( File VAR_1 ) { if ( VAR_2 == null ) { return "" ; } <START> File VAR_3 = METHOD_2 ( VAR_1 ) . METHOD_3 ( STRING_1 ) . METHOD_4 ( ) ; <END> METHOD_5 ( VAR_2 , VAR_3 ) ; return String . format ( STRING_2 , VAR_3 ) ; } 
public String METHOD_1 ( ) { <START> if ( true ) return VAR_1 . keySet ( ) . toString ( ) ; <END> if ( VAR_1 . containsKey ( TYPE_1 . VAR_3 ) ) { return TYPE_1 . VAR_3 ; } if ( VAR_1 . containsKey ( TYPE_1 . VAR_4 ) ) { return TYPE_1 . VAR_4 ; } return TYPE_1 . VAR_5 ; } 
public void METHOD_1 ( ) { try ( TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ) { <START> METHOD_2 ( VAR_1 ) ; <END> METHOD_3 ( VAR_1 ) ; } } 
public org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_3 METHOD_1 ( TYPE_1 VAR_6 ) { return new TYPE_2 ( VAR_7 , VAR_3 , VAR_6 ) ; <START> } <END> 
public TYPE_1 properties ( ) { TYPE_1 m = properties ; if ( m == null ) { <START> synchronized ( VAR_1 ) <END> { m = properties ; if ( m == null ) { m = properties = TYPE_2 . METHOD_1 ( node . VAR_2 ( ) ) ; } } } return m ; } 
public static TYPE_1 create ( TYPE_2 config , TYPE_3 VAR_1 ) { Type type = config . get ( TYPE_8 . VAR_3 ) ; <START> switch ( type ) <END> { case NONE : return new TYPE_4 ( ) ; case VAR_4 : return new TYPE_5 ( config . get ( VAR_5 ) , config . get ( VAR_6 ) , VAR_1 . METHOD_1 ( TYPE_6 . class ) , false ) ; case VAR_7 : return new TYPE_7 ( ) ; default : throw new IllegalArgumentException ( STRING_1 ) ; } } 
public boolean equals ( TYPE_1 value ) { <START> if ( value instanceof org . VAR_1 . values . VAR_2 . TYPE_2 ) <END> { return Arrays . equals ( VAR_3 , ( ( org . VAR_1 . values . VAR_2 . TYPE_2 ) value ) . VAR_3 ) ; } else { return super . equals ( value ) ; } } 
static TYPE_1 METHOD_1 ( byte [ ] VAR_1 ) { int VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 [ 1 ] ) ; int VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 [ 2 ] ) ; int VAR_4 = TYPE_2 . METHOD_2 ( VAR_1 [ 3 ] ) ; <START> int VAR_5 = TYPE_2 . METHOD_2 ( VAR_1 [ 5 ] ) + ( TYPE_2 . METHOD_2 ( VAR_1 [ 4 ] ) < < INT_1 ) ; <END> return new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; } 
public static TYPE_1 get ( String VAR_1 ) { if ( TYPE_1 . VAR_2 . VAR_1 . equals ( VAR_1 ) ) { return TYPE_1 . VAR_2 ; } else if ( TYPE_1 . TYPE_3 . VAR_1 . equals ( VAR_1 ) ) { return TYPE_1 . TYPE_3 ; } else { <START> throw new TYPE_2 ( STRING_1 + VAR_1 ) ; <END> } } 
public synchronized TYPE_1 get ( String name ) { boolean VAR_1 = name == null ; <START> if ( VAR_2 != null && VAR_1 != VAR_2 . METHOD_1 ( ) ) <END> { throw METHOD_2 ( ) ; } if ( name == null ) { return TYPE_1 . VAR_3 ; } TYPE_1 group = VAR_4 . get ( name ) ; if ( group == null ) { throw new TYPE_2 ( STRING_1 + name + STRING_2 + METHOD_3 ( ) ) ; } return group ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( null ) ; <START> try <END> { VAR_1 . METHOD_2 ( STRING_1 ) ; METHOD_3 ( STRING_2 ) ; } catch ( IllegalStateException e ) { } } 
private void METHOD_1 ( TYPE_1 state , long [ ] VAR_1 ) { for ( long VAR_2 : VAR_1 ) { <START> state . VAR_3 ( ) . METHOD_2 ( ) . METHOD_3 ( state . VAR_4 ( ) , TYPE_2 . VAR_6 , VAR_2 ) ; <END> } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; try ( TYPE_2 < TYPE_3 , TYPE_3 > index = index ( ) . METHOD_2 ( VAR_1 ) . build ( ) ) { VAR_1 . METHOD_3 ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { <START> } <END> index . VAR_2 ( METHOD_4 ( ) ) ; assertEquals ( 1 , VAR_1 . count ( ) ) ; } } 
<START> static final File METHOD_1 ( File VAR_1 ) <END> { return path ( VAR_1 , STRING_1 , STRING_2 ) ; } 
<START> public TYPE_3 ( TYPE_1 source , int VAR_2 , TYPE_2 VAR_3 ) <END> { this . source = source ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( T obj ) { TYPE_1 < T > VAR_1 = VAR_2 . get ( ) ; <START> if ( VAR_1 . METHOD_1 ( obj ) ) <END> { } else { VAR_3 . METHOD_1 ( obj ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws Exception { <START> VAR_2 = new TYPE_3 ( 100 , ( VAR_3 , VAR_4 ) - > VAR_5 . apply ( VAR_3 , VAR_1 ) ) ; <END> return new TYPE_4 ( VAR_2 ) ; } 
<START> public TYPE_2 ( TYPE_1 ... VAR_2 ) <END> { this . VAR_2 = VAR_2 ; } 
<START> public TYPE_4 ( TYPE_1 state , boolean VAR_2 ) <END> { this ( state , VAR_2 , TYPE_3 . VAR_4 , TYPE_2 : : new ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , Map < Long , Collection < TYPE_2 > > VAR_3 ) { <START> super ( VAR_2 . METHOD_1 ( ) , VAR_2 . METHOD_2 ( ) ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public TYPE_1 apply ( TYPE_1 VAR_1 , TYPE_2 description ) { TYPE_3 VAR_2 = description . VAR_3 ( TYPE_3 . class ) ; if ( VAR_2 != null || VAR_4 > 1 ) { <START> return new TYPE_4 ( max ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 1 , VAR_4 ) , VAR_1 , description ) ; <END> } return VAR_1 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 ) { TYPE_2 result = new TYPE_2 ( VAR_2 . index ( ) . METHOD_2 ( VAR_1 ) ) ; <START> ArrayList < TYPE_2 > VAR_3 = new ArrayList < > ( ) ; <END> VAR_3 . add ( result ) ; return VAR_3 . stream ( ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 , ANNOTATION_1 ( STRING_2 ) TYPE_3 node , ANNOTATION_1 ( STRING_3 ) String key , ANNOTATION_1 ( STRING_4 ) Object value ) { VAR_2 . index ( ) . METHOD_2 ( VAR_1 ) . add ( node , key , value ) ; List < TYPE_2 > results = new ArrayList < > ( 1 ) ; results . add ( new TYPE_2 ( true ) ) ; <START> return results . stream ( ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 , TYPE_1 > TYPE_4 ) { <START> return TYPE_5 . METHOD_2 ( VAR_1 . METHOD_3 ( ) . map ( TYPE_4 : : apply ) . collect ( Collectors . VAR_2 ( ) ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 , TYPE_2 < TYPE_3 > VAR_3 ) { if ( VAR_4 != null ) { VAR_4 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <START> } <END> } 
public void METHOD_1 ( ) throws Throwable { long VAR_1 = 100 ; int count = 5 ; VAR_2 . start ( ) ; VAR_3 . METHOD_2 ( VAR_4 , VAR_5 , VAR_1 , VAR_6 ) ; <START> METHOD_3 ( ) ; <END> METHOD_4 ( count ) ; VAR_3 . METHOD_5 ( ) ; int VAR_7 = VAR_8 . get ( ) ; METHOD_6 ( VAR_1 * 2 ) ; assertThat ( VAR_8 . get ( ) , METHOD_7 ( VAR_7 ) ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( new TYPE_1 ( IllegalArgumentException . VAR_2 ) ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; db . execute ( STRING_2 ) ; <START> METHOD_4 ( STRING_3 ) ; <END> } 
private void METHOD_1 ( ) { <START> VAR_1 . forEach ( VAR_2 - > METHOD_2 ( VAR_2 , VAR_2 . METHOD_3 ( ) ) ) ; <END> } 
public static < T > long count ( TYPE_1 < T > VAR_1 , TYPE_2 < T > filter ) { <START> try ( TYPE_3 < T > iterator = TYPE_4 . METHOD_1 ( VAR_1 . iterator ( ) ) ) <END> { return TYPE_4 . count ( iterator , filter ) ; } } 
<START> TYPE_1 ( ) <END> { this ( new HashMap < > ( ) ) ; } 
public static TYPE_1 path ( TYPE_2 [ ] VAR_1 , TYPE_3 [ ] VAR_2 ) { assert VAR_1 != null ; assert VAR_2 != null ; <START> if ( VAR_1 . length + VAR_2 . length % 2 == 0 ) <END> { throw new IllegalArgumentException ( STRING_1 ) ; } return new TYPE_1 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( long length , long VAR_1 , long VAR_2 ) { TYPE_1 VAR_3 = METHOD_2 ( METHOD_3 ( length ) , VAR_1 ) ; <START> VAR_3 . METHOD_4 ( length - 1 ) ; <END> return VAR_3 ; } 
public TYPE_2 ( TYPE_1 VAR_2 , long length , byte [ ] VAR_3 , long VAR_4 ) throws IOException { <START> super ( VAR_2 , VAR_3 . length , length , 0 , VAR_4 ) ; <END> this . VAR_3 = VAR_3 ; METHOD_1 ( - 1 ) ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 , File VAR_3 ) <END> { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 , long length , long VAR_3 , long VAR_4 ) throws IOException <END> { super ( VAR_2 , Long . VAR_5 , length , VAR_3 , VAR_4 ) ; } 
protected int offset ( long index ) { <START> return METHOD_1 ( METHOD_2 ( index ) % VAR_1 ) * VAR_2 ; <END> } 
public static TYPE_1 METHOD_1 ( Class < ? > VAR_1 ) throws IOException { TYPE_2 VAR_2 = new TYPE_2 ( ) ; TYPE_3 VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 ) ; File VAR_4 = VAR_3 . METHOD_3 ( STRING_1 ) ; <START> VAR_2 . METHOD_4 ( VAR_4 ) ; <END> TYPE_4 VAR_5 = TYPE_5 . METHOD_5 ( VAR_2 ) ; return new TYPE_1 ( VAR_5 , VAR_2 , VAR_4 ) ; } 
public void METHOD_1 ( File VAR_1 , File VAR_2 , String VAR_3 , String VAR_4 ) throws IOException { if ( VAR_5 ) { METHOD_2 ( VAR_6 ) ; } <START> METHOD_2 ( TYPE_1 . METHOD_3 ( VAR_2 ) ) ; <END> } 
public final boolean equals ( Object VAR_1 ) { if ( VAR_1 == null ) { return false ; } try { <START> if ( ( ( TYPE_1 ) VAR_1 ) . METHOD_1 ( ) && this . METHOD_1 ( ) ) <END> { return ( ( TYPE_2 ) this ) . equals ( ( TYPE_2 ) VAR_1 ) ; } return VAR_1 instanceof TYPE_3 && equals ( ( TYPE_3 ) VAR_1 ) ; } catch ( TYPE_4 e ) { return false ; } } 
private File METHOD_1 ( String VAR_1 , File VAR_2 ) { <START> File VAR_3 = null ; <END> boolean VAR_4 = false ; for ( File file : VAR_2 . METHOD_2 ( ) ) { if ( file . getName ( ) . equals ( VAR_1 ) ) { VAR_3 = file ; VAR_4 = true ; break ; } } if ( ! VAR_4 ) { METHOD_3 ( STRING_1 + VAR_1 ) ; } return VAR_3 ; } 
public void METHOD_1 ( ) { <START> VAR_1 = VAR_2 = VAR_3 = VAR_4 = VAR_5 = false ; <END> } 
public boolean equals ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == null || ! ( VAR_1 instanceof TYPE_2 ) ) <END> { return false ; } TYPE_2 that = ( TYPE_2 ) VAR_1 ; return size ( ) == that . size ( ) && Arrays . equals ( VAR_2 , that . VAR_2 ) && Arrays . equals ( VAR_3 , that . VAR_3 ) ; } 
<START> public TYPE_9 ( TYPE_1 VAR_2 , TYPE_2 cache , int VAR_3 , <END> TYPE_5 . TYPE_6 VAR_4 , TYPE_7 . TYPE_8 VAR_5 ) { this . VAR_2 = VAR_2 ; this . cache = cache ; this . VAR_6 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_7 = new long [ VAR_3 + 1 ] ; this . VAR_5 = VAR_5 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , long ... VAR_2 ) { VAR_3 . METHOD_2 ( this ) ; try { TYPE_2 < TYPE_3 > VAR_4 = METHOD_3 ( VAR_1 ) ; for ( long VAR_5 : VAR_2 ) { TYPE_3 resource = VAR_4 . get ( VAR_5 ) ; if ( resource . VAR_6 ( ) != 0 ) { <START> return ; <END> } VAR_4 . remove ( VAR_5 ) ; VAR_7 . METHOD_4 ( new TYPE_3 ( VAR_1 , VAR_5 ) , VAR_8 ) ; } } finally { VAR_3 . METHOD_5 ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { byte [ ] VAR_2 = VAR_3 ; VAR_1 . METHOD_2 ( TYPE_2 . VAR_5 ) ; int VAR_6 = VAR_1 . METHOD_3 ( ) - VAR_1 . METHOD_4 ( ) ; if ( VAR_2 . length + VAR_7 > VAR_6 ) { <START> VAR_2 = Arrays . VAR_8 ( VAR_2 , VAR_6 - 2 ) ; <END> } VAR_1 . METHOD_5 ( ( short ) VAR_2 . length ) ; VAR_1 . METHOD_6 ( VAR_2 ) ; } 
public void METHOD_1 ( long id ) { if ( VAR_1 . METHOD_2 ( ) ) { VAR_2 . METHOD_1 ( id ) ; <START> } <END> } 
public void METHOD_1 ( long id ) { <START> VAR_1 . METHOD_1 ( id ) ; <END> } 
public boolean equals ( Object VAR_1 ) { <START> return false ; <END> } 
public boolean equals ( TYPE_1 VAR_1 ) { <START> return false ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> return new TYPE_2 ( Arrays . asList ( VAR_1 ) ) ; <END> } 
<START> public TYPE_2 ( File file , File VAR_2 , TYPE_1 VAR_3 ) <END> { this . file = file ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws Throwable { <START> System . out . println ( Thread . VAR_3 ( ) . getName ( ) + STRING_1 ) ; <END> VAR_4 . METHOD_2 ( ) ; } 
private static Long METHOD_1 ( String VAR_1 ) { if ( VAR_1 != null ) { <START> if ( VAR_1 . METHOD_2 ( STRING_1 ) ) <END> { int VAR_2 = Integer . parseInt ( VAR_1 . substring ( 0 , VAR_1 . length ( ) - 1 ) ) ; return METHOD_3 ( VAR_2 ) ; } return TYPE_1 . METHOD_4 ( VAR_1 ) ; } return null ; } 
<START> public static long METHOD_1 ( int VAR_1 ) <END> { if ( VAR_1 < 1 ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; } if ( VAR_1 > 100 ) { throw new IllegalArgumentException ( STRING_2 + VAR_1 ) ; } long VAR_2 = TYPE_1 . METHOD_2 ( ) ; if ( VAR_2 == TYPE_1 . VAR_3 ) { throw new TYPE_2 ( STRING_3 ) ; } double VAR_4 = VAR_1 / FLOAT_1 ; return METHOD_3 ( ( VAR_2 - TYPE_3 . METHOD_4 ( ) . METHOD_5 ( ) ) * VAR_4 ) ; } 
public static boolean METHOD_1 ( long VAR_1 ) { <START> long s , n ; <END> for ( ; ; ) { s = METHOD_2 ( VAR_1 ) ; boolean VAR_2 = ( s & VAR_3 ) != 0 ; boolean VAR_4 = ( s & VAR_5 ) == VAR_5 ; if ( VAR_2 | VAR_4 ) { return METHOD_3 ( s , VAR_4 ) ; } n = s + VAR_6 | VAR_7 ; if ( METHOD_4 ( VAR_1 , s , n ) ) { TYPE_1 . METHOD_5 ( ) ; return true ; } } } 
public void METHOD_1 ( ) throws IOException { monitor . VAR_1 ( ) ; boolean VAR_2 = METHOD_2 ( ) ; boolean VAR_3 ; try { VAR_4 = ! VAR_2 ; if ( ! VAR_2 ) { monitor . VAR_5 ( ) ; } VAR_3 = METHOD_3 ( ) ; } catch ( TYPE_1 e ) { VAR_3 = true ; } if ( VAR_3 ) { monitor . VAR_6 ( ) ; METHOD_4 ( ) ; METHOD_3 ( ) ; } if ( VAR_3 || ! VAR_2 ) <START> { <END> VAR_4 = true ; } } 
public void close ( ) throws IOException { VAR_1 . METHOD_1 ( ) ; try { if ( VAR_2 ) { return ; } <START> VAR_2 = true ; <END> writer . close ( ) ; VAR_3 . close ( ) ; } finally { VAR_1 . METHOD_2 ( ) ; } } 
public TYPE_2 ( <START> Map < Long , TYPE_1 > VAR_2 ) <END> { this ( VAR_2 , METHOD_1 ( VAR_2 ) , METHOD_2 ( VAR_2 ) ) ; } 
<START> public static < TYPE_1 extends Exception > void METHOD_1 ( TYPE_2 < TYPE_1 > f , Class VAR_1 ) throws <END> Exception { try { f . apply ( ) ; METHOD_2 ( STRING_1 + VAR_1 + STRING_2 ) ; } catch ( Exception e ) { if ( ! VAR_1 . METHOD_3 ( e ) ) { METHOD_2 ( STRING_3 + e . getClass ( ) + STRING_4 + VAR_1 ) ; } } } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { if ( ! VAR_1 . METHOD_2 ( ) . type ( ) . METHOD_3 ( ) ) { throw new IllegalStateException ( STRING_1 + VAR_1 ) ; <START> } <END> return VAR_1 . METHOD_2 ( ) ; } 
private int [ ] METHOD_1 ( ) { return VAR_1 . keySet ( ) . stream ( ) . METHOD_2 ( this : : METHOD_1 ) . METHOD_3 ( ) . METHOD_4 ( ) ; <START> } <END> 
<START> public static boolean METHOD_1 ( <END> TYPE_1 < TYPE_2 > VAR_1 , int [ ] VAR_2 ) { for ( int VAR_3 : VAR_2 ) { if ( ! VAR_1 . containsKey ( VAR_3 ) ) { return false ; } } return true ; } 
private TYPE_1 METHOD_1 ( int VAR_1 , int VAR_2 , TYPE_2 index ) throws TYPE_3 { try { final int VAR_3 = VAR_1 ; <START> final int [ ] VAR_4 = new int [ ] { VAR_2 } ; <END> return VAR_5 . METHOD_2 ( TYPE_4 . METHOD_3 ( VAR_3 , VAR_4 ) ) ; } catch ( TYPE_5 e ) { throw new TYPE_3 ( Status . TYPE_7 . TYPE_6 , e , STRING_1 , index ) ; } } 
public static String [ ] METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 { int [ ] VAR_3 = <START> false ? VAR_2 . METHOD_2 ( ) : new int [ ] { VAR_2 . METHOD_3 ( ) } ; <END> String [ ] VAR_4 = new String [ VAR_3 . length ] ; for ( int i = 0 ; i < VAR_3 . length ; i ++ ) { VAR_4 [ i ] = VAR_1 . METHOD_4 ( VAR_3 [ i ] ) ; } return VAR_4 ; } 
public static String [ ] METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { int [ ] VAR_3 = <START> false ? VAR_2 . METHOD_2 ( ) : new int [ ] { VAR_2 . METHOD_3 ( ) } ; <END> String [ ] VAR_4 = new String [ VAR_3 . length ] ; for ( int i = 0 ; i < VAR_3 . length ; i ++ ) { VAR_4 [ i ] = VAR_1 . METHOD_4 ( VAR_3 [ i ] ) ; } return VAR_4 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 , int VAR_3 ) { try { final int VAR_4 = VAR_3 ; <START> final int [ ] VAR_5 = new int [ ] { VAR_2 } ; <END> TYPE_1 VAR_6 = VAR_1 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_4 , VAR_5 ) ) ; if ( VAR_1 . METHOD_4 ( VAR_6 ) == TYPE_6 . VAR_8 ) { return VAR_6 ; } } catch ( TYPE_4 | TYPE_5 e ) { } return null ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( ) ; VAR_2 = VAR_1 . METHOD_3 ( VAR_3 ) ; VAR_4 = VAR_1 . METHOD_4 ( VAR_5 ) ; final int VAR_6 = VAR_2 ; final int [ ] VAR_7 = new int [ ] { VAR_4 } ; <START> VAR_8 = TYPE_2 . METHOD_5 ( VAR_6 , VAR_7 ) ; <END> commit ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { <START> return VAR_2 . METHOD_2 ( TYPE_4 . METHOD_3 ( VAR_1 ) ) . METHOD_4 ( ) ; <END> } 
private boolean METHOD_1 ( ) { <START> return VAR_1 | VAR_2 | VAR_3 ; <END> } 
public void METHOD_1 ( ) throws Throwable { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 VAR_2 = METHOD_3 ( TYPE_2 . class ) ; VAR_3 . METHOD_4 ( ) ; VAR_4 . execute ( ( TYPE_6 . TYPE_7 < TYPE_4 , TYPE_4 > ) state - > { METHOD_5 ( VAR_1 ) ; return null ; } ) ; VAR_5 . METHOD_6 ( TYPE_5 . class ) ; <START> VAR_1 . METHOD_7 ( TYPE_8 . Type . VAR_7 , VAR_2 , INT_1 ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> assert VAR_2 . METHOD_2 ( ) . length == VAR_3 . values ( ) . length ; <END> String VAR_4 = VAR_1 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; if ( VAR_5 == VAR_6 ) { return format ( STRING_1 , VAR_7 , VAR_4 , METHOD_5 ( VAR_1 , VAR_2 . METHOD_2 ( ) ) ) ; } else { return format ( STRING_2 , VAR_7 , VAR_5 , VAR_4 , METHOD_5 ( VAR_1 , VAR_2 . METHOD_2 ( ) ) ) ; } } 
public Object METHOD_1 ( ) { assert VAR_1 . values ( ) . length == 1 ; <START> return VAR_1 . values ( ) [ 0 ] ; <END> } 
private void METHOD_1 ( Object ... values ) { METHOD_2 ( ) ; for ( int i = 0 ; i < values . length ; i ++ ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_3 ( values [ i ] ) ; TYPE_2 VAR_2 = METHOD_4 ( i , STRING_1 , VAR_1 , values [ i ] ) ; VAR_3 . add ( VAR_2 ) ; } <START> } <END> 
private void METHOD_1 ( Object ... values ) { if ( values . length == 1 ) { METHOD_2 ( values [ 0 ] ) ; return ; <START> } <END> METHOD_3 ( ) ; for ( int i = 0 ; i < values . length ; i ++ ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_4 ( values [ i ] ) ; TYPE_2 VAR_2 = METHOD_5 ( i , STRING_1 , VAR_1 , values [ i ] ) ; VAR_3 . add ( VAR_2 ) ; } } 
private void METHOD_1 ( Collection < TYPE_1 > data ) throws IOException { TYPE_1 [ ] VAR_1 = data . VAR_2 ( new TYPE_1 [ data . size ( ) ] ) ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <START> TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( ( long ) i , VAR_1 [ i ] . value ) ; <END> index . VAR_4 ( ) . METHOD_3 ( VAR_3 ) ; } index . VAR_5 ( ) ; } 
private Object [ ] METHOD_1 ( int n ) { <START> return n == 0 ? new Object [ ] { STRING_1 } : METHOD_1 ( n - 1 ) ; <END> } 
public TYPE_5 ( final File VAR_2 ) { try { this . reader = new TYPE_1 ( new TYPE_2 ( VAR_2 ) ) ; this . VAR_3 = VAR_2 . getName ( ) ; } catch ( TYPE_3 ex ) { <START> throw new TYPE_4 ( STRING_1 + VAR_3 + STRING_2 , ex ) ; <END> } } 
<START> private File METHOD_1 ( ) { <END> final String VAR_1 = System . getProperty ( STRING_1 ) ; if ( VAR_1 == null ) { return new File ( TYPE_1 . get ( ) . METHOD_2 ( ) , STRING_2 ) ; } else { return new File ( VAR_1 ) ; } } 
public TYPE_1 ( String VAR_2 , String VAR_3 , boolean VAR_4 , int VAR_5 ) { METHOD_1 ( VAR_3 ) ; METHOD_2 ( VAR_2 ) ; <START> METHOD_3 ( VAR_4 ) ; <END> METHOD_4 ( VAR_5 ) ; } 
private static Set < String > METHOD_1 ( ) { final int VAR_1 = CHAR_1 ; final int VAR_2 = CHAR_2 ; Set < String > VAR_3 = new HashSet < > ( VAR_2 - VAR_1 + 1 ) ; <START> for ( int i = VAR_1 ; i <= VAR_2 ; i ++ ) { <END> VAR_3 . add ( TYPE_1 . toString ( ( char ) i ) ) ; } return VAR_3 ; } 
public abstract void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 filter ) throws IOException ; @Override <START> public boolean METHOD_2 ( ) { <END> return false ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 container ) { <START> TYPE_2 j = TYPE_2 . METHOD_2 ( ) ; <END> METHOD_3 ( container , j ) ; for ( TYPE_3 node : j . VAR_1 ( ) ) { METHOD_3 ( container , node ) ; } } 
<START> public static String METHOD_1 ( TYPE_1 VAR_1 ) { <END> String VAR_2 = STRING_1 ; for ( TYPE_2 e : VAR_1 . METHOD_2 ( ) ) { if ( e . VAR_3 ( ) . METHOD_3 ( ) . equals ( TYPE_3 . VAR_5 ) ) { VAR_2 = STRING_2 ; break ; } } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( String name , TYPE_2 options ) { boolean VAR_1 = options . get ( TYPE_6 . VAR_3 , true ) ; boolean VAR_4 = options . get ( TYPE_6 . VAR_5 , true ) ; if ( VAR_1 ) { try { return new TYPE_3 ( name , VAR_4 ) ; } catch ( TYPE_4 e ) { } <START> } <END> int VAR_6 = options . get ( TYPE_6 . VAR_7 , INT_1 ) ; return new TYPE_5 ( name , VAR_6 , VAR_4 ) ; } 
private static String METHOD_1 ( String s ) { try { return TYPE_1 . METHOD_2 ( s , TYPE_4 . TYPE_5 . name ( ) ) <START> . METHOD_3 ( STRING_1 , STRING_2 ) . METHOD_3 ( STRING_3 , STRING_4 ) . METHOD_3 ( STRING_5 , STRING_6 ) ; <END> } catch ( TYPE_3 e ) { throw new RuntimeException ( e ) ; } } 
public TYPE_1 METHOD_1 ( final TYPE_2 state , final TYPE_3 params ) { <START> if ( state != null ) params . put ( STRING_1 , state . getType ( ) ) ; <END> return METHOD_2 ( TYPE_1 . VAR_1 , TYPE_1 . class , params ) ; } 
public int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , <START> VAR_9 , <END> VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 , VAR_16 , VAR_17 , VAR_18 , VAR_19 ) ; } 
<START> protected void METHOD_1 ( ) { <END> List < String > VAR_1 = new ArrayList < String > ( ) ; Set < TYPE_1 > VAR_2 = METHOD_2 ( VAR_1 ) ; this . VAR_3 . clear ( ) ; this . VAR_3 . addAll ( VAR_2 ) ; } 
public TYPE_1 ( String VAR_2 , Class VAR_3 ) { this ( <START> VAR_2 , <END> VAR_3 , VAR_2 . contains ( STRING_1 ) ? VAR_2 . substring ( VAR_2 . METHOD_1 ( STRING_1 ) + INT_1 ) : VAR_2 ) ; } 
<START> public TYPE_1 ( String VAR_2 , Class VAR_3 , String VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_5 . put ( VAR_4 , this ) ; } 
<START> public TYPE_2 ( String VAR_2 , Class VAR_3 ) { <END> this ( VAR_2 , VAR_3 , TYPE_1 . METHOD_1 ( VAR_2 , STRING_1 , VAR_2 ) ) ; } 
<START> public String METHOD_1 ( ) throws TYPE_1 { <END> if ( this . VAR_1 . METHOD_2 ( STRING_1 ) < 0 ) { throw new TYPE_1 ( STRING_2 ) ; } else { return getString ( STRING_3 ) ; } } 
private String METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; <START> if ( VAR_1 == null || VAR_1 . id ( ) . isEmpty ( ) ) { <END> return null ; } else { return VAR_1 . id ( ) ; } } 
public String METHOD_1 ( TYPE_1 description ) { TYPE_2 VAR_1 = description . VAR_2 ( TYPE_2 . class ) ; <START> return VAR_1 == null ? STRING_1 : VAR_1 . value ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 listener , Exception e ) { <START> logger . error ( STRING_1 + listener , e ) ; <END> } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 from , File to ) throws IOException { <START> TYPE_3 is = VAR_1 . METHOD_2 ( from ) ; <END> TYPE_4 VAR_2 = new TYPE_4 ( to ) ; TYPE_5 . METHOD_1 ( is , VAR_2 ) ; VAR_2 . close ( ) ; is . close ( ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 from , File to ) throws IOException { TYPE_3 is = null ; TYPE_4 VAR_2 = null ; <START> try { <END> is = VAR_1 . METHOD_2 ( from ) ; VAR_2 = new TYPE_4 ( to ) ; TYPE_5 . METHOD_1 ( is , VAR_2 ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( VAR_2 != null ) { VAR_2 . close ( ) ; } } } 
public static String METHOD_1 ( String message ) { <START> return message . VAR_1 ( STRING_1 , STRING_2 ) . METHOD_2 ( STRING_3 , STRING_4 ) ; <END> } 
public void METHOD_1 ( ) { if ( ! VAR_1 . get ( ) && VAR_1 . METHOD_2 ( false , true ) ) { TYPE_1 VAR_2 = METHOD_3 ( ) ; TYPE_2 . METHOD_4 ( ) . METHOD_5 ( VAR_2 ) ; METHOD_6 ( new TYPE_3 ( VAR_2 ) ) ; <START> TYPE_6 . TYPE_7 . METHOD_7 ( ( ) - > { <END> TYPE_5 . METHOD_8 ( ) ; this . METHOD_9 ( ) ; } ) ; } } 
private void log ( String VAR_1 , TYPE_1 VAR_2 ) { Set < TYPE_1 > VAR_3 = TYPE_2 . METHOD_1 ( VAR_1 , VAR_4 - > new TYPE_3 < > ( ) ) ; <START> if ( VAR_3 . size ( ) >= VAR_5 ) { <END> VAR_3 . add ( VAR_2 ) ; } else { logger . warn ( STRING_1 ) ; METHOD_2 ( VAR_1 , VAR_3 ) ; VAR_3 . add ( VAR_2 ) ; } } 
public static boolean METHOD_1 ( String VAR_1 ) { <START> return METHOD_2 ( VAR_1 ) || Boolean . VAR_2 . toString ( ) . equals ( VAR_1 ) ; <END> } 
protected void METHOD_1 ( Integer value ) { <START> if ( value != null && VAR_1 == null ) { <END> this . VAR_1 = value ; } } 
private void METHOD_1 ( TYPE_1 url , TYPE_2 properties , String VAR_1 ) { String VAR_2 = url . VAR_3 ( VAR_1 ) ; <START> if ( VAR_2 != null && VAR_2 . length ( ) != 0 ) { <END> properties . VAR_4 ( VAR_1 , VAR_2 ) ; } } 
private TYPE_1 METHOD_1 ( String key , String group ) { <START> String VAR_1 = METHOD_2 ( key ) ; <END> TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_3 ( VAR_1 , group ) ; return VAR_2 ; } 
public void run ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = TYPE_2 . METHOD_1 ( VAR_3 ) ; <START> if ( VAR_2 . METHOD_2 ( ) ) { <END> return ; } Response VAR_4 = new Response ( VAR_2 . getId ( ) ) ; VAR_4 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ? Response . VAR_5 : Response . VAR_6 ) ; VAR_4 . METHOD_5 ( VAR_2 . METHOD_6 ( true ) ) ; TYPE_2 . METHOD_7 ( VAR_2 . METHOD_8 ( ) , VAR_4 , true ) ; } 
public boolean METHOD_1 ( Type type , Class < ? > VAR_1 ) { if ( VAR_1 == null ) { return false ; } <START> if ( TYPE_1 . class . METHOD_2 ( VAR_1 ) ) { <END> return true ; } return false ; } 
public void METHOD_1 ( String VAR_1 , String group , String VAR_2 ) { String VAR_3 = VAR_4 . get ( VAR_1 ) ; TYPE_1 event = new TYPE_1 ( VAR_1 , VAR_2 , METHOD_2 ( VAR_2 , VAR_3 ) ) ; <START> VAR_4 . put ( VAR_1 , VAR_2 ) ; <END> VAR_5 . forEach ( listener - > listener . VAR_6 ( event ) ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> this . VAR_2 = new ArrayList < > ( Arrays . asList ( new TYPE_1 [ ] { new TYPE_1 ( VAR_1 ) } ) ) ; <END> } 
public boolean METHOD_1 ( ) { long VAR_1 = System . currentTimeMillis ( ) ; if ( VAR_1 > VAR_2 + VAR_3 ) { token = METHOD_2 ( VAR_4 ) ; VAR_2 = VAR_1 ; } boolean VAR_5 = false ; <START> while ( token . VAR_6 ( ) > 0 && ! VAR_5 ) { <END> token . VAR_7 ( ) ; VAR_5 = true ; } return VAR_5 ; } 
public static String METHOD_1 ( String VAR_1 ) { <START> int i = VAR_1 . METHOD_2 ( CHAR_1 ) ; <END> return i < 0 ? VAR_1 : VAR_1 . substring ( i + 1 ) ; } 
public static int METHOD_1 ( TYPE_1 url ) { String VAR_1 = url . VAR_2 ( Constants . VAR_3 ) ; return url . VAR_2 ( Constants . VAR_4 , VAR_1 != null && <START> VAR_1 . startsWith ( STRING_1 ) ? Constants . VAR_5 : 0 ) ; <END> } 
public void METHOD_1 ( TYPE_1 ctx , Object VAR_1 ) throws Exception { TYPE_2 channel = TYPE_2 . METHOD_2 ( ctx . channel ( ) , url , VAR_2 ) ; try { <START> if ( VAR_1 instanceof TYPE_3 ) { <END> logger . info ( STRING_1 + channel ) ; channel . close ( ) ; } super . METHOD_1 ( ctx , VAR_1 ) ; } finally { TYPE_2 . METHOD_3 ( ctx . channel ( ) ) ; } } 
public void METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( false , true ) ) { return ; } <START> METHOD_3 ( ) ; <END> TYPE_1 . METHOD_4 ( ) ; METHOD_5 ( ) ; } 
private void METHOD_1 ( Set < TYPE_1 > VAR_1 , File file ) throws IOException { TYPE_2 writer = new TYPE_2 ( file , true ) ; try { for ( Iterator < TYPE_1 > iterator = VAR_1 . iterator ( ) ; iterator . hasNext ( ) ; <START> iterator . remove ( ) ) { <END> writer . write ( iterator . next ( ) . METHOD_2 ( ) ) ; writer . write ( STRING_1 ) ; } writer . VAR_2 ( ) ; } finally { writer . close ( ) ; } } 
private static void append ( StringBuilder builder , String value ) { if ( StringUtils . VAR_1 ( value ) ) { <START> builder . append ( value ) . append ( VAR_2 ) ; <END> } } 
public String METHOD_1 ( String path ) { try { byte [ ] VAR_1 = client . VAR_2 ( ) . METHOD_2 ( path ) ; if ( VAR_1 == null || VAR_1 . length == 0 ) { return null ; } <START> return new String ( VAR_1 , VAR_3 ) ; <END> } catch ( TYPE_1 e ) { } catch ( TYPE_2 e ) { } catch ( Exception e ) { throw new IllegalStateException ( e . getMessage ( ) , e ) ; } return null ; } 
public String METHOD_1 ( String path ) { try { byte [ ] VAR_1 = client . VAR_2 ( ) . METHOD_2 ( path ) ; return ( VAR_1 == null || VAR_1 . length == 0 ) ? null : new String ( VAR_1 , VAR_3 ) ; <START> } catch ( TYPE_1 e ) { <END> } catch ( TYPE_2 e ) { } catch ( Exception e ) { throw new IllegalStateException ( e . getMessage ( ) , e ) ; } return null ; } 
private boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) != null && METHOD_2 ( ) . METHOD_3 ( ) != null && METHOD_2 ( ) . METHOD_3 ( ) . isEmpty ( ) ; <END> } 
static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null || VAR_1 . METHOD_2 ( ) ) { return false ; } String name = VAR_1 . METHOD_3 ( ) ; return ( name != null && ! Constants . VAR_2 . equals ( name ) && ! Constants . VAR_3 . equals ( name ) <START> && TYPE_2 . matcher ( name ) . METHOD_4 ( ) ) ; <END> } 
default Object getProperty ( String key , Object VAR_1 ) { Object value = VAR_2 ( key ) ; if ( value == null ) { value = VAR_1 ; } <START> return value ; <END> } 
public static boolean METHOD_1 ( TYPE_1 url ) { return TYPE_2 . equals ( url . VAR_1 ( Constants . VAR_2 , TYPE_2 ) ) && ! TYPE_3 . equals ( url . VAR_3 ( ) ) <START> && ! TYPE_4 . equals ( url . VAR_3 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { <START> if ( VAR_1 <= 0 ) { <END> return null ; } if ( VAR_2 == null || VAR_3 != VAR_1 ) { synchronized ( this ) { if ( VAR_2 == null || VAR_3 != VAR_1 ) { VAR_2 = new TYPE_1 ( VAR_1 ) ; VAR_3 = VAR_1 ; } } } return VAR_2 ; } 
<START> public void METHOD_1 ( Level VAR_1 ) { <END> } 
<START> public void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( VAR_2 ) ; assert VAR_1 . METHOD_3 ( ) . contains ( VAR_2 ) ; VAR_1 . METHOD_3 ( ) . clear ( ) ; List < TYPE_1 > VAR_3 = METHOD_4 ( ) ; for ( TYPE_1 url : VAR_3 ) { VAR_1 . METHOD_2 ( url ) ; } Assert . assertThat ( VAR_1 . METHOD_3 ( ) . size ( ) , TYPE_2 . METHOD_5 ( VAR_3 . size ( ) ) ) ; } 
<START> private String METHOD_1 ( ANNOTATION_1 String VAR_1 ) { <END> return VAR_1 != null ? VAR_1 : STRING_1 ; } 
<START> public Long METHOD_1 ( ) { <END> return VAR_1 ; } 
private static Map < String , String > METHOD_1 ( String VAR_1 ) { <START> TYPE_1 VAR_2 = new TYPE_2 ( ) . METHOD_2 ( ) . METHOD_3 ( ) . create ( ) ; <END> try { return VAR_2 . METHOD_1 ( METHOD_4 ( VAR_1 , TYPE_3 . name ( ) ) , VAR_3 ) ; } catch ( TYPE_4 e ) { throw new IllegalStateException ( e ) ; } } 
private void METHOD_1 ( TYPE_2 . TYPE_3 action ) { action . VAR_1 ( STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 + STRING_7 + STRING_8 + STRING_9 + STRING_10 + <START> STRING_11 ) <END> . METHOD_2 ( getClass ( ) . METHOD_3 ( STRING_12 ) ) . METHOD_4 ( STRING_13 ) . METHOD_5 ( this ) ; METHOD_6 ( action ) ; } 
private Optional < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_4 . TYPE_5 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; if ( VAR_2 != null ) { if ( VAR_2 . METHOD_5 ( ) == 0 ) { return METHOD_6 ( VAR_1 , VAR_2 . METHOD_7 ( ) ) ; } return METHOD_8 ( VAR_1 , VAR_2 ) ; } LOGGER . trace ( STRING_1 , VAR_1 . getKey ( ) ) ; <START> return METHOD_6 ( VAR_1 , false ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_4 . TYPE_5 VAR_1 ) { try ( TYPE_3 VAR_2 = VAR_3 . METHOD_2 ( false ) ) { <START> VAR_4 . METHOD_3 ( VAR_5 . METHOD_4 ( VAR_2 ) ) ; <END> TYPE_1 VAR_6 = METHOD_5 ( VAR_2 , VAR_7 . METHOD_6 ( ) ) ; METHOD_7 ( VAR_1 , VAR_6 ) ; VAR_4 . METHOD_8 ( VAR_6 ) ; return VAR_6 ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { <START> VAR_3 . METHOD_2 ( VAR_4 . METHOD_3 ( VAR_1 ) ) ; <END> Optional < TYPE_3 > VAR_5 = VAR_6 . METHOD_4 ( ) . METHOD_5 ( VAR_1 , VAR_2 ) ; METHOD_6 ( VAR_5 . isPresent ( ) , STRING_1 , VAR_2 ) ; return TYPE_1 . from ( VAR_5 . get ( ) ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 == null , STRING_1 ) ; this . VAR_2 = Optional . of ( VAR_1 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String name ) { List < String > VAR_3 = new ArrayList < > ( ) ; METHOD_2 ( VAR_1 , VAR_2 , name , VAR_3 ) ; <START> METHOD_3 ( VAR_3 . isEmpty ( ) , VAR_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) . METHOD_1 ( ) ; <START> METHOD_3 ( VAR_2 != null , STRING_1 ) ; <END> return VAR_2 ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; <START> db . VAR_2 ( STRING_1 ) ; <END> db . commit ( ) ; } 
public void METHOD_1 ( Context context ) { <START> System . err . println ( STRING_1 + VAR_1 . length ) ; <END> TYPE_1 VAR_2 = context . VAR_3 ( STRING_2 ) ; Arrays . stream ( VAR_1 ) . forEach ( action - > action . VAR_4 ( VAR_2 ) ) ; VAR_2 . METHOD_2 ( ) ; } 
private void METHOD_1 ( Set < String > VAR_1 ) { <START> for ( String VAR_2 : VAR_1 ) { <END> TYPE_1 . METHOD_2 ( VAR_2 ) ; } } 
<START> public boolean METHOD_1 ( ) { <END> return ! METHOD_2 ( ) . isEmpty ( ) ; } 
<START> public List < String > METHOD_1 ( ) { <END> List < String > VAR_1 = new ArrayList < > ( ) ; for ( File file : METHOD_2 ( this . VAR_2 ) ) { VAR_1 . add ( file . getName ( ) ) ; } return VAR_1 ; } 
<START> protected void METHOD_1 ( String key ) { <END> if ( ! VAR_1 . METHOD_2 ( key ) ) { throw new IllegalArgumentException ( format ( STRING_1 , key ) ) ; } } 
<START> private String METHOD_1 ( String VAR_1 , String VAR_2 ) { <END> METHOD_2 ( VAR_1 , STRING_1 , VAR_2 ) ; METHOD_3 ( ! VAR_1 . isEmpty ( ) , STRING_2 , VAR_2 ) ; return VAR_1 ; } 
<START> public void METHOD_1 ( ) throws IOException { <END> File VAR_1 = VAR_2 . METHOD_2 ( ) ; String VAR_3 = STRING_1 ; String VAR_4 = STRING_2 ; TYPE_1 VAR_5 = METHOD_3 ( VAR_6 , STRING_3 + VAR_4 , VAR_7 , STRING_4 ) ; VAR_5 . METHOD_4 ( VAR_8 , VAR_1 , VAR_3 ) ; METHOD_5 ( VAR_5 , VAR_1 , VAR_3 , VAR_4 , INT_1 ) ; } 
public TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( Collection < TYPE_2 > VAR_1 , Collection < TYPE_3 > VAR_2 ) { TYPE_1 < TYPE_2 , TYPE_3 > VAR_3 = new TYPE_1 < > ( VAR_1 , VAR_2 ) ; <START> METHOD_2 ( VAR_3 , TYPE_4 : : new , true ) ; <END> METHOD_2 ( VAR_3 , TYPE_5 : : new , true ) ; return VAR_3 ; } 
private void METHOD_1 ( Set < String > VAR_1 ) { TYPE_1 < TYPE_2 > . TYPE_3 VAR_3 = VAR_4 . METHOD_2 ( ) ; try { for ( String VAR_5 : VAR_1 ) { <START> List < TYPE_2 > VAR_6 = VAR_7 . METHOD_3 ( VAR_5 , false ) ; <END> for ( TYPE_2 VAR_8 : VAR_6 ) { VAR_8 . METHOD_4 ( true ) ; VAR_8 . METHOD_5 ( false ) ; VAR_9 . METHOD_6 ( VAR_8 ) ; VAR_3 . append ( VAR_8 ) ; } } } finally { VAR_3 . close ( ) ; } } 
public void METHOD_1 ( TYPE_1 request , Response response ) { try ( TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( false ) ) { <START> long VAR_3 = request . VAR_4 ( VAR_5 ) ; <END> TYPE_3 VAR_6 = VAR_7 . METHOD_3 ( VAR_1 ) ; VAR_8 . METHOD_4 ( VAR_9 , VAR_6 ) ; VAR_2 . METHOD_5 ( ) . METHOD_6 ( VAR_7 . METHOD_7 ( VAR_1 , VAR_3 ) , VAR_1 ) ; VAR_1 . commit ( ) ; response . VAR_10 ( ) ; } } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } <START> if ( ! ( o instanceof TYPE_1 ) ) { <END> return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) o ; return TYPE_2 . METHOD_1 ( VAR_2 , VAR_1 . VAR_2 ) && TYPE_2 . METHOD_1 ( VAR_3 , VAR_1 . VAR_3 ) && TYPE_2 . METHOD_1 ( VAR_4 , VAR_1 . VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 user ) { <START> METHOD_2 ( VAR_1 ) . METHOD_3 ( VAR_2 . METHOD_4 ( ) , user . VAR_3 ( ) ) ; <END> } 
public void start ( ) { <START> VAR_1 = this ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 = null ; <END> } 
private String METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . getId ( ) . METHOD_4 ( TYPE_1 . VAR_3 ) ; <END> } 
<START> public Optional < String > METHOD_1 ( String id ) { <END> TYPE_1 request = VAR_1 . METHOD_2 ( TYPE_4 . VAR_3 , id ) . METHOD_3 ( TYPE_4 . VAR_4 ) ; TYPE_2 response = request . get ( ) ; if ( response . VAR_5 ( ) ) { TYPE_3 field = response . VAR_6 ( TYPE_4 . VAR_4 ) ; String value = String . valueOf ( field . getValue ( ) ) ; return Optional . of ( value ) ; } return Optional . empty ( ) ; } 
<START> public void METHOD_1 ( String id , String value ) { <END> VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) . METHOD_3 ( id ) . METHOD_4 ( TYPE_1 . VAR_4 , value ) . METHOD_5 ( VAR_5 ) . get ( ) ; } 
public void close ( ) { try { <START> VAR_1 . close ( ) ; <END> } catch ( TYPE_1 e ) { LOGGER . debug ( STRING_1 , e ) ; } } 
private void METHOD_1 ( ) { <START> String VAR_1 = VAR_2 . METHOD_2 ( ) . get ( ) . METHOD_3 ( ) . get ( ) ; <END> VAR_3 = new HashMap < > ( ) ; try ( TYPE_1 VAR_4 = VAR_5 . METHOD_4 ( false ) ) { List < TYPE_2 > VAR_6 = VAR_5 . METHOD_5 ( ) . METHOD_6 ( VAR_1 , VAR_4 ) ; for ( TYPE_2 VAR_7 : VAR_6 ) { VAR_3 . put ( METHOD_7 ( VAR_7 . METHOD_8 ( ) ) , VAR_7 . METHOD_9 ( ) ) ; } } } 
public void METHOD_1 ( TYPE_1 session , String VAR_1 , boolean VAR_2 ) { METHOD_2 ( session ) . METHOD_1 ( VAR_1 , VAR_2 ) ; <START> session . VAR_3 ( TYPE_2 . class ) . METHOD_3 ( VAR_1 ) <END> . stream ( ) . filter ( VAR_4 - > ! VAR_1 . equals ( VAR_4 . METHOD_4 ( ) ) ) . forEach ( VAR_4 - > METHOD_2 ( session ) . METHOD_1 ( VAR_4 . METHOD_4 ( ) , VAR_2 ) ) ; } 
<START> private static Optional < String > METHOD_1 ( Optional < TYPE_1 > VAR_1 ) { <END> if ( ! VAR_1 . isPresent ( ) ) { return Optional . empty ( ) ; } TYPE_1 VAR_2 = VAR_1 . get ( ) ; if ( ! VAR_2 . METHOD_2 ( ) && ! VAR_2 . METHOD_3 ( ) ) { return VAR_2 . getName ( ) ; } return Optional . empty ( ) ; } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 ) { return METHOD_2 ( VAR_1 ) ; <START> } <END> 
public List < TYPE_1 > METHOD_1 ( TYPE_2 session ) { <START> return METHOD_2 ( session ) . METHOD_3 ( TYPE_3 . VAR_2 , TYPE_3 . VAR_3 , TYPE_3 . VAR_4 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 session , TYPE_1 VAR_1 ) { <START> METHOD_2 ( session ) . METHOD_1 ( METHOD_3 ( VAR_1 ) ) ; <END> return VAR_1 ; } 
<START> private String METHOD_1 ( TYPE_1 request ) { <END> return StringUtils . VAR_1 ( request . VAR_2 ( ) , request . VAR_3 ( ) + request . VAR_4 ( ) + STRING_1 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( new TYPE_2 ( db . VAR_2 ( ) , parser , VAR_3 , VAR_4 , TYPE_3 . from ( db ) ) ) ; <END> db . VAR_2 ( ) . METHOD_2 ( ) . METHOD_3 ( db . VAR_5 ( ) , VAR_6 ) ; db . commit ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String key , String VAR_2 ) { <START> return METHOD_2 ( ( ) - > VAR_3 . METHOD_3 ( ) . METHOD_4 ( VAR_1 , key ) , ( ) - > format ( STRING_1 , VAR_2 , key ) ) ; <END> } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 query ) { <START> List < Integer > VAR_2 = new ArrayList < > ( VAR_3 . METHOD_2 ( ) . METHOD_3 ( VAR_1 , query ) ) ; <END> return TYPE_4 . METHOD_4 ( VAR_2 ) . METHOD_5 ( TYPE_1 : : getId ) . METHOD_6 ( VAR_3 . METHOD_7 ( ) . METHOD_8 ( VAR_1 , VAR_2 ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 props ) { TYPE_1 ctx = VAR_1 . METHOD_2 ( ) ; ctx . VAR_2 ( ) ; METHOD_3 ( props ) ; VAR_1 . apply ( VAR_3 , props ) ; <START> VAR_1 . METHOD_4 ( ctx ) ; <END> METHOD_5 ( ctx , VAR_4 ) ; METHOD_6 ( ) ; return ctx ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> TYPE_2 . METHOD_2 ( StringUtils . VAR_2 ( VAR_1 , STRING_1 ) <= 1 , STRING_2 ) ; <END> this . VAR_1 = VAR_1 ; return this ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> VAR_3 . METHOD_4 ( ) . METHOD_5 ( VAR_2 . METHOD_6 ( ) , VAR_1 , false ) ; <END> VAR_2 . commit ( ) ; VAR_4 . METHOD_7 ( ) . METHOD_8 ( VAR_5 , VAR_1 ) ; METHOD_9 ( METHOD_10 ( VAR_1 ) . METHOD_11 ( ) ) . METHOD_12 ( STRING_1 ) ; } 
public void METHOD_1 ( TYPE_1 request , Response response ) throws Exception { METHOD_2 ( ) ; <START> List < TYPE_2 > VAR_1 = null ; <END> try ( TYPE_3 VAR_2 = VAR_3 . METHOD_3 ( false ) ) { if ( METHOD_4 ( VAR_2 ) ) { METHOD_5 ( VAR_2 ) ; METHOD_6 ( VAR_2 ) ; VAR_1 = METHOD_7 ( VAR_2 ) ; METHOD_8 ( VAR_2 ) ; VAR_2 . commit ( ) ; } } if ( VAR_1 != null ) { VAR_4 . METHOD_9 ( VAR_1 ) ; } response . VAR_5 ( ) ; } 
private static String METHOD_1 ( List < String > input ) { <START> StringBuilder VAR_1 = new StringBuilder ( ) ; <END> if ( input . isEmpty ( ) ) { return "" ; } if ( input . size ( ) == 1 ) { return VAR_1 . append ( input . get ( 0 ) ) . toString ( ) ; } return VAR_1 . append ( input . get ( 0 ) ) . append ( STRING_1 ) . toString ( ) ; } 
private void METHOD_1 ( TYPE_1 request , Response response , TYPE_2 VAR_1 , TYPE_3 group ) { <START> TYPE_5 . TYPE_6 . Builder VAR_2 = TYPE_5 . TYPE_6 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( METHOD_4 ( VAR_1 , group , 0 ) ) ; METHOD_5 ( VAR_2 . build ( ) , request , response ) ; } 
private void METHOD_1 ( TYPE_1 connection , long VAR_1 ) { try ( TYPE_2 VAR_2 = connection . VAR_3 ( STRING_1 ) ) { METHOD_2 ( 0 , VAR_1 + 1 , VAR_2 , connection , ( VAR_4 , VAR_5 ) - > VAR_4 . METHOD_3 ( 1 , String . valueOf ( VAR_5 ) ) ) ; } catch ( TYPE_3 e ) { <START> throw new RuntimeException ( STRING_2 , e ) ; <END> } } 
protected void METHOD_1 ( ) { add ( TYPE_1 . class , <START> TYPE_2 . class , <END> TYPE_3 . class , TYPE_4 . class , TYPE_5 . class ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 ) . remove ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> VAR_1 . METHOD_5 ( ) ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; VAR_2 . METHOD_2 ( ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> } 
public boolean hasNext ( ) { for ( ; ; ) { <START> if ( VAR_1 != null && VAR_1 . hasNext ( ) ) { <END> return true ; } else if ( VAR_2 . hasNext ( ) ) { VAR_1 = METHOD_1 ( ) ; } else { return false ; } } } 
<START> public List < TYPE_1 > METHOD_1 ( String VAR_1 , ANNOTATION_1 String VAR_2 ) { <END> StringBuilder url = new StringBuilder ( VAR_3 + STRING_1 + METHOD_2 ( VAR_1 ) ) ; if ( VAR_2 != null ) { url . append ( STRING_2 ) . append ( METHOD_2 ( VAR_2 ) ) ; } METHOD_3 ( ) . METHOD_4 ( VAR_4 - > url . append ( STRING_3 ) . append ( METHOD_2 ( VAR_4 ) ) ) ; return call ( url . toString ( ) ) ; } 
public void METHOD_1 ( TYPE_1 request , Response response ) throws Exception { <START> VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> TYPE_2 VAR_2 = METHOD_4 ( METHOD_5 ( request ) ) ; METHOD_6 ( VAR_2 , request , response ) ; } 
<START> private TYPE_1 METHOD_1 ( String key ) { <END> return new TYPE_1 ( ) { { METHOD_2 ( key ) ; } @Override public String toString ( ) { return getKey ( ) ; } } ; } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 . METHOD_2 ( TYPE_1 . class ) ; <END> VAR_1 . METHOD_3 ( STRING_1 ) ; TYPE_2 request = new TYPE_2 ( ) . METHOD_4 ( STRING_2 ) ; TYPE_3 . METHOD_5 ( request ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 action ) { return action . VAR_1 ( VAR_2 ) . METHOD_2 ( STRING_1 ) . METHOD_3 ( STRING_2 ) <START> . METHOD_4 ( STRING_3 ) <END> . METHOD_5 ( true ) ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> TYPE_2 VAR_2 = this . VAR_3 . METHOD_2 ( STRING_1 ) ; return VAR_2 . METHOD_3 ( new TYPE_3 ( STRING_2 ) { @Override public boolean apply ( TYPE_4 VAR_4 ) { return VAR_4 . METHOD_4 ( STRING_3 ) . METHOD_5 ( STRING_4 + VAR_1 + STRING_5 ) ; } } ) ; } 
<START> public List < TYPE_1 > METHOD_1 ( String name , Collection < String > VAR_1 , TYPE_2 session ) { <END> return METHOD_2 ( VAR_1 , input - > METHOD_3 ( session ) . METHOD_1 ( name , input ) ) ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) { VAR_3 . METHOD_2 ( getString ( R . string . VAR_4 ) ) ; VAR_5 . METHOD_3 ( 1 ) ; <START> VAR_6 . METHOD_4 ( VAR_2 ) ; <END> METHOD_5 ( VAR_1 ) ; } 
<START> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> int VAR_2 = VAR_1 . position ( ) ; List < String > VAR_3 = METHOD_2 ( VAR_2 ) ; String VAR_4 = METHOD_3 ( ) ; return new TYPE_1 ( VAR_3 , VAR_4 ) ; } 
public boolean METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { <START> if ( VAR_2 . getId ( ) . equalsIgnoreCase ( TYPE_2 ) ) { <END> return true ; } } return false ; } 
public int METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , int VAR_3 ) { <START> VAR_4 = new TYPE_2 . Builder ( this ) <END> . METHOD_2 ( TYPE_3 . VAR_6 ) . METHOD_3 ( VAR_7 ) . METHOD_4 ( VAR_8 ) . build ( ) ; VAR_4 . METHOD_5 ( ) ; return TYPE_4 . VAR_10 ; } 
public synchronized TYPE_1 < T > METHOD_1 ( TYPE_2 < T > VAR_1 ) { if ( VAR_1 == null ) { throw new TYPE_3 ( STRING_1 ) ; } <START> if ( VAR_2 . contains ( VAR_1 ) ) { <END> return this ; } VAR_2 . add ( VAR_1 ) ; return this ; } 
protected void METHOD_1 ( T VAR_1 ) { TYPE_1 < T > [ ] VAR_2 ; synchronized ( this ) { if ( METHOD_2 ( ) ) { return ; } <START> VAR_2 = VAR_3 . METHOD_3 ( new TYPE_1 [ VAR_3 . size ( ) ] ) ; <END> METHOD_4 ( ) ; } for ( int i = VAR_2 . length - 1 ; i >= 0 ; i -- ) { VAR_2 [ i ] . update ( VAR_1 ) ; } } 
public void METHOD_1 ( String VAR_1 ) { <START> super . setText ( VAR_1 ) ; <END> METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , View view , TYPE_2 parent , TYPE_2 . TYPE_4 state ) { int VAR_2 = METHOD_2 ( ) . METHOD_3 ( R . VAR_3 . VAR_4 ) ; <START> int VAR_5 = METHOD_2 ( ) . METHOD_3 ( R . VAR_3 . VAR_6 ) ; <END> VAR_1 . VAR_7 = VAR_2 ; VAR_1 . VAR_8 = VAR_2 ; VAR_1 . VAR_9 = VAR_5 ; VAR_1 . VAR_10 = VAR_5 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_1 = TYPE_1 . VAR_2 ; <END> VAR_3 . METHOD_2 ( VAR_4 ) ; VAR_5 . METHOD_3 ( null ) ; VAR_6 . METHOD_4 ( null ) ; } 
private boolean METHOD_1 ( ) { <START> return VAR_1 == null && VAR_2 == null && VAR_3 == null && VAR_4 == null ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . create ( TYPE_1 . class ) ; VAR_1 . METHOD_2 ( STRING_1 ) ; Assert . assertThat ( VAR_1 . METHOD_3 ( ) , is ( 0 ) ) ; <START> System . out . println ( VAR_1 ) ; <END> Assert . assertThat ( VAR_1 . METHOD_4 ( ) , is ( INT_1 ) ) ; Assert . assertThat ( VAR_1 . METHOD_5 ( ) , is ( 0 ) ) ; Assert . assertThat ( VAR_1 . METHOD_6 ( ) , is ( 1 ) ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 ) { <START> VAR_2 . METHOD_2 ( method , TYPE_3 . VAR_4 ) ; <END> return this ; } else { throw new IllegalStateException ( STRING_1 ) ; } } 
<START> public static < TYPE_1 extends TYPE_2 < TYPE_1 > > int METHOD_1 ( String name ) <END> { int count = 0 ; if ( name != null ) { if ( METHOD_2 ( name ) ) { name = METHOD_3 ( name ) ; } for ( char c : name . VAR_1 ( ) ) { if ( c == CHAR_1 ) { count ++ ; } } } return count ; } 
<START> public static < TYPE_1 extends TYPE_2 < TYPE_1 > > int METHOD_1 ( String name ) <END> { int count = 0 ; if ( name != null ) { for ( char c : name . VAR_1 ( ) ) { if ( c == CHAR_1 ) { count ++ ; } } } return count ; } 
private static boolean METHOD_1 ( TYPE_1 node ) { <START> if ( ( node . VAR_1 & TYPE_2 . VAR_3 ) == TYPE_2 . VAR_3 ) { return true ; } return false ; <END> } 
static String METHOD_1 ( Path path ) { return STRING_1 + TYPE_1 . METHOD_2 ( ) <START> . METHOD_3 ( TYPE_2 . METHOD_4 ( path . VAR_1 ( ) ) , TYPE_3 . VAR_3 ) <END> . toString ( ) . substring ( 0 , 10 ) ; } 
public Optional < Path > METHOD_1 ( TYPE_1 < ? extends TYPE_2 , ? > VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; Path VAR_3 = TYPE_4 . METHOD_3 ( VAR_2 , VAR_4 ) ; <START> return Optional . VAR_5 ( VAR_3 ) ; <END> } 
protected TYPE_1 METHOD_1 ( ) { return new TYPE_2 ( TYPE_3 . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) , VAR_2 , VAR_3 , <START> METHOD_4 ( ) , VAR_4 , VAR_5 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 . METHOD_2 ( ) ; <END> TYPE_3 . TYPE_4 VAR_1 = VAR_2 . METHOD_3 ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_4 ( STRING_3 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ) ; <START> TYPE_2 . METHOD_6 ( ) ; <END> TYPE_3 result = VAR_1 . METHOD_7 ( STRING_1 ) ; result . VAR_2 ( ) ; } 
private TYPE_1 METHOD_1 ( ) { File file = path . VAR_1 ( ) ; TYPE_1 model = new TYPE_1 ( ) ; model . VAR_2 ( VAR_3 ) ; if ( VAR_4 . METHOD_2 ( ) . isPresent ( ) ) { model = METHOD_1 ( VAR_4 . METHOD_2 ( ) . get ( ) . METHOD_3 ( ) , model ) ; } if ( file . VAR_5 ( ) ) { TYPE_1 VAR_6 = METHOD_1 ( file , model ) ; <START> model = METHOD_4 ( model , VAR_6 ) ; <END> } return model ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 , String ... VAR_2 ) throws IllegalArgumentException { if ( StringUtils . isEmpty ( VAR_1 ) || VAR_2 == null ) <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> return new TYPE_1 ( VAR_1 + VAR_3 + StringUtils . VAR_4 ( VAR_2 , VAR_3 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 . Context VAR_2 = TYPE_3 . METHOD_2 ( TYPE_7 . VAR_4 ) ; try { TYPE_4 VAR_5 = TYPE_5 . METHOD_3 ( ) . METHOD_4 ( ) ; TYPE_6 . getInstance ( ) . METHOD_1 ( VAR_1 , VAR_5 ) ; VAR_5 . execute ( ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } finally { <START> if ( VAR_2 != null ) { <END> VAR_2 . METHOD_5 ( ) ; } } } 
public Set < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { Set < TYPE_1 > VAR_2 = new HashSet < TYPE_1 > ( ) ; try { VAR_2 . addAll ( TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( METHOD_4 ( ) ) ) ; <START> VAR_3 . update ( VAR_2 . size ( ) ) ; <END> } catch ( Throwable e ) { VAR_1 . METHOD_5 ( e ) ; log . error ( STRING_1 + METHOD_6 ( ) , e ) ; } return VAR_2 ; } 
public static void METHOD_1 ( TYPE_1 ctx , TYPE_2 request , List < TYPE_6 . TYPE_7 > VAR_1 , TYPE_4 status ) { try { String VAR_2 = new TYPE_5 ( ) . METHOD_2 ( new TYPE_6 ( VAR_1 ) ) ; METHOD_3 ( ctx , request , VAR_2 , status ) ; } catch ( IOException e ) { <START> log . warn ( STRING_1 , e ) ; <END> METHOD_1 ( ctx , request , STRING_1 , TYPE_4 . VAR_3 ) ; } } 
public boolean METHOD_1 ( long VAR_1 ) { <START> if ( METHOD_2 ( VAR_1 ) > VAR_2 ) { <END> return true ; } else { return false ; } } 
final public void run ( ) { int VAR_1 = config . VAR_2 ( TYPE_3 . VAR_4 ) ; while ( true ) { try { Set < TYPE_1 > VAR_5 = TYPE_2 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; synchronized ( this ) { VAR_6 = VAR_5 ; <START> } <END> VAR_7 . METHOD_4 ( ) ; Thread . VAR_8 ( VAR_1 ) ; } catch ( Exception e ) { log . error ( STRING_1 + e ) ; VAR_9 . METHOD_4 ( ) ; } } } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
<START> public int METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 , <END> TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { if ( log . VAR_5 ( ) ) log . trace ( STRING_1 , VAR_4 , VAR_6 ) ; try { METHOD_2 ( VAR_2 , VAR_3 , VAR_4 ) ; VAR_1 += 1 ; } catch ( Throwable VAR_7 ) { VAR_2 . METHOD_3 ( VAR_7 ) ; VAR_2 . METHOD_4 ( ) ; log . error ( VAR_7 . getMessage ( ) , VAR_7 ) ; log . error ( STRING_2 , VAR_6 , VAR_8 ) ; } return VAR_1 ; } 
<START> public static TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { <END> TYPE_1 VAR_2 = new TYPE_3 ( ) . METHOD_2 ( VAR_1 , TYPE_1 . class ) ; return VAR_2 ; } 
<START> public static List < TYPE_1 > METHOD_1 ( String VAR_1 ) throws TYPE_2 { <END> TYPE_3 VAR_2 = new TYPE_3 ( ) ; TYPE_4 parser = new TYPE_4 ( ) ; TYPE_5 VAR_3 = parser . parse ( VAR_1 ) . METHOD_2 ( ) ; ArrayList < TYPE_1 > VAR_4 = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_6 obj : VAR_3 ) { TYPE_1 VAR_5 = VAR_2 . METHOD_3 ( obj , TYPE_1 . class ) ; VAR_4 . add ( VAR_5 ) ; } return VAR_4 ; } 
protected TYPE_4 . TYPE_5 METHOD_1 ( Long VAR_1 , Object value ) { <START> if ( value instanceof TYPE_2 || value instanceof String ) <END> return new TYPE_4 . TYPE_5 ( VAR_1 , value ) ; else return new TYPE_4 . TYPE_5 ( VAR_1 , new TYPE_3 ( value ) ) ; } 
public TYPE_4 ( long currentTimeMillis , Collection < Integer > VAR_2 ) { this . VAR_3 = currentTimeMillis ; this . VAR_4 = new TYPE_1 ( VAR_2 , METHOD_1 ( ) ) ; this . VAR_5 = new TYPE_2 ( ) ; <START> this . VAR_6 = new TYPE_3 ( ) ; <END> METHOD_2 ( ) ; } 
public Map < TYPE_1 , TYPE_2 > METHOD_1 ( final List < TYPE_1 > VAR_1 , final TYPE_3 VAR_2 , final TYPE_4 VAR_3 ) { String VAR_4 = TYPE_5 . METHOD_2 ( TYPE_6 . class , VAR_3 ) . getName ( ) ; <START> if ( VAR_4 == null ) { <END> throw new IllegalArgumentException ( STRING_1 + VAR_3 ) ; } return METHOD_1 ( VAR_1 , VAR_2 , VAR_4 ) ; } 
<START> public static TYPE_1 getInstance ( ) { <END> METHOD_1 ( ) ; return instance ; } 
public void METHOD_1 ( ) throws InterruptedException { Thread . VAR_1 ( ) . METHOD_2 ( VAR_2 * INT_1 ) ; <START> } <END> 
protected int METHOD_1 ( ) { <START> return 1 ; <END> } 
protected String [ ] METHOD_1 ( TYPE_1 response ) throws IOException { TYPE_2 VAR_1 = new TYPE_2 ( ) ; TYPE_3 . METHOD_2 ( response . VAR_2 ( ) . METHOD_3 ( ) , VAR_1 ) ; <START> TYPE_3 . METHOD_4 ( response . VAR_2 ( ) . METHOD_3 ( ) ) ; <END> return VAR_1 . toString ( ) . split ( System . VAR_3 ( ) ) ; } 
private double METHOD_1 ( Collection < TYPE_3 . TYPE_4 < TYPE_2 > > VAR_1 ) { long VAR_2 = 0 ; int count = 0 ; for ( TYPE_3 . TYPE_4 < TYPE_2 > p : VAR_1 ) { VAR_2 += p . VAR_3 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; <START> count ++ ; <END> } return VAR_2 / count ; } 
private static void METHOD_1 ( ) { if ( ! config . VAR_1 ( TYPE_1 . VAR_3 ) ) { log . error ( STRING_1 ) ; System . VAR_4 ( TYPE_2 . VAR_6 ) ; } log . info ( STRING_2 ) ; boolean VAR_7 = false ; <START> log . info ( STRING_3 + VAR_7 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 config = TYPE_1 . getInstance ( ) ; config . VAR_1 ( TYPE_4 . VAR_3 , "" ) ; TYPE_2 ex = null ; try { TYPE_3 . METHOD_2 ( ) ; } catch ( TYPE_2 e ) { <START> ex = e ; <END> } assertNotNull ( ex ) ; assertEquals ( - 1 , ex . getStatus ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 config = TYPE_1 . getInstance ( ) ; config . VAR_1 ( TYPE_4 . VAR_3 , STRING_1 ) ; TYPE_2 ex = null ; try { TYPE_3 . METHOD_2 ( ) ; } catch ( TYPE_2 e ) { ex = e ; } <START> assertNotNull ( ex ) ; <END> assertEquals ( - 1 , ex . getStatus ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 config = TYPE_1 . getInstance ( ) ; config . VAR_1 ( TYPE_4 . VAR_3 , STRING_1 ) ; String [ ] args = new String [ 0 ] ; TYPE_2 ex = null ; try { TYPE_3 . METHOD_2 ( args ) ; } catch ( TYPE_2 e ) { ex = e ; } <START> METHOD_3 ( ex ) ; <END> } 
<START> public static boolean containsKey ( String key ) { <END> return props . containsKey ( key ) ; } 
<START> public static void METHOD_1 ( TYPE_1 < ? extends TYPE_2 > name ) { <END> METHOD_1 ( name . toString ( ) ) ; } 
public int METHOD_1 ( ) { int VAR_1 = 0 ; Set keySet = VAR_2 . keySet ( ) ; Iterator VAR_3 = keySet . iterator ( ) ; while ( VAR_3 . hasNext ( ) ) { VAR_1 += VAR_2 . get ( VAR_3 . next ( ) ) ; <START> } <END> return VAR_1 ; } 
<START> private Map < Long , String > METHOD_1 ( TYPE_1 < Long > VAR_1 ) { <END> HashMap < Long , String > VAR_2 = new HashMap < Long , String > ( ) ; for ( TYPE_2 < Long > VAR_3 : VAR_1 ) { VAR_2 . put ( VAR_3 . getName ( ) , VAR_3 . METHOD_2 ( ) ) ; } return VAR_2 ; } 
<START> private static < T > TYPE_1 < T > METHOD_1 ( Class < T > type , long VAR_1 , long VAR_2 , T ... values ) { <END> TYPE_1 < T > VAR_3 = new TYPE_1 < T > ( ) ; long time = VAR_1 ; for ( T v : values ) { VAR_3 . add ( new TYPE_1 . TYPE_3 < T > ( time , v ) ) ; time += VAR_2 ; } return VAR_3 ; } 
<START> public void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) throws Exception { <END> try { TYPE_2 . getInstance ( ) . METHOD_2 ( VAR_1 , TYPE_4 . VAR_3 ) ; } catch ( TYPE_3 e ) { throw new IOException ( e ) ; } } 
public ByteBuffer METHOD_1 ( Object o ) { try { byte type = METHOD_2 ( o ) ; <START> byte [ ] buf = new byte [ METHOD_3 ( o , type , VAR_1 ) ] ; <END> METHOD_4 ( o , buf ) ; ByteBuffer out = ByteBuffer . VAR_2 ( buf ) ; return out ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { <START> boolean VAR_2 = TYPE_2 . getInstance ( ) . METHOD_2 ( TYPE_4 . VAR_4 ) ; <END> if ( VAR_2 ) { return false ; } else { String VAR_5 = String . valueOf ( VAR_1 . METHOD_3 ( ) ) ; final String VAR_6 = TYPE_3 . getInstance ( ) . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; return VAR_6 == null || ! VAR_5 . equals ( VAR_6 ) ; } } 
<START> private String METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_1 . METHOD_1 ( ) ; } 
<START> public < TYPE_1 > Builder < TYPE_2 , TYPE_1 > METHOD_1 ( TYPE_3 < TYPE_4 , TYPE_1 > VAR_1 ) { <END> TYPE_5 . METHOD_2 ( VAR_1 ) ; ArrayList < TYPE_3 < ? , ? > > VAR_2 = new ArrayList < TYPE_3 < ? , ? > > ( this . VAR_3 ) ; return new Builder < TYPE_2 , TYPE_1 > ( VAR_2 ) ; } 
public boolean METHOD_1 ( ) { <START> final TYPE_1 config = TYPE_1 . getInstance ( ) ; <END> return config . VAR_1 ( TYPE_2 . VAR_3 ) ; } 
public static final boolean METHOD_1 ( ) { <START> final TYPE_1 config = TYPE_1 . getInstance ( ) ; <END> return config . VAR_1 ( TYPE_2 . VAR_3 ) ; } 
public static void METHOD_1 ( String [ ] args ) throws Exception { String [ ] VAR_1 = { STRING_1 , STRING_2 , } ; for ( String VAR_2 : VAR_1 ) { <START> Class . VAR_3 ( VAR_2 ) ; <END> } new TYPE_1 ( ) . run ( args ) ; } 
public void update ( long when , int VAR_1 ) { Long VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_3 . put ( VAR_1 , when ) ; } else { <START> if ( when > VAR_2 ) { <END> VAR_3 . put ( VAR_1 , when ) ; } } } 
public void METHOD_1 ( long count ) { <START> VAR_1 . METHOD_2 ( ( - 1 ) * count ) ; <END> VAR_2 . METHOD_3 ( ) ; } 
public long METHOD_1 ( ) { <START> return ( System . VAR_1 ( ) - VAR_2 ) / INT_1 ; <END> } 
<START> public synchronized void start ( ) { <END> VAR_1 = new TYPE_1 ( ) ; if ( VAR_2 != null ) { throw new RuntimeException ( STRING_1 ) ; } VAR_2 = new Thread ( VAR_1 , STRING_2 ) ; VAR_2 . start ( ) ; log . info ( STRING_3 ) ; } 
public boolean equals ( Object obj ) { <START> if ( ! ( obj instanceof TYPE_1 ) || obj == null ) <END> return false ; TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return this . METHOD_1 ( ) . equals ( VAR_1 . METHOD_1 ( ) ) && this . VAR_2 == VAR_1 . VAR_2 ; } 
public boolean equals ( Object obj ) { <START> return obj instanceof TYPE_1 && obj . VAR_1 ( ) == this . METHOD_1 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( final String event , final TYPE_2 < T > VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 < T > ( ) { @Override <START> public void call ( T ... VAR_3 ) { <END> TYPE_1 . this . METHOD_2 ( event , this ) ; VAR_1 . call ( VAR_3 ) ; } } ; this . VAR_4 . put ( VAR_1 , VAR_2 ) ; this . METHOD_3 ( event , VAR_2 ) ; return this ; } 
public String toString ( ) { switch ( type ) { case VAR_1 : return String . format ( STRING_1 , VAR_2 ) ; case VAR_3 : return String . format ( STRING_2 , VAR_4 ) ; case VAR_5 : return String . format ( STRING_3 , VAR_6 ) ; default : <START> return STRING_4 ; <END> } } 
<START> public void start ( ) { <END> synchronized ( VAR_1 ) { if ( VAR_1 . get ( ) ) return ; else { VAR_1 . set ( true ) ; run ( ) ; } } } 
public final boolean METHOD_1 ( TYPE_1 VAR_1 ) { Object [ ] VAR_2 = VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; <START> if ( VAR_2 != null && VAR_2 . length > 0 ) { <END> return false ; } return true ; } 
public String METHOD_1 ( TYPE_1 entity ) { <START> if ( entity != null ) { <END> TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( entity . VAR_2 ( ) ) ; return METHOD_1 ( VAR_1 , entity . getId ( ) ) ; } return null ; } 
public Collection < TYPE_1 > METHOD_1 ( String VAR_1 ) { if ( VAR_2 == null ) { log . info ( STRING_1 ) ; return Collections . VAR_3 ( ) ; } METHOD_2 ( VAR_1 ) ; final Map < TYPE_2 , TYPE_1 > VAR_4 = VAR_2 . METHOD_3 ( VAR_1 ) ; <START> <END> return VAR_4 . values ( ) ; } 
private Set < TYPE_1 > METHOD_1 ( Set < TYPE_1 > VAR_1 ) throws TYPE_2 { final Set < TYPE_1 > VAR_2 = METHOD_2 ( ) ; <START> for ( TYPE_1 VAR_3 : VAR_2 ) { <END> VAR_1 . add ( VAR_3 ) ; if ( VAR_3 . METHOD_3 ( ) ) { ( ( TYPE_3 ) VAR_3 ) . METHOD_1 ( VAR_1 ) ; } } return VAR_1 ; } 
public boolean METHOD_1 ( TYPE_1 group ) throws TYPE_2 { final Set < TYPE_1 > VAR_1 = METHOD_2 ( ) ; <START> return VAR_1 . contains ( group ) ; <END> } 
private String METHOD_1 ( int id ) { if ( id > 0 ) { String VAR_1 = VAR_2 . METHOD_2 ( id ) ; if ( VAR_1 != null ) { return VAR_1 ; } <START> logger . warn ( STRING_1 ) ; <END> } return VAR_3 ; } 
private TYPE_1 METHOD_1 ( String name ) { Set < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( name ) ; if ( VAR_1 . size ( ) > 1 ) { <START> logger . warn ( STRING_1 , name ) ; <END> } return VAR_1 . isEmpty ( ) ? null : VAR_1 . iterator ( ) . next ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 ) { if ( VAR_1 . METHOD_2 ( ) == - 1 ) { try { throw new RuntimeException ( ) ; } catch ( Exception e ) { <START> e . VAR_4 ( System . out ) ; <END> } } VAR_2 . METHOD_3 ( VAR_3 ) ; VAR_5 . METHOD_4 ( VAR_1 , VAR_2 ) ; } 
protected void METHOD_1 ( TYPE_1 request , TYPE_2 response ) { try { METHOD_2 ( request , response ) ; } catch ( IOException ex ) { logger . error ( STRING_1 + METHOD_3 ( ) + STRING_2 , ex ) ; <START> } catch ( TYPE_3 ex ) { <END> logger . error ( STRING_1 + METHOD_3 ( ) + STRING_2 , ex ) ; } } 
public TYPE_1 METHOD_1 ( String name ) throws TYPE_2 { <START> List < TYPE_3 > VAR_1 = VAR_2 . METHOD_2 ( name ) ; <END> TYPE_3 VAR_3 = VAR_1 . get ( 0 ) ; TYPE_4 VAR_4 = METHOD_3 ( VAR_3 ) ; TYPE_1 group = new TYPE_5 ( VAR_4 . getKey ( ) , VAR_5 ) ; group . VAR_6 ( VAR_4 . getName ( ) ) ; group . VAR_7 ( VAR_4 . METHOD_4 ( ) ) ; return group ; } 
private TYPE_1 METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( VAR_1 . size ( ) == 0 ) { return VAR_2 . METHOD_3 ( STRING_1 , STRING_2 ) ; } else { <START> return VAR_1 . get ( 0 ) ; <END> } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String name , String description ) { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( name ) ; if ( VAR_2 . size ( ) == 0 ) { return VAR_3 . METHOD_3 ( VAR_1 , name , description ) ; <START> } else { <END> VAR_2 . get ( 0 ) . METHOD_4 ( description ) ; VAR_3 . METHOD_5 ( VAR_2 . get ( 0 ) ) ; return VAR_2 . get ( 0 ) ; } } 
<START> public TYPE_2 ( String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 ) throws Exception { <END> try { if ( TYPE_3 . VAR_7 ) { METHOD_1 ( new TYPE_1 ( STRING_1 + VAR_3 ) ) ; } else { METHOD_1 ( new TYPE_1 ( STRING_2 + VAR_3 ) ) ; } } catch ( Exception e ) { throw new RuntimeException ( STRING_3 , e ) ; } this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 . split ( STRING_4 ) ; this . VAR_5 = VAR_5 ; } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { try { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . METHOD_3 ( ) , new TYPE_5 . TYPE_6 ( null ) ) . METHOD_4 ( ) ; return VAR_2 . METHOD_5 ( ) ; } catch ( IOException e ) { log . error ( STRING_1 , e ) ; <START> return null ; <END> } } 
public boolean METHOD_1 ( ) { if ( STRING_1 . equals ( VAR_1 ) && STRING_2 . equals ( VAR_2 ) ) return false ; if ( VAR_3 != null ) return true ; if ( name . isEmpty ( ) ) return false ; <START> return VAR_4 <= 0 ; <END> } 
public TYPE_3 ( final String VAR_2 , final String VAR_3 , final String VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_5 = VAR_3 ; this . VAR_6 . clear ( ) ; this . VAR_6 . add ( false ) ; <START> VAR_7 = VAR_4 . equals ( VAR_8 ) ? true : false ; <END> VAR_9 = new TYPE_1 ( ) ; VAR_10 = new TYPE_2 ( ) ; } 
private void METHOD_1 ( ) { final List < String > VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null ) { System . out . println ( STRING_1 ) ; for ( final String VAR_2 : VAR_1 ) { System . out . println ( STRING_2 + VAR_2 ) ; } } else { System . out . println ( STRING_3 ) ; } <START> } <END> 
private void METHOD_1 ( final TYPE_1 action , final TYPE_2 key ) { if ( VAR_1 . get ( key ) == null ) { VAR_1 . put ( key , action ) ; } else { <START> logger . error ( TYPE_3 . getMessage ( STRING_1 , key . toString ( ) ) . toString ( ) ) ; <END> } } 
public void METHOD_1 ( final String uri , final String VAR_1 , final String VAR_2 ) throws TYPE_1 { VAR_3 . METHOD_2 ( ) ; final TYPE_2 VAR_4 = VAR_5 . METHOD_2 ( ) ; if ( ( VAR_4 == null || ! VAR_4 . METHOD_3 ( ) ) && ! TYPE_3 . equals ( VAR_1 ) ) { <START> return ; <END> } METHOD_4 ( ) . METHOD_1 ( uri , VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 != null ) { return VAR_1 ; } else { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } } 
public static TYPE_1 METHOD_1 ( final String name , List < TYPE_1 > VAR_1 ) { TYPE_1 VAR_2 = null ; for ( TYPE_1 VAR_3 : VAR_1 ) { if ( name . equals ( VAR_3 . getName ( ) ) ) { <START> VAR_2 = VAR_3 ; <END> } } return VAR_2 ; } 
<START> public static < T > TYPE_1 < T > METHOD_1 ( ANNOTATION_1 TYPE_2 < T > VAR_1 ) { <END> TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; return TYPE_4 . METHOD_3 ( new TYPE_5 < > ( VAR_1 ) ) ; } 
<START> public static < T > TYPE_1 < T > METHOD_1 ( ANNOTATION_1 TYPE_2 < T > stream ) { <END> TYPE_3 . METHOD_2 ( stream , STRING_1 ) ; return TYPE_4 . METHOD_3 ( new TYPE_5 < > ( stream ) ) ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; synchronized ( this ) { Map < Long , TYPE_1 > VAR_2 = VAR_3 ; if ( VAR_2 == null ) { return ; } for ( TYPE_1 b : VAR_2 . values ( ) ) { VAR_4 . METHOD_3 ( b ) ; } <START> VAR_2 = null ; <END> } VAR_5 = true ; METHOD_4 ( ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 , Throwable ex ) { TYPE_2 . METHOD_2 ( VAR_2 ) ; <START> VAR_3 . METHOD_3 ( VAR_1 ) ; <END> if ( VAR_4 . METHOD_4 ( ex ) ) { VAR_3 . METHOD_5 ( ) ; synchronized ( this ) { VAR_5 = null ; } VAR_6 = true ; METHOD_6 ( ) ; } else { TYPE_3 . METHOD_7 ( ex ) ; } } 
public final TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 < ? super Throwable > VAR_2 ) { TYPE_4 . METHOD_2 ( VAR_2 , STRING_1 ) ; TYPE_4 . METHOD_2 ( VAR_1 , STRING_2 ) ; <START> return METHOD_1 ( VAR_1 , VAR_2 , TYPE_5 . METHOD_3 ( ) ) ; <END> } 
public final TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> return METHOD_1 ( VAR_1 , TYPE_4 . VAR_3 ) ; <END> } 
public final TYPE_1 < T > METHOD_1 ( T VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> return METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( Throwable e ) { if ( VAR_1 ) { <START> return ; <END> } VAR_1 = true ; try { VAR_2 . METHOD_1 ( e ) ; } catch ( Throwable ex ) { TYPE_1 . METHOD_2 ( ex ) ; TYPE_2 . METHOD_1 ( e ) ; throw new TYPE_3 ( new TYPE_4 ( e , ex ) ) ; } } 
final void METHOD_1 ( ) { TYPE_1 VAR_1 = get ( ) ; TYPE_1 next = VAR_1 . get ( ) ; size -- ; TYPE_1 VAR_2 = new TYPE_1 ( null ) ; TYPE_1 VAR_3 = next . get ( ) ; <START> VAR_2 . set ( VAR_3 ) ; <END> METHOD_2 ( VAR_2 ) ; if ( VAR_3 == null ) { VAR_4 = VAR_2 ; } } 
<START> TYPE_1 ( int VAR_2 ) { <END> this ( VAR_2 , true ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 ) { <START> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; <END> VAR_3 . METHOD_2 ( METHOD_3 ( VAR_2 ) ) ; } 
public TYPE_3 ( TYPE_1 < ? super R > VAR_2 , TYPE_2 < R , ? super T , R > VAR_3 , R value ) { this . VAR_2 = VAR_2 ; this . value = value ; this . VAR_3 = VAR_3 ; <START> this . value = value ; <END> } 
public void METHOD_1 ( Throwable e ) { if ( VAR_1 ) { TYPE_1 . METHOD_1 ( e ) ; return ; } <START> value = null ; <END> VAR_2 . METHOD_1 ( e ) ; } 
public void METHOD_1 ( T value ) { <START> R v = this . value ; <END> try { this . value = TYPE_1 . METHOD_2 ( VAR_1 . apply ( v , value ) , STRING_1 ) ; } catch ( Throwable ex ) { TYPE_2 . METHOD_3 ( ex ) ; d . VAR_2 ( ) ; METHOD_4 ( ex ) ; } } 
<START> public TYPE_3 ( ) { <END> this . VAR_2 = new TYPE_1 < TYPE_2 < T > [ ] > ( VAR_3 ) ; } 
<START> @Override public Object call ( ) { <END> return null ; } 
public TYPE_6 ( TYPE_1 < T > source , TYPE_2 < ? super T , ? extends TYPE_3 > VAR_2 , TYPE_2 < ? super T , ? extends TYPE_4 > VAR_3 ) { <START> this ( source , VAR_2 , VAR_3 , TYPE_5 < TYPE_3 , TYPE_4 > instance ( ) ) ; <END> } 
public void call ( final TYPE_1 < ? super T > child ) { final TYPE_2 VAR_1 = VAR_2 . METHOD_1 ( ) ; child . add ( VAR_1 ) ; TYPE_3 < T > VAR_3 = new TYPE_3 < T > ( child ) ; <START> VAR_1 . METHOD_2 ( VAR_3 , time , VAR_4 ) ; <END> source . VAR_5 ( VAR_3 ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( false , true ) ) { <START> VAR_2 . METHOD_3 ( new TYPE_1 ( ) { <END> @Override public void call ( ) { VAR_3 . METHOD_4 ( VAR_2 ) ; } } ) ; } VAR_4 . METHOD_1 ( ) ; } 
public final TYPE_1 METHOD_1 ( final TYPE_2 < ? super T , ? extends TYPE_1 > VAR_1 ) { <START> return TYPE_1 . create ( new TYPE_3 ( this , VAR_1 ) ) ; <END> } 
public void METHOD_1 ( Throwable e ) { error = e ; List < Throwable > VAR_1 = null ; for ( TYPE_1 < T > VAR_2 : METHOD_2 ( VAR_3 ) ) { try { VAR_2 . METHOD_1 ( e ) ; } catch ( Throwable ex ) { if ( VAR_1 == null ) { <START> VAR_1 = new ArrayList < Throwable > ( ) ; <END> } VAR_1 . add ( ex ) ; } } TYPE_2 . METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( Throwable e ) { <START> long r = get ( ) ; <END> if ( r != Long . VAR_1 ) { VAR_2 . METHOD_1 ( e ) ; } } 
public void METHOD_1 ( TYPE_1 < R > VAR_1 , R value ) { <START> if ( ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( value ) ) { <END> VAR_1 . METHOD_4 ( ) ; METHOD_5 ( VAR_1 , new TYPE_2 ( ) ) ; } else { METHOD_6 ( ) ; } } 
public void METHOD_1 ( T t ) { if ( VAR_1 != VAR_2 ) { <START> if ( ! VAR_3 . METHOD_2 ( t ) ) { <END> METHOD_3 ( new IllegalStateException ( STRING_1 ) ) ; return ; } } METHOD_4 ( ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 ) { return ; } List < TYPE_1 < TYPE_2 , TYPE_3 > > list = new ArrayList < TYPE_1 < TYPE_2 , TYPE_3 > > ( VAR_2 . values ( ) ) ; VAR_2 . clear ( ) ; <START> for ( TYPE_1 < TYPE_2 , TYPE_3 > e : list ) { <END> e . VAR_3 ( ) ; } VAR_1 = true ; TYPE_4 . METHOD_2 ( this ) ; METHOD_3 ( ) ; } 
public void METHOD_1 ( T t ) { List < T > b = buffer ; if ( b == null ) { <START> b = new ArrayList < T > ( ) ; <END> buffer = b ; } b . add ( t ) ; if ( b . size ( ) == count ) { buffer = null ; VAR_1 . METHOD_1 ( b ) ; } } 
public void call ( ) { try { VAR_1 . METHOD_1 ( value ) ; } catch ( Throwable t ) { VAR_1 . METHOD_2 ( t ) ; <START> return ; <END> } } 
public int METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 . time == VAR_2 . time ) { <START> return Long . valueOf ( VAR_1 . count ) . METHOD_2 ( VAR_2 . count ) ; <END> } else { return Long . valueOf ( VAR_1 . time ) . METHOD_2 ( VAR_2 . time ) ; } } 
public TYPE_3 ( ) { this . VAR_2 = new TYPE_1 < TYPE_2 < ? extends T > > ( ) ; <START> this . buf = null ; <END> } 
public TYPE_1 < ? super T > call ( final TYPE_1 < ? super T > child ) { <START> return new TYPE_1 < T > ( child ) { <END> @Override public void METHOD_1 ( ) { child . VAR_1 ( ) ; } @Override public void METHOD_2 ( Throwable e ) { child . VAR_2 ( e ) ; } @Override public void METHOD_3 ( T t ) { } } ; } 
void METHOD_1 ( long n ) { if ( n > 0 ) { while ( true ) { final int s = state . get ( ) ; if ( s == VAR_1 ) { if ( state . VAR_2 ( VAR_1 , VAR_3 ) ) { <START> request ( Long . VAR_4 ) ; <END> return ; } } else if ( s == VAR_5 ) { if ( state . VAR_2 ( VAR_5 , VAR_6 ) ) { METHOD_2 ( ) ; return ; } } else return ; } } } 
<START> protected String METHOD_1 ( Object item ) { <END> return null ; } 
private boolean METHOD_1 ( ) { if ( VAR_1 . VAR_2 . get ( ) == this ) { return true ; } else { if ( VAR_1 . VAR_2 . METHOD_2 ( null , this ) ) { VAR_1 . METHOD_3 ( this ) ; return true ; } else { <START> METHOD_4 ( ) ; <END> VAR_1 . METHOD_5 ( ) ; return false ; } } } 
public void METHOD_1 ( ) { <START> synchronized ( this ) { <END> if ( TYPE_1 . METHOD_2 ( this , 1 ) == 0 ) { VAR_1 . METHOD_3 ( new TYPE_2 ( ) { @Override public void call ( ) { VAR_1 . METHOD_1 ( ) ; } } ) ; } } } 
public void METHOD_1 ( ) { if ( VAR_1 ) { return ; } <START> VAR_1 = true ; <END> METHOD_2 ( VAR_2 ) ; } 
void error ( Throwable e ) { <START> TYPE_1 . getInstance ( ) . METHOD_1 ( ) . METHOD_2 ( e ) ; <END> VAR_1 . add ( e ) ; METHOD_3 ( ) ; } 
public void METHOD_1 ( ) { synchronized ( this ) { <START> if ( VAR_1 || VAR_2 == null ) { <END> return ; } else { VAR_1 = true ; } } METHOD_2 ( VAR_2 ) ; } 
public void clear ( ) { List < TYPE_1 > VAR_1 = null ; synchronized ( this ) { if ( VAR_2 || VAR_3 == null ) { return ; } else { <START> VAR_1 = new ArrayList < TYPE_1 > ( VAR_3 ) ; <END> } } METHOD_1 ( VAR_1 ) ; } 
private TYPE_2 ( T value ) { <START> TYPE_1 . METHOD_1 ( this , VAR_2 . next ( value ) ) ; <END> } 
public void next ( T value ) { if ( ! VAR_1 ) { list . VAR_2 ( VAR_3 . call ( VAR_4 . next ( value ) ) ) ; VAR_5 . METHOD_1 ( list ) ; <START> TYPE_1 . METHOD_2 ( this , list . VAR_6 ) ; <END> } } 
public final TYPE_1 < T > METHOD_1 ( final int count ) { <START> return METHOD_2 ( new TYPE_2 ( count ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { VAR_1 . close ( ) ; while ( ! VAR_1 . METHOD_2 ( ) ) { try { Thread . VAR_2 ( INT_1 ) ; } catch ( InterruptedException e ) { <START> e . VAR_3 ( ) ; <END> } } } 
public void METHOD_1 ( String VAR_1 , String value ) { <START> METHOD_2 ( STRING_1 + VAR_1 + STRING_2 , value ) ; <END> } 
protected void METHOD_1 ( String message ) { <START> System . out . METHOD_2 ( message ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_1 < String > VAR_1 ) { <START> return TYPE_3 . METHOD_2 ( TYPE_4 . METHOD_3 ( VAR_2 . get ( ) . METHOD_4 ( ) , in ( TYPE_5 . METHOD_5 ( VAR_1 ) ) ) . values ( ) , VAR_3 ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_1 < String > VAR_1 ) { return TYPE_3 . filter ( METHOD_2 ( ) , new TYPE_4 < TYPE_2 > ( ) { @Override public boolean apply ( TYPE_2 server ) { <START> return TYPE_3 . contains ( VAR_1 , server . getId ( ) ) ; <END> } } ) ; } 
VAR_1 ( final TYPE_1 < String , String > VAR_2 ) { return new TYPE_2 < String , Set < ? extends TYPE_3 < ? extends TYPE_4 > > > ( ) { @Override public Set < ? extends TYPE_3 < ? extends TYPE_4 > > apply ( String from ) { return client . VAR_3 ( ) <START> . METHOD_1 ( from , TYPE_5 . METHOD_2 ( VAR_2 . get ( from ) , String . VAR_4 ) ) ; <END> } } ; } 
public TYPE_1 < ? extends TYPE_2 > METHOD_1 ( TYPE_1 < String > VAR_1 ) { <START> return TYPE_3 . from ( METHOD_2 ( METHOD_3 ( ) ) ) . filter ( METHOD_4 ( TYPE_4 . METHOD_5 ( VAR_1 , String . VAR_2 ) ) ) . METHOD_6 ( ) ; <END> } 
protected TYPE_1 < String , Set < TYPE_2 > > METHOD_1 ( final TYPE_3 < String , String > VAR_1 ) { return new TYPE_1 < String , Set < TYPE_2 > > ( ) { @Override public Set < TYPE_2 > apply ( String from ) { return client . VAR_2 ( ) <START> . METHOD_2 ( from , TYPE_4 . METHOD_3 ( VAR_1 . get ( from ) , String . VAR_3 ) ) ; <END> } } ; } 
public String toString ( ) { <START> return METHOD_1 ( "" ) . METHOD_2 ( ) . add ( STRING_1 , id ) . add ( STRING_2 , name ) . toString ( ) ; <END> } 
protected boolean METHOD_1 ( ) { if ( VAR_1 != null && TYPE_1 . equals ( VAR_1 ) && VAR_2 != null && TYPE_2 . equals ( VAR_2 ) ) { <START> return true ; <END> } return false ; } 
public Response METHOD_1 ( ) throws Exception { TYPE_1 session = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_3 ( ) ) ; TYPE_2 VAR_1 = METHOD_4 ( ) . METHOD_5 ( ) ; String type = VAR_1 . getString ( STRING_1 ) ; TYPE_3 log = ( TYPE_3 ) session . VAR_2 ( ) . METHOD_6 ( type ) ; <START> List < TYPE_4 > VAR_3 = ( log == null ? ( TYPE_5 < TYPE_4 > METHOD_7 ( ) ) : log . VAR_5 ( ) ) ; <END> return METHOD_8 ( VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 , TYPE_3 { <START> while ( true ) { <END> try { TYPE_1 row = METHOD_2 ( ) ; if ( row == null ) { return null ; } return row ; } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } } } 
public void close ( ) throws TYPE_1 { try { super . close ( ) ; } catch ( Exception e ) { <START> e . VAR_1 ( ) ; <END> } TYPE_2 . METHOD_1 ( TYPE_6 . VAR_3 , TYPE_4 . TYPE_5 . getString ( STRING_1 ) ) ; } 
public TYPE_1 . Builder < T > METHOD_1 ( final TYPE_2 ... VAR_1 ) { if ( VAR_1 != null ) { this . VAR_2 = METHOD_2 ( this . VAR_2 ) ; this . VAR_2 . clear ( ) ; <START> VAR_3 = VAR_1 [ 0 ] ; <END> this . VAR_2 . addAll ( Arrays . asList ( VAR_1 ) ) ; } return this ; } 
public TYPE_1 . Builder < T > METHOD_1 ( final List < TYPE_2 > VAR_1 ) { if ( VAR_1 != null ) { this . VAR_2 = METHOD_2 ( this . VAR_2 ) ; this . VAR_2 . clear ( ) ; for ( final TYPE_2 VAR_3 : VAR_1 ) { this . VAR_2 . add ( VAR_3 ) ; <START> VAR_4 = VAR_3 ; <END> } } return this ; } 
public void start ( ) throws TYPE_1 { for ( TYPE_2 VAR_1 : VAR_2 . values ( ) ) { VAR_1 . start ( ) ; } VAR_3 . start ( ) ; VAR_4 . start ( ) ; System . out . println ( STRING_1 ) ; server . VAR_5 ( ) ; <START> Thread VAR_6 = new Thread ( ( ) - > { <END> VAR_7 . METHOD_1 ( ) ; } , STRING_2 ) ; VAR_6 . METHOD_2 ( true ) ; VAR_6 . start ( ) ; } 
protected TYPE_6 ( Path location ) { if ( TYPE_1 . exists ( location ) ) { try { this . VAR_2 = new TYPE_2 ( location . toString ( ) ) { } ; } catch ( TYPE_3 e ) { throw TYPE_4 . METHOD_1 ( e ) ; } } else { this . VAR_2 = null ; } METHOD_2 ( TYPE_7 . VAR_4 , VAR_5 ) ; METHOD_2 ( TYPE_7 . VAR_6 , Level . VAR_7 . VAR_8 ) ; <START> METHOD_2 ( TYPE_7 . VAR_9 , TYPE_5 . METHOD_3 ( ) ) ; <END> } 
public boolean METHOD_1 ( Set < TYPE_1 < TYPE_2 , TYPE_3 , TYPE_4 > > VAR_1 ) { <START> for ( TYPE_1 < TYPE_2 , TYPE_3 , TYPE_4 > entry : VAR_1 ) { <END> if ( ! METHOD_1 ( entry ) ) { return false ; } } return true ; } 
private boolean METHOD_1 ( ByteBuffer VAR_1 ) { <START> if ( VAR_2 . contains ( VAR_1 ) ) <END> return false ; return VAR_3 . METHOD_2 ( TYPE_1 . METHOD_3 ( VAR_1 ) ) ; } 
public Iterator < TYPE_1 > iterator ( ) { return new Iterator < TYPE_1 > ( ) { Iterator < TYPE_2 > VAR_1 = VAR_2 . iterator ( ) ; <START> int VAR_3 ; <END> @Override public boolean hasNext ( ) { return VAR_3 <= size ( ) ; } @Override public TYPE_1 next ( ) { TYPE_2 VAR_4 = VAR_1 . next ( ) ; VAR_3 += 1 ; return VAR_5 . apply ( VAR_4 ) ; } } ; } 
public static TYPE_1 parse ( String string ) { <START> TYPE_2 VAR_1 = TYPE_3 . METHOD_1 ( string ) ; <END> if ( VAR_1 != null ) return new TYPE_1 ( VAR_1 ) ; else throw new RuntimeException ( TYPE_4 . format ( STRING_1 , string ) ) ; } 
public void METHOD_1 ( ) { try { client . VAR_1 ( VAR_2 ) ; } catch ( Exception e ) { throw TYPE_1 . METHOD_2 ( e ) ; } <START> client . VAR_3 ( ) . METHOD_3 ( ) . close ( ) ; <END> client . VAR_4 ( ) . METHOD_3 ( ) . close ( ) ; } 
private short METHOD_1 ( ) { write . VAR_1 ( ) ; try { this . VAR_2 += 1 ; } finally { write . VAR_3 ( ) ; } <START> return this . VAR_2 ; <END> } 
public boolean METHOD_1 ( String VAR_1 ) { if ( StringUtils . VAR_2 ( VAR_1 ) ) { return false ; } if ( StringUtils . length ( VAR_1 ) < INT_1 ) { return false ; <START> } <END> return true ; } 
public void METHOD_1 ( ) { <START> context . VAR_1 ( ) ; <END> VAR_2 . METHOD_2 ( STRING_1 , true ) ; context . VAR_3 ( ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , IOException { try ( Context c = new Context ( ) ) { c . VAR_2 ( ) ; TYPE_3 VAR_3 = VAR_4 . METHOD_2 ( c , VAR_1 ) ; if ( VAR_3 != null ) { try { VAR_4 . METHOD_3 ( c , VAR_3 ) ; } catch ( TYPE_4 e ) { <START> throw new RuntimeException ( e . getMessage ( ) , e ) ; <END> } } c . VAR_5 ( ) ; } } 
private boolean METHOD_1 ( Context context , TYPE_1 item , TYPE_2 VAR_1 , Integer VAR_2 , boolean VAR_3 ) throws TYPE_3 { List < TYPE_2 > list = this . METHOD_2 ( context , item , VAR_1 . METHOD_3 ( ) , <START> - 1 , - 1 , VAR_3 ) ; <END> if ( VAR_2 != null && ! ( list . size ( ) > VAR_2 ) ) { return false ; } return true ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; <START> VAR_1 . METHOD_4 ( STRING_1 , null ) ; <END> VAR_1 . METHOD_4 ( STRING_2 , null ) ; VAR_1 . METHOD_4 ( STRING_3 , null ) ; VAR_1 . METHOD_4 ( STRING_4 , null ) ; VAR_1 . METHOD_4 ( STRING_5 , null ) ; VAR_1 . METHOD_4 ( STRING_6 , null ) ; super . METHOD_1 ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> List < TYPE_3 > list = VAR_3 . METHOD_2 ( VAR_1 , STRING_1 , STRING_2 , null , TYPE_1 . VAR_4 ) ; <END> if ( list . isEmpty ( ) ) { return false ; } String VAR_5 = list . get ( 0 ) . getValue ( ) ; if ( ! StringUtils . equals ( VAR_5 , VAR_2 . METHOD_3 ( ) ) ) { return false ; } return true ; } 
public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } <START> Class < ? > VAR_1 = TYPE_1 . METHOD_1 ( obj ) ; <END> if ( getClass ( ) != VAR_1 ) { return false ; } final TYPE_2 VAR_2 = ( TYPE_2 ) obj ; if ( this . METHOD_2 ( ) != VAR_2 . METHOD_2 ( ) ) { return false ; } return super . equals ( obj ) ; } 
public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } <START> if ( getClass ( ) != TYPE_1 . class ) { <END> return false ; } final TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( this . METHOD_1 ( ) != VAR_1 . METHOD_1 ( ) ) { return false ; } return super . equals ( obj ) ; } 
private String METHOD_1 ( List < TYPE_1 > list ) { String VAR_1 = null ; for ( TYPE_1 VAR_2 : list ) { if ( StringUtils . equals ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . getName ( ) , STRING_1 ) && StringUtils . equals ( VAR_2 . METHOD_2 ( ) . METHOD_4 ( ) , STRING_2 ) ) { VAR_1 = VAR_2 . getValue ( ) ; <START> } <END> } return VAR_1 ; } 
<START> public List < TYPE_1 > METHOD_1 ( TYPE_2 request ) throws IOException { <END> return METHOD_2 ( TYPE_3 . METHOD_3 ( request ) , request ) ; } 
private TYPE_1 METHOD_1 ( Context context , TYPE_2 VAR_1 , String VAR_2 , Integer VAR_3 ) { TYPE_1 VAR_4 = METHOD_2 ( context , TYPE_4 . TYPE_5 . getName ( ) + STRING_1 + VAR_2 ) ; <START> VAR_4 . METHOD_3 ( Constants . VAR_5 + VAR_3 ) ; <END> VAR_4 . METHOD_4 ( VAR_1 . METHOD_5 ( ) . toString ( ) ) ; return VAR_4 ; } 
public void METHOD_1 ( ) throws Exception { <START> context . VAR_1 ( ) ; <END> METHOD_2 ( ) . METHOD_3 ( get ( STRING_1 ) ) . METHOD_4 ( METHOD_5 ( STRING_2 , METHOD_6 ( ) ) ) ; METHOD_2 ( ) . METHOD_3 ( get ( STRING_3 ) ) . METHOD_4 ( status ( ) . METHOD_7 ( ) ) . METHOD_4 ( content ( ) . METHOD_8 ( VAR_2 ) ) . METHOD_4 ( METHOD_5 ( STRING_4 , METHOD_6 ( ) ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> context . VAR_1 ( ) ; <END> METHOD_2 ( ) . METHOD_3 ( get ( STRING_1 ) ) . METHOD_4 ( status ( ) . METHOD_5 ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> context . VAR_1 ( ) ; <END> TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_3 ) ; VAR_2 . METHOD_3 ( VAR_4 ) ; VAR_2 . METHOD_4 ( VAR_5 ) ; METHOD_5 ( ) . METHOD_6 ( METHOD_7 ( STRING_1 ) . METHOD_8 ( STRING_2 , VAR_6 . METHOD_9 ( ) + "" ) . content ( new TYPE_2 ( ) . METHOD_10 ( VAR_2 ) ) . METHOD_11 ( VAR_7 ) ) . METHOD_12 ( status ( ) . METHOD_13 ( ) ) ; } 
public TYPE_1 METHOD_1 ( Context context , String VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = METHOD_2 ( context ) ; TYPE_4 VAR_3 = METHOD_3 ( VAR_2 , TYPE_1 . class ) ; TYPE_5 < TYPE_1 > VAR_4 = VAR_3 . from ( TYPE_1 . class ) ; VAR_3 . METHOD_4 ( VAR_4 ) ; VAR_3 . METHOD_5 ( VAR_2 . METHOD_6 ( VAR_4 . get ( TYPE_6 . VAR_1 ) , VAR_1 ) ) ; <START> return METHOD_7 ( context , VAR_3 , true , TYPE_1 . class , - 1 , - 1 ) ; <END> } 
public void METHOD_1 ( Context c , List < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 , TYPE_4 { List < TYPE_1 > VAR_3 = new TYPE_5 < > ( ) ; for ( TYPE_1 VAR_4 : VAR_1 ) { TYPE_1 VAR_5 = VAR_6 . create ( c ) ; <START> VAR_5 = VAR_4 . METHOD_2 ( VAR_5 , VAR_2 ) ; <END> VAR_6 . update ( c , VAR_5 ) ; VAR_3 . add ( VAR_5 ) ; } VAR_6 . update ( c , VAR_3 ) ; } 
public void METHOD_1 ( Context context , TYPE_1 event ) throws Exception { int VAR_1 = event . VAR_2 ( ) ; int VAR_3 = event . VAR_4 ( ) ; switch ( VAR_1 ) { case Constants . VAR_5 : if ( VAR_3 == TYPE_1 . VAR_6 ) { VAR_7 . add ( ( TYPE_2 ) event . VAR_8 ( context ) ) ; } break ; default : <START> log . warn ( STRING_1 + event . toString ( ) ) ; <END> } } 
public static TYPE_1 row ( String table ) throws TYPE_2 { <START> return new TYPE_1 ( METHOD_1 ( table ) , METHOD_2 ( null , table ) ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( Context context , TYPE_3 VAR_1 ) { List < TYPE_4 > VAR_2 = new ArrayList < TYPE_4 > ( ) ; <START> int VAR_3 = 0 ; <END> try { VAR_2 . add ( VAR_4 . METHOD_2 ( context ) ) ; } catch ( TYPE_5 e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } TYPE_1 < TYPE_2 > page = new TYPE_6 < TYPE_4 > ( VAR_2 , VAR_1 , VAR_3 ) . map ( VAR_5 ) ; return page ; } 
public TYPE_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> } 
public void METHOD_1 ( Context context , String name ) throws TYPE_1 { if ( ! VAR_1 ) METHOD_2 ( ) . METHOD_3 ( context , this , <START> TYPE_2 . VAR_3 , STRING_1 , null , null , name ) ; <END> } 
public static void METHOD_1 ( ) { if ( VAR_1 != null ) { try { VAR_1 . METHOD_2 ( ) ; } catch ( Exception e ) { } <START> VAR_1 . METHOD_2 ( ) ; <END> } VAR_1 = null ; } 
<START> public List < Map > METHOD_1 ( Context context ) throws TYPE_1 { <END> return VAR_1 . METHOD_1 ( context ) ; } 
public static String format ( Date VAR_1 , boolean VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( STRING_1 ) ; <START> if ( ! VAR_2 ) <END> VAR_3 = new TYPE_1 ( STRING_2 ) ; VAR_3 . METHOD_1 ( TYPE_2 . METHOD_2 ( STRING_3 ) ) ; String VAR_4 = VAR_3 . format ( VAR_1 ) ; return VAR_4 ; } 
private static void log ( String text ) { if ( debug ) { <START> log ( text ) ; <END> } } 
private TYPE_1 METHOD_1 ( ) { <START> final TYPE_1 [ ] VAR_1 = new TYPE_1 [ 1 ] ; <END> TYPE_5 . TYPE_6 . Collection < TYPE_1 > VAR_2 = TYPE_3 . getInstance ( ) . METHOD_2 ( TYPE_7 . VAR_4 ) ; VAR_1 [ 0 ] = TYPE_4 . METHOD_3 ( VAR_2 ) ; return VAR_1 [ 0 ] ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; METHOD_2 ( R . VAR_2 . VAR_3 ) ; <START> TYPE_2 . getInstance ( ) . METHOD_3 ( METHOD_4 ( ) , new TYPE_3 < TYPE_4 > ( ) { <END> @Override public void METHOD_5 ( TYPE_4 VAR_4 ) { Log . i ( TAG , STRING_1 + VAR_4 . METHOD_6 ( ) ) ; } @Override public void METHOD_7 ( Exception e ) { Log . e ( TAG , STRING_2 , e ) ; } } ) ; METHOD_8 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( METHOD_3 ( null ) , TYPE_1 . of ( METHOD_4 ( ) ) ) ; <END> } 
public boolean METHOD_1 ( ) { <START> return this . VAR_1 != null && TYPE_1 . METHOD_2 ( this . VAR_1 ) ; <END> } 
public T METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return null ; } <START> T VAR_2 = reader . read ( type , VAR_1 ) ; <END> return METHOD_2 ( VAR_2 , VAR_1 , index ) ; } 
public TYPE_1 < T > METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 ) { if ( VAR_1 == null ) { return TYPE_1 . empty ( ) ; } <START> T VAR_2 = reader . read ( type , VAR_1 ) ; <END> return METHOD_2 ( VAR_2 , VAR_1 , index ) ; } 
private TYPE_1 < String > METHOD_1 ( List < TYPE_2 < String > > VAR_1 ) { <START> return new TYPE_3 < String > ( 1 , TYPE_4 . VAR_3 , 0 , STRING_1 , VAR_1 , null ) ; <END> } 
<START> public RuntimeException METHOD_1 ( Exception exception ) { <END> RuntimeException VAR_1 = exception instanceof RuntimeException ? ( RuntimeException ) exception : new RuntimeException ( exception . getMessage ( ) , exception ) ; RuntimeException VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; return VAR_2 != null ? VAR_2 : VAR_1 ; } 
<START> public RuntimeException METHOD_1 ( Throwable VAR_1 ) { <END> RuntimeException VAR_2 = VAR_1 instanceof RuntimeException ? ( RuntimeException ) VAR_1 : new RuntimeException ( VAR_1 . getMessage ( ) , VAR_1 ) ; RuntimeException VAR_3 = VAR_4 . METHOD_2 ( VAR_2 ) ; return VAR_3 != null ? VAR_3 : VAR_2 ; } 
<START> public < T > Optional < T > get ( String id , Class < T > VAR_1 , TYPE_1 index ) { <END> TYPE_2 request = VAR_2 . METHOD_1 ( id , index ) ; try { TYPE_3 response = client . get ( request , TYPE_6 . VAR_4 ) ; return Optional . VAR_5 ( VAR_6 . METHOD_2 ( TYPE_4 . from ( response ) , VAR_1 ) ) ; } catch ( IOException e ) { throw new TYPE_5 ( STRING_1 + request . toString ( ) , e ) ; } } 
<START> float METHOD_1 ( ) { <END> return VAR_1 ; } 
public static TYPE_1 of ( String ... VAR_1 ) { <START> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <END> return new TYPE_1 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return new TYPE_1 ( VAR_1 , new TYPE_3 ( ) ) ; <END> } 
public void METHOD_1 ( ) { final List < String > VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) . stream ( ) . map ( it - > it . id ) . collect ( Collectors . VAR_3 ( ) ) ; <START> assertThat ( VAR_1 ) . METHOD_3 ( STRING_2 , STRING_3 ) ; <END> } 
public String METHOD_1 ( ) { <START> return VAR_1 ? VAR_2 : getProperty ( ) . getName ( ) ; <END> } 
protected TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_3 VAR_1 = new TYPE_3 ( this ) ; <START> VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; <END> return VAR_1 ; } 
protected void METHOD_1 ( ) { <START> VAR_1 . remove ( ) ; <END> VAR_2 . remove ( ) ; if ( VAR_3 != null ) { VAR_3 . remove ( ) ; } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { File VAR_2 ; try { <START> VAR_2 = METHOD_2 ( VAR_1 ) ; <END> } catch ( TYPE_2 | TYPE_3 e ) { throw new IOException ( e ) ; } METHOD_3 ( VAR_2 , VAR_1 ) ; } 
public TYPE_1 < Long , String > METHOD_1 ( ) { <START> <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_2 < Long , String > ( ) ; VAR_1 . put ( INT_1 * INT_2 * INT_3 , STRING_1 ) ; VAR_1 . put ( INT_4 * INT_2 * INT_3 , STRING_2 ) ; VAR_1 . put ( INT_3 , STRING_3 ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( TYPE_1 . class ) ; if ( VAR_1 == null ) { LOG . warn ( STRING_1 + STRING_2 ) ; return ; } boolean VAR_3 = VAR_4 . METHOD_3 ( STRING_3 ) ; <START> Boolean VAR_5 = VAR_4 . getProperty ( STRING_4 , Boolean . VAR_6 , Boolean . VAR_7 ) ; <END> VAR_1 . METHOD_4 ( METHOD_5 ( VAR_3 , VAR_5 ) ) ; } 
public void METHOD_1 ( Integer VAR_1 , String VAR_2 , String VAR_3 ) { TYPE_1 . METHOD_2 ( VAR_1 != null , STRING_1 ) ; TYPE_1 . METHOD_2 ( StringUtils . VAR_4 ( VAR_2 ) , STRING_2 ) ; TYPE_1 . METHOD_2 ( StringUtils . VAR_4 ( VAR_3 ) , STRING_3 ) ; TYPE_1 . METHOD_2 ( ! VAR_2 . equals ( VAR_3 ) , STRING_4 ) ; Date VAR_5 = new Date ( ) ; <START> VAR_6 . METHOD_1 ( new TYPE_2 ( VAR_1 , VAR_5 , VAR_2 , VAR_3 ) ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_2 . METHOD_2 ( VAR_1 != null , STRING_1 ) ; TYPE_2 . METHOD_2 ( ! VAR_1 . trim ( ) . isEmpty ( ) , STRING_2 ) ; List < Integer > VAR_3 = VAR_4 . METHOD_3 ( VAR_1 ) ; return VAR_3 . isEmpty ( ) ? Collections . VAR_5 ( ) <START> : VAR_4 . METHOD_4 ( VAR_3 , VAR_2 ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 context ) { if ( VAR_1 == null ) { return true ; } <START> TYPE_3 VAR_2 = TYPE_3 . METHOD_2 ( ) ; <END> if ( METHOD_3 ( VAR_2 , VAR_1 ) ) { METHOD_4 ( context , STRING_1 ) ; return false ; } if ( METHOD_5 ( VAR_2 , VAR_1 ) ) { METHOD_4 ( context , STRING_2 ) ; return false ; } if ( METHOD_6 ( VAR_2 , VAR_1 ) ) { METHOD_4 ( context , STRING_3 ) ; return false ; } return true ; } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 context ) { TYPE_3 VAR_1 = ( context instanceof TYPE_3 ? ( TYPE_3 ) context : TYPE_4 . getInstance ( ) ) ; <START> if ( VAR_1 != null && ! VAR_1 . METHOD_2 ( TYPE_11 . VAR_3 ) ) { <END> return new TYPE_1 ( ) ; } return new TYPE_5 ( ) . METHOD_3 ( TYPE_6 . matcher ( TYPE_7 . class ) , TYPE_8 . METHOD_4 ( TYPE_9 . class , context , VAR_4 . VAR_5 , TYPE_10 . VAR_7 ) ) ; } 
public TYPE_4 ( String url , String user , String VAR_2 ) throws TYPE_1 { TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_1 ( url ) ; VAR_3 . METHOD_2 ( true ) ; <START> VAR_3 . METHOD_3 ( user ) ; <END> VAR_3 . METHOD_4 ( VAR_2 ) ; VAR_3 . METHOD_5 ( user , VAR_2 ) ; VAR_4 = new TYPE_3 ( ) ; METHOD_6 ( VAR_3 ) ; } 
public String METHOD_1 ( ) { <START> return super . METHOD_2 ( ) ; <END> } 
public void remove ( ) throws TYPE_1 { if ( TYPE_2 . METHOD_1 ( METHOD_2 ( ) ) ) { METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) , METHOD_2 ( ) ) ; } else { <START> METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) , METHOD_6 ( TYPE_3 . VAR_2 ) ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; TYPE_2 VAR_3 = VAR_1 . METHOD_3 ( ) ; <START> System . out . println ( STRING_1 + VAR_3 . getString ( STRING_2 ) ) ; <END> Assert . assertTrue ( VAR_3 . getString ( STRING_2 ) . equals ( STRING_3 ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_2 , VAR_3 ) ; String name = STRING_1 + System . currentTimeMillis ( ) ; <START> String description = STRING_2 ; <END> File VAR_4 = VAR_1 . METHOD_4 ( name , description , "" ) ; assertEquals ( VAR_4 . METHOD_5 ( ) , name ) ; VAR_1 . METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; } 
<START> public static void METHOD_1 ( boolean VAR_1 , boolean VAR_2 , TYPE_1 entity , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) <END> { if ( ! VAR_1 && VAR_2 ) TYPE_9 . TYPE_10 . METHOD_2 ( new TYPE_7 . TYPE_8 ( entity , VAR_3 , VAR_4 ) ) ; else if ( VAR_1 && ! VAR_2 ) TYPE_9 . TYPE_10 . METHOD_2 ( new TYPE_7 . TYPE_11 ( entity , VAR_3 , VAR_4 ) ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> this . VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> } 
public static double METHOD_1 ( TYPE_1 VAR_1 , ANNOTATION_1 TYPE_2 VAR_2 , double VAR_3 ) { TYPE_3 event = new TYPE_3 ( VAR_1 , VAR_2 , VAR_3 ) ; TYPE_6 . TYPE_7 . METHOD_2 ( event ) ; double value = event . VAR_4 ( ) ; if ( VAR_1 instanceof TYPE_5 ) { <START> value = METHOD_3 ( ( TYPE_5 ) VAR_1 , value , VAR_3 ) ; <END> } return value ; } 
public void METHOD_1 ( boolean value ) { <START> if ( METHOD_2 ( ) ) throw new TYPE_1 ( STRING_1 ) ; <END> VAR_1 = value ; } 
public static int METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . isEmpty ( ) ) { return 0 ; } else { TYPE_2 item = VAR_1 . METHOD_2 ( ) ; int VAR_2 = VAR_1 . METHOD_3 ( ) ; <START> return METHOD_4 ( ) . METHOD_5 ( item , i - > VAR_3 . VAR_4 . event . TYPE_3 . METHOD_1 ( VAR_1 , VAR_2 == - 1 ? METHOD_6 ( ) . METHOD_7 ( i , 0 ) : VAR_2 ) ) ; <END> } } 
public static void METHOD_1 ( ) <START> { <END> VAR_1 = null ; VAR_2 = null ; } 
public static Map < TYPE_1 , Pair < Integer , Integer > > METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 ) { <START> return METHOD_1 ( VAR_1 , ( VAR_2 ? - INT_1 : - 1 ) ) ; <END> } 
public Class < T > METHOD_1 ( ) { return VAR_1 ; <START> } <END> 
public < T > T get ( ) { if ( TYPE_2 . VAR_2 == TYPE_1 . VAR_4 ) { return ( T ) this . VAR_5 . apply ( client ) ; } else if ( TYPE_2 . VAR_2 == TYPE_1 . VAR_6 ) { return ( T ) this . VAR_7 . apply ( server ) ; } else if ( TYPE_2 . VAR_2 == null ) { return ( T ) this . VAR_8 . get ( ) ; } else { <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> } } 
public static < T > TYPE_1 < TYPE_2 < T > > METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( TYPE_2 : : METHOD_3 , TYPE_1 . METHOD_4 ( ) ) ; <END> } 
public void write ( TYPE_1 buffer ) { this . METHOD_1 ( ) . write ( buffer ) ; this . METHOD_2 ( ) . write ( buffer ) ; <START> this . METHOD_3 ( ) . write ( buffer ) ; <END> METHOD_4 ( buffer ) ; } 
public TYPE_1 < TYPE_2 > get ( ) { <START> if ( this . VAR_1 == null ) <END> { return TYPE_3 . METHOD_1 ( ) ; } return this . VAR_1 ; } 
<START> private String [ ] METHOD_1 ( String name , String VAR_1 , String [ ] VAR_2 , String VAR_3 , String [ ] VAR_4 , String [ ] VAR_5 , String VAR_6 ) <END> { TYPE_1 VAR_7 = this . get ( VAR_1 , name , VAR_2 ) ; VAR_7 . METHOD_2 ( VAR_4 ) ; if ( VAR_5 != null ) VAR_7 . METHOD_3 ( VAR_5 ) ; VAR_7 . METHOD_4 ( VAR_6 ) ; VAR_7 . METHOD_5 ( VAR_3 + STRING_1 + VAR_2 + STRING_2 ) ; return VAR_7 . METHOD_6 ( ) ; } 
public float METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 state , TYPE_4 VAR_3 ) { float VAR_4 = METHOD_2 ( VAR_1 , VAR_2 ) ; <START> return VAR_4 > 0 ? VAR_4 : 0 ; <END> } 
public TYPE_4 ( ) { METHOD_1 ( new TYPE_1 ( ) ) ; METHOD_1 ( new TYPE_2 ( ) ) ; <START> METHOD_1 ( new TYPE_3 ( this ) ) ; <END> } 
<START> public static String METHOD_1 ( Class < ? > VAR_1 , String VAR_2 ) <END> { String VAR_3 = TYPE_2 . TYPE_3 . METHOD_2 ( Type . VAR_4 ( VAR_1 ) ) ; return TYPE_2 . TYPE_3 . METHOD_3 ( VAR_3 , VAR_2 , null ) ; } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) <END> { super ( VAR_2 , VAR_2 . METHOD_1 ( ) . get ( VAR_3 ) ) ; VAR_4 = VAR_3 ; } 
<START> public ANNOTATION_1 TYPE_1 METHOD_1 ( ) { return VAR_1 ; } <END> 
private String METHOD_1 ( TYPE_1 VAR_1 ) { <START> String VAR_2 = VAR_1 . getClass ( ) . METHOD_2 ( ) ; <END> TYPE_2 VAR_3 = TYPE_1 . getKey ( VAR_1 . getClass ( ) ) ; if ( VAR_3 == null ) return VAR_2 ; else { return VAR_3 . toString ( ) ; } } 
public static boolean METHOD_1 ( TYPE_1 target , TYPE_2 VAR_1 , float VAR_2 , double VAR_3 , double VAR_4 ) { <START> return ! TYPE_5 . TYPE_6 . METHOD_2 ( new TYPE_4 ( target , VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ) ; <END> } 
<START> public static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <END> if ( ! ( VAR_1 instanceof TYPE_3 ) ) return false ; boolean VAR_3 = VAR_2 . METHOD_2 ( ) == TYPE_5 . VAR_5 && TYPE_4 . METHOD_3 ( VAR_2 ) ; double VAR_6 = VAR_1 . METHOD_4 ( TYPE_6 . VAR_8 ) . METHOD_5 ( ) ; return VAR_6 > FLOAT_1 || ( VAR_3 && VAR_6 >= FLOAT_1 ) ; } 
<START> public boolean METHOD_1 ( Collection < ? > VAR_1 ) <END> { for ( Iterator < ? > iterator = VAR_1 . iterator ( ) ; iterator . hasNext ( ) ; ) { if ( ! contains ( iterator . next ( ) ) ) return false ; } return true ; } 
<START> ANNOTATION_1 public TYPE_1 METHOD_1 ( ) { return VAR_1 ; } <END> 
public TYPE_1 getProperty ( String name ) { METHOD_1 ( ) ; <START> return null ; <END> } 
public TYPE_3 ( final TYPE_1 entity , final TYPE_2 . Type VAR_2 ) { this . entity = entity ; final List < TYPE_2 > VAR_3 = new ArrayList < TYPE_2 > ( ) ; for ( final TYPE_2 VAR_4 : TYPE_2 . values ( ) ) { if ( VAR_4 . METHOD_1 ( ) == VAR_2 ) { VAR_3 . add ( VAR_4 . METHOD_2 ( ) , VAR_4 ) ; } <START> } <END> this . VAR_3 = ImmutableList . VAR_5 ( VAR_3 ) ; } 
public int METHOD_1 ( TYPE_1 resource , boolean VAR_1 ) { if ( resource . VAR_2 < TYPE_5 . VAR_4 ) { return 0 ; } if ( VAR_1 ) { TYPE_2 VAR_5 = VAR_6 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> TYPE_3 VAR_7 = TYPE_4 . METHOD_4 ( VAR_5 ) ; <END> VAR_8 . METHOD_5 ( VAR_9 , VAR_7 . METHOD_2 ( ) . METHOD_6 ( TYPE_4 . VAR_10 , 0 ) , INT_1 ) ; } return TYPE_5 . VAR_4 ; } 
<START> public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) <END> { return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) || VAR_1 . METHOD_4 ( ) instanceof TYPE_2 ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_4 ( String name , TYPE_1 VAR_2 , Class < ? extends TYPE_2 > VAR_3 ) { this . name = name ; this . VAR_4 = VAR_2 ; <START> if ( TYPE_4 . VAR_5 . get ( VAR_3 ) . contains ( VAR_6 ) == false ) <END> { TYPE_4 . TYPE_5 . METHOD_1 ( VAR_3 ) ; } } 
public boolean METHOD_1 ( int VAR_1 ) { if ( VAR_2 <= 1 && VAR_1 > VAR_3 ) { return true ; } else { <START> return false ; <END> } } 
public void METHOD_1 ( TYPE_4 . TYPE_5 event ) { <START> if ( ! event . VAR_1 ( ) . METHOD_2 ( ) && event . VAR_1 ( ) . METHOD_3 ( ) == TYPE_6 . VAR_3 ) <END> event . VAR_4 ( new TYPE_2 ( STRING_1 ) , new TYPE_3 ( event . VAR_1 ( ) ) ) ; } 
private static long METHOD_1 ( long VAR_1 ) { <START> return VAR_1 / INT_1 / INT_1 ; <END> } 
public static TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { TYPE_1 < TYPE_2 > VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , TYPE_2 . VAR_3 ) ; for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { TYPE_2 container = METHOD_4 ( VAR_1 . METHOD_5 ( i ) ) ; if ( container != null ) { VAR_2 . set ( i , container ) ; } <START> } <END> return VAR_2 ; } 
public static int METHOD_1 ( TYPE_1 target , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { int VAR_3 = 0 ; if ( VAR_1 instanceof TYPE_3 ) { VAR_3 = TYPE_4 . METHOD_2 ( ( TYPE_3 ) VAR_1 ) ; } if ( target instanceof TYPE_3 ) { <START> VAR_3 = VAR_4 . VAR_5 . VAR_6 . TYPE_5 . METHOD_1 ( ( TYPE_3 ) target , VAR_2 , VAR_3 ) ; <END> } return VAR_3 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , List < TYPE_3 > VAR_2 , TYPE_4 VAR_3 ) <START> { <END> TYPE_3 VAR_4 = VAR_2 . get ( 0 ) ; TYPE_5 VAR_5 = VAR_4 . METHOD_2 ( ) . METHOD_3 ( VAR_4 . METHOD_4 ( ) . offset ( VAR_3 . METHOD_5 ( ) ) ) ; TYPE_1 event = new TYPE_1 ( VAR_2 , VAR_5 , VAR_1 ) ; TYPE_7 . TYPE_8 . METHOD_6 ( event ) ; return event ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { <START> if ( VAR_1 . METHOD_2 ( TYPE_7 . VAR_6 , TYPE_8 . VAR_8 ) ) <END> { TYPE_6 VAR_9 = VAR_1 . METHOD_3 ( TYPE_7 . VAR_6 , VAR_4 == TYPE_5 . VAR_10 ? TYPE_8 . VAR_8 : TYPE_8 . VAR_11 ) ; VAR_3 . METHOD_4 ( VAR_9 ) ; return TYPE_1 . METHOD_5 ( TYPE_9 . VAR_13 , VAR_1 ) ; } return TYPE_1 . METHOD_5 ( TYPE_9 . VAR_14 , VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( STRING_1 , this . VAR_2 ) ; <END> VAR_1 . METHOD_3 ( STRING_2 , VAR_3 . METHOD_4 ( ) ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( ! VAR_2 . contains ( VAR_1 ) , STRING_1 ) ; TYPE_2 . METHOD_2 ( VAR_1 . VAR_3 == this , STRING_2 ) ; VAR_1 . id = VAR_2 . size ( ) ; VAR_2 . add ( VAR_1 ) ; <START> TYPE_3 . put ( VAR_1 , new ArrayList < List < TYPE_4 > > ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( String name ) { for ( TYPE_1 VAR_1 : this . VAR_2 ) { <START> if ( VAR_1 . getName ( ) == name ) <END> return VAR_1 ; } return null ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) { TYPE_5 state = VAR_3 . METHOD_2 ( VAR_4 ) ; state = state . VAR_5 ( ) . METHOD_3 ( state , VAR_3 , VAR_4 ) ; <START> return METHOD_1 ( VAR_1 , VAR_2 , state ) ; <END> } 
public void METHOD_1 ( ) { <START> this . METHOD_2 ( this . METHOD_3 ( ) ) ; <END> } 
public void METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) { <START> TYPE_1 [ ] VAR_3 = this . VAR_3 ; <END> METHOD_2 ( VAR_1 , VAR_3 ) ; if ( TYPE_1 . METHOD_3 ( VAR_3 [ VAR_1 ] , VAR_2 ) ) return ; VAR_3 [ VAR_1 ] = VAR_2 ; METHOD_4 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { <START> TYPE_1 [ ] VAR_2 = this . VAR_2 ; <END> METHOD_2 ( VAR_1 , VAR_2 ) ; return VAR_2 [ VAR_1 ] ; } 
private void METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) <START> { <END> if ( VAR_3 == null ) { VAR_3 = TYPE_2 . METHOD_2 ( ) ; } VAR_3 . put ( VAR_1 , VAR_2 ) ; } 
<START> public static < TYPE_1 extends TYPE_2 , TYPE_3 > TYPE_4 METHOD_1 ( TYPE_1 VAR_1 ) <END> { return new TYPE_5 ( VAR_1 ) ; } 
<START> public Class getType ( ) <END> { return TYPE_1 . class ; } 
public static Set < String > METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) return ( ( TYPE_2 ) VAR_1 ) . METHOD_1 ( ) ; Set < String > VAR_2 = VAR_3 . get ( VAR_1 . VAR_4 ) ; <START> return VAR_2 != null ? VAR_5 : TYPE_3 < String > METHOD_2 ( ) ; <END> } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 target ) { super ( VAR_2 , VAR_3 , VAR_4 , target ) ; <START> } <END> 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , String node , Map < String , TYPE_2 > VAR_2 ) { if ( VAR_1 instanceof TYPE_3 ) <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> return TYPE_4 . METHOD_1 ( VAR_1 , node , VAR_2 ) ; } 
public int size ( ) <START> { <END> return properties . size ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return TYPE_2 . METHOD_2 ( TYPE_3 . of ( VAR_1 , context ( ) . METHOD_3 ( ) ) ) && VAR_1 . METHOD_4 ( ) . size ( ) == 1 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 && ! METHOD_2 ( VAR_1 ) && STRING_1 . equals ( VAR_1 . METHOD_3 ( ) . text ( ) ) ) { <END> context ( ) . METHOD_4 ( this , VAR_1 . METHOD_3 ( ) , VAR_3 ) ; } super . METHOD_1 ( VAR_1 ) ; } 
private boolean METHOD_1 ( String value ) { int VAR_1 = 0 ; for ( char c : value . VAR_2 ( ) ) { if ( TYPE_1 . contains ( c ) ) { VAR_1 ++ ; } } <START> return VAR_1 >= 2 ; <END> } 
private int METHOD_1 ( TYPE_1 VAR_1 ) { int index = 0 ; if ( VAR_1 . METHOD_2 ( ) . toString ( ) . equalsIgnoreCase ( VAR_2 ) ) { index = 1 ; } <START> return index ; <END> } 
<START> public static TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 , TYPE_4 VAR_2 ) { <END> return new TYPE_5 ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( ) { assertThat ( TYPE_1 . VAR_2 ) . METHOD_2 ( STRING_1 ) . METHOD_2 ( STRING_2 ) . METHOD_2 ( STRING_3 ) . METHOD_2 ( STRING_4 ) . METHOD_2 ( STRING_5 ) . METHOD_2 ( STRING_6 ) <START> . METHOD_3 ( STRING_7 ) <END> . METHOD_3 ( STRING_8 ) . METHOD_3 ( STRING_9 ) . METHOD_3 ( STRING_10 ) ; } 
<START> TYPE_1 ( Set < TYPE_1 > VAR_1 , ANNOTATION_1 TYPE_1 VAR_2 ) { <END> this . VAR_1 = TYPE_2 . METHOD_1 ( VAR_1 ) ; this . VAR_2 = VAR_2 ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , Collection < TYPE_1 . TYPE_3 > VAR_2 ) { TYPE_1 parent = VAR_1 ; while ( parent != null && ! VAR_2 . contains ( parent . VAR_3 ( ) ) ) { parent = parent . VAR_4 ( ) ; } <START> if ( parent != null ) { <END> return parent ; } return null ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) . parse ( STRING_1 ) ; TYPE_3 VAR_2 = ( ( TYPE_4 ) VAR_1 ) . METHOD_3 ( ) . METHOD_4 ( ) . get ( 0 ) ; assertThat ( METHOD_5 ( VAR_2 , VAR_1 ) ) . METHOD_6 ( ) ; <START> assertThat ( METHOD_5 ( VAR_1 , VAR_2 ) ) . METHOD_7 ( ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 forEach ) { if ( forEach . VAR_1 ( ) . size ( ) > 1 ) { return true ; } <START> TYPE_2 VAR_2 = forEach . VAR_1 ( ) . get ( 0 ) ; <END> if ( VAR_2 . is ( TYPE_5 . TYPE_4 . VAR_5 ) ) { return ( ( TYPE_3 ) VAR_2 ) . METHOD_2 ( ) . size ( ) > 1 ; } return false ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 . add ( VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( ) . stream ( ) . forEach ( this : : METHOD_3 ) ; <END> super . METHOD_1 ( VAR_1 ) ; } 
<START> private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_1 . is ( TYPE_4 . TYPE_3 . VAR_4 ) && STRING_1 . equals ( ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) . toString ( ) ) ; } 
public TYPE_1 parse ( File VAR_1 ) { try ( TYPE_2 VAR_2 = new TYPE_3 ( VAR_1 ) ) { final Object VAR_3 = METHOD_1 ( ) . METHOD_2 ( VAR_2 ) ; TYPE_1 VAR_4 = ( TYPE_1 ) VAR_3 ; <START> return VAR_4 ; <END> } catch ( IOException e ) { throw new IllegalStateException ( STRING_1 + VAR_1 . METHOD_3 ( ) , e ) ; } } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return ImmutableList . VAR_1 ( TYPE_2 . filter ( VAR_2 , input - > input != null ? ! input . is ( TYPE_3 . VAR_4 ) : false ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . is ( TYPE_3 . TYPE_2 . VAR_4 ) && STRING_1 . equals ( VAR_1 . object ( ) . toString ( ) ) && ! METHOD_2 ( VAR_1 ) && ! METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ) { <END> context ( ) . METHOD_5 ( this , VAR_5 ) . METHOD_6 ( VAR_1 ) ; } super . METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( STRING_1 ) ) { <END> VAR_1 . METHOD_3 ( ) . forEach ( VAR_2 - > VAR_3 . add ( VAR_2 . METHOD_4 ( ) . text ( ) ) ) ; } } 
private TYPE_1 METHOD_1 ( ) { List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( ) . stream ( ) . filter ( VAR_2 - > VAR_2 instanceof TYPE_3 ) <START> . map ( VAR_2 - > TYPE_2 . METHOD_3 ( ( TYPE_3 ) VAR_2 ) ) <END> . collect ( Collectors . VAR_3 ( ) ) ; return VAR_1 . isEmpty ( ) ? null : VAR_1 . get ( 0 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { return STRING_1 . equals ( VAR_2 . text ( ) ) ? new TYPE_4 ( VAR_1 , VAR_2 , VAR_3 ) <START> : null ; <END> } 
<START> private boolean METHOD_1 ( TYPE_1 token ) { <END> return TYPE_2 . METHOD_2 ( token , TYPE_3 . VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 . is ( TYPE_3 . VAR_4 ) ) { <START> context ( ) . METHOD_4 ( this . VAR_5 , VAR_6 ) . METHOD_5 ( VAR_2 ) ; <END> } super . METHOD_1 ( VAR_1 ) ; } 
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null ) { return false ; } <START> if ( ! ( obj instanceof TYPE_1 ) ) { <END> return false ; } if ( getId ( ) == null ) { return super . equals ( obj ) ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return getId ( ) . equals ( VAR_1 . getId ( ) ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( StringUtils . VAR_3 ( VAR_2 ) ) return false ; <START> TYPE_1 VAR_4 = VAR_5 . METHOD_3 ( VAR_2 , false ) ; <END> if ( VAR_4 != null && ! VAR_4 . getId ( ) . equals ( VAR_1 . getId ( ) ) ) return true ; return false ; } 
private static String METHOD_1 ( String VAR_1 , String VAR_2 ) { final TYPE_1 VAR_3 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> String value = VAR_3 . METHOD_4 ( VAR_1 ) . get ( 0 ) ; <END> if ( value == null ) { value = VAR_2 ; } return value ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 resource = client ( ) . resource ( STRING_1 ) ; TYPE_1 . Builder builder = resource . type ( TYPE_4 . VAR_2 ) ; boolean VAR_3 = false ; try { builder . VAR_4 ( TYPE_2 . class , null ) ; } catch ( TYPE_3 e ) { VAR_3 = true ; assertEquals ( STRING_2 , INT_1 , e . VAR_5 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ) ; } <START> if ( ! VAR_3 ) { <END> METHOD_4 ( STRING_3 ) ; } } 
private static TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { try { TYPE_2 . METHOD_2 ( STRING_1 ) ; VAR_1 = true ; } catch ( final TYPE_3 VAR_2 ) { VAR_1 = false ; } } <START> return VAR_1 ? new TYPE_1 ( ) : null ; <END> } 
public TYPE_1 ( Logger logger , Level VAR_2 ) { this . logger = logger ; this . VAR_2 = VAR_2 ; this . VAR_3 = false ; this . VAR_4 = Thread . VAR_5 ( ) . getId ( ) ; <START> this . VAR_3 = true ; <END> } 
<START> public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 , TYPE_3 { <END> assertEquals ( 1 , Constants . VAR_1 ( STRING_1 ) ) ; assertEquals ( INT_1 , Constants . VAR_1 ( STRING_2 ) ) ; assertEquals ( INT_2 , Constants . VAR_1 ( STRING_3 ) ) ; assertEquals ( INT_3 , Constants . VAR_1 ( STRING_4 ) ) ; } 
TYPE_1 METHOD_1 ( String host , int VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_2 != null ) { return new TYPE_1 ( VAR_3 , <START> TYPE_3 . create ( host + STRING_1 + String . valueOf ( VAR_1 ) ) , <END> VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) , null ) ; } else { return new TYPE_1 ( VAR_3 , host , VAR_1 , false ) ; } } 
private boolean METHOD_1 ( boolean VAR_1 ) { <START> return VAR_2 || VAR_1 || VAR_3 . size ( ) >= VAR_4 ; <END> } 
void METHOD_1 ( boolean VAR_1 ) { synchronized ( this ) { <START> this . VAR_1 = VAR_1 ; <END> } } 
public boolean METHOD_1 ( ) { <START> if ( index == 0 ) { <END> return true ; } else { return false ; } } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 . equals ( TYPE_1 ) ) { <END> return false ; } else { return true ; } } 
private boolean METHOD_1 ( long time ) { <START> if ( time < VAR_1 ) { <END> return false ; } else { return true ; } } 
public static TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; synchronized ( VAR_1 ) { if ( VAR_1 == null ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> } } } return VAR_1 ; } 
public List < TYPE_1 > METHOD_1 ( String host ) { <START> if ( VAR_1 != null ) { <END> return VAR_1 . get ( host ) ; } return null ; } 
private static String METHOD_1 ( int length ) { String VAR_1 = STRING_1 ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> TYPE_2 sb = new TYPE_2 ( ) ; <END> for ( int i = 0 ; i < length ; i ++ ) { int VAR_3 = VAR_2 . METHOD_2 ( VAR_1 . length ( ) ) ; sb . append ( VAR_1 . METHOD_3 ( VAR_3 ) ) ; } return sb . toString ( ) ; } 
public void METHOD_1 ( ) { <START> System . VAR_1 ( ) ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } <START> if ( o instanceof TYPE_1 ) { <END> TYPE_1 VAR_1 = ( TYPE_1 ) o ; return TYPE_2 . equals ( parent , VAR_1 . parent ) && TYPE_2 . equals ( getId ( ) , VAR_1 . getId ( ) ) ; } return false ; } 
public void update ( TYPE_1 event ) { TYPE_2 < ? > VAR_1 = VAR_2 . METHOD_1 ( ) ; <START> TYPE_2 < TYPE_3 > VAR_3 = ( TYPE_2 < TYPE_3 > ) VAR_1 ; <END> if ( VAR_3 . METHOD_2 ( ) . getId ( ) != null && VAR_1 . METHOD_2 ( ) instanceof TYPE_3 ) { event . VAR_4 ( ) . METHOD_3 ( true ) ; } else event . VAR_4 ( ) . METHOD_3 ( false ) ; } 
protected TYPE_1 METHOD_1 ( long VAR_1 , double VAR_2 , TYPE_1 VAR_3 , boolean VAR_4 ) { if ( VAR_4 ) { TYPE_1 VAR_5 = TYPE_2 . METHOD_2 ( new long [ ] { 1 , VAR_1 } , VAR_2 ) ; <START> VAR_3 . METHOD_3 ( VAR_5 ) ; <END> } return VAR_3 ; } 
public void close ( ) throws Exception { if ( VAR_1 || isEmpty ( ) ) return ; if ( ! METHOD_1 ( ) ) <START> throw new TYPE_1 ( STRING_1 ) ; <END> data . close ( ) ; VAR_1 = true ; } 
private void METHOD_1 ( ) { if ( status == null ) { status = METHOD_2 ( ) ; } if ( options == null ) { options = METHOD_3 ( ) ; if ( VAR_1 != null ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 . METHOD_4 ( ) ) ; METHOD_5 ( options , VAR_2 , VAR_2 . METHOD_6 ( ) . length , status ) ; if ( METHOD_7 ( status ) != VAR_3 ) { <START> throw new RuntimeException ( STRING_1 + METHOD_8 ( status ) . getString ( ) ) ; <END> } } } } 
protected void METHOD_1 ( long [ ] VAR_1 ) { if ( VAR_1 . length == 1 ) { VAR_2 = 1 ; <START> VAR_3 = ( int ) VAR_1 [ 0 ] ; <END> } else if ( this . METHOD_2 ( ) . length == 2 ) { VAR_2 = ( int ) VAR_1 [ 0 ] ; VAR_3 = ( int ) VAR_1 [ 1 ] ; } VAR_4 = VAR_1 . length ; } 
<START> public Builder ( ) { <END> super ( new int [ ] { 1 , 1 , 1 } , new int [ ] { 1 , 1 , 1 } , new int [ ] { 0 , 0 , 0 } , new int [ ] { 0 , 0 , 0 } ) ; } 
public TYPE_3 ( TYPE_1 conf , TYPE_2 input ) { this . input = input ; <START> this . conf = conf ; <END> } 
public TYPE_1 create ( String VAR_1 ) { if ( VAR_1 . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } TYPE_2 t = new TYPE_2 ( VAR_2 , VAR_1 , VAR_3 ) ; <START> <END> if ( VAR_4 != null ) { t . VAR_5 ( VAR_4 ) ; } return t ; } 
public boolean METHOD_1 ( int VAR_1 ) { <START> if ( VAR_1 >= VAR_2 ) <END> throw new TYPE_1 ( STRING_1 ) ; return VAR_3 . get ( VAR_1 ) . hasNext ( ) ; } 
public boolean hasNext ( ) { if ( VAR_1 != null ) throw VAR_1 ; try { if ( VAR_2 != null && VAR_2 != VAR_3 ) { return true ; } else if ( VAR_2 == VAR_3 ) return false ; VAR_2 = buffer . VAR_4 ( ) ; if ( VAR_2 == VAR_3 ) return false ; return true ; } catch ( Exception e ) { <START> log . error ( STRING_1 ) ; <END> return false ; } } 
public void METHOD_1 ( ) { buffer . clear ( ) ; if ( VAR_1 != null ) VAR_1 . METHOD_2 ( ) ; try { if ( VAR_1 != null ) VAR_1 . METHOD_3 ( ) ; <START> } catch ( InterruptedException e ) { <END> } buffer . clear ( ) ; } 
public Builder ( ) { this . VAR_1 = new int [ ] { 5 , 1 } ; <START> this . VAR_2 = new int [ ] { 1 , 1 } ; <END> this . VAR_3 = new int [ ] { 0 , 0 } ; } 
<START> public static void METHOD_1 ( String [ ] args ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( ) ) ; VAR_1 . start ( ) ; logger . info ( STRING_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> throw new TYPE_2 ( ) ; <END> } 
public TYPE_1 params ( boolean VAR_1 ) { if ( VAR_1 ) return params ( ) ; List < TYPE_1 > params = new ArrayList < > ( ) ; for ( TYPE_2 VAR_2 : METHOD_1 ( ) ) { TYPE_1 VAR_3 ; if ( VAR_2 instanceof TYPE_3 ) <START> VAR_3 = ( ( TYPE_3 ) VAR_2 ) . METHOD_2 ( ) ; <END> else VAR_3 = VAR_2 . params ( ) ; if ( VAR_3 != null ) params . add ( VAR_3 ) ; } return TYPE_4 . METHOD_3 ( CHAR_1 , params ) ; } 
<START> public void METHOD_1 ( TYPE_1 state ) throws IllegalArgumentException { <END> if ( ! this . state . VAR_1 ( state ) ) { throw new IllegalArgumentException ( STRING_1 + this . state . name ( ) + STRING_2 + state . name ( ) + STRING_3 ) ; } this . state = state ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! VAR_2 . add ( VAR_1 ) ) <END> throw new IllegalArgumentException ( STRING_1 ) ; if ( VAR_3 . contains ( VAR_1 ) ) throw new IllegalArgumentException ( STRING_2 ) ; this . VAR_4 . remove ( VAR_1 ) ; } 
<START> public TYPE_4 ( Map < TYPE_1 , TYPE_2 > VAR_2 , Map < TYPE_3 , TYPE_1 > VAR_3 ) { <END> if ( VAR_2 == null || VAR_3 == null ) throw new IllegalArgumentException ( STRING_1 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public Object METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 { try { <START> return TYPE_3 . valueOf ( TYPE_4 . parse ( VAR_2 , TYPE_5 . METHOD_2 ( STRING_1 ) ) ) ; <END> } catch ( TYPE_6 e ) { throw TYPE_7 . create ( STRING_2 + VAR_1 + STRING_3 + VAR_2 , e ) ; } } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) ; String output = TYPE_4 . METHOD_3 ( VAR_1 ) ; Assert . assertNotNull ( output ) ; TYPE_5 stream = getClass ( ) . METHOD_4 ( VAR_2 ) ; String VAR_3 = TYPE_6 . toString ( stream , TYPE_7 . VAR_5 ) ; <START> System . out . println ( output ) ; <END> assertEquals ( VAR_3 . length ( ) , output . length ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( FLOAT_1 , FLOAT_2 ) ; TYPE_1 VAR_2 = new TYPE_1 ( FLOAT_3 , FLOAT_1 ) ; TYPE_1 result = TYPE_2 . METHOD_2 ( VAR_1 , VAR_2 ) ; TYPE_1 VAR_3 = new TYPE_1 ( FLOAT_4 , FLOAT_5 ) ; <START> METHOD_3 ( VAR_3 , result , FLOAT_6 ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 = VAR_2 + STRING_1 ; <END> METHOD_2 ( VAR_3 ) ; } 
public static boolean METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 == null ) { <END> return false ; } return TYPE_1 . equalsIgnoreCase ( VAR_1 ) ; } 
public static String METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 == null ) { <END> return null ; } if ( ! METHOD_2 ( VAR_1 ) ) { return VAR_1 ; } return VAR_1 . substring ( 0 , VAR_1 . length ( ) - 1 ) ; } 
public void METHOD_1 ( TYPE_1 ctx , TYPE_2 req ) { METHOD_2 ( ctx , req ) ; TYPE_3 VAR_1 = new TYPE_3 ( ctx , null ) ; TYPE_4 VAR_2 = new TYPE_4 ( VAR_3 . METHOD_1 ( VAR_1 ) ) ; ArrayList < TYPE_5 > VAR_4 = new ArrayList < > ( 1 ) ; VAR_4 . add ( new TYPE_5 ( VAR_2 ) ) ; <START> ctx . VAR_5 ( new TYPE_6 < TYPE_5 > ( VAR_4 ) ) ; <END> } 
protected TYPE_1 METHOD_1 ( Path VAR_1 , String VAR_2 , String VAR_3 ) { TYPE_1 VAR_4 = VAR_5 . get ( VAR_2 ) ; if ( VAR_4 != null ) { String VAR_6 = VAR_4 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( ! METHOD_4 ( VAR_3 , VAR_7 , VAR_6 ) ) { throw TYPE_2 . get ( TYPE_3 . VAR_9 , VAR_2 + STRING_1 + VAR_3 + STRING_2 + VAR_7 ) ; } } <START> return VAR_5 . get ( VAR_2 ) ; <END> } 
private static Set < String > METHOD_1 ( String ... x ) { HashSet < String > set = new HashSet < > ( ) ; for ( String a : x ) <START> set . add ( a ) ; <END> return set ; } 
public Integer METHOD_1 ( ) { if ( to == null ) { return null ; } else <START> return this . to ; <END> } 
public static void METHOD_1 ( Response response ) throws TYPE_1 { List < Throwable > VAR_1 = new ArrayList < Throwable > ( ) ; for ( TYPE_2 error : response . VAR_2 ( ) ) { <START> Exception e = new Exception ( error . getMessage ( ) , error ) ; <END> e . VAR_3 ( ) ; VAR_1 . add ( e ) ; } if ( ! VAR_1 . isEmpty ( ) ) { throw new TYPE_1 ( VAR_1 ) ; } } 
<START> public static int METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return VAR_2 + 1 ; } final int r = VAR_1 . METHOD_2 ( ) ; final int VAR_3 = VAR_1 . METHOD_3 ( ) ; final int b = VAR_1 . METHOD_4 ( ) ; int VAR_4 = ( r > VAR_3 ) ? r : VAR_3 ; <END> if ( b > VAR_4 ) { VAR_4 = b ; } return VAR_4 ; } 
public final TYPE_1 METHOD_1 ( final int page ) { if ( METHOD_2 ( ) == false ) { throw new IllegalStateException ( ) ; } try { return VAR_1 . get ( page ) ; } catch ( TYPE_2 e ) { throw e ; <START> } <END> } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) != null && VAR_1 . METHOD_2 ( ) instanceof TYPE_2 ) { <START> return METHOD_1 ( VAR_1 ) ; <END> } return VAR_1 . METHOD_2 ( ) ; } 
<START> protected Boolean METHOD_1 ( ) { <END> return false ; } 
<START> public void METHOD_1 ( int b ) { <END> VAR_1 = b ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( value ) ; <END> } 
public T METHOD_1 ( Object value ) { <START> return METHOD_2 ( value ) ; <END> } 
public TYPE_2 ( TYPE_1 in ) throws IOException { if ( in . VAR_2 ( ) . METHOD_1 ( TYPE_3 . VAR_4 ) ) { if ( in . VAR_5 ( ) ) { <START> VAR_6 = Integer . VAR_7 ; } else { VAR_6 = in . VAR_8 ( ) ; <END> } } else { VAR_6 = Integer . VAR_7 ; } } 
public static < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_1 , TYPE_2 > of ( List < TYPE_1 > list , TYPE_4 < ? super TYPE_1 , ? extends TYPE_2 > VAR_1 ) { <START> if ( ! ( list instanceof TYPE_5 ) ) { <END> throw new IllegalArgumentException ( STRING_1 + STRING_2 ) ; } return new TYPE_3 < > ( list , VAR_1 ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { super . METHOD_1 ( VAR_1 , VAR_2 ) ; TYPE_2 VAR_3 = ( ( TYPE_3 ) VAR_1 ) ; this . VAR_4 = ( ( TYPE_3 ) VAR_1 ) . VAR_4 ; if ( ! TYPE_4 . equals ( this . VAR_5 , VAR_3 . VAR_5 ) ) { throw new IllegalArgumentException ( STRING_1 + name ( ) + STRING_2 <START> + this . METHOD_2 ( ) . VAR_5 + STRING_3 + VAR_3 . METHOD_2 ( ) . VAR_5 + STRING_4 ) ; <END> } } 
<START> public void METHOD_1 ( int VAR_1 ) throws IOException { <END> this . VAR_1 = VAR_1 ; } 
public static TYPE_1 < ? > METHOD_1 ( String VAR_1 ) { <START> return TYPE_2 . METHOD_2 ( VAR_1 , null ) ; <END> } 
public static Map < String , Object > METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> try { <END> final TYPE_3 VAR_3 = METHOD_2 ( VAR_1 ) ; TYPE_4 parser = VAR_2 . METHOD_3 ( ) . METHOD_4 ( TYPE_6 . VAR_5 , TYPE_7 . VAR_7 , VAR_3 ) ; return parser . map ( ) ; } catch ( IOException e ) { throw new TYPE_5 ( e ) ; } } 
private static void METHOD_1 ( int VAR_1 ) { <START> assert VAR_1 == 2 <END> : STRING_1 + VAR_1 ; } 
public static TYPE_1 < ? > METHOD_1 ( TYPE_1 < ? > VAR_1 , TYPE_1 < ? > VAR_2 ) { <START> TYPE_2 VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; <END> if ( ! VAR_3 . METHOD_3 ( ) ) { return null ; } return VAR_3 . METHOD_1 ( ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return List . VAR_1 ( VAR_2 ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 != null && ( VAR_1 . METHOD_2 ( ) . size ( ) > 1 || ( VAR_1 . METHOD_2 ( ) . size ( ) == 1 && ! VAR_1 . METHOD_2 ( ) . get ( 0 ) . name ( ) . equals ( STRING_1 ) ) ) ; <END> } 
public void METHOD_1 ( ) { execute ( STRING_1 ) ; execute ( STRING_2 ) ; METHOD_2 ( ) ; execute ( STRING_3 ) ; assertEquals ( 1 , response . VAR_1 ( ) ) ; assertEquals ( METHOD_3 ( response . VAR_2 ( ) ) , STRING_4 ) ; execute ( STRING_5 ) ; <START> assertEquals ( 1 , response . VAR_1 ( ) ) ; <END> assertEquals ( METHOD_3 ( response . VAR_2 ( ) ) , STRING_4 ) ; VAR_3 . METHOD_4 ( METHOD_5 ( STRING_6 ) ) ; execute ( STRING_7 ) ; } 
public < TYPE_1 > TYPE_2 < TYPE_1 > map ( TYPE_3 < ? super T , ? extends TYPE_1 > VAR_1 ) { <START> return new TYPE_4 ( name , VAR_2 , VAR_3 , VAR_4 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { execute ( STRING_1 ) ; execute ( STRING_2 ) ; assertEquals ( 1 , response . VAR_1 ( ) ) ; METHOD_2 ( ) ; execute ( STRING_3 ) ; assertThat ( METHOD_3 ( response . VAR_2 ( ) ) , is ( STRING_4 ) ) ; <START> METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { execute ( STRING_1 ) ; execute ( STRING_2 ) ; assertEquals ( 1 , response . VAR_1 ( ) ) ; METHOD_2 ( ) ; execute ( STRING_3 ) ; assertThat ( response . VAR_2 ( ) [ 0 ] , is ( STRING_4 ) ) ; assertThat ( response . VAR_1 ( ) , is ( INT_1 ) ) ; <START> METHOD_2 ( ) ; <END> } 
public long METHOD_1 ( ) { if ( VAR_1 == - 1 ) { <START> return VAR_1 ; <END> } return VAR_2 / VAR_1 ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { VAR_2 . METHOD_2 ( VAR_1 ) ; <START> return TYPE_2 . METHOD_3 ( new byte [ VAR_1 ] ) ; <END> } 
public Double METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { Object value = VAR_1 . value ( ) ; if ( value instanceof Boolean ) { <START> Boolean val = ( Boolean ) VAR_1 . value ( ) ; <END> return ( val == null || ! val ) ? FLOAT_1 : FLOAT_2 ; } return super . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 < Integer > METHOD_1 ( ) { for ( TYPE_2 VAR_1 : VAR_2 ) { try { VAR_1 . METHOD_2 ( ) ; } catch ( Throwable t ) { <START> LOGGER . error ( STRING_1 , t , VAR_1 ) ; <END> } } Collection < TYPE_3 > VAR_3 = ImmutableList . VAR_4 ( VAR_5 . keySet ( ) ) ; if ( VAR_3 . isEmpty ( ) ) { return TYPE_1 . METHOD_3 ( 0 ) ; } return METHOD_4 ( VAR_3 , null ) ; } 
public TYPE_1 < Integer > METHOD_1 ( Collection < TYPE_2 > VAR_1 , ANNOTATION_1 String VAR_2 ) { for ( TYPE_3 VAR_3 : VAR_4 ) { for ( TYPE_2 job : VAR_1 ) { try { VAR_3 . METHOD_2 ( job ) ; } catch ( Throwable t ) { <START> LOGGER . error ( STRING_1 , t , VAR_3 ) ; <END> } } } return METHOD_3 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 , TYPE_4 < TYPE_5 , TYPE_6 > VAR_2 , TYPE_7 VAR_3 ) { <START> TYPE_8 VAR_4 = new TYPE_9 ( <END> VAR_5 , VAR_3 , VAR_2 , TYPE_11 . VAR_7 , null ) ; TYPE_6 VAR_8 ; if ( VAR_1 . METHOD_2 ( ) != null ) { VAR_8 = VAR_4 . METHOD_3 ( VAR_1 . METHOD_2 ( ) , new TYPE_10 ( ) ) ; } else { VAR_8 = null ; } return new TYPE_1 ( VAR_8 ) ; } 
TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( METHOD_3 ( ) , <END> VAR_1 . METHOD_4 ( ) , TYPE_4 . VAR_5 ) ; VAR_1 . METHOD_5 ( ( TYPE_3 ) VAR_2 ) ; return VAR_2 ; } 
TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return METHOD_2 ( METHOD_3 ( ) , VAR_1 , TYPE_3 . VAR_3 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( ) ; execute ( STRING_1 + STRING_2 + STRING_3 ) ; assertThat ( METHOD_3 ( response . VAR_2 ( ) ) , is ( STRING_4 ) ) ; <START> assertThat ( METHOD_3 ( response . VAR_2 ( ) ) , <END> is ( STRING_4 ) ) ; } 
public TYPE_1 next ( ) { if ( ! hasNext ( ) ) { throw new TYPE_2 ( STRING_1 ) ; } TYPE_3 VAR_1 = VAR_2 . next ( ) ; if ( VAR_1 . column ( ) . METHOD_1 ( ) == false ) { return new TYPE_1 ( VAR_3 , VAR_1 , null ) ; } Integer position = VAR_1 . position ( ) ; if ( position == null ) { <START> position = VAR_4 . METHOD_2 ( ) ; <END> } VAR_4 ++ ; return new TYPE_1 ( VAR_3 , VAR_1 , position ) ; } 
public boolean METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { try { <START> this . count = ( int ) VAR_1 . METHOD_2 ( ) . count ( query ) ; <END> return count == VAR_2 ; } catch ( IOException e ) { return false ; } } 
<START> public static TYPE_1 < TYPE_5 . TYPE_6 > METHOD_1 ( TYPE_3 query , int VAR_1 ) { <END> return new TYPE_4 ( query , VAR_1 ) ; } 
<START> public static TYPE_1 < TYPE_5 . TYPE_6 > METHOD_1 ( int VAR_1 ) { <END> return new TYPE_3 ( TYPE_4 . METHOD_2 ( ) , VAR_1 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . apply ( STRING_1 ) ; <START> Assert . assertEquals ( VAR_1 , <END> new TYPE_1 ( ) . METHOD_2 ( 1 ) . METHOD_3 ( 1 ) . METHOD_4 ( 1 ) . METHOD_5 ( 1 ) . METHOD_6 ( 1 ) . METHOD_7 ( 1 ) ) ; } 
public TYPE_3 ( String value , TYPE_1 VAR_2 , TYPE_2 VAR_3 , ANNOTATION_1 TYPE_2 VAR_4 ) { METHOD_1 ( value , STRING_1 ) ; METHOD_1 ( VAR_2 , STRING_2 ) ; METHOD_1 ( VAR_3 , STRING_3 ) ; <START> <END> this . value = value ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public TYPE_1 < Long > METHOD_1 ( ) { TYPE_1 < Long > VAR_1 = new TYPE_1 < > ( ) ; for ( long VAR_2 : VAR_3 ) { VAR_1 . METHOD_2 ( VAR_2 , ( key , VAR_4 ) - > { if ( VAR_4 == null ) { <START> return INT_1 ; <END> } else { return VAR_4 + VAR_2 ; } } ) ; } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < ? > VAR_2 ) { VAR_3 . put ( VAR_1 , VAR_2 ) ; final TYPE_3 VAR_4 = VAR_1 . column ( ) ; if ( ! VAR_4 . METHOD_2 ( ) ) { List < TYPE_1 > VAR_5 = VAR_6 . METHOD_3 ( VAR_4 . name ( ) , <START> new ArrayList < > ( ) ) ; <END> VAR_5 . add ( VAR_1 ) ; VAR_6 . put ( VAR_4 . name ( ) , VAR_5 ) ; } } 
public void METHOD_1 ( ) throws IOException { <START> VAR_1 . METHOD_2 ( IllegalArgumentException . VAR_2 ) ; <END> VAR_1 . METHOD_3 ( METHOD_4 ( STRING_1 ) ) ; final long VAR_3 = TYPE_5 . TYPE_6 . METHOD_5 ( METHOD_6 ( INT_1 , 10 ) ) ; final TYPE_2 VAR_4 = METHOD_7 ( TYPE_2 . VAR_2 ) ; final TYPE_3 VAR_5 = new TYPE_3 ( METHOD_7 ( TYPE_4 . VAR_2 ) , VAR_4 ) ; VAR_5 . METHOD_8 ( VAR_4 , METHOD_9 ( 1 , 10 ) , null , VAR_3 ) ; } 
public Map < Object , Object > value ( Object value ) { Map < Object , Object > map = ( Map < Object , Object > ) value ; if ( map == null ) { return map ; } <START> return new HashMap < > ( map ) ; <END> } 
public void METHOD_1 ( ) throws Exception { execute ( STRING_1 ) ; <START> METHOD_2 ( ) ; <END> String VAR_1 = STRING_2 + STRING_3 + STRING_4 + STRING_5 ; assertEquals ( VAR_1 , METHOD_3 ( STRING_6 ) ) ; } 
public < T > int METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 , ANNOTATION_1 TYPE_1 < T > VAR_4 , List < T > VAR_5 ) { if ( VAR_1 == VAR_3 ) { return VAR_1 ; } else { if ( VAR_4 != null ) { <START> return METHOD_2 ( VAR_5 , VAR_3 , VAR_4 ) ; <END> } else { return VAR_3 ; } } } 
<START> public void METHOD_1 ( ) { <END> METHOD_2 ( STRING_1 ) ; METHOD_2 ( STRING_2 ) ; execute ( STRING_3 , null , METHOD_3 ( ) ) ; String VAR_1 = STRING_4 + STRING_5 + STRING_6 + STRING_7 ; METHOD_2 ( VAR_1 ) ; assertThat ( METHOD_4 ( response . VAR_2 ( ) ) , is ( STRING_8 + STRING_9 + STRING_10 ) ) ; METHOD_2 ( STRING_11 + VAR_3 ) ; execute ( VAR_1 , null , METHOD_3 ( ) ) ; assertThat ( METHOD_4 ( response . VAR_2 ( ) ) , is ( STRING_8 ) ) ; } 
public TYPE_1 build ( ) { return new TYPE_1 ( method , VAR_1 , VAR_2 , VAR_3 , VAR_4 , position , VAR_5 , VAR_6 , <START> VAR_7 , VAR_8 , VAR_9 , parameters , VAR_10 , VAR_11 , VAR_12 , VAR_13 ) ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
private static String METHOD_1 ( TYPE_1 params , String VAR_1 ) { <START> if ( params != null && params . size ( ) > 0 && params . get ( VAR_2 ) != null ) { <END> return VAR_1 + VAR_2 + STRING_1 + params . get ( VAR_2 ) ; } return VAR_1 ; } 
public < R > R METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , TYPE_1 VAR_3 , String VAR_4 , TYPE_2 params , boolean VAR_5 ) throws TYPE_3 { if ( VAR_1 == null || VAR_3 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } Class < ? > VAR_6 = VAR_1 . METHOD_2 ( ) ; Class < ? > VAR_7 = VAR_3 . METHOD_2 ( ) ; <START> TYPE_4 VAR_8 ; <END> VAR_8 = METHOD_3 ( VAR_5 , VAR_6 , VAR_7 ) ; return execute ( VAR_8 , VAR_2 , VAR_4 , params ) ; } 
private TYPE_1 METHOD_1 ( boolean VAR_1 , Class < ? > VAR_2 ) { TYPE_1 VAR_3 ; <START> if ( VAR_1 == true ) { <END> VAR_3 = new TYPE_1 ( TYPE_2 . VAR_5 , VAR_2 ) ; } else { VAR_3 = new TYPE_1 ( TYPE_2 . VAR_6 , VAR_2 ) ; } return VAR_3 ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { boolean VAR_2 = METHOD_2 ( ) ; if ( VAR_2 ) { <START> List < TYPE_3 > VAR_3 = new ArrayList < TYPE_3 > ( ) ; <END> TYPE_3 VAR_4 = new TYPE_3 ( ) ; VAR_4 . METHOD_3 ( STRING_1 ) ; VAR_4 . METHOD_4 ( STRING_2 ) ; VAR_4 . METHOD_5 ( STRING_3 ) ; VAR_3 . add ( VAR_4 ) ; VAR_1 . METHOD_6 ( VAR_3 ) ; } } 
public Boolean METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_1 { <START> if ( VAR_1 == null && VAR_2 == null ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } return VAR_3 . METHOD_2 ( TYPE_2 . VAR_5 , VAR_1 , TYPE_2 . VAR_6 , VAR_2 ) ; } 
private static void METHOD_1 ( ) throws TYPE_1 , IOException { VAR_1 = new Object ( ) { } . getClass ( ) . METHOD_2 ( ) . getName ( ) ; System . out . println ( VAR_1 = STRING_1 + VAR_1 ) ; TYPE_2 VAR_2 = TYPE_3 . METHOD_3 ( ) ; TYPE_4 response = VAR_2 . METHOD_4 ( ) ; System . out . println ( STRING_2 + ( response . VAR_3 ( ) . METHOD_5 ( ) != null ) ) ; <START> <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 ) { this . VAR_3 = TYPE_2 . METHOD_1 ( VAR_3 , STRING_1 ) ; this . VAR_4 = TYPE_2 . METHOD_1 ( VAR_4 , STRING_2 ) ; this . VAR_5 = TYPE_2 . METHOD_1 ( VAR_5 , STRING_3 ) ; <START> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 , STRING_4 ) . name ( ) ; <END> } 
<START> public boolean METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) <END> throws TYPE_1 { TYPE_2 params = TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; return VAR_4 . execute ( VAR_5 , VAR_1 , VAR_2 , params ) ; } 
public static TYPE_1 METHOD_1 ( ) throws TYPE_2 { TYPE_3 VAR_1 = TYPE_4 . METHOD_2 ( ) ; List < TYPE_1 > VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( VAR_2 == null ) { return null ; } int VAR_3 = ( int ) Math . VAR_4 ( Math . VAR_5 ( ) * ( VAR_2 . size ( ) - 1 ) ) ; <START> VAR_3 = 1 ; <END> return VAR_2 . get ( VAR_3 ) ; } 
public boolean METHOD_1 ( String VAR_1 ) throws TYPE_1 { String VAR_2 = new String ( VAR_3 . METHOD_2 ( VAR_4 + STRING_1 + VAR_1 ) ) ; String VAR_5 = VAR_3 . METHOD_3 ( VAR_2 , TYPE_3 . VAR_7 ) ; boolean VAR_8 = false ; TYPE_2 response = new TYPE_2 ( VAR_5 ) ; <START> if ( response . VAR_9 ( ) == 0 ) <END> VAR_8 = true ; return VAR_8 ; } 
private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 ) { if ( VAR_1 == null ) { if ( log . VAR_2 ( ) ) log . debug ( STRING_1 ) ; return null ; } if ( VAR_1 . size ( ) == 1 ) { return VAR_1 . get ( 0 ) ; } <START> final long VAR_3 = Math . VAR_4 ( VAR_5 . METHOD_2 ( ) ) ; <END> final int index = ( int ) ( VAR_3 % VAR_1 . size ( ) ) ; return VAR_1 . get ( index ) ; } 
void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <START> VAR_2 . VAR_1 = VAR_1 ; <END> } 
public static Map < String , Object > METHOD_1 ( ) { <START> return new HashMap < > ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( ) . METHOD_4 ( ) ) ; <END> } 
public static List < TYPE_1 > METHOD_1 ( ) { <START> TYPE_2 < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <END> return new ArrayList < > ( VAR_1 ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 Context VAR_1 ) { <START> synchronized ( VAR_2 ) { <END> if ( client == null ) { client = new TYPE_1 ( VAR_1 ) ; TYPE_2 . METHOD_2 ( client ) ; } else { METHOD_3 ( ) ; } } return client ; } 
public static Map < String , Object > METHOD_1 ( ) { HashMap < String , Object > data = new HashMap < > ( ) ; TYPE_1 source = METHOD_2 ( ) . METHOD_1 ( ) ; data . VAR_1 ( source . VAR_2 ( ) ) ; data . VAR_1 ( source . VAR_3 ( ) ) ; <START> data . VAR_1 ( source . VAR_4 ( ) ) ; <END> return data ; } 
void METHOD_1 ( ) { METHOD_2 ( ) ; super . METHOD_3 ( new TYPE_1 ( TYPE_6 . TYPE_7 . VAR_3 , config ) ) ; <START> final TYPE_2 client = this ; <END> try { TYPE_3 . run ( new TYPE_4 ( ) { @Override public void run ( ) { METHOD_4 ( ) ; } } ) ; } catch ( TYPE_5 ex ) { Logger . warn ( STRING_1 , ex ) ; } } 
<START> void METHOD_1 ( ) { <END> METHOD_2 ( ) ; METHOD_3 ( new TYPE_1 ( TYPE_2 . TYPE_3 . VAR_3 , null ) ) ; } 
public void value ( ANNOTATION_1 File file ) throws IOException { super . METHOD_1 ( ) ; METHOD_2 ( false ) ; TYPE_1 input = null ; try { TYPE_2 VAR_1 = new TYPE_2 ( file ) ; <START> input = new TYPE_3 ( new TYPE_4 ( VAR_1 , STRING_1 ) ) ; <END> TYPE_5 . METHOD_3 ( input , out ) ; } finally { TYPE_5 . METHOD_4 ( input ) ; } out . VAR_2 ( ) ; } 
private void METHOD_1 ( boolean VAR_1 , TYPE_1 session ) { String VAR_2 = METHOD_2 ( ) ; <START> boolean VAR_3 = client != null && configuration . VAR_4 ( VAR_2 ) ; <END> if ( ( configuration . VAR_5 ( ) || ! VAR_1 ) && VAR_3 ) { VAR_6 . add ( session ) ; VAR_7 . write ( session ) ; VAR_8 = true ; } } 
private static String METHOD_1 ( ) { String VAR_1 = TYPE_3 . VAR_3 ; if ( TYPE_3 . VAR_4 . VAR_5 >= TYPE_3 . VAR_6 . VAR_7 ) { VAR_1 = TYPE_1 . METHOD_2 ( ) ; } else if ( TYPE_3 . VAR_4 . VAR_5 >= TYPE_3 . VAR_6 . VAR_8 ) { VAR_1 = TYPE_2 . METHOD_3 ( ) ; } <START> return VAR_1 ; <END> } 
protected String METHOD_1 ( TYPE_3 . TYPE_7 VAR_1 ) { TYPE_2 writer = new TYPE_2 ( ) ; TYPE_3 VAR_2 = new TYPE_3 ( writer ) ; try { VAR_1 . METHOD_2 ( VAR_2 ) ; <START> } catch ( TYPE_5 . TYPE_6 . IOException e ) { } <END> return writer . toString ( ) ; } 
public static int METHOD_1 ( final String VAR_1 ) { if ( VAR_1 != null ) { try { <START> final String VAR_2 = Optional . of ( VAR_1 . METHOD_2 ( TYPE_2 . VAR_4 ) ) <END> . METHOD_3 ( IllegalArgumentException : : new ) ; return TYPE_1 . valueOf ( VAR_2 ) . METHOD_4 ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; } } return - 1 ; } 
<START> public TYPE_1 add ( String name , TYPE_2 VAR_1 ) { <END> VAR_2 . put ( name , VAR_1 ) ; return this ; } 
public void METHOD_1 ( boolean VAR_1 ) throws TYPE_1 { VAR_2 . METHOD_1 ( VAR_1 ) ; VAR_3 = VAR_1 ; <START> VAR_4 = false ; <END> VAR_5 |= VAR_6 ; } 
final void METHOD_1 ( ) { <START> if ( VAR_1 || VAR_2 ) { <END> VAR_3 = VAR_4 . METHOD_2 ( ) ; } else { VAR_5 = true ; } } 
public Boolean call ( ) throws Exception { long VAR_1 = INT_1 ; do { final TYPE_1 VAR_2 = METHOD_1 ( ) ; <START> if ( VAR_2 == TYPE_1 . VAR_3 ) { <END> return Boolean . VAR_4 ; } else if ( VAR_2 != null ) { VAR_5 . add ( VAR_2 ) ; return Boolean . VAR_6 ; } METHOD_2 ( VAR_1 ) ; VAR_1 = Math . VAR_7 ( VAR_8 / 2 , ( long ) ( VAR_1 * FLOAT_1 ) ) ; } while ( true ) ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final long VAR_2 ) { if ( VAR_2 != Integer . VAR_3 ) { try { VAR_1 . METHOD_1 ( ( int ) TimeUnit . VAR_4 . METHOD_2 ( Math . max ( INT_1 , VAR_2 ) ) ) ; } catch ( TYPE_2 e ) { LOGGER . warn ( STRING_1 , VAR_5 , e ) ; } <START> catch ( TYPE_3 e ) { <END> LOGGER . warn ( STRING_1 , VAR_5 , e ) ; } } } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( new TYPE_3 ( STRING_1 , STRING_2 , TYPE_4 . class ) ) ; VAR_1 . METHOD_2 ( new TYPE_3 ( STRING_3 , STRING_4 , String . VAR_2 , List . VAR_2 , null ) ) ; <START> return new TYPE_5 ( VAR_1 , STRING_1 , STRING_1 , STRING_3 , STRING_3 ) ; <END> } 
public Map < String , TYPE_1 < TYPE_2 > > METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> System . out . println ( VAR_1 ) ; <END> return this ; } 
public TYPE_3 ( byte [ ] key ) { this . key = key ; <START> METHOD_1 ( key , TYPE_2 . TYPE_1 . VAR_4 ) ; <END> } 
public Collection < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( 1 ) ; <START> VAR_1 . add ( new TYPE_2 ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) ) ; <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( Long id , boolean VAR_1 ) { Optional < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( METHOD_3 ( id ) ) ; TYPE_1 VAR_4 = null ; if ( VAR_2 . isPresent ( ) ) { VAR_4 = VAR_2 . get ( ) ; VAR_4 . METHOD_4 ( VAR_1 ) ; <START> VAR_3 . METHOD_5 ( VAR_4 ) ; <END> METHOD_6 ( ) ; } return VAR_4 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = TYPE_3 . METHOD_2 ( ) ; try { <START> METHOD_3 ( VAR_1 ) ; <END> VAR_2 . METHOD_4 ( new TYPE_4 ( METHOD_5 ( VAR_1 ) ) ) ; VAR_2 . METHOD_6 ( config . VAR_3 ( ) ) ; VAR_2 . METHOD_7 ( METHOD_8 ( VAR_1 . METHOD_9 ( ) ) ) ; VAR_2 . METHOD_10 ( INT_1 * METHOD_8 ( VAR_1 . METHOD_11 ( ) ) ) ; } catch ( Exception e ) { throw METHOD_12 ( STRING_1 , e ) ; } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , File file , String path ) throws IOException { <START> TYPE_2 . METHOD_2 ( VAR_1 , file , METHOD_3 ( ) + path ) ; <END> } 
void METHOD_1 ( ) { VAR_1 = System . getProperty ( STRING_1 , STRING_2 ) ; <START> VAR_2 = System . getProperty ( STRING_3 , System . getProperty ( STRING_4 ) ) ; <END> if ( METHOD_2 ( ) ) { VAR_3 = METHOD_3 ( ) ; VAR_4 = ( VAR_3 + File . VAR_5 + VAR_6 ) ; } this . METHOD_4 ( ) ; this . METHOD_5 ( ) ; } 
public < TYPE_1 > List < TYPE_1 > METHOD_1 ( Class < TYPE_1 > VAR_1 , TYPE_1 VAR_2 ) { ArrayList < TYPE_1 > VAR_3 = new ArrayList < TYPE_1 > ( ) ; if ( VAR_2 != null ) { VAR_3 . add ( VAR_2 ) ; } <START> if ( VAR_4 . METHOD_2 ( VAR_1 ) . size ( ) > 0 ) { <END> VAR_3 . addAll ( VAR_4 . METHOD_2 ( VAR_1 ) ) ; } return VAR_3 ; } 
public Map < String , Set < String > > METHOD_1 ( ) { <START> Map < String , Set < String > > result = new TYPE_1 < String , Set < String > > ( ) ; <END> return result ; } 
protected TYPE_1 METHOD_1 ( ) { <START> if ( TYPE_5 . TYPE_6 . equals ( METHOD_2 ( ) ) ) { <END> return new TYPE_3 ( ) ; } return new TYPE_4 ( ) ; } 
<START> static public Set < String > METHOD_1 ( String value ) { <END> if ( StringUtils . isEmpty ( value ) ) { return null ; } Set < String > VAR_1 = new TYPE_1 < > ( ) ; if ( ! StringUtils . isEmpty ( value ) ) { String [ ] values = value . split ( STRING_1 ) ; for ( String v : values ) { VAR_1 . add ( v . trim ( ) ) ; } } return VAR_1 ; } 
public String METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
public TYPE_1 ( Context context ) { <START> this . VAR_2 = context . VAR_3 ( ) . METHOD_1 ( ) ; <END> } 
<START> public void METHOD_1 ( String VAR_1 ) <END> { TYPE_2 . TYPE_3 . VAR_2 . Logger logger = VAR_3 . get ( VAR_1 ) ; if ( logger == null ) { logger = TYPE_2 . TYPE_3 . VAR_2 . Logger . METHOD_2 ( VAR_1 ) ; } logger . VAR_4 ( null ) ; } 
static TYPE_1 METHOD_1 ( TYPE_1 binder ) { return ( TYPE_1 ) TYPE_2 . METHOD_2 ( TYPE_3 . class . METHOD_3 ( ) , <START> new Class [ ] { TYPE_1 . class } , <END> new TYPE_3 ( binder ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . create ( STRING_1 ) ; TYPE_1 VAR_2 = TYPE_1 . create ( STRING_2 ) ; String VAR_3 = STRING_3 ; TYPE_1 VAR_4 = TYPE_1 . create ( STRING_4 + VAR_3 ) ; <START> assertEquals ( VAR_4 , TYPE_2 . METHOD_2 ( VAR_1 , VAR_3 ) ) ; <END> assertEquals ( VAR_4 , TYPE_2 . METHOD_2 ( VAR_2 , VAR_3 ) ) ; } 
public void METHOD_1 ( ) { String VAR_1 = STRING_1 ; TYPE_1 VAR_2 = TYPE_1 . create ( STRING_2 + VAR_1 ) ; <START> assertEquals ( VAR_2 , METHOD_2 ( TYPE_1 . create ( STRING_3 ) , VAR_1 ) ) ; <END> assertEquals ( VAR_2 , METHOD_2 ( TYPE_1 . create ( STRING_4 ) , VAR_1 ) ) ; } 
private static boolean METHOD_1 ( TYPE_1 request ) { <START> return request . VAR_1 ( ) . get ( VAR_2 ) == TYPE_2 ; <END> } 
<START> TYPE_3 ( TYPE_1 VAR_2 , double VAR_3 , TYPE_2 VAR_4 ) <END> { this ( VAR_2 , VAR_3 , VAR_4 , TimeUnit . VAR_5 . METHOD_1 ( VAR_4 . read ( ) ) ) ; } 
public void METHOD_1 ( ) { List < Object > response = client . execute ( METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( STRING_1 ) ) . build ( ) , METHOD_5 ( VAR_1 ) ) ; <START> assertEquals ( response , Collections . VAR_2 ( ) ) ; <END> } 
<START> public TYPE_3 ( double VAR_2 , double VAR_3 , TYPE_1 VAR_4 ) <END> { VAR_5 = new TYPE_2 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_6 = TimeUnit . VAR_7 . METHOD_1 ( VAR_4 . read ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 VAR_1 = new TYPE_1 ( ( TYPE_2 ) binder - > { <END> binder . bind ( TYPE_3 . class ) ; binder . bind ( TYPE_4 . class ) ; } ) ; try { VAR_1 . METHOD_2 ( ) . getInstance ( TYPE_3 . class ) ; METHOD_3 ( STRING_1 ) ; } catch ( TYPE_5 e ) { METHOD_4 ( e . VAR_2 ( ) . iterator ( ) . next ( ) . getMessage ( ) , STRING_2 ) ; } } 
public TYPE_4 ( TYPE_1 uri , String method , TYPE_2 < String , String > VAR_2 , TYPE_3 VAR_3 ) { this ( uri , method , VAR_2 , VAR_3 , true ) ; <START> } <END> 
public static boolean METHOD_1 ( String data ) { <START> if ( TYPE_1 . matcher ( data ) . METHOD_2 ( ) ) { <END> return true ; } if ( TYPE_2 . matcher ( data ) . METHOD_2 ( ) ) { return true ; } if ( TYPE_3 . matcher ( data ) . METHOD_2 ( ) ) { return true ; } return false ; } 
<START> TYPE_1 ( ) <END> { super ( STRING_1 , METHOD_1 ( STRING_2 ) . toString ( ) ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 config ) { <START> return METHOD_1 ( new TYPE_5 ( Optional . empty ( ) ) , VAR_1 , VAR_2 , config ) ; <END> } 
private void METHOD_1 ( ) throws Exception { <START> METHOD_1 ( new TYPE_1 ( Optional . empty ( ) ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { <START> if ( ! file . VAR_1 ( ) ) { <END> throw new IOException ( STRING_1 + file . VAR_2 ( ) ) ; } } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) { try { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; } } <START> catch ( InterruptedException VAR_2 ) { <END> Thread . VAR_3 ( ) . METHOD_3 ( ) ; } catch ( Exception VAR_4 ) { } } 
public void METHOD_1 ( ) { TYPE_1 in = new TYPE_1 ( new TYPE_2 ( METHOD_2 ( ) . toString ( ) ) ) ; while ( true ) { try { String line = in . VAR_1 ( ) ; if ( line == null ) { break ; } if ( logger . VAR_2 ( ) ) { <START> logger . info ( line ) ; <END> } } catch ( IOException e ) { throw new TYPE_3 ( e ) ; } } METHOD_2 ( ) . METHOD_3 ( 0 ) ; } 
private static byte [ ] METHOD_1 ( String VAR_1 ) { <START> return TYPE_1 . METHOD_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( VAR_2 ) ) ; <END> } 
public String toString ( ) { <START> return TYPE_1 . METHOD_1 ( this ) <END> . add ( STRING_1 , VAR_1 ) . toString ( ) ; } 
public synchronized void METHOD_1 ( TYPE_1 result ) { Throwable VAR_1 = result . VAR_2 ( ) ; if ( VAR_1 != null ) { VAR_3 . METHOD_2 ( VAR_1 ) ; } else { <START> VAR_4 = null ; <END> VAR_5 = 0 ; VAR_3 . METHOD_3 ( result . VAR_6 ( ) , new TYPE_2 ( VAR_7 , size ) ) ; } } 
protected void METHOD_1 ( TYPE_1 binder ) { T configuration = METHOD_2 ( config ) ; if ( VAR_1 . METHOD_3 ( configuration ) ) { if ( VAR_2 instanceof TYPE_2 ) { <START> METHOD_4 ( ( TYPE_2 ) VAR_2 ) ; <END> } else { binder . VAR_3 ( VAR_2 ) ; } } } 
public List < Long > METHOD_1 ( List < Double > VAR_1 ) { List < Long > VAR_2 = new ArrayList < Long > ( VAR_1 . size ( ) ) ; <START> for ( Double VAR_3 : VAR_1 ) { <END> VAR_2 . add ( METHOD_2 ( VAR_3 ) ) ; } return VAR_2 ; } 
<START> public static TYPE_1 METHOD_1 ( int VAR_1 , TYPE_2 VAR_2 ) <END> { TYPE_3 < TYPE_4 > VAR_3 = new TYPE_5 < > ( ) ; return new TYPE_1 ( 0 , VAR_1 , INT_1 , TimeUnit . VAR_4 , VAR_3 , VAR_2 , ( VAR_5 , VAR_6 ) - > VAR_3 . add ( VAR_5 ) ) ; } 
public TYPE_4 ( ) { <START> VAR_2 = new TYPE_1 ( ) ; <END> VAR_3 = new TYPE_1 ( ) ; VAR_4 = new TYPE_1 ( ) ; VAR_5 = new TYPE_1 ( ) ; VAR_6 = new TYPE_1 ( ) ; VAR_7 = new TYPE_1 ( ) ; VAR_8 = new TYPE_1 ( ) ; VAR_9 = new TYPE_1 ( ) ; VAR_10 = new TYPE_2 ( ) ; VAR_11 = new TYPE_2 ( ) ; VAR_12 = new TYPE_3 ( ) ; VAR_13 = new TYPE_3 ( ) ; } 
private void METHOD_1 ( int VAR_1 , int value ) { int VAR_2 = METHOD_2 ( VAR_1 ) ; byte VAR_3 = ( byte ) ( VAR_4 < < METHOD_3 ( VAR_1 ) ) ; <START> VAR_5 [ VAR_2 ] &= ( byte ) ~ VAR_3 ; <END> byte VAR_6 = ( byte ) ( value < < METHOD_3 ( VAR_1 ) ) ; VAR_5 [ VAR_2 ] |= VAR_6 ; } 
<START> public static String METHOD_1 ( String VAR_1 ) <END> throws TYPE_1 { METHOD_2 ( VAR_1 , STRING_1 ) ; String VAR_2 = TYPE_2 . METHOD_3 ( ) . METHOD_4 ( ) ; METHOD_5 ( ! VAR_2 . equalsIgnoreCase ( STRING_2 ) , STRING_3 ) ; return String . format ( STRING_4 , VAR_1 , VAR_2 . METHOD_6 ( TYPE_3 . VAR_4 ) ) ; } 
public TYPE_1 METHOD_1 ( String type , TYPE_2 uri , String VAR_1 ) { if ( VAR_2 . METHOD_2 ( type , uri , VAR_1 ) ) { return VAR_2 ; } <START> throw new TYPE_3 ( String . format ( STRING_1 , type ) ) ; <END> } 
public void close ( ) { try { <START> context . VAR_1 ( ) ; <END> VAR_2 . METHOD_1 ( ) ; } catch ( TYPE_1 | TYPE_2 e ) { throw new TYPE_3 ( e ) ; } } 
public static String METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_1 { METHOD_2 ( VAR_1 , STRING_1 ) ; METHOD_2 ( VAR_2 , STRING_2 ) ; TYPE_2 VAR_3 = TYPE_2 . METHOD_3 ( VAR_2 ) ; String VAR_4 ; if ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . startsWith ( STRING_3 ) ) { return METHOD_1 ( VAR_1 ) ; } VAR_4 = VAR_3 . METHOD_6 ( ) ; <START> return String . format ( STRING_4 , VAR_1 , VAR_4 . METHOD_5 ( TYPE_3 . VAR_6 ) ) ; <END> } 
<START> private static int METHOD_1 ( int entry ) <END> { return entry > > > ( Integer . VAR_1 - VAR_2 ) ; } 
public String METHOD_1 ( String VAR_1 ) { <START> TYPE_2 . TYPE_3 . VAR_2 . Logger logger = METHOD_2 ( VAR_1 ) ; <END> return METHOD_3 ( logger ) . toString ( ) ; } 
public static double METHOD_1 ( int VAR_1 ) { double VAR_2 ; switch ( VAR_1 ) { case 4 : <START> VAR_2 = FLOAT_1 ; <END> break ; case 5 : VAR_2 = FLOAT_2 ; break ; case INT_1 : VAR_2 = FLOAT_3 ; break ; default : VAR_2 = ( FLOAT_4 / ( 1 + FLOAT_5 / METHOD_2 ( VAR_1 ) ) ) ; } return VAR_2 ; } 
public void METHOD_1 ( Object instance ) throws Exception { TYPE_1 VAR_1 = state . get ( ) ; if ( ( VAR_1 == TYPE_1 . VAR_2 ) || ( VAR_1 == TYPE_1 . VAR_3 ) ) { throw new IllegalStateException ( ) ; } else { METHOD_2 ( instance ) ; if ( VAR_4 . get ( instance . getClass ( ) ) . METHOD_3 ( TYPE_2 . class ) ) { if ( ! VAR_5 . contains ( instance ) ) { <START> VAR_5 . add ( instance ) ; <END> } } } } 
public void close ( ) { TYPE_1 . METHOD_1 ( VAR_1 ) ; <START> TYPE_1 . METHOD_1 ( VAR_2 ) ; <END> } 
public int METHOD_1 ( int b ) { <START> METHOD_2 ( ( b > > TYPE_1 . VAR_2 ) == 0 , STRING_1 ) ; <END> for ( int i = 0 ; i < size ; i ++ ) { if ( METHOD_3 ( i ) == b ) { return i ; } } return - 1 ; } 
public TYPE_1 METHOD_1 ( int index , int length ) { if ( ( index == 0 ) && ( length == length ( ) ) ) { return this ; } METHOD_2 ( index , length ) ; if ( length == 0 ) { return TYPE_2 . VAR_2 ; } if ( VAR_3 == VAR_4 ) { return new TYPE_1 ( VAR_5 , VAR_6 + index , length , VAR_7 , VAR_8 ) ; } <START> else { <END> return new TYPE_1 ( VAR_5 , VAR_6 + index , length , VAR_7 , VAR_3 ) ; } } 
public static TYPE_1 METHOD_1 ( int VAR_1 ) { <START> METHOD_2 ( VAR_1 ) ; <END> if ( VAR_1 == 0 ) { return VAR_2 ; } return METHOD_3 ( ByteBuffer . VAR_3 ( VAR_1 ) ) ; } 
public static long METHOD_1 ( long VAR_1 , TYPE_1 in ) throws IOException { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; byte [ ] buffer = new byte [ INT_1 ] ; while ( true ) { <START> int n = in . read ( buffer ) ; <END> if ( n == - 1 ) { break ; } VAR_2 . update ( buffer , 0 , n ) ; } return VAR_2 . METHOD_1 ( ) ; } 
public void start ( ) { try { <START> this . server . start ( ) ; <END> } catch ( Exception e ) { LOGGER . error ( STRING_1 ) ; throw TYPE_1 . METHOD_1 ( e ) ; } } 
public boolean METHOD_1 ( final Class < ? extends T > VAR_1 ) { final TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) . METHOD_3 ( TYPE_1 . class ) ; <START> return null != VAR_2 ; <END> } 
public Optional < TYPE_1 < TYPE_2 , TYPE_3 > > create ( final TYPE_4 < ? > type ) { final Class < ? > VAR_1 = type . VAR_2 ( ) ; final boolean VAR_3 = VAR_1 . METHOD_1 ( TYPE_5 . class ) ; <START> TYPE_6 VAR_4 = VAR_3 ? <END> new TYPE_7 ( VAR_5 ) : new TYPE_8 ( VAR_5 ) ; final TYPE_9 < TYPE_2 , TYPE_3 > VAR_6 = new TYPE_10 ( VAR_4 ) ; return Optional . of ( TYPE_1 . METHOD_2 ( VAR_6 ) ) ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { METHOD_2 ( VAR_1 ) ; final TYPE_3 VAR_2 = TYPE_3 . of ( VAR_1 . getClass ( ) ) . METHOD_3 ( TYPE_2 . class ) . METHOD_4 ( TYPE_2 . class . METHOD_5 ( ) [ 0 ] ) ; <START> VAR_3 . METHOD_6 ( VAR_2 . METHOD_7 ( ) , VAR_1 ) ; <END> return this ; } 
public TYPE_1 ( final TYPE_1 response ) { this . status = response . status ; <START> this . VAR_1 = response . VAR_1 ; <END> } 
public TYPE_3 VAR_2 ( ) { <START> if ( TYPE_1 . VAR_4 . equals ( VAR_5 ( ) ) { <END> return ( TYPE_3 ) this ; } throw new TYPE_2 ( STRING_1 ) ; } 
private void METHOD_1 ( ) { <START> int i = 1 ; <END> } 
<START> public List < Integer > METHOD_1 ( ) { <END> List < Integer > VAR_1 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_2 : VAR_3 ) { int position = VAR_2 . METHOD_2 ( ) ? VAR_2 . METHOD_3 ( ) : VAR_2 . METHOD_4 ( ) ; VAR_1 . add ( position ) ; } return VAR_1 ; } 
public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { STRING_1 , R . string . VAR_1 , new TYPE_1 ( ) , <START> R . id . VAR_2 , R . id . VAR_3 , STRING_2 , <END> INT_1 , STRING_3 , STRING_4 } , { STRING_5 , R . string . VAR_4 , new TYPE_2 ( ) , R . id . VAR_5 , R . id . VAR_6 , STRING_2 , INT_1 , STRING_3 , STRING_4 } } ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = VAR_2 ; TYPE_1 VAR_3 = VAR_4 ; <END> TYPE_2 VAR_5 = new TYPE_2 ( VAR_6 , VAR_7 , Constants . VAR_8 ) ; assertEquals ( VAR_1 , VAR_5 . METHOD_2 ( VAR_9 ) ) ; assertEquals ( VAR_3 , VAR_5 . METHOD_3 ( VAR_10 ) ) ; } 
public static TYPE_1 getInstance ( ) { <START> return VAR_1 ; <END> } 
<START> public List < TYPE_1 > METHOD_1 ( List < ? extends TYPE_2 > VAR_1 ) { <END> List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { VAR_2 . add ( VAR_3 . METHOD_2 ( ) ) ; } return VAR_2 ; } 
public void METHOD_1 ( ) throws TYPE_1 { VAR_1 . METHOD_2 ( VAR_2 , STRING_1 , STRING_2 , VAR_3 . METHOD_3 ( ) ) ; METHOD_4 ( VAR_4 , METHOD_5 ( ) ) . METHOD_6 ( METHOD_7 ( ) , METHOD_8 ( ) ) ; METHOD_4 ( VAR_4 , METHOD_9 ( ) ) . METHOD_10 ( ) ; token = VAR_3 . getString ( Constants . VAR_5 , Constants . VAR_6 ) ; <START> boolean VAR_7 = new TYPE_2 ( ) . METHOD_11 ( token , VAR_8 , VAR_9 ) ; <END> assertTrue ( VAR_7 ) ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> if ( VAR_1 . get ( ) == null ) { <END> return ; } String VAR_2 = VAR_1 . get ( ) . getString ( R . string . VAR_3 ) ; String message = VAR_1 . get ( ) . getString ( R . string . VAR_4 ) ; VAR_5 = TYPE_1 . METHOD_2 ( VAR_1 . get ( ) , VAR_2 , message ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 stream = new TYPE_2 ( ) ; <END> stream . VAR_1 ( ) ; stream . VAR_2 ( 0 , 0 ) ; assertEquals ( 1 , stream . VAR_3 ( ) . size ( ) ) ; assertTrue ( stream . VAR_3 ( ) . get ( 0 ) . METHOD_2 ( ) ) ; } 
<START> protected void METHOD_1 ( ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( this ) ; VAR_1 . execute ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> METHOD_2 ( VAR_1 , VAR_2 . METHOD_3 ( VAR_3 ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { VAR_1 = null ; <START> VAR_2 = null ; <END> } 
public boolean METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 ) { List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_4 : VAR_1 ) { for ( TYPE_1 VAR_5 : VAR_2 ) { if ( VAR_4 . getName ( ) . equals ( VAR_5 . getName ( ) ) && ! VAR_4 . getValue ( ) . equals ( VAR_5 . getValue ( ) ) ) { VAR_3 . add ( VAR_4 ) ; } } } <START> return VAR_3 . isEmpty ( ) ; <END> } 
public boolean METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 ) { List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_4 : VAR_1 ) { for ( TYPE_1 VAR_5 : VAR_2 ) { if ( VAR_4 . getName ( ) . equals ( VAR_5 . getName ( ) ) && ! VAR_4 . METHOD_2 ( ) . equals ( VAR_5 . METHOD_2 ( ) ) ) { VAR_3 . add ( VAR_4 ) ; } } } return VAR_3 . isEmpty ( ) ; <START> } <END> 
public List < TYPE_1 > METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; TYPE_2 VAR_3 = METHOD_2 ( VAR_1 . getName ( ) ) ; for ( TYPE_1 VAR_4 : VAR_5 ) { <START> TYPE_3 matcher = VAR_3 . matcher ( VAR_4 . getName ( ) ) ; <END> if ( VAR_4 . VAR_6 && matcher . VAR_7 ( ) ) { VAR_2 . add ( VAR_4 ) ; } } return VAR_2 ; } 
private ANNOTATION_1 String METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_4 . VAR_3 ) ; TYPE_2 VAR_4 = VAR_1 . METHOD_3 ( ) ; <START> boolean VAR_5 = VAR_4 . METHOD_4 ( ) == TYPE_2 . TYPE_3 . VAR_7 ; <END> return VAR_5 ? VAR_4 . getValue ( ) : null ; } 
public void METHOD_1 ( ) { <START> Context context = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> VAR_1 . addAll ( Arrays . asList ( context . VAR_2 ( ) . METHOD_4 ( R . VAR_3 . VAR_4 ) ) ) ; VAR_5 . addAll ( Arrays . asList ( TYPE_3 . TYPE_4 . METHOD_5 ( ) ) ) ; VAR_6 = context . getString ( VAR_7 ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { METHOD_2 ( VAR_1 , VAR_2 . METHOD_3 ( VAR_3 ) ) ; <START> METHOD_2 ( VAR_1 , VAR_4 . METHOD_3 ( VAR_3 ) ) ; <END> } 
public boolean METHOD_1 ( float VAR_1 ) { if ( VAR_2 == null ) { return true ; } if ( VAR_3 ) { VAR_3 = false ; VAR_4 = false ; <START> new TYPE_3 . TYPE_2 ( ) . execute ( VAR_2 ) ; <END> } return VAR_4 ; } 
public void METHOD_1 ( ) { VAR_1 = new File ( TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) , STRING_1 ) ; VAR_1 . METHOD_4 ( ) ; <START> VAR_2 = new TYPE_2 ( STRING_2 ) ; <END> VAR_3 = new TYPE_3 ( STRING_3 , VAR_4 ) ; VAR_5 = new TYPE_3 ( STRING_4 , VAR_4 ) ; VAR_2 . METHOD_5 ( VAR_5 ) ; VAR_6 = new TYPE_4 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { if ( METHOD_2 ( VAR_1 ) ) { METHOD_3 ( VAR_1 ) ; } if ( ! VAR_2 . exists ( ) ) { VAR_2 . METHOD_4 ( ) ; } synchronized ( VAR_3 ) { HashMap VAR_4 = METHOD_5 ( ) ; if ( VAR_4 == null ) { VAR_4 = new HashMap < > ( ) ; } VAR_4 . put ( VAR_1 . METHOD_6 ( ) , VAR_1 . getValue ( ) ) ; METHOD_7 ( VAR_4 ) ; } <START> } <END> 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <START> File VAR_2 = TYPE_3 . getInstance ( ) . METHOD_4 ( ) . METHOD_3 ( ) ; <END> TYPE_4 VAR_3 = new TYPE_4 ( VAR_2 ) ; for ( TYPE_5 VAR_4 : VAR_1 . METHOD_5 ( ) ) { try { VAR_3 . METHOD_6 ( VAR_4 ) ; } catch ( IOException e ) { Log . i ( TAG , e . getMessage ( ) ) ; } } } 
public void METHOD_1 ( int VAR_1 , int VAR_2 , TYPE_1 data ) { if ( VAR_3 . METHOD_2 ( VAR_1 ) >= 0 ) { TYPE_2 VAR_4 = VAR_3 . get ( VAR_1 ) ; VAR_4 . METHOD_3 ( VAR_2 , data ) ; VAR_3 . remove ( VAR_1 ) ; } else if ( VAR_1 == VAR_5 ) { if ( VAR_2 == VAR_6 ) { <START> Log . d ( TAG , STRING_1 ) ; <END> } } else { VAR_7 . METHOD_1 ( VAR_1 , VAR_2 , data ) ; } } 
public T remove ( int index ) { try { T VAR_1 = super . remove ( index ) ; VAR_2 . remove ( VAR_1 ) ; return VAR_1 ; <START> } catch ( TYPE_1 VAR_3 ) { <END> throw new TYPE_1 ( ) ; } } 
public T set ( int index , T element ) { try { if ( element . equals ( this . get ( index ) ) ) { return element ; } T VAR_1 = null ; if ( VAR_2 . add ( element ) ) { VAR_1 = super . set ( index , element ) ; VAR_2 . remove ( VAR_1 ) ; } return VAR_1 ; } catch ( TYPE_1 VAR_3 ) { <START> throw new TYPE_1 ( ) ; <END> } } 
public void METHOD_1 ( ) { if ( call != null ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . execute ( new TYPE_1 ( ) { @Override public void run ( ) { TYPE_2 listener = METHOD_4 ( ) ; if ( listener != null ) { call . VAR_2 ( ) ; listener . VAR_3 ( ) ; } <START> } <END> } ) ; } } 
public boolean METHOD_1 ( ) { <START> if ( METHOD_2 ( ) ) { <END> return VAR_1 . VAR_2 ; } return false ; } 
public static void METHOD_1 ( ) { <START> Log . d ( TAG , STRING_1 ) ; <END> if ( ! VAR_1 && METHOD_2 ( ) ) { VAR_1 = true ; if ( METHOD_3 ( ) ) { VAR_2 = true ; METHOD_4 ( ) ; } } } 
public static void METHOD_1 ( ) { <START> Log . d ( TAG , STRING_1 ) ; <END> if ( ! METHOD_2 ( ) ) { return ; } TYPE_1 . getInstance ( ) . METHOD_3 ( VAR_1 ) ; VAR_2 = false ; } 
public void METHOD_1 ( ) { TYPE_1 project = new TYPE_1 ( TYPE_2 . METHOD_2 ( ) , VAR_1 ) ; TYPE_3 . getInstance ( ) . METHOD_3 ( project ) ; VAR_2 = new TYPE_4 ( ) ; <START> VAR_3 = new File ( Constants . VAR_4 + STRING_1 + VAR_1 + STRING_2 ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 ) { METHOD_2 ( this ) ; } else { <START> super . METHOD_1 ( ) ; <END> } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( false ) ; VAR_1 . VAR_2 . get ( 0 ) . VAR_3 = Utils . VAR_4 ( METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( ) ; String VAR_5 = METHOD_3 ( ) . METHOD_5 ( ) . METHOD_6 ( TYPE_1 . VAR_7 ) ; if ( VAR_5 != null ) { METHOD_7 ( VAR_5 ) ; <START> METHOD_3 ( ) . METHOD_5 ( ) . METHOD_8 ( TYPE_1 . VAR_7 ) ; <END> } } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> this . VAR_3 = VAR_3 ; <END> this . VAR_4 = VAR_2 ; } 
private static Boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . x != VAR_2 . get ( VAR_3 ) . x || VAR_1 . y != VAR_2 . get ( VAR_3 ) . y ) { <END> return true ; } return false ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( METHOD_4 ( ) ) ; VAR_1 . METHOD_5 ( METHOD_4 ( ) ) ; VAR_1 . METHOD_6 ( METHOD_4 ( ) ) ; <START> client = null ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 ) ; VAR_2 = 1 ; VAR_3 = 2 ; <START> VAR_1 . METHOD_3 ( VAR_2 - 1 , new TYPE_3 ( ) ) ; <END> VAR_1 . METHOD_3 ( VAR_3 - 1 , new TYPE_4 ( ) ) ; VAR_4 . METHOD_4 ( ) ; } 
private String METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ; if ( VAR_2 . METHOD_2 ( TYPE_1 . VAR_3 ) == 0 ) { <START> VAR_2 = TYPE_1 . VAR_3 ; <END> } else { VAR_2 = VAR_2 . METHOD_3 ( ) ; } return VAR_2 . METHOD_4 ( ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) ; <END> super . METHOD_1 ( ) ; VAR_1 . METHOD_4 ( ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) . METHOD_3 ( R . id . VAR_2 ) <START> . METHOD_4 ( VAR_3 ) ; <END> METHOD_2 ( VAR_1 ) . METHOD_3 ( R . id . VAR_2 ) . METHOD_5 ( VAR_3 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 ) ; VAR_1 . METHOD_3 ( new TYPE_3 ( TYPE_3 . TYPE_4 . VAR_3 , VAR_4 , VAR_4 , VAR_4 ) ) ; <START> VAR_5 . METHOD_4 ( null ) ; <END> } 
public void METHOD_1 ( Thread VAR_1 , Throwable exception ) { TYPE_1 . METHOD_2 ( exception ) ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( VAR_3 , true ) . commit ( ) ; <START> Log . e ( TAG , STRING_1 , exception ) ; <END> METHOD_5 ( ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { if ( METHOD_2 ( ) == null ) { <START> Log . e ( TAG , STRING_1 ) ; <END> return ; } TYPE_1 VAR_2 = new TYPE_1 ( METHOD_2 ( ) , TYPE_2 . class ) ; VAR_2 . METHOD_3 ( Constants . VAR_3 , true ) ; METHOD_2 ( ) . METHOD_4 ( VAR_2 ) ; } 
private void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : project . VAR_2 ( ) ) { for ( TYPE_2 VAR_3 : VAR_1 . METHOD_2 ( ) ) { <START> for ( int j = 0 ; j < VAR_3 . METHOD_3 ( ) . size ( ) ; j ++ ) { <END> TYPE_3 VAR_4 = VAR_3 . METHOD_3 ( ) . get ( j ) ; VAR_4 . METHOD_4 ( ) . METHOD_5 ( ) ; VAR_4 . METHOD_6 ( ) . METHOD_7 ( ) . METHOD_5 ( ) ; } } } } 
public static void METHOD_1 ( Context context , boolean VAR_1 ) { TYPE_3 . TYPE_4 VAR_2 = METHOD_2 ( context ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_3 , VAR_1 ) ; VAR_2 . commit ( ) ; if ( VAR_1 ) { TYPE_2 . METHOD_5 ( context ) ; <START> } <END> } 
public static void METHOD_1 ( Context context , boolean VAR_1 ) { TYPE_3 . TYPE_4 VAR_2 = METHOD_2 ( context ) . METHOD_3 ( ) ; <START> VAR_2 . METHOD_4 ( VAR_3 , VAR_1 ) ; <END> VAR_2 . commit ( ) ; TYPE_2 . METHOD_5 ( context ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( ) ; if ( VAR_1 ) { <START> TYPE_1 . METHOD_3 ( VAR_2 , this ) ; <END> } if ( VAR_2 != null && VAR_3 != null && VAR_3 . METHOD_4 ( ) . contains ( VAR_2 ) ) { VAR_3 . VAR_2 . METHOD_5 ( VAR_2 ) ; VAR_4 = true ; } } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 : new ArrayList < TYPE_1 > ( ) ; <END> } 
public static int METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( 0 ) ; <START> } <END> return VAR_1 . METHOD_2 ( ) ; } 
<START> public void METHOD_1 ( ) throws TYPE_1 , <END> TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 { METHOD_2 ( METHOD_3 ( R . id . VAR_1 ) ) . METHOD_4 ( METHOD_5 ( ) ) ; METHOD_2 ( METHOD_3 ( R . id . VAR_2 ) ) . METHOD_6 ( METHOD_7 ( METHOD_8 ( ) ) ) ; } 
public static void METHOD_1 ( Context context , boolean VAR_1 ) { TYPE_3 . TYPE_4 VAR_2 = METHOD_2 ( context ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_3 , VAR_1 ) ; VAR_2 . commit ( ) ; <START> TYPE_2 . VAR_4 = TYPE_2 . METHOD_5 ( context ) ; <END> } 
public static void METHOD_1 ( Context context , boolean VAR_1 ) { TYPE_3 . TYPE_4 VAR_2 = METHOD_2 ( context ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_3 , VAR_1 ) ; VAR_2 . commit ( ) ; <START> TYPE_2 . METHOD_5 ( context ) ; <END> } 
public static boolean METHOD_1 ( Context context ) { VAR_1 = TYPE_1 . METHOD_2 ( context ) ; <START> if ( TYPE_2 . METHOD_3 ( ) ) { <END> VAR_2 . METHOD_1 ( context ) ; Log . d ( TAG , STRING_1 ) ; return true ; } Log . d ( TAG , STRING_2 + METHOD_3 ( ) + STRING_3 ) ; return false ; } 
public void METHOD_1 ( ) { Context context = TYPE_1 . METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( context , false ) ; METHOD_4 ( TYPE_4 . VAR_2 , TYPE_3 . METHOD_5 ( 0 ) ) . METHOD_6 ( context ) ; TYPE_2 . METHOD_3 ( context , true ) ; <START> METHOD_4 ( TYPE_4 . VAR_2 , TYPE_3 . METHOD_5 ( 1 ) ) . METHOD_6 ( context ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = null ; VAR_3 = false ; VAR_4 = false ; Thread . VAR_5 ( new TYPE_2 ( ) ) ; METHOD_2 ( this ) ; METHOD_3 ( ) . METHOD_4 ( true ) ; <START> VAR_6 = TYPE_3 . METHOD_5 ( this ) ; <END> } 
public boolean METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( this ) . METHOD_3 ( VAR_1 , false ) ; <START> } <END> 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = null ; VAR_3 = false ; VAR_4 = false ; Thread . VAR_5 ( new TYPE_2 ( this ) ) ; METHOD_2 ( this ) ; METHOD_3 ( ) . METHOD_4 ( true ) ; <START> TYPE_3 . METHOD_5 ( ) ; <END> } 
public static void METHOD_1 ( ) { String VAR_1 = VAR_2 . getString ( VAR_3 , "" ) ; if ( METHOD_2 ( ) && ! VAR_1 . isEmpty ( ) ) { Log . d ( TAG , STRING_1 ) ; TYPE_1 VAR_4 = new TYPE_1 ( ) ; Throwable exception = VAR_4 . METHOD_3 ( VAR_1 , Throwable . VAR_5 ) ; <START> if ( METHOD_4 ( exception ) ) { <END> VAR_2 . METHOD_5 ( ) . remove ( VAR_3 ) . commit ( ) ; } } } 
public void METHOD_1 ( Thread VAR_1 , Throwable exception ) { Log . e ( TAG , STRING_1 , exception ) ; TYPE_1 . METHOD_2 ( exception ) ; <START> if ( ! TYPE_2 . VAR_3 ) { <END> System . VAR_4 ( VAR_5 ) ; VAR_6 . VAR_7 . TYPE_3 . METHOD_3 ( VAR_6 . VAR_7 . TYPE_3 . METHOD_4 ( ) ) ; } } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 ; <END> VAR_2 = 1 ; VAR_3 = new TYPE_2 ( ) ; TYPE_3 VAR_4 = new TYPE_3 ( VAR_3 ) ; TYPE_4 VAR_5 = new TYPE_4 ( VAR_4 , VAR_3 ) ; VAR_3 . METHOD_2 ( VAR_4 ) ; VAR_3 . METHOD_3 ( VAR_5 ) ; VAR_1 = TYPE_5 . METHOD_4 ( STRING_1 ) ; VAR_1 . METHOD_5 ( VAR_3 ) ; VAR_1 . METHOD_5 ( VAR_4 ) ; VAR_1 . METHOD_5 ( VAR_5 ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 ) ; VAR_1 . METHOD_3 ( null ) ; <START> METHOD_4 ( METHOD_5 ( R . id . VAR_2 ) ) . METHOD_6 ( METHOD_7 ( ) ) ; <END> METHOD_4 ( METHOD_5 ( R . id . VAR_3 ) ) . METHOD_6 ( METHOD_7 ( ) ) ; METHOD_4 ( METHOD_8 ( METHOD_9 ( R . string . VAR_4 ) ) ) . METHOD_6 ( METHOD_7 ( ) ) ; METHOD_4 ( METHOD_5 ( R . id . VAR_5 ) ) . METHOD_6 ( METHOD_7 ( ) ) ; } 
public void clear ( String VAR_1 ) { <START> if ( ! VAR_2 . containsKey ( VAR_1 ) ) { <END> return ; } VAR_2 . get ( VAR_1 ) . clear ( ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 = 1 ; <START> VAR_2 = FLOAT_1 ; <END> TYPE_1 . METHOD_2 ( STRING_1 ) . METHOD_3 ( new TYPE_2 ( ) ) ; VAR_3 . METHOD_4 ( null ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 == FLOAT_1 ) { return ; } <START> if ( ! VAR_3 . contains ( VAR_1 ) ) { <END> VAR_1 . METHOD_2 ( TYPE_2 . VAR_5 , VAR_1 . METHOD_3 ( ) * METHOD_4 ( ) ) ; VAR_3 . add ( VAR_1 ) ; } } 
private Object METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { TYPE_1 VAR_3 ; try { VAR_3 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; } catch ( TYPE_4 . TYPE_5 exception ) { return FLOAT_1 ; <START> } <END> float VAR_4 = VAR_3 . VAR_5 . METHOD_4 ( ) ; float VAR_6 = VAR_3 . VAR_5 . METHOD_5 ( ) ; return VAR_1 . VAR_5 . METHOD_6 ( VAR_4 , VAR_6 ) ; } 
private void METHOD_1 ( ) { ArrayList < Object > params = new ArrayList < > ( ) ; params . add ( this ) ; <START> if ( TYPE_2 . VAR_2 == null ) { <END> return ; } TYPE_1 message = TYPE_2 . VAR_2 . METHOD_2 ( TYPE_2 . VAR_3 , params ) ; message . VAR_4 ( ) ; VAR_5 = true ; } 
public static < T extends Object > List < T > METHOD_1 ( List < T > VAR_1 ) { List < T > VAR_2 = new ArrayList < > ( ) ; HashMap < Class , T > VAR_3 = new HashMap < > ( ) ; for ( T VAR_4 : VAR_1 ) { VAR_3 . put ( VAR_4 . getClass ( ) , VAR_4 ) ; } VAR_2 . addAll ( VAR_3 . values ( ) ) ; <START> return VAR_2 ; <END> } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null && project != null ) { VAR_1 = project . VAR_2 ( ) ; } <START> return VAR_1 ; <END> } 
public void METHOD_1 ( View view ) { if ( VAR_1 == null ) { return ; } if ( VAR_1 . METHOD_2 ( ) != TYPE_1 . TYPE_2 . VAR_3 ) { return ; } <START> if ( ( ( TYPE_1 ) VAR_1 ) . VAR_4 ) { <END> return ; } METHOD_3 ( view ) ; } 
public boolean METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> boolean VAR_2 ; <END> for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_2 = METHOD_1 ( VAR_3 ) ; if ( VAR_2 ) { return true ; } } return false ; } 
private void METHOD_1 ( TYPE_1 reader , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws TYPE_4 { <START> String value = METHOD_2 ( reader , VAR_2 . METHOD_3 ( ) , VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) ; <END> if ( value != null ) { VAR_2 . METHOD_6 ( value , VAR_1 , reader ) ; } else { throw METHOD_7 ( reader , VAR_2 . METHOD_3 ( ) ) ; } } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 , final TYPE_3 description , TYPE_4 VAR_3 ) throws TYPE_5 { final Class < ? > VAR_4 ; try { VAR_4 = TYPE_6 . METHOD_2 ( description . VAR_5 ( ) , VAR_3 ) ; METHOD_3 ( VAR_1 , VAR_2 , VAR_4 , description ) ; } catch ( Throwable e ) { TYPE_8 . TYPE_9 . METHOD_4 ( e , STRING_1 , description . VAR_5 ( ) ) ; <START> return ; <END> } } 
protected void METHOD_1 ( TYPE_1 context , TYPE_2 VAR_1 , TYPE_3 resource ) throws TYPE_4 { super . METHOD_1 ( context , VAR_1 , resource ) ; <START> TYPE_2 VAR_2 = TYPE_5 . METHOD_2 ( context , VAR_1 ) ; <END> if ( VAR_2 . METHOD_3 ( ) ) { context . VAR_3 ( TYPE_7 . Builder . of ( TYPE_6 . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) , false ) . build ( ) ) ; } } 
static TYPE_1 METHOD_1 ( final String ... VAR_1 ) { <START> String [ ] VAR_2 = new String [ VAR_1 . length + 1 ] ; VAR_2 [ 0 ] = VAR_3 ; System . VAR_4 ( VAR_1 , 0 , VAR_2 , 1 , VAR_1 . length ) ; <END> return METHOD_1 ( false , VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> super . METHOD_1 ( VAR_1 ) ; <END> VAR_1 . METHOD_2 ( VAR_2 , null ) ; VAR_1 . METHOD_2 ( VAR_3 , null ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; VAR_1 . METHOD_3 ( ) ; <START> Thread . VAR_2 ( INT_1 ) ; <END> try { VAR_1 . METHOD_3 ( ) ; throw new RuntimeException ( STRING_1 ) ; } catch ( TYPE_2 VAR_3 ) { } Assert . assertTrue ( TYPE_1 . VAR_4 ) ; } 
public void METHOD_1 ( T value ) { TYPE_1 VAR_1 = this . VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( ) ; try { <START> this . value = value ; <END> } finally { VAR_1 . METHOD_4 ( ) ; } } 
public < R , TYPE_1 extends Exception > R execute ( TYPE_2 < T , R , TYPE_1 > VAR_1 ) throws TYPE_1 { TYPE_3 VAR_2 = this . VAR_2 . METHOD_1 ( ) ; VAR_2 . METHOD_2 ( ) ; try { T value = this . value ; <START> return ( value != null ) ? VAR_1 . apply ( value ) : null ; <END> } finally { VAR_2 . METHOD_3 ( ) ; } } 
private static TYPE_1 METHOD_1 ( String name , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { if ( TYPE_4 . equals ( VAR_2 . METHOD_2 ( ) ) ) { return new TYPE_5 ( name , VAR_1 ) . METHOD_3 ( false ) <START> . METHOD_4 ( false ) <END> . build ( ) ; } else { return new TYPE_5 ( name , VAR_1 ) . METHOD_3 ( false ) . METHOD_4 ( false ) . METHOD_5 ( VAR_2 ) . build ( ) ; } } 
protected void METHOD_1 ( TYPE_1 context , TYPE_2 VAR_1 , String VAR_2 , TYPE_2 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 ) throws TYPE_4 { TYPE_5 resource = context . VAR_6 ( TYPE_7 . VAR_8 ) ; TYPE_2 model = resource . VAR_9 ( ) ; <START> VAR_10 . METHOD_2 ( VAR_1 , model ) ; <END> TYPE_6 . METHOD_3 ( VAR_2 , VAR_3 ) ; } 
private static TYPE_1 METHOD_1 ( String name , TYPE_2 VAR_1 ) { return new TYPE_3 . Builder ( name ) . METHOD_2 ( false ) . METHOD_3 ( false ) . METHOD_4 ( TYPE_4 . VAR_3 ) . build ( ) ; <START> } <END> 
public boolean METHOD_1 ( String VAR_1 ) { String VAR_2 = ctx . VAR_3 ( ) . getName ( ) ; if ( ! TYPE_1 . equals ( VAR_2 ) ) { <START> log . VAR_4 ( STRING_1 + TYPE_1 + STRING_2 + VAR_2 ) ; <END> } return ctx . VAR_5 ( VAR_1 ) ; } 
public void close ( ) { this . VAR_1 . close ( ) ; if ( ! this . VAR_1 . METHOD_1 ( ) ) { TYPE_1 . this . METHOD_2 ( this . VAR_1 ) ; } else { TYPE_1 . VAR_3 . METHOD_3 ( this . VAR_1 ) ; } <START> } <END> 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( 1 ) ; VAR_2 = new TYPE_1 ( 1 ) ; <START> System . out . println ( STRING_1 + VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> String VAR_1 = VAR_2 . equals ( TYPE_2 ) || VAR_3 . equals ( TYPE_2 ) ? TYPE_2 : VAR_4 ; <END> return METHOD_1 ( VAR_1 , VAR_5 , VAR_6 , VAR_7 ) ; } 
public static boolean METHOD_1 ( String VAR_1 , String VAR_2 ) throws Exception { TYPE_1 VAR_3 = null ; boolean VAR_4 = false ; Path VAR_5 = TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> VAR_3 = TYPE_3 . METHOD_3 ( VAR_5 ) ; <END> String line = "" ; while ( ( line = VAR_3 . METHOD_4 ( ) ) != null ) { if ( line . contains ( VAR_2 ) ) { VAR_4 = true ; break ; } } VAR_3 . close ( ) ; return VAR_4 ; } 
public TYPE_1 METHOD_1 ( Collection < TYPE_2 > VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 ) { <START> this . METHOD_1 ( new TYPE_3 ( ) { <END> @Override public TYPE_2 METHOD_2 ( ) { return VAR_2 ; } } ) ; } return this ; } 
<START> public void METHOD_1 ( ) { <END> LOG . info ( STRING_1 ) ; LOG . info ( STRING_2 ) ; LOG . info ( STRING_1 ) ; TYPE_1 . METHOD_2 ( true ) ; } 
private void METHOD_1 ( Boolean VAR_1 ) throws Exception { String VAR_2 = VAR_1 == null ? VAR_3 : VAR_4 ; <START> TYPE_1 VAR_5 = METHOD_2 ( STRING_1 , VAR_4 ) ; <END> VAR_5 . get ( STRING_2 ) . set ( STRING_3 ) ; if ( VAR_1 != null ) { VAR_5 . get ( STRING_4 ) . set ( VAR_1 ) ; } TYPE_2 . METHOD_3 ( VAR_5 , VAR_6 . METHOD_4 ( ) ) ; TYPE_3 . METHOD_5 ( VAR_6 . METHOD_4 ( ) ) ; } 
public TYPE_3 ( String name , TYPE_1 VAR_2 , int VAR_3 ) { super ( name , VAR_2 , VAR_3 ) ; <START> VAR_4 = TYPE_2 . METHOD_1 ( ) ; <END> } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) ; try { TYPE_2 . METHOD_3 ( VAR_2 ) ; <START> TYPE_3 . METHOD_4 ( this . METHOD_5 ( ) ) ; <END> this . VAR_3 . METHOD_1 ( VAR_4 , VAR_5 ) ; TYPE_3 . METHOD_6 ( ) ; } catch ( Exception e ) { throw TYPE_5 . TYPE_6 . METHOD_7 ( METHOD_8 ( ) , e ) ; } finally { TYPE_2 . METHOD_3 ( VAR_1 ) ; } } 
<START> public TYPE_1 getValue ( ) throws IllegalStateException , IllegalArgumentException { <END> return this ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( VAR_2 ) ; final TYPE_1 client = TYPE_2 . METHOD_3 ( ) ; final TYPE_3 VAR_3 = new TYPE_3 ( client , TYPE_2 . METHOD_4 ( ) , TYPE_2 . METHOD_5 ( ) , STRING_1 ) ; <START> LOGGER . info ( STRING_2 ) ; <END> METHOD_6 ( VAR_3 ) ; LOGGER . trace ( STRING_3 ) ; VAR_4 . METHOD_7 ( VAR_5 ) ; } 
public void run ( ) { final TYPE_1 VAR_1 = VAR_2 . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_2 ( this : : METHOD_3 ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 stream ) { try { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . index ( stream ) ; return VAR_1 ; <START> } catch ( IOException e ) { <END> throw new IllegalStateException ( e ) ; } } 
<START> public String METHOD_1 ( String id ) { <END> String VAR_1 = id + STRING_1 ; log . info ( STRING_2 ) ; String VAR_2 = METHOD_2 ( ) ; log . info ( String . format ( STRING_3 , ( VAR_2 != null ) , VAR_2 ) ) ; context . VAR_3 ( ) . put ( STRING_4 , VAR_2 ) ; return "" + context . VAR_3 ( ) . get ( VAR_1 ) ; } 
TYPE_7 ( String name , String VAR_2 , TYPE_1 VAR_3 , TYPE_2 < TYPE_3 > VAR_4 , TYPE_4 < TYPE_5 > VAR_5 ) { <START> super ( METHOD_1 ( name ) , VAR_4 . METHOD_2 ( VAR_6 - > VAR_6 . METHOD_3 ( new TYPE_6 ( VAR_2 ) ) . METHOD_4 ( new TYPE_6 ( VAR_2 ) ) ) , null , VAR_5 ) ; <END> this . METHOD_5 ( VAR_3 . METHOD_6 ( ) ) ; } 
public static TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_2 . create ( TYPE_1 . class , VAR_2 + STRING_1 ) ; VAR_1 . METHOD_2 ( TYPE_3 . class . METHOD_3 ( ) ) ; <START> VAR_1 . METHOD_4 ( TYPE_4 . class ) . METHOD_5 ( new File ( TYPE_5 . METHOD_6 ( ) , VAR_1 . getName ( ) ) , true ) ; <END> return VAR_1 ; } 
public TYPE_1 < TYPE_2 > build ( TYPE_3 target ) { TYPE_1 < TYPE_2 > builder = target . VAR_1 ( this . METHOD_1 ( ) , new TYPE_4 < > ( this ) ) . METHOD_2 ( TYPE_6 . TYPE_5 . VAR_4 ) ; <START> if ( VAR_5 != null ) { <END> this . VAR_5 . METHOD_3 ( builder ) ; } return builder ; } 
public TYPE_1 METHOD_1 ( Set < ? extends TYPE_2 > set ) { <START> set . forEach ( VAR_1 - > this . VAR_2 . add ( VAR_1 . METHOD_2 ( ) ) ) ; <END> return this ; } 
public TYPE_1 < TYPE_2 > build ( TYPE_3 target ) { TYPE_1 < TYPE_2 > builder = super . build ( target ) ; <START> this . VAR_1 . METHOD_1 ( builder ) ; <END> return builder ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> List < TYPE_2 > list = new ArrayList < > ( ) ; <END> for ( TYPE_1 VAR_2 : VAR_1 ) { TYPE_3 VAR_3 = new TYPE_3 ( VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) ) ; list . add ( VAR_3 ) ; } this . METHOD_4 ( list ) ; } 
public void METHOD_1 ( TYPE_1 context , TYPE_2 resource , String VAR_1 , String ... values ) { String VAR_2 = this . VAR_3 . METHOD_2 ( context . VAR_4 ( ) ) . getName ( ) ; for ( String value : values ) { <START> this . VAR_5 . apply ( context , value ) . METHOD_3 ( VAR_6 - > context . VAR_7 ( VAR_6 , VAR_2 , VAR_1 ) ) ; <END> } } 
public void METHOD_1 ( TYPE_1 context , TYPE_2 resource , String VAR_1 , String ... values ) { String VAR_2 = this . VAR_3 . METHOD_2 ( context . VAR_4 ( ) ) . getName ( ) ; for ( String value : values ) { <START> this . VAR_5 . apply ( context , value ) . METHOD_3 ( VAR_6 - > context . VAR_7 ( VAR_6 , VAR_2 ) ) ; <END> } } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > list = new ArrayList < > ( ) ; <START> for ( TYPE_2 < TYPE_1 > VAR_1 : this . VAR_2 ) { <END> TYPE_1 value = VAR_1 . getValue ( ) ; list . add ( value ) ; } return list ; } 
public void METHOD_1 ( TYPE_1 output , T VAR_1 ) throws IOException { <START> Optional < Object > VAR_2 = Optional . empty ( ) ; <END> for ( Object o : VAR_1 ) { VAR_2 = Optional . of ( o ) ; break ; } output . VAR_3 ( VAR_2 . get ( ) ) ; } 
public void METHOD_1 ( TYPE_1 listener ) { <START> log . debug ( STRING_1 ) ; <END> if ( listener == null ) { throw new IllegalArgumentException ( STRING_2 ) ; } VAR_1 . add ( listener ) ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 , final TYPE_3 description , TYPE_4 VAR_3 ) throws TYPE_5 { final Class < ? > VAR_4 ; try { VAR_4 = TYPE_6 . METHOD_2 ( description . VAR_5 ( ) , VAR_3 ) ; <START> } catch ( Exception e ) { <END> return ; } METHOD_3 ( VAR_1 , VAR_2 , VAR_4 , description ) ; } 
public < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_1 , TYPE_2 > METHOD_1 ( boolean VAR_1 ) { <START> return VAR_2 . METHOD_1 ( ) ; <END> } 
static byte [ ] METHOD_1 ( final TYPE_1 VAR_1 ) throws IOException { final TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . get ( VAR_3 ) . set ( VAR_4 ) ; VAR_2 . get ( VAR_5 ) . set ( VAR_1 ) ; VAR_2 . get ( VAR_6 ) . set ( VAR_7 ) ; <START> final TYPE_1 result = METHOD_2 ( VAR_2 ) ; <END> return METHOD_2 ( VAR_2 ) . get ( 0 ) . get ( STRING_1 ) . METHOD_3 ( ) ; } 
public String METHOD_1 ( int VAR_1 , int VAR_2 ) throws TYPE_1 , TYPE_2 { TYPE_3 . METHOD_2 ( VAR_3 , false ) ; for ( int i = 1 ; i <= VAR_1 ; i ++ ) { <START> boolean VAR_4 = ( VAR_2 - i >= 0 ) ? true : false ; <END> METHOD_3 ( VAR_4 ) ; } try { return TYPE_3 . METHOD_4 ( VAR_5 . getStatus ( ) ) ; } catch ( TYPE_4 VAR_6 ) { throw new TYPE_5 ( STRING_1 , VAR_6 ) ; } } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { <START> log . info ( STRING_1 ) ; <END> TYPE_3 VAR_1 ; VAR_1 = VAR_2 . METHOD_2 ( ) ; TYPE_4 . METHOD_3 ( VAR_1 ) ; TYPE_4 . METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { <START> log . debug ( STRING_1 ) ; <END> } 
public String METHOD_1 ( int VAR_1 , int VAR_2 ) throws TYPE_1 , TYPE_2 { TYPE_3 . METHOD_2 ( VAR_3 , false ) ; for ( int i = 1 ; i <= VAR_1 ; i ++ ) { boolean VAR_4 = ( i <= VAR_2 ) ; METHOD_3 ( VAR_4 ) ; } try { return TYPE_3 . METHOD_4 ( VAR_5 . getStatus ( ) ) ; } catch ( TYPE_4 VAR_6 ) { <START> throw new TYPE_5 ( STRING_1 , VAR_6 ) ; <END> } } 
public void METHOD_1 ( TYPE_2 . TYPE_3 . List < Object > VAR_1 ) throws Exception { for ( Object o : VAR_1 ) { <START> LOG . info ( o . toString ( ) ) ; <END> } } 
protected TYPE_2 ( String VAR_2 , TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_4 = ( ) - > { <START> if ( VAR_3 . METHOD_1 ( ) ) { <END> try { Thread . VAR_5 ( VAR_6 ) ; } catch ( InterruptedException e ) { Thread . VAR_7 ( ) . METHOD_2 ( ) ; } } } ; } 
public TYPE_2 ( ) { <START> if ( TYPE_1 . METHOD_1 ( ) != null ) { <END> this . VAR_2 = TYPE_1 . METHOD_1 ( ) ; } } 
public void METHOD_1 ( Object instance , Object VAR_1 ) throws TYPE_1 { <START> try { <END> VAR_2 . METHOD_2 ( instance ) ; } catch ( Exception e ) { throw new TYPE_1 ( e ) ; } } 
public static void METHOD_1 ( String name , String value , TYPE_1 client ) { TYPE_2 VAR_1 = METHOD_2 ( STRING_1 + name , VAR_2 ) ; VAR_1 . get ( VAR_3 ) . set ( value ) ; <START> VAR_1 . get ( VAR_4 ) . get ( VAR_5 ) . set ( true ) ; <END> TYPE_2 result = METHOD_3 ( VAR_1 , client ) ; log . VAR_6 ( STRING_2 , name , result ) ; } 
public static void METHOD_1 ( String name , TYPE_1 client ) { TYPE_2 VAR_1 = METHOD_2 ( STRING_1 + name , VAR_2 ) ; TYPE_2 result = METHOD_3 ( VAR_1 , client ) ; <START> VAR_1 . get ( VAR_3 ) . get ( VAR_4 ) . set ( true ) ; <END> log . VAR_5 ( STRING_2 , name , result ) ; } 
public static void METHOD_1 ( String name , String value , TYPE_1 client ) { TYPE_2 VAR_1 = METHOD_2 ( STRING_1 + name , VAR_2 ) ; VAR_1 . get ( VAR_3 ) . set ( VAR_4 ) ; VAR_1 . get ( VAR_4 ) . set ( value ) ; <START> VAR_1 . get ( VAR_5 ) . get ( VAR_6 ) . set ( true ) ; <END> TYPE_2 result = METHOD_3 ( VAR_1 , client ) ; log . VAR_7 ( STRING_2 , name , value , result ) ; } 
public void METHOD_1 ( final TYPE_1 context ) { TYPE_5 . TYPE_6 . debug ( STRING_1 ) ; final TYPE_3 VAR_1 = context . VAR_2 ( VAR_3 , VAR_4 ) ; VAR_1 . METHOD_2 ( TYPE_4 . VAR_5 ) ; VAR_1 . METHOD_3 ( TYPE_7 . VAR_5 ) ; if ( context . VAR_7 ( ) ) { <START> TYPE_4 . METHOD_4 ( VAR_1 ) ; <END> } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 reader = new TYPE_1 . Builder ( this . VAR_1 ) . build ( ) ; TYPE_2 VAR_2 = reader . VAR_2 ( TYPE_3 . METHOD_2 ( STRING_1 ) ) ; assertEquals ( true , VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <START> assertEquals ( true , VAR_2 . METHOD_5 ( ) . METHOD_4 ( ) ) ; <END> } 
public void METHOD_1 ( ) { assertNotNull ( STRING_1 , this . VAR_1 . METHOD_2 ( ) ) ; assertEquals ( STRING_2 , STRING_3 , this . VAR_1 . METHOD_2 ( ) . getType ( ) ) ; <START> assertEquals ( <END> STRING_4 , true , this . VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ; } 
private static boolean METHOD_1 ( Path VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) . getName ( ) ; try { TYPE_1 . METHOD_3 ( VAR_2 ) ; return true ; } catch ( Exception e ) { <START> return false ; <END> } } 
public void execute ( ) throws Exception { while ( ! TYPE_1 . METHOD_1 ( ) ) { logger . debug ( STRING_1 + VAR_1 / INT_1 + STRING_2 ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; } if ( ! VAR_3 . METHOD_3 ( ) ) { <START> logger . error ( STRING_3 ) ; <END> throw new Exception ( STRING_4 ) ; } try { METHOD_4 ( ) ; } finally { VAR_3 . METHOD_5 ( ) ; } } 
public TYPE_3 ( TYPE_1 config ) { super ( config ) ; VAR_2 = TYPE_2 . get ( config . VAR_3 ( ) ) ; VAR_4 = TYPE_2 . get ( config . VAR_3 ( ) , STRING_1 ) ; <START> <END> VAR_5 = false ; VAR_6 = false ; } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> this . VAR_2 . set ( VAR_1 ) ; } 
<START> public org . VAR_1 . VAR_2 . TYPE_1 . Builder METHOD_1 ( ) { <END> return this ; } 
protected < T > TYPE_1 METHOD_1 ( T resource ) { if ( resource instanceof TYPE_3 . TYPE_4 ) { return ( ( TYPE_3 . TYPE_4 ) resource ) . VAR_1 . METHOD_1 ( ) ; } else { <START> throw new IllegalArgumentException ( STRING_1 + String . valueOf ( resource ) ) ; <END> } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; VAR_1 = null ; <START> METHOD_2 ( ) ; <END> } 
<START> public synchronized boolean METHOD_1 ( TYPE_1 . Type type ) { <END> return values . keySet ( ) . stream ( ) . METHOD_2 ( e - > e . getType ( ) . equals ( type ) ) ; } 
<START> public void run ( TYPE_1 VAR_1 , Collection < TYPE_2 > VAR_2 ) { <END> if ( VAR_3 == null ) { log . error ( STRING_1 ) ; return ; } if ( VAR_4 == null ) { log . error ( STRING_2 ) ; return ; } for ( TYPE_2 VAR_5 : VAR_2 ) { METHOD_1 ( VAR_5 ) ; } } 
private TYPE_2 ( String name , Type type ) { TYPE_1 . METHOD_1 ( name ) ; <START> TYPE_1 . METHOD_1 ( type ) ; <END> this . name = name ; this . type = type ; } 
public Object METHOD_1 ( Object key , int size , TYPE_1 VAR_1 ) { <START> return new TYPE_2 ( key . VAR_2 ( ) , size ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> log . append ( new String ( VAR_1 . METHOD_2 ( ) ) ) ; <END> } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( VAR_2 ) ; <START> if ( VAR_3 > 0 ) { <END> long VAR_4 = VAR_3 / METHOD_2 ( ) . size ( ) ; long VAR_5 = VAR_3 % METHOD_2 ( ) . size ( ) ; if ( METHOD_3 ( ) + 1 <= VAR_5 ) { VAR_4 ++ ; } VAR_1 = new TYPE_3 ( VAR_4 ) ; } return VAR_1 ; } 
<START> protected Map < String , Object > METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_2 . METHOD_2 ( ) ; } 
<START> public void METHOD_1 ( boolean VAR_1 , TYPE_1 VAR_2 ) { <END> VAR_3 . record ( this , VAR_2 ) ; this . VAR_1 = VAR_1 ; } 
private String METHOD_1 ( String cache , TYPE_1 key ) { <START> String s = new TYPE_2 ( METHOD_2 ( cache ) ) . append ( STRING_1 ) . append ( key ) . toString ( ) ; <END> log . trace ( STRING_2 + s ) ; return s ; } 
public void METHOD_1 ( ) { File VAR_1 = new File ( VAR_2 ) ; if ( VAR_1 . exists ( ) && ! VAR_1 . METHOD_2 ( ) ) { throw new IllegalArgumentException ( VAR_1 . METHOD_3 ( ) + STRING_1 ) ; <START> } else if ( ! VAR_1 . exists ( ) ) { <END> VAR_1 . METHOD_4 ( ) ; } } 
<START> public TYPE_1 < String , TYPE_1 < Integer , String > > METHOD_1 ( ) { <END> return properties ; } 
public long next ( ) { <START> long result = ( long ) ( VAR_1 . METHOD_1 ( ) * VAR_2 + VAR_3 ) ; <END> while ( result < 0 || result >= VAR_4 ) { result = ( long ) ( VAR_1 . METHOD_1 ( ) * VAR_2 + VAR_3 ) ; } return result ; } 
<START> public static TYPE_1 METHOD_1 ( TYPE_1 properties , TYPE_2 VAR_1 ) throws IOException { <END> try { properties . VAR_2 ( VAR_1 ) ; return properties ; } finally { close ( VAR_1 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 key ) { boolean VAR_1 = METHOD_2 ( key ) ; <START> super . remove ( key ) ; <END> TYPE_1 VAR_2 = super . METHOD_1 ( key ) ; METHOD_3 ( VAR_1 ) ; return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 e ) { for ( TYPE_2 listener : VAR_1 ) { try { listener . VAR_1 ( e . getKey ( ) , e . VAR_2 ( ) ) ; <START> } catch ( Throwable t ) { <END> log . error ( STRING_1 + listener + STRING_2 , t ) ; } } } 
protected int METHOD_1 ( ) { <START> return METHOD_2 ( ) * ( VAR_1 != null ? VAR_2 . length + 1 : 1 ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; VAR_1 = null ; VAR_2 . METHOD_1 ( ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> } 
public Object run ( TYPE_1 VAR_1 , int VAR_2 ) { Map < String , Object > VAR_3 = new HashMap < String , Object > ( ) ; VAR_3 . put ( TYPE_2 . VAR_5 , VAR_6 ) ; VAR_3 . put ( TYPE_2 . VAR_7 , VAR_8 ) ; VAR_3 . put ( TYPE_2 . VAR_9 , VAR_10 ) ; Object obj = VAR_1 . METHOD_1 ( VAR_2 , TYPE_3 . VAR_12 , VAR_3 ) ; <START> VAR_13 . add ( obj ) ; <END> return obj ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 result = null ; TYPE_2 t = VAR_2 . METHOD_2 ( ) ; if ( t == null ) { <START> result = VAR_2 . METHOD_3 ( ) ; <END> } else { for ( TYPE_1 add : t . VAR_3 ( ) ) { if ( add . toString ( ) . contains ( VAR_1 ) ) { result = add ; break ; } } } return result ; } 
public void METHOD_1 ( boolean VAR_1 ) { <START> } <END> 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , String name , long VAR_2 ) { String url = METHOD_2 ( VAR_1 , name ) ; String VAR_3 = METHOD_3 ( url , 1 ) ; String VAR_4 = METHOD_3 ( url , 2 ) ; try { return new TYPE_2 ( VAR_1 , VAR_2 ) . METHOD_4 ( ( VAR_5 ) - > METHOD_5 ( url , VAR_3 , VAR_4 ) ) ; <START> } catch ( Exception e ) { <END> return false ; } } 
default boolean VAR_1 ( String VAR_2 ) { <START> TYPE_1 VAR_4 = TYPE_1 . getInstance ( ) ; <END> String res = VAR_4 . VAR_5 ( ) ; if ( res . contains ( VAR_2 ) ) { LOGGER . info ( STRING_1 + VAR_2 + STRING_2 ) ; return true ; } else { LOGGER . error ( STRING_3 + VAR_2 + STRING_4 + res ) ; return false ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 . METHOD_3 ( ) <= VAR_2 || VAR_1 . METHOD_3 ( ) >= VAR_3 ) { <END> METHOD_4 ( ) ; VAR_1 . METHOD_5 ( TYPE_2 . VAR_5 ) ; METHOD_6 ( ) ; } else METHOD_7 ( ) ; } 
public void METHOD_1 ( Iterator < TYPE_1 > VAR_1 ) throws Exception { if ( METHOD_2 ( ) == 1 ) { <START> METHOD_3 ( ) ; <END> if ( METHOD_4 ( ) ) { VAR_1 = METHOD_5 ( ) ; } } METHOD_6 ( VAR_1 ) ; METHOD_7 ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { int VAR_3 = METHOD_2 ( ) . VAR_4 - METHOD_2 ( ) . index ; <START> return VAR_1 . METHOD_3 ( ) . METHOD_4 ( VAR_3 ) == VAR_2 <END> . METHOD_4 ( VAR_5 - 1 ) ; } 
public Integer METHOD_1 ( ) { <START> if ( VAR_1 == null ) <END> VAR_1 = new Integer ( 0 ) ; return VAR_1 ; } 
public String toString ( ) { StringBuilder VAR_1 = new StringBuilder ( ) ; VAR_1 . append ( CHAR_1 ) ; <START> VAR_1 . append ( VAR_2 + STRING_1 + VAR_3 ) ; <END> VAR_1 . append ( CHAR_2 ) ; return VAR_1 . toString ( ) ; } 
public void METHOD_1 ( Iterator < TYPE_1 > VAR_1 ) throws Exception { METHOD_2 ( ) ; <START> if ( METHOD_3 ( ) == 1 && VAR_2 . contains ( METHOD_4 ( ) ) ) { <END> METHOD_5 ( ) ; } else if ( METHOD_3 ( ) <= VAR_3 + 1 && VAR_1 . hasNext ( ) ) { METHOD_5 ( ) ; } METHOD_6 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( INT_1 ) ; String VAR_3 = STRING_1 ; String VAR_4 = STRING_2 ; <START> METHOD_3 ( VAR_1 . METHOD_4 ( ) , 0 ) ; <END> VAR_2 . METHOD_5 ( VAR_1 , TYPE_1 . TYPE_2 . VAR_6 , VAR_3 , VAR_4 ) ; TYPE_1 VAR_7 = VAR_2 . METHOD_2 ( INT_1 ) ; assertEquals ( VAR_7 . METHOD_4 ( ) , VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_2 ( this ) ; METHOD_3 ( ) . add ( VAR_1 ) ; } } 
public void METHOD_1 ( ) { <START> int i = 0 ; <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; Collection < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( ) ; List < TYPE_3 > VAR_4 ; VAR_1 . METHOD_3 ( ) . clear ( ) ; VAR_4 = VAR_5 . METHOD_4 ( null , VAR_2 ) ; assertEquals ( VAR_4 . size ( ) , 4 ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> int VAR_3 = VAR_1 . size ( ) ; <END> assertEquals ( VAR_3 , 1 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . get ( 0 ) ; Context . VAR_3 ( ) . METHOD_3 ( VAR_1 , false ) ; List < TYPE_1 > list = VAR_2 . METHOD_2 ( ) ; <START> int VAR_4 = list . size ( ) ; <END> assertEquals ( VAR_4 , 0 ) ; } 
public void METHOD_1 ( ) { int i = 0 ; TYPE_1 VAR_1 = new TYPE_1 ( ) ; Collection < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( ) ; <START> List < TYPE_3 > VAR_4 ; <END> VAR_1 . METHOD_3 ( 1 ) ; VAR_1 . METHOD_3 ( 2 ) ; VAR_4 = VAR_5 . METHOD_4 ( VAR_1 , VAR_2 ) ; assertEquals ( VAR_4 . size ( ) , 2 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { if ( log . VAR_2 ( ) ) { <START> log . debug ( STRING_1 + VAR_1 ) ; <END> } return METHOD_2 ( ) . METHOD_1 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( String s ) { try { return Context . VAR_1 ( ) . METHOD_2 ( Integer . valueOf ( s ) ) ; } catch ( Exception e ) { <START> logger . error ( STRING_1 , e ) ; <END> } return null ; } 
public void METHOD_1 ( Object obj , TYPE_1 VAR_1 ) throws TYPE_2 { log . debug ( STRING_1 , this . getClass ( ) . getName ( ) ) ; <START> if ( obj == null || ! ( obj instanceof TYPE_3 ) ) { <END> throw new IllegalArgumentException ( STRING_2 + TYPE_3 . class ) ; } TYPE_3 VAR_2 = ( TYPE_3 ) obj ; TYPE_4 . METHOD_2 ( VAR_1 , STRING_3 , STRING_4 ) ; TYPE_5 . METHOD_3 ( VAR_1 , obj . getClass ( ) , STRING_3 ) ; } 
public void METHOD_1 ( ) { VAR_1 = Context . VAR_2 ( ) ; <START> METHOD_2 ( VAR_3 ) ; <END> } 
public void METHOD_1 ( ) { <START> String VAR_1 = STRING_1 ; <END> TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; List < TYPE_1 > VAR_3 = VAR_4 . METHOD_3 ( VAR_1 ) ; assertTrue ( VAR_3 . isEmpty ( ) ) ; TYPE_1 VAR_5 = VAR_4 . METHOD_4 ( VAR_2 ) ; assertEquals ( VAR_1 , VAR_5 . METHOD_5 ( ) ) ; assertEquals ( VAR_2 , VAR_5 ) ; } 
public void METHOD_1 ( Date VAR_1 ) { <START> this . VAR_1 = new Date ( VAR_1 . METHOD_2 ( ) ) ; <END> } 
public Date METHOD_1 ( ) { <START> return VAR_1 != null ? ( Date ) VAR_1 . METHOD_2 ( ) : new Date ( ) ; <END> } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( new TYPE_2 ( 3 ) ) ; Assert . assertThat ( VAR_1 , METHOD_3 ( VAR_2 . METHOD_4 ( 3 ) , VAR_2 . METHOD_4 ( INT_1 ) , VAR_2 . METHOD_4 ( INT_2 ) , VAR_2 . METHOD_4 ( INT_3 ) ) ) ; <START> } <END> 
public void METHOD_1 ( ) { TYPE_1 p = new TYPE_1 ( ) ; p . VAR_1 ( null ) ; <START> assertThat ( VAR_2 . METHOD_2 ( p , true , true ) , is ( empty ( ) ) ) ; <END> } 
public void METHOD_1 ( boolean VAR_1 ) { <START> this . VAR_1 = VAR_1 == true ; <END> } 
public void METHOD_1 ( boolean VAR_1 ) { <START> this . VAR_1 = VAR_1 == false ; <END> } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <START> System . out . println ( STRING_1 ) ; <END> TYPE_3 query = VAR_2 . METHOD_2 ( ) . METHOD_3 ( STRING_2 + STRING_3 ) ; query . VAR_3 ( STRING_4 , VAR_1 . getId ( ) ) ; return query . list ( ) ; } 
public boolean METHOD_1 ( ) { <START> return false ; <END> } 
public Object METHOD_1 ( Context context , Class VAR_1 , String method , Exception e , TYPE_1 info ) { log . debug ( STRING_1 + VAR_1 . getName ( ) + STRING_2 + method , e ) ; if ( STRING_3 . equals ( method ) ) { return null ; } <START> <END> try { throw e ; } catch ( Exception x ) { x . VAR_2 ( ) ; } return info ; } 
public Collection < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_2 < > ( ) ; <START> } <END> return VAR_1 ; return VAR_1 . stream ( ) . filter ( m - > ! m . VAR_2 ( ) ) . collect ( Collectors . VAR_3 ( ) ) ; } 
public void METHOD_1 ( ) { <START> Context . VAR_1 ( ) ; <END> TYPE_1 VAR_2 = Context . VAR_3 ( new TYPE_2 ( STRING_1 ) ) ; Assert . assertEquals ( STRING_2 , VAR_2 . METHOD_2 ( ) ) ; Assert . assertEquals ( Context . VAR_4 ( ) . METHOD_3 ( ) , VAR_2 . METHOD_4 ( ) . METHOD_3 ( ) ) ; Assert . assertEquals ( STRING_1 , Context . VAR_4 ( ) . METHOD_5 ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( INT_1 ) ; <START> boolean result = VAR_1 . equals ( null ) ; <END> METHOD_2 ( result ) ; } 
<START> public void METHOD_1 ( ) throws RuntimeException { <END> if ( ! VAR_1 . isEmpty ( ) ) { throw new TYPE_1 ( STRING_1 ) ; } VAR_2 = VAR_3 ; } 
<START> public Optional < String > METHOD_1 ( ) { Optional < String > VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . isPresent ( ) ) { return Optional . of ( VAR_2 + File . VAR_3 + VAR_4 + VAR_1 . get ( ) + VAR_5 ) ; } return Optional . empty ( ) ; } <END> 
protected void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = null ; try { VAR_1 = connection . VAR_2 ( ) ; String query = STRING_1 ; VAR_1 . execute ( query ) ; } catch ( TYPE_3 e ) { <START> log . info ( STRING_2 ) ; <END> } finally { connection . close ( ) ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { if ( StringUtils . VAR_2 ( VAR_1 ) ) { TYPE_1 user = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( user == null ) { return METHOD_3 ( VAR_1 ) ; <START> } else { <END> return user ; } } throw new TYPE_2 ( STRING_1 , ( Object [ ] ) null ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = null ; <START> METHOD_2 ( VAR_1 ) ; <END> VAR_2 . METHOD_3 ( VAR_1 ) ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , Date VAR_2 ) { <START> return VAR_3 . METHOD_2 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( 3 ) ; <START> List < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <END> assertEquals ( 2 , VAR_2 . size ( ) ) ; TYPE_1 VAR_4 = new TYPE_1 ( INT_1 ) ; List < TYPE_2 > VAR_5 = VAR_3 . METHOD_2 ( VAR_4 ) ; assertEquals ( 0 , VAR_5 . size ( ) ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( 2 ) ; <END> List < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; assertEquals ( 2 , VAR_2 . size ( ) ) ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> if ( log . VAR_2 ( ) ) { log . info ( STRING_1 + VAR_1 ) ; } return VAR_3 . METHOD_1 ( VAR_1 ) ; } 
<START> public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <END> if ( log . VAR_2 ( ) ) { log . info ( STRING_1 + VAR_1 ) ; } return VAR_3 . METHOD_1 ( VAR_1 ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> VAR_1 . METHOD_2 ( false ) ; VAR_1 . METHOD_3 ( null ) ; VAR_1 . METHOD_4 ( null ) ; VAR_1 . METHOD_5 ( null ) ; Context . VAR_2 ( ) . METHOD_6 ( VAR_1 ) ; return VAR_1 ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> return VAR_2 . METHOD_1 ( VAR_1 ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> VAR_2 . METHOD_2 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { <START> TYPE_1 user = VAR_2 . METHOD_1 ( VAR_1 ) ; <END> if ( METHOD_2 ( user ) ) { log . warn ( STRING_1 + VAR_1 + STRING_2 ) ; return null ; } return user ; } 
public TYPE_1 METHOD_1 ( Integer VAR_1 ) throws TYPE_2 { <START> TYPE_1 user = VAR_2 . METHOD_1 ( VAR_1 ) ; <END> if ( METHOD_2 ( user ) ) { log . warn ( STRING_1 + VAR_1 + STRING_2 ) ; return null ; } return user ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { List < TYPE_2 > VAR_2 = new ArrayList < > ( ) ; VAR_2 . add ( VAR_1 ) ; <START> return METHOD_2 ( Context . VAR_3 ( ) . METHOD_3 ( null , VAR_2 , false ) ) ; <END> } 
public void METHOD_1 ( Object object , TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 , STRING_2 ) ; TYPE_2 . METHOD_2 ( VAR_1 , STRING_3 , STRING_2 ) ; if ( object == null ) { throw new IllegalArgumentException ( STRING_4 ) ; } if ( ! ( object instanceof TYPE_3 ) ) { throw new IllegalArgumentException ( STRING_5 + TYPE_3 . class ) ; } <START> <END> } 
public void METHOD_1 ( ) { exception . VAR_1 ( IllegalArgumentException . VAR_2 ) ; <START> exception . VAR_3 ( STRING_1 ) ; <END> VAR_4 . METHOD_2 ( STRING_2 , null ) ; } 
private static String METHOD_1 ( String VAR_1 ) { <START> String VAR_2 = STRING_1 + VAR_1 + STRING_2 ; <END> return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( new TYPE_1 ( ) ) ; <END> } 
public static List < Integer > METHOD_1 ( String VAR_1 , String VAR_2 ) { List < Integer > VAR_3 = new ArrayList < > ( ) ; String [ ] VAR_4 = VAR_1 . split ( VAR_2 ) ; for ( String token : VAR_4 ) { token = token . trim ( ) ; if ( token . length ( ) == 0 ) { } else { VAR_3 . add ( Integer . valueOf ( token ) ) ; <START> } <END> } return VAR_3 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( new TYPE_1 ( VAR_1 ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 { <START> if ( VAR_1 . METHOD_2 ( ) == null ) { <END> throw new TYPE_3 ( STRING_1 , ( Object [ ] ) null ) ; } if ( VAR_1 . METHOD_3 ( ) == null ) { VAR_1 . METHOD_4 ( VAR_2 ) ; } else if ( ! VAR_1 . METHOD_3 ( ) . equals ( VAR_2 ) ) { throw new TYPE_3 ( STRING_2 , new Object [ ] { VAR_1 . METHOD_3 ( ) } ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . METHOD_1 ( VAR_1 ) ; if ( VAR_2 != null && VAR_2 . METHOD_2 ( ) ) { <START> VAR_2 = METHOD_1 ( VAR_2 ) ; <END> } return VAR_2 ; } 
public void METHOD_1 ( ) throws Exception { <START> int VAR_1 = 3 ; <END> String VAR_2 = STRING_1 ; TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ; VAR_4 . METHOD_5 ( VAR_3 , VAR_2 ) ; assertTrue ( VAR_3 . METHOD_4 ( ) ) ; assertEquals ( VAR_2 , VAR_3 . METHOD_6 ( ) ) ; } 
<START> public static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 outputStream ) throws IOException { <END> if ( VAR_1 == null || outputStream == null ) { if ( outputStream != null ) { TYPE_3 . METHOD_2 ( outputStream ) ; } return false ; } try { TYPE_3 . METHOD_3 ( VAR_1 , outputStream ) ; } finally { TYPE_3 . METHOD_2 ( outputStream ) ; return true ; } } 
<START> public void METHOD_1 ( ) throws IOException { <END> final int VAR_1 = INT_1 ; File VAR_2 = this . METHOD_2 ( ) ; TYPE_1 . METHOD_3 ( METHOD_4 ( ) , VAR_2 , null , false ) ; Assert . assertEquals ( VAR_1 , TYPE_2 . METHOD_5 ( VAR_2 , null , true ) . size ( ) ) ; TYPE_2 . METHOD_6 ( VAR_2 ) ; } 
public boolean contains ( TYPE_1 VAR_1 ) { <START> return METHOD_1 ( ) != null && METHOD_1 ( ) . stream ( ) <END> . METHOD_2 ( m - > m . VAR_2 ( ) . METHOD_3 ( ) . equals ( VAR_1 . METHOD_3 ( ) ) ) ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
<START> private TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 { if ( ! VAR_1 . contains ( VAR_2 ) ) { <START> TYPE_4 . METHOD_2 ( VAR_2 ) ; <END> VAR_1 . METHOD_3 ( VAR_2 ) ; Context . VAR_3 ( ) . METHOD_4 ( VAR_1 ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( VAR_1 ) ; TYPE_1 VAR_2 = new TYPE_1 ( 4 ) ; <START> METHOD_3 ( VAR_3 . METHOD_4 ( 2 ) . contains ( VAR_2 . METHOD_5 ( ) ) ) ; <END> try { VAR_3 . METHOD_6 ( VAR_3 . METHOD_4 ( 2 ) , VAR_2 ) ; } catch ( Exception e ) { Assert . VAR_4 ( STRING_1 ) ; } } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( VAR_1 ) ; <START> <END> TYPE_1 VAR_2 = new TYPE_1 ( new TYPE_2 ( 4 ) ) ; VAR_3 . METHOD_3 ( VAR_3 . METHOD_4 ( 1 ) , VAR_2 ) ; assertTrue ( VAR_3 . METHOD_4 ( 1 ) . contains ( VAR_2 ) ) ; } 
public boolean METHOD_1 ( ) { <START> return this . METHOD_2 ( ) . METHOD_3 ( new Date ( ) ) && this . METHOD_4 ( ) == null ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( true , 1 , 2 , 3 , STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 ) ; TYPE_2 type = new TYPE_2 ( new Integer ( 3 ) ) ; type . VAR_2 ( STRING_3 ) ; <START> Assert . VAR_3 ( null , VAR_1 . METHOD_3 ( type ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 { if ( ! StringUtils . VAR_3 ( VAR_2 ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> return METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( new TYPE_3 ( ) ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; <START> TYPE_4 . METHOD_4 ( VAR_1 , null , STRING_1 , STRING_2 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( new TYPE_3 ( ) ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; TYPE_4 . METHOD_4 ( VAR_1 , STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , STRING_8 , STRING_9 , STRING_10 , STRING_11 , STRING_12 , <START> STRING_13 , STRING_14 , STRING_15 , STRING_16 , STRING_17 , STRING_18 , <END> STRING_19 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( new TYPE_1 ( ) , null , STRING_1 , STRING_2 ) ; <END> METHOD_2 ( new TYPE_2 ( ) , null , STRING_1 , STRING_2 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 . METHOD_2 ( new TYPE_2 ( ) , null , STRING_1 , STRING_2 ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_1 target ) { super . METHOD_1 ( target ) ; target . VAR_1 ( METHOD_2 ( ) ) ; target . VAR_2 ( METHOD_3 ( ) ) ; target . VAR_3 ( METHOD_4 ( ) ) ; target . VAR_4 ( METHOD_5 ( ) ) ; target . VAR_5 ( METHOD_6 ( ) ) ; target . VAR_6 ( METHOD_7 ( ) ) ; <START> target . VAR_7 ( METHOD_8 ( ) ) ; <END> return target ; } 
public String getMessage ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> if ( ( VAR_1 . METHOD_1 ( ) [ 0 ] ) == ( VAR_3 . getMessage ( VAR_1 , VAR_2 ) ) ) { <END> return ( VAR_1 . METHOD_1 ( ) [ ( VAR_1 . METHOD_1 ( ) . length ) - 1 ] ) ; } else { return VAR_3 . getMessage ( VAR_1 , VAR_2 ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; <START> VAR_1 . METHOD_2 ( STRING_1 ) ; <END> TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; VAR_3 . METHOD_2 ( STRING_2 ) ; METHOD_4 ( VAR_1 . METHOD_5 ( VAR_3 ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_3 . METHOD_2 ( VAR_2 ) ; <START> VAR_1 . METHOD_3 ( VAR_3 ) ; <END> VAR_1 . METHOD_4 ( STRING_1 ) ; TYPE_1 VAR_4 = new TYPE_1 ( ) ; VAR_4 . METHOD_2 ( VAR_2 ) ; VAR_4 . METHOD_3 ( VAR_3 ) ; VAR_4 . METHOD_4 ( STRING_2 ) ; assertTrue ( VAR_1 . METHOD_5 ( VAR_4 ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( STRING_1 ) ; TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; METHOD_4 ( VAR_1 . METHOD_5 ( VAR_3 ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_2 . METHOD_3 ( ) ) ) { return VAR_2 ; <START> } else { <END> return null ; } } 
<START> public TYPE_1 METHOD_1 ( ) throws IOException { <END> if ( stream == null ) { stream = METHOD_2 ( ) ; } return ( stream ) ; } 
<START> public static void METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_2 . VAR_3 = VAR_1 ; } 
<START> public static void METHOD_1 ( Map < String , TYPE_1 > VAR_1 ) { <END> TYPE_2 . VAR_3 = VAR_1 ; } 
<START> public static void METHOD_1 ( <END> Map < Class < ? extends TYPE_1 > , TYPE_1 > VAR_1 ) { TYPE_2 . VAR_3 = VAR_1 ; } 
public static Thread METHOD_1 ( final TYPE_1 VAR_1 ) { if ( ! METHOD_2 ( ) ) { throw new TYPE_2 ( STRING_1 ) ; } TYPE_3 VAR_2 = new TYPE_3 ( ) { @Override public void run ( ) { VAR_3 . set ( true ) ; try { Context . VAR_4 ( ) ; <START> new Thread ( VAR_1 ) . start ( ) ; <END> } finally { Context . VAR_5 ( ) ; } } } ; VAR_2 . start ( ) ; return VAR_2 ; } 
public static Thread METHOD_1 ( final TYPE_1 VAR_1 , TYPE_2 token ) { if ( ! TYPE_3 . METHOD_2 ( token ) ) { throw new TYPE_4 ( STRING_1 + token ) ; } TYPE_5 VAR_2 = new TYPE_5 ( ) { @Override public void run ( ) { VAR_3 . set ( true ) ; try { Context . VAR_4 ( ) ; <START> new Thread ( VAR_1 ) . start ( ) ; <END> } finally { Context . VAR_5 ( ) ; } } } ; VAR_2 . start ( ) ; return VAR_2 ; } 
public void METHOD_1 ( ) throws Exception { List < TYPE_1 > VAR_1 = Context . VAR_2 ( ) . METHOD_2 ( ) ; <START> VAR_1 . remove ( 3 ) ; <END> VAR_1 . add ( new TYPE_1 ( STRING_1 , STRING_2 , STRING_3 ) ) ; Context . VAR_2 ( ) . METHOD_3 ( VAR_1 ) ; Assert . assertNotNull ( Context . VAR_2 ( ) . METHOD_4 ( STRING_1 ) . METHOD_5 ( ) ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . class ) ; VAR_2 . add ( TYPE_4 . METHOD_4 ( STRING_1 , VAR_1 ) ) ; <START> if ( VAR_2 . list ( ) . size ( ) > 0 ) { <END> return true ; } return false ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( false ) ; <END> return VAR_2 . METHOD_3 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( this . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( this . METHOD_5 ( ) ) ; VAR_1 . METHOD_6 ( TYPE_3 . VAR_3 ) ; VAR_1 . METHOD_7 ( this ) ; VAR_1 . METHOD_8 ( this . METHOD_9 ( ) ) ; VAR_1 . METHOD_10 ( this . METHOD_11 ( ) ) ; VAR_1 . METHOD_12 ( this . METHOD_13 ( ) ) ; <START> VAR_1 . METHOD_14 ( this . METHOD_15 ( ) ) ; <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( this . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( this . METHOD_5 ( ) ) ; VAR_1 . METHOD_6 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_7 ( this ) ; VAR_1 . METHOD_8 ( this . METHOD_9 ( ) ) ; <START> VAR_1 . METHOD_10 ( this . METHOD_11 ( ) ) ; <END> VAR_1 . METHOD_12 ( this . METHOD_13 ( ) ) ; return VAR_1 ; } 
<START> public Collection < TYPE_1 > METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = Collections . VAR_2 ; } return VAR_1 ; } 
<START> public TYPE_2 . TYPE_4 METHOD_1 ( TYPE_2 < T > VAR_1 , String VAR_2 ) { <END> TYPE_3 < T > VAR_3 = ( TYPE_3 < T > ) VAR_1 ; return new TYPE_2 . TYPE_4 ( VAR_3 . METHOD_2 ( VAR_2 ) . getName ( ) , true ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_1 item ) throws TYPE_2 { VAR_1 . METHOD_2 ( ) . METHOD_3 ( item ) ; <START> return null ; <END> } 
private String METHOD_1 ( Response response ) { String VAR_1 = TYPE_1 . METHOD_2 ( ) . toString ( ) ; byte [ ] VAR_2 = new byte [ INT_1 ] ; VAR_3 . METHOD_3 ( VAR_2 ) ; <START> String state = VAR_4 . VAR_5 . TYPE_2 . METHOD_4 ( ) . METHOD_5 ( VAR_2 ) ; <END> TYPE_3 VAR_6 = new TYPE_3 ( STRING_1 , VAR_1 ) ; response . VAR_7 ( ) . add ( VAR_6 ) ; METHOD_6 ( ) . METHOD_7 ( ) . put ( VAR_1 , state ) ; return state ; } 
public static String METHOD_1 ( String uri ) { <START> String VAR_1 = "" ; <END> String [ ] split = uri . VAR_2 ( STRING_1 , "" ) . METHOD_2 ( STRING_2 , "" ) . split ( STRING_3 ) ; for ( String VAR_3 : split ) { VAR_1 += StringUtils . VAR_4 ( VAR_3 ) ; } return VAR_1 ; } 
<START> public List < TYPE_1 > METHOD_1 ( final TYPE_2 < TYPE_1 > VAR_1 , ANNOTATION_1 final TYPE_3 VAR_2 , final Boolean VAR_3 , final Boolean VAR_4 , final String VAR_5 , final String VAR_6 , final String VAR_7 ) throws TYPE_4 { <END> return METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , null , null , TYPE_5 . builder ( ) . METHOD_2 ( VAR_5 ) . METHOD_3 ( VAR_6 ) . METHOD_4 ( VAR_7 ) . build ( ) ) ; } 
<START> } catch ( TYPE_4 VAR_2 ) { <END> try { Class . VAR_3 ( STRING_1 ) ; VAR_4 = new TYPE_1 ( ) { TYPE_5 public TYPE_3 create ( String message , String VAR_8 , String VAR_9 ) { return new org . VAR_10 . VAR_11 . VAR_12 . VAR_13 . TYPE_2 ( message , VAR_8 , VAR_9 ) ; } } ; } catch ( TYPE_4 VAR_15 ) { } } 
<START> protected void METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 > VAR_2 ) { <END> if ( ! VAR_2 . isEmpty ( ) ) { int VAR_3 = VAR_2 . size ( ) ; int VAR_4 = VAR_1 . METHOD_2 ( ) . length ; if ( VAR_4 != VAR_3 ) { throw METHOD_3 ( VAR_4 , VAR_2 ) ; } } } 
public TYPE_1 < T > METHOD_1 ( Class < ? extends Throwable > VAR_1 , Class < ? extends Throwable > ... VAR_2 ) { if ( VAR_2 == null ) { <START> return METHOD_2 ( ) ; <END> } TYPE_1 < T > VAR_3 = METHOD_1 ( VAR_1 ) ; for ( Class < ? extends Throwable > t : VAR_2 ) { VAR_3 = VAR_3 . METHOD_1 ( t ) ; } return VAR_3 ; } 
public Object METHOD_1 ( TYPE_1 VAR_1 ) throws Throwable { if ( VAR_2 == null ) { <START> throw new IllegalStateException ( STRING_1 + <END> STRING_2 ) ; } if ( TYPE_2 . METHOD_2 ( VAR_2 ) ) { throw VAR_2 ; } VAR_2 . METHOD_3 ( ) ; filter . filter ( VAR_2 ) ; throw VAR_2 ; } 
private static String METHOD_1 ( List < TYPE_1 > VAR_1 ) { if ( VAR_1 == null ) { return STRING_1 ; } StringBuilder sb = new StringBuilder ( ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { <START> sb . append ( VAR_2 ) . append ( STRING_1 ) ; <END> } return sb . toString ( ) ; } 
<START> public TYPE_1 METHOD_1 ( Object target , TYPE_2 VAR_1 , TYPE_3 method , final TYPE_4 VAR_2 , Object ... args ) { <END> TYPE_7 . TYPE_8 VAR_3 = new TYPE_7 . TYPE_8 ( VAR_2 ) ; return TYPE_6 . METHOD_1 ( target , method , args , VAR_3 , VAR_1 ) ; } 
public TYPE_5 ( TYPE_1 < Object , TYPE_2 > VAR_2 , String VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; try { TYPE_3 field = TYPE_1 . class . METHOD_1 ( STRING_1 ) ; field . VAR_4 ( true ) ; VAR_5 = field . get ( VAR_2 ) ; } catch ( Exception e ) { <START> throw new TYPE_4 ( STRING_2 , e ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( listener ) ; listener . VAR_1 ( new TYPE_2 ( ) { public Throwable METHOD_4 ( ) { return null ; } public Object METHOD_5 ( ) { <START> return VAR_2 . get ( 0 ) ; <END> } public String METHOD_6 ( ) { return null ; } } ) ; TYPE_1 . METHOD_7 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = VAR_2 ; } this . VAR_1 = VAR_1 ; return this ; } 
public List < T > METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; try { <START> return Arrays . asList ( ( T [ ] ) VAR_2 . METHOD_3 ( ) ) ; <END> } finally { VAR_1 . METHOD_4 ( ) ; } } 
<START> public void METHOD_1 ( ) { <END> assertEquals ( new TYPE_1 ( STRING_1 ) . METHOD_2 ( TYPE_2 . class ) . getClass ( ) , TYPE_2 . class ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 listener = new TYPE_2 ( ) ; TYPE_3 VAR_1 = TYPE_4 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( listener ) ; <START> TYPE_5 VAR_2 = TYPE_6 . class . METHOD_4 ( STRING_1 , String . VAR_3 ) ; <END> TYPE_6 VAR_4 = METHOD_5 ( TYPE_6 . VAR_3 ) ; TYPE_7 VAR_5 = METHOD_6 ( ) ; METHOD_7 ( VAR_4 , VAR_5 ) . METHOD_8 ( "" ) ; assertThat ( listener ) . is ( METHOD_9 ( VAR_4 , VAR_5 , VAR_2 ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( TYPE_1 . METHOD_3 ( ) . METHOD_4 ( TYPE_1 . VAR_1 ) ) ; <END> TYPE_2 < TYPE_3 > VAR_2 = METHOD_5 ( TYPE_3 . class ) ; TYPE_3 VAR_3 = VAR_4 . METHOD_6 ( VAR_2 , new TYPE_4 < TYPE_3 > ( VAR_2 ) ) ; assertThat ( VAR_3 . METHOD_7 ( ) ) . METHOD_8 ( STRING_1 ) ; } 
public static boolean METHOD_1 ( ) { if ( ! TYPE_1 . equals ( STRING_1 ) ) { return false ; } int VAR_1 = TYPE_2 . METHOD_2 ( CHAR_1 ) ; int VAR_2 = TYPE_2 . METHOD_2 ( CHAR_2 ) ; if ( VAR_1 == - 1 || VAR_2 == - 1 ) { return false ; } String VAR_3 = TYPE_2 . substring ( VAR_1 + 1 , VAR_2 - 1 ) ; <START> return INT_1 > Integer . valueOf ( VAR_3 ) ; <END> } 
public void METHOD_1 ( TYPE_1 listener ) { <START> if ( listener instanceof TYPE_2 ) { <END> METHOD_2 ( ) . METHOD_1 ( listener ) ; } } 
public void METHOD_1 ( TYPE_1 listener ) { assertNotNull ( listener ) ; if ( listener instanceof TYPE_2 ) { METHOD_2 ( ) . METHOD_1 ( listener ) ; } <START> } <END> 
private List < TYPE_1 > METHOD_1 ( List < ? extends TYPE_1 > VAR_1 , String VAR_2 ) { if ( VAR_2 . length ( ) != 0 ) { TYPE_2 VAR_3 = TYPE_2 . METHOD_2 ( VAR_2 ) ; VAR_1 = VAR_1 . stream ( ) . filter ( t - > VAR_3 . matcher ( t . VAR_4 ( ) ) . METHOD_3 ( ) ) . collect ( Collectors . VAR_5 ( ) ) ; } <START> return ( List < TYPE_1 > ) VAR_1 ; <END> } 
protected void METHOD_1 ( final TYPE_1 buffer , final String VAR_1 , final Collection < ? > VAR_2 ) { if ( VAR_2 != null && ! VAR_2 . isEmpty ( ) ) { VAR_2 . stream ( ) . METHOD_2 ( ) . map ( Object : : getClass ) <START> . filter ( Class : : METHOD_3 ) <END> . METHOD_4 ( ( VAR_3 ) - > METHOD_1 ( buffer , VAR_1 , VAR_2 . METHOD_5 ( ) ) ) ; return ; } buffer . append ( VAR_2 ) ; } 
public static float [ ] METHOD_1 ( final float [ ] VAR_1 , final float element ) { <START> TYPE_1 VAR_2 = METHOD_2 ( VAR_1 , element ) ; <END> return ( float [ ] ) METHOD_3 ( ( Object ) VAR_1 , VAR_2 ) ; } 
public static RuntimeException METHOD_1 ( Throwable VAR_1 ) { if ( VAR_1 == null ) { throw new TYPE_1 ( STRING_1 ) ; } <START> if ( VAR_1 instanceof RuntimeException ) { <END> throw ( RuntimeException ) VAR_1 ; } else if ( VAR_1 instanceof TYPE_2 ) { throw ( TYPE_2 ) VAR_1 ; } else if ( VAR_1 instanceof IOException ) { throw new TYPE_3 ( ( IOException ) VAR_1 ) ; } else { throw new TYPE_4 ( VAR_1 ) ; } } 
private Object METHOD_1 ( ) { <START> return TYPE_1 . VAR_2 ; <END> } 
public boolean equals ( final Object obj ) { <START> return obj instanceof TYPE_1 && Arrays . equals ( VAR_1 , ( ( TYPE_1 ) obj ) . VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { <START> Assert . assertEquals ( 0 , new TYPE_1 ( false , INT_1 , 0 ) ) ; <END> } 
public static String METHOD_1 ( final String VAR_1 , final String VAR_2 ) { <START> return isEmpty ( VAR_1 ) ? VAR_3 : VAR_1 + METHOD_2 ( VAR_2 ) ; <END> } 
public static String METHOD_1 ( final String VAR_1 , final String VAR_2 ) { <START> return METHOD_2 ( VAR_1 ) ? VAR_3 : VAR_1 + METHOD_3 ( VAR_2 ) ; <END> } 
public static String METHOD_1 ( final String VAR_1 , final String VAR_2 ) { <START> return isEmpty ( VAR_1 ) ? VAR_3 : METHOD_2 ( VAR_2 ) + VAR_1 ; <END> } 
public static String METHOD_1 ( final String VAR_1 , final String VAR_2 ) { <START> return METHOD_2 ( VAR_1 ) ? VAR_3 : METHOD_3 ( VAR_2 ) + VAR_1 ; <END> } 
public static boolean METHOD_1 ( final TYPE_1 ... VAR_1 ) { if ( TYPE_2 . isEmpty ( VAR_1 ) ) { <START> return true ; <END> } for ( final TYPE_1 VAR_2 : VAR_1 ) { if ( METHOD_2 ( VAR_2 ) ) { return true ; } } return false ; } 
public void METHOD_1 ( ) { <START> try { <END> TYPE_1 . METHOD_2 ( null , VAR_1 ) ; METHOD_3 ( STRING_1 ) ; } catch ( final TYPE_2 VAR_2 ) { } } 
public void METHOD_1 ( ) { <START> try { <END> TYPE_1 . METHOD_2 ( VAR_1 , null ) ; METHOD_3 ( STRING_1 ) ; } catch ( final TYPE_2 VAR_2 ) { } } 
public static Thread METHOD_1 ( final long VAR_1 ) { final Collection < Thread > result = METHOD_2 ( new TYPE_1 ( VAR_1 ) ) ; <START> if ( ! result . iterator ( ) . hasNext ( ) ) { <END> return null ; } else { return result . iterator ( ) . next ( ) ; } } 
public static < T extends TYPE_1 > T METHOD_1 ( final T msg ) { <START> return TYPE_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( msg ) ) ; <END> } 
public boolean contains ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> logger . info ( STRING_1 + VAR_1 + VAR_2 ) ; <END> return this . cache . containsKey ( VAR_1 . getName ( ) + VAR_2 . getName ( ) ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> TYPE_2 VAR_1 = new TYPE_2 ( new TYPE_3 ( ) ) ; <END> return this . VAR_2 . values ( ) . stream ( ) . map ( VAR_2 - > VAR_1 . METHOD_2 ( VAR_2 ) ) . collect ( Collectors . VAR_3 ( ) ) ; } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 ) { try { logger . debug ( VAR_1 ) ; List < TYPE_2 > VAR_2 = this . VAR_3 . METHOD_2 ( VAR_1 , VAR_3 . METHOD_3 ( ) . METHOD_4 ( List . VAR_4 , TYPE_3 . VAR_4 ) ) ; this . VAR_5 . METHOD_5 ( VAR_2 ) ; } catch ( Exception e ) { <START> e . VAR_6 ( ) ; <END> throw new TYPE_4 ( TYPE_5 . VAR_8 , STRING_1 , e ) ; } return new TYPE_1 ( STRING_2 , TYPE_5 . VAR_9 ) ; } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { if ( VAR_1 ) { METHOD_2 ( VAR_2 . METHOD_3 ( ) , VAR_2 . METHOD_4 ( ) ) ; <START> if ( ! VAR_2 . METHOD_5 ( ) ) { <END> VAR_3 . METHOD_6 ( VAR_2 ) ; } } } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( ) ; TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( TYPE_4 . METHOD_4 ( VAR_2 ) ) { TYPE_5 session = VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) ; TYPE_6 VAR_3 = ( TYPE_6 ) session . VAR_4 ( VAR_5 ) ; <START> int n = 0 ; <END> if ( VAR_3 != null ) { return TYPE_7 . METHOD_7 ( TYPE_8 . METHOD_8 ( ) , VAR_3 , true ) ; } } return TYPE_7 . METHOD_7 ( true ) ; } 
protected void METHOD_1 ( TYPE_1 in , TYPE_2 out , String VAR_1 , String type ) throws IOException { try { if ( TYPE_3 . equals ( type ) ) { VAR_2 . METHOD_2 ( VAR_1 , in , out ) ; } else if ( TYPE_4 . equals ( type ) ) { VAR_3 . METHOD_3 ( VAR_1 , in , out ) ; } else { throw new TYPE_5 ( STRING_1 + VAR_1 ) ; } } catch ( TYPE_5 e ) { <START> throw new RuntimeException ( e ) ; <END> } } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( ) ; <START> return new TYPE_3 ( VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; <END> } 
public < T > T getValue ( final TYPE_1 VAR_1 ) { if ( config != null && config . containsKey ( VAR_1 . getKey ( ) ) ) <START> return ( T ) config . get ( VAR_1 . getKey ( ) ) ; <END> return VAR_1 . getValue ( ) ; } 
public TYPE_1 METHOD_1 ( ) { try { return VAR_1 ; } catch ( RuntimeException e ) { throw METHOD_2 ( e ) ; } catch ( TYPE_2 e ) { throw METHOD_2 ( e ) ; } catch ( Throwable t ) { throw METHOD_2 ( t ) ; <START> } <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , Exception e ) { TYPE_2 . instance ( ) . debug ( this , STRING_1 , e , VAR_1 . getId ( ) ) ; <START> METHOD_2 ( VAR_1 ) ; <END> if ( e instanceof TYPE_3 ) throw ( ( TYPE_3 ) e ) ; else throw TYPE_3 . METHOD_3 ( new TYPE_4 ( STRING_2 ) , e ) ; } 
<START> private int METHOD_1 ( byte [ ] buffer , int VAR_1 ) { <END> int VAR_2 ; if ( VAR_3 - VAR_4 < buffer . length - VAR_1 ) { VAR_2 = ( int ) ( VAR_3 - VAR_4 ) ; } else { VAR_2 = buffer . length - VAR_1 ; } int i ; for ( i = 0 ; i < VAR_2 ; i += INT_1 ) { METHOD_2 ( buffer , i + VAR_1 ) ; } VAR_4 += VAR_2 ; return VAR_2 + VAR_1 ; } 
<START> T METHOD_1 ( List < String > input , Set < String > VAR_1 , T result ) { <END> if ( input == null ) { return result ; } for ( int i = 1 ; i < input . size ( ) ; i += 2 ) { if ( VAR_1 == null || VAR_1 . contains ( input . get ( i ) ) ) { result . put ( input . get ( i ) , new TYPE_1 ( input . get ( i + 1 ) ) ) ; } } return result ; } 
public void METHOD_1 ( String table ) throws IOException { final TYPE_1 VAR_1 = TYPE_1 . valueOf ( table ) ; <START> synchronized ( VAR_2 ) { <END> this . VAR_3 = connection . VAR_4 ( VAR_1 ) ; if ( VAR_5 ) { final TYPE_2 p = new TYPE_2 ( VAR_1 ) ; p . VAR_6 ( VAR_6 ) ; this . VAR_7 = connection . VAR_8 ( p ) ; } } } 
<START> private String METHOD_1 ( long VAR_1 ) { <END> if ( ! VAR_2 ) { VAR_1 = Utils . VAR_3 ( VAR_1 ) ; } String value = Long . toString ( VAR_1 ) ; int VAR_4 = VAR_5 - value . length ( ) ; String VAR_6 = STRING_1 ; for ( int i = 0 ; i < VAR_4 ; i ++ ) { VAR_6 += CHAR_1 ; } return VAR_6 + value ; } 
public void run ( ) { try { Thread . VAR_1 ( VAR_2 ) ; this . VAR_3 . METHOD_1 ( true ) ; } catch ( InterruptedException e ) { <START> byte a = 0 ; <END> } } 
private int METHOD_1 ( Exception e , String url , String method ) { if ( VAR_1 ) { <START> System . out . println ( new StringBuilder ( method ) . append ( STRING_1 ) . append ( url ) . append ( STRING_2 ) <END> . append ( e . getClass ( ) . getName ( ) ) . append ( STRING_3 ) . append ( e . getMessage ( ) ) . toString ( ) ) ; } if ( e instanceof TYPE_1 ) { return INT_1 ; } return INT_2 ; } 
public Status METHOD_1 ( String table , String VAR_1 ) { int VAR_2 ; try { VAR_2 = METHOD_2 ( VAR_3 + VAR_1 ) ; } catch ( Exception e ) { VAR_2 = METHOD_3 ( e , VAR_3 + VAR_1 , TYPE_1 . VAR_5 ) ; } if ( VAR_6 ) { <START> System . out . println ( new StringBuilder ( STRING_1 ) . append ( VAR_3 ) . append ( VAR_1 ) <END> . append ( STRING_2 ) . append ( VAR_2 ) . toString ( ) ) ; } return getStatus ( VAR_2 ) ; } 
public static int METHOD_1 ( ) { <START> return ( int ) METHOD_2 ( ) / INT_1 / INT_1 ; <END> } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> return db ; } 
public void METHOD_1 ( ) throws TYPE_1 { try { client . close ( ) ; <START> } catch ( IOException e ) { <END> e . VAR_1 ( ) ; } } 
public void METHOD_1 ( ) { try { VAR_1 = new TYPE_1 ( ) ; TYPE_2 p = new TYPE_2 ( ) ; p . VAR_2 ( STRING_1 , VAR_3 ) ; VAR_1 . METHOD_2 ( p ) ; VAR_1 . METHOD_3 ( ) ; VAR_4 = new TYPE_3 ( VAR_3 ) . METHOD_4 ( STRING_2 , STRING_2 ) ; VAR_5 = VAR_4 . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) ; <START> } catch ( TYPE_4 e ) { <END> e . VAR_6 ( ) ; METHOD_8 ( STRING_3 ) ; } } 
public synchronized String METHOD_1 ( ) { try { return VAR_1 = reader . VAR_2 ( ) ; } catch ( TYPE_1 e ) { System . err . println ( STRING_1 + VAR_3 + CHAR_1 + VAR_1 ) ; throw e ; } catch ( IOException e ) { <START> throw new RuntimeException ( e ) ; } <END> } 
@Override public int METHOD_1 ( ) { <START> return VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_1 . VAR_8 ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 . assertThat ( VAR_1 . VAR_2 ) . METHOD_2 ( ) ; <END> TYPE_2 . assertThat ( VAR_1 . VAR_3 ) . METHOD_2 ( ) ; TYPE_2 . assertThat ( VAR_1 . VAR_4 ) . METHOD_2 ( ) ; } 
ANNOTATION_1 public void METHOD_1 ( ) { final TYPE_1 source = TYPE_2 . METHOD_2 ( STRING_1 , <START> TYPE_3 . METHOD_3 ( CHAR_1 ) . METHOD_4 ( <END> STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , STRING_8 ) ) ; TYPE_4 . METHOD_5 ( METHOD_6 ( ) ) . that ( source ) . METHOD_7 ( METHOD_8 ( ) ) . METHOD_9 ( ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return new TYPE_1 ( ) { @Override public Object get ( TYPE_2 VAR_1 , TYPE_3 < ? > VAR_2 ) { if ( VAR_2 == VAR_3 ) { return TYPE_5 . this ; } else { return super . get ( VAR_1 , VAR_2 ) ; } } @Override public void METHOD_2 ( TYPE_2 VAR_1 ) { TYPE_4 < ? > VAR_5 = VAR_1 . get ( TYPE_4 . VAR_6 ) ; if ( VAR_5 != null ) { VAR_5 . METHOD_3 ( TYPE_5 . VAR_7 ) ; } } } ; } 
public TYPE_2 ( final long VAR_2 , TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; <START> VAR_4 = VAR_3 ; <END> length = 0 ; VAR_5 = 0 ; VAR_6 = 0 ; VAR_7 = 0 ; update ( ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 s = r . VAR_1 . METHOD_2 ( TYPE_1 . class , STRING_1 ) ; <START> s . VAR_2 ( new TYPE_2 ( STRING_2 ) ) ; <END> s . VAR_3 ( new TYPE_2 ( STRING_2 ) ) ; assertEquals ( 0 , s . VAR_4 ( ) . size ( ) ) ; } 
public synchronized TYPE_1 METHOD_1 ( ) throws IOException , TYPE_2 { TYPE_3 e = TYPE_3 . of ( this ) ; if ( e == null ) { for ( TYPE_4 c : TYPE_5 . METHOD_2 ( ) . METHOD_3 ( ) ) { <START> for ( TYPE_3 VAR_1 : c . VAR_2 ( ) ) { <END> if ( VAR_1 . METHOD_4 ( ) == this ) e = VAR_1 ; } } } if ( e != null ) { return e . VAR_3 ( ) ; } else { return TYPE_6 . METHOD_5 ( ) ; } } 
public void METHOD_1 ( TYPE_1 item , String VAR_1 , String VAR_2 ) throws IOException { VAR_3 . remove ( VAR_1 ) ; <START> VAR_3 . put ( VAR_2 , ( TYPE_1 ) item ) ; <END> for ( View v : VAR_4 ) { v . VAR_5 ( item , VAR_1 , VAR_2 ) ; } METHOD_2 ( ) ; } 
protected TYPE_1 METHOD_1 ( String url ) throws IOException { TYPE_2 VAR_1 ; try { VAR_1 = new TYPE_2 ( url ) ; } catch ( TYPE_3 e ) { <START> throw new IOException ( STRING_1 + url ) ; <END> } TYPE_1 connection = ( TYPE_1 ) VAR_1 . METHOD_1 ( ) ; connection . VAR_2 ( VAR_3 ) ; connection . VAR_4 ( VAR_5 ) ; connection . VAR_6 ( STRING_2 , STRING_3 ) ; connection . VAR_6 ( STRING_4 , VAR_7 ) ; connection . VAR_8 ( true ) ; return connection ; } 
@Override public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IllegalStateException { if ( ! METHOD_2 ( STRING_1 ) ) { throw new IllegalStateException ( STRING_2 ) ; } <START> VAR_3 = VAR_2 . METHOD_3 ( STRING_3 , true ) ; <END> TYPE_3 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_2 . getString ( STRING_4 ) , VAR_2 . getString ( STRING_5 ) ) ; TYPE_4 VAR_4 = VAR_1 . METHOD_6 ( ) ; TYPE_3 . METHOD_7 ( VAR_4 == VAR_5 || VAR_4 == VAR_6 ) ; } 
@Override void METHOD_1 ( Context context , TYPE_1 VAR_1 ) throws TYPE_2 { if ( ! METHOD_2 ( context , TYPE_4 . VAR_3 . VAR_4 ) ) { throw new TYPE_2 ( STRING_1 ) ; } TYPE_3 . METHOD_3 ( VAR_1 . getString ( STRING_2 ) ) ; <START> TYPE_3 . METHOD_4 ( VAR_1 . METHOD_5 ( STRING_3 ) ) ; <END> this . context = context ; } 
public String METHOD_1 ( final TYPE_1 VAR_1 ) { <START> if ( this . VAR_2 != null ) { <END> final TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( this . VAR_2 . getId ( ) ) ; if ( VAR_3 != null && ! TYPE_3 . isEmpty ( VAR_3 . getName ( ) ) ) { return VAR_3 . getName ( ) ; } else { return this . name ; } } else { return this . name ; } } 
protected void METHOD_1 ( boolean result , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws Throwable { if ( result ) { <START> new TYPE_3 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) , VAR_3 , false ) <END> . METHOD_4 ( VAR_2 ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( this . VAR_1 != VAR_1 ) { VAR_2 . set ( false ) ; <START> VAR_3 . clear ( ) ; <END> VAR_4 . clear ( ) ; } this . VAR_1 = VAR_1 ; return this ; } 
<START> private TYPE_3 ( ) <END> { this . VAR_2 = new TYPE_1 < String , TYPE_2 > ( ) ; this . VAR_3 = null ; this . VAR_4 = null ; this . VAR_5 = new HashMap < String , TYPE_2 > ( ) ; this . VAR_6 = new HashMap < String , Integer > ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == null ) <END> { TYPE_2 configuration = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_2 < ? > conf = configuration . VAR_2 ( new TYPE_4 ( ) ) ; VAR_1 = new TYPE_5 ( conf . VAR_3 ( ) ) ; } return VAR_1 ; } 
@Override public void METHOD_1 ( ) { <START> METHOD_1 ( TYPE_1 . VAR_2 ) ; <END> } 
public TYPE_8 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_3 ; this . VAR_5 = new TYPE_3 < TYPE_4 , TYPE_5 > ( ) ; this . VAR_6 = new TYPE_3 < Object , Map < TYPE_5 , TYPE_6 > > ( ) ; this . VAR_7 = new TYPE_7 ( VAR_4 . METHOD_1 ( ) ) ; <START> this . VAR_8 = VAR_3 . METHOD_2 ( ) ; <END> } 
public synchronized void METHOD_1 ( ) { <START> VAR_1 . set ( true ) ; <END> for ( TYPE_1 VAR_2 : VAR_3 . values ( ) ) VAR_2 . METHOD_1 ( ) ; VAR_3 . clear ( ) ; } 
public TYPE_1 METHOD_1 ( Integer VAR_1 , Integer VAR_2 , Integer VAR_3 , Boolean VAR_4 , Boolean VAR_5 , TYPE_2 VAR_6 ) throws Exception { VAR_7 = new TYPE_3 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , <START> VAR_5 , VAR_6 , false , null , TYPE_4 . VAR_9 , null ) ; <END> return this ; } 
public TYPE_1 METHOD_1 ( Integer VAR_1 , Integer VAR_2 , Integer VAR_3 , Boolean VAR_4 , Boolean VAR_5 , TYPE_2 VAR_6 , Boolean VAR_7 , Boolean VAR_8 , Boolean VAR_9 , Boolean VAR_10 , Boolean VAR_11 ) throws Exception { VAR_12 = new TYPE_3 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , <START> VAR_10 , VAR_11 , false , null , TYPE_4 . VAR_14 , null ) ; <END> return this ; } 
public void METHOD_1 ( ) { METHOD_2 ( null ) ; METHOD_3 ( null ) ; METHOD_4 ( null ) ; METHOD_5 ( null ) ; METHOD_6 ( null ) ; METHOD_7 ( null ) ; if ( METHOD_8 ( ) != null ) { METHOD_8 ( ) . METHOD_1 ( ) ; } <START> METHOD_9 ( null ) ; <END> METHOD_10 ( ) ; } 
private static void METHOD_1 ( final TYPE_1 request , final TYPE_2 VAR_1 ) { final TYPE_3 session = request . VAR_2 ( ) ; session . VAR_3 ( VAR_4 , VAR_1 . METHOD_2 ( ) ) ; session . VAR_3 ( VAR_5 , VAR_1 . METHOD_3 ( ) ) ; <START> } <END> 
static void METHOD_1 ( final TYPE_1 session ) { final String VAR_1 = ( String ) session . VAR_2 ( VAR_3 ) ; <START> final TYPE_2 VAR_4 = TYPE_2 . METHOD_2 ( VAR_1 ) ; <END> final TYPE_3 user = VAR_4 . METHOD_3 ( ) ; if ( user != null && TYPE_4 . METHOD_4 ( user ) ) { VAR_5 . set ( VAR_4 ) ; } else { clear ( ) ; } } 
private boolean METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( 0 ) ; return VAR_1 != null && VAR_1 . equals ( VAR_2 . METHOD_3 ( 0 ) ) && VAR_1 . METHOD_4 ( METHOD_5 ( ) ) <START> . METHOD_6 ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 user , TYPE_2 VAR_1 ) { String VAR_2 = TYPE_3 . getString ( VAR_1 , STRING_1 ) ; if ( TYPE_4 . METHOD_2 ( VAR_2 ) ) { <START> throw TYPE_5 . METHOD_3 ( ) ; <END> } String VAR_3 = TYPE_3 . getString ( VAR_1 , STRING_2 ) ; if ( ! TYPE_6 . equals ( VAR_2 , VAR_3 ) ) { throw TYPE_5 . METHOD_4 ( ) ; } if ( user . VAR_4 ( VAR_2 ) ) { throw TYPE_5 . METHOD_5 ( ) ; } user . VAR_5 ( VAR_2 ) ; } 
public void METHOD_1 ( View v ) { if ( v . getId ( ) == R . id . VAR_1 ) { TYPE_1 task = new TYPE_1 ( ) ; METHOD_2 ( ) . METHOD_3 ( task ) ; <START> task . execute ( ) ; <END> } } 
public void METHOD_1 ( ) throws Exception { <START> Assert . assertEquals ( STRING_1 , VAR_1 . METHOD_2 ( ) ) ; <END> } 
private Boolean METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_1 { String VAR_3 = VAR_4 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <START> if ( STRING_1 . equals ( VAR_3 ) ) { <END> return true ; } return VAR_5 . METHOD_1 ( VAR_1 , VAR_3 ) ; } 
<START> private long METHOD_1 ( boolean VAR_1 , String VAR_2 ) throws TYPE_1 { <END> long VAR_3 = Long . VAR_4 ( VAR_2 ) ; try { VAR_5 . METHOD_2 ( VAR_3 ) ; } catch ( TYPE_2 e ) { if ( VAR_1 ) { return - INT_1 ; } else { throw e ; } } return VAR_3 ; } 
protected TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( ) { if ( VAR_1 == null ) { throw new TYPE_4 ( STRING_1 ) ; } if ( VAR_2 == null ) { <START> logger . info ( STRING_2 ) ; <END> } if ( VAR_3 == null ) { VAR_3 = VAR_4 . create ( VAR_2 , VAR_1 ) ; } return VAR_3 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { return ( VAR_1 . METHOD_2 ( ) . equals ( TYPE_1 . TYPE_2 . VAR_3 ) || VAR_1 . METHOD_2 ( ) . equals ( TYPE_1 . TYPE_2 . VAR_4 ) ) ; <START> } <END> 
public TYPE_1 < ? > METHOD_1 ( ANNOTATION_1 Long VAR_1 ) { <START> TYPE_2 project = new TYPE_2 ( ) ; <END> project . VAR_2 ( VAR_1 ) ; VAR_3 . METHOD_2 ( project ) ; return TYPE_1 . METHOD_3 ( ) . build ( ) ; } 
private void METHOD_1 ( String VAR_1 ) { if ( VAR_1 . equals ( this . VAR_1 ) ) { return ; } this . VAR_1 = VAR_1 ; TYPE_1 VAR_2 = new TYPE_1 ( <START> VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) , <END> TYPE_2 . of ( TYPE_1 . TYPE_4 . VAR_5 ) ) ; TYPE_3 VAR_6 = VAR_3 . METHOD_4 ( new HashSet < String > ( Arrays . asList ( VAR_1 ) ) , VAR_2 ) ; METHOD_5 ( VAR_6 ) ; METHOD_6 ( VAR_6 ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; Map < String , Set < String > > VAR_3 = VAR_2 . METHOD_3 ( ) ; TYPE_1 VAR_4 = new TYPE_1 ( ) ; <START> VAR_4 . METHOD_4 ( VAR_1 ) ; <END> VAR_4 . METHOD_5 ( VAR_3 ) ; return VAR_4 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { switch ( VAR_2 ) { case VAR_3 : METHOD_2 ( VAR_1 ) ; break ; case VAR_4 : METHOD_3 ( VAR_1 ) ; break ; default : <START> TYPE_2 . METHOD_4 ( STRING_1 , STRING_2 + VAR_2 + STRING_3 ) ; <END> } } 
<START> private static TYPE_1 of ( List < String > values ) { <END> return new TYPE_1 ( values ) ; } 
<START> public static TYPE_1 of ( String ... values ) { <END> List < String > list = TYPE_2 . METHOD_1 ( values ) ; return new TYPE_1 ( list ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; <START> METHOD_2 ( this . VAR_1 . METHOD_3 ( ) ) ; <END> } 
<START> public synchronized List < TYPE_1 > METHOD_1 ( ) { <END> List < TYPE_2 > VAR_1 = ( List < TYPE_2 > ) ( VAR_2 . METHOD_2 ( STRING_1 ) ) . METHOD_3 ( ) ; List < TYPE_1 > VAR_3 = new ArrayList < TYPE_1 > ( ) ; if ( ! VAR_1 . isEmpty ( ) ) { for ( TYPE_2 VAR_4 : VAR_1 ) { VAR_3 . add ( new TYPE_1 ( VAR_4 . getName ( ) , VAR_4 . METHOD_4 ( ) ) ) ; } } return VAR_3 ; } 
<START> <END> <END> private <END> <END> TYPE_1 METHOD_1 <END> <END> ( <END> String <END> url <END> ) { <END> TYPE_1 <END> VAR_1 <END> = VAR_2 <END> . <END> get <END> ( url <END> ) <END> ; <END> if <END> ( VAR_1 == <END> <END> <END> null <END> ) 
private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { return VAR_1 != null && VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) && VAR_1 . METHOD_2 ( ) . toString ( ) . startsWith ( VAR_2 == null ? "" : VAR_2 ) && TYPE_2 . contains ( VAR_1 . METHOD_4 ( ) . toString ( ) ) <START> & ! ( VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 event , TYPE_2 entity ) { VAR_1 = new TYPE_3 ( VAR_2 ) ; <START> VAR_3 = new TYPE_4 ( ) ; <END> TYPE_2 VAR_4 = event . VAR_5 ( ) ; if ( ! METHOD_2 ( entity , VAR_4 ) ) { METHOD_3 ( entity , VAR_4 ) ; METHOD_4 ( VAR_4 ) ; } } 
public void METHOD_1 ( ) { for ( TYPE_1 entity : VAR_1 . METHOD_2 ( TYPE_2 . class ) ) { <START> VAR_2 = entity ; <END> VAR_3 = VAR_2 . METHOD_3 ( TYPE_2 . class ) ; } if ( ! VAR_2 . equals ( TYPE_1 . VAR_4 ) ) { VAR_5 = METHOD_4 ( STRING_1 , TYPE_3 . class ) ; VAR_5 . METHOD_5 ( new TYPE_4 < String > ( ) { @Override public String get ( ) { return String . valueOf ( VAR_3 . VAR_6 ) ; } } ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . get ( TYPE_1 . class ) ; VAR_2 = TYPE_3 . builder ( VAR_1 ) . METHOD_2 ( TYPE_4 . VAR_4 , STRING_1 ) . METHOD_2 ( TYPE_4 . VAR_5 , STRING_2 ) . METHOD_2 ( TYPE_4 . VAR_6 , STRING_3 ) . build ( ) ; <START> VAR_7 = TYPE_2 . get ( TYPE_1 . class ) . METHOD_3 ( STRING_4 ) ; <END> VAR_8 = TYPE_2 . get ( TYPE_1 . class ) . METHOD_3 ( STRING_5 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . class ) . METHOD_3 ( 0 , INT_1 , 4 ) ; <END> TYPE_3 VAR_3 = new TYPE_3 ( VAR_1 . METHOD_4 ( ) , VAR_2 ) ; for ( TYPE_4 VAR_4 : VAR_5 ) { VAR_3 . add ( VAR_4 ) ; } VAR_1 . METHOD_5 ( TYPE_3 . class , VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . class ) . METHOD_3 ( 0 , 0 , 0 ) ; <END> TYPE_3 VAR_3 = new TYPE_3 ( VAR_1 . METHOD_4 ( ) , VAR_2 ) ; for ( TYPE_4 VAR_4 : VAR_5 ) { VAR_3 . add ( VAR_4 ) ; } VAR_1 . METHOD_5 ( TYPE_3 . class , VAR_3 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = new Date ( ) ; <END> try { VAR_2 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; } catch ( TYPE_2 e ) { } } 
public void METHOD_1 ( Object entity , TYPE_1 id , Object [ ] state , String [ ] VAR_1 , Type [ ] VAR_2 ) { if ( entity instanceof TYPE_2 ) { TYPE_2 VAR_3 = ( TYPE_2 ) entity ; <START> TYPE_3 output = new TYPE_3 ( VAR_3 . METHOD_2 ( ) , TYPE_4 . VAR_5 ) ; <END> METHOD_3 ( STRING_1 , output ) ; } super . METHOD_1 ( entity , id , state , VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 context ) { TYPE_3 VAR_1 = context . VAR_2 ( VAR_3 ) . METHOD_2 ( ) ; VAR_1 . add ( STRING_1 , VAR_1 . remove ( STRING_2 ) ) ; if ( VAR_3 . METHOD_3 ( ) != null ) { <START> VAR_1 . remove ( STRING_3 ) ; <END> VAR_1 . add ( STRING_4 , context . VAR_2 ( new TYPE_4 ( VAR_3 . METHOD_3 ( ) ) ) ) ; } VAR_1 . add ( STRING_5 , context . VAR_2 ( VAR_4 ) ) ; return VAR_1 ; } 
public String METHOD_1 ( ) { <START> return entry ; <END> } 
public TYPE_3 ( String type , TYPE_1 VAR_2 , String VAR_3 ) { this . type = TYPE_2 . METHOD_1 ( type ) ; <START> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 ) . getName ( ) ; <END> this . VAR_3 = VAR_3 ; } 
<START> public TYPE_1 < ? > METHOD_1 ( TYPE_2 request , <END> ANNOTATION_1 ( value = STRING_1 , VAR_1 = false ) Integer VAR_2 ) throws IOException { TYPE_3 VAR_3 = METHOD_2 ( request , VAR_2 ) ; TYPE_4 input = METHOD_3 ( request , TYPE_4 . class ) ; TYPE_5 VAR_4 = VAR_5 . METHOD_1 ( VAR_3 , input . VAR_6 ( ) ) ; return METHOD_4 ( VAR_4 . toString ( ) ) ; } 
private void METHOD_1 ( TYPE_1 id , boolean VAR_1 ) { boolean VAR_2 = false ; try { VAR_3 . METHOD_2 ( id ) ; } catch ( TYPE_5 . TYPE_6 VAR_4 ) { VAR_2 = true ; } catch ( TYPE_3 VAR_5 ) { <START> VAR_2 = true ; <END> } catch ( TYPE_4 e ) { throw e ; } assertEquals ( VAR_2 , ! VAR_1 , ( VAR_1 ? STRING_1 : STRING_2 ) ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) throws IOException { try ( TYPE_2 stream = VAR_3 . METHOD_2 ( VAR_1 . toString ( ) ) ) { assertNotNull ( stream ) ; assertTrue ( VAR_2 ) ; } catch ( TYPE_6 . TYPE_7 VAR_4 ) { METHOD_3 ( VAR_2 ) ; } catch ( TYPE_4 VAR_5 ) { <START> METHOD_3 ( VAR_2 ) ; <END> } catch ( TYPE_5 e ) { throw e ; } } 
public List < String > METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { ArrayList < String > VAR_2 = new ArrayList < > ( ) ; VAR_2 . add ( STRING_1 ) ; <START> return VAR_2 ; <END> } 
String METHOD_1 ( Response response ) { try { if ( response . VAR_1 ( ) != null ) return response . VAR_2 ( ) ; if ( response . VAR_3 ( ) . size ( ) > 0 ) return response . VAR_3 ( ) . get ( 0 ) ; } catch ( Exception e ) { <START> return null ; <END> } return null ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 > VAR_2 , TYPE_3 t ) throws IOException { <END> for ( final TYPE_2 VAR_3 : VAR_2 ) { if ( VAR_3 == null ) { LOGGER . VAR_4 ( STRING_1 + t ) ; continue ; } TYPE_4 c = VAR_3 . METHOD_2 ( ) ; if ( VAR_3 . METHOD_3 ( ) && c != null ) { c . VAR_5 ( false ) ; } VAR_1 . METHOD_4 ( VAR_3 ) ; } } 
public TYPE_1 ( boolean VAR_2 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = "" ; <START> this . VAR_4 = false ; this . VAR_5 = 0 ; <END> } 
private void METHOD_1 ( boolean VAR_1 ) throws TYPE_1 { <START> return METHOD_1 ( VAR_1 , INT_1 ) ; <END> } 
public TYPE_1 < TYPE_2 < ? > , TYPE_3 > METHOD_1 ( ) { <START> return TYPE_4 . METHOD_2 ( VAR_1 ) ; <END> } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 ) { TYPE_1 VAR_2 ; if ( VAR_1 != null ) { VAR_2 = TYPE_3 . METHOD_2 ( TYPE_1 . class , VAR_1 ) ; } else { <START> VAR_2 = TYPE_3 . METHOD_2 ( TYPE_1 . class ) ; <END> METHOD_3 ( VAR_2 ) ; METHOD_4 ( VAR_2 ) ; METHOD_5 ( VAR_2 ) ; METHOD_6 ( VAR_2 ) ; METHOD_7 ( VAR_2 ) ; METHOD_8 ( VAR_2 ) ; METHOD_9 ( VAR_2 ) ; METHOD_10 ( VAR_2 ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { return VAR_2 ? TYPE_1 . VAR_3 : TYPE_1 . VAR_4 ; } <START> return VAR_1 ; <END> } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = ( TYPE_1 ) TYPE_2 . get ( ) . METHOD_2 ( STRING_1 ) ; assertNotNull ( VAR_1 ) ; <START> assertEquals ( VAR_1 . METHOD_3 ( ) . size ( ) , 0 ) ; <END> } 
public TYPE_3 ( String host , String VAR_2 , String VAR_3 ) { this . host = host ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = new TYPE_1 ( ) ; <START> this . VAR_5 = new TYPE_2 ( VAR_2 , VAR_3 . METHOD_1 ( ) , null ) ; ; <END> } 
private static void METHOD_1 ( int VAR_1 ) { <START> TYPE_1 . VAR_1 = INT_1 ; <END> } 
public int METHOD_1 ( ) { if ( StringUtils . isEmpty ( VAR_1 ) || Integer . parseInt ( VAR_1 ) <= 0 ) <START> VAR_1 = "" + Integer . VAR_2 ; <END> return Integer . parseInt ( VAR_1 ) ; } 
public static Integer get ( final String key ) { <START> if ( key == null ) { <END> return R . VAR_1 . VAR_2 ; } return map . containsKey ( key . VAR_3 ( TYPE_1 . METHOD_1 ( ) ) ) ? map . get ( key . VAR_3 ( ) ) : R . VAR_1 . VAR_2 ; } 
public void METHOD_1 ( ) { <START> if ( ! VAR_1 ) { <END> if ( METHOD_2 ( ) ) { METHOD_3 ( false ) ; } } if ( VAR_2 . METHOD_4 ( ) != VAR_2 . METHOD_5 ( ) ) { VAR_2 . METHOD_6 ( ) ; return ; } super . METHOD_1 ( ) ; } 
public void METHOD_1 ( TYPE_1 event ) { <START> Log . d ( STRING_1 , getClass ( ) . METHOD_2 ( ) + STRING_2 ) ; <END> METHOD_3 ( ) ; } 
<START> public Object METHOD_1 ( int position ) { <END> return VAR_1 . get ( position ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , File VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 , String VAR_6 , boolean VAR_7 ) throws IOException { TYPE_3 data = new TYPE_3 ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ) ; TYPE_1 VAR_8 = METHOD_1 ( VAR_1 , data , VAR_3 , VAR_4 , VAR_5 ) ; if ( VAR_7 ) { <START> VAR_2 . METHOD_4 ( ) ; <END> } return VAR_8 ; } 
private TYPE_1 METHOD_1 ( ) { if ( METHOD_2 ( TYPE_5 . TYPE_3 ) ) { TYPE_1 result = ( TYPE_1 ) METHOD_3 ( TYPE_5 . TYPE_3 ) ; <START> if ( METHOD_4 ( TYPE_5 . TYPE_6 ) ) { <END> String VAR_4 = METHOD_5 ( TYPE_5 . TYPE_6 ) ; result = TYPE_2 . METHOD_6 ( result , VAR_4 ) ; } if ( result != null ) { return result ; } } return TYPE_1 . TYPE_4 ; } 
public TYPE_1 apply ( ANNOTATION_1 TYPE_1 node ) { for ( TYPE_2 VAR_1 : VAR_2 ) { if ( ! VAR_1 . METHOD_1 ( node ) ) { return VAR_1 . apply ( node ) ; } } for ( TYPE_2 VAR_1 : VAR_2 ) { node = VAR_1 . apply ( node ) ; if ( METHOD_2 ( node ) ) <START> return METHOD_3 ( node ) ; <END> } return METHOD_3 ( node ) ; } 
public TYPE_1 METHOD_1 ( ) { return super . METHOD_1 ( ) . METHOD_2 ( METHOD_3 ( ) ) . METHOD_2 ( METHOD_4 ( ) ) . METHOD_2 ( METHOD_5 ( ) ) . METHOD_2 ( METHOD_6 ( ) ) <START> . METHOD_2 ( METHOD_7 ( TYPE_2 . VAR_2 , TYPE_2 . VAR_3 ) ) ; <END> } 
protected static TYPE_1 [ ] METHOD_1 ( TYPE_2 [ ] VAR_1 ) { TYPE_1 [ ] VAR_2 = new TYPE_1 [ VAR_1 . length ] ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <START> VAR_2 [ i ] = METHOD_2 ( VAR_1 [ 0 ] ) ; <END> } return VAR_2 ; } 
public TYPE_1 ( final String VAR_2 ) { <START> this . TYPE_2 = VAR_2 ; <END> } 
<START> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { <END> TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( STRING_1 ) ; VAR_2 . METHOD_3 ( STRING_2 ) ; VAR_2 . METHOD_4 ( STRING_3 ) ; return new TYPE_1 ( VAR_2 ) ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <END> TYPE_2 item = VAR_1 . METHOD_2 ( VAR_2 ) ; item . VAR_3 ( false ) ; item . VAR_4 ( false ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <START> TYPE_2 item = VAR_1 . METHOD_2 ( VAR_2 ) ; <END> item . VAR_3 ( true ) ; item . VAR_4 ( true ) ; } 
<START> public static long [ ] METHOD_1 ( int [ ] source ) { <END> long [ ] VAR_1 = new long [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { VAR_1 [ i ] = source [ i ] ; } return VAR_1 ; } 
public TYPE_4 ( final TYPE_1 VAR_2 , final TYPE_2 next ) { this . VAR_2 = VAR_2 ; this . next = next ; VAR_3 = new TYPE_3 ( ) { @Override public void run ( ) { <START> LOG . info ( STRING_1 ) ; <END> } } ; } 
public TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . METHOD_5 ( filter ) , TYPE_2 . VAR_2 ) <START> . METHOD_4 ( TYPE_3 . METHOD_5 ( VAR_3 . METHOD_6 ( ) ) , TYPE_2 . VAR_2 ) <END> . METHOD_7 ( ) ; return VAR_1 ; } 
public void METHOD_1 ( final byte [ ] VAR_1 , final int VAR_2 ) { if ( VAR_3 == 1 ) { VAR_1 [ 0 ] = ( byte ) VAR_2 ; return ; } int VAR_4 = 0 ; for ( int i = 0 ; i <= VAR_3 ; i ++ ) { <START> VAR_1 [ VAR_3 - i ] = 0 ; <END> VAR_1 [ VAR_3 - i ] = ( byte ) ( VAR_2 > > > VAR_4 ) ; VAR_4 += INT_1 ; } } 
public final boolean METHOD_1 ( final String VAR_1 ) { final String val = this . properties . getProperty ( VAR_1 ) . METHOD_2 ( ) ; <START> if ( val == null ) <END> throw new TYPE_1 ( ) ; if ( val . equals ( STRING_1 ) ) return true ; if ( val . equals ( STRING_2 ) ) return true ; if ( val . equals ( STRING_3 ) ) return true ; return false ; } 
private TYPE_1 METHOD_1 ( int VAR_1 , TYPE_2 VAR_2 ) { int VAR_3 = VAR_2 . METHOD_2 ( ) != null ? VAR_2 . METHOD_2 ( ) : 100 ; if ( VAR_3 <= 0 ) { return null ; } TYPE_1 VAR_4 = new TYPE_1 ( ) ; VAR_4 . METHOD_3 ( VAR_1 ) ; VAR_4 . METHOD_4 ( STRING_1 ) ; VAR_4 . METHOD_5 ( STRING_2 ) ; VAR_4 . METHOD_6 ( STRING_3 ) ; <START> VAR_4 . METHOD_7 ( STRING_4 ) ; <END> VAR_4 . METHOD_8 ( VAR_3 ) ; return VAR_4 ; } 
public boolean METHOD_1 ( long VAR_1 , long VAR_2 , int VAR_3 ) { try ( final TYPE_1 session = factory . VAR_4 ( ) ) { int VAR_5 = METHOD_2 ( session ) . METHOD_3 ( VAR_1 , VAR_2 , VAR_3 ) ; if ( VAR_5 != 1 ) { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } } return true ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> if ( VAR_1 == null ) { <END> VAR_1 = TYPE_1 . METHOD_2 ( TYPE_2 . class ) ; } } 
public void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> if ( VAR_1 == null ) { METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_2 . class ) ) ; } } 
private String METHOD_1 ( String name ) { int i = name . VAR_1 ( CHAR_1 ) ; <START> if ( i < 0 || i > name . length ( ) - 1 ) { <END> return null ; } return name . substring ( i + 1 ) ; } 
public void METHOD_1 ( TYPE_1 params ) throws TYPE_2 { <START> <END> log . debug ( STRING_1 ) ; TYPE_3 VAR_1 = METHOD_2 ( - 1 , params , 0 ) ; log . debug ( STRING_2 ) ; TYPE_4 . METHOD_3 ( params , VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( this . VAR_1 == null ) { <START> log . warn ( STRING_1 ) ; <END> if ( this . VAR_2 == null ) { this . METHOD_2 ( ) ; } return this . VAR_2 ; } return this . VAR_1 ; } 
public boolean METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 == null || VAR_1 . length ( ) == 0 ) { <END> return false ; } return VAR_2 . METHOD_2 ( ) . stream ( ) . METHOD_3 ( c - > VAR_1 . equals ( c . VAR_3 ( ) ) ) ; } 
public boolean METHOD_1 ( String format ) { <START> if ( format == null || format . length ( ) == 0 ) { <END> return false ; } return VAR_1 . METHOD_2 ( ) . stream ( ) . METHOD_3 ( f - > format . equals ( f ) ) ; } 
private List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( TYPE_2 < TYPE_1 > it = VAR_1 . METHOD_2 ( ) ; it . hasNext ( ) ; ) { final TYPE_1 VAR_2 = ( TYPE_1 ) it . next ( ) ; <START> METHOD_3 ( VAR_2 ) ; <END> final TYPE_1 VAR_3 = update ( VAR_2 ) ; it . set ( VAR_3 ) ; } return VAR_1 ; } 
public static int METHOD_1 ( String VAR_1 ) { String VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null ) { int VAR_3 = VAR_2 . METHOD_3 ( CHAR_1 ) ; if ( VAR_3 >= 0 ) { return Integer . valueOf ( VAR_2 . substring ( 0 , VAR_3 ) ) ; } } <START> return 0 ; <END> } 
private Set < String > METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { Set < String > VAR_2 = new HashSet < > ( ) ; TYPE_3 VAR_3 = VAR_1 . METHOD_2 ( VAR_4 , null , null , TYPE_4 . METHOD_3 ( VAR_5 ) ) ; while ( VAR_3 . next ( ) ) { VAR_2 . add ( VAR_3 . getString ( STRING_1 ) ) ; } <START> TYPE_5 . METHOD_4 ( VAR_3 ) ; <END> return VAR_2 ; } 
<START> public TYPE_1 value ( final int VAR_1 , final Object value ) { <END> values . set ( VAR_1 , value ) ; return this ; } 
<START> private void METHOD_1 ( TYPE_1 column , String VAR_1 ) { <END> final String VAR_2 = column . VAR_3 ( ) ; if ( VAR_2 == null ) { column . VAR_4 ( VAR_1 ) ; } else { column . VAR_4 ( VAR_2 + STRING_1 + VAR_1 ) ; } } 
public TYPE_1 ( String VAR_2 , char VAR_3 ) { VAR_4 = VAR_2 ; VAR_5 = VAR_3 ; <START> VAR_6 = ( VAR_4 . METHOD_1 ( 0 ) == VAR_5 ) ; <END> VAR_7 = ( VAR_4 . METHOD_1 ( VAR_2 . length ( ) - 1 ) == VAR_5 ) ; } 
public TYPE_1 ( String ... VAR_2 ) { <START> this . VAR_2 = Arrays . asList ( VAR_2 ) ; <END> } 
private static void METHOD_1 ( String VAR_1 , int id , Date VAR_2 ) { try { client . VAR_3 ( VAR_4 , VAR_1 ) . METHOD_2 ( METHOD_3 ( id , VAR_2 ) ) . METHOD_4 ( STRING_1 + VAR_1 + STRING_2 + id ) . execute ( ) . METHOD_5 ( ) ; } catch ( Exception ex ) { <START> System . out . println ( STRING_3 ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 instanceof TYPE_1 ) return ( TYPE_1 ) VAR_1 ; <START> else <END> return null ; } 
protected TYPE_1 METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 == null ) { TYPE_3 VAR_2 = new TYPE_3 ( METHOD_2 ( ) ) ; for ( TYPE_4 VAR_3 : VAR_4 ) { TYPE_5 table = VAR_3 . METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; VAR_2 . METHOD_5 ( table ) ; } <START> VAR_1 = VAR_2 ; <END> } return VAR_1 ; } 
public int METHOD_1 ( ) { int VAR_1 = 1 ; VAR_1 = INT_1 * VAR_1 + this . type . VAR_2 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_2 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_3 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_4 ( ) ; <START> return VAR_1 ; <END> } 
public int METHOD_1 ( ) { long VAR_1 = 1 ; VAR_1 = INT_1 * VAR_1 + Double . VAR_2 ( METHOD_2 ( ) ) ; VAR_1 = INT_1 * VAR_1 + Double . VAR_2 ( METHOD_3 ( ) ) ; VAR_1 = INT_1 * VAR_1 + Double . VAR_2 ( METHOD_4 ( ) ) ; VAR_1 = INT_1 * VAR_1 + Double . VAR_2 ( METHOD_5 ( ) ) ; final int b = ( int ) VAR_1 ; <START> return b ; <END> } 
public int METHOD_1 ( ) { int VAR_1 = 1 ; VAR_1 = INT_1 * VAR_1 + this . VAR_2 ; VAR_1 = INT_1 * VAR_1 + this . VAR_3 ; VAR_1 = INT_1 * VAR_1 + this . VAR_4 ; VAR_1 = INT_1 * VAR_1 + this . VAR_5 ; VAR_1 = INT_1 * VAR_1 + this . VAR_6 ; VAR_1 = INT_1 * VAR_1 + this . VAR_7 ; <START> return VAR_1 ; <END> } 
public int METHOD_1 ( ) { long VAR_1 = 1 ; VAR_1 = INT_1 * VAR_1 + Double . VAR_2 ( this . VAR_3 ) ; VAR_1 = INT_1 * VAR_1 + ( ( this . VAR_4 == null ) ? 0 : this . VAR_4 . METHOD_1 ( ) ) ; final int b = ( int ) VAR_1 ; <START> return b ; <END> } 
public double METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public boolean equals ( Object obj ) { <START> if ( ! super . equals ( obj ) ) { <END> return false ; } final TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( VAR_2 . equals ( VAR_1 . VAR_2 ) ) { return VAR_2 . equals ( VAR_1 . VAR_2 ) ; } return false ; } 
<START> public int METHOD_1 ( ) { <END> int VAR_1 = 1 ; final int VAR_2 = INT_1 ; VAR_1 = VAR_1 * VAR_2 + ( int ) ( VAR_3 . METHOD_1 ( ) ) ; return VAR_1 ; } 
public TYPE_1 [ ] METHOD_1 ( TYPE_1 [ ] VAR_1 ) { if ( this . data == null ) { <START> return ( TYPE_1 [ ] ) TYPE_2 . METHOD_2 ( VAR_1 . getClass ( ) , 0 ) ; <END> } return this . data . VAR_2 ( VAR_1 ) ; } 
public double METHOD_1 ( ) { <START> final double VAR_1 = this . max - ( double ) this . VAR_2 ; <END> if ( VAR_1 == FLOAT_1 ) { return FLOAT_1 ; } return ( this . VAR_3 - this . VAR_2 ) / VAR_1 ; } 
public double METHOD_1 ( ) { <START> final double VAR_1 = this . max - ( double ) this . VAR_2 ; <END> if ( VAR_1 == FLOAT_1 ) { return FLOAT_1 ; } return ( this . VAR_3 - this . VAR_2 ) * FLOAT_2 / VAR_1 ; } 
private void METHOD_1 ( TYPE_1 view , float VAR_1 ) { <START> if ( TYPE_2 . VAR_3 . VAR_4 < INT_1 ) { <END> view . VAR_5 ( ( int ) ( INT_2 * VAR_1 ) ) ; } else { view . VAR_5 ( VAR_1 ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { File VAR_3 = METHOD_2 ( ) ; <START> TYPE_4 VAR_4 = METHOD_3 ( ( ) - > new TYPE_4 ( VAR_3 ) ) ; <END> if ( VAR_3 . exists ( ) ) { return TYPE_1 . METHOD_4 ( VAR_3 , VAR_1 ) ; } return new TYPE_5 ( VAR_1 , VAR_2 , VAR_4 ) ; } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = this . properties . VAR_2 ( ) ; if ( VAR_1 == TYPE_1 . VAR_3 ) { return false ; } <START> return VAR_1 != TYPE_1 . VAR_4 || METHOD_2 ( ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 command ) { <START> return ! ( command instanceof TYPE_2 ) && ! ( command instanceof TYPE_3 ) ; <END> } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_2 VAR_3 : METHOD_2 ( STRING_1 , VAR_1 ) ) { <START> VAR_2 . add ( new TYPE_1 ( METHOD_3 ( STRING_2 , VAR_3 ) , format ( METHOD_4 ( METHOD_3 ( STRING_3 , VAR_3 ) ) ) , <END> METHOD_5 ( VAR_3 ) ) ) ; } return VAR_2 ; } 
default String VAR_1 ( ) { <START> if ( "" . equals ( getPath ( ) ) || STRING_1 . equals ( getPath ( ) ) ) { <END> return STRING_1 ; } if ( getPath ( ) . contains ( STRING_2 ) ) { return getPath ( ) ; } if ( getPath ( ) . VAR_2 ( STRING_1 ) ) { return getPath ( ) + STRING_2 ; } return getPath ( ) + STRING_3 ; } 
default String VAR_1 ( ) { String path = getPath ( ) ; if ( ! path . startsWith ( STRING_1 ) ) { path = STRING_1 + path ; } <START> if ( STRING_1 . equals ( path ) ) { <END> return STRING_2 ; } if ( path . contains ( STRING_3 ) ) { return path ; } if ( path . VAR_2 ( STRING_1 ) ) { return path + STRING_3 ; } return path + STRING_2 ; } 
private void METHOD_1 ( List < ? extends TYPE_1 > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { List < TYPE_2 > VAR_3 = VAR_2 . METHOD_2 ( ) ; for ( TYPE_2 node : new ArrayList < > ( VAR_3 ) ) { <START> if ( STRING_1 . equals ( node . VAR_4 ( ) . METHOD_3 ( ) ) ) { <END> node . VAR_5 ( STRING_2 , new TYPE_3 ( false ) ) ; } } } } 
private void METHOD_1 ( TYPE_1 url ) { <START> if ( STRING_1 . equals ( url . VAR_1 ( ) ) && url . getPath ( ) . METHOD_2 ( STRING_2 ) ) { <END> try { this . VAR_2 . add ( TYPE_2 . METHOD_3 ( url ) ) ; } catch ( Exception ex ) { logger . warn ( TYPE_3 . format ( STRING_3 , url ) ) ; logger . trace ( TYPE_3 . format ( STRING_3 , url ) , ex ) ; } } } 
protected boolean METHOD_1 ( Thread VAR_1 ) { <START> return STRING_1 . equals ( VAR_1 . getName ( ) ) <END> && VAR_1 . METHOD_2 ( ) . getClass ( ) . getName ( ) . contains ( STRING_2 ) ; } 
public void execute ( ) throws TYPE_1 , TYPE_2 { <START> if ( STRING_1 . equals ( this . project . VAR_1 ( ) ) ) { <END> METHOD_1 ( ) . debug ( STRING_2 ) ; return ; } if ( this . VAR_2 ) { METHOD_1 ( ) . debug ( STRING_3 ) ; return ; } METHOD_2 ( ) ; } 
private boolean METHOD_1 ( ) { for ( TYPE_1 method : String . VAR_1 . METHOD_2 ( ) ) { <START> if ( STRING_1 . equals ( method . getName ( ) ) ) { <END> return true ; } } return false ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { String value = VAR_1 . getProperty ( VAR_2 ) ; <START> return ( value != null && ! STRING_1 . equals ( value ) ) ; <END> } 
<START> public int METHOD_1 ( ) { <END> return this . VAR_1 ; } 
public Object METHOD_1 ( TYPE_1 a ) { Object id = super . METHOD_1 ( a ) ; <START> return ( id != null ) ? id : VAR_1 ; <END> } 
public void METHOD_1 ( ) { bind ( STRING_1 ) ; <START> bind ( STRING_2 ) ; <END> METHOD_2 ( ( server ) - > assertThat ( server . VAR_1 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) . METHOD_5 ( - 1 ) ) ; } 
public String METHOD_1 ( ) { <START> return this . VAR_1 . METHOD_1 ( ) == null ? this . VAR_2 : this . VAR_1 . METHOD_1 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 , TYPE_4 VAR_2 ) throws TYPE_5 { String VAR_3 = VAR_2 . getProperty ( VAR_4 , VAR_5 ) ; if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( ) . forEach ( VAR_6 - > { <END> VAR_6 . METHOD_3 ( VAR_3 ) ; } ) ; } return new TYPE_1 ( VAR_3 ) ; } 
void METHOD_1 ( Map < String , TYPE_1 > VAR_1 , TYPE_2 VAR_2 , TYPE_3 < TYPE_4 > VAR_3 ) { <START> List < TYPE_4 > VAR_4 = VAR_3 . METHOD_2 ( ) <END> . collect ( Collectors . VAR_5 ( ) ) ; VAR_1 . forEach ( ( name , VAR_6 ) - > METHOD_3 ( name , VAR_6 , VAR_4 , VAR_2 ) ) ; } 
void METHOD_1 ( ) { this . VAR_1 . METHOD_2 ( TYPE_1 . of ( TYPE_2 . class ) ) . METHOD_3 ( STRING_1 , STRING_2 , <START> STRING_3 , STRING_4 , <END> STRING_5 , STRING_6 + VAR_2 . METHOD_4 ( ) ) . run ( METHOD_5 ( STRING_7 , TYPE_4 . VAR_4 , STRING_8 , TYPE_3 . VAR_6 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_2 . create ( METHOD_2 ( ) , METHOD_3 ( ) ) ; if ( this . properties . VAR_2 ( ) != null <START> && this . properties . VAR_3 ( ) != null ) { <END> return VAR_1 . METHOD_4 ( this . properties . VAR_2 ( ) , this . properties . VAR_3 ( ) ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { if ( this . properties . VAR_1 ( ) . isEmpty ( ) || this . properties . VAR_2 ( ) . isEmpty ( ) ) { <START> return METHOD_2 ( ) . METHOD_3 ( this . properties . VAR_3 ( ) . getName ( ) ) ; <END> } return METHOD_2 ( ) . METHOD_3 ( this . properties . VAR_3 ( ) . getName ( ) , this . properties . VAR_3 ( ) . METHOD_4 ( ) ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_1 ) ; <START> if ( this . VAR_2 ) { <END> if ( ( VAR_1 instanceof TYPE_2 ) ) { METHOD_4 ( VAR_1 ) ; } } else { if ( ! ( VAR_1 instanceof TYPE_2 ) ) { METHOD_4 ( VAR_1 ) ; } } if ( this . VAR_3 && VAR_1 != TYPE_3 . VAR_4 ) { TYPE_3 . METHOD_5 ( VAR_1 ) ; } } 
private TYPE_1 METHOD_1 ( String url ) { try { <START> return new TYPE_1 ( new TYPE_2 ( TYPE_3 . toString ( url , "" ) ) ) ; <END> } catch ( TYPE_4 ex ) { return new TYPE_1 ( url ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> return ( VAR_1 ) - > VAR_1 . METHOD_2 ( INT_1 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 : : new ) . METHOD_2 ( TYPE_3 . of ( TYPE_4 . class ) ) . METHOD_3 ( TYPE_5 . class ) ; VAR_1 . run ( ( context ) - > { TYPE_6 factory = context . VAR_2 ( TYPE_6 . class ) ; <START> assertThat ( factory . VAR_3 ( ) ) . METHOD_4 ( 1 ) ; <END> } ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 config ) { <END> return new TYPE_3 ( config . VAR_1 ( ) ) ; } 
void METHOD_1 ( ) { this . VAR_1 . METHOD_1 ( ) ; if ( this . VAR_2 . METHOD_2 ( ) ) { METHOD_3 ( ) ; } if ( this . VAR_2 . METHOD_4 ( ) ) { <START> try { <END> this . VAR_3 . METHOD_5 ( job ( ) , this . VAR_2 . METHOD_6 ( ) ) ; } catch ( Throwable VAR_4 ) { this . logger . error ( STRING_1 , VAR_4 ) ; } } } 
<START> protected List < String > METHOD_1 ( <END> TYPE_1 VAR_1 ) { List < String > VAR_2 = new ArrayList < > ( Arrays . asList ( VAR_1 . METHOD_2 ( ) ) ) ; String VAR_3 = METHOD_3 ( ) ; if ( VAR_3 != null ) { VAR_2 . add ( VAR_3 ) ; } METHOD_4 ( VAR_1 , VAR_2 ) ; return VAR_2 ; } 
public TYPE_4 ( ) { <START> this . VAR_2 = new TYPE_1 ( false ) ; <END> this . VAR_2 . METHOD_1 ( new TYPE_2 ( TYPE_3 . class ) ) ; this . VAR_2 . METHOD_2 ( STRING_1 ) ; } 
<START> public void METHOD_1 ( ) { <END> this . VAR_1 = this . factory . VAR_2 ( ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return this . VAR_1 ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> TYPE_2 connection = this . VAR_1 . getProperty ( STRING_1 , TYPE_2 . class , TYPE_2 . NONE ) ; if ( TYPE_2 . NONE . equals ( connection ) ) { connection = TYPE_2 . get ( getClass ( ) . METHOD_2 ( ) ) ; } Assert . state ( connection != TYPE_2 . NONE , STRING_2 + STRING_3 + STRING_4 + STRING_5 ) ; return new TYPE_3 ( ) . METHOD_3 ( true ) . METHOD_4 ( connection . getType ( ) ) . build ( ) ; } 
<START> private static synchronized void METHOD_1 ( ) { <END> if ( ! VAR_1 ) { VAR_1 = true ; METHOD_2 ( ) ; } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> VAR_2 . METHOD_1 ( VAR_1 ) ; VAR_3 . METHOD_1 ( VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 map ) { if ( map . VAR_1 ( ) == null ) { return false ; } if ( ( map . VAR_2 ( ) != null && ! METHOD_2 ( map . VAR_2 ( ) ) && ! METHOD_3 ( map . VAR_2 ( ) ) ) || ( map . VAR_3 ( ) != null && ! METHOD_2 ( map . VAR_3 ( ) ) && ! METHOD_3 ( map . VAR_3 ( ) ) ) ) { <START> return map . VAR_4 ( ) != null ; <END> } return true ; } 
private void METHOD_1 ( ) throws InterruptedException { <START> if ( METHOD_2 ( METHOD_3 ( R . id . VAR_1 ) ) == false ) { <END> return ; } METHOD_4 ( ) ; METHOD_5 ( METHOD_6 ( R . id . VAR_2 ) ) . METHOD_7 ( METHOD_8 ( ) ) ; METHOD_9 ( R . string . VAR_3 , VAR_4 ) ; METHOD_10 ( METHOD_6 ( R . id . VAR_5 ) , INT_1 ) ; } 
private void METHOD_1 ( ) { <START> if ( METHOD_2 ( METHOD_3 ( R . id . VAR_1 ) ) == false ) { <END> return ; } METHOD_4 ( ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; METHOD_4 ( ) ; METHOD_7 ( ) ; } 
public static void METHOD_1 ( Context context , String VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( context ) ; if ( ! VAR_2 . contains ( VAR_1 ) ) { return ; } TYPE_1 . TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( ) ; VAR_3 . remove ( VAR_1 ) ; <START> VAR_3 . commit ( ) ; <END> } 
<START> private TYPE_1 METHOD_1 ( TYPE_2 url ) throws IOException { <END> return ( TYPE_1 ) url . VAR_1 ( ) ; } 
<START> private TYPE_1 METHOD_1 ( String url ) throws IOException { <END> return new TYPE_2 ( url ) . METHOD_1 ( ) ; } 
public static TYPE_1 from ( final TYPE_2 props ) throws IOException { return new TYPE_1 ( new TYPE_3 < String , String > ( ) { ANNOTATION_1 ( value = STRING_1 , VAR_1 = STRING_2 ) public String apply ( String from ) { <START> return props . getProperty ( from ) ; <END> } } ) ; } 
public void METHOD_1 ( TYPE_1 model , ANNOTATION_1 ( VAR_1 = true , value = STRING_1 ) String VAR_2 ) throws Exception { TYPE_2 VAR_3 = Context . VAR_4 ( ) . METHOD_2 ( VAR_2 ) ; <START> if ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . class . METHOD_5 ( ) ) ) { <END> int VAR_5 = VAR_3 . METHOD_6 ( ) ; model . put ( STRING_2 , VAR_5 ) ; model . put ( STRING_3 , true ) ; } else { model . put ( STRING_3 , false ) ; } } 
public void METHOD_1 ( String VAR_1 , String message , boolean command ) throws TYPE_1 { Response response = METHOD_2 ( ) . METHOD_3 ( TYPE_2 . entity ( <START> METHOD_4 ( VAR_1 , message . trim ( ) ) , VAR_2 ) ) ; <END> if ( response . getStatus ( ) / 100 != 2 ) { throw new TYPE_1 ( response . VAR_3 ( String . VAR_4 ) ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( ) ) ; METHOD_2 ( VAR_1 , text ( STRING_1 ) ) ; METHOD_2 ( VAR_1 , text ( STRING_2 ) ) ; METHOD_2 ( VAR_1 , text ( STRING_3 ) ) ; METHOD_2 ( VAR_1 , text ( STRING_4 ) ) ; <START> METHOD_2 ( VAR_1 , text ( <END> STRING_5 ) ) ; METHOD_2 ( VAR_1 , text ( STRING_6 ) ) ; } 
public void METHOD_1 ( String VAR_1 , String message , boolean command ) throws InterruptedException , TYPE_1 { Response response = METHOD_2 ( ) . METHOD_3 ( TYPE_2 . METHOD_4 ( METHOD_5 ( VAR_1 , message ) ) ) ; if ( ! response . VAR_2 ( ) . equals ( Response . Status . VAR_3 ) ) { String output = response . VAR_4 ( String . VAR_5 ) ; <START> throw new TYPE_1 ( new Exception ( output ) ) ; <END> } } 
public static String METHOD_1 ( long VAR_1 , TYPE_1 event , TYPE_2 position ) { <START> String VAR_2 = Context . VAR_3 ( ) . getString ( STRING_1 , STRING_2 ) ; <END> return METHOD_2 ( null , VAR_1 , event , position , VAR_2 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 command = new TYPE_2 ( ) ; command . VAR_2 ( 1 ) ; command . VAR_3 ( TYPE_2 . VAR_4 ) ; Assert . assertEquals ( STRING_1 , VAR_1 . METHOD_2 ( command ) ) ; TYPE_3 VAR_5 = Context . VAR_6 ( ) ; Context . VAR_7 ( VAR_8 ) ; try { Assert . assertEquals ( STRING_2 , VAR_1 . METHOD_2 ( command ) ) ; <START> } finally { <END> Context . VAR_7 ( VAR_5 ) ; } } 
public TYPE_1 ( ) { VAR_2 = Context . VAR_3 ( ) . getString ( STRING_1 , STRING_2 ) ; <START> VAR_4 = Context . VAR_3 ( ) . getString ( STRING_3 , "" ) ; <END> } 
protected String METHOD_1 ( TYPE_1 command , String format , String ... VAR_1 ) { <START> return super . METHOD_1 ( command , format , this , VAR_1 ) ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> VAR_3 = Context . VAR_4 ( ) . getString ( STRING_1 , STRING_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_2 { TYPE_1 user = TYPE_3 . create ( VAR_3 , METHOD_2 ( STRING_1 ) ) <START> . METHOD_3 ( STRING_2 , VAR_1 . trim ( ) . METHOD_4 ( ) ) <END> . METHOD_5 ( TYPE_1 . class ) ; if ( user != null && user . VAR_4 ( VAR_2 ) ) { return user ; } else { return null ; } } 
public TYPE_2 ( ) { <START> if ( Context . VAR_2 ( ) != null ) { <END> VAR_3 = TYPE_1 . METHOD_1 ( ) ; } } 
public Response update ( TYPE_1 entity ) throws TYPE_2 { Context . VAR_1 ( ) . METHOD_1 ( METHOD_2 ( ) ) ; <START> Context . VAR_1 ( ) . METHOD_3 ( STRING_1 , METHOD_2 ( ) , entity . getId ( ) ) ; <END> Context . VAR_2 ( ) . METHOD_4 ( entity ) ; return Response . VAR_3 ( entity ) . build ( ) ; } 
public TYPE_6 ( TYPE_1 VAR_2 ) { super ( VAR_2 , TYPE_2 . class , TYPE_3 . class , TYPE_4 . class , TYPE_5 . class ) ; METHOD_1 ( ) ; <START> METHOD_2 ( ) ; <END> } 
protected Object METHOD_1 ( TYPE_1 command ) { <START> METHOD_2 ( command , "" ) ; <END> switch ( command . getType ( ) ) { case TYPE_1 . VAR_1 : return METHOD_3 ( command . getString ( TYPE_1 . VAR_2 ) ) ; case TYPE_1 . VAR_3 : return METHOD_3 ( STRING_1 ) ; case TYPE_1 . VAR_4 : return METHOD_3 ( STRING_2 ) ; default : Log . VAR_5 ( new TYPE_2 ( command . getType ( ) ) ) ; break ; } return null ; } 
public void METHOD_1 ( String VAR_1 ) { if ( VAR_1 != null ) { <START> this . VAR_1 = TYPE_1 . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ; <END> } else { this . VAR_1 = null ; } } 
<START> public Response add ( TYPE_1 entity ) throws TYPE_2 , TYPE_3 , <END> TYPE_4 , TYPE_5 , InterruptedException { Context . VAR_1 ( ) . METHOD_1 ( METHOD_2 ( ) ) ; Context . VAR_1 ( ) . METHOD_3 ( METHOD_2 ( ) , entity . VAR_2 ( ) ) ; Context . VAR_3 ( ) . METHOD_4 ( entity ) ; return Response . VAR_4 ( entity ) . build ( ) ; } 
public void run ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_1 ( ) ; if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { try { VAR_1 . METHOD_3 ( new TYPE_2 ( ) , VAR_3 ) ; } catch ( TYPE_3 | TYPE_4 | TYPE_5 | TYPE_6 error ) { <START> Log . VAR_4 ( STRING_1 + error ) ; <END> VAR_2 . METHOD_4 ( ) ; } catch ( InterruptedException error ) { Log . info ( STRING_2 ) ; } } else { Log . error ( STRING_3 ) ; } } 
private String METHOD_1 ( int value ) { switch ( value ) { case 1 : return TYPE_1 . VAR_2 ; case 2 : <START> return null ; <END> case 3 : return TYPE_1 . VAR_3 ; case 4 : return TYPE_1 . VAR_4 ; case 5 : return null ; case INT_1 : return null ; default : return null ; } } 
public TYPE_4 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; this . config = Context . VAR_3 ( ) ; VAR_4 = config . VAR_5 ( STRING_1 , VAR_6 ) * INT_1 ; if ( VAR_2 != null ) { try { METHOD_1 ( true ) ; <START> METHOD_2 ( true ) ; <END> for ( TYPE_2 position : VAR_2 . METHOD_3 ( ) ) { VAR_7 . put ( position . VAR_8 ( ) , position ) ; } } catch ( TYPE_3 error ) { Log . VAR_9 ( error ) ; } } } 
public TYPE_1 METHOD_1 ( String name , long value ) throws TYPE_2 { for ( int i : METHOD_2 ( name ) ) { try { if ( value == 0 ) { VAR_1 . METHOD_3 ( i , TYPE_3 . VAR_3 ) ; } else { <START> VAR_1 . METHOD_1 ( i , value ) ; <END> } } catch ( TYPE_2 error ) { VAR_1 . close ( ) ; connection . close ( ) ; throw error ; } } return this ; } 
public void METHOD_1 ( TYPE_1 session ) { super . METHOD_1 ( session ) ; <START> Map < String , Collection < ? > > data = new HashMap < String , Collection < ? > > ( ) ; <END> data . put ( VAR_1 , Context . VAR_2 ( ) . METHOD_2 ( VAR_3 ) ) ; METHOD_3 ( data ) ; Context . VAR_2 ( ) . METHOD_4 ( VAR_3 , this ) ; } 
TYPE_3 ( TYPE_1 VAR_2 ) { super ( METHOD_1 ( STRING_1 ) ) ; try { METHOD_2 ( TYPE_2 . VAR_4 ) ; } catch ( IOException e ) { <START> throw new RuntimeException ( STRING_2 ) ; <END> } this . VAR_2 = VAR_2 ; METHOD_3 ( true ) ; } 
public boolean METHOD_1 ( long VAR_1 ) { try { close ( ) ; TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 ) ; boolean VAR_4 = VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_2 . close ( ) ; VAR_5 = new TYPE_1 ( VAR_3 ) ; VAR_6 = new TYPE_2 ( VAR_7 ) ; return VAR_4 ; <START> } catch ( IOException e ) { <END> LOG . error ( STRING_1 , e ) ; return false ; } } 
public void close ( ) throws IOException { VAR_1 . close ( ) ; <START> VAR_1 = null ; <END> VAR_2 . close ( ) ; VAR_2 = null ; } 
public void METHOD_1 ( ) { boolean value = true ; boolean VAR_1 = false ; VAR_2 = new TYPE_1 ( ) ; System . VAR_3 ( VAR_2 . METHOD_2 ( ) , Boolean . toString ( value ) ) ; TYPE_2 conf = new TYPE_2 ( ) ; boolean result = conf . VAR_4 ( VAR_2 . METHOD_2 ( ) , VAR_1 ) ; assertEquals ( value , result ) ; <START> System . VAR_5 ( VAR_2 . METHOD_2 ( ) ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , int VAR_4 , int VAR_5 ) { this ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , Integer . VAR_6 ) ; <START> } <END> 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , String value ) { <END> if ( value != null ) { VAR_2 . put ( VAR_1 . name ( ) . METHOD_2 ( ) , value ) ; } } 
void METHOD_1 ( ) { try { long VAR_1 = TYPE_1 . METHOD_2 ( ) ; <START> VAR_2 . close ( ) ; <END> TYPE_3 . TYPE_4 ( ) . VAR_3 . add ( TYPE_1 . METHOD_2 ( ) - VAR_1 ) ; } catch ( IOException e ) { LOG . warn ( STRING_1 , e ) ; } } 
public TYPE_5 ( String VAR_2 , TYPE_1 VAR_3 , int VAR_4 , TYPE_2 VAR_5 , TYPE_3 VAR_6 , TYPE_4 VAR_7 , boolean VAR_8 ) { this ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , <START> VAR_6 , <END> VAR_7 , 0 , new byte [ INT_1 ] , VAR_8 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 . METHOD_2 ( true ) ; <END> METHOD_3 ( false , true ) ; METHOD_4 ( STRING_1 , TYPE_1 . METHOD_5 ( ) ) ; } 
public synchronized void METHOD_1 ( ) { if ( VAR_1 == null ) { METHOD_2 ( ) ; } METHOD_3 ( ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; METHOD_8 ( ) ; METHOD_9 ( TYPE_2 . VAR_3 ) ; VAR_4 . start ( ) ; <START> VAR_5 = VAR_1 instanceof TYPE_1 <END> && ( ( TYPE_1 ) VAR_1 ) . METHOD_10 ( ) ; METHOD_11 ( ) ; } 
public void METHOD_1 ( long VAR_1 ) { <START> if ( VAR_2 ) VAR_3 . write ( new TYPE_1 ( VAR_1 ) ) ; <END> } 
protected abstract TYPE_1 METHOD_1 ( ) throws TYPE_2 ; <START> private char [ ] METHOD_2 ( String VAR_1 ) { <END> return VAR_1 == null ? VAR_2 : VAR_1 . METHOD_3 ( ) ; } 
void METHOD_1 ( ) { try { <START> if ( VAR_1 != null && ! VAR_1 . METHOD_2 ( ) ) { <END> VAR_1 . close ( ) ; } } catch ( IOException e ) { LOG . warn ( STRING_1 , e ) ; } } 
<START> public int METHOD_1 ( ) { <END> if ( VAR_1 != null ) { return VAR_1 . METHOD_2 ( ) ; } return 0 ; } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 . close ( ) ; <END> VAR_2 . close ( ) ; super . METHOD_1 ( ) ; } 
static void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> } 
public int METHOD_1 ( ) { return ( int ) getValue ( VAR_1 ) ; <START> } <END> 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( super . METHOD_1 ( ) , time ) ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; <START> if ( ! super . equals ( o ) ) return false ; <END> TYPE_1 that = ( TYPE_1 ) o ; return time == that . time ; } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } <START> if ( o == null || getClass ( ) != o . getClass ( ) ) { <END> return false ; } TYPE_1 that = ( TYPE_1 ) o ; return err == that . err && TYPE_2 . equals ( path , that . path ) ; } 
public void start ( ) { <START> if ( VAR_1 > 0 ) { <END> VAR_2 . METHOD_1 ( TYPE_2 . VAR_4 , VAR_1 ) ; } LOG . info ( STRING_1 , VAR_5 ) ; VAR_6 = VAR_2 . bind ( VAR_5 ) . METHOD_2 ( ) . channel ( ) ; VAR_5 = ( TYPE_1 ) VAR_6 . METHOD_3 ( ) ; LOG . info ( STRING_2 + METHOD_4 ( ) ) ; } 
public void METHOD_1 ( int VAR_1 ) { <START> LOG . info ( STRING_1 + VAR_1 ) ; <END> this . VAR_2 = VAR_1 ; } 
public TYPE_1 get ( ) { try { return TYPE_1 . METHOD_1 ( ) ; } catch ( TYPE_2 e ) { <START> return null ; <END> } } 
public void METHOD_1 ( ) { final boolean VAR_1 = false ; final String VAR_2 = STRING_1 ; METHOD_2 ( ( VAR_3 ) - > VAR_3 . METHOD_3 ( VAR_1 , VAR_2 ) , ( VAR_4 ) - > { boolean VAR_5 = VAR_4 . METHOD_4 ( VAR_2 ) ; <START> Assert . assertEquals ( VAR_1 , VAR_5 ) ; <END> } ) ; } 
<START> public Boolean METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { <END> if ( ! TYPE_2 . METHOD_2 ( ) ) { return false ; } TYPE_3 VAR_2 = VAR_3 ; if ( VAR_2 == null ) { VAR_2 = new TYPE_3 ( ) ; } VAR_2 . METHOD_3 ( VAR_1 ) ; return true ; } 
<START> public Boolean METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { <END> if ( ! TYPE_2 . METHOD_2 ( ) ) { return false ; } try { TYPE_3 VAR_2 = new TYPE_3 ( ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; if ( VAR_2 . VAR_3 > 0 ) { VAR_4 = VAR_2 ; } return true ; } catch ( TYPE_4 e ) { LOG . warn ( STRING_1 + STRING_2 ) ; return false ; } } 
<START> public default void VAR_1 ( ) { <END> VAR_1 ( 1 ) ; } 
public void METHOD_1 ( ) throws Exception { String [ ] VAR_1 = { STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 } ; <START> String [ ] VAR_2 = { STRING_3 , STRING_2 , STRING_1 } ; <END> METHOD_2 ( VAR_1 , VAR_2 ) ; } 
public boolean close ( int VAR_1 ) throws InterruptedException { close ( ) ; <START> if ( VAR_1 > 0 ) { <END> return METHOD_1 ( VAR_1 ) ; } return false ; } 
<START> private void METHOD_1 ( ) throws TYPE_1 , IOException { <END> if ( VAR_1 . METHOD_2 ( ) ) { if ( VAR_2 == null ) { VAR_2 = new TYPE_2 ( ) ; } VAR_3 = VAR_2 . METHOD_3 ( ) ; } else { VAR_3 = new TYPE_3 ( ) ; } VAR_3 . METHOD_4 ( VAR_1 . VAR_4 * VAR_1 . VAR_5 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( true ) ; <START> if ( VAR_3 != null ) { <END> LOG . debug ( STRING_1 , Arrays . toString ( VAR_3 ) ) ; VAR_2 . METHOD_4 ( VAR_3 ) ; } VAR_1 . METHOD_5 ( VAR_2 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 != null ) { <END> TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; LOG . debug ( STRING_1 , Arrays . toString ( VAR_2 ) ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; } } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( ) ; TYPE_1 . METHOD_3 ( ) ; System . VAR_1 ( STRING_1 , STRING_2 ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; TYPE_2 VAR_2 = METHOD_6 ( ) ; <START> String VAR_3 = METHOD_7 ( VAR_2 . METHOD_8 ( ) ) ; <END> METHOD_5 ( ) ; VAR_2 . METHOD_9 ( STRING_3 , true , null ) ; METHOD_5 ( ) ; VAR_2 . close ( ) ; METHOD_10 ( STRING_2 , STRING_4 ) ; METHOD_5 ( ) ; } 
public void METHOD_1 ( ) throws IOException , InterruptedException , TYPE_1 { TYPE_2 VAR_1 = null ; try { VAR_1 = METHOD_2 ( new TYPE_3 ( ) , VAR_2 ) ; VAR_1 . METHOD_3 ( STRING_1 , VAR_3 ) ; METHOD_4 ( VAR_1 ) ; } finally { if ( VAR_1 != null ) { <START> VAR_1 . close ( ) ; <END> } } } 
<START> private boolean METHOD_1 ( ) { <END> return Boolean . VAR_1 ( VAR_2 ) ; } 
<START> public void METHOD_1 ( ) throws InterruptedException , TYPE_4 . TYPE_5 { <END> System . VAR_1 ( VAR_2 , VAR_3 ) ; TYPE_2 . METHOD_2 ( false ) ; VAR_4 = new TYPE_3 ( 1 ) ; VAR_4 . VAR_5 = true ; try { VAR_4 . METHOD_3 ( ) ; } catch ( IOException e ) { Assert . VAR_6 ( STRING_1 ) ; } METHOD_4 ( ) ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) throws IOException { <END> this . VAR_2 = VAR_2 ; METHOD_1 ( ) ; } 
public static boolean METHOD_1 ( String file ) throws IOException { try { <START> TYPE_1 reader = new TYPE_1 ( new File ( file ) ) ; <END> TYPE_2 VAR_1 = new TYPE_2 ( reader ) ; TYPE_3 VAR_2 = new TYPE_3 ( ) ; VAR_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; } finally { reader . close ( ) ; } return VAR_2 . METHOD_3 ( ) == TYPE_4 . VAR_4 ; } 
public void METHOD_1 ( final TYPE_1 event ) { final ArrayList < TYPE_2 > VAR_1 = new ArrayList < > ( this . VAR_1 ) ; for ( final TYPE_2 listener : VAR_1 ) { try { listener . VAR_2 ( event ) ; <START> } catch ( Exception e ) { <END> logger . warn ( STRING_1 + listener . getClass ( ) ) ; logger . warn ( e . getMessage ( ) , e ) ; } } } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { try { return TYPE_1 . METHOD_2 ( VAR_1 ) ; } catch ( final IllegalArgumentException e ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_1 ( VAR_1 ) ; <START> if ( null == VAR_2 ) return null ; <END> try { return TYPE_1 . METHOD_3 ( VAR_2 ) ; } catch ( final IllegalArgumentException VAR_3 ) { return null ; } } } 
public void METHOD_1 ( ) throws Exception { <START> if ( this . VAR_1 != null ) { <END> this . VAR_1 . close ( ) ; } final Path VAR_2 = TYPE_1 . METHOD_2 ( ) ; if ( TYPE_2 . exists ( VAR_2 ) ) { TYPE_2 . METHOD_3 ( TYPE_1 ) ; TYPE_2 . METHOD_4 ( VAR_2 ) ; } } 
public void METHOD_1 ( ) { <START> if ( null != this . VAR_1 ) this . VAR_1 . METHOD_1 ( ) ; <END> if ( null != this . VAR_2 ) this . VAR_2 . METHOD_1 ( ) ; } 
private static TYPE_1 METHOD_1 ( final TYPE_2 conf , final TYPE_3 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) return null ; <START> else METHOD_3 ( VAR_1 . METHOD_2 ( ) , VAR_2 ) ; <END> try { return TYPE_1 . get ( VAR_1 . METHOD_2 ( ) , conf ) ; } catch ( final IOException e ) { log . error ( STRING_1 , e ) ; throw new TYPE_4 ( e ) ; } } 
<START> public String METHOD_1 ( ) { return VAR_1 ; } <END> 
public TYPE_1 METHOD_1 ( ) { <START> return uri ; <END> } 
public List < String > METHOD_1 ( final Type type ) { <START> final ArrayList < String > VAR_1 = new ArrayList < > ( ) ; <END> for ( final Map . Entry < String , TYPE_1 > entry : this . VAR_2 . entrySet ( ) ) { final TYPE_1 VAR_3 = entry . getValue ( ) ; if ( VAR_3 . METHOD_2 ( type ) ) { VAR_1 . add ( entry . getKey ( ) ) ; } } return VAR_1 ; } 
private void METHOD_1 ( final TYPE_1 page , final TYPE_2 project , final TYPE_3 session ) { boolean VAR_1 = project . VAR_2 ( Type . VAR_3 ) . size ( ) > 1 || project . VAR_4 ( Type . VAR_3 ) . size ( ) > 0 || ! METHOD_2 ( session . VAR_5 ( ) , Type . VAR_3 ) <START> || ! this . VAR_6 ; <END> page . add ( STRING_1 , VAR_1 ) ; } 
public Object METHOD_1 ( ) { final TYPE_1 VAR_1 ; try { VAR_1 = this . VAR_2 . METHOD_2 ( this . VAR_3 ) ; <START> logger . info ( STRING_1 + this . VAR_3 + STRING_2 + VAR_1 . toString ( ) ) ; <END> } catch ( final TYPE_2 e ) { logger . error ( STRING_3 , e ) ; return true ; } return METHOD_3 ( VAR_1 ) ; } 
<START> public static TYPE_1 METHOD_1 ( long VAR_1 , long VAR_2 , long VAR_3 , <END> int VAR_4 , int VAR_5 , int VAR_6 , int VAR_7 , boolean VAR_8 , int VAR_9 , boolean VAR_10 ) { return new TYPE_1 ( ) . METHOD_2 ( VAR_1 ) . METHOD_3 ( VAR_2 ) . METHOD_4 ( VAR_3 ) . METHOD_5 ( VAR_4 ) . METHOD_6 ( VAR_5 ) . METHOD_7 ( VAR_6 ) . METHOD_8 ( VAR_7 ) . METHOD_9 ( VAR_8 ) . METHOD_10 ( VAR_9 ) . METHOD_11 ( VAR_10 ) ; } 
<START> public void METHOD_1 ( boolean VAR_1 ) { VAR_2 = VAR_1 ; } <END> 
<START> public double METHOD_1 ( ) { <END> if ( this . VAR_1 . isEmpty ( ) ) { return - 1 ; } final TYPE_1 VAR_2 = this . VAR_1 . METHOD_2 ( ) ; final TYPE_1 VAR_3 = METHOD_3 ( ) ; this . VAR_1 . METHOD_4 ( VAR_3 ) ; return METHOD_5 ( VAR_2 , VAR_3 ) ; } 
<START> public String METHOD_1 ( ) { <END> final List < Integer > VAR_1 = new ArrayList < > ( ) ; try { METHOD_2 ( VAR_1 , this . VAR_2 . METHOD_3 ( ) . values ( ) ) ; } catch ( final TYPE_1 e ) { this . logger . error ( STRING_1 , e ) ; } return VAR_1 . toString ( ) ; } 
<START> public String METHOD_1 ( ) { <END> final List < Integer > VAR_1 = new ArrayList < > ( ) ; try { METHOD_2 ( VAR_1 , this . VAR_2 . METHOD_3 ( ) ) ; } catch ( final TYPE_1 e ) { this . logger . error ( STRING_1 , e ) ; } return VAR_1 . toString ( ) ; } 
<START> public int METHOD_1 ( ) { <END> return VAR_1 ; } 
public static void METHOD_1 ( ) { VAR_1 = VAR_2 + STRING_1 ; VAR_3 = new File ( VAR_1 ) ; VAR_4 = new File ( VAR_3 , STRING_2 ) ; <START> VAR_4 = new File ( VAR_3 , STRING_2 ) ; <END> VAR_5 = new File ( VAR_4 , STRING_3 + STRING_4 ) ; VAR_6 = new File ( VAR_4 , STRING_5 ) ; } 
public boolean containsKey ( final String key ) { <START> return super . get ( key . VAR_1 ( ) ) != null ; <END> } 
private void write ( final String string ) { <START> if ( METHOD_1 ( ) ) { <END> METHOD_2 ( ) ; System . err . println ( string ) ; METHOD_3 ( ) ; } else { logger . log ( this . VAR_1 , string ) ; } } 
public List < byte [ ] > METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 { if ( ! VAR_1 . next ( ) ) { return Collections . VAR_2 ( ) ; } <START> final ArrayList < byte [ ] > data = new ArrayList < > ( ) ; <END> do { final byte [ ] VAR_3 = VAR_1 . METHOD_2 ( 1 ) ; data . add ( VAR_3 ) ; } while ( VAR_1 . next ( ) ) ; return data ; } 
public void start ( ) { try { this . VAR_1 . start ( ) ; } catch ( final TYPE_1 e ) { <START> logger . warn ( STRING_1 , e ) ; <END> } logger . info ( STRING_2 ) ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return this . VAR_1 ; } 
public void METHOD_1 ( ) { logger . warn ( STRING_1 ) ; this . VAR_1 . METHOD_1 ( ) ; this . VAR_2 . METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { props . put ( Constants . TYPE_7 . VAR_2 , VAR_3 ) ; final TYPE_1 VAR_4 = TYPE_2 . METHOD_2 ( new TYPE_3 ( props ) , new TYPE_4 ( ) ) ; <START> TYPE_5 . METHOD_3 ( ) ; <END> TYPE_5 . METHOD_4 ( VAR_4 ) ; assertNotNull ( TYPE_5 . getInstance ( TYPE_6 . class ) ) ; } 
public void METHOD_1 ( ) throws Exception { logger . info ( STRING_1 + METHOD_2 ( ) ) ; <START> TYPE_1 VAR_1 = TYPE_3 . TYPE_4 . getInstance ( TYPE_1 . class ) ; <END> VAR_1 . METHOD_3 ( VAR_2 , VAR_3 ) ; } 
private static String METHOD_1 ( ) throws IOException { final String VAR_1 = METHOD_2 ( ) ; Path VAR_2 = TYPE_1 . get ( VAR_1 ) . METHOD_3 ( ) ; Path VAR_3 = VAR_2 . METHOD_3 ( ) . METHOD_3 ( ) . METHOD_3 ( ) . METHOD_3 ( ) ; File VAR_4 = TYPE_1 . get ( VAR_3 . toString ( ) , VAR_5 ) . METHOD_4 ( ) ; <START> return props . getString ( TYPE_2 . VAR_7 , VAR_4 . METHOD_5 ( ) ) ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; <START> METHOD_1 ( VAR_2 . METHOD_2 ( ) , STRING_1 ) ; <END> } 
public Boolean METHOD_1 ( int id ) { TYPE_1 project = METHOD_2 ( id ) ; <START> return project != null ; <END> } 
public void METHOD_1 ( ) throws Exception { if ( ! METHOD_2 ( ) ) { return ; } TYPE_1 VAR_1 = METHOD_3 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_4 ( STRING_1 , INT_1 ) ; VAR_1 . METHOD_5 ( STRING_1 , INT_1 ) ; <START> TYPE_2 VAR_3 = VAR_1 . METHOD_6 ( STRING_1 , INT_1 ) ; <END> Assert . VAR_4 ( VAR_3 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 . isPresent ( ) ) { <END> METHOD_2 ( VAR_2 ) ; VAR_3 . info ( STRING_1 + this . VAR_4 ) ; } VAR_2 = Optional . of ( VAR_1 ) ; logger . VAR_5 ( VAR_2 . get ( ) ) ; logger . VAR_6 ( false ) ; VAR_3 . info ( STRING_2 + this . VAR_4 ) ; } 
private void METHOD_1 ( Optional < TYPE_1 > VAR_1 ) { METHOD_1 ( VAR_1 . get ( ) ) ; <START> VAR_1 = Optional . empty ( ) ; <END> } 
public static boolean METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { if ( ! TYPE_2 . METHOD_2 ( VAR_1 ) ) { return false ; } else { TYPE_2 VAR_3 = METHOD_3 ( VAR_1 , VAR_2 ) ; <START> if ( VAR_3 == null || VAR_3 . METHOD_4 ( new Date ( ) ) == null ) { <END> return false ; } return true ; } } 
public boolean METHOD_1 ( ) { <START> return VAR_1 == null && VAR_2 == null ? false : true ; <END> } 
public TYPE_3 ( List < String > VAR_2 , Map < String , Integer > VAR_3 ) { <START> super ( null == VAR_2 || VAR_2 . size ( ) == 0 ? null : new TYPE_1 ( VAR_2 ) , <END> null == VAR_3 || VAR_3 . size ( ) == 0 ? null : new TYPE_2 ( VAR_3 ) ) ; } 
public static TYPE_1 getInstance ( ) { <START> if ( null == instance ) { <END> synchronized ( TYPE_1 . class ) { if ( null == instance ) { instance = new TYPE_1 ( ) ; } } } return instance ; } 
protected synchronized void METHOD_1 ( ) { <START> } <END> 
public void METHOD_1 ( Set < String > VAR_1 ) { <START> VAR_2 . addAll ( VAR_1 ) ; <END> } 
private void METHOD_1 ( ) { String VAR_1 = node . VAR_2 ( ) . METHOD_2 ( ) ; String VAR_3 = node . getId ( ) ; String VAR_4 = String . format ( STRING_1 , VAR_1 , VAR_5 , VAR_3 ) ; String VAR_6 = props . get ( TYPE_1 . VAR_8 ) ; if ( VAR_6 == null ) { VAR_6 = VAR_4 ; } else { <START> VAR_6 += STRING_2 + VAR_4 ; <END> } logger . info ( STRING_3 + VAR_6 ) ; props . put ( TYPE_1 . VAR_8 , VAR_6 ) ; } 
public void METHOD_1 ( TYPE_1 event ) { if ( event . getType ( ) == TYPE_1 . Type . VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) event . VAR_3 ( ) ; TYPE_3 VAR_4 = VAR_2 . METHOD_2 ( ) ; VAR_5 . put ( VAR_4 . METHOD_3 ( ) , VAR_4 ) ; logger . info ( STRING_1 + VAR_4 . METHOD_3 ( ) + STRING_2 ) ; VAR_6 . remove ( VAR_4 . METHOD_3 ( ) ) ; <START> VAR_7 . remove ( VAR_4 . METHOD_3 ( ) ) ; <END> } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException , TYPE_2 { logger . debug ( STRING_1 ) ; if ( ! VAR_2 . METHOD_2 ( VAR_1 ) ) { <START> TYPE_1 VAR_3 = new TYPE_1 ( VAR_1 ) ; <END> IOException e = new IOException ( STRING_2 ) ; if ( ! METHOD_3 ( VAR_3 , e ) ) { logger . error ( STRING_3 + VAR_1 . METHOD_4 ( ) + STRING_4 , e ) ; } } } 
public String METHOD_1 ( ) { <START> Assert . state ( ! StringUtils . isEmpty ( VAR_1 ) , STRING_1 ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( ANNOTATION_1 Throwable VAR_1 ) { METHOD_2 ( false ) ; if ( VAR_1 instanceof TYPE_1 ) { METHOD_3 ( ( TYPE_1 ) VAR_1 ) ; <START> TYPE_2 . e ( VAR_1 ) ; } else { METHOD_4 ( VAR_1 ) ; TYPE_2 . e ( VAR_1 ) ; <END> } } 
void METHOD_1 ( ANNOTATION_1 String VAR_1 ) { VAR_2 . execute ( TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ) ; for ( TYPE_2 VAR_3 : VAR_4 . VAR_5 ) { if ( VAR_3 . METHOD_3 ( ) . equals ( VAR_1 ) ) { <START> METHOD_1 ( VAR_3 ) ; <END> break ; } } } 
public Set < String > METHOD_1 ( ) { <START> Set < String > VAR_1 = new HashSet < > ( ) ; VAR_1 . add ( VAR_2 ) ; return VAR_2 != null ? Collections . VAR_3 ( VAR_1 ) : Collections . VAR_4 ( ) ; <END> } 
TYPE_1 METHOD_1 ( ANNOTATION_1 Throwable VAR_1 ) { if ( VAR_1 != null && METHOD_2 ( VAR_1 ) ) { return TYPE_1 . VAR_2 ; } else if ( VAR_1 != null && METHOD_3 ( VAR_1 ) ) { return TYPE_1 . VAR_3 ; <START> } else if ( VAR_1 != null && METHOD_4 ( VAR_1 ) ) { <END> return TYPE_1 . VAR_4 ; } return TYPE_1 . VAR_5 ; } 
public void METHOD_1 ( ANNOTATION_1 String text ) { <START> if ( VAR_1 != VAR_2 && VAR_1 != VAR_3 ) { <END> VAR_4 . setText ( text ) ; } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; VAR_2 = VAR_1 . METHOD_2 ( ) ; METHOD_3 ( ) ; <START> if ( VAR_3 != VAR_4 && VAR_3 != VAR_5 ) { <END> METHOD_4 ( VAR_2 ) ; } METHOD_5 ( false ) ; } 
public void METHOD_1 ( ) { <START> if ( VAR_1 != null && ! VAR_1 . METHOD_2 ( ) ) { <END> VAR_1 . clear ( ) ; } } 
public String METHOD_1 ( ) { return VAR_1 ? VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) : VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <START> } <END> 
void METHOD_1 ( boolean VAR_1 ) { VAR_2 = VAR_1 ; <START> VAR_3 . METHOD_2 ( ) . METHOD_3 ( this : : update , VAR_4 ) ; <END> } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; METHOD_2 ( ) . METHOD_3 ( TYPE_4 . TYPE_2 . VAR_4 ) ; METHOD_2 ( ) . METHOD_4 ( TYPE_3 . VAR_6 ) ; <START> METHOD_2 ( ) . METHOD_5 ( 0 ) ; <END> } 
private void METHOD_1 ( ) { VAR_1 . setText ( TYPE_1 . METHOD_2 ( ) ) ; <START> VAR_2 . setText ( METHOD_3 ( ) . METHOD_4 ( R . VAR_3 . VAR_4 , TYPE_2 . METHOD_5 ( ) ) ) ; <END> METHOD_6 ( ) . METHOD_7 ( ) ; } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) { switch ( VAR_1 . METHOD_2 ( ) ) { <START> case STRING_1 : <END> return STRING_2 ; case STRING_3 : return STRING_4 ; case STRING_5 : return STRING_6 ; case STRING_7 : return STRING_8 ; default : return STRING_2 ; } } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! VAR_1 . getPath ( ) . isEmpty ( ) ) return VAR_1 . getPath ( ) ; else <START> return STRING_1 ; <END> } 
private static String METHOD_1 ( final String host ) { if ( host == null ) { return null ; <START> } <END> return METHOD_2 ( host ) . METHOD_3 ( ) ; } 
private static String METHOD_1 ( final String VAR_1 ) { <START> if ( VAR_1 == null ) { <END> return null ; } return METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> for ( ; ; ) { <END> TYPE_1 VAR_1 = this . VAR_2 ; if ( VAR_1 != null ) { return VAR_1 ; } TYPE_1 r = new TYPE_1 ( ) ; if ( VAR_3 . METHOD_2 ( this , null , r ) ) { return r ; } } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> final TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; final long VAR_3 = VAR_1 . METHOD_3 ( ) . stream ( ) . filter ( channel - > ! channel . VAR_4 ( ) ) . count ( ) ; final long VAR_5 = VAR_1 . METHOD_3 ( ) . stream ( ) . filter ( TYPE_3 : : METHOD_4 ) . count ( ) ; return new TYPE_1 ( VAR_3 , VAR_5 ) ; } 
private static String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 request , TYPE_3 VAR_2 ) { <START> return VAR_1 != null ? VAR_1 . toString ( ) + STRING_1 : "" + <END> request . VAR_3 ( ) . METHOD_2 ( request . VAR_4 ( ) , VAR_2 ) . toString ( ) ; } 
private static boolean METHOD_1 ( ) { <START> if ( VAR_1 == false ) { <END> VAR_2 . METHOD_2 ( ) ; try { if ( VAR_1 == false ) { VAR_3 = TYPE_1 . METHOD_3 ( TYPE_1 . VAR_4 ) ; VAR_1 = true ; } } finally { VAR_2 . METHOD_4 ( ) ; } } return ( VAR_3 != null ) ; } 
public boolean METHOD_1 ( String name ) { if ( VAR_1 . remove ( name ) == null ) return false ; else return true ; <START> } <END> 
<START> ANNOTATION_1 public void METHOD_1 ( ) throws Exception { <END> METHOD_2 ( STRING_1 ) ; METHOD_2 ( STRING_2 ) ; METHOD_2 ( STRING_3 ) ; METHOD_2 ( STRING_4 ) ; METHOD_2 ( STRING_5 ) ; METHOD_2 ( STRING_6 ) ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { List < TYPE_1 > properties = new ArrayList < > ( ) ; for ( TYPE_3 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_2 ( VAR_1 ) ) { <START> properties . addAll ( VAR_2 . METHOD_3 ( ) ) ; <END> } } if ( properties . isEmpty ( ) ) { properties . addAll ( VAR_4 ) ; } return properties ; } 
private ANNOTATION_1 TYPE_1 [ ] METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 , String VAR_2 ) { TYPE_1 [ ] VAR_3 = new TYPE_1 [ 0 ] ; try { List < TYPE_1 > VAR_4 = source . VAR_5 ( VAR_1 , event , listener ) ; <START> VAR_3 = VAR_4 . METHOD_2 ( new TYPE_1 [ 0 ] ) ; <END> } catch ( IOException | InterruptedException e ) { METHOD_3 ( e , listener . error ( STRING_1 , VAR_1 , VAR_2 ) ) ; } return VAR_3 ; } 
public final boolean METHOD_1 ( ANNOTATION_1 TYPE_1 source , ANNOTATION_1 TYPE_2 VAR_1 , ANNOTATION_1 TYPE_3 VAR_2 , ANNOTATION_2 TYPE_3 VAR_3 , ANNOTATION_1 TYPE_4 listener ) { <START> return METHOD_1 ( source , VAR_1 , VAR_2 , VAR_3 , listener , null ) ; <END> } 
<START> private static ANNOTATION_1 TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 index ) throws IOException , InterruptedException { <END> TYPE_1 stream = index . read ( ) ; assert stream != null ; return stream ; } 
public synchronized void METHOD_1 ( ) throws IOException { if ( TYPE_1 . contains ( this ) ) { return ; } METHOD_2 ( ) . write ( this ) ; <START> TYPE_2 . METHOD_3 ( this , METHOD_2 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 item ) { if ( item instanceof TYPE_2 ) { try { ( ( TYPE_2 ) item ) . METHOD_2 ( ) ; } catch ( TYPE_3 e ) { VAR_1 = false ; <START> throw e ; <END> } } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 job = new TYPE_1 ( METHOD_2 ( ) , VAR_1 . getName ( ) ) ; job . VAR_2 ( ) ; TYPE_1 VAR_3 = METHOD_3 ( job ) ; <START> when ( VAR_3 . METHOD_4 ( ) ) . METHOD_5 ( false ) ; <END> METHOD_6 ( VAR_3 , VAR_1 ) ; return VAR_3 ; } 
<START> public abstract ANNOTATION_1 TYPE_1 < ? , ? > METHOD_1 ( ANNOTATION_2 TYPE_2 < ? > parent , ANNOTATION_2 String name , ANNOTATION_2 List < ? extends TYPE_3 > VAR_1 , ANNOTATION_2 Map < String , Object > VAR_2 , ANNOTATION_2 TYPE_4 listener ) throws IOException , InterruptedException ; <END> @Override public TYPE_5 METHOD_2 ( ) { return ( TYPE_5 ) super . METHOD_2 ( ) ; } 
<START> ANNOTATION_1 public final void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
<START> @Override public boolean filter ( Object context , TYPE_1 VAR_1 ) { <END> if ( context instanceof TYPE_2 && VAR_1 instanceof TYPE_3 ) { return ( ( TYPE_3 ) VAR_1 ) . METHOD_1 ( ( TYPE_2 ) context ) ; } else { return true ; } } 
<START> public ANNOTATION_1 TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public ANNOTATION_1 TYPE_1 METHOD_1 ( ) { <END> TYPE_2 j = TYPE_2 . getInstance ( ) ; if ( VAR_1 == null || VAR_1 . isEmpty ( ) || j == null ) { return j ; } else { return j . VAR_2 ( VAR_1 ) ; } } 
<START> @Override protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> for ( TYPE_2 d : VAR_1 . METHOD_2 ( ) ) { Type VAR_2 = TYPE_3 . METHOD_3 ( d . VAR_3 , TYPE_4 . class ) ; Type VAR_4 = TYPE_3 . METHOD_4 ( VAR_2 , 0 , TYPE_5 . class ) ; if ( TYPE_5 . class . METHOD_5 ( TYPE_3 . METHOD_6 ( VAR_4 ) ) ) { return true ; } } return false ; } 
< T > void METHOD_1 ( Class < T > type , TYPE_1 < T > VAR_1 ) { Map < TYPE_1 , TYPE_1 > VAR_2 = VAR_3 . get ( type ) ; if ( VAR_2 != null ) { TYPE_1 VAR_4 = VAR_2 . remove ( VAR_1 ) ; if ( VAR_4 != null ) { VAR_4 . METHOD_2 ( ) ; <START> return ; <END> } } throw new IllegalArgumentException ( STRING_1 + type + STRING_2 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws Exception { TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_3 r = new TYPE_3 ( ) ; TYPE_1 [ ] values = TYPE_1 . values ( ) ; int i ; do { i = r . VAR_3 ( values . length ) ; <START> } while ( VAR_2 . equals ( values [ i ] ) ) ; <END> return values [ i ] ; } 
public void METHOD_1 ( TYPE_1 method ) throws Exception { TYPE_2 . METHOD_2 ( STRING_1 + method . getName ( ) ) ; <START> VAR_1 [ 0 ] = new TYPE_3 ( ) ; <END> VAR_1 [ 0 ] = TYPE_2 . METHOD_3 ( ) [ 0 ] [ 0 ] ; VAR_1 [ 0 ] = new TYPE_3 ( VAR_1 [ 0 ] , cluster . VAR_2 ( ) , cluster . VAR_3 ( ) ) ; VAR_1 [ 0 ] . METHOD_4 ( VAR_4 ) ; VAR_1 [ 0 ] . METHOD_5 ( VAR_5 ) ; } 
public static void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) throws IOException { Path path = new Path ( VAR_1 ) ; if ( VAR_2 . exists ( path ) ) { <START> System . out . println ( STRING_1 + path + STRING_2 + VAR_2 . METHOD_2 ( ) . get ( STRING_3 ) ) ; <END> VAR_2 . METHOD_3 ( path , true ) ; } } 
public static boolean METHOD_1 ( String VAR_1 , String VAR_2 ) throws IOException , TYPE_1 { TYPE_2 . METHOD_2 ( true ) ; TYPE_2 . METHOD_3 ( true ) ; TYPE_3 VAR_3 = TYPE_2 . METHOD_4 ( VAR_1 , VAR_2 ) ; <START> System . out . println ( VAR_3 ) ; <END> return VAR_3 . METHOD_5 ( ) ; } 
TYPE_1 METHOD_1 ( TYPE_2 message ) { TYPE_1 VAR_1 = message . VAR_2 ( channel ) ; <START> if ( VAR_1 == null ) throw new IllegalStateException ( METHOD_2 ( null , channel ) + STRING_1 + message ) ; <END> VAR_1 . METHOD_3 ( channel , message instanceof TYPE_3 ) ; return VAR_1 ; } 
<START> private void METHOD_1 ( TYPE_1 channel ) <END> { if ( VAR_1 . remove ( channel . id ( ) ) != null && VAR_1 . isEmpty ( ) ) VAR_2 . close ( ) ; } 
public static void METHOD_1 ( ) { if ( conf . VAR_1 == null ) { throw new TYPE_1 ( STRING_1 , false ) ; } String VAR_2 = conf . VAR_1 ; try { VAR_2 = System . getProperty ( TYPE_3 . VAR_4 + STRING_2 , conf . VAR_1 ) ; VAR_1 = TYPE_2 . METHOD_2 ( VAR_2 ) ; } catch ( Exception e ) { <START> throw new TYPE_1 ( STRING_3 + VAR_2 , e ) ; <END> } VAR_5 = VAR_1 . getClass ( ) . METHOD_3 ( ) ; } 
public static void METHOD_1 ( ) { System . VAR_1 ( STRING_1 , STRING_2 ) ; <START> TYPE_1 . METHOD_2 ( ) ; <END> } 
public TYPE_1 ( boolean VAR_2 ) throws IOException { super ( "" , 0 ) ; this . VAR_2 = VAR_2 ; <START> METHOD_1 ( ) ; <END> } 
public boolean METHOD_1 ( int from , int to , TYPE_1 msg ) { for ( TYPE_2 filter : VAR_1 ) { if ( filter . VAR_2 ( from , to , msg ) ) <START> return filter . VAR_3 ; <END> } return true ; } 
<START> public TYPE_1 create ( String host , int VAR_1 , String VAR_2 , String VAR_3 ) throws IOException { <END> return new TYPE_2 ( host , VAR_1 , VAR_2 , VAR_3 ) ; } 
private static int METHOD_1 ( int VAR_1 , int VAR_2 ) { int d = VAR_1 % VAR_2 ; if ( d > 0 ) { VAR_1 += VAR_2 - d ; if ( VAR_1 == TYPE_1 . VAR_4 ) <START> VAR_1 = TYPE_1 . VAR_4 ; <END> else if ( VAR_1 < 0 ) return TYPE_1 . VAR_4 ; return VAR_1 ; } else return VAR_1 ; } 
public void add ( TYPE_1 VAR_1 ) { <START> assert VAR_2 == 0 ; <END> if ( size == VAR_3 . length ) { int VAR_4 ; if ( size < 3 ) VAR_4 = 3 ; else if ( size < INT_1 ) VAR_4 = INT_1 ; else VAR_4 = size * 2 ; VAR_3 = Arrays . VAR_5 ( VAR_3 , VAR_4 ) ; } VAR_3 [ size ++ ] = VAR_1 ; } 
<START> static final TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 list ) { return new TYPE_1 < > ( list , TYPE_4 : : METHOD_2 ) ; } <END> 
public Iterator < TYPE_1 > iterator ( ) { return new Iterator < TYPE_1 > ( ) { final int VAR_1 = VAR_2 + size ; int i = VAR_2 ; <START> @Override <END> public boolean hasNext ( ) { return i < VAR_1 ; } @Override public TYPE_1 next ( ) { return VAR_3 [ i ++ ] ; } } ; } 
<START> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) <END> { return METHOD_2 ( VAR_1 , TYPE_2 : : METHOD_3 ) || METHOD_2 ( VAR_1 , VAR_2 - > VAR_2 . METHOD_4 ( ) . METHOD_5 ( true ) . equals ( STRING_1 ) ) ; } 
<START> public static < TYPE_1 extends TYPE_2 < TYPE_1 > > TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) <END> { return VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } 
public Iterator < TYPE_5 . TYPE_6 > iterator ( ) { if ( METHOD_1 ( ) ) return Collections . VAR_1 ( ) ; return new TYPE_2 < TYPE_5 . TYPE_6 > ( ) { Iterator < TYPE_3 > VAR_2 = VAR_3 . iterator ( ) ; protected TYPE_5 . TYPE_6 METHOD_2 ( ) { if ( VAR_2 . hasNext ( ) ) <START> { <END> return new TYPE_4 ( VAR_2 . next ( ) ) ; } return METHOD_3 ( ) ; } } ; } 
public String toString ( ) { StringBuilder sb = new StringBuilder ( STRING_1 ) . append ( VAR_1 ) . append ( CHAR_1 ) ; for ( TYPE_1 VAR_2 : VAR_3 ) <START> { <END> sb . append ( VAR_2 . toString ( ) ) . append ( CHAR_1 ) ; } sb . append ( STRING_2 ) ; return sb . toString ( ) ; } 
private String METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 ) { StringBuilder sb = new StringBuilder ( ) ; if ( VAR_1 == null ) <START> { <END> sb . append ( STRING_1 ) ; } else if ( VAR_1 . METHOD_2 ( ) ) { sb . append ( STRING_2 ) ; } else { for ( TYPE_3 . TYPE_5 VAR_2 : VAR_1 ) { sb . append ( VAR_2 . toString ( ) ) ; } } return sb . toString ( ) ; } 
private Object METHOD_1 ( TYPE_1 type ) { for ( int VAR_1 = 0 ; VAR_1 < parameters . size ( ) ; VAR_1 += VAR_2 ) { <START> if ( ( ( TYPE_1 ) parameters . get ( VAR_1 + VAR_3 ) ) . equals ( type ) ) <END> { return parameters . get ( VAR_1 + VAR_4 ) ; } } return null ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> METHOD_3 ( VAR_1 . METHOD_4 ( 0 , VAR_1 . size ( ) > 1 ? 2 : 1 ) . METHOD_5 ( ) ) ; <END> if ( VAR_1 . size ( ) > 2 ) METHOD_6 ( VAR_1 . METHOD_4 ( 2 , VAR_1 . size ( ) ) . METHOD_5 ( ) ) ; VAR_2 . VAR_3 . VAR_4 . METHOD_7 ( ) ; } 
public static TYPE_1 create ( long VAR_1 , boolean VAR_2 ) { if ( VAR_1 < 0 ) <START> logger . warn ( STRING_1 + <END> STRING_2 ) ; if ( VAR_1 > 100 ) logger . warn ( STRING_3 , VAR_1 ) ; long VAR_3 = TimeUnit . VAR_4 . METHOD_1 ( VAR_1 ) ; return new TYPE_1 ( VAR_3 , VAR_2 ) ; } 
private static String METHOD_1 ( File file ) throws IOException { TYPE_1 in = new TYPE_2 ( new TYPE_3 ( file ) ) ; StringBuilder sb = new StringBuilder ( ) ; char [ ] VAR_1 = new char [ 1 < < INT_1 ] ; int length ; while ( ( length = in . read ( VAR_1 ) ) > 0 ) sb . append ( VAR_1 , 0 , length ) ; <START> in . close ( ) ; <END> return sb . toString ( ) ; } 
<START> ANNOTATION_1 private TYPE_1 METHOD_1 ( ) throws IOException { <END> File VAR_1 = File . VAR_2 ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_2 ( ) ; return new TYPE_1 ( VAR_1 , INT_1 * INT_1 ) ; } 
protected void METHOD_1 ( TYPE_1 file , String VAR_1 , String VAR_2 ) { <START> System . err . println ( STRING_1 ) ; <END> METHOD_2 ( file , VAR_1 , VAR_2 ) ; } 
public Map < String , ? > METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( STRING_1 ) ; <END> return VAR_1 . METHOD_4 ( ) ; } 
public TYPE_4 ( String VAR_2 , String project , TYPE_1 VAR_3 , TYPE_2 VAR_4 ) { this . VAR_3 = VAR_3 ; this . VAR_5 = String . format ( STRING_1 , VAR_2 , project ) ; this . VAR_6 = VAR_2 + STRING_2 + project ; <START> this . VAR_7 = new TYPE_3 ( ) ; <END> this . cache = VAR_4 ; } 
private void METHOD_1 ( ) { <START> System . VAR_1 ( null ) ; <END> } 
private void METHOD_1 ( TYPE_1 state ) { int VAR_1 = this . VAR_2 . size ( ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { <START> if ( this . VAR_2 . get ( i ) . METHOD_2 ( state ) ) { <END> this . VAR_3 [ i ] = true ; } } } 
public TYPE_7 ( String name , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( name , VAR_2 , new String [ ] { TYPE_5 . TYPE_4 , TYPE_3 . TYPE_4 , TYPE_6 . TYPE_4 } , VAR_3 ) ; <START> this . VAR_8 = null ; <END> } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { VAR_2 = true ; <START> VAR_3 . VAR_4 . Log . i ( TAG , STRING_1 ) ; <END> METHOD_2 ( ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { VAR_2 = false ; <START> VAR_3 . VAR_4 . Log . i ( TAG , STRING_1 ) ; <END> } 
protected final void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { if ( TYPE_2 . METHOD_2 ( context ) > 5 ) { TYPE_3 . getInstance ( context ) . METHOD_3 ( ) . add ( new TYPE_4 ( context ) ) ; throw new TYPE_5 ( STRING_1 ) ; } try { METHOD_4 ( ) ; TYPE_2 . METHOD_5 ( context , false ) ; <START> } catch ( Exception e ) { <END> TYPE_2 . METHOD_5 ( context , true ) ; throw e ; } } 
private static File METHOD_1 ( ) throws TYPE_1 { File VAR_1 = TYPE_2 . METHOD_1 ( ) ; File VAR_2 = new File ( TYPE_3 . METHOD_2 ( ) , STRING_1 ) ; <START> if ( ! VAR_1 . exists ( ) && VAR_2 . exists ( ) ) { <END> return VAR_2 ; } return VAR_1 ; } 
public static File METHOD_1 ( ) throws TYPE_1 { final File VAR_1 = TYPE_2 . METHOD_2 ( ) ; <START> if ( ! VAR_1 . METHOD_3 ( ) ) <END> throw new TYPE_1 ( ) ; return VAR_1 ; } 
int METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) / 4 ; return TYPE_1 . METHOD_3 ( VAR_2 ) == VAR_3 ? - VAR_1 : VAR_1 ; <START> } <END> 
public static void METHOD_1 ( Context context , boolean VAR_1 ) { METHOD_2 ( context , VAR_2 , VAR_1 ) ; if ( METHOD_3 ( context ) ) { METHOD_4 ( context , VAR_1 ) ; <START> } <END> } 
<START> public void METHOD_1 ( ) { <END> String VAR_1 = TYPE_1 . METHOD_2 ( context ) ; String VAR_2 = TYPE_1 . METHOD_3 ( context ) ; String VAR_3 = TYPE_1 . METHOD_4 ( context ) ; if ( ! VAR_1 . equals ( STRING_1 ) ) { String [ ] VAR_4 = METHOD_5 ( VAR_2 , VAR_3 ) ; METHOD_6 ( TYPE_2 . METHOD_7 ( VAR_1 ) , Integer . parseInt ( VAR_4 [ 0 ] ) , Integer . parseInt ( VAR_4 [ 1 ] ) ) ; } } 
protected void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( this ) ; <END> super . METHOD_1 ( ) ; } 
private synchronized void METHOD_1 ( ) { Log . VAR_1 ( TAG , STRING_1 , new Exception ( ) ) ; VAR_2 . METHOD_2 ( TYPE_2 . TYPE_3 . VAR_5 ) ; TYPE_1 . METHOD_3 ( this ) ; VAR_6 . METHOD_4 ( ) ; <START> if ( VAR_7 . METHOD_5 ( ) ) { <END> VAR_7 . METHOD_4 ( ) ; } if ( VAR_8 != null ) { VAR_8 . METHOD_1 ( ) ; VAR_8 = null ; } METHOD_6 ( ) ; state = VAR_9 ; VAR_2 . METHOD_2 ( TYPE_2 . TYPE_3 . VAR_10 ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 == null ) return ; try { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_1 = null ; } catch ( IllegalStateException e ) { } VAR_2 = - 1 ; } 
private String METHOD_1 ( String VAR_1 ) { if ( TYPE_1 . METHOD_2 ( context ) ) { return new TYPE_2 ( ) . filter ( VAR_1 ) ; } else { return VAR_1 ; } <START> } <END> 
private void METHOD_1 ( ) { List < TYPE_1 < T > > VAR_1 ; synchronized ( this ) { METHOD_2 ( ) ; VAR_1 = new TYPE_2 < > ( VAR_2 ) ; <START> } <END> for ( TYPE_1 < T > listener : VAR_1 ) { METHOD_3 ( listener ) ; } } 
private static String METHOD_1 ( ) { File VAR_1 = TYPE_1 . METHOD_2 ( ) ; <START> File VAR_2 = new File ( VAR_1 . METHOD_3 ( ) + File . VAR_3 , STRING_1 ) ; <END> if ( VAR_2 . exists ( ) ) { return VAR_1 . METHOD_3 ( ) + File . VAR_3 + STRING_1 ; } else { return VAR_1 . METHOD_3 ( ) + File . VAR_3 + STRING_2 ; } } 
<START> @Override protected void METHOD_1 ( ) { <END> super . METHOD_1 ( ) ; if ( VAR_1 != null ) VAR_1 . METHOD_2 ( this ) ; } 
private void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> METHOD_3 ( ) ; } 
<START> public static TYPE_1 METHOD_1 ( ANNOTATION_1 Context context , ANNOTATION_2 String VAR_1 ) { <END> if ( VAR_1 == null ) { return new TYPE_1 ( context , null ) ; } try { TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_1 ) ) ; return new TYPE_1 ( context , VAR_2 ) ; } catch ( IOException e ) { Log . VAR_3 ( TAG , e ) ; return new TYPE_1 ( context , null ) ; } } 
private String METHOD_1 ( ) throws TYPE_1 { String [ ] VAR_1 = uri . split ( STRING_1 ) [ 0 ] . split ( STRING_2 , 2 ) ; if ( VAR_1 . length < 2 || VAR_1 [ 1 ] . isEmpty ( ) ) { throw new TYPE_1 ( uri , STRING_3 ) ; <START> } else if ( VAR_1 [ 1 ] . contains ( STRING_4 ) ) { <END> return TYPE_2 . METHOD_2 ( VAR_1 [ 1 ] ) ; } else { return VAR_1 [ 1 ] ; } } 
protected final void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) ; final TYPE_2 VAR_2 = TYPE_3 . METHOD_3 ( this ) ; METHOD_4 ( VAR_2 ) ; super . METHOD_1 ( VAR_1 ) ; if ( ! METHOD_5 ( ) ) { <START> TYPE_4 . get ( this ) . METHOD_6 ( TYPE_5 . class , TYPE_6 . class , new TYPE_8 . TYPE_9 ( VAR_2 ) ) ; <END> METHOD_7 ( ) ; METHOD_1 ( VAR_1 , VAR_2 ) ; } } 
<START> public static TYPE_1 METHOD_1 ( Context context ) { <END> String VAR_1 [ ] = TYPE_2 . split ( TYPE_3 . METHOD_2 ( context ) , STRING_1 ) ; if ( VAR_1 [ 0 ] . equals ( VAR_2 ) ) { return TYPE_1 . METHOD_3 ( ) ; } else if ( VAR_1 . length == 2 ) { return new TYPE_1 ( VAR_1 [ 0 ] , VAR_1 [ 1 ] ) ; } else { return new TYPE_1 ( VAR_1 [ 0 ] ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> return ( VAR_1 != null ) ? VAR_1 : TYPE_1 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( View view , Context context , TYPE_1 VAR_1 ) { if ( VAR_2 != null && VAR_3 != null ) { <START> TYPE_5 . TYPE_6 reader = VAR_4 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <END> TYPE_3 record = reader . VAR_5 ( ) ; ( ( TYPE_4 ) view ) . set ( VAR_2 , record , VAR_6 , VAR_7 , VAR_8 ) ; } } 
private static TYPE_1 METHOD_1 ( Context context ) { final int VAR_1 = R . string . VAR_2 ; final String VAR_3 = context . getString ( R . string . TYPE_3 ) ; final String VAR_5 = context . getString ( R . string . TYPE_4 ) ; if ( TYPE_2 . METHOD_2 ( context ) ) return context . getString ( VAR_1 , VAR_5 ) ; <START> return context . getString ( VAR_1 , VAR_3 ) ; <END> } 
public TYPE_4 ( Context context , TYPE_1 VAR_2 , TYPE_2 record , TYPE_3 VAR_3 ) { <START> super ( ) ; <END> this . context = context ; this . VAR_2 = VAR_2 ; this . record = record ; this . VAR_3 = VAR_3 ; } 
<START> public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <END> TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_2 ( VAR_2 ) ; return TYPE_1 . METHOD_3 ( VAR_1 , 0 , 0 , VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , VAR_3 , true ) ; } 
public static byte [ ] METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == null ) return null ; <END> TYPE_2 stream = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( TYPE_1 . TYPE_3 . VAR_3 , 100 , stream ) ; return stream . VAR_4 ( ) ; } 
public void METHOD_1 ( TYPE_1 s ) { METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 item ) { switch ( item . VAR_1 ( ) ) { <START> case VAR_2 . R . id . VAR_3 : <END> METHOD_2 ( ) ; break ; case R . id . VAR_4 : METHOD_3 ( ) ; break ; } return super . METHOD_1 ( item ) ; } 
private void METHOD_1 ( ) { if ( ! TYPE_1 . METHOD_2 ( this , null , false ) ) { TYPE_2 . METHOD_3 ( this ) . METHOD_4 ( ) . METHOD_5 ( TYPE_4 . VAR_2 , true ) . commit ( ) ; METHOD_6 ( R . VAR_3 . VAR_4 ) ; this . METHOD_7 ( TYPE_4 . VAR_2 ) . METHOD_8 ( new TYPE_3 ( ) ) ; <START> } <END> else METHOD_6 ( R . VAR_3 . VAR_4 ) ; } 
private void METHOD_1 ( ) { new TYPE_1 < TYPE_2 , TYPE_2 , Boolean > ( ) { @Override protected Boolean METHOD_2 ( TYPE_2 ... params ) { return TYPE_3 . METHOD_3 ( TYPE_6 . this ) ; } @Override protected void METHOD_4 ( Boolean VAR_2 ) { TYPE_6 . VAR_3 . VAR_2 = VAR_2 ; } } . execute ( ) ; TYPE_4 VAR_4 = new TYPE_4 ( TYPE_5 . VAR_5 , null , this , TYPE_5 . class ) ; <START> METHOD_5 ( VAR_4 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { ( ( TYPE_2 ) METHOD_2 ( ) ) . METHOD_3 ( false ) ; <START> if ( VAR_2 != null ) { <END> VAR_2 = null ; VAR_3 = false ; } } 
private void METHOD_1 ( byte ... VAR_1 ) throws IOException { while ( ! METHOD_2 ( VAR_1 ) ) { <START> if ( stream . VAR_2 ( 1 ) == 0 ) return ; <END> } } 
<START> public Integer METHOD_1 ( ) { <END> int VAR_1 = 0 ; Integer [ ] VAR_2 = { METHOD_2 ( ) , METHOD_3 ( ) , METHOD_4 ( ) } ; for ( Integer VAR_3 : VAR_2 ) { if ( VAR_3 != null ) { VAR_1 += VAR_3 ; } } return VAR_1 ; } 
public int METHOD_1 ( ) { int VAR_1 = TYPE_1 . VAR_2 ; VAR_1 = TYPE_1 . METHOD_1 ( VAR_1 , this . METHOD_2 ( TimeUnit . VAR_3 ) ) ; <START> VAR_1 = TYPE_1 . METHOD_1 ( VAR_1 , TimeUnit . VAR_3 ) ; <END> return VAR_1 ; } 
public int METHOD_1 ( final TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { final TimeUnit VAR_2 = METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; return Long . VAR_3 ( METHOD_4 ( VAR_2 ) , VAR_1 . METHOD_4 ( VAR_2 ) ) ; } else { <START> return - Integer . VAR_4 ; <END> } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { <END> VAR_3 . add ( VAR_1 , VAR_2 ) ; } 
public int METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> Double VAR_3 = Double . valueOf ( VAR_1 != null ? VAR_1 : "" ) ; <END> Double VAR_4 = Double . valueOf ( VAR_2 != null ? VAR_2 : "" ) ; return VAR_3 . METHOD_2 ( VAR_4 ) ; } 
private void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( TYPE_2 . METHOD_2 ( "" ) ) ; <END> VAR_2 = new TYPE_1 ( "" ) ; VAR_1 . METHOD_3 ( TYPE_3 . create ( TYPE_4 . class , this , STRING_1 ) ) ; VAR_2 . METHOD_3 ( TYPE_3 . create ( TYPE_4 . class , this , STRING_2 ) ) ; VAR_2 . METHOD_4 ( true ) ; TYPE_5 VAR_3 = new TYPE_5 ( ) ; VAR_3 . add ( VAR_1 ) ; VAR_3 . add ( VAR_2 ) ; METHOD_5 ( ) ; } 
<START> TYPE_1 ( ) { <END> } 
public TYPE_1 [ ] METHOD_1 ( ) { return new TYPE_1 [ ] { <START> new TYPE_2 ( getType ( null ) , TYPE_3 . VAR_2 , <END> TYPE_3 . VAR_3 ) , new TYPE_2 ( getType ( null ) , TYPE_3 . VAR_2 , TYPE_3 . VAR_4 ) } ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) { <START> String value = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; <END> try { getValue ( value ) ; return true ; } catch ( TYPE_4 ex ) { LOGGER . error ( TYPE_5 . METHOD_3 ( STRING_1 ) , ex ) ; return false ; } catch ( Exception ex ) { LOGGER . error ( ex . VAR_2 ( ) , ex ) ; return false ; } } else { throw new IllegalArgumentException ( STRING_2 ) ; } } 
public TYPE_4 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; <START> TYPE_2 . METHOD_1 ( TYPE_1 . class , <END> TYPE_3 . METHOD_2 ( STRING_1 ) , VAR_2 ) ; } 
public void METHOD_1 ( ) { try { <START> TYPE_1 VAR_1 = ( TYPE_1 ) TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; <END> File file = new File ( VAR_1 . METHOD_3 ( ) + File . VAR_2 + TYPE_6 ) ; TYPE_3 VAR_4 = new TYPE_3 ( file ) ; for ( String server : VAR_5 ) { VAR_4 . println ( server ) ; } VAR_4 . close ( ) ; } catch ( TYPE_4 e ) { LOGGER . error ( TYPE_5 . METHOD_4 ( STRING_1 ) ) ; } } 
public Type METHOD_1 ( int VAR_1 ) { try { <START> return METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> } catch ( TYPE_1 e ) { return null ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 ; if ( VAR_3 . METHOD_2 ( ) || ! VAR_3 . METHOD_3 ( ) . isEmpty ( ) ) { <START> TYPE_1 VAR_4 = new TYPE_1 ( ) ; <END> for ( Integer VAR_5 : VAR_1 ) { int VAR_6 = table . VAR_7 ( VAR_5 ) ; if ( VAR_6 != - 1 ) { VAR_4 . add ( VAR_6 ) ; } } VAR_2 = VAR_4 ; } else { VAR_2 = VAR_1 ; } METHOD_4 ( VAR_2 ) ; } 
public static int METHOD_1 ( Type type ) { int VAR_1 = type . VAR_2 ( ) ; switch ( VAR_1 ) { case Type . VAR_3 : case Type . VAR_4 : return VAR_3 ; case Type . VAR_5 : case Type . VAR_6 : return VAR_7 ; case Type . VAR_8 : case Type . VAR_9 : return VAR_8 ; case Type . VAR_10 : case Type . VAR_11 : return VAR_12 ; } <START> throw new IllegalArgumentException ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } 
private void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = ( TYPE_1 ) TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; <END> try { File VAR_2 = new File ( VAR_1 . METHOD_3 ( ) + File . VAR_3 + VAR_4 ) ; if ( VAR_2 . exists ( ) ) { VAR_5 . METHOD_4 ( new TYPE_3 ( VAR_2 ) ) ; } } catch ( IOException e ) { LOGGER . error ( e ) ; } } 
private TYPE_1 METHOD_1 ( ) { <START> return ( TYPE_1 ) TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; <END> } 
public double METHOD_1 ( int VAR_1 ) { <START> return ( double ) ( 1 + ( FLOAT_1 * Math . VAR_2 ( VAR_1 ) ) ) ; <END> } 
public double METHOD_1 ( int VAR_1 ) { <START> return ( double ) ( FLOAT_1 * Math . VAR_2 ( VAR_1 , FLOAT_2 ) ) ; <END> } 
protected String METHOD_1 ( String VAR_1 ) { String res = VAR_1 ; <START> if ( ! VAR_1 . METHOD_2 ( STRING_1 ) && VAR_1 . contains ( STRING_2 ) ) { <END> String [ ] VAR_2 = VAR_1 . split ( STRING_2 ) ; if ( VAR_2 . length > 1 ) { res = VAR_2 [ 1 ] ; } } return res ; } 
private TYPE_1 METHOD_1 ( TYPE_2 request ) { <START> log . info ( STRING_1 ) ; <END> final TYPE_3 VAR_1 ; try { final TYPE_4 VAR_2 = METHOD_2 ( ) ; VAR_1 = VAR_2 . build ( ) ; VAR_1 . start ( ) ; } catch ( TYPE_5 e ) { throw new RuntimeException ( STRING_2 + VAR_3 . METHOD_3 ( ) + STRING_3 , e ) ; } return new TYPE_6 < TYPE_7 > ( VAR_1 , VAR_4 , VAR_5 ) ; } 
protected void METHOD_1 ( StringBuilder description , TYPE_1 VAR_1 , long VAR_2 ) { TYPE_2 VAR_3 = null ; <START> if ( ! StringUtils . VAR_4 ( VAR_1 . METHOD_2 ( ) ) ) { <END> VAR_3 = new TYPE_3 ( VAR_1 . METHOD_2 ( ) ) ; } else { VAR_3 = new TYPE_3 ( STRING_1 , TYPE_4 . METHOD_3 ( ) ) ; } Date VAR_5 = new Date ( VAR_2 ) ; String VAR_6 = VAR_3 . format ( VAR_5 ) ; description . append ( VAR_6 ) ; } 
public void METHOD_1 ( String VAR_1 ) { this . VAR_1 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> if ( this . VAR_1 != null ) { <END> this . VAR_2 = TYPE_2 . METHOD_3 ( this . VAR_1 ) ; } else { this . VAR_2 = null ; } } 
public Long METHOD_1 ( String VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; Long VAR_3 = INT_1 ; VAR_2 = this . METHOD_2 ( ) ; for ( TYPE_1 VAR_4 : VAR_2 ) { <START> LOGGER . VAR_5 ( STRING_1 + VAR_4 . getName ( ) + STRING_2 + VAR_4 . getId ( ) ) ; <END> if ( VAR_4 . getName ( ) . equalsIgnoreCase ( VAR_1 ) ) { VAR_3 = VAR_4 . getId ( ) ; break ; } } return VAR_3 ; } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( TYPE_1 . METHOD_3 ( STRING_1 ) ) ; TYPE_2 VAR_1 = ( ( TYPE_3 ) VAR_2 ) . METHOD_4 ( ) ; Date VAR_3 = VAR_1 . METHOD_5 ( TYPE_4 . valueOf ( STRING_2 ) . METHOD_6 ( ) , TYPE_1 . METHOD_7 ( ) ) ; <START> assertEquals ( new TYPE_5 ( INT_1 , TYPE_6 . VAR_5 , 10 ) . METHOD_6 ( ) , VAR_3 ) ; <END> } 
<START> public synchronized int read ( ) throws IOException { <END> if ( METHOD_1 ( 1 ) ) { return buffer [ index ++ ] & INT_1 ; } return - 1 ; } 
public int METHOD_1 ( ) { <START> return VAR_1 [ 0 ] ; <END> } 
private void METHOD_1 ( boolean VAR_1 , int VAR_2 ) throws TYPE_1 { if ( VAR_1 <START> && ( VAR_2 & TYPE_7 . VAR_4 ) == 1 <END> && METHOD_2 ( ) == TYPE_8 . VAR_6 && METHOD_3 ( ) == TYPE_4 . VAR_8 ) { try { METHOD_4 ( VAR_9 , TYPE_5 . VAR_11 , 1 , 0 , VAR_12 | VAR_13 | VAR_14 ) ; } catch ( IOException ex ) { throw new TYPE_2 ( TYPE_3 . METHOD_5 ( STRING_1 ) , TYPE_6 . VAR_16 ) ; } } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) throws IOException , TYPE_3 { TYPE_1 VAR_3 = null ; try { TYPE_4 VAR_4 = new TYPE_4 ( VAR_2 ) ; VAR_3 = ( TYPE_1 ) VAR_1 . METHOD_2 ( VAR_4 ) ; <START> VAR_4 . close ( ) ; <END> } catch ( TYPE_5 ex ) { } return VAR_3 ; } 
<START> public void set ( long VAR_1 , long VAR_2 ) { <END> this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> TYPE_2 . METHOD_2 ( VAR_1 ) ; <END> TYPE_3 . METHOD_3 ( VAR_2 , STRING_1 ) ; TYPE_3 . METHOD_4 ( VAR_2 ) ; } 
<START> private Set < Integer > METHOD_1 ( String VAR_1 ) throws TYPE_1 { <END> Set < Integer > VAR_2 = new HashSet < Integer > ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( VAR_1 , STRING_1 ) ; while ( VAR_3 . METHOD_2 ( ) ) { String VAR_4 = VAR_3 . METHOD_3 ( ) ; VAR_2 . add ( TYPE_3 . valueOf ( VAR_4 ) ) ; } return VAR_2 ; } 
public synchronized String toString ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_1 ( 0 ) ; <START> if ( VAR_1 == TYPE_1 . VAR_3 ) { <END> return STRING_1 ; } METHOD_2 ( VAR_2 , VAR_1 ) ; return VAR_2 . toString ( ) ; } 
public long [ ] METHOD_1 ( ) { long [ ] VAR_1 = METHOD_2 ( ) ; <START> return Arrays . VAR_2 ( VAR_1 , VAR_1 . length ) ; <END> } 
public int METHOD_1 ( int VAR_1 ) throws TYPE_1 { if ( VAR_1 == TYPE_4 . VAR_3 ) { return TYPE_3 . VAR_5 ; } <START> Integer VAR_6 = VAR_7 . get ( VAR_1 ) ; <END> if ( VAR_6 != null ) { return VAR_6 ; } TYPE_2 VAR_8 = METHOD_2 ( VAR_1 ) ; if ( VAR_8 == null ) { return TYPE_3 . VAR_5 ; } return VAR_8 . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> METHOD_2 ( ) ; <END> try ( TYPE_2 call = VAR_1 . METHOD_3 ( VAR_2 + VAR_3 + STRING_1 ) ) { call . VAR_4 ( 1 , TYPE_4 . VAR_6 ) ; call . execute ( ) ; assertEquals ( new TYPE_3 ( INT_1 ) , call . VAR_7 ( 1 , TYPE_3 . class ) ) ; } } 
public String get ( TYPE_1 properties ) { <START> return new org . VAR_1 . VAR_2 . TYPE_2 ( properties ) . getProperty ( VAR_4 , VAR_5 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { <START> if ( VAR_2 != null ) { <END> VAR_2 . close ( ) ; } this . VAR_1 = VAR_1 ; TYPE_2 VAR_3 = new TYPE_3 ( VAR_4 ) { @Override public void METHOD_2 ( ) throws IOException { } @Override public void close ( ) throws IOException { super . METHOD_2 ( ) ; } } ; VAR_2 = VAR_1 . METHOD_3 ( VAR_3 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( null ) ; TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; when ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( null ) ; <START> boolean VAR_3 = false ; <END> try { VAR_2 . METHOD_5 ( ) ; } catch ( TYPE_1 . TYPE_3 VAR_4 ) { VAR_3 = true ; } assertTrue ( VAR_3 ) ; } 
public static void METHOD_1 ( ) throws IOException { TYPE_1 . METHOD_2 ( new File ( VAR_1 ) ) ; <START> TYPE_2 . METHOD_3 ( false ) ; <END> TYPE_2 . METHOD_4 ( false ) ; } 
public void METHOD_1 ( TYPE_1 monitor ) throws TYPE_2 { super . METHOD_1 ( monitor ) ; final File VAR_1 = METHOD_2 ( ) ; <START> METHOD_3 ( VAR_1 , monitor ) ; <END> METHOD_4 ( METHOD_5 ( ) ) ; METHOD_6 ( VAR_1 , monitor ) ; final TYPE_3 resource = TYPE_4 . METHOD_7 ( METHOD_5 ( ) , monitor ) ; METHOD_8 ( resource , monitor ) ; } 
public TYPE_5 ( TYPE_1 action , TYPE_2 project ) { super ( TYPE_3 . bind ( STRING_1 , action == TYPE_1 . VAR_2 ? STRING_2 : STRING_3 , project . getName ( ) ) ) ; this . action = action ; this . project = project ; <START> METHOD_1 ( TYPE_4 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_4 . METHOD_2 ( ) . METHOD_5 ( ) ) ) ; <END> } 
private File METHOD_1 ( File VAR_1 ) { String [ ] VAR_2 = VAR_1 . list ( ) ; <START> VAR_2 = ( VAR_2 == null ? new String [ 0 ] : VAR_2 ) ; <END> for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { TYPE_1 m = TYPE_2 . matcher ( VAR_2 [ i ] ) ; if ( m . VAR_3 ( ) ) { return new File ( VAR_1 , VAR_2 [ i ] ) ; } } return null ; } 
public static String METHOD_1 ( String ... path ) { StringBuilder builder = new StringBuilder ( ) ; for ( String VAR_1 : path ) { builder . append ( STRING_1 + VAR_1 ) ; } String VAR_2 = "" ; <START> VAR_2 = System . getProperty ( STRING_2 ) ; <END> File file = new File ( VAR_2 + builder . toString ( ) ) ; if ( ! file . exists ( ) ) { throw new TYPE_1 ( STRING_3 + VAR_2 + builder . toString ( ) ) ; } return file . VAR_3 ( ) ; } 
private void METHOD_1 ( ) { if ( VAR_1 != null ) { String VAR_2 = TYPE_1 . getInstance ( ) . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { <END> VAR_3 . METHOD_3 ( ) ; VAR_3 . METHOD_4 ( TYPE_2 . METHOD_5 ( ) . METHOD_6 ( TYPE_2 . VAR_4 ) . METHOD_7 ( ) ) ; VAR_3 . METHOD_8 ( STRING_1 ) ; } else { VAR_3 . METHOD_9 ( ) ; } } } 
public TYPE_6 ( TYPE_1 server , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 , TYPE_5 VAR_5 ) { super ( server , STRING_1 ) ; this . VAR_6 = server ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; VAR_7 = ! VAR_2 . METHOD_1 ( ) ; <START> VAR_8 = VAR_3 . METHOD_2 ( ) ; <END> this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; } 
public boolean METHOD_1 ( TYPE_1 context , TYPE_2 monitor ) throws TYPE_3 { monitor . VAR_1 ( TYPE_4 . bind ( STRING_1 , VAR_2 ) ) ; TYPE_5 VAR_3 = METHOD_2 ( VAR_4 ) ; if ( VAR_3 == null ) { return false ; } int VAR_5 = VAR_3 . METHOD_3 ( ) ; <START> if ( VAR_5 >= VAR_2 ) { <END> TYPE_6 . METHOD_4 ( VAR_5 , context . VAR_6 ( ) ) ; return false ; } VAR_3 . METHOD_5 ( VAR_2 ) ; return true ; } 
public static String METHOD_1 ( TYPE_1 project ) throws TYPE_2 { if ( project == null ) { return null ; } <START> TYPE_3 repo = TYPE_4 . METHOD_2 ( project ) ; <END> if ( repo == null ) { return null ; } String VAR_1 = TYPE_4 . METHOD_1 ( repo ) ; repo . close ( ) ; return VAR_1 ; } 
public static boolean METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 ) { return VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . VAR_4 ) . stream ( ) . filter ( VAR_5 - > METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_5 . METHOD_6 ( ) ) ) . filter ( VAR_5 - > VAR_2 . getName ( ) . equals ( VAR_5 . METHOD_7 ( TYPE_4 . VAR_7 ) ) ) <START> . count ( ) > 0 ; <END> } 
public static String METHOD_1 ( String VAR_1 ) { if ( StringUtils . isEmpty ( VAR_1 ) ) { return null ; } String [ ] VAR_2 = VAR_1 . split ( String . valueOf ( VAR_3 ) ) ; if ( VAR_2 . length == 2 ) { return TYPE_1 . VAR_5 ; } else { <START> return VAR_2 [ 1 ] ; <END> } } 
private void METHOD_1 ( TYPE_1 project , TYPE_2 connection , String ... VAR_1 ) { <START> for ( String VAR_2 : VAR_3 ) { <END> TYPE_3 < TYPE_4 > VAR_4 = VAR_5 . remove ( new TYPE_5 ( connection , project , VAR_2 ) ) ; if ( ( VAR_4 != null ) && ( VAR_4 . get ( ) != null ) ) { VAR_4 . get ( ) . METHOD_2 ( ) ; } } } 
public TYPE_6 ( ) { listener = new TYPE_1 ( ) { @Override <START> public void METHOD_1 ( TYPE_2 < ? , ? > element ) { <END> if ( element instanceof TYPE_3 ) { METHOD_2 ( TYPE_4 . getInstance ( ) ) ; } else { METHOD_2 ( element ) ; } if ( element . VAR_2 ( ) instanceof TYPE_5 ) { VAR_3 . update ( element . VAR_4 ( ) , null ) ; } } } ; model . VAR_5 ( listener ) ; } 
private String METHOD_1 ( String VAR_1 ) { String VAR_2 = TYPE_7 . TYPE_8 ; <START> if ( TYPE_3 . TYPE_5 . equals ( VAR_1 ) ) { <END> VAR_2 = TYPE_7 . TYPE_9 ; } else if ( TYPE_3 . TYPE_4 . equals ( VAR_1 ) ) { VAR_2 = TYPE_7 . TYPE_6 ; } return VAR_2 ; } 
<START> public static TYPE_4 . TYPE_5 . VAR_1 . model . TYPE_2 METHOD_1 ( TYPE_3 resource ) { <END> TYPE_2 project = null ; if ( resource instanceof TYPE_2 ) { project = ( TYPE_2 ) resource ; } else if ( resource != null ) { project = resource . VAR_2 ( ) ; } return project ; } 
public TYPE_1 update ( TYPE_1 VAR_1 ) { Assert . VAR_2 ( VAR_1 instanceof TYPE_2 ) ; final TYPE_2 connection = ( TYPE_2 ) VAR_1 ; TYPE_3 . METHOD_1 ( ) . METHOD_2 ( new TYPE_4 ( ) { @Override public void run ( ) { connection . VAR_3 ( TYPE_5 . VAR_5 ) ; connection . VAR_6 ( ( String ) VAR_7 . getValue ( ) ) ; <START> connection . VAR_8 ( ( boolean ) VAR_9 . getValue ( ) ) ; <END> } } ) ; return connection ; } 
private TYPE_1 METHOD_1 ( Object VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_2 = new TYPE_1 ( ) ; <START> VAR_3 . put ( VAR_1 , VAR_2 ) ; <END> } return VAR_2 ; } 
TYPE_1 METHOD_1 ( final String name , final TYPE_2 VAR_1 ) { <START> return new TYPE_1 ( STRING_1 ) { <END> @Override protected TYPE_3 run ( TYPE_4 monitor ) { VAR_1 . METHOD_2 ( getName ( ) ) ; return Status . VAR_2 ; } } ; } 
private TYPE_1 METHOD_1 ( TYPE_2 server ) throws TYPE_3 { TYPE_4 VAR_1 = TYPE_5 . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_6 version = new TYPE_7 ( server ) . METHOD_4 ( ) ; if ( version != null ) { TYPE_8 VAR_2 = VAR_1 . METHOD_5 ( version ) ; <START> return new TYPE_9 ( this , server , VAR_2 ) ; <END> } return null ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; TYPE_1 . getInstance ( ) . METHOD_2 ( this ) ; ( ( TYPE_2 ) VAR_1 ) . METHOD_1 ( ) ; connection = null ; project = null ; VAR_2 = null ; VAR_3 . clear ( ) ; VAR_4 . clear ( ) ; VAR_5 . clear ( ) ; if ( VAR_6 != null ) { VAR_6 . clear ( ) ; <START> } <END> } 
public void METHOD_1 ( String VAR_1 ) throws TYPE_1 { METHOD_2 ( VAR_2 , true ) ; <START> } <END> 
protected boolean METHOD_1 ( ) { String VAR_1 = TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) ; if ( STRING_1 . equals ( VAR_1 ) ) { <START> return false ; <END> } return true ; } 
<START> default public boolean VAR_1 ( ) { <END> return false ; } 
public void METHOD_1 ( final TYPE_1 project ) { TYPE_2 < String , TYPE_3 > VAR_1 = new TYPE_4 < > ( ) ; if ( VAR_2 . METHOD_2 ( project , VAR_1 ) == null ) { <START> final TYPE_5 VAR_3 = TYPE_6 . METHOD_3 ( project ) ; <END> for ( String VAR_4 : VAR_5 ) { TYPE_7 listener = new TYPE_7 ( project , VAR_3 , VAR_4 , 0 , 0 ) ; METHOD_1 ( project , 0 , 0 , listener ) ; } } } 
protected void METHOD_1 ( final Object object ) { METHOD_2 ( new TYPE_1 ( ) { public void run ( ) { synchronized ( VAR_1 ) { final TYPE_2 [ ] VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( object != null ) { VAR_1 . METHOD_4 ( object ) ; } else { VAR_1 . METHOD_4 ( ) ; } <START> VAR_1 . METHOD_5 ( VAR_2 ) ; <END> } } } ) ; } 
private TYPE_1 METHOD_1 ( String host , String VAR_1 ) throws TYPE_2 { <START> HashMap < String , String > VAR_2 = new HashMap < String , String > ( ) ; <END> VAR_2 . put ( STRING_1 , STRING_2 + host + STRING_3 + VAR_1 ) ; VAR_2 . put ( STRING_4 , STRING_5 ) ; VAR_2 . put ( STRING_6 , STRING_7 ) ; VAR_2 . put ( STRING_8 , STRING_9 ) ; return new TYPE_1 ( VAR_2 ) ; } 
public static String METHOD_1 ( TYPE_1 build ) { final String VAR_1 = build . VAR_2 ( ) ; if ( TYPE_5 . TYPE_6 . equals ( VAR_1 ) || TYPE_3 . equals ( VAR_1 ) ) { return build . VAR_3 ( ) . METHOD_2 ( ) ; } <START> if ( TYPE_4 . equals ( VAR_1 ) ) { <END> return build . VAR_3 ( ) . METHOD_2 ( ) . toString ( ) ; } return "" ; } 
public Object execute ( TYPE_1 event ) throws TYPE_2 { try { TYPE_3 . METHOD_1 ( new TYPE_4 ( ) , TYPE_5 . METHOD_2 ( event ) ) ; <START> new TYPE_6 ( ) . execute ( event ) ; <END> } catch ( TYPE_7 e ) { return new Status ( Status . VAR_1 , TYPE_8 . VAR_3 , STRING_1 , e ) ; } return Status . VAR_4 ; } 
public TYPE_3 ( HashMap < String , String > VAR_2 ) throws TYPE_1 { this . VAR_2 = VAR_2 ; <START> String VAR_3 = VAR_2 . get ( STRING_1 ) ; <END> TYPE_2 url = new TYPE_2 ( VAR_3 ) ; String VAR_4 = url . VAR_5 ( ) ; VAR_6 = STRING_2 + VAR_4 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . size ( ) == 0 || VAR_1 . size ( ) > 1 ) { <END> METHOD_2 ( false ) ; return ; } METHOD_2 ( true ) ; synchronized ( this ) { METHOD_3 ( VAR_2 , VAR_1 ) ; VAR_2 = VAR_1 ; } super . METHOD_1 ( VAR_1 ) ; } 
public TYPE_3 ( TYPE_1 project ) { super ( ) ; VAR_2 = new TYPE_2 ( project ) ; <START> System . out . println ( this . METHOD_1 ( ) ) ; <END> } 
<START> public String [ ] METHOD_1 ( ) { <END> return ( String [ ] ) VAR_1 . METHOD_2 ( new String [ VAR_1 . size ( ) ] ) ; } 
public void run ( ) { while ( VAR_1 . METHOD_1 ( ) && ! METHOD_2 ( ) ) { String line = VAR_1 . METHOD_3 ( ) ; <START> VAR_2 . add ( line ) ; <END> } } 
<START> private void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { <END> for ( TYPE_1 build : VAR_1 ) { METHOD_2 ( build ) ; } } 
private void METHOD_1 ( TYPE_1 build ) { String VAR_1 = METHOD_2 ( build , project ) ; Collection < TYPE_2 > VAR_2 = VAR_3 . get ( VAR_1 ) ; <START> if ( VAR_3 . containsKey ( VAR_1 ) && VAR_2 != null ) { <END> for ( TYPE_2 VAR_4 : VAR_2 ) { METHOD_3 ( build , VAR_4 ) ; } } } 
<START> default TYPE_2 VAR_2 ( ) { <END> return TYPE_2 . of ( TYPE_3 . VAR_4 ( this ) . path ( ) , TYPE_1 . TYPE_4 . VAR_7 ) ; } 
<START> public boolean METHOD_1 ( ) { <END> return true ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 state , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { <START> if ( ( state . VAR_5 ( ) instanceof TYPE_6 && ( ( TYPE_6 ) state . VAR_5 ( ) ) . METHOD_2 ( state ) ) || state . VAR_5 ( ) instanceof TYPE_7 ) <END> { TYPE_6 . METHOD_3 ( state , VAR_2 , VAR_3 ) ; } return super . METHOD_1 ( VAR_1 , VAR_2 , state , VAR_3 , VAR_4 ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <END> TYPE_4 VAR_4 = new TYPE_4 ( ) ; int VAR_5 = VAR_4 . METHOD_2 ( 10 ) ; TYPE_1 VAR_6 = new TYPE_1 ( TYPE_6 . VAR_8 , VAR_5 ) ; if ( VAR_3 instanceof TYPE_5 && ! VAR_3 . VAR_9 . VAR_10 ) { TYPE_5 VAR_11 = ( TYPE_5 ) VAR_3 ; VAR_11 . METHOD_3 ( VAR_6 ) ; } return super . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; } 
<START> public static void METHOD_1 ( String VAR_1 ) throws IOException { <END> File file = new File ( VAR_1 ) ; if ( file . VAR_2 ( ) ) { LOGGER . log ( Level . VAR_3 , file . getName ( ) + STRING_1 ) ; } else { LOGGER . log ( Level . VAR_4 , file . getName ( ) + STRING_2 ) ; } } 
protected void METHOD_1 ( int VAR_1 , boolean VAR_2 ) { <START> if ( VAR_2 ) { <END> this . VAR_1 = VAR_1 ; } } 
<START> public String METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; return METHOD_3 ( VAR_2 ) ; } 
public static String METHOD_1 ( TYPE_1 VAR_1 , Object [ ] args ) { <START> String VAR_2 ; <END> try { VAR_2 = args [ 0 ] . toString ( ) ; } catch ( Throwable t ) { throw new TYPE_2 ( STRING_1 ) ; } return VAR_1 . VAR_3 . METHOD_2 ( ) + STRING_2 + VAR_2 ; } 
public List < TYPE_1 > METHOD_1 ( ) throws IOException { try { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; for ( String VAR_2 : VAR_3 . METHOD_2 ( ) ) { VAR_1 . add ( TYPE_2 . METHOD_3 ( VAR_2 ) ) ; } return VAR_1 ; <START> } catch ( TYPE_3 e ) { <END> throw TYPE_4 . METHOD_4 ( e ) ; } } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { try { VAR_1 = ( ( TYPE_2 ) VAR_2 ) . METHOD_2 ( ) ; } catch ( IOException e ) { <START> throw new IOException ( STRING_1 , e ) ; <END> } } 
public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 ) throws IOException { String result ; <START> try { <END> result = METHOD_1 ( new TYPE_3 ( VAR_3 , VAR_1 , VAR_2 ) ) ; return result ; } catch ( TYPE_4 e ) { throw TYPE_5 . METHOD_2 ( e ) ; } } 
public boolean METHOD_1 ( String VAR_1 ) throws IOException { TYPE_1 request = new TYPE_1 ( ) ; request . VAR_2 ( VAR_1 ) ; TYPE_2 VAR_3 ; try { <START> VAR_3 = METHOD_2 ( request ) ; <END> } catch ( TYPE_3 e ) { throw TYPE_4 . METHOD_3 ( e ) ; } return VAR_3 != null ; } 
public TYPE_2 ( ANNOTATION_1 ( STRING_1 ) String status , ANNOTATION_1 ( STRING_2 ) Date VAR_2 , ANNOTATION_1 ( STRING_3 ) TYPE_1 VAR_3 , ANNOTATION_1 ( STRING_4 ) String VAR_4 , ANNOTATION_1 ( STRING_5 ) String VAR_5 , ANNOTATION_1 ( STRING_6 ) String VAR_6 ) { super ( status , VAR_5 , VAR_6 , VAR_3 ) ; this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; <START> METHOD_1 ( ) . METHOD_2 ( VAR_2 ) ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = VAR_2 . METHOD_2 ( ) . get ( METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ) ; TYPE_5 VAR_4 = VAR_1 . getType ( ) == TYPE_6 . VAR_6 ? VAR_3 . METHOD_5 ( ) : VAR_3 . METHOD_6 ( ) ; <START> return TYPE_1 . Builder . from ( VAR_1 ) . METHOD_7 ( VAR_4 ) . METHOD_8 ( new Date ( ) ) . build ( ) ; <END> } 
public void METHOD_1 ( ) throws TYPE_1 { List < Integer > VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> System . out . println ( VAR_1 ) ; <END> Assert . assertEquals ( STRING_1 , INT_1 , VAR_1 . size ( ) ) ; Assert . assertTrue ( STRING_2 , VAR_1 . METHOD_4 ( Arrays . asList ( 5 , 2 , INT_2 , 4 , 1 , INT_1 , 3 ) ) ) ; } 
public List < Integer > METHOD_1 ( ) throws TYPE_1 { <START> List < Map < String , Object > > VAR_1 = METHOD_2 ( ) ; List < Integer > VAR_2 = new ArrayList < > ( ) ; for ( Map < String , Object > VAR_3 : VAR_1 ) { <END> VAR_2 . add ( Integer . parseInt ( ( String ) VAR_3 . get ( STRING_1 ) ) ) ; } return VAR_2 ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> try { TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( ) . METHOD_4 ( VAR_1 . getId ( ) ) ) ; VAR_2 . METHOD_1 ( ) ; } catch ( TYPE_4 e ) { TYPE_5 . METHOD_5 ( STRING_1 , VAR_3 ) ; } VAR_4 . remove ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 task ) { <START> METHOD_1 ( Arrays . asList ( ) ) ; <END> } 
public static List < TYPE_1 > METHOD_1 ( ) throws TYPE_2 , TYPE_3 , IOException { <START> final TYPE_4 VAR_1 = TYPE_5 . METHOD_2 ( ) ; <END> final TYPE_6 VAR_2 = TYPE_5 . METHOD_3 ( ) ; final TYPE_7 VAR_3 = TYPE_5 . METHOD_4 ( ) ; List < TYPE_1 > VAR_4 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_5 : VAR_1 . METHOD_5 ( ) ) { if ( METHOD_6 ( VAR_5 , VAR_2 , VAR_3 ) ) { VAR_4 . add ( VAR_5 ) ; } } return VAR_4 ; } 
public String METHOD_1 ( String VAR_1 ) { VAR_2 = VAR_1 ; TYPE_1 . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ; <START> return this . VAR_3 ; <END> } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) && VAR_1 . METHOD_3 ( ) instanceof View <END> && TYPE_2 . METHOD_2 ( ( ( View ) VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( ) ) ) { return VAR_2 . METHOD_5 ( ( ( View ) VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( ) ) ; } return - 1 ; } 
public boolean METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) && VAR_1 . METHOD_3 ( ) instanceof TYPE_2 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 . METHOD_3 ( ) ; <START> if ( TYPE_1 . METHOD_2 ( VAR_2 . METHOD_4 ( ) ) && VAR_2 . METHOD_4 ( ) instanceof View ) { <END> View view = ( View ) VAR_2 . METHOD_4 ( ) ; return view . VAR_3 ( ) . METHOD_5 ( ) . size ( ) > 1 ; } } return false ; } 
public boolean METHOD_1 ( ) { <START> return this . VAR_1 . getId ( ) < 0 || ! METHOD_2 ( ) . isEmpty ( ) ; <END> } 
public Date METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) && TYPE_1 . METHOD_3 ( getValue ( ) ) ) { try { VAR_1 = new TYPE_2 ( STRING_1 ) . parse ( getValue ( ) ) ; } catch ( TYPE_3 e ) { <START> logger . error ( e . VAR_2 ( ) ) ; <END> } } return VAR_1 ; } 
public List < TYPE_1 > METHOD_1 ( int VAR_1 , int VAR_2 , String VAR_3 , TYPE_2 VAR_4 , Map VAR_5 ) throws TYPE_3 { <START> String filter = "" ; <END> try { filter = TYPE_4 . METHOD_2 ( ) . METHOD_3 ( VAR_5 ) ; } catch ( IllegalArgumentException e ) { logger . error ( e . getMessage ( ) ) ; } return METHOD_4 ( METHOD_5 ( filter ) , METHOD_6 ( VAR_3 , VAR_4 ) , VAR_1 , VAR_2 , false ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 uri = VAR_1 . METHOD_2 ( ) ; try ( TYPE_3 out = TYPE_4 . METHOD_3 ( ) . write ( uri , VAR_1 . METHOD_4 ( ) ) ) { logger . info ( STRING_1 , uri . toString ( ) ) ; <START> VAR_2 . METHOD_1 ( VAR_1 . METHOD_5 ( ) , out ) ; <END> } } 
<START> public TYPE_2 ( ) { <END> super ( new TYPE_1 ( ) ) ; } 
public static TYPE_1 getInstance ( ) { if ( TYPE_2 . equals ( instance , null ) ) { <START> synchronized ( TYPE_3 . class ) { <END> if ( TYPE_2 . equals ( instance , null ) ) { instance = new TYPE_1 ( ) ; } } } return instance ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , Map < TYPE_3 , TYPE_4 > VAR_2 , <START> Map < TYPE_2 , String > VAR_3 , TYPE_5 VAR_4 ) { <END> TYPE_1 VAR_5 = new TYPE_6 ( VAR_1 ) . METHOD_2 ( VAR_2 , VAR_3 , VAR_4 ) ; for ( TYPE_2 child : VAR_1 . METHOD_3 ( ) ) { VAR_5 . METHOD_4 ( ) . add ( new TYPE_6 ( child ) . METHOD_2 ( VAR_2 , VAR_3 , VAR_4 ) ) ; } return VAR_5 ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 , String field , String VAR_2 , int VAR_3 ) { <END> METHOD_2 ( VAR_1 ) ; HashMap < String , String > VAR_4 = new HashMap < > ( ) ; VAR_4 . put ( field , VAR_2 ) ; return METHOD_1 ( VAR_1 , VAR_4 , VAR_3 ) ; } 
<START> public List < String > METHOD_1 ( String VAR_1 ) throws IllegalArgumentException { <END> try { TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; List < String > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_4 : VAR_2 . METHOD_3 ( STRING_1 ) ) { VAR_3 . add ( VAR_4 . getString ( STRING_2 ) ) ; } return VAR_3 ; } catch ( IllegalArgumentException e ) { logger . error ( e . VAR_5 ( ) ) ; throw new IllegalArgumentException ( STRING_3 + VAR_1 + STRING_4 ) ; } } 
<START> public List < String > METHOD_1 ( ) throws IllegalArgumentException { <END> try { return TYPE_1 . METHOD_2 ( ) ; } catch ( IllegalArgumentException e ) { logger . error ( e . VAR_1 ( ) ) ; throw new IllegalArgumentException ( STRING_1 ) ; } } 
void METHOD_1 ( TYPE_1 VAR_1 , List < ? extends TYPE_2 > list ) { if ( TYPE_3 . METHOD_2 ( this . id ) && ! TYPE_4 . METHOD_3 ( list ) ) { try { <START> TYPE_4 . METHOD_1 ( list ) ; <END> } catch ( TYPE_5 e ) { VAR_1 . METHOD_1 ( this , list ) ; } } } 
<START> public TYPE_2 ( Optional < TYPE_1 > VAR_2 , Collection < T > values ) { <END> this . VAR_2 = VAR_2 ; this . values = values ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
public TYPE_2 ( Map < TYPE_1 , Collection < String > > VAR_2 ) { <START> assert ! VAR_2 . isEmpty ( ) : STRING_1 ; <END> this . VAR_2 = VAR_2 ; } 
private void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { String VAR_2 = STRING_1 ; <START> String VAR_3 = VAR_1 . METHOD_2 ( ) . filter ( uri - > TYPE_2 . METHOD_3 ( uri ) ) <END> . map ( uri - > uri . toString ( ) ) . collect ( Collectors . VAR_4 ( STRING_2 , VAR_2 , "" ) ) ; if ( VAR_3 . length ( ) > VAR_2 . length ( ) ) { throw new IllegalStateException ( VAR_3 ) ; } } 
void close ( String user , Map < TYPE_1 , TYPE_2 > VAR_1 ) { synchronized ( this ) { METHOD_1 ( VAR_1 . keySet ( ) ) ; <START> VAR_1 . entrySet ( ) . METHOD_2 ( ) . map ( entry - > entry . getKey ( ) ) <END> . METHOD_3 ( uri - > METHOD_4 ( user , VAR_1 . get ( uri ) , uri ) ) . forEach ( uri - > VAR_2 . METHOD_5 ( uri , user ) ) ; } } 
public TYPE_1 METHOD_1 ( ) throws Exception { if ( METHOD_2 ( ) ) { METHOD_3 ( ) ; } <START> METHOD_4 ( VAR_1 , TYPE_2 . METHOD_5 ( ) . METHOD_6 ( ) ) ; <END> return TYPE_2 . METHOD_7 ( ) ; } 
public static List < String > METHOD_1 ( TYPE_1 table , int VAR_1 ) { List < TYPE_1 > VAR_2 = METHOD_2 ( table ) ; List < String > data = new ArrayList < > ( ) ; for ( TYPE_1 row : VAR_2 ) { data . add ( METHOD_3 ( row , VAR_1 ) ) ; <START> System . out . println ( METHOD_3 ( row , VAR_1 ) ) ; <END> } return data ; } 
public List < String > METHOD_1 ( ) throws Exception { int index = METHOD_2 ( VAR_1 , STRING_1 ) ; <START> Thread . VAR_2 ( INT_1 ) ; <END> TYPE_1 VAR_3 = TYPE_2 . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . id ( VAR_4 + STRING_2 + index + STRING_3 ) ) ; Thread . VAR_2 ( INT_1 ) ; return new ArrayList < > ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 , IOException , TYPE_2 , TYPE_3 { TYPE_4 VAR_1 = new TYPE_4 ( VAR_2 , VAR_3 ) ; TYPE_5 VAR_4 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_5 VAR_5 = VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) . get ( 1 ) . METHOD_3 ( ) ; TYPE_6 writer = new TYPE_6 ( ) ; <START> System . out . println ( writer . VAR_6 ( VAR_1 . METHOD_4 ( ) ) ) ; <END> Assert . assertEquals ( STRING_1 , VAR_4 , VAR_5 ) ; } 
for ( String VAR_1 : VAR_2 ) { <START> if ( name . VAR_3 ( VAR_1 ) ) { <END> VAR_4 = true ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 task ) { if ( ( VAR_1 . getValue ( ) == null || VAR_1 . getValue ( ) . equals ( "" ) ) ) { List < String > VAR_2 = new ArrayList < > ( ) ; VAR_2 . add ( VAR_1 . METHOD_2 ( ) ) ; VAR_2 . add ( task . VAR_3 ( ) . METHOD_2 ( ) ) ; <START> TYPE_3 . METHOD_3 ( TYPE_3 . METHOD_4 ( STRING_1 , VAR_2 ) ) ; <END> return true ; } return false ; } 
private void METHOD_1 ( TYPE_1 node ) { Collection < TYPE_2 > VAR_1 = node . VAR_2 ( ) ; <START> TYPE_1 VAR_3 = VAR_1 . iterator ( ) . next ( ) . METHOD_2 ( ) ; <END> if ( VAR_3 instanceof TYPE_3 ) { METHOD_3 ( ( TYPE_3 ) VAR_3 ) ; } else if ( VAR_3 instanceof TYPE_4 ) { this . VAR_4 . add ( VAR_3 ) ; METHOD_1 ( VAR_3 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 ) throws IOException { try { TYPE_3 VAR_4 = METHOD_2 ( VAR_1 , true ) ; TYPE_4 VAR_5 = new TYPE_4 ( ) ; VAR_5 . METHOD_3 ( TYPE_5 . METHOD_4 ( ) ) ; VAR_5 . output ( VAR_4 , VAR_2 ) ; VAR_2 . close ( ) ; } catch ( IOException | RuntimeException e ) { <START> throw new IOException ( e . getMessage ( ) , e ) ; <END> } } 
<START> List < TYPE_1 > METHOD_1 ( boolean VAR_1 , boolean VAR_2 , String VAR_3 , Integer offset , Integer size ) <END> throws TYPE_2 { TYPE_3 query = new TYPE_3 ( ) ; query . VAR_4 ( METHOD_2 ( VAR_1 ) ) ; query . VAR_4 ( METHOD_3 ( VAR_2 ) ) ; return VAR_5 . METHOD_4 ( query . toString ( ) , VAR_3 , offset , size ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; int VAR_1 = VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) . size ( ) ; int VAR_3 = TYPE_1 . METHOD_6 ( ) . METHOD_7 ( ) ; <START> Thread . VAR_4 ( INT_1 ) ; <END> Assert . assertEquals ( STRING_1 , VAR_1 , VAR_3 ) ; } 
public Long METHOD_1 ( String query ) throws TYPE_1 { TYPE_2 VAR_1 = METHOD_2 ( ) ; String response = VAR_1 . METHOD_1 ( METHOD_3 ( query ) ) ; if ( ! response . equals ( "" ) ) { <START> TYPE_3 VAR_2 = TYPE_4 . METHOD_4 ( new TYPE_5 ( response ) ) ; <END> TYPE_6 result = VAR_2 . METHOD_5 ( ) ; return result . VAR_3 ( STRING_1 ) . METHOD_6 ( ) ; } else { return INT_1 ; } } 
public TYPE_1 METHOD_1 ( Integer id ) throws TYPE_2 { TYPE_3 VAR_1 = METHOD_2 ( ) ; String response = VAR_1 . METHOD_3 ( id ) ; if ( ! response . equals ( "" ) ) { <START> TYPE_4 VAR_2 = TYPE_5 . METHOD_4 ( new TYPE_6 ( response ) ) ; <END> return VAR_2 . METHOD_5 ( ) ; } else { return TYPE_5 . METHOD_6 ( ) . build ( ) ; } } 
public TYPE_1 METHOD_1 ( String query , String VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = METHOD_2 ( ) ; String response = VAR_2 . METHOD_1 ( METHOD_3 ( query ) , VAR_1 ) ; if ( ! response . equals ( "" ) ) { <START> TYPE_4 VAR_3 = TYPE_5 . METHOD_4 ( new TYPE_6 ( response ) ) ; <END> TYPE_1 result = VAR_3 . METHOD_5 ( ) ; return result . VAR_4 ( STRING_1 ) ; } else { return TYPE_5 . METHOD_6 ( ) . build ( ) ; } } 
private void METHOD_1 ( String VAR_1 , TYPE_1 task ) { try { VAR_2 . METHOD_2 ( ) . METHOD_3 ( task ) ; } catch ( TYPE_2 e ) { <START> TYPE_3 . METHOD_4 ( VAR_3 , STRING_1 + VAR_1 , e ) ; <END> logger . error ( VAR_3 + STRING_1 + VAR_1 , e ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; for ( TYPE_2 VAR_2 : ( List < TYPE_2 > ) this . page . VAR_3 ( ) ) { try { VAR_1 . METHOD_2 ( VAR_2 ) ; } catch ( Exception e ) { TYPE_3 . METHOD_3 ( STRING_1 , logger , e ) ; } } <START> TYPE_3 . METHOD_4 ( null , STRING_2 , "" ) ; <END> logger . info ( TYPE_3 . METHOD_5 ( STRING_2 ) ) ; } 
protected void METHOD_1 ( ) { try { this . user . addAll ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ; } catch ( RuntimeException VAR_2 ) { <START> TYPE_1 . METHOD_4 ( STRING_1 , new String [ ] { TYPE_1 . METHOD_5 ( STRING_2 ) } ) ; <END> logger . warn ( STRING_3 ) ; } } 
public ArrayList < TYPE_1 > METHOD_1 ( ) { if ( TYPE_2 . METHOD_2 ( VAR_1 ) ) { <START> return new ArrayList < > ( ) ; <END> } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 node ) { <START> List < ? extends TYPE_1 > VAR_1 = node . VAR_2 ( VAR_3 ) ; <END> for ( TYPE_1 VAR_4 : VAR_1 ) { if ( VAR_3 . getName ( ) . equals ( VAR_4 . METHOD_2 ( ) . getName ( ) ) ) { return VAR_4 ; } } return null ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) <START> throws TYPE_4 , TYPE_5 , TYPE_6 { <END> TYPE_7 VAR_3 = TYPE_12 . TYPE_13 . METHOD_2 ( VAR_2 ) ; VAR_3 . read ( VAR_1 ) ; TYPE_9 VAR_4 = VAR_3 . METHOD_3 ( ) ; TYPE_1 VAR_5 = TYPE_12 . TYPE_13 . METHOD_4 ( VAR_2 ) ; VAR_5 . METHOD_5 ( VAR_4 ) ; TYPE_10 VAR_6 = VAR_2 . METHOD_6 ( STRING_1 ) ; TYPE_11 VAR_7 = VAR_4 . METHOD_7 ( VAR_6 ) ; VAR_4 . METHOD_8 ( VAR_7 ) ; return VAR_5 ; } 
public boolean equals ( Object o ) { <START> if ( this == o ) <END> return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 VAR_1 = ( TYPE_1 ) o ; return VAR_2 != null ? VAR_2 . equals ( VAR_1 . VAR_2 ) : VAR_1 . VAR_2 == null ; } 
private TYPE_1 ( String name ) { <START> this . name = name ; <END> } 
private Type ( String name ) { <START> this . name = name ; <END> } 
private String METHOD_1 ( String VAR_1 ) { try { String VAR_2 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . get ( STRING_1 ) ; String VAR_3 = VAR_2 . substring ( VAR_2 . METHOD_5 ( STRING_2 ) + 1 ) ; if ( ! VAR_3 . isEmpty ( ) && VAR_3 . contains ( STRING_3 ) ) { return STRING_4 + VAR_1 ; } else { return STRING_5 + VAR_1 ; } } catch ( TYPE_2 e ) { <START> return STRING_6 + VAR_1 ; <END> } } 
public TYPE_1 [ ] METHOD_1 ( ) { switch ( VAR_1 ) { case VAR_2 : case VAR_3 : return this . VAR_4 . METHOD_2 ( this . VAR_5 , true ) ; case VAR_6 : case VAR_7 : return this . VAR_4 . METHOD_2 ( this . VAR_5 , false ) ; default : logger . error ( STRING_1 ) ; <START> return null ; <END> } } 
<START> private TYPE_1 METHOD_1 ( ) { <END> while ( true ) { if ( ( VAR_1 == null ) || ! VAR_1 . hasNext ( ) ) { if ( VAR_2 . hasNext ( ) ) { VAR_1 = VAR_2 . next ( ) . getValue ( ) . iterator ( ) ; } else { return null ; } } while ( VAR_1 . hasNext ( ) ) { return VAR_1 . next ( ) ; } } } 
public static Boolean METHOD_1 ( TYPE_1 VAR_1 ) { Boolean VAR_2 ; try { VAR_2 = METHOD_2 ( VAR_1 ) ; VAR_2 = METHOD_3 ( VAR_1 ) ; } catch ( Exception ex ) { logger . warn ( STRING_1 , ex ) ; <START> logger . error ( ex . VAR_3 ( ) ) ; <END> VAR_2 = false ; } return VAR_2 ; } 
public File METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { TYPE_3 VAR_3 = new TYPE_3 ( ) ; File file = new File ( STRING_1 ) ; TYPE_4 VAR_4 = new TYPE_4 ( file ) ; <START> try { <END> VAR_3 . METHOD_2 ( VAR_1 , VAR_4 , new File ( VAR_2 ) ) ; } catch ( IOException e ) { throw new IOException ( e . getMessage ( ) ) ; } finally { VAR_4 . METHOD_3 ( ) ; VAR_4 . close ( ) ; } return file ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( ) ; File file = new File ( STRING_1 ) ; TYPE_2 VAR_2 = new TYPE_2 ( file ) ; File VAR_3 = new File ( STRING_2 ) ; <START> try { <END> VAR_1 . METHOD_2 ( VAR_4 . METHOD_3 ( STRING_3 , STRING_4 , STRING_5 ) , VAR_2 , VAR_3 ) ; } catch ( IOException e ) { throw new IOException ( e . getMessage ( ) ) ; } finally { VAR_2 . close ( ) ; } } 
public Long METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) != 0 ) { return VAR_2 != null ? VAR_2 / VAR_1 . METHOD_2 ( ) : null ; } else { <START> return null ; <END> } } 
public boolean METHOD_1 ( ) { <START> return ( this . VAR_1 ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , IOException { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_1 . METHOD_3 ( ) == TYPE_4 . VAR_4 ) { <END> if ( VAR_2 != null ) { VAR_2 . METHOD_4 ( ) . remove ( VAR_1 ) ; VAR_5 . METHOD_5 ( ) . METHOD_6 ( VAR_2 ) ; } } else { if ( VAR_2 != null ) { VAR_5 . METHOD_5 ( ) . METHOD_6 ( VAR_2 ) ; } } } 
< TYPE_1 extends TYPE_2 > TYPE_3 METHOD_1 ( List < TYPE_1 > VAR_1 ) { TYPE_3 VAR_2 = new TYPE_3 ( ) ; <START> if ( VAR_1 != null && VAR_1 . size ( ) > 0 ) { <END> for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_2 . add ( METHOD_2 ( VAR_3 . getId ( ) ) ) ; } } return VAR_2 ; } 
private boolean METHOD_1 ( ) { if ( this . VAR_1 . METHOD_2 ( ) ) { return true ; } else { List < String > VAR_2 = new ArrayList < String > ( ) ; VAR_2 . add ( VAR_1 . getName ( ) ) ; <START> String value = TYPE_1 . METHOD_3 ( STRING_1 , VAR_2 ) ; <END> TYPE_1 . METHOD_4 ( value ) ; TYPE_1 . METHOD_4 ( STRING_2 + this . VAR_1 . getName ( ) + STRING_3 ) ; return false ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; long VAR_2 = VAR_1 . METHOD_2 ( ) . count ( STRING_1 ) ; Assert . assertNotNull ( STRING_2 , VAR_2 ) ; Assert . assertEquals ( 4 , VAR_2 ) ; String VAR_3 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( 1 ) . METHOD_4 ( ) ; <START> Assert . assertEquals ( STRING_3 , VAR_3 ) ; <END> } 
public static String METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> } 
<START> public int METHOD_1 ( ) { <END> if ( this . METHOD_2 ( ) == null ) { return 0 ; } else { return this . METHOD_2 ( ) . size ( ) ; } } 
<START> public void METHOD_1 ( long VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
public TYPE_3 ( ) { <START> this . container = new Integer ( 0 ) ; <END> this . value = "" ; this . VAR_2 = new ArrayList < String > ( ) ; this . VAR_3 = new ArrayList < String > ( ) ; this . VAR_4 = new ArrayList < TYPE_1 > ( ) ; this . VAR_5 = new TYPE_2 ( ) ; } 
public void METHOD_1 ( final TYPE_1 stream , final int VAR_1 , final TYPE_2 config ) throws TYPE_3 , IOException { super . METHOD_1 ( stream , VAR_1 , config ) ; <START> if ( METHOD_2 ( ) . length ( ) == 0 ) { METHOD_3 ( ) ; } <END> } 
public void close ( ) throws IOException { <START> if ( METHOD_1 ( ) != null ) { METHOD_2 ( ) ; } <END> super . close ( ) ; } 
public void METHOD_1 ( TYPE_1 n ) { <START> n . VAR_1 ( STRING_1 , ( byte ) getType ( ) . METHOD_2 ( ) ) ; <END> super . METHOD_1 ( n ) ; } 
public void METHOD_1 ( TYPE_1 event ) { if ( TYPE_2 . METHOD_2 ( ) . VAR_1 != null && ! TYPE_2 . METHOD_2 ( ) . VAR_1 . VAR_2 ) { if ( TYPE_2 . METHOD_2 ( ) . VAR_3 . VAR_4 == 0 || TYPE_2 . METHOD_2 ( ) . VAR_5 != null ) { TYPE_3 p = TYPE_2 . METHOD_2 ( ) . VAR_1 ; <START> if ( ! p . VAR_6 ( ) ) <END> METHOD_3 ( p ) ; METHOD_4 ( p ) ; } } } 
public void METHOD_1 ( TYPE_1 VAR_1 , double d , double VAR_2 , double VAR_3 , float f , float VAR_4 ) { if ( VAR_5 && VAR_1 . VAR_6 % INT_1 == 0 ) { <START> this . VAR_7 = new TYPE_2 ( ) ; <END> this . VAR_8 = new TYPE_2 ( ) ; VAR_5 = false ; } this . METHOD_2 ( ( TYPE_1 ) VAR_1 , d , VAR_2 , VAR_3 , VAR_4 ) ; } 
public void METHOD_1 ( ) { if ( ! VAR_1 . VAR_2 ) { <START> if ( METHOD_2 ( ) . length > 0 ) { <END> METHOD_3 ( METHOD_2 ( ) [ VAR_3 . METHOD_4 ( METHOD_2 ( ) . length ) ] ) ; } } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( STRING_1 ) ; if ( VAR_2 != null && VAR_2 . equals ( STRING_2 ) ) { return true ; } String VAR_3 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( STRING_3 ) ; <START> if ( VAR_3 != null && VAR_3 . equals ( STRING_2 ) ) { return true ; } return false ; <END> } 
<START> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <END> return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) , VAR_1 . METHOD_5 ( VAR_2 . METHOD_4 ( ) ) , VAR_1 . METHOD_3 ( VAR_2 . METHOD_6 ( ) ) , VAR_1 . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ) ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> METHOD_2 ( VAR_1 ) ; this . VAR_1 = VAR_1 ; return this ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_3 ; VAR_3 = VAR_1 ; VAR_4 = ! METHOD_2 ( ) ; VAR_3 = VAR_2 ; <START> } <END> 
public TYPE_2 ( ) { <START> this . VAR_2 = TYPE_1 . create ( ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( VAR_2 ) ) { <END> return true ; } return false ; } 
private TYPE_1 METHOD_1 ( Response response ) throws IOException { <START> response . VAR_1 ( ) ; <END> String VAR_2 = response . VAR_3 ( String . VAR_4 ) ; TYPE_2 VAR_5 = new TYPE_2 ( ) ; return VAR_5 . METHOD_2 ( VAR_2 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , double VAR_2 ) { TYPE_3 result = new TYPE_3 ( new TYPE_4 ( VAR_1 ) , VAR_3 ) ; if ( ! Double . VAR_4 ( VAR_2 ) ) { result . VAR_5 ( VAR_2 ) ; <START> } <END> return result ; } 
public static String METHOD_1 ( String VAR_1 , List < String > VAR_2 ) { <START> TYPE_1 VAR_3 = new TYPE_1 ( VAR_1 ) ; <END> for ( TYPE_2 VAR_4 : VAR_2 ) { VAR_3 . add ( VAR_4 ) ; } return VAR_3 . toString ( ) ; } 
public TYPE_1 ( ) { VAR_2 . METHOD_1 ( true ) ; VAR_3 . METHOD_1 ( false ) ; <START> VAR_4 . METHOD_1 ( true ) ; <END> VAR_5 . add ( VAR_2 ) ; VAR_5 . add ( VAR_3 ) ; VAR_5 . add ( VAR_4 ) ; } 
private int METHOD_1 ( double VAR_1 ) { <START> if ( VAR_1 < 0 ) <END> throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; if ( VAR_1 > VAR_2 ) { VAR_1 = VAR_2 ; } int VAR_3 = Math . VAR_4 ( ( float ) ( VAR_1 * VAR_5 ) ) ; assert VAR_3 >= 0 : STRING_2 ; return VAR_3 ; } 
public void METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 , long VAR_4 ) { if ( VAR_4 == VAR_5 ) { return ; } TYPE_1 < Long , Long , Long > VAR_6 = ( VAR_7 , VAR_8 ) - > { return VAR_8 ; <START> } ; <END> METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_6 ) ; } 
public TYPE_2 ( List < Path > VAR_2 , TYPE_1 VAR_3 ) { <START> super ( METHOD_1 ( VAR_2 ) , METHOD_2 ( VAR_2 , VAR_3 ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { <START> VAR_1 . create ( INT_1 ) ; <END> METHOD_2 ( ) ; METHOD_3 ( ) ; } 
protected String METHOD_1 ( String VAR_1 ) { if ( VAR_1 != null && VAR_1 . contains ( STRING_1 ) ) { <START> VAR_1 = VAR_1 . substring ( 0 , VAR_1 . METHOD_2 ( CHAR_1 ) ) ; <END> } return VAR_1 ; } 
boolean METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( STRING_1 ) ; String VAR_3 = VAR_1 . METHOD_2 ( STRING_2 ) ; return VAR_1 . METHOD_3 ( STRING_1 , VAR_4 ) || VAR_1 . METHOD_3 ( STRING_3 , STRING_4 ) <START> || VAR_1 . METHOD_3 ( STRING_5 , STRING_6 ) <END> || STRING_7 . equals ( VAR_2 ) && VAR_3 != null && ! STRING_8 . equals ( VAR_3 ) ; } 
private boolean METHOD_1 ( final StringBuilder VAR_1 , final Long value , final String key , final boolean VAR_2 ) { boolean append = VAR_2 ; if ( value == null ) { return VAR_2 ; } <START> if ( ! VAR_2 && value . VAR_3 ( ) > 0 ) { <END> append = true ; } if ( append ) { VAR_1 . append ( value . VAR_3 ( ) ) . append ( key ) ; return true ; } return false ; } 
private boolean METHOD_1 ( ) { TYPE_1 session = METHOD_2 ( ) ; Object data = session . VAR_1 ( VAR_2 ) ; <START> if ( ( data != null ) && ( data instanceof TYPE_2 ) ) { <END> TYPE_2 VAR_3 = ( TYPE_2 ) data ; VAR_4 = VAR_3 . VAR_4 ; VAR_5 = VAR_3 . VAR_5 ; VAR_6 = TYPE_3 . METHOD_3 ( VAR_5 ) ; VAR_7 = VAR_3 . VAR_7 ; VAR_8 = TYPE_3 . METHOD_3 ( VAR_7 ) ; return true ; } else { return false ; } } 
private void METHOD_1 ( ) { <START> final TYPE_1 VAR_1 = TYPE_1 . getInstance ( ) ; <END> VAR_1 . add ( TYPE_1 . VAR_2 , - 1 ) ; VAR_3 = VAR_1 . METHOD_2 ( ) ; VAR_4 = TYPE_2 . METHOD_3 ( VAR_3 ) ; } 
public static String METHOD_1 ( ) { <START> final String VAR_1 = TYPE_1 . METHOD_2 ( ) <END> . METHOD_3 ( STRING_1 ) . METHOD_4 ( ) . METHOD_5 ( ) ; return VAR_1 ; } 
public TYPE_3 ( TYPE_1 VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = false ; this . VAR_4 = new TYPE_2 ( ) ; } 
public TYPE_3 ( final TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> this . VAR_3 = new TYPE_2 ( VAR_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; <START> VAR_2 = this . VAR_3 . METHOD_3 ( ) . METHOD_1 ( VAR_2 ) ; <END> final TYPE_1 result = TYPE_3 . METHOD_4 ( VAR_2 ) ; return result ; } 
public TYPE_1 ( final String VAR_2 , final String value ) { super ( ) ; this . VAR_2 = VAR_2 ; this . value = value ; <START> this . VAR_3 = false ; <END> } 
private static List < TYPE_1 > METHOD_1 ( final TYPE_2 VAR_1 , final Map < String , TYPE_3 > VAR_2 ) { <START> List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; <END> for ( final TYPE_3 VAR_4 : VAR_2 . values ( ) ) { final TYPE_1 VAR_5 = new TYPE_1 ( ) ; VAR_5 . METHOD_2 ( VAR_1 ) ; VAR_5 . METHOD_3 ( VAR_4 . METHOD_4 ( ) ) ; VAR_5 . METHOD_5 ( 1 ) ; VAR_3 . add ( VAR_5 ) ; } return VAR_3 ; } 
public TYPE_2 ( TYPE_1 project , Integer VAR_2 , String value , Integer VAR_3 , Integer VAR_4 , String VAR_5 ) { this . project = project ; this . VAR_2 = VAR_2 ; this . value = value ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> this . description = description ; <END> } 
public void METHOD_1 ( ) { if ( this . METHOD_2 ( ) != null ) { return ; } if ( this . METHOD_3 ( ) == null ) { return ; } <START> String VAR_1 = this . METHOD_4 ( ) . getProperty ( ) . getName ( ) ; <END> this . METHOD_5 ( TYPE_1 . METHOD_6 ( this . METHOD_3 ( ) , VAR_1 ) ) ; } 
public TYPE_1 METHOD_1 ( final File file , final String VAR_1 ) throws TYPE_2 { final TYPE_3 parser = new TYPE_3 ( this . VAR_2 ) ; final TYPE_4 VAR_3 = new TYPE_4 ( this . METHOD_2 ( ) ) ; <START> final TYPE_5 VAR_4 = new TYPE_6 ( this . METHOD_2 ( ) ) ; <END> return this . METHOD_1 ( file , parser , parser . VAR_5 ( file , true ) , VAR_3 , VAR_4 , VAR_1 ) ; } 
protected void VAR_1 ( ) { super . VAR_1 ( ) ; if ( VAR_2 != null ) { TYPE_1 i = VAR_2 . VAR_4 . get ( 0 ) ; <START> VAR_5 . VAR_6 ( ! STRING_1 . equalsIgnoreCase ( i . VAR_7 ) && ! STRING_2 . equalsIgnoreCase ( i . VAR_7 ) ; <END> } } 
public void close ( boolean VAR_1 ) throws IOException { super . close ( VAR_1 ) ; if ( ! VAR_1 ) { VAR_2 = 0 ; TYPE_1 . clear ( ) ; TYPE_2 . clear ( ) ; VAR_3 . clear ( ) ; <START> if ( VAR_4 != null ) { <END> VAR_4 . close ( ) ; } VAR_4 = null ; VAR_5 = 0 ; } } 
protected void METHOD_1 ( String key , boolean value ) { <START> METHOD_1 ( key , new Boolean ( value ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> System . out . println ( VAR_1 ) ; <END> TYPE_2 n = VAR_1 . METHOD_2 ( ) ; if ( ! n . VAR_2 ( ) ) throw new TYPE_3 ( getClass ( ) . METHOD_3 ( ) + STRING_1 + VAR_1 ) ; TYPE_4 t = TYPE_5 . METHOD_4 ( n ) ; TYPE_2 x = METHOD_5 ( t ) ; return TYPE_1 . METHOD_6 ( x ) ; } 
public void run ( ) { try { log . info ( format ( STRING_1 , VAR_1 ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) <START> TYPE_1 . METHOD_1 ( VAR_2 / 10 ) ; <END> log . info ( format ( STRING_2 , VAR_1 ) ) ; } catch ( Exception ex ) { log . info ( format ( STRING_3 , VAR_1 ) , ex ) ; } } 
private static Iterator < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 , TYPE_1 node , TYPE_1 VAR_3 ) { <START> TYPE_3 < TYPE_1 > VAR_4 = null ; <END> if ( VAR_2 ) return TYPE_4 . METHOD_2 ( VAR_1 , node , VAR_3 , TYPE_1 . VAR_5 ) . METHOD_3 ( TYPE_5 : : METHOD_4 ) ; else return TYPE_4 . METHOD_2 ( VAR_1 , TYPE_1 . VAR_5 , VAR_3 , node ) . METHOD_3 ( TYPE_5 : : METHOD_5 ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <START> TYPE_4 results = VAR_2 . METHOD_2 ( ) ; ; <END> TYPE_5 . write ( System . out , results ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_2 key = ( VAR_1 != null ) ? VAR_1 : TYPE_4 . VAR_3 ; <START> return VAR_4 . METHOD_2 ( VAR_1 , ( ) - > TYPE_3 . METHOD_3 ( this , key ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( VAR_2 . METHOD_3 ( ) , STRING_1 ) ; VAR_1 . METHOD_4 ( ) . METHOD_5 ( TYPE_2 ) ; METHOD_6 ( VAR_1 ) ; VAR_1 . METHOD_7 ( METHOD_8 ( STRING_2 ) ) ; METHOD_9 ( VAR_1 ) ; TYPE_2 . METHOD_10 ( ) ; <START> METHOD_11 ( VAR_1 , new TYPE_3 ( ) { <END> @Override public void run ( ) { assertTrue ( VAR_1 . contains ( METHOD_8 ( STRING_2 ) ) ) ; } } ) ; } 
public static void METHOD_1 ( boolean VAR_1 , TYPE_1 VAR_2 ) { VAR_3 = TYPE_2 . METHOD_2 ( ) ; server = TYPE_3 . create ( ) <START> . add ( METHOD_3 ( ) , VAR_3 ) <END> . METHOD_4 ( METHOD_5 ( ) ) . METHOD_6 ( VAR_2 ) . build ( ) . start ( ) ; } 
ANNOTATION_1 public void METHOD_1 ( ) { <START> iterator . VAR_1 ( new TYPE_1 ( ) <END> { @Override public void call ( ) { } } ) ; Context context = new Context ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( context , ( TYPE_3 ) null , ( TYPE_4 ) null , ( TYPE_5 ) null ) ; TYPE_6 VAR_3 = new TYPE_6 ( iterator , VAR_4 , VAR_2 ) ; while ( VAR_3 . hasNext ( ) ) VAR_3 . next ( ) ; assertTrue ( STRING_1 , iterator . VAR_5 ( ) ) ; } 
public void METHOD_1 ( ) { <START> final String VAR_1 = STRING_1 ; <END> final String VAR_2 = STRING_2 ; final TYPE_1 < Integer , Object > VAR_3 = new TYPE_2 < > ( 5 ) ; VAR_3 . put ( 1 , VAR_1 ) ; VAR_3 . put ( 1 , VAR_2 ) ; assertEquals ( STRING_3 , 1 , VAR_3 . size ( ) ) ; assertEquals ( STRING_4 , VAR_2 , VAR_3 . METHOD_2 ( 1 ) ) ; } 
<START> private static Boolean METHOD_1 ( final TYPE_1 key ) { <END> final TYPE_2 < TYPE_1 , Boolean > cache = TYPE_4 . TYPE_5 . get ( ) ; return ( cache == null ) ? null : ( Boolean ) cache . get ( key ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = create ( ) ; TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 , ( ) - > { long x = TYPE_4 . count ( VAR_1 . METHOD_3 ( ) ) ; <START> Assert . assertEquals ( 0 , x ) ; <END> } ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; VAR_1 . add ( VAR_4 ) ; VAR_1 . commit ( ) ; VAR_1 . METHOD_5 ( ) ; VAR_2 . run ( ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 , VAR_3 , VAR_4 , VAR_5 , super . METHOD_3 ( ) ) ; if ( VAR_2 == null ) VAR_2 = TYPE_3 . METHOD_4 ( VAR_6 ) ; <START> return VAR_2 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> METHOD_2 ( VAR_1 . METHOD_4 ( ) ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , Map < String , List < TYPE_2 > > VAR_2 ) { List < String > VAR_3 = METHOD_2 ( VAR_1 ) ; for ( String key : VAR_3 ) { <START> VAR_2 . METHOD_3 ( key , VAR_4 - > new ArrayList < > ( ) ) . add ( VAR_1 ) ; <END> } } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 . size ( ) > 2 ) { return VAR_2 . stream ( ) . METHOD_3 ( VAR_3 - > ! VAR_3 . METHOD_4 ( ) && TYPE_3 . METHOD_5 ( VAR_3 . METHOD_6 ( ) , TYPE_5 . TYPE_4 . VAR_6 ) == null ) ; <START> } else { <END> return false ; } } 
private static TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_1 < String > VAR_1 ) { return VAR_2 - > { if ( VAR_2 . is ( TYPE_5 . TYPE_4 . VAR_5 ) ) { return VAR_1 . METHOD_2 ( ( ( TYPE_3 ) VAR_2 ) . METHOD_3 ( ) ) ; } else { <START> return false ; <END> } } ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( ( TYPE_2 ) TYPE_3 . METHOD_2 ( VAR_1 , VAR_3 ) ) ; <START> if ( VAR_2 == null ) { return false ; } return METHOD_3 ( VAR_2 . METHOD_4 ( ) , VAR_1 ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) == TYPE_1 . TYPE_5 . VAR_4 ) { return false ; } TYPE_3 VAR_5 = VAR_1 . METHOD_3 ( ) ; <START> return VAR_2 . equals ( TYPE_4 . METHOD_4 ( VAR_5 , TYPE_3 . TYPE_5 . VAR_6 ) ) <END> && TYPE_4 . METHOD_4 ( VAR_5 , TYPE_3 . TYPE_5 . VAR_7 ) == null ; } 
<START> Map < String , TYPE_1 > METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( ) . stream ( ) . collect ( Collectors . VAR_2 ( TYPE_1 : : name , m - > m , ( VAR_3 , VAR_4 ) - > VAR_3 ) ) ; } return VAR_1 ; } 
public TYPE_1 type ( ) { if ( VAR_1 . contains ( STRING_1 ) ) { return TYPE_2 . METHOD_1 ( STRING_2 ) ; } if ( VAR_2 . contains ( STRING_3 ) || VAR_1 . contains ( STRING_4 ) ) { return TYPE_2 . METHOD_1 ( STRING_5 ) ; } <START> return TYPE_2 . METHOD_1 ( STRING_6 ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! VAR_1 . is ( TYPE_6 . TYPE_5 . VAR_4 ) ) { return true ; } TYPE_2 VAR_5 = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; <START> if ( VAR_5 . is ( TYPE_6 . TYPE_5 . VAR_6 ) || VAR_5 . is ( TYPE_6 . TYPE_5 . VAR_7 ) ) { <END> return METHOD_3 ( ( ( TYPE_4 ) VAR_5 ) . METHOD_4 ( ) ) ; } return true ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 |= ( VAR_1 . METHOD_2 ( ) && VAR_1 . METHOD_3 ( ) ) ; <END> super . METHOD_1 ( VAR_1 ) ; } 
public TYPE_8 ( TYPE_1 context , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 , List < TYPE_5 > VAR_5 ) { this . context = context ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_6 = new TYPE_6 ( context ) ; this . VAR_5 = VAR_5 ; this . parser = TYPE_7 . create ( ) ; <START> this . VAR_7 = new HashMap < > ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 name ) { <START> if ( ! VAR_1 && ! VAR_2 && name . VAR_3 ( ) && name . VAR_4 ( ) == null ) { <END> VAR_5 . METHOD_2 ( name . name ( ) , VAR_6 - > new ArrayList < > ( ) ) . add ( name ) ; } } 
private static String METHOD_1 ( String VAR_1 , String VAR_2 ) { int VAR_3 = VAR_1 . METHOD_2 ( CHAR_1 ) ; <START> String VAR_4 = VAR_1 . substring ( 0 , VAR_3 ) ; <END> return VAR_2 . isEmpty ( ) ? VAR_4 : ( VAR_2 + STRING_1 + VAR_4 ) ; } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . VAR_4 ) ; String VAR_5 = VAR_1 . METHOD_4 ( ) ; boolean VAR_6 = VAR_2 . METHOD_5 ( CHAR_1 ) == - 1 ; boolean VAR_7 = VAR_2 . METHOD_5 ( CHAR_2 ) != - 1 ; if ( VAR_6 ) { boolean VAR_8 = ! VAR_7 ; VAR_5 = METHOD_6 ( VAR_5 , VAR_8 ) ; <START> } <END> return VAR_5 ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_2 ) ; if ( VAR_3 . is ( TYPE_6 . TYPE_5 . VAR_6 ) ) { TYPE_4 VAR_7 = ( TYPE_4 ) VAR_3 ; VAR_8 . add ( VAR_7 ) ; <START> METHOD_1 ( VAR_1 , ( VAR_7 ) . METHOD_3 ( ) ) ; <END> METHOD_1 ( VAR_1 , ( VAR_7 ) . METHOD_4 ( ) ) ; } else { VAR_1 . METHOD_5 ( VAR_3 , null ) ; } } 
public void METHOD_1 ( TYPE_1 name ) { Optional . VAR_1 ( name . VAR_2 ( ) ) . METHOD_2 ( VAR_2 - > VAR_2 . METHOD_3 ( ) . stream ( ) <START> . filter ( VAR_3 - > VAR_3 . METHOD_4 ( ) == name ) <END> . METHOD_5 ( ) . METHOD_2 ( VAR_3 - > METHOD_6 ( VAR_3 , VAR_2 ) ) ) ; super . METHOD_1 ( name ) ; } 
public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) . contains ( STRING_1 ) || METHOD_2 ( ) . contains ( STRING_2 ) ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 ... VAR_2 ) { <START> return METHOD_2 ( VAR_1 , t - > Arrays . asList ( VAR_2 ) . contains ( t . VAR_3 ( ) ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . get ( STRING_1 ) ; Map < String , TYPE_2 > VAR_3 = METHOD_2 ( VAR_1 ) ; assertThat ( VAR_3 ) . METHOD_3 ( 4 ) ; for ( Map . Entry < String , TYPE_2 > VAR_4 : VAR_3 . entrySet ( ) ) { <START> System . out . println ( VAR_4 . getKey ( ) + STRING_2 + VAR_4 . getValue ( ) . name ( ) ) ; <END> } } 
private static List < List < TYPE_1 > > METHOD_1 ( TYPE_2 token ) { <START> List < List < TYPE_1 > > result = new TYPE_3 < > ( ) ; <END> List < TYPE_1 > VAR_1 = null ; for ( TYPE_1 VAR_2 : token . VAR_2 ( ) ) { VAR_1 = METHOD_2 ( result , VAR_1 , VAR_2 ) ; } if ( VAR_1 != null ) { result . add ( VAR_1 ) ; } return result ; } 
private static Set < String > METHOD_1 ( TYPE_1 VAR_1 ) { return VAR_1 . METHOD_2 ( TYPE_5 . VAR_3 ) . map ( TYPE_2 . class : : METHOD_3 ) . METHOD_4 ( VAR_4 - > VAR_4 . METHOD_5 ( ) . stream ( ) ) <START> . filter ( VAR_4 - > VAR_4 . METHOD_6 ( ) . equals ( STRING_1 ) ) <END> . map ( TYPE_3 : : METHOD_7 ) . METHOD_4 ( TYPE_4 : : METHOD_8 ) . collect ( Collectors . VAR_5 ( ) ) ; } 
public void METHOD_1 ( Context context ) { <START> context . VAR_1 ( TYPE_5 . TYPE_4 . VAR_4 , ctx - > this . VAR_5 = new TYPE_1 < > ( ) ) ; <END> context . VAR_1 ( TYPE_5 . TYPE_4 . VAR_6 , ctx - > { TYPE_2 VAR_7 = ( TYPE_2 ) ctx . VAR_8 ( ) ; if ( VAR_5 . contains ( VAR_7 ) ) { return ; } List < TYPE_3 > VAR_9 = METHOD_2 ( VAR_7 ) ; METHOD_3 ( VAR_9 , ctx ) ; } ) ; } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <START> List < TYPE_1 > VAR_2 = new ArrayList < > ( Collections . VAR_3 ( VAR_1 . METHOD_2 ( ) ) ) ; <END> VAR_2 . addAll ( VAR_1 . METHOD_3 ( ) . stream ( ) . map ( TYPE_2 : : METHOD_2 ) . collect ( Collectors . VAR_4 ( ) ) ) ; TYPE_3 VAR_5 = VAR_1 . METHOD_4 ( ) ; if ( VAR_5 != null ) { METHOD_5 ( VAR_2 , VAR_5 ) ; } return VAR_2 ; } 
<START> private void METHOD_1 ( TYPE_1 ctx , TYPE_2 VAR_1 ) { <END> TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 . is ( TYPE_7 . TYPE_6 . VAR_5 ) ) { VAR_2 = ( ( TYPE_4 ) VAR_2 ) . METHOD_2 ( ) ; if ( VAR_2 . is ( TYPE_7 . TYPE_6 . VAR_6 ) || ! ( VAR_2 instanceof TYPE_5 ) ) { ctx . VAR_7 ( VAR_2 , String . format ( VAR_8 , STRING_1 ) ) ; } } } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = ( TYPE_4 ) VAR_3 ; <END> this . VAR_4 = VAR_4 ; this . VAR_5 = null ; TYPE_5 VAR_6 = new TYPE_5 ( ) ; VAR_6 . METHOD_1 ( this ) ; VAR_7 = VAR_6 . METHOD_2 ( ) ; } 
<START> private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 . is ( TYPE_4 . TYPE_3 . VAR_4 ) || VAR_1 . is ( TYPE_4 . TYPE_3 . VAR_5 ) ) { return METHOD_1 ( ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ) ; } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; if ( VAR_2 != null ) { <START> System . out . println ( VAR_2 . METHOD_4 ( ) ) ; <END> VAR_4 . add ( VAR_2 . METHOD_4 ( ) ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; TYPE_2 VAR_3 = VAR_1 . METHOD_3 ( TYPE_7 . VAR_5 ) ; TYPE_4 VAR_6 = null ; if ( VAR_3 != null ) { VAR_6 = new TYPE_5 ( VAR_3 , METHOD_4 ( VAR_3 ) ) ; <START> } <END> return new TYPE_6 ( VAR_1 , VAR_2 , VAR_6 , VAR_1 . METHOD_3 ( TYPE_8 . VAR_8 ) , VAR_1 . METHOD_3 ( TYPE_8 . VAR_9 ) ) ; } 
TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 == null ) { return null ; <START> } else if ( VAR_1 . is ( TYPE_2 . TYPE_3 . VAR_3 ) ) { <END> return ( TYPE_1 ) VAR_1 ; } else { return METHOD_1 ( VAR_1 . parent ( ) ) ; } } 
public void METHOD_1 ( Context context ) { context . VAR_1 ( TYPE_4 . TYPE_3 . VAR_4 , ctx - > { <START> TYPE_1 VAR_5 = ( ( TYPE_1 ) ctx . VAR_6 ( ) ) ; <END> TYPE_2 VAR_7 = VAR_5 . name ( ) ; String VAR_8 = VAR_7 . name ( ) ; if ( ! METHOD_2 ( ) . matcher ( VAR_8 ) . METHOD_3 ( ) ) { String message = String . format ( VAR_9 , VAR_8 , format ) ; ctx . VAR_10 ( VAR_7 , message ) ; } } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( new ArrayList < > ( VAR_1 . METHOD_3 ( ) ) ) ; <END> } 
<START> public Set < TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 element ) { if ( element != null ) { VAR_1 = element ; <START> List < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( element . VAR_4 ( ) , Collections . VAR_5 ( ) ) ; <END> for ( TYPE_2 VAR_6 : VAR_2 ) { VAR_6 . execute ( ) ; } } super . METHOD_1 ( element ) ; } 
private static TYPE_1 METHOD_1 ( String VAR_1 ) { File VAR_2 = new File ( STRING_1 ) ; File file = new File ( VAR_2 , VAR_1 ) ; String VAR_3 ; try { VAR_3 = TYPE_2 . toString ( file , TYPE_6 . VAR_5 ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } <START> TYPE_3 VAR_6 = new org . VAR_7 . VAR_8 . VAR_9 . TYPE_4 ( ) . parse ( VAR_3 ) ; <END> return new TYPE_1 ( TYPE_5 . METHOD_2 ( file ) , true , VAR_6 ) ; } 
<START> private TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { <END> return TYPE_4 . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) . filter ( TYPE_2 . class ) ; } 
public void METHOD_1 ( Context context ) { context . VAR_1 ( TYPE_2 . VAR_3 , ctx - > { TYPE_1 node = ( TYPE_1 ) ctx . VAR_4 ( ) ; <START> ctx . VAR_5 ( node . VAR_6 ( ) . METHOD_2 ( ) , STRING_1 ) ; <END> } ) ; } 
private String METHOD_1 ( TYPE_1 node ) { TYPE_2 VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( node ) ; <START> if ( VAR_1 != null ) { <END> return VAR_1 . METHOD_5 ( ) ; } return "" ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( TYPE_2 . VAR_4 ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_3 ( TYPE_2 . VAR_5 ) <START> . forEach ( VAR_6 - > { <END> if ( VAR_7 . contains ( METHOD_4 ( VAR_6 ) ) ) { METHOD_5 ( VAR_6 , VAR_8 ) ; } } ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . VAR_2 ) ; assertThat ( p ) . METHOD_3 ( STRING_1 ) ; assertThat ( p ) . METHOD_3 ( STRING_2 ) ; <START> assertThat ( p ) . METHOD_3 ( STRING_3 ) ; <END> METHOD_2 ( TYPE_1 . VAR_3 ) ; assertThat ( p ) . METHOD_3 ( STRING_4 ) ; assertThat ( p ) . METHOD_4 ( STRING_5 ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { VAR_2 = context . VAR_2 ( ) ; <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> System . out . println ( STRING_2 + context . VAR_3 ( ) ) ; TYPE_2 VAR_4 = context . VAR_3 ( ) . METHOD_2 ( context . VAR_3 ( ) . METHOD_3 ( ) . is ( METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ) ; VAR_2 . METHOD_7 ( VAR_4 ) ; } 
public void METHOD_1 ( ) { TYPE_1 project = METHOD_2 ( TYPE_1 . class ) ; assertThat ( VAR_1 . toString ( ) ) . METHOD_3 ( STRING_1 ) ; assertThat ( VAR_1 . METHOD_4 ( project ) ) . METHOD_5 ( ) ; <START> VAR_2 . add ( new TYPE_2 ( TYPE_3 . VAR_4 , STRING_2 ) . METHOD_6 ( TYPE_4 . VAR_6 ) ) ; <END> assertThat ( VAR_1 . METHOD_4 ( project ) ) . METHOD_7 ( ) ; } 
public String METHOD_1 ( ) throws TYPE_1 { <START> return new TYPE_2 ( ) . METHOD_1 ( <END> VAR_1 . METHOD_2 ( ) ) ; } 
public String METHOD_1 ( long VAR_1 ) throws TYPE_1 { ArrayList < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ; <START> return new TYPE_3 ( ) . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } 
public String METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> return new TYPE_3 ( ) . METHOD_1 ( VAR_1 ) ; <END> } 
public String METHOD_1 ( ArrayList < TYPE_1 > VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = new TYPE_3 ( ) ; TYPE_4 VAR_3 = new TYPE_4 ( ) ; if ( VAR_1 == null ) return "" ; for ( TYPE_1 task : VAR_1 ) { TYPE_3 VAR_4 = new TYPE_3 ( METHOD_2 ( task ) ) ; VAR_3 . put ( VAR_4 ) ; } VAR_2 . put ( TYPE_5 . VAR_6 , VAR_3 ) ; <START> return VAR_2 . toString ( ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( ) ; VAR_1 = new TYPE_1 ( METHOD_2 ( ) , METHOD_4 ( ) ) ; VAR_2 = new TYPE_2 ( METHOD_2 ( ) , METHOD_4 ( ) ) ; <START> VAR_3 = new TYPE_3 ( METHOD_2 ( ) , METHOD_4 ( ) ) ; <END> } 
private void METHOD_1 ( long VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( super . METHOD_2 ( ) ) ; VAR_3 = new TYPE_2 ( ) ; VAR_4 = VAR_3 . METHOD_3 ( VAR_1 ) ; <START> TYPE_3 VAR_5 = new TYPE_4 ( ) . METHOD_4 ( VAR_4 . getName ( ) ) ; <END> VAR_6 = new TYPE_5 ( VAR_5 , VAR_2 ) ; VAR_7 = new TYPE_6 ( VAR_2 , VAR_5 ) ; } 
public void METHOD_1 ( String text ) { <START> this . VAR_1 = text ; <END> this . METHOD_2 ( METHOD_3 ( STRING_1 ) ) ; this . METHOD_4 ( METHOD_3 ( STRING_2 ) ) ; this . METHOD_5 ( METHOD_3 ( STRING_3 ) ) ; this . METHOD_6 ( METHOD_3 ( STRING_4 ) ) ; this . METHOD_7 ( METHOD_3 ( STRING_5 ) ) ; } 
public Date METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = this . METHOD_2 ( ) ; <END> return TYPE_2 . METHOD_3 ( VAR_1 . get ( 0 ) . METHOD_4 ( ) ) ; } 
public TYPE_5 ( TYPE_1 project , TYPE_2 VAR_2 ) { VAR_3 = new TYPE_3 ( ) ; <START> VAR_3 . METHOD_1 ( project . getName ( ) ) ; <END> VAR_4 = VAR_2 ; VAR_5 = new TYPE_4 ( VAR_4 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 . getId ( ) ; VAR_3 = VAR_1 . METHOD_2 ( ) ; VAR_4 = VAR_1 . METHOD_3 ( ) ; VAR_5 = VAR_1 . METHOD_4 ( ) ; VAR_6 = VAR_1 . METHOD_5 ( ) ; VAR_7 = VAR_1 . METHOD_6 ( ) ; <START> VAR_8 = null ; <END> } 
<START> private static double METHOD_1 ( int [ ] m ) { <END> double VAR_1 = 0 ; for ( int i = 0 ; i < m . length ; i ++ ) { VAR_1 += m [ i ] ; } return VAR_1 / m . length ; } 
public void write ( byte [ ] data , int offset , int VAR_1 ) { if ( ! this . VAR_2 ) { return ; } <START> VAR_3 . METHOD_1 ( TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . METHOD_4 ( data ) ) . build ( ) ) ; <END> } 
<START> public Iterator < String > METHOD_1 ( ) { <END> return VAR_1 ; } 
protected List < TYPE_1 > METHOD_1 ( ) { <START> synchronized ( this . VAR_1 ) { <END> return this . VAR_1 ; } } 
public Object create ( String VAR_1 , TYPE_1 VAR_2 , TYPE_2 context ) throws TYPE_3 { if ( VAR_2 == null ) { return null ; } TYPE_4 VAR_3 = Context . VAR_4 ( TYPE_4 . class ) ; String VAR_5 = VAR_3 . METHOD_1 ( VAR_3 . METHOD_2 ( VAR_1 ) , <START> VAR_2 . containsKey ( STRING_1 ) ? String . valueOf ( ( String ) VAR_2 . get ( STRING_1 ) ) : "" ) ; <END> TYPE_1 response = new TYPE_1 ( ) ; response . add ( VAR_6 , VAR_5 ) ; return response ; } 
public String METHOD_1 ( ) { <START> return this . METHOD_2 ( ) . METHOD_1 ( ) ; <END> } 
public String METHOD_1 ( ) { <START> return METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 ) ; <START> this . VAR_1 = Context . VAR_2 ( TYPE_1 . class ) ; <END> } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { <START> throw new TYPE_3 ( STRING_1 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 req = request ( TYPE_2 . VAR_2 , METHOD_2 ( ) + STRING_1 + METHOD_3 ( ) ) ; <END> req . VAR_3 ( STRING_2 , "" ) ; METHOD_4 ( req ) ; METHOD_5 ( VAR_4 . METHOD_6 ( Integer . parseInt ( METHOD_3 ( ) ) ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( STRING_1 , METHOD_3 ( ) ) ; <END> METHOD_4 ( STRING_2 ) ; METHOD_4 ( STRING_3 ) ; METHOD_4 ( STRING_4 ) ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { TYPE_1 description = new TYPE_1 ( ) ; description . VAR_1 ( STRING_1 ) ; <START> description . VAR_1 ( STRING_2 ) ; <END> description . VAR_1 ( STRING_3 ) ; return description ; } 
TYPE_1 METHOD_1 ( final String VAR_1 , final String VAR_2 , final String VAR_3 , final boolean VAR_4 , final String VAR_5 , final TYPE_2 item ) { final String VAR_6 = TYPE_3 . METHOD_2 ( VAR_3 , item , null ) ; if ( VAR_6 != null ) { return new TYPE_4 ( <START> new TYPE_5 ( ) <END> . METHOD_3 ( VAR_1 ) . METHOD_4 ( VAR_2 ) . METHOD_5 ( VAR_4 ) . METHOD_6 ( VAR_5 ) . METHOD_7 ( VAR_6 ) ) ; } else { throw new TYPE_6 ( STRING_1 + VAR_3 ) ; } } 
public TYPE_2 ( String VAR_2 , String VAR_3 , boolean VAR_4 , String VAR_5 , boolean VAR_6 , String VAR_7 ) { <START> this ( new TYPE_1 ( ) <END> . METHOD_1 ( VAR_2 ) . METHOD_2 ( VAR_3 ) . METHOD_3 ( VAR_4 ) . METHOD_4 ( VAR_5 ) . METHOD_5 ( VAR_6 ) . METHOD_6 ( VAR_7 ) ) ; if ( VAR_7 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } this . VAR_7 = VAR_7 ; } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> return TYPE_1 . VAR_2 ; <END> } else { return VAR_1 ; } } 
public TYPE_2 ( String VAR_2 ) { <START> TYPE_1 result = new TYPE_1 ( VAR_2 ) ; <END> VAR_3 = result . getString ( STRING_1 ) ; VAR_4 = result . getString ( STRING_2 ) ; } 
public TYPE_2 ( String VAR_2 ) { <START> if ( StringUtils . isEmpty ( VAR_2 ) ) { <END> TYPE_1 result = new TYPE_1 ( VAR_2 ) ; VAR_3 = result . getString ( STRING_1 ) ; VAR_4 = result . getString ( STRING_2 ) ; } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return new TYPE_1 ( ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( new TYPE_1 ( ) { @Override <START> public Object METHOD_3 ( TYPE_2 VAR_1 ) throws Throwable { <END> TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 . METHOD_4 ( 1 ) ; VAR_2 . METHOD_5 ( STRING_1 , STRING_2 ) ; return null ; } } ) . when ( VAR_3 ) . METHOD_6 ( METHOD_7 ( ) , METHOD_7 ( ) ) ; METHOD_8 ( METHOD_9 ( STRING_3 ) ) . METHOD_10 ( view ( ) . name ( STRING_4 ) ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> METHOD_2 ( ( ) - > METHOD_3 ( get ( STRING_1 + VAR_1 + STRING_2 ) ) ) . METHOD_4 ( TYPE_1 . class ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( new TYPE_1 ( ) { @Override <START> public Object METHOD_3 ( TYPE_2 VAR_1 ) throws Throwable { <END> TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 . METHOD_4 ( 1 ) ; VAR_2 . METHOD_5 ( STRING_1 , STRING_2 ) ; return null ; } } ) . when ( VAR_3 ) . METHOD_6 ( METHOD_7 ( ) , METHOD_7 ( ) ) ; METHOD_8 ( METHOD_9 ( STRING_3 + VAR_4 + STRING_4 ) ) . METHOD_10 ( view ( ) . name ( STRING_5 ) ) ; } 
private static TYPE_1 METHOD_1 ( int VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> VAR_2 . METHOD_2 ( VAR_3 ) ; <END> return VAR_2 ; } 
public void METHOD_1 ( ) throws Exception { when ( VAR_1 . METHOD_2 ( VAR_2 ) ) . METHOD_3 ( Optional . of ( VAR_3 ) ) ; when ( VAR_4 . METHOD_4 ( VAR_3 , VAR_3 ) ) . METHOD_3 ( true ) ; <START> when ( VAR_5 . METHOD_5 ( ) ) . METHOD_3 ( METHOD_6 ( TYPE_1 . VAR_7 ) ) ; <END> METHOD_7 ( get ( STRING_1 + VAR_2 ) . METHOD_8 ( TYPE_2 . VAR_9 , STRING_2 ) ) . METHOD_9 ( model ( ) . METHOD_10 ( TYPE_2 . VAR_9 , INT_1 ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( METHOD_4 ( TYPE_1 . VAR_3 ) ) ; <END> METHOD_5 ( get ( STRING_1 ) . METHOD_6 ( STRING_2 , STRING_3 ) ) ; METHOD_7 ( VAR_1 ) . METHOD_8 ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { Optional < TYPE_4 > VAR_3 = VAR_4 . METHOD_2 ( VAR_1 , VAR_2 ) ; <START> if ( VAR_3 . isEmpty ( ) ) { <END> throw new TYPE_5 ( STRING_1 + VAR_1 + STRING_2 ) ; } TYPE_4 VAR_5 = VAR_3 . get ( ) ; return VAR_5 . METHOD_3 ( VAR_2 . METHOD_4 ( ) . getValue ( ) ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 ) { Assert . VAR_6 ( VAR_2 , STRING_1 ) ; Assert . VAR_6 ( VAR_3 , STRING_2 ) ; Assert . VAR_6 ( VAR_4 , STRING_3 ) ; Assert . VAR_6 ( VAR_5 , STRING_4 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_7 = VAR_5 ; <START> this . VAR_8 = TYPE_4 . METHOD_1 ( VAR_9 ) . METHOD_2 ( ) ; <END> } 
TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . VAR_2 ; <START> for ( TYPE_2 VAR_3 : VAR_4 ) { <END> VAR_1 = VAR_1 . add ( VAR_3 . METHOD_2 ( ) ) ; } TYPE_1 VAR_5 = TYPE_1 . TYPE_4 . METHOD_3 ( VAR_1 ) ; boolean VAR_6 = VAR_5 . METHOD_4 ( TYPE_1 . VAR_2 ) < 0 ; if ( VAR_6 ) { VAR_5 = TYPE_1 . VAR_2 ; } return VAR_5 ; } 
public TYPE_1 METHOD_1 ( String container , String name , long VAR_1 ) { <START> System . out . println ( STRING_1 + container + STRING_2 + name + STRING_2 + VAR_1 ) ; <END> METHOD_2 ( container , STRING_3 ) ; METHOD_2 ( name , STRING_4 ) ; return METHOD_3 ( STRING_5 , container , name , null , VAR_1 , null , null ) ; } 
<START> public String [ ] METHOD_1 ( TYPE_1 uri ) throws TYPE_2 , IllegalArgumentException { <END> String path = uri . getPath ( ) ; String [ ] result = path . split ( STRING_1 ) ; if ( result . length < 2 ) { throw new IllegalArgumentException ( STRING_2 ) ; } for ( int i = 1 ; i < result . length ; i ++ ) { if ( result [ i ] == null ) { throw new TYPE_2 ( STRING_3 ) ; } } return result ; } 
public static Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] { { false , "" } , { false , STRING_1 } , { false , STRING_2 } , { false , STRING_3 } , { false , STRING_4 } , { false , STRING_5 } , { false , STRING_6 } , { true , STRING_7 } , { true , STRING_8 } , <START> { false , "" } <END> } ; } 
private static TYPE_1 METHOD_1 ( TYPE_1 request ) { boolean VAR_1 = false ; if ( request . VAR_2 ( ) != null ) { Long length = request . VAR_2 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; if ( length != null && length == 0 ) { <START> VAR_1 = true ; <END> } } else { VAR_1 = true ; } if ( VAR_1 ) { request = request . VAR_3 ( ) . METHOD_4 ( STRING_1 ) . build ( ) ; } return request ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> VAR_1 . METHOD_3 ( null , VAR_2 ) ; TYPE_1 VAR_3 = VAR_1 . METHOD_4 ( VAR_4 . getName ( ) ) . METHOD_5 ( new TYPE_2 ( VAR_4 ) ) . build ( ) ; VAR_1 . METHOD_6 ( VAR_5 , VAR_3 ) ; VAR_1 . METHOD_7 ( VAR_5 , VAR_4 . getName ( ) ) ; VAR_1 . METHOD_8 ( VAR_2 ) ; VAR_1 . METHOD_9 ( VAR_2 ) ; } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_3 ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( binder ( ) , TYPE_1 . class ) ; METHOD_2 ( binder ( ) , TYPE_2 . class ) ; <START> METHOD_3 ( TYPE_3 . class ) ; <END> } 
public < T > T METHOD_1 ( TYPE_1 VAR_1 , Type type ) { TYPE_2 reader = new TYPE_3 ( VAR_1 ) ; try { return ( T ) VAR_2 . METHOD_1 ( reader , type ) ; } finally { <START> METHOD_2 ( reader ) ; <END> } } 
protected TYPE_1 METHOD_1 ( Set < ? extends TYPE_1 > VAR_1 ) { try { return super . METHOD_1 ( VAR_1 ) ; } catch ( Exception TYPE_2 ) { if ( METHOD_2 ( VAR_2 ) ) { TYPE_3 VAR_3 = METHOD_3 ( VAR_2 ) ; return METHOD_4 ( VAR_3 . METHOD_5 ( ) , VAR_3 . METHOD_6 ( ) ) ; } else { <START> throw METHOD_7 ( STRING_1 , VAR_1 ) ; <END> } } } 
<START> public final TYPE_1 call ( ) { <END> return METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; } 
public static TYPE_1 METHOD_1 ( ) { TYPE_1 properties = TYPE_2 . METHOD_1 ( ) ; properties . VAR_1 ( VAR_2 , STRING_1 ) ; properties . VAR_1 ( VAR_3 , STRING_2 ) ; <START> properties . VAR_1 ( Constants . VAR_4 , STRING_3 ) ; <END> return properties ; } 
protected TYPE_2 ( String id , String name , ANNOTATION_1 Date VAR_2 , ANNOTATION_1 Date VAR_3 , ANNOTATION_1 Map < String , String > VAR_4 ) { this . id = METHOD_1 ( id , STRING_1 ) ; this . name = METHOD_1 ( name , STRING_2 ) ; this . VAR_2 = Optional . VAR_5 ( VAR_2 ) ; this . VAR_3 = Optional . VAR_5 ( VAR_3 ) ; <START> this . VAR_4 = VAR_4 == null ? new HashMap < String , String > ( ) : TYPE_1 . METHOD_2 ( VAR_4 ) ; <END> } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; VAR_1 = VAR_2 . METHOD_2 ( ) ; VAR_3 = TYPE_1 . get ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) , 0 ) ; <START> METHOD_5 ( VAR_3 , STRING_1 ) ; <END> } 
protected void METHOD_1 ( ) { <START> if ( ! VAR_1 ) { <END> return ; } if ( view . VAR_2 ( ) == TYPE_2 . VAR_4 ) { TYPE_1 . METHOD_2 ( VAR_5 , TimeUnit . VAR_6 ) ; } } 
public TYPE_1 < String > METHOD_1 ( ) { ArrayList < String > VAR_1 = new ArrayList < String > ( VAR_2 . keySet ( ) ) ; Collections . VAR_3 ( VAR_1 ) ; <START> return VAR_1 ; <END> } 
public TYPE_1 METHOD_1 ( String container , TYPE_2 VAR_1 ) { <START> Long VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> String VAR_3 = String . format ( STRING_1 , VAR_1 . getName ( ) , System . currentTimeMillis ( ) / FLOAT_1 , VAR_2 == null ? 0 : VAR_2 ) ; return TYPE_1 . create ( container , VAR_1 . getName ( ) , VAR_3 , VAR_1 ) ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) { <END> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; } 
<START> String METHOD_1 ( String VAR_1 ) { <END> return VAR_2 . METHOD_2 ( TYPE_1 . of ( STRING_1 , ImmutableList . of ( TYPE_1 . of ( STRING_2 , VAR_1 ) ) ) ) ; } 
TYPE_2 ( TYPE_1 VAR_2 ) { <START> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; <END> } 
protected void METHOD_1 ( ) { if ( view . VAR_1 ( ) == TYPE_2 . VAR_3 ) { <START> TYPE_1 . METHOD_2 ( INT_1 , TimeUnit . VAR_4 ) ; <END> } } 
public boolean METHOD_1 ( TYPE_1 command , IOException error ) { <START> return METHOD_2 ( command ) && METHOD_3 ( command ) ; <END> } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_2 ) ; } 
<START> public TYPE_4 ( TYPE_1 client , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <END> this . client = METHOD_1 ( client , STRING_1 ) ; this . VAR_2 = METHOD_1 ( VAR_2 , STRING_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_3 ) ; } 
public TYPE_1 METHOD_1 ( String group ) { <START> return VAR_1 . apply ( group ) ; <END> } 
public TYPE_1 apply ( Object from ) { <START> if ( ! ( from instanceof String ) ) { <END> throw new TYPE_2 ( STRING_1 ) ; } Map < String , TYPE_3 < TYPE_1 > > VAR_1 = VAR_2 . get ( ) ; METHOD_1 ( ! VAR_1 . isEmpty ( ) , STRING_2 ) ; METHOD_2 ( VAR_1 . containsKey ( from ) , STRING_3 , from , VAR_1 ) ; return VAR_1 . get ( from ) . get ( ) ; } 
public static boolean METHOD_1 ( ) { <START> System . out . println ( System . getProperty ( STRING_1 , STRING_2 ) ) ; <END> return System . getProperty ( STRING_1 , "" ) . contains ( STRING_3 ) ; } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null || getClass ( ) != obj . getClass ( ) ) return false ; TYPE_1 that = TYPE_1 . class . METHOD_1 ( obj ) ; <START> return TYPE_2 . METHOD_2 ( this . name , that . name ) && this . state . equals ( that . state ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) . getId ( ) ; VAR_1 . METHOD_3 ( TYPE_5 . VAR_4 , TYPE_4 . VAR_6 ) ; <START> VAR_1 . METHOD_3 ( new TYPE_2 ( VAR_7 ) , TYPE_4 . VAR_8 ) ; <END> VAR_1 . METHOD_3 ( new TYPE_3 ( VAR_2 ) , TYPE_4 . VAR_9 ) ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { <START> return new TYPE_1 ( ) . METHOD_1 ( VAR_1 ) ; <END> } 
public TYPE_4 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_1 < TYPE_3 > VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> } <END> 
public void METHOD_1 ( ) throws Exception { Set < ? extends TYPE_1 > VAR_1 = client . VAR_2 ( METHOD_2 ( group ) ) ; for ( TYPE_2 node : VAR_1 ) { assert node . VAR_3 ( ) != null : node ; <START> assert node . VAR_4 ( ) != null : node ; <END> assertEquals ( node . getType ( ) , TYPE_3 . VAR_6 ) ; } METHOD_3 ( ) ; } 
private TYPE_1 METHOD_1 ( Set < ? extends TYPE_1 > VAR_1 ) { Optional < ? extends TYPE_1 > VAR_2 = METHOD_2 ( VAR_1 , VAR_3 ) ; if ( VAR_2 . isPresent ( ) ) { return VAR_2 . get ( ) ; } <START> logger . warn ( STRING_1 , VAR_4 ) ; <END> TYPE_1 VAR_5 = VAR_6 . METHOD_3 ( VAR_4 ) ; if ( VAR_5 == null ) { METHOD_4 ( format ( STRING_2 , VAR_3 ) , VAR_1 ) ; } this . VAR_1 . METHOD_5 ( VAR_5 ) ; return VAR_5 ; } 
protected String METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> return TYPE_2 . METHOD_3 ( VAR_2 . list ( ) . METHOD_4 ( ) , null ) . getId ( ) ; <END> } 
private TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_2 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; TYPE_3 options = new TYPE_3 ( ) ; <START> if ( VAR_2 != null ) options = options . VAR_5 ( VAR_2 ) ; <END> TYPE_4 server = VAR_3 . create ( VAR_6 , METHOD_3 ( VAR_1 ) , METHOD_4 ( VAR_1 ) , options ) ; METHOD_5 ( VAR_3 ) . apply ( server ) ; return VAR_3 . get ( server . getId ( ) ) ; } 
<START> public void METHOD_1 ( ) { <END> TYPE_1 VAR_1 = TYPE_1 . builder ( ) . user ( STRING_1 ) . METHOD_2 ( STRING_2 ) . METHOD_3 ( STRING_3 ) . build ( ) ; String VAR_2 = VAR_1 . toString ( ) ; assertTrue ( VAR_2 . contains ( STRING_1 ) , STRING_4 + VAR_1 ) ; assertTrue ( VAR_2 . contains ( STRING_5 ) , STRING_4 + VAR_1 ) ; assertTrue ( VAR_2 . contains ( STRING_6 ) , STRING_4 + VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( final String id ) { return METHOD_2 ( METHOD_3 ( ) , new TYPE_2 < TYPE_1 > ( ) { @Override public boolean apply ( TYPE_1 input ) { <START> return input . equals ( id ) ; <END> } } , null ) ; } 
protected void METHOD_1 ( ) { <START> bind ( TYPE_5 . TYPE_3 . class ) . to ( TYPE_5 . TYPE_4 . class ) ; <END> } 
public Set < Integer > METHOD_1 ( ) { <START> if ( VAR_1 . isEmpty ( ) ) return TYPE_1 . of ( ) ; <END> return TYPE_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_1 , new TYPE_4 < TYPE_5 , Integer > ( ) { @Override public Integer apply ( TYPE_5 input ) { return input . VAR_2 ( ) . METHOD_4 ( ) ; } } ) ) ; } 
public TYPE_2 ( int id , ANNOTATION_1 String description , ANNOTATION_1 String VAR_2 , ANNOTATION_1 TYPE_1 VAR_3 ) { <START> this . id = METHOD_1 ( id , STRING_1 ) ; <END> this . description = description ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public TYPE_1 ( int VAR_2 , int id , int VAR_3 , String name ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . id = METHOD_1 ( id , STRING_2 ) ; <START> this . VAR_3 = METHOD_1 ( VAR_3 , STRING_3 ) ; <END> this . name = METHOD_1 ( name , STRING_4 ) ; } 
public TYPE_1 apply ( TYPE_2 VAR_1 , Map < String , TYPE_3 > VAR_2 , String VAR_3 , TYPE_1 options ) { if ( VAR_1 . METHOD_1 ( ) . size ( ) > 0 ) { options . VAR_4 ( VAR_1 . METHOD_1 ( ) ) ; } <START> if ( VAR_1 . METHOD_2 ( ) . size ( ) > 0 ) { <END> options . VAR_5 ( VAR_1 . METHOD_2 ( ) ) ; } return options ; } 
protected void METHOD_1 ( ) { try { VAR_1 = new TYPE_1 ( TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ) . build ( ) ; } catch ( TYPE_3 ex ) { <START> throw TYPE_4 . METHOD_4 ( ex ) ; <END> } catch ( TYPE_5 ex ) { throw TYPE_4 . METHOD_4 ( ex ) ; } } 
public TYPE_1 id ( String id ) { <START> this . VAR_1 . METHOD_1 ( STRING_1 , TYPE_2 . of ( id + "" ) ) ; <END> return this ; } 
<START> void METHOD_1 ( ) { <END> String VAR_1 = VAR_2 ; TYPE_1 < TYPE_2 > VAR_3 = TYPE_3 . METHOD_2 ( client . VAR_4 ( VAR_1 ) ) ; assertNotNull ( VAR_3 ) ; if ( VAR_3 . size ( ) >= 1 ) { TYPE_2 VAR_5 = VAR_3 . METHOD_3 ( ) ; TYPE_2 result = TYPE_4 . METHOD_4 ( client . VAR_6 ( VAR_1 , TYPE_5 < String , String > builder ( ) . put ( STRING_1 , VAR_5 . getId ( ) ) . build ( ) ) ) ; } } 
private TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 , TYPE_4 VAR_2 ) { return new TYPE_5 ( VAR_1 , VAR_2 ) ; <START> } <END> 
public void METHOD_1 ( ) throws InterruptedException { if ( System . getProperty ( STRING_1 ) . contains ( STRING_2 ) ) throw new TYPE_1 ( STRING_3 ) ; <START> else <END> super . METHOD_1 ( ) ; } 
protected void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> client . VAR_2 ( METHOD_2 ( group ) ) ; <END> } super . METHOD_1 ( ) ; } 
protected Builder ( ) { id ( STRING_1 ) . name ( STRING_2 ) . METHOD_1 ( new TYPE_1 ( ) ) . METHOD_2 ( TYPE_2 . create ( STRING_3 ) ) . METHOD_3 ( TYPE_2 . create ( STRING_4 ) ) <START> . METHOD_4 ( STRING_5 , STRING_6 , STRING_7 , STRING_8 , STRING_9 , STRING_7 , STRING_10 ) <END> . METHOD_5 ( STRING_11 ) . METHOD_6 ( TYPE_3 . METHOD_6 ( ) ) ; } 
public TYPE_1 METHOD_1 ( String name , TYPE_2 location ) { String VAR_1 = location . getId ( ) ; if ( VAR_1 != null ) { return METHOD_1 ( name , VAR_1 ) ; } else { return null ; <START> } <END> } 
public void METHOD_1 ( ) { TYPE_1 item = TYPE_1 . builder ( ) . build ( ) ; <START> assertEquals ( item . getId ( ) + "" , METHOD_2 ( ) . apply ( item ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . builder ( ) . id ( INT_1 ) . build ( ) ; TYPE_2 item = TYPE_2 . builder ( ) . id ( INT_2 ) . METHOD_2 ( VAR_1 ) . build ( ) ; <START> assertEquals ( STRING_1 , STRING_2 , METHOD_3 ( ) . apply ( item ) ) ; <END> } 
public static TYPE_1 < TYPE_2 , String > METHOD_1 ( ) { return new TYPE_1 < TYPE_2 , String > ( ) { @Override public String apply ( TYPE_2 VAR_1 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; TYPE_3 VAR_2 = TYPE_4 . METHOD_3 ( ) . apply ( VAR_1 ) ; METHOD_2 ( VAR_2 , STRING_2 ) ; <START> return String . valueOf ( VAR_2 . getId ( ) ) ; <END> } } ; } 
public boolean METHOD_1 ( String id ) { try { TYPE_1 VAR_1 = client . VAR_2 ( ) . METHOD_2 ( id ) ; boolean VAR_3 = VAR_4 . apply ( VAR_1 . METHOD_3 ( ) ) ; } catch ( Exception e ) { return false ; } <START> return true ; <END> } 
public Set < TYPE_1 > METHOD_1 ( final TYPE_2 location ) { String VAR_1 = TYPE_3 . METHOD_2 ( location ) ; if ( VAR_1 != null ) { return METHOD_1 ( VAR_1 ) ; } else { return TYPE_4 . of ( ) ; <START> } <END> } 
protected TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_5 . TYPE_6 factory , ANNOTATION_1 String VAR_1 , ANNOTATION_2 ( TYPE_7 . VAR_3 ) String VAR_4 ) { TYPE_1 < Map < String , TYPE_1 < TYPE_2 > > > VAR_5 = factory . VAR_6 ( TYPE_8 . VAR_8 , VAR_1 ) ; <START> if ( ! TYPE_4 . METHOD_2 ( VAR_4 ) ) { <END> return METHOD_3 ( VAR_5 , VAR_4 ) ; } else { return METHOD_4 ( VAR_5 ) ; } } 
public void METHOD_1 ( Exception exception ) { if ( exception instanceof IllegalArgumentException <START> || exception instanceof IllegalStateException ) { <END> throw new TYPE_1 ( exception ) ; } if ( exception instanceof TYPE_2 ) { METHOD_2 ( exception , exception . VAR_1 ( ) ) ; } METHOD_2 ( exception , exception ) ; } 
protected boolean METHOD_1 ( Exception e ) { TYPE_1 < TYPE_2 > VAR_1 = VAR_2 . METHOD_2 ( e ) ; if ( VAR_1 == null ) { return false ; } METHOD_3 ( e ) ; <START> logger . debug ( STRING_1 , e ) ; <END> VAR_1 . METHOD_1 ( result ) ; return true ; } 
public static TYPE_1 METHOD_1 ( Class < ? > type , TYPE_2 method ) { <START> TYPE_3 . METHOD_2 ( type ) ; <END> return new TYPE_4 ( new TYPE_5 ( type ) , method ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( ) ; <START> VAR_1 . METHOD_4 ( ) ; <END> VAR_2 . METHOD_5 ( new TYPE_1 ( null ) ) ; super . METHOD_1 ( ) ; } 
public < T extends View > T METHOD_1 ( Class < T > view ) { if ( ! METHOD_2 ( ) ) { return new TYPE_1 ( VAR_1 ) . METHOD_3 ( view ) ; } result . VAR_2 ( STRING_1 , METHOD_4 ( ) ) ; VAR_3 . METHOD_5 ( ) ; <START> logger . debug ( STRING_2 , VAR_4 . METHOD_6 ( ) ) ; <END> return VAR_5 . METHOD_7 ( view , VAR_4 . METHOD_6 ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { Status status = METHOD_2 ( Status . VAR_1 ) ; result . VAR_2 ( new TYPE_1 ( ) ) ; METHOD_3 ( status ) . METHOD_4 ( TYPE_1 . VAR_1 ) ; <START> METHOD_3 ( VAR_3 ) . METHOD_5 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> VAR_1 = VAR_2 . get ( VAR_3 , STRING_1 ) . equalsIgnoreCase ( STRING_1 ) ; <END> return this ; } 
public void METHOD_1 ( ) { when ( VAR_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ) . METHOD_4 ( new ArrayList < TYPE_1 > ( ) ) ; VAR_3 . METHOD_5 ( VAR_2 ) ; List < TYPE_1 > VAR_4 = ( List < TYPE_1 > ) result . VAR_5 ( ) . get ( STRING_1 ) ; Assert . assertTrue ( VAR_4 . isEmpty ( ) ) ; <START> } <END> 
public void METHOD_1 ( ) { VAR_1 . add ( user ) ; METHOD_2 ( VAR_2 ) . add ( user ) ; assertEquals ( STRING_1 + user . getName ( ) + STRING_2 , result . VAR_3 ( ) . get ( STRING_3 ) ) ; <START> } <END> 
private TYPE_1 < String > METHOD_1 ( final String VAR_1 ) { return new TYPE_1 < String > ( ) { @Override public boolean apply ( String input ) { <START> return VAR_1 . contains ( input ) ; <END> } } ; } 
public String get ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_1 ( ) ; <START> TYPE_3 VAR_3 = VAR_2 . METHOD_2 ( TYPE_3 . class ) ; <END> String key = VAR_3 . value ( ) ; if ( METHOD_3 ( key ) ) key = VAR_1 . METHOD_4 ( ) . getName ( ) ; return VAR_4 . get ( key ) ; } 
public < T > T METHOD_1 ( Class < T > type ) { type = ( Class < T > ) TYPE_1 . METHOD_2 ( type ) ; <START> logger . debug ( STRING_1 , type ) ; <END> TYPE_2 < ? > VAR_1 = METHOD_3 ( type ) ; TYPE_3 < ? > ctx = VAR_2 . METHOD_4 ( VAR_1 ) ; return ( T ) VAR_2 . METHOD_5 ( VAR_1 , type , ctx ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_1 ) ; <END> this . VAR_1 = VAR_1 ; } 
<START> public TYPE_1 ( ) { <END> } 
private void METHOD_1 ( ) { response . VAR_1 ( new TYPE_2 . TYPE_3 ( ) { @Override public void METHOD_2 ( ) { if ( ! VAR_2 . METHOD_3 ( ) && VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) ) { <START> VAR_3 . METHOD_4 ( ) . commit ( ) ; <END> } } } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) ; TYPE_2 VAR_2 = null ; try { VAR_2 = VAR_3 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( ) ; VAR_1 . next ( ) ; if ( ! VAR_4 . METHOD_5 ( ) && VAR_2 . METHOD_6 ( ) ) { VAR_2 . commit ( ) ; <START> } <END> } finally { if ( VAR_2 != null && VAR_2 . METHOD_6 ( ) ) { VAR_2 . METHOD_7 ( ) ; } } } 
@Override void apply ( TYPE_1 builder , ANNOTATION_1 Object value ) { try { METHOD_1 ( value , STRING_1 ) ; <START> } catch ( TYPE_2 VAR_1 ) { <END> throw Utils . VAR_2 ( method , VAR_1 , p , STRING_1 ) ; } builder . VAR_3 ( value ) ; } 
TYPE_5 ( TYPE_1 method , int p , TYPE_2 VAR_2 , TYPE_3 < T , TYPE_4 > VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . method = method ; <START> this . p = p ; <END> } 
Path ( TYPE_1 method , int p , String name , TYPE_2 < T , String > VAR_1 , boolean VAR_2 ) { <START> this . name = METHOD_1 ( name , STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; this . method = method ; this . p = p ; } 
static Type METHOD_1 ( int index , TYPE_1 type ) { Type [ ] VAR_1 = type . VAR_2 ( ) ; if ( index < 0 || index >= VAR_1 . length ) { <START> throw new IllegalArgumentException ( <END> STRING_1 + index + STRING_2 + VAR_1 . length + STRING_3 + type ) ; } Type VAR_3 = VAR_1 [ index ] ; if ( VAR_3 instanceof TYPE_2 ) { return ( ( TYPE_2 ) VAR_3 ) . METHOD_2 ( ) [ 0 ] ; } return VAR_3 ; } 
public static < T > Response < T > METHOD_1 ( int VAR_1 , ANNOTATION_1 T VAR_2 ) { <START> if ( VAR_1 < INT_1 || VAR_1 >= INT_2 ) throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; <END> return METHOD_1 ( VAR_2 , new TYPE_1 . Response . Builder ( ) . METHOD_2 ( VAR_1 ) . message ( STRING_2 ) . METHOD_3 ( TYPE_3 . VAR_4 ) . request ( new TYPE_2 . Builder ( ) . url ( STRING_3 ) . build ( ) ) . build ( ) ) ; } 
ANNOTATION_1 public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 . Builder ( ) . METHOD_2 ( server . url ( STRING_1 ) ) . build ( ) ; <START> assertEquals ( VAR_1 . METHOD_3 ( ) . size ( ) - 1 , <END> VAR_1 . METHOD_4 ( ) . METHOD_3 ( ) . size ( ) ) ; } 
void METHOD_1 ( Throwable t ) { set ( VAR_1 ) ; if ( ! METHOD_2 ( ) ) { try { <START> if ( ! METHOD_2 ( ) ) { <END> VAR_2 . METHOD_3 ( t ) ; } } catch ( Throwable VAR_3 ) { TYPE_1 . METHOD_4 ( VAR_3 ) ; TYPE_2 VAR_4 = new TYPE_2 ( t , VAR_3 ) ; TYPE_3 . getInstance ( ) . METHOD_5 ( ) . METHOD_6 ( VAR_4 ) ; } } } 
<START> private void METHOD_1 ( int VAR_1 , String message ) { <END> if ( VAR_1 < 0 || VAR_1 > 100 ) { throw new IllegalArgumentException ( message ) ; } } 
public TYPE_1 < TYPE_2 , ? > METHOD_1 ( Type type , TYPE_3 [ ] VAR_1 , TYPE_4 VAR_2 ) { TYPE_5 < ? > VAR_3 = VAR_4 . METHOD_2 ( type , METHOD_3 ( VAR_1 ) ) ; if ( VAR_5 ) { VAR_3 = VAR_3 . METHOD_4 ( ) ; } if ( VAR_6 ) { <START> VAR_3 . METHOD_5 ( ) ; <END> } return new TYPE_6 < > ( VAR_3 ) ; } 
public Builder ( TYPE_1 VAR_1 ) { this . VAR_2 = VAR_1 . VAR_2 ; this . VAR_3 = VAR_1 . VAR_3 ; this . VAR_4 = VAR_1 . VAR_4 ; <START> this . VAR_5 = VAR_1 . VAR_5 ; <END> this . VAR_6 = VAR_1 . VAR_6 ; this . VAR_7 = VAR_1 . VAR_7 ; this . VAR_8 = VAR_1 . VAR_8 ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 ) { <END> return this ; } return create ( VAR_2 , true ) ; } 
ANNOTATION_1 public void METHOD_1 ( ) { server . VAR_1 ( new TYPE_1 ( ) . METHOD_2 ( STRING_1 ) ) ; try { VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; assertThat ( true ) ; } catch ( RuntimeException e ) { METHOD_5 ( ) ; <START> } <END> } 
<START> private TYPE_2 ( TYPE_1 VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
@Override public T METHOD_1 ( TYPE_1 value ) throws IOException { <START> TYPE_2 source = value . source ( ) ; <END> try { return VAR_1 . METHOD_2 ( source ) ; } finally { if ( source != null ) { try { source . close ( ) ; } catch ( IOException VAR_2 ) { } } } } 
@Override public < R > TYPE_1 < TYPE_2 < R > > METHOD_1 ( TYPE_3 < R > call , TYPE_4 VAR_1 ) { return TYPE_1 . create ( new TYPE_5 < > ( call , VAR_1 ) ) <START> . METHOD_2 ( new TYPE_6 < Throwable , TYPE_2 < R > > ( ) { <END> @Override public TYPE_2 < R > call ( Throwable VAR_2 ) { return TYPE_2 . error ( VAR_2 ) ; } } ) ; } 
<START> public static TYPE_1 create ( ) { <END> return VAR_1 ; } 
public static < T > TYPE_1 < T > response ( final Response < T > response ) { return new TYPE_1 < T > ( ) { @Override public Response < T > execute ( ) throws IOException { return response ; } @Override public void METHOD_1 ( TYPE_2 < T > VAR_1 ) { VAR_1 . METHOD_2 ( response ) ; } @Override public void METHOD_3 ( ) { } ANNOTATION_1 ( STRING_1 ) @Override public TYPE_1 < T > METHOD_4 ( ) { <START> return response ( response ) ; <END> } } ; } 
<START> public synchronized void METHOD_1 ( ) { <END> VAR_1 = true ; TYPE_2 . TYPE_3 . VAR_2 . TYPE_4 VAR_4 = this . VAR_4 ; if ( VAR_4 != null ) { VAR_4 . METHOD_1 ( ) ; } } 
ANNOTATION_1 public TYPE_1 read ( TYPE_2 VAR_1 ) throws IOException { VAR_1 . METHOD_1 ( ) ; String name = null ; <START> while ( VAR_1 . METHOD_2 ( ) != TYPE_2 . TYPE_4 . VAR_3 ) { <END> switch ( VAR_1 . METHOD_3 ( ) ) { case STRING_1 : name = VAR_1 . METHOD_4 ( ) ; break ; } } VAR_1 . METHOD_5 ( ) ; return new TYPE_3 ( name ) ; } 
static < T > T METHOD_1 ( T object , String message , Object ... args ) { <START> if ( args . length > 0 ) message = String . format ( message , args ) ; <END> if ( object == null ) throw new TYPE_1 ( message ) ; return object ; } 
private static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { <START> if ( VAR_1 == null ) { <END> return null ; } return new TYPE_1 ( ) { @Override public String METHOD_2 ( ) { return VAR_1 . METHOD_3 ( ) . toString ( ) ; } @Override public long length ( ) { return VAR_1 . METHOD_4 ( ) ; } @Override public TYPE_3 in ( ) throws IOException { return VAR_1 . METHOD_5 ( ) ; } } ; } 
<START> public String toString ( ) { <END> try { return STRING_1 + new String ( METHOD_1 ( ) , STRING_2 ) + STRING_3 ; } catch ( TYPE_1 e ) { throw new TYPE_2 ( STRING_4 ) ; } } 
void METHOD_1 ( String name , TYPE_1 < ? > values ) { if ( name == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( values == null ) { throw new IllegalArgumentException ( STRING_2 ) ; } for ( Object value : values ) { <START> VAR_1 . METHOD_2 ( name , value . toString ( ) ) ; <END> } } 
public List < byte [ ] > METHOD_1 ( ) throws Exception { <START> List < byte [ ] > VAR_1 = new ArrayList < byte [ ] > ( ) ; <END> for ( TYPE_1 VAR_2 : VAR_3 ) { TYPE_2 VAR_4 = new TYPE_2 ( ) ; try { VAR_2 . METHOD_2 ( VAR_4 ) ; VAR_1 . add ( VAR_4 . METHOD_3 ( ) ) ; } finally { VAR_4 . close ( ) ; } } return VAR_1 ; } 
<START> public String METHOD_1 ( ) { <END> return null ; } 
<START> public String METHOD_1 ( ) { <END> return STRING_1 + VAR_1 ; } 
<START> public long length ( ) { <END> return length ; } 
<START> public void METHOD_1 ( TYPE_1 out ) throws IOException { <END> for ( TYPE_2 VAR_1 : VAR_2 ) { VAR_1 . METHOD_1 ( out ) ; } out . write ( VAR_3 ) ; } 
ANNOTATION_1 public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_2 ( STRING_1 , Arrays . asList ( new String [ ] { STRING_2 , STRING_3 } ) ) ; <END> TYPE_2 out = new TYPE_2 ( ) ; VAR_1 . METHOD_3 ( out ) ; String VAR_2 = new String ( out . VAR_3 ( ) , STRING_4 ) ; assertThat ( VAR_2 ) . METHOD_4 ( STRING_5 ) ; } 
@Override public void METHOD_1 ( String name , String value ) { <START> boolean VAR_1 = false ; <END> METHOD_1 ( name , value , VAR_1 ) ; } 
public TYPE_3 ( ) { this ( new TYPE_1 ( ) ) ; TYPE_1 client = ( TYPE_1 ) this . client ; <START> this . VAR_2 = new TYPE_2 ( ) ; <END> client . VAR_3 ( this . VAR_2 ) ; } 
void METHOD_1 ( String name , TYPE_1 VAR_1 ) { if ( name == null ) { throw new TYPE_2 ( STRING_1 ) ; } if ( VAR_1 == null ) { throw new TYPE_2 ( STRING_2 ) ; } boolean VAR_2 = ( VAR_3 . size ( ) == 0 ) ; <START> byte [ ] VAR_4 = METHOD_2 ( name , VAR_1 , VAR_2 ) ; <END> VAR_3 . add ( VAR_4 ) ; length += VAR_4 . length ; } 
public static TYPE_1 METHOD_1 ( Class c , String name ) { <START> TYPE_1 [ ] VAR_1 = c . VAR_2 ( ) ; <END> for ( TYPE_1 method : VAR_1 ) { if ( method . getName ( ) . equals ( name ) ) { return method ; } } throw new IllegalArgumentException ( STRING_1 + name + STRING_2 + c ) ; } 
public static boolean METHOD_1 ( String VAR_1 ) { return StringUtils . startsWith ( VAR_1 , TYPE_2 . VAR_3 ) || TYPE_1 . startsWith ( VAR_1 , TYPE_2 . VAR_4 ) <START> || TYPE_1 . startsWith ( VAR_1 , TYPE_2 . VAR_5 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { String text = STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 ; List < TYPE_1 > res = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( text , VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ) ; assertNotNull ( res ) ; <START> System . out . println ( res ) ; <END> assertTrue ( res . size ( ) > 2 ) ; } 
public static void METHOD_1 ( String [ ] args ) throws Exception { TYPE_1 . getInstance ( ) ; TYPE_2 VAR_1 = new TYPE_2 ( ) ; TYPE_3 . METHOD_2 ( VAR_1 ) ; <START> TYPE_3 . METHOD_3 ( VAR_1 ) ; <END> System . VAR_2 ( 0 ) ; } 
public static < T > TYPE_1 < T > create ( TYPE_2 VAR_1 , String VAR_2 , TYPE_3 < byte [ ] , T > VAR_3 , TYPE_4 < T > VAR_4 ) throws InterruptedException , TYPE_5 , TYPE_6 { TYPE_1 < T > VAR_5 = <START> new TYPE_1 < T > ( VAR_1 , VAR_2 , new TYPE_7 < T > ( VAR_3 ) , <END> VAR_4 ) ; VAR_5 . METHOD_1 ( ) ; return VAR_5 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> VAR_2 . VAR_3 . VAR_4 . TYPE_3 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> VAR_6 = ( TYPE_2 ) VAR_1 . METHOD_5 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 update ) { <START> if ( VAR_2 . METHOD_2 ( VAR_1 , update ) ) { <END> switch ( VAR_1 ) { case VAR_3 : TYPE_2 . getInstance ( METHOD_3 ( ) . METHOD_4 ( ) ) . METHOD_5 ( VAR_4 ) ; break ; case VAR_5 : default : break ; } switch ( update ) { case VAR_3 : TYPE_2 . getInstance ( METHOD_3 ( ) . METHOD_4 ( ) ) . METHOD_6 ( VAR_4 , VAR_6 ) ; break ; case VAR_5 : default : break ; } } } 
public void METHOD_1 ( View view ) { ArrayList < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( VAR_3 . METHOD_3 ( ) . toString ( ) ) ; <START> if ( VAR_1 == null || VAR_1 . size ( ) != 1 ) { <END> return ; } VAR_4 . setText ( String . valueOf ( VAR_1 . get ( 0 ) . VAR_5 ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( R . id . VAR_3 ) ; <START> if ( VAR_2 == null || ! ( VAR_2 instanceof TYPE_3 ) ) { <END> VAR_2 = new TYPE_3 ( ) ; VAR_1 . METHOD_4 ( ) . METHOD_5 ( R . id . VAR_3 , VAR_2 ) . commit ( ) ; } } 
public void METHOD_1 ( ANNOTATION_1 int VAR_1 ) { final int VAR_2 = METHOD_2 ( ) ; final TYPE_1 VAR_3 = METHOD_3 ( ) ; TYPE_2 VAR_4 = VAR_3 . METHOD_4 ( VAR_2 ) ; <START> if ( VAR_4 != null && VAR_4 instanceof TYPE_3 ) { <END> ( ( TYPE_3 ) VAR_4 ) . METHOD_1 ( VAR_1 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = VAR_1 . METHOD_2 ( TYPE_2 . VAR_4 , false ) ; if ( VAR_2 ) { ArrayList < File > VAR_5 = ( ArrayList < File > ) VAR_1 . METHOD_3 ( TYPE_2 . VAR_6 ) ; <START> VAR_7 . METHOD_1 ( VAR_5 ) ; <END> } else { String VAR_8 = VAR_1 . METHOD_4 ( TYPE_2 . VAR_9 ) ; METHOD_5 ( VAR_8 ) ; } } 
private void METHOD_1 ( ) { <START> File VAR_1 = METHOD_2 ( ) . METHOD_3 ( null ) ; <END> File VAR_2 = new File ( VAR_1 . getPath ( ) + STRING_1 ) ; TYPE_1 . d ( STRING_2 + VAR_2 . getPath ( ) ) ; METHOD_4 ( METHOD_2 ( ) , VAR_2 ) ; } 
private static String METHOD_1 ( File VAR_1 ) { <START> File VAR_2 = null ; <END> if ( TYPE_2 . VAR_4 . VAR_5 >= TYPE_2 . VAR_6 . VAR_7 ) { VAR_2 = VAR_1 ; try { while ( TYPE_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ) { VAR_2 = VAR_2 . METHOD_3 ( ) ; } } catch ( IllegalArgumentException e ) { return VAR_2 . METHOD_4 ( ) ; } } return VAR_2 . METHOD_4 ( ) ; } 
public static TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; final TYPE_2 args = new TYPE_2 ( ) ; <START> VAR_1 . METHOD_2 ( args ) ; <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( final int position ) { <START> if ( ( position >= 0 ) && ( position < VAR_1 . size ( ) ) ) <END> return VAR_1 . get ( position ) ; else return null ; } 
public TYPE_1 [ ] [ ] METHOD_1 ( ) { <START> return new TYPE_1 [ ] [ ] { { METHOD_2 ( ) . getString ( R . string . VAR_1 ) } , <END> { STRING_1 } } ; } 
public void METHOD_1 ( TYPE_3 . TYPE_4 event , TYPE_2 VAR_1 ) { <START> if ( event . equals ( TYPE_3 . TYPE_4 . VAR_2 ) ) { <END> if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) { VAR_3 . METHOD_4 ( VAR_4 , FLOAT_1 , FLOAT_1 , 1 , 1 , FLOAT_1 ) ; } else { VAR_3 . METHOD_5 ( VAR_4 ) ; } } } 
private static String METHOD_1 ( Class < ? extends TYPE_1 > type ) { TYPE_2 VAR_1 = type . VAR_2 ( TYPE_2 . class ) ; String name = type . getName ( ) ; if ( VAR_1 != null && VAR_1 . value ( ) . length ( ) > 0 ) { name = VAR_1 . value ( ) ; } <START> name = VAR_3 + name . VAR_4 ( CHAR_1 , CHAR_2 ) ; <END> return name ; } 
private void METHOD_1 ( File VAR_1 ) throws IOException { List < String > VAR_2 = config . VAR_3 ( ) ; if ( ! VAR_2 . isEmpty ( ) ) { <START> TYPE_1 VAR_4 = new TYPE_1 ( new File ( VAR_1 , STRING_1 ) ) ; <END> String VAR_5 = StringUtils . toString ( VAR_2 . METHOD_2 ( new String [ VAR_2 . size ( ) ] ) , STRING_2 ) ; VAR_4 . write ( VAR_5 ) ; VAR_4 . close ( ) ; } } 
private static void METHOD_1 ( ANNOTATION_1 long VAR_1 , ANNOTATION_1 long VAR_2 ) { if ( TYPE_1 . METHOD_2 ( VAR_1 , VAR_3 ) == 1 ) { synchronized ( TYPE_2 ) { TYPE_2 . remove ( VAR_1 ) ; } } long VAR_4 = TYPE_1 . METHOD_3 ( VAR_1 ) ; <START> long VAR_5 = VAR_6 . get ( VAR_4 ) ; <END> TYPE_3 VAR_7 = new TYPE_3 ( VAR_1 , VAR_5 ) ; TYPE_1 . METHOD_4 ( VAR_7 . METHOD_5 ( ) , VAR_2 ) ; } 
private static ANNOTATION_1 long METHOD_1 ( TYPE_1 VAR_1 , ANNOTATION_1 long VAR_2 ) { <START> if ( TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_3 ) == 1 ) { <END> synchronized ( TYPE_3 ) { TYPE_3 . put ( VAR_1 . METHOD_3 ( ) , VAR_1 ) ; } } return TYPE_2 . METHOD_4 ( new TYPE_4 ( VAR_1 . METHOD_3 ( ) , VAR_4 ) . METHOD_3 ( ) , VAR_2 ) ; } 
public static TYPE_1 METHOD_1 ( int error ) { switch ( error ) { case 0 : return VAR_1 ; case 1 : return VAR_2 ; case 2 : return VAR_3 ; case 3 : return VAR_4 ; case 4 : return VAR_5 ; case 5 : return VAR_6 ; case INT_1 : return VAR_7 ; default : <START> return VAR_8 ; <END> } } 
public TYPE_4 ( TYPE_1 VAR_2 , float VAR_3 , float VAR_4 ) { super ( VAR_2 , VAR_3 , VAR_4 ) ; <START> this . VAR_5 = TYPE_2 . METHOD_1 ( STRING_1 , ( ( TYPE_3 ) VAR_2 ) . METHOD_2 ( ) ) ; <END> } 
private boolean METHOD_1 ( final TYPE_1 ... VAR_1 ) { <START> Boolean result = null ; <END> if ( this . VAR_2 . isEmpty ( ) ) { result = false ; } else { for ( final TYPE_1 obj : VAR_1 ) { if ( ! this . VAR_2 . contains ( obj ) ) { result = false ; break ; } } } if ( result == null ) { result = true ; } return result ; } 
private boolean METHOD_1 ( final TYPE_1 ... VAR_1 ) { <START> Boolean result = null ; <END> if ( this . VAR_2 . isEmpty ( ) ) { result = false ; } else { for ( final TYPE_1 obj : VAR_1 ) { if ( this . VAR_2 . contains ( obj ) ) { result = true ; break ; } } } if ( result == null ) { result = false ; } return result ; } 
public boolean contains ( int VAR_1 ) { final boolean VAR_2 = VAR_3 == null || VAR_1 >= VAR_3 ; <START> final boolean VAR_4 = VAR_5 == null || VAR_1 <= VAR_5 ; <END> return VAR_2 && VAR_4 ; } 
<START> protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return METHOD_2 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; TYPE_3 metadata = VAR_2 . METHOD_2 ( ) ; TYPE_4 VAR_3 = VAR_4 . METHOD_3 ( ) . METHOD_4 ( metadata . VAR_5 ( ) ) ; if ( VAR_3 != null ) { <START> return VAR_3 . METHOD_5 ( ) ; <END> } throw new IllegalStateException ( STRING_1 ) ; } 
public static byte [ ] METHOD_1 ( byte [ ] data ) throws TYPE_1 { TYPE_2 VAR_1 ; VAR_1 = TYPE_2 . getInstance ( STRING_1 ) ; VAR_1 . METHOD_2 ( ) ; VAR_1 . update ( data ) ; <START> return VAR_1 . METHOD_3 ( ) ; <END> } 
<START> static Pair < TYPE_1 , Boolean > METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 ) { <END> TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; int VAR_3 = VAR_2 . METHOD_3 ( ) ; int VAR_4 = VAR_2 . METHOD_4 ( ) ; TYPE_1 VAR_5 = METHOD_5 ( VAR_1 , VAR_3 , VAR_4 ) ; boolean VAR_6 = METHOD_6 ( VAR_1 , VAR_3 , VAR_4 ) ; return new Pair < > ( VAR_5 , VAR_6 ) ; } 
<START> protected int METHOD_1 ( ) { <END> return VAR_1 . size ( ) ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_3 . VAR_3 , false ) ; <START> final TYPE_1 VAR_4 = new TYPE_1 ( new TYPE_2 ( STRING_1 ) , false , false , null ) ; <END> VAR_5 . METHOD_3 ( model , 5 , INT_1 , VAR_4 ) ; assertEquals ( 0 , METHOD_4 ( model ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { try { TYPE_2 . METHOD_2 ( VAR_1 ) ; } catch ( TYPE_3 e ) { <START> log . error ( STRING_1 + VAR_1 , e ) ; <END> } } 
public boolean METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { if ( this . VAR_2 . containsKey ( VAR_1 ) ) { <START> return this . VAR_2 . get ( VAR_1 ) . getValue ( ) ; <END> } return false ; } 
<START> static String METHOD_1 ( File VAR_1 ) { <END> String VAR_2 ; try ( TYPE_1 VAR_3 = new TYPE_1 ( VAR_1 ) ) { TYPE_2 VAR_4 = new TYPE_2 ( VAR_3 ) ; VAR_2 = VAR_4 . METHOD_2 ( ) . getValue ( VAR_5 ) ; } catch ( IOException e ) { throw new TYPE_3 ( STRING_1 + VAR_1 . METHOD_3 ( ) , e ) ; } return VAR_2 ; } 
<START> static String [ ] METHOD_1 ( String value , List < String > VAR_1 ) { <END> return Arrays . stream ( value . split ( STRING_1 ) ) . map ( ( it ) - > { return it . split ( STRING_2 ) [ 0 ] ; } ) . filter ( ( it ) - > { return ! VAR_1 . contains ( it ) ; } ) . METHOD_2 ( String [ ] : : new ) ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 ; if ( VAR_1 == null ) { return null ; } <START> TYPE_3 VAR_3 = VAR_1 . METHOD_2 ( TYPE_3 . class ) ; <END> if ( ! VAR_3 . METHOD_3 ( ) ) { return null ; } return VAR_3 . METHOD_4 ( ) ; } 
public boolean METHOD_1 ( ) { <START> if ( status == Type . VAR_1 || status == Type . VAR_2 ) return true ; <END> return false ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; TYPE_1 VAR_3 = session ; if ( VAR_3 != null ) { VAR_3 . METHOD_3 ( VAR_4 ) ; METHOD_4 ( VAR_3 ) ; } <START> VAR_5 . clear ( ) ; <END> VAR_6 . clear ( ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( VAR_2 ) ) ; <END> VAR_1 . METHOD_2 ( STRING_1 , TYPE_3 . class ) ; return VAR_1 ; } 
public void METHOD_1 ( final int VAR_1 , final int VAR_2 ) { <START> this . METHOD_2 ( ( ) - > VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ) ; <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { final TYPE_2 < RuntimeException > exception = new TYPE_2 < RuntimeException > ( ) ; VAR_2 . METHOD_2 ( ) . METHOD_1 ( ( ) - > { try { VAR_1 . run ( ) ; } catch ( RuntimeException e ) { exception . set ( e ) ; } <START> } ) ; <END> if ( exception . get ( ) != null ) { throw exception . get ( ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ( Boolean ) <END> this . VAR_2 . METHOD_2 ( String . format ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ) ; } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; TYPE_1 VAR_1 = ( TYPE_1 ) obj ; <START> if ( path == null ) { <END> if ( VAR_1 . path != null ) return false ; } else if ( ! path . equals ( VAR_1 . path ) ) return false ; return true ; } 
public TYPE_4 ( ) { <START> VAR_2 = new HashMap < String , TYPE_1 > ( ) ; <END> VAR_3 = new HashMap < TYPE_1 , String > ( ) ; VAR_4 = new HashMap < TYPE_2 , List < String > > ( ) ; VAR_5 = new HashMap < TYPE_1 , Set < TYPE_3 > > ( ) ; VAR_6 = new HashSet < TYPE_1 > ( ) ; VAR_7 = new HashSet < TYPE_1 > ( ) ; } 
public synchronized void METHOD_1 ( TYPE_1 user ) { <START> List < String > VAR_1 = new ArrayList < String > ( ) ; <END> for ( String VAR_2 : VAR_3 . keySet ( ) ) { VAR_1 . add ( VAR_2 ) ; } this . VAR_4 . put ( user , VAR_1 ) ; } 
private static TYPE_1 METHOD_1 ( final TYPE_2 target ) { return new TYPE_1 ( ) { @Override public void METHOD_2 ( TYPE_3 VAR_1 ) { if ( VAR_1 instanceof TYPE_4 ) { target . VAR_2 ( METHOD_3 ( ( TYPE_4 ) VAR_1 ) ) ; } else if ( VAR_1 instanceof TYPE_5 ) { target . VAR_2 ( METHOD_4 ( ( TYPE_5 ) VAR_1 ) ) ; } else if ( VAR_1 instanceof TYPE_6 ) { target . VAR_2 ( METHOD_5 ( ( TYPE_6 ) VAR_1 ) ) ; } else { <START> return ; <END> } } } ; } 
<START> public synchronized void start ( ) { <END> session . VAR_1 ( VAR_2 , TYPE_1 . VAR_4 ) ; session . VAR_5 ( this ) ; } 
void METHOD_1 ( ANNOTATION_1 String path , ANNOTATION_2 TYPE_1 VAR_1 , ANNOTATION_2 TYPE_2 VAR_2 , ANNOTATION_2 TYPE_3 VAR_3 ) { TYPE_4 VAR_4 = new TYPE_4 ( VAR_1 , VAR_2 , VAR_3 ) ; TYPE_4 VAR_5 = VAR_6 . put ( path , VAR_4 ) ; <START> if ( VAR_5 != null ) { <END> if ( log . VAR_7 ( ) ) { log . trace ( STRING_1 + path + STRING_2 + VAR_5 + STRING_3 + VAR_4 ) ; } } } 
public void run ( ) { TYPE_1 session = VAR_1 . METHOD_1 ( ) ; TYPE_2 VAR_2 = METHOD_2 ( ) ; if ( session != null || VAR_2 == null ) { return ; } <START> if ( ! VAR_3 . METHOD_3 ( VAR_2 , TYPE_6 . VAR_5 ) ) { <END> return ; } VAR_6 . METHOD_4 ( VAR_2 , TYPE_4 . TYPE_5 . create ( new TYPE_4 ( ) ) ) ; } 
protected void METHOD_1 ( ) { <START> if ( ! session . VAR_1 ( ) || session . VAR_2 ( ) . isEmpty ( ) ) <END> VAR_3 . METHOD_2 ( TYPE_1 . VAR_5 ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { if ( this . VAR_1 && ! VAR_1 ) { if ( LOG . VAR_2 ( ) ) { <START> LOG . trace ( STRING_1 ) ; <END> } this . VAR_1 = false ; VAR_3 . METHOD_2 ( this ) ; } else if ( ! this . VAR_1 && VAR_1 ) { if ( LOG . VAR_2 ( ) ) { LOG . trace ( STRING_2 ) ; } this . VAR_1 = true ; VAR_3 . METHOD_3 ( this ) ; } } 
<START> public synchronized TYPE_1 get ( TYPE_2 VAR_1 ) { <END> if ( VAR_2 . containsKey ( VAR_1 ) ) { return VAR_2 . get ( VAR_1 ) ; } return null ; } 
private List < TYPE_1 > create ( TYPE_2 action ) { <START> List < TYPE_1 > VAR_1 = new TYPE_3 < TYPE_1 > ( ) ; <END> TYPE_4 parent = VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) ; TYPE_4 VAR_3 = parent . VAR_4 ( null , action . VAR_5 ( ) ) ; VAR_3 . METHOD_3 ( action . VAR_6 ( ) ) ; VAR_1 . add ( VAR_3 ) ; VAR_1 . addAll ( METHOD_4 ( VAR_3 , action . VAR_7 ( ) ) ) ; return VAR_1 ; } 
protected void METHOD_1 ( TYPE_1 monitor , Map < String , TYPE_2 > VAR_1 ) { <START> METHOD_2 ( VAR_1 ) ; <END> for ( TYPE_2 project : VAR_1 . values ( ) ) VAR_2 . METHOD_3 ( project ) ; super . METHOD_1 ( monitor , VAR_1 ) ; } 
<START> @Override public void start ( ) { <END> session . VAR_1 ( this , TYPE_1 . VAR_3 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 path = VAR_1 . getPath ( ) ; TYPE_3 VAR_2 = path . VAR_3 ( ) ; <START> this . VAR_4 . METHOD_2 ( path ) ; <END> VAR_2 . METHOD_3 ( TYPE_4 . NONE ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> content . VAR_2 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) . length ( ) ) ; <END> content . VAR_3 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_4 ( ) ) ; } 
public final void METHOD_1 ( TYPE_1 session , TYPE_2 container ) { container . VAR_1 ( TYPE_3 . class ) ; container . VAR_1 ( TYPE_4 . class ) ; container . VAR_1 ( TYPE_5 . class ) ; container . VAR_1 ( TYPE_6 . class ) ; <START> container . VAR_1 ( TYPE_7 . class ) ; <END> } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 properties ) { METHOD_2 ( properties ) ; METHOD_3 ( properties ) ; <START> METHOD_4 ( System . VAR_1 ( ) , properties ) ; <END> } 
public void METHOD_1 ( ) throws Exception { for ( TYPE_1 VAR_1 : TYPE_1 . values ( ) ) { if ( VAR_1 == TYPE_1 . VAR_2 ) { continue ; <START> } <END> VAR_3 . METHOD_2 ( STRING_1 , STRING_2 ) . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) . create ( ) ; TYPE_2 VAR_4 = VAR_3 . METHOD_5 ( ) ; METHOD_6 ( VAR_1 , VAR_4 , VAR_5 ) ; } } 
public void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 ) { this . VAR_1 = VAR_1 ; <START> } <END> } 
@Override public TYPE_1 element ( ) { VAR_1 . METHOD_1 ( ) ; try { if ( VAR_2 . isEmpty ( ) ) { throw new TYPE_2 ( ) ; } return VAR_2 . METHOD_2 ( ) ; } catch ( IOException e ) { TYPE_4 < TYPE_3 > METHOD_3 ( e ) ; <START> return null ; <END> } finally { VAR_1 . METHOD_4 ( ) ; } } 
@Override public Iterator < TYPE_1 > iterator ( ) { VAR_1 . METHOD_1 ( ) ; try { <START> return VAR_2 . iterator ( ) ; <END> } finally { VAR_1 . METHOD_2 ( ) ; } } 
@Override public boolean addAll ( Collection < ? extends TYPE_1 > c ) { if ( c . isEmpty ( ) ) { return false ; } VAR_1 . METHOD_1 ( ) ; try { for ( TYPE_1 e : c ) { VAR_2 . add ( e ) ; } VAR_3 . METHOD_2 ( ) ; return true ; } catch ( IOException e ) { TYPE_3 < TYPE_2 > METHOD_3 ( e ) ; <START> return false ; <END> } finally { VAR_1 . METHOD_4 ( ) ; } } 
@Override public void clear ( ) { VAR_1 . METHOD_1 ( ) ; try { VAR_2 . clear ( ) ; } catch ( IOException e ) { <START> TYPE_2 < TYPE_1 > METHOD_2 ( e ) ; <END> } finally { VAR_1 . METHOD_3 ( ) ; } } 
ANNOTATION_1 public void METHOD_1 ( ) throws Exception { VAR_1 = File . VAR_2 ( VAR_3 , STRING_1 ) ; assertTrue ( VAR_1 . METHOD_2 ( ) ) ; METHOD_3 ( VAR_1 . exists ( ) ) ; TYPE_1 VAR_4 = new TYPE_1 . Builder ( VAR_1 ) . build ( ) ; try { assertEquals ( 0 , VAR_4 . size ( ) ) ; assertTrue ( VAR_1 . exists ( ) ) ; } finally { <START> VAR_4 . close ( ) ; <END> } } 
static File METHOD_1 ( String file ) throws IOException { File VAR_1 = File . VAR_2 ( file , STRING_1 ) ; TYPE_1 in = TYPE_2 . class . METHOD_2 ( file ) ; TYPE_3 VAR_3 = TYPE_4 . buffer ( TYPE_4 . METHOD_3 ( VAR_1 ) ) ; VAR_3 . METHOD_4 ( TYPE_4 . source ( in ) ) ; <START> VAR_3 . METHOD_5 ( ) ; <END> VAR_3 . close ( ) ; assertTrue ( VAR_1 . exists ( ) ) ; return VAR_1 ; } 
@Override public T next ( ) { if ( VAR_1 ) throw new IllegalStateException ( STRING_1 ) ; METHOD_1 ( ) ; if ( size ( ) == 0 ) throw new TYPE_1 ( ) ; <START> if ( VAR_2 >= size ( ) ) throw new TYPE_1 ( ) ; <END> return VAR_3 . get ( VAR_2 ++ ) ; } 
ANNOTATION_1 public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( file ) ; for ( int i = 0 ; i < INT_1 ; i ++ ) { VAR_1 . add ( values [ i ] ) ; } Iterator < byte [ ] > iterator = VAR_1 . iterator ( ) ; iterator . next ( ) ; VAR_1 . remove ( ) ; try { iterator . remove ( ) ; <START> METHOD_2 ( STRING_1 ) ; <END> } catch ( TYPE_2 VAR_2 ) { } } 
public final void remove ( int n ) throws IOException { try { VAR_1 . remove ( n ) ; if ( listener != null ) { <START> for ( int i = 0 ; i < n ; i ++ ) <END> listener . VAR_2 ( this ) ; } } catch ( IOException e ) { throw new TYPE_1 ( STRING_1 , e , file ) ; } } 
<START> private TYPE_1 ( ) { <END> } 
<START> public boolean METHOD_1 ( final TYPE_1 config ) { <END> return STRING_1 . equals ( config . VAR_1 ( ) ) ; } 
public List < File > METHOD_1 ( ) { List < File > VAR_1 = VAR_2 . get ( ) ; return Collections . VAR_3 ( VAR_1 == null ? Collections . VAR_4 ( ) : VAR_1 ) ; <START> } <END> 
private boolean METHOD_1 ( String value ) { <START> return STRING_1 . equals ( value ) || STRING_2 . equals ( value ) ; <END> } 
TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = INT_1 ; <END> } 
public void METHOD_1 ( Level VAR_1 ) throws TYPE_1 { super . METHOD_1 ( VAR_1 ) ; <START> TYPE_2 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_1 ( VAR_1 ) ; } 
private TYPE_1 METHOD_1 ( Logger logger ) { synchronized ( this ) { for ( TYPE_2 VAR_1 : logger . VAR_2 ( ) ) { if ( VAR_1 instanceof TYPE_1 ) { return ( TYPE_1 ) VAR_1 ; } } TYPE_1 VAR_3 = new TYPE_1 ( VAR_4 . METHOD_2 ( logger . getName ( ) ) ) ; logger . VAR_5 ( VAR_3 ) ; logger . VAR_6 ( false ) ; <START> return VAR_3 ; <END> } } 
protected void METHOD_1 ( final TYPE_1 record ) { record . VAR_1 ( ) ; synchronized ( buffer ) { if ( METHOD_2 ( record ) ) { if ( buffer . size ( ) == VAR_2 ) { buffer . VAR_3 ( ) ; } buffer . VAR_4 ( record ) ; } for ( TYPE_2 VAR_5 : METHOD_3 ( ) ) { <START> if ( VAR_5 . METHOD_2 ( record ) ) { <END> VAR_5 . METHOD_4 ( record ) ; } } } } 
public static void METHOD_1 ( final TYPE_1 writer , final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final TYPE_3 VAR_3 , final TYPE_4 VAR_4 ) { if ( VAR_2 == null ) { return ; } for ( final TYPE_5 VAR_5 : VAR_2 . METHOD_2 ( ) ) { if ( ! VAR_3 . METHOD_3 ( VAR_5 . METHOD_4 ( ) ) ) { VAR_4 . METHOD_5 ( writer ) ; writer . println ( ) ; <START> writer . println ( VAR_5 . METHOD_6 ( VAR_1 ) ) ; <END> } } } 
private static String METHOD_1 ( final ArrayList < String > VAR_1 ) { HashMap map = new HashMap < > ( ) ; <START> for ( String e : VAR_1 ) <END> map . put ( STRING_1 , e ) ; System . out . println ( STRING_2 + map ) ; return new TYPE_1 ( ) . METHOD_2 ( map ) ; } 
public List < Integer > METHOD_1 ( ) { <START> assert VAR_1 == null || ! VAR_1 . isEmpty ( ) ; <END> if ( VAR_1 == null ) { int VAR_2 = target . VAR_3 ( ) ; List < Integer > res = new ArrayList < > ( VAR_2 ) ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { res . add ( i ) ; } return res ; } return VAR_1 ; } 
<START> public TYPE_5 ( TYPE_1 node , String VAR_2 ) { <END> VAR_3 = node ; logger = VAR_3 . METHOD_1 ( TYPE_3 . TYPE_4 . VAR_4 . VAR_5 . VAR_6 . TYPE_5 . class ) ; VAR_7 = VAR_2 ; } 
public int METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 . METHOD_1 ( ) : 0 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_2 ( STRING_3 , STRING_4 ) ; Map < String , String > map = VAR_1 . getParameters ( ) ; assertEquals ( STRING_5 , VAR_1 . build ( ) ) ; <START> assertNotNull ( map ) ; <END> assertEquals ( TYPE_2 . of ( STRING_1 , STRING_2 , STRING_3 , STRING_4 ) , map ) ; METHOD_3 ( map . get ( STRING_6 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 [ ] VAR_2 = new TYPE_2 [ ] { new TYPE_3 ( ) , new TYPE_4 ( ) , new TYPE_5 ( ) , new TYPE_6 ( ) , new TYPE_7 ( ) } ; <START> List < TYPE_2 > VAR_3 = Arrays . asList ( VAR_2 ) ; <END> VAR_3 . forEach ( ( VAR_4 - > VAR_1 . METHOD_2 ( VAR_4 . METHOD_3 ( VAR_5 ) ) ) ) ; return VAR_1 ; } 
public void start ( ) { if ( ! VAR_1 ) { logger . info ( format ( STRING_1 , TYPE_1 . getName ( ) ) ) ; return ; } <START> if ( VAR_2 ) { <END> this . VAR_3 = new TYPE_2 ( this ) ; } else { this . VAR_3 = new TYPE_3 ( this ) ; } this . VAR_4 = new TYPE_4 ( 1 , new TYPE_5 ( ) ) ; logger . info ( STRING_2 ) ; } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 . get ( ) ) { <END> return false ; } boolean res = VAR_1 . METHOD_2 ( false , true ) ; if ( res ) { VAR_2 . METHOD_3 ( this ) ; } return res ; } 
protected Collection < TYPE_1 > METHOD_1 ( ) { long VAR_1 = System . VAR_2 ( ) + TYPE_2 . METHOD_2 ( VAR_3 ) ; <START> for ( int i = 0 ; System . VAR_2 ( ) - VAR_1 < 0 ; i ++ ) { <END> Collection < TYPE_1 > VAR_4 = METHOD_3 ( ) ; if ( ! VAR_4 . isEmpty ( ) ) { return VAR_4 ; } VAR_5 . METHOD_4 ( i ) ; } return Collections . VAR_6 ( ) ; } 
public Object METHOD_1 ( int index ) { <START> assert index >= 0 && index <= VAR_1 . size ( ) ; <END> return VAR_1 . get ( index ) ; } 
<START> public Entry ( int VAR_1 , TYPE_1 VAR_2 ) { <END> this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> this . VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> this . VAR_1 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; return this ; } 
private void METHOD_1 ( boolean VAR_1 ) { if ( ! VAR_2 ) { return ; } if ( ( VAR_3 == TYPE_2 . VAR_5 || <START> VAR_3 == TYPE_2 . VAR_6 ) && VAR_1 ) { <END> throw new TYPE_1 ( STRING_1 + STRING_2 + STRING_3 ) ; } else if ( VAR_3 == TYPE_2 . VAR_7 && ! VAR_1 ) { throw new TYPE_1 ( STRING_4 + STRING_5 + STRING_3 ) ; } } 
public TYPE_4 ( TYPE_1 VAR_2 , String VAR_3 , String VAR_4 , TYPE_2 VAR_5 , TYPE_3 source ) { super ( source ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> this . source = source ; <END> } 
public void METHOD_1 ( TYPE_1 in ) throws IOException { name = in . VAR_1 ( ) ; type = TYPE_2 . METHOD_2 ( in . VAR_2 ( ) ) ; VAR_3 = METHOD_3 ( in ) ; if ( type == TYPE_2 . VAR_4 ) { <START> VAR_5 = in . VAR_6 ( ) ; <END> } } 
public void METHOD_1 ( ) { Set < TYPE_1 > VAR_1 = METHOD_2 ( ) ; <START> assertEquals ( Arrays . toString ( VAR_1 . METHOD_3 ( ) ) , 0 , VAR_1 . size ( ) ) ; <END> } 
void METHOD_1 ( final String VAR_1 ) { VAR_2 . METHOD_2 ( new TYPE_1 ( ) { @Override public String toString ( ) { return STRING_1 + TYPE_3 . this ; } @Override public void run ( ) { TYPE_3 . VAR_4 . close ( VAR_1 , new TYPE_2 ( STRING_2 ) ) ; } } ) ; VAR_2 . METHOD_3 ( ) ; <START> System . out . println ( STRING_3 ) ; <END> } 
public void clear ( ) { METHOD_1 ( ) ; try { VAR_1 . clear ( ) ; if ( VAR_2 != null ) { VAR_2 . clear ( ) ; VAR_3 = 0 ; } if ( VAR_4 != null ) { VAR_4 . clear ( ) ; <START> VAR_3 = 0 ; <END> } } finally { METHOD_2 ( ) ; } } 
private long METHOD_1 ( TYPE_1 VAR_1 , Object VAR_2 ) { Object key = TYPE_2 . METHOD_2 ( VAR_3 , VAR_4 , VAR_5 , VAR_1 , VAR_2 , null ) ; if ( key == null ) { throw new TYPE_3 ( STRING_1 ) ; } if ( ! TYPE_4 . METHOD_3 ( key . getClass ( ) ) ) { <START> throw new TYPE_3 ( STRING_2 ) ; <END> } return ( ( TYPE_5 ) key ) . METHOD_4 ( ) ; } 
private long METHOD_1 ( TYPE_1 entry ) { Object key = entry . VAR_1 ( VAR_2 ) ; <START> if ( key == null ) { <END> throw new TYPE_2 ( STRING_1 ) ; } if ( ! TYPE_3 . METHOD_2 ( key . getClass ( ) ) ) { throw new TYPE_2 ( STRING_2 ) ; } return ( ( TYPE_4 ) key ) . METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 < Integer , TYPE_3 > [ ] VAR_1 = new TYPE_2 [ VAR_2 ] ; VAR_1 [ VAR_3 ] = VAR_4 - > new TYPE_4 ( ) ; VAR_1 [ VAR_5 ] = VAR_4 - > new TYPE_5 ( ) ; <START> VAR_1 [ VAR_6 ] = VAR_4 - > new TYPE_6 ( ) ; <END> VAR_1 [ VAR_7 ] = VAR_4 - > new TYPE_7 ( ) ; VAR_1 [ VAR_8 ] = VAR_4 - > new TYPE_8 ( ) ; return new TYPE_9 ( VAR_1 ) ; } 
public String toString ( ) { return STRING_1 + STRING_2 + VAR_1 + STRING_3 + VAR_2 <START> + STRING_4 + VAR_3 + CHAR_1 <END> + STRING_5 + VAR_4 + CHAR_1 + CHAR_2 ; } 
protected void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { <START> VAR_3 . METHOD_2 ( VAR_1 . VAR_4 , VAR_1 . VAR_5 , <END> VAR_1 . VAR_6 , VAR_1 . VAR_7 , VAR_1 . VAR_8 , VAR_1 . VAR_9 ) ; } METHOD_3 ( VAR_10 ) ; VAR_11 = true ; super . METHOD_1 ( ) ; } 
public static < T > void METHOD_1 ( TYPE_4 . TYPE_5 iterator , TYPE_2 < TYPE_4 . TYPE_5 , T > VAR_1 , TYPE_3 < T > VAR_2 ) { <START> if ( METHOD_2 ( iterator ) ) { <END> METHOD_3 ( iterator , VAR_1 , VAR_2 ) ; } } 
public final boolean equals ( Object o ) { <START> if ( o instanceof TYPE_1 ) { <END> return true ; } return false ; } 
static void METHOD_1 ( TYPE_1 VAR_1 , Object VAR_2 , String VAR_3 , String name ) { if ( TYPE_3 . VAR_5 <START> || VAR_3 . equals ( STRING_1 ) ) { <END> VAR_1 . METHOD_2 ( VAR_2 , name , VAR_6 , ( TYPE_2 < Object > ) source - > - 1 ) ; } else { METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , name , 1 ) ; } } 
private static TYPE_1 METHOD_1 ( TYPE_2 config ) { TYPE_3 VAR_1 = config . VAR_2 ( ) ; boolean VAR_3 = VAR_1 . METHOD_2 ( ) ; TYPE_1 VAR_4 = config . VAR_5 ( ) . METHOD_3 ( ) ; if ( VAR_3 && VAR_1 . METHOD_4 ( ) . get ( TYPE_5 . VAR_7 ) != null ) { TYPE_4 VAR_8 = VAR_1 . METHOD_5 ( ) ; VAR_4 . METHOD_6 ( true ) . METHOD_7 ( VAR_8 . METHOD_8 ( ) ) ; } <START> VAR_4 . METHOD_9 ( ) ; <END> return VAR_4 ; } 
public TYPE_1 < Boolean > METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { METHOD_2 ( VAR_1 ) ; METHOD_2 ( VAR_2 ) ; TYPE_3 VAR_3 = new TYPE_3 ( client , TYPE_4 . METHOD_3 ( VAR_2 ) , null , VAR_1 . METHOD_4 ( ) ) ; return new TYPE_5 < > ( VAR_3 . METHOD_5 ( ) , VAR_4 , clientMessage - > { TYPE_4 . TYPE_7 response = TYPE_4 . METHOD_6 ( clientMessage ) ; return response . response ; } , <START> true <END> ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 , boolean VAR_3 ) { TYPE_1 VAR_4 = METHOD_2 ( VAR_1 , VAR_2 ) ; METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) ) ; VAR_5 . put ( VAR_1 . getKey ( ) , VAR_4 ) ; <START> VAR_6 . METHOD_6 ( VAR_4 . getKey ( ) , VAR_4 , ! VAR_3 ) ; <END> METHOD_7 ( VAR_1 . METHOD_8 ( ) , VAR_2 ) ; return VAR_4 ; } 
protected void METHOD_1 ( ) { if ( VAR_1 == null ) { for ( int i = 0 ; i < VAR_2 . size ( ) ; i += 2 ) { <START> Object obj = VAR_2 . get ( i ) ; <END> if ( obj != null ) { METHOD_2 ( ( TYPE_1 ) obj ) ; } } } else { for ( TYPE_1 < TYPE_2 > record : VAR_1 ) { METHOD_2 ( record ) ; } } } 
private boolean METHOD_1 ( TYPE_1 client ) { TYPE_2 VAR_1 = METHOD_2 ( client ) ; TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) ; Collection < TYPE_4 > values = ( ( TYPE_5 ) VAR_2 ) . METHOD_4 ( ) . values ( ) ; boolean VAR_3 = false ; for ( TYPE_4 value : values ) { if ( value instanceof TYPE_7 . TYPE_8 ) { <START> VAR_3 = true ; <END> } } return VAR_3 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_2 != null ) { return VAR_2 ; } else { try { TYPE_1 VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 , VAR_4 ) ; <START> VAR_3 . METHOD_3 ( properties ) ; <END> return VAR_3 ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING_1 + VAR_4 + STRING_2 + e . getMessage ( ) , e ) ; } } } 
<START> public static < TYPE_1 , R > TYPE_2 < TYPE_1 , TYPE_3 < R > > METHOD_1 ( String VAR_1 ) { <END> return new TYPE_4 < TYPE_1 , R > ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( result == null ) { <END> return VAR_1 . METHOD_2 ( VAR_2 ) ; } return result ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( parameters . name ) ; TYPE_3 VAR_2 ; <START> if ( parameters . VAR_3 == VAR_4 ) { <END> VAR_2 = VAR_1 . METHOD_3 ( parameters . name , parameters . key , parameters . value ) ; } else { VAR_2 = VAR_1 . METHOD_4 ( parameters . name , parameters . key , parameters . value , parameters . VAR_3 , VAR_5 ) ; } VAR_2 . METHOD_5 ( parameters . VAR_6 ) ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> METHOD_2 ( VAR_1 , STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; return this ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 ) { <START> TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( ) . get ( VAR_1 ) ; <END> return VAR_4 . METHOD_1 ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { boolean VAR_3 = VAR_1 == null || ! VAR_1 . METHOD_2 ( ) ; boolean VAR_4 = VAR_2 == null || ! VAR_2 . METHOD_2 ( ) ; return VAR_1 == VAR_2 || ( VAR_3 && VAR_4 ) || ( VAR_1 != null && VAR_2 != null <START> && METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_2 . METHOD_4 ( ) ) ) ; <END> } 
public boolean equals ( Object obj ) { <START> if ( id == null || ! ( obj instanceof TYPE_1 ) ) { <END> return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return VAR_1 . id != null && id . equals ( VAR_1 . id ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { try { Object VAR_3 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <START> VAR_1 . close ( ) ; <END> return METHOD_4 ( VAR_2 , VAR_3 ) ; } catch ( Exception ex ) { throw new TYPE_3 ( STRING_1 , ex ) ; } } 
public TYPE_2 ( String name , TYPE_1 VAR_2 ) { super ( name , VAR_2 ) ; <START> Thread . VAR_3 ( ) ; <END> } 
public boolean apply ( Map . Entry VAR_1 ) { <START> Thread . VAR_2 ( ) ; <END> TYPE_1 . METHOD_1 ( ) ; return true ; } 
public void METHOD_1 ( ) throws Exception { final String response = STRING_1 ; TYPE_1 < String > f = VAR_1 . METHOD_2 ( new TYPE_2 ( VAR_2 - > new TYPE_3 ( VAR_2 ) { @Override public void start ( ) { <START> new Thread ( ) { <END> @Override public void run ( ) { METHOD_3 ( 5 ) ; METHOD_4 ( ) . METHOD_5 ( response ) ; } } . start ( ) ; } } ) ) ; METHOD_6 ( f ) ; assertEquals ( response , f . get ( ) ) ; } 
public static < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_4 < TYPE_1 , TYPE_2 > > METHOD_1 ( ) { <START> return new TYPE_5 < > ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( ) { @Override public TYPE_2 create ( int VAR_1 ) { switch ( VAR_1 ) { case VAR_2 : return new TYPE_3 ( ) ; case VAR_3 : <START> return new TYPE_4 < > ( ) ; <END> default : return null ; } } } ; } 
public static < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_4 < TYPE_1 , TYPE_2 > , Entry < TYPE_1 , TYPE_2 > > METHOD_1 ( ) { <START> return new TYPE_5 < > ( ) ; <END> } 
public boolean equals ( Object o ) { if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; assert VAR_1 . length == that . VAR_1 . length ; for ( int i = 0 ; i < VAR_1 . length ; ++ i ) { <START> if ( ! TYPE_2 . METHOD_1 ( VAR_1 [ i ] , that . VAR_1 [ i ] ) ) { <END> return false ; } } return true ; } 
<START> public void METHOD_1 ( TYPE_1 < TYPE_2 > set ) { <END> map . VAR_1 ( set . map ) ; } 
private boolean METHOD_1 ( ) { if ( ! config . VAR_1 ( ) . METHOD_2 ( ) ) { return true ; } Map < TYPE_1 , TYPE_2 > VAR_2 = config . VAR_1 ( ) . METHOD_3 ( ) ; TYPE_2 VAR_3 = VAR_2 . get ( VAR_4 ) ; <START> return VAR_3 instanceof TYPE_3 ; <END> } 
<START> public int METHOD_1 ( ) { <END> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_3 ) ; return VAR_4 . METHOD_5 ( new TYPE_2 ( VAR_1 ) ) . size ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 instanceof TYPE_2 <END> && ! ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ) { return false ; } TYPE_3 type = config . getType ( ) ; switch ( type ) { case VAR_2 : return METHOD_3 ( VAR_1 ) ; case VAR_3 : return METHOD_4 ( VAR_1 ) ; case VAR_4 : return METHOD_4 ( VAR_1 ) || METHOD_3 ( VAR_1 ) ; default : throw new IllegalStateException ( STRING_1 + type ) ; } } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = node . VAR_2 ( ) ; <START> return VAR_3 . METHOD_2 ( ) && VAR_1 . METHOD_3 ( ) && node . VAR_4 ( ) . METHOD_4 ( ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 != null ) { return VAR_1 ; } if ( VAR_2 == null ) { return null ; } return METHOD_2 ( VAR_2 ) ; } 
<START> public TYPE_1 METHOD_1 ( String name ) { <END> this . name = name ; return this ; } 
public TYPE_1 get ( ) throws InterruptedException , TYPE_2 { String name = Thread . VAR_1 ( ) . getName ( ) ; <START> System . out . println ( STRING_1 + name ) ; <END> if ( name . contains ( STRING_2 ) ) { throw new IllegalStateException ( STRING_1 + name ) ; } return super . get ( ) ; } 
public void info ( Throwable VAR_1 ) { long VAR_2 = System . VAR_3 ( ) ; <START> VAR_4 . METHOD_1 ( VAR_1 ) ; <END> METHOD_2 ( VAR_2 ) ; } 
public long METHOD_1 ( ) { <START> return 0 ; <END> } 
protected Collection < TYPE_1 > METHOD_1 ( ) { <START> final TYPE_3 . TYPE_4 VAR_1 = config . VAR_2 ( ) ; <END> return METHOD_2 ( VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 value , int index ) { TYPE_3 VAR_2 = METHOD_2 ( VAR_1 ) ; <START> boolean VAR_3 ; <END> if ( index < 0 ) { VAR_3 = VAR_2 . METHOD_3 ( false ) . add ( value ) ; } else { ( ( List < TYPE_2 > ) VAR_2 . METHOD_3 ( false ) ) . add ( index , value ) ; VAR_3 = true ; } if ( VAR_3 ) { METHOD_4 ( 1 ) ; } return VAR_3 ; } 
public Collection < TYPE_1 > remove ( TYPE_2 VAR_1 , boolean VAR_2 ) { TYPE_3 VAR_3 = VAR_4 . remove ( VAR_1 ) ; if ( VAR_3 != null ) { METHOD_1 ( VAR_3 . size ( ) ) ; return VAR_3 . METHOD_2 ( VAR_2 ) ; <START> } else { <END> return null ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 value = VAR_2 . remove ( VAR_1 ) ; if ( value != null ) { METHOD_2 ( value . size ( ) ) ; return true ; <START> } else { <END> return false ; } } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; if ( VAR_1 . METHOD_2 ( ) ) { <START> for ( TYPE_1 key : VAR_2 ) { <END> TYPE_2 record = VAR_1 . METHOD_3 ( key ) ; VAR_3 . METHOD_4 ( name , TYPE_3 . METHOD_5 ( key , VAR_4 , record ) ) ; } } } 
protected void METHOD_1 ( TYPE_1 in ) throws IOException { super . METHOD_1 ( in ) ; int s = in . VAR_1 ( ) ; <START> VAR_2 = new ArrayList < TYPE_2 > ( ) ; <END> while ( s -- > 0 ) { VAR_2 . add ( in . VAR_3 ( ) ) ; } VAR_4 = in . VAR_3 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 < Integer , String > map = METHOD_2 ( ) ; <START> map . put ( 1 , STRING_1 , 0 , TimeUnit . VAR_1 ) ; <END> METHOD_3 ( 1 ) ; METHOD_4 ( map . containsKey ( 1 ) ) ; } 
public TYPE_3 ( int VAR_2 , float VAR_3 ) { METHOD_1 ( VAR_2 , STRING_1 + VAR_2 ) ; <START> METHOD_2 ( VAR_3 <= 0 || TYPE_1 . METHOD_3 ( VAR_3 ) , STRING_2 + VAR_3 ) ; <END> this . VAR_4 = TYPE_2 . METHOD_4 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_5 = ( int ) ( VAR_4 * VAR_3 ) ; this . VAR_6 = VAR_4 - 1 ; this . VAR_7 = new int [ VAR_4 ] ; this . table = new Object [ VAR_4 ] ; } 
public void METHOD_1 ( String VAR_1 ) { <START> for ( TYPE_1 context : VAR_2 ) { <END> TYPE_2 . METHOD_2 ( ) . METHOD_3 ( context ) ; } VAR_3 = VAR_1 != null ? TYPE_3 . create ( VAR_1 ) : null ; METHOD_4 ( ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> if ( ! VAR_2 ) { <END> METHOD_2 ( key , VAR_3 ) ; } } } 
<START> public String METHOD_1 ( ) { <END> String VAR_1 = STRING_1 ; TYPE_1 is = null ; try { is = getClass ( ) . METHOD_2 ( ) . METHOD_3 ( STRING_2 ) ; if ( is != null ) { final TYPE_2 properties = new TYPE_2 ( ) ; properties . VAR_2 ( is ) ; VAR_1 = properties . getProperty ( STRING_3 ) ; } } catch ( IOException VAR_3 ) { METHOD_4 ( VAR_3 ) ; } finally { METHOD_5 ( is ) ; } return VAR_1 ; } 
public TYPE_1 < T > METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 ) { <START> return null ; <END> } 
public TYPE_1 < T > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , boolean VAR_3 ) { <START> return null ; <END> } 
protected TYPE_3 ( TYPE_1 VAR_2 , List < String > VAR_3 ) { super ( VAR_2 ) ; this . VAR_4 = VAR_3 ; <START> this . toString = STRING_1 <END> + TYPE_2 . METHOD_1 ( VAR_2 ) + STRING_2 ; } 
<START> public TYPE_1 METHOD_1 ( ) throws Exception { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 ) ; } return VAR_1 ; } 
<START> public List < TYPE_1 < ? > > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public TYPE_1 call ( ) throws Exception { <END> TYPE_1 VAR_1 = TYPE_1 . METHOD_1 ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; if ( ! VAR_1 . isEmpty ( ) || ( VAR_5 && ! VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) ) { List < Map < String , String > > VAR_7 = VAR_1 . METHOD_3 ( ) ; } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == TYPE_1 . VAR_2 || VAR_1 == TYPE_1 . VAR_3 ) { <END> VAR_4 . METHOD_2 ( ) ; } if ( VAR_5 != null && ( VAR_1 == TYPE_1 . VAR_6 || VAR_1 == TYPE_1 . VAR_3 ) ) { VAR_5 . METHOD_2 ( ) ; } VAR_7 = TYPE_1 . NONE ; } 
protected void METHOD_1 ( ) { Log . d ( TAG , STRING_1 ) ; METHOD_2 ( VAR_1 ) ; <START> VAR_2 . METHOD_3 ( ) ; <END> super . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { assertTrue ( VAR_1 . METHOD_2 ( ) == 3 ) ; Map < Type , TYPE_1 > map = VAR_1 . METHOD_3 ( ) ; <START> assertTrue ( map . get ( TYPE_2 . class ) instanceof TYPE_3 ) ; <END> assertTrue ( map . get ( TYPE_4 . class ) instanceof TYPE_3 ) ; assertTrue ( map . get ( TYPE_5 . class ) instanceof TYPE_3 ) ; } 
public Object METHOD_1 ( TYPE_1 ctx ) throws Exception { try { VAR_1 . METHOD_2 ( TYPE_2 . class ) . METHOD_3 ( ) ; <START> VAR_2 . set ( true ) ; <END> return ctx . VAR_3 ( ) ; } catch ( TYPE_3 e ) { } return ctx . VAR_3 ( ) ; } 
public TYPE_4 ( final String id , final String VAR_2 , final String VAR_3 , final TYPE_1 VAR_4 , final TYPE_2 VAR_5 , ANNOTATION_1 final String VAR_6 ) { super ( METHOD_1 ( id ) , VAR_2 , VAR_3 , VAR_5 ) ; <START> this . VAR_7 = new TYPE_3 ( id , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; <END> this . VAR_8 = VAR_6 ; } 
public String METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 ) { for ( final TYPE_2 VAR_3 : VAR_4 . keySet ( ) ) { if ( VAR_3 . matcher ( VAR_2 ) . METHOD_2 ( ) ) { return this . VAR_4 . get ( VAR_3 ) ; } } if ( this . VAR_5 ) { return VAR_6 ; } <START> throw new TYPE_3 ( STRING_1 + VAR_2 , VAR_1 . getId ( ) ) ; <END> } 
public void METHOD_1 ( ) { <START> METHOD_2 ( this . action . VAR_1 ( VAR_2 , null , STRING_1 ) ) ; <END> } 
public void METHOD_1 ( ) { <START> METHOD_2 ( this . action . VAR_1 ( VAR_2 , METHOD_3 ( ) , null ) ) ; <END> } 
public void METHOD_1 ( ) { <START> METHOD_2 ( this . action . VAR_1 ( VAR_2 , METHOD_3 ( ) , STRING_1 ) ) ; <END> } 
public void METHOD_1 ( String VAR_1 , TYPE_1 props ) throws TYPE_2 , TYPE_3 , TYPE_4 { <START> if ( VAR_1 == null || VAR_1 == "" ) { <END> throw new TYPE_4 ( STRING_1 ) ; } try { this . client . VAR_2 ( VAR_1 , null , props ) ; } catch ( Exception e ) { throw e ; } } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 props ) throws TYPE_2 , TYPE_3 , TYPE_4 { <START> if ( VAR_1 == null || VAR_1 == "" || VAR_2 == null || VAR_2 == "" ) { <END> throw new TYPE_4 ( STRING_1 ) ; } try { this . client . VAR_3 ( VAR_1 , VAR_2 , props ) ; } catch ( Exception e ) { throw e ; } } 
private TYPE_2 ( int VAR_2 , String VAR_3 , TYPE_1 VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . client = VAR_4 ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) throws Exception { TYPE_2 VAR_3 = METHOD_2 ( ) . METHOD_3 ( <START> new TYPE_3 ( STRING_1 ) , <END> new TYPE_4 ( ) , METHOD_4 ( ) , new TYPE_5 ( ) , new TYPE_6 ( ) , new TYPE_7 ( ) , VAR_1 ) . METHOD_5 ( STRING_2 , String . valueOf ( VAR_2 ) ) . METHOD_6 ( ) ; VAR_4 = VAR_3 . getInstance ( TYPE_8 . class ) ; server = VAR_3 . getInstance ( TYPE_9 . class ) ; } 
public int METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) + VAR_1 . METHOD_3 ( ) - VAR_1 . METHOD_4 ( ) ; <END> } 
public TYPE_6 ( ) { binder = new TYPE_1 < TYPE_2 > ( TYPE_2 . class ) ; try { <START> VAR_2 = TYPE_1 . class . METHOD_1 ( STRING_1 , Object . VAR_3 , TYPE_3 . VAR_3 ) ; <END> VAR_4 = TYPE_1 . VAR_3 . METHOD_1 ( STRING_2 , TYPE_4 . VAR_3 , Class . VAR_3 ) ; } catch ( TYPE_5 e ) { throw new RuntimeException ( STRING_3 , e ) ; } VAR_2 . METHOD_2 ( true ) ; VAR_4 . METHOD_2 ( true ) ; } 
<START> protected TYPE_2 ( ) { <END> super ( TYPE_1 . class ) ; } 
public void run ( ) { if ( VAR_1 == null ) { <START> Arrays . VAR_2 ( VAR_3 ) ; <END> } else { Arrays . VAR_2 ( VAR_3 , VAR_1 ) ; } } 
public void format ( StringBuilder buffer , String format , Object ... args ) throws TYPE_1 { <START> position = 0 ; <END> METHOD_1 ( buffer , format , args ) ; } 
public void close ( ) { try { <START> VAR_1 . close ( ) ; <END> } catch ( Exception e ) { } out . VAR_2 ( ) ; out . close ( ) ; } 
<START> public synchronized String format ( String format , Object ... args ) <END> throws TYPE_1 { StringBuilder buffer = new StringBuilder ( ) ; format ( buffer , format , args ) ; return buffer . toString ( ) ; } 
public void format ( StringBuilder buffer , Object o , String VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> buffer . append ( VAR_2 . format ( STRING_1 + VAR_1 + STRING_2 , o ) ) ; <END> } 
<START> private void close ( ) { <END> try { reader . close ( ) ; } catch ( Exception e ) { } } 
public void add ( String string ) { if ( VAR_1 == TYPE_1 . VAR_3 ) { count ++ ; return ; } if ( VAR_1 == TYPE_1 . VAR_4 ) { <START> string = string . VAR_5 ( ) ; <END> } Integer res = map . get ( string ) ; if ( res == null ) { map . put ( string , 1 ) ; } else { map . put ( string , res + 1 ) ; } } 
public static boolean METHOD_1 ( String s ) { <START> if ( s . length ( ) != 0 ) { <END> if ( TYPE_1 . METHOD_2 ( s . VAR_1 ( 0 ) ) ) { return true ; } } return false ; } 
<START> public static Boolean getMessage ( TYPE_1 VAR_1 , ByteBuffer message , <END> Map < String , TYPE_1 > VAR_2 ) { try { int count = VAR_1 . read ( message ) ; if ( count == - 1 ) { METHOD_1 ( VAR_2 , VAR_1 ) ; return true ; } } catch ( Exception e ) { METHOD_2 ( STRING_1 + e . getMessage ( ) ) ; } return false ; } 
private static boolean METHOD_1 ( String [ ] VAR_1 ) { int VAR_2 = 0 ; int VAR_3 = 0 ; for ( String s : VAR_1 ) { if ( s . equals ( STRING_1 ) || s . equals ( STRING_2 ) || s . equals ( STRING_3 ) || s . equals ( STRING_4 ) ) { ++ VAR_3 ; } else { ++ VAR_2 ; } } <START> if ( ( VAR_2 - VAR_3 ) == 1 ) { <END> return true ; } else { return false ; } } 
static void METHOD_1 ( ) throws Exception { while ( true ) { System . out . METHOD_2 ( STRING_1 ) ; TYPE_1 reader = new TYPE_1 ( new TYPE_2 ( System . in ) ) ; String command = reader . VAR_1 ( ) ; try { METHOD_3 ( command ) ; } catch ( Exception e ) { <START> System . err . METHOD_2 ( e . getMessage ( ) ) ; <END> System . VAR_2 ( 1 ) ; } } } 
public String METHOD_1 ( ) { <START> String VAR_1 = VAR_2 . get ( ) . get ( TYPE_1 . VAR_4 ) ; <END> return this . METHOD_2 ( ) ? METHOD_3 ( ) : METHOD_4 ( ) ; } 
private static void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { try { VAR_1 . call ( ) ; <START> } catch ( Throwable VAR_2 ) { <END> logger . error ( STRING_1 , VAR_2 ) ; } } 
public void METHOD_1 ( ) { try { TYPE_1 . getInstance ( ) . METHOD_2 ( TYPE_2 . METHOD_3 ( this ) ) ; } catch ( Throwable t ) { logger . error ( STRING_1 , t ) ; } try { if ( VAR_1 != null ) { <START> for ( TYPE_3 node : this . VAR_1 . METHOD_4 ( ) ) { <END> node . VAR_2 ( ) ; } } } catch ( Throwable t ) { logger . error ( STRING_2 , t ) ; } super . METHOD_1 ( ) ; } 
public TYPE_4 ( TYPE_1 config , String VAR_2 ) { <START> this ( config , STRING_1 , new TYPE_2 ( ) { <END> @Override public TYPE_3 getName ( ) { return TYPE_3 . TYPE_5 ; } } ) ; } 
public TYPE_2 ( TYPE_1 config , String VAR_2 ) { this . VAR_3 = config . getString ( STRING_1 , null ) ; <START> this . config = config . VAR_4 ( VAR_5 ) ; <END> } 
public TYPE_1 < TYPE_2 < TYPE_3 > > METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
private boolean METHOD_1 ( ) { boolean VAR_1 = VAR_2 . METHOD_1 ( VAR_3 , VAR_4 . size ( ) ) >= 0 ; <START> METHOD_2 ( VAR_1 ? Status . VAR_5 : Status . VAR_6 ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; if ( VAR_1 != null && METHOD_3 ( VAR_1 ) ) { VAR_1 . METHOD_4 ( TYPE_2 . VAR_3 ) ; METHOD_5 ( ) ; } <START> TYPE_1 . getInstance ( ) . METHOD_6 ( null ) ; <END> TYPE_1 . getInstance ( ) . METHOD_7 ( null ) ; } 
<START> public Builder METHOD_1 ( String VAR_1 ) { <END> result . VAR_1 = VAR_1 ; if ( result . VAR_1 != null ) { result . VAR_1 = result . VAR_1 . METHOD_2 ( ) ; } return this ; } 
protected Object METHOD_1 ( ) throws Exception { <START> METHOD_2 ( VAR_1 , STRING_1 ) ; <END> TYPE_1 VAR_2 = METHOD_3 ( ) ; final TYPE_2 VAR_3 = METHOD_4 ( VAR_2 ) ; final String VAR_4 = VAR_2 . METHOD_5 ( STRING_2 + TYPE_3 . METHOD_6 ( ) . toString ( ) , VAR_3 ) ; return String . format ( STRING_3 , VAR_4 ) ; } 
protected List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { <START> List < List < TYPE_1 > > VAR_2 = TYPE_3 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_1 , new TYPE_4 < TYPE_2 , List < TYPE_1 > > ( ) { <END> @Override public List < TYPE_1 > apply ( TYPE_2 VAR_1 ) { return VAR_1 . METHOD_4 ( ) ; } } ) ) ; return TYPE_3 . METHOD_2 ( TYPE_5 . METHOD_5 ( VAR_2 ) ) ; } 
private static String METHOD_1 ( String VAR_1 ) { try { return TYPE_1 . toString ( TYPE_1 . METHOD_2 ( TYPE_2 . class , VAR_1 ) , TYPE_4 . VAR_3 ) ; } catch ( IOException e ) { <START> TYPE_3 . METHOD_3 ( e ) ; <END> } throw new RuntimeException ( STRING_1 + VAR_1 ) ; } 
static void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { try { TYPE_2 VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; LOG . info ( STRING_1 , VAR_3 . getName ( ) ) ; VAR_1 . METHOD_3 ( ) . METHOD_4 ( VAR_3 . getId ( ) ) ; } catch ( TYPE_3 e ) { <START> LOG . debug ( STRING_2 , VAR_2 , e ) ; <END> } } 
void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { String VAR_3 = VAR_1 . name ( ) ; try { LOG . info ( STRING_1 , VAR_3 ) ; String VAR_4 = METHOD_2 ( VAR_2 ) ; LOG . info ( STRING_2 , VAR_3 ) ; VAR_5 . METHOD_1 ( METHOD_3 ( VAR_3 , VAR_4 ) , METHOD_4 ( VAR_3 ) ) ; <START> } catch ( Exception e ) { <END> LOG . error ( STRING_3 , VAR_3 , e ) ; } } 
public static TYPE_1 METHOD_1 ( ) { return TYPE_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . class ) <START> . METHOD_3 ( TYPE_4 . class ) <END> . METHOD_4 ( TYPE_5 . METHOD_5 ( ) . METHOD_6 ( STRING_1 , STRING_2 ) . filter ( TYPE_6 . class , STRING_3 ) . filter ( TYPE_6 . class , STRING_3 ) . METHOD_7 ( ) ) ; } 
public TYPE_3 VAR_2 ( TYPE_2 VAR_4 ) { for ( TYPE_1 VAR_6 : VAR_7 . VAR_8 ( VAR_9 ) ) { TYPE_3 VAR_10 = VAR_6 . VAR_2 ( VAR_4 ) ; if ( VAR_10 != null ) { <START> return VAR_10 <END> } } return null ; } 
public boolean METHOD_1 ( Object item ) { boolean VAR_1 = false ; ANNOTATION_1 ( STRING_1 ) Set < TYPE_1 > VAR_2 = ( Set < TYPE_1 > ) item ; for ( TYPE_1 f : VAR_2 ) { if ( f . name ( ) . equals ( VAR_3 . name ( ) ) ) { VAR_1 = true ; break ; } } <START> return VAR_1 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 uri ) throws TYPE_4 { <START> if ( ! VAR_3 ) { <END> for ( TYPE_5 VAR_4 : VAR_5 ) { VAR_4 . METHOD_1 ( VAR_1 , VAR_2 , uri ) ; } } } 
protected void METHOD_1 ( TYPE_1 context ) throws TYPE_2 { Map . Entry < String , String > entry ; for ( Map . Entry < String , String > VAR_1 : VAR_2 . entrySet ( ) ) { entry = VAR_1 ; context . VAR_3 ( entry . getKey ( ) , entry . getValue ( ) ) ; <START> } <END> } 
public void METHOD_1 ( boolean VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> VAR_2 . forEach ( call - > { <END> if ( ! VAR_1 ) { call . VAR_3 ( ) . METHOD_2 ( null ) ; } } ) ; VAR_2 . clear ( ) ; VAR_4 . METHOD_1 ( VAR_1 ) ; } 
void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 > VAR_1 = new TYPE_1 < > ( TYPE_3 . class , STRING_1 ) ; try { VAR_1 . METHOD_2 ( ) ; assertThat ( VAR_2 . VAR_3 ) . METHOD_3 ( ) ; } catch ( Exception e ) { <START> Assert . VAR_4 ( ) ; <END> } finally { VAR_1 . METHOD_4 ( ) ; } } 
public TYPE_1 [ ] METHOD_1 ( ) { <START> return VAR_1 . keySet ( ) . stream ( ) . map ( key - > VAR_1 . get ( key ) ) . METHOD_2 ( TYPE_1 [ ] : : new ) ; <END> } 
public TYPE_1 build ( ) { final TYPE_2 VAR_1 = new TYPE_2 ( this . VAR_2 , this . VAR_3 , this . VAR_4 ) ; <START> if ( this . VAR_5 != null ) { <END> VAR_1 . METHOD_1 ( this . VAR_5 . METHOD_2 ( ) ) ; } this . VAR_6 . METHOD_3 ( new TYPE_3 ( VAR_1 , this . VAR_7 , this . VAR_8 ) ) ; return VAR_1 ; } 
public String METHOD_1 ( ANNOTATION_1 Optional < TYPE_1 > VAR_1 ) { <START> return STRING_1 + ( ( VAR_1 . isPresent ( ) ) ? "" : STRING_2 ) + STRING_3 ; <END> } 
public void METHOD_1 ( Map < String , String > options ) { VAR_1 = Optional . VAR_2 ( options . get ( STRING_1 ) ) . map ( Boolean : : METHOD_2 ) . METHOD_3 ( true ) ; if ( options . containsKey ( STRING_2 ) ) { <START> VAR_3 = new File ( options . get ( STRING_2 ) ) ; <END> } } 
public TYPE_2 ( TYPE_1 configuration ) { this . configuration = configuration ; <START> this . VAR_2 = null ; <END> } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 ; if ( configuration . VAR_2 ( ) ) { <START> if ( VAR_3 == null ) { <END> VAR_1 = TYPE_2 . METHOD_2 ( ) ; } else { VAR_1 = VAR_3 ; } } else { VAR_1 = new TYPE_3 ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { factory . VAR_1 ( STRING_1 ) ; factory . VAR_2 ( 0 ) ; TYPE_1 VAR_3 = factory . build ( VAR_4 , STRING_2 ) ; try { <START> VAR_3 . start ( ) ; <END> } catch ( Exception e ) { METHOD_2 ( ) ; } } 
public void METHOD_1 ( ) throws Exception { try { <START> TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; <END> assertThat ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( 0 ) ; } catch ( TYPE_2 e ) { e . VAR_2 ( ) ; METHOD_5 ( e . getMessage ( ) ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 > factory = VAR_1 . create ( TYPE_2 . class , VAR_2 , TYPE_3 . METHOD_2 ( ) , STRING_1 ) ; <START> final TYPE_2 VAR_3 = factory . build ( new TYPE_4 ( ) , VAR_4 . getPath ( ) ) ; <END> assertThat ( VAR_3 . getName ( ) ) . METHOD_3 ( STRING_2 ) ; } 
public void METHOD_1 ( ) { <START> when ( this . VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( this . VAR_2 ) ; <END> } 
<START> protected String name ( ) { <END> return VAR_1 ; } 
<START> public static synchronized void METHOD_1 ( ) throws Exception { <END> VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_2 = ImmutableList . of ( STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , STRING_8 ) ; } 
public TYPE_2 ( ) { <START> super ( ) ; <END> METHOD_1 ( TYPE_1 . class ) ; } 
public TYPE_2 ( ) { <START> super ( ) ; <END> METHOD_1 ( TYPE_1 . class ) ; METHOD_2 ( STRING_1 ) ; } 
public String toString ( ) { return TYPE_1 . METHOD_1 ( this ) . add ( STRING_1 , VAR_1 ) . add ( STRING_2 , VAR_2 ) . add ( STRING_3 , VAR_3 ) . add ( STRING_4 , VAR_4 ) <START> . add ( STRING_5 , VAR_5 ) <END> . toString ( ) ; } 
<START> public void METHOD_1 ( TYPE_1 outputStream ) { <END> this . outputStream = outputStream ; } 
public void close ( ) throws Exception { try { VAR_1 . close ( ) ; <START> } catch ( TYPE_1 e ) { <END> LOGGER . warn ( STRING_1 , e ) ; } VAR_2 . METHOD_1 ( ) ; } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { if ( count == 0 && VAR_1 . count == 0 ) { return 0 ; } <START> if ( count < 0 && VAR_1 . count >= 0 ) { <END> return - 1 ; } if ( count >= 0 && VAR_1 . count < 0 ) { return 1 ; } if ( VAR_2 == VAR_1 . VAR_2 ) { return Long . VAR_3 ( count , VAR_1 . count ) ; } return Long . VAR_3 ( METHOD_2 ( ) , VAR_1 . METHOD_2 ( ) ) ; } 
protected TYPE_1 < ? > METHOD_1 ( final TYPE_2 VAR_1 ) { final Class < ? > VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> TYPE_3 VAR_3 = VAR_1 . METHOD_3 ( TYPE_3 . class ) ; <END> if ( VAR_3 == null ) { return null ; } if ( VAR_2 . METHOD_4 ( this . factory . VAR_4 ( ) ) ) { return this . factory . VAR_5 ( VAR_3 . METHOD_5 ( ) ) ; } else { return null ; } } 
public TYPE_1 build ( String name ) { final TYPE_2 params = METHOD_1 ( name ) ; final TYPE_3 VAR_1 = METHOD_2 ( VAR_2 , name ) ; final TYPE_4 client = new TYPE_4 ( VAR_3 , VAR_1 , params , name ) ; <START> client . VAR_4 ( VAR_5 ) ; <END> METHOD_3 ( client ) ; return client ; } 
public TYPE_3 ( ) { <START> this ( ImmutableList . VAR_2 ( TYPE_1 . METHOD_1 ( TYPE_2 . class ) ) ) ; <END> } 
private void METHOD_1 ( String name , Set < String > VAR_1 , String type ) { if ( VAR_1 . contains ( name ) ) { LOGGER . warn ( STRING_1 , type , name ) ; } <START> VAR_1 . add ( name ) ; <END> } 
public T build ( String VAR_1 , TYPE_1 VAR_2 ) throws IOException , TYPE_2 { <START> final TYPE_3 node = VAR_3 . METHOD_1 ( VAR_2 ) ; <END> return build ( node , VAR_1 != null ? VAR_1 : STRING_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { METHOD_2 ( VAR_1 ) ; <START> METHOD_3 ( VAR_1 . getId ( ) ) ; <END> return METHOD_1 ( VAR_1 . getId ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 user ) { METHOD_2 ( user ) ; <START> METHOD_3 ( user . getId ( ) ) ; <END> return METHOD_1 ( user . getId ( ) ) ; } 
public static TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_6 . VAR_3 ) ; VAR_1 . METHOD_2 ( TYPE_3 . VAR_5 ) ; VAR_1 . METHOD_3 ( TYPE_3 . VAR_6 ) ; VAR_1 . METHOD_4 ( TYPE_4 . TYPE_5 . VAR_9 ) ; VAR_1 . METHOD_3 ( TYPE_6 . VAR_10 ) ; VAR_1 . METHOD_5 ( new TYPE_2 ( ) ) ; <START> VAR_1 . METHOD_2 ( TYPE_3 . VAR_11 ) ; <END> return VAR_1 ; } 
public String toString ( ) { return STRING_1 + STRING_2 + id + <START> STRING_3 + ( value == null ? STRING_4 : Arrays . asList ( value ) . toString ( ) ) + <END> CHAR_1 ; } 
<START> public static boolean METHOD_1 ( ) { <END> return VAR_1 . get ( ) ; } 
private int METHOD_1 ( int res ) { if ( ! METHOD_2 ( ) || ! VAR_1 . METHOD_2 ( ) ) { if ( VAR_2 != null ) { return TYPE_1 . VAR_4 ; } return res ; } <START> if ( VAR_2 == null || METHOD_3 ( VAR_2 , VAR_1 , VAR_1 . METHOD_4 ( ) . name ( ) ) ) { <END> VAR_2 = null ; return TYPE_1 . VAR_5 ; } return TYPE_1 . VAR_4 ; } 
public TYPE_3 ( TYPE_1 VAR_2 ) { builder = new TYPE_2 ( VAR_2 ) ; VAR_3 = new ArrayList < > ( ) ; <START> Collections . addAll ( VAR_3 , METHOD_1 ( METHOD_1 ( VAR_2 . getPath ( ) ) ) . split ( STRING_1 ) ) ; <END> } 
public long METHOD_1 ( TYPE_1 VAR_1 , Class < ? > type , Type VAR_2 , TYPE_2 [ ] VAR_3 , TYPE_3 VAR_4 ) { <START> return 0 ; <END> } 
public Response METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 , ANNOTATION_2 ( VAR_2 ) String VAR_3 , ANNOTATION_2 ( VAR_4 ) String VAR_5 ) { <START> return VAR_6 . METHOD_2 ( VAR_1 ) . METHOD_1 ( METHOD_3 ( VAR_3 ) , METHOD_3 ( VAR_5 ) ) ; <END> } 
<START> public TYPE_2 ( Map < String , TYPE_1 > VAR_2 ) { <END> this . VAR_2 = new HashMap < > ( VAR_2 ) ; } 
void METHOD_1 ( ANNOTATION_1 TYPE_1 < TYPE_2 > VAR_1 ) { <START> if ( VAR_2 . contains ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ) { <END> TYPE_3 < TYPE_2 > VAR_3 = new TYPE_3 < TYPE_2 > ( VAR_1 ) ; VAR_3 . METHOD_4 ( new TYPE_4 ( ) ) ; VAR_1 . METHOD_5 ( VAR_3 ) ; } } 
<START> protected TYPE_1 METHOD_1 ( String VAR_1 ) { <END> if ( VAR_2 != null ) { TYPE_2 i = new TYPE_2 ( VAR_2 ) ; TYPE_3 r ; while ( ( r = i . VAR_3 ( ) ) != null ) { if ( r instanceof TYPE_1 ) { TYPE_1 VAR_4 = ( TYPE_1 ) r ; if ( VAR_4 . METHOD_2 ( ) . equals ( VAR_1 ) ) return VAR_4 ; } } } return null ; } 
public TYPE_1 METHOD_1 ( Object id ) { <START> return VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . VAR_7 . TYPE_3 . METHOD_2 ( ( TYPE_2 ) id ) ; <END> } 
private final void METHOD_1 ( int VAR_1 , int VAR_2 ) throws TYPE_1 { <START> if ( VAR_3 && VAR_4 != null ) { <END> VAR_4 . METHOD_1 ( VAR_5 , VAR_6 , VAR_1 , VAR_2 ) ; } } 
<START> public void start ( ) throws TYPE_1 , TYPE_2 , TYPE_3 , IllegalStateException , TYPE_4 <END> { VAR_1 . logger . trace ( STRING_1 + VAR_2 + STRING_2 ) ; TYPE_5 VAR_3 = METHOD_1 ( ) ; TYPE_6 . METHOD_2 ( new TYPE_7 ( ) ) . METHOD_3 ( VAR_3 ) ; } 
<START> public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 <END> { VAR_1 . logger . trace ( STRING_1 + VAR_2 + STRING_2 ) ; TYPE_5 . METHOD_2 ( new TYPE_6 ( ) ) . METHOD_3 ( ) ; } 
public Object METHOD_1 ( ) { if ( TYPE_2 . TYPE_3 . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_4 . METHOD_2 ( ) == null ) <START> return null ; <END> return TYPE_2 . TYPE_3 . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . TYPE_4 . METHOD_2 ( ) . METHOD_3 ( ) ; } 
public static String METHOD_1 ( final Thread VAR_1 ) { <START> final Object id = TYPE_1 . get ( VAR_1 ) ; <END> if ( id != null ) { return ( String ) id ; } final String VAR_2 = METHOD_2 ( ) ; TYPE_1 . put ( VAR_1 , VAR_2 ) ; return VAR_2 ; } 
public int METHOD_1 ( ) { if ( parent ( ) != null ) parent ( ) . METHOD_2 ( this ) ; int VAR_1 ; <START> synchronized ( VAR_2 ) { <END> if ( TYPE_1 . METHOD_3 ( ) && METHOD_4 ( ) ) TYPE_1 . getInstance ( ) . METHOD_5 ( ) ; VAR_1 = super . METHOD_6 ( ) ; } if ( VAR_1 == TYPE_2 . VAR_4 ) { METHOD_7 ( VAR_1 ) ; } return VAR_1 ; } 
public void commit ( TYPE_1 VAR_1 , boolean b ) throws TYPE_2 { <START> METHOD_1 ( ) ; <END> VAR_2 . commit ( VAR_1 , b ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> METHOD_2 ( ) ; <END> VAR_2 . METHOD_1 ( VAR_1 ) ; } 
private void METHOD_1 ( ) throws TYPE_1 { if ( VAR_1 != null ) { return ; } try { VAR_2 = VAR_3 . METHOD_2 ( ) ; VAR_4 = VAR_2 . METHOD_3 ( ) ; VAR_1 = VAR_4 . METHOD_4 ( ) ; } catch ( TYPE_2 e ) { LOGGER . warn ( STRING_1 , e ) ; <START> throw new TYPE_1 ( TYPE_1 . VAR_5 ) ; <END> } } 
private void METHOD_1 ( ) throws TYPE_1 { try { VAR_1 . close ( ) ; } catch ( TYPE_2 e ) { LOGGER . warn ( STRING_1 , e ) ; <START> throw new TYPE_1 ( TYPE_1 . VAR_2 ) ; <END> } finally { VAR_1 = null ; VAR_3 = null ; VAR_4 = null ; } } 
public boolean METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 ) { TYPE_4 . TYPE_5 . VAR_3 . VAR_4 . VAR_2 . TYPE_2 VAR_6 = ( TYPE_4 . TYPE_5 . VAR_3 . VAR_4 . VAR_2 . TYPE_2 ) VAR_2 ; if ( VAR_6 . METHOD_2 ( ) ) { <START> return ( VAR_6 . METHOD_3 ( VAR_1 ) != null ) ; <END> } else { return false ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( STRING_1 , true , STRING_2 ) ; VAR_1 . METHOD_2 ( STRING_3 , true , STRING_4 ) ; VAR_1 . METHOD_2 ( STRING_5 , true , STRING_6 ) ; <START> VAR_1 . METHOD_2 ( STRING_7 , true , STRING_8 ) ; <END> VAR_1 . METHOD_2 ( STRING_9 , true , STRING_10 ) ; VAR_1 . METHOD_2 ( STRING_11 , true , STRING_12 ) ; VAR_1 . METHOD_2 ( STRING_13 , true , STRING_14 ) ; return VAR_1 ; } 
public String apply ( TYPE_1 from ) { String id = from . VAR_1 ( TYPE_3 . VAR_3 ) ; if ( id == null ) <START> throw new TYPE_2 ( STRING_1 ) ; <END> return id ; } 
<START> public Builder ( ) { <END> } 
public void METHOD_1 ( ) throws TYPE_1 , IOException { TYPE_2 . METHOD_2 ( STRING_1 ) ; TYPE_2 . METHOD_2 ( STRING_2 ) ; TYPE_2 . METHOD_2 ( STRING_3 ) ; TYPE_2 . METHOD_2 ( STRING_4 ) ; TYPE_2 . METHOD_2 ( STRING_5 ) ; <START> TYPE_2 . METHOD_2 ( new String ( METHOD_3 ( INT_1 ) . read ( ) , VAR_1 ) ) ; <END> } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> METHOD_2 ( new TYPE_1 ( ) ) ; <END> bind ( TYPE_2 . class ) . in ( TYPE_3 . VAR_2 ) ; } 
private String METHOD_1 ( String VAR_1 ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( VAR_1 ) . append ( STRING_1 ) ; buffer . append ( VAR_2 ) . append ( STRING_1 ) ; buffer . append ( VAR_3 ) . append ( STRING_1 ) ; buffer . append ( VAR_4 ) ; <START> return buffer . toString ( ) ; <END> } 
<START> private String METHOD_1 ( byte [ ] VAR_1 ) { <END> return TYPE_1 . METHOD_1 ( ) . METHOD_2 ( VAR_1 ) . toString ( ) ; } 
<START> public static String format ( final String format , final String ... args ) { <END> String [ ] split = format . split ( STRING_1 ) ; final StringBuilder msg = new StringBuilder ( ) ; for ( int VAR_1 = 0 ; VAR_1 < split . length - 1 ; VAR_1 += 1 ) { msg . append ( split [ VAR_1 ] ) ; msg . append ( args [ VAR_1 ] ) ; } msg . append ( split [ split . length - 1 ] ) ; return msg . toString ( ) ; } 
public static String METHOD_1 ( String id , TYPE_1 VAR_1 ) { <START> StringBuilder sb = new StringBuilder ( ) ; <END> TYPE_2 VAR_2 = new TYPE_2 ( sb ) ; VAR_2 . format ( STRING_1 + STRING_2 , TYPE_3 . METHOD_2 ( VAR_1 ) . METHOD_3 ( "" ) . build ( ) , id ) ; return sb . toString ( ) ; } 
protected boolean METHOD_1 ( long VAR_1 , long VAR_2 ) { if ( VAR_1 > - 1 ) { long VAR_3 = currentTimeMillis ( ) ; <START> if ( VAR_2 > VAR_3 || VAR_3 - VAR_2 > VAR_1 ) <END> return true ; } return false ; } 
public void METHOD_1 ( String VAR_1 ) { this . VAR_1 = VAR_1 ; <START> this . METHOD_2 ( new Date ( ) ) ; <END> } 
protected void METHOD_1 ( List < TYPE_1 > VAR_1 , List < String > VAR_2 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( VAR_2 == null ) { throw new IllegalArgumentException ( STRING_2 ) ; } for ( String VAR_3 : VAR_2 ) { if ( VAR_3 == null ) { continue ; } <START> TYPE_1 VAR_4 = new TYPE_1 ( ) ; METHOD_2 ( VAR_4 , new TYPE_2 ( ) . METHOD_3 ( VAR_3 ) ) ; VAR_1 . add ( VAR_4 ) ; <END> } } 
public TYPE_1 < TYPE_2 > METHOD_1 ( String VAR_1 ) { TYPE_3 < TYPE_2 > query = this . VAR_2 . METHOD_2 ( VAR_1 != null ? this . VAR_3 . METHOD_3 ( TYPE_4 . METHOD_4 ( VAR_1 ) ) : this . VAR_3 . METHOD_5 ( ) , TYPE_2 . class ) ; <START> return TYPE_5 . stream ( query . VAR_4 ( ) , false ) ; <END> } 
<START> private static void METHOD_1 ( Collection < TYPE_1 > VAR_1 , <END> Set < TYPE_2 > VAR_2 ) { for ( TYPE_1 VAR_3 : VAR_1 ) { for ( TYPE_2 VAR_4 : VAR_2 ) { assertNotNull ( VAR_4 ) ; assertNotNull ( VAR_4 . getId ( ) ) ; if ( VAR_4 . getId ( ) . equals ( VAR_3 . getId ( ) ) ) { assertTrue ( VAR_4 . getName ( ) . equals ( VAR_3 . getName ( ) ) ) ; } } } } 
public TYPE_2 ( ) { this . VAR_2 = new HashMap < > ( ) ; this . VAR_3 = new TYPE_1 < > ( ) ; this . VAR_4 = new HashSet < > ( ) ; this . VAR_5 = new HashSet < > ( ) ; this . VAR_6 = new HashSet < > ( ) ; this . VAR_7 = new HashSet < > ( ) ; this . VAR_8 = null ; <START> this . VAR_9 = null ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( this . VAR_1 == null ) { <END> this . VAR_1 = VAR_1 ; } return this ; } 
<START> private TYPE_1 METHOD_1 ( ) throws TYPE_2 { <END> if ( this . VAR_1 == null || this . VAR_1 . METHOD_2 ( ) ) { log . debug ( STRING_1 ) ; TYPE_3 session = this . METHOD_3 ( ) ; TYPE_4 config = session . VAR_2 ( ) ; this . VAR_1 = session . VAR_3 ( config ) ; log . debug ( STRING_2 , this . VAR_1 ) ; } return this . VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_1 > VAR_2 ) { List < TYPE_1 > VAR_3 = VAR_4 . METHOD_1 ( VAR_1 , VAR_2 ) ; log . debug ( STRING_1 , VAR_3 . size ( ) ) ; boolean VAR_5 = VAR_1 . METHOD_2 ( ) ; for ( TYPE_1 p : VAR_3 ) { METHOD_3 ( p ) ; } for ( TYPE_1 VAR_6 : VAR_3 ) { <START> if ( VAR_5 ) { <END> VAR_6 . METHOD_4 ( true ) ; } } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) { <START> if ( VAR_2 != null ) { <END> return VAR_2 ; } TYPE_1 VAR_2 = VAR_3 . METHOD_1 ( ) ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) { if ( this . VAR_2 != null ) { <START> return this . VAR_2 ; <END> } TYPE_1 VAR_2 = VAR_3 . METHOD_1 ( ) ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) throws Exception { log . debug ( STRING_1 ) ; TYPE_2 VAR_2 = this . METHOD_2 ( ) ; TYPE_1 session = VAR_1 ? VAR_2 . METHOD_3 ( ) : <START> VAR_2 . METHOD_4 ( true , false ) ; <END> log . debug ( STRING_2 , session ) ; return session ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } final String VAR_2 = VAR_1 . METHOD_2 ( ) ; this . METHOD_3 ( new TYPE_3 ( this . VAR_3 , new TYPE_4 ( new TYPE_5 ( VAR_4 ) , <START> new TYPE_6 ( VAR_5 , VAR_2 ) <END> ) ) ) . METHOD_4 ( VAR_5 , VAR_2 ) ; return this ; } 
public TYPE_2 ( ) { this . METHOD_1 ( VAR_2 ) . METHOD_2 ( VAR_3 ) <START> . METHOD_3 ( TYPE_1 . METHOD_4 ( VAR_4 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( Set < String > VAR_1 ) { <START> this . VAR_1 = VAR_1 ; <END> return this ; } 
public Collection < TYPE_1 > METHOD_1 ( Collection < String > VAR_1 ) { Set < TYPE_1 > VAR_2 = new HashSet < > ( ) ; <START> for ( List < String > VAR_3 : this . METHOD_2 ( VAR_1 ) ) { <END> TYPE_2 VAR_4 = this . METHOD_3 ( ) . add ( TYPE_3 . in ( STRING_1 , VAR_1 ) ) ; VAR_2 . addAll ( VAR_4 . list ( ) ) ; } return VAR_2 ; } 
public TYPE_4 ( TYPE_1 config , TYPE_2 VAR_2 ) { try { <START> this . VAR_3 = new HashMap < > ( ) ; <END> this . config = config ; this . VAR_4 = VAR_2 ; this . VAR_3 = new HashMap < > ( ) ; ctx = METHOD_1 ( ) ; VAR_5 = METHOD_2 ( ) ; } catch ( TYPE_3 e ) { throw new RuntimeException ( e ) ; } } 
public void METHOD_1 ( ) { log . debug ( STRING_1 ) ; try { TYPE_1 session = this . METHOD_2 ( ) ; session . commit ( ) ; <START> session . close ( ) ; <END> } catch ( Exception e ) { log . error ( STRING_2 , e ) ; } } 
public void METHOD_1 ( ) { log . warn ( STRING_1 ) ; try { TYPE_1 session = this . METHOD_2 ( ) ; session . VAR_1 ( ) ; <START> session . close ( ) ; <END> } catch ( TYPE_2 e ) { log . error ( STRING_2 , e ) ; } } 
public TYPE_2 ( String VAR_2 , Map < String , TYPE_1 > VAR_3 ) { this . VAR_4 = VAR_3 . remove ( VAR_2 ) ; this . VAR_5 = VAR_3 ; <START> log . debug ( STRING_1 , this . VAR_4 ) ; <END> } 
protected Object METHOD_1 ( String field , Object input ) { if ( field != null && ( field . equals ( STRING_1 ) || field . equals ( STRING_2 ) ) && input == null ) { return false ; <START> } <END> return input ; } 
public TYPE_1 METHOD_1 ( Collection < String > VAR_1 ) { if ( VAR_1 != null ) { if ( this . VAR_1 == null ) { <START> this . VAR_1 = new HashSet < String > ( ) ; <END> } this . VAR_1 . clear ( ) ; this . VAR_1 . addAll ( VAR_1 ) ; } else { this . VAR_1 = null ; } return this ; } 
protected TYPE_1 METHOD_1 ( String path ) { try ( TYPE_2 VAR_1 = new TYPE_3 ( path ) ; ) { TYPE_1 VAR_2 = ( TYPE_1 ) this . VAR_3 . METHOD_2 ( VAR_1 ) ; <START> VAR_1 . close ( ) ; <END> return VAR_2 ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> VAR_1 . METHOD_2 ( this . VAR_2 , TYPE_2 . class , TYPE_3 . class ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = super . METHOD_1 ( ) ; <START> VAR_1 . VAR_2 = VAR_2 != null ? new Date ( VAR_2 . METHOD_2 ( ) ) : null ; <END> return VAR_1 ; } 
<START> public TYPE_3 . TYPE_4 . Collection < TYPE_2 > METHOD_1 ( ) { <END> return this . VAR_1 . values ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_2 ( VAR_1 . getId ( ) ) ; <START> VAR_2 . METHOD_3 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = super . METHOD_1 ( ) ; Map < String , String > VAR_2 = this . METHOD_2 ( ) ; if ( VAR_2 != null ) { <START> VAR_1 . METHOD_3 ( new HashMap < String , String > ( VAR_2 ) ) ; <END> } return VAR_1 ; } 
public boolean equals ( Object VAR_1 ) { if ( ! ( VAR_1 instanceof TYPE_1 ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) VAR_1 ; if ( this . METHOD_1 ( ) . equalsIgnoreCase ( that . VAR_2 ( ) ) ) { <START> TYPE_2 builder = new TYPE_2 ( ) <END> . append ( this . METHOD_2 ( ) , that . VAR_3 ( ) ) ; return builder . VAR_4 ( ) ; } return false ; } 
public String METHOD_1 ( ) { <START> return this . id != null ? String . format ( STRING_1 , this . id ) : null ; <END> } 
private boolean METHOD_1 ( Set < TYPE_1 > VAR_1 , Map < String , TYPE_1 > VAR_2 ) { if ( VAR_1 != null && VAR_2 != null ) { <START> for ( TYPE_1 VAR_3 : VAR_1 ) { <END> if ( VAR_3 != null && VAR_3 . getId ( ) != null && VAR_2 . get ( VAR_3 . getId ( ) ) != null ) { return true ; } } } return false ; } 
public int METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . append ( VAR_2 ) ; return VAR_1 . METHOD_2 ( ) ; <START> } <END> 
public void METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 ) { TYPE_1 VAR_2 = this . VAR_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { throw new TYPE_2 ( VAR_4 . METHOD_3 ( STRING_2 , VAR_1 ) ) ; } <START> this . VAR_3 . METHOD_4 ( Collections . VAR_5 ( VAR_2 ) , null ) ; <END> } 
<START> public boolean METHOD_1 ( TYPE_1 context ) { <END> for ( TYPE_2 VAR_1 : VAR_2 ) { log . debug ( STRING_1 , VAR_1 . getClass ( ) . METHOD_2 ( ) ) ; if ( VAR_1 . METHOD_1 ( context ) ) { log . debug ( STRING_2 , VAR_1 . getClass ( ) . METHOD_2 ( ) ) ; } else { log . error ( STRING_3 , VAR_1 . getClass ( ) . METHOD_2 ( ) ) ; return false ; } } return true ; } 
<START> public boolean execute ( TYPE_1 context ) { <END> for ( TYPE_2 VAR_1 : VAR_2 ) { log . debug ( STRING_1 , VAR_1 . getClass ( ) . METHOD_1 ( ) ) ; if ( VAR_1 . execute ( context ) ) { log . debug ( STRING_2 , VAR_1 . getClass ( ) . METHOD_1 ( ) ) ; } else { log . error ( STRING_3 , VAR_1 . getClass ( ) . METHOD_1 ( ) ) ; return false ; } } return true ; } 
<START> public void METHOD_1 ( TYPE_1 context ) { <END> log . debug ( STRING_1 ) ; context . VAR_1 ( ) ; log . debug ( STRING_2 ) ; } 
public void METHOD_1 ( String VAR_1 , boolean VAR_2 ) { if ( VAR_2 ) { VAR_3 . METHOD_2 ( VAR_1 ) ; } else { List < TYPE_1 > VAR_4 = this . METHOD_3 ( null , null , null , VAR_1 , new Date ( ) , false , false , new TYPE_2 ( ) , null , false , false ) . METHOD_4 ( ) ; for ( TYPE_1 VAR_5 : VAR_4 ) { <START> METHOD_1 ( VAR_5 . METHOD_5 ( ) , VAR_2 ) ; <END> } } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = STRING_1 ; TYPE_2 query = METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; query . VAR_3 ( STRING_2 , VAR_1 ) ; <START> return query . VAR_4 ( ) > 0 ? true : false ; <END> } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . getName ( ) . equals ( TYPE_1 . METHOD_2 ( VAR_2 ) ) ; <END> } 
public Map < String , Object > METHOD_1 ( String VAR_1 ) throws TYPE_1 { log . debug ( STRING_1 , VAR_1 ) ; List < Map < String , Object > > VAR_2 = METHOD_2 ( STRING_2 , METHOD_3 ( STRING_3 , VAR_1 ) ) ; if ( VAR_2 . size ( ) == 0 ) { throw new RuntimeException ( STRING_4 + VAR_1 ) ; } if ( VAR_2 . size ( ) > 1 ) { throw new RuntimeException ( STRING_5 + VAR_1 ) ; } return VAR_2 . get ( 0 ) ; <START> } <END> 
<START> public static Map < Object , Object > METHOD_1 ( Object key , Object value ) { <END> Map < Object , Object > query = new HashMap < Object , Object > ( ) ; query . put ( key , value ) ; return query ; } 
public void remove ( ANNOTATION_1 ( STRING_1 ) String VAR_1 , ANNOTATION_1 ( STRING_2 ) String VAR_2 ) { TYPE_1 VAR_3 = this . METHOD_1 ( VAR_1 ) ; TYPE_2 content = this . METHOD_2 ( VAR_1 , VAR_2 ) ; if ( content . VAR_4 ( ) ) { throw new TYPE_3 ( VAR_5 . METHOD_3 ( STRING_3 , content . getId ( ) ) ) ; } <START> List < TYPE_4 > VAR_6 = this . VAR_7 . METHOD_4 ( content , VAR_3 , true ) ; <END> } 
public TYPE_1 METHOD_1 ( Collection < TYPE_2 > VAR_1 ) { this . VAR_1 . clear ( ) ; <START> if ( VAR_1 != null ) { <END> this . VAR_1 . addAll ( VAR_1 ) ; } return this ; } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 ) ; <START> return VAR_2 . size ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 event ) { <START> if ( log . VAR_1 ( ) ) { <END> log . debug ( STRING_1 + event ) ; } METHOD_2 ( ) . add ( event ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 config ) { this . VAR_2 = VAR_2 ; try { VAR_3 = config . getInt ( TYPE_5 . VAR_5 ) ; factory = METHOD_1 ( ) ; } catch ( TYPE_3 e ) { throw new RuntimeException ( e ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; <START> } <END> } 
public void METHOD_1 ( TYPE_1 event ) { if ( log . VAR_1 ( ) ) { <START> log . debug ( STRING_1 + event ) ; <END> } try { TYPE_2 message = METHOD_2 ( ) . METHOD_3 ( true ) ; String VAR_2 = VAR_3 . METHOD_4 ( event ) ; message . VAR_4 ( ) . METHOD_5 ( VAR_2 ) ; METHOD_6 ( ) . METHOD_7 ( message ) ; } catch ( Exception e ) { log . error ( STRING_2 + event , e ) ; } } 
public void METHOD_1 ( TYPE_1 event ) { <START> VAR_1 . METHOD_2 ( new TYPE_2 ( event . VAR_2 ( ) . METHOD_3 ( ) ) ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return new ArrayList < TYPE_1 > ( this . VAR_1 . values ( ) ) ; <END> } 
public String toString ( ) { <START> return STRING_1 + getId ( ) + STRING_2 + ( ( VAR_1 == null ) ? STRING_3 : VAR_1 . getId ( ) ) + <END> STRING_4 + VAR_2 + STRING_5 + METHOD_1 ( ) + STRING_6 + METHOD_2 ( ) + STRING_7 ; } 
public TYPE_5 ( String name , String VAR_2 , TYPE_1 VAR_3 , TYPE_2 type ) { this ( ) ; this . name = name ; this . VAR_4 = VAR_2 ; this . VAR_3 = VAR_3 ; this . type = type ; this . VAR_5 = new HashMap < String , String > ( ) ; this . VAR_6 = new HashSet < TYPE_3 > ( ) ; this . VAR_7 = new ArrayList < TYPE_4 > ( ) ; this . VAR_8 = true ; <START> this . VAR_9 = null ; <END> } 
public TYPE_1 METHOD_1 ( String version ) { VAR_1 . METHOD_2 ( ) ; <START> METHOD_3 ( INT_1 ) ; <END> METHOD_4 ( STRING_1 ) . METHOD_5 ( version ) ; return this ; } 
public void METHOD_1 ( TYPE_1 < ? , ? > build , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 listener ) throws IOException , InterruptedException { if ( build . VAR_3 ( ) == null ) { TYPE_5 . METHOD_2 ( build , VAR_4 . getName ( ) , true ) ; } else { TYPE_5 . METHOD_2 ( build , VAR_4 . getName ( ) , false ) ; <START> } <END> } 
public TYPE_1 ( ) { <START> VAR_2 = new ArrayList < > ( ) ; <END> METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( ) ; try { <START> Thread . VAR_1 ( INT_1 ) ; <END> } catch ( Throwable t ) { } } 
void METHOD_1 ( TYPE_1 VAR_1 ) throws Throwable { TYPE_2 VAR_2 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <START> VAR_3 = VAR_2 == null ? null : TYPE_3 . METHOD_4 ( VAR_2 ) ; <END> } 
void METHOD_1 ( TYPE_1 VAR_1 ) throws Throwable { TYPE_2 VAR_2 = client . VAR_3 ( VAR_1 ) ; <START> VAR_4 = VAR_2 == null ? null : TYPE_3 . METHOD_2 ( VAR_2 ) ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <START> TYPE_1 e = new TYPE_1 ( VAR_1 , VAR_2 ) ; <END> VAR_3 . p . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( e ) ; return e ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , TYPE_4 . VAR_5 ) ; <START> this . METHOD_1 ( VAR_3 ) ; <END> VAR_6 = false ; } 
public TYPE_3 ( TYPE_1 VAR_2 , double VAR_3 ) { super ( VAR_2 , TYPE_2 . VAR_5 ) ; <START> this . METHOD_1 ( VAR_3 ) ; <END> VAR_6 = false ; } 
public static boolean VAR_1 ( TYPE_1 VAR_3 ) { switch ( VAR_3 . getType ( ) ) { case VAR_4 : case VAR_5 : <START> case VAR_6 <END> return true ; case VAR_7 : if ( VAR_3 . VAR_8 ( ) == 0 ) { return true ; } default : return false ; } } 
public void METHOD_1 ( final File VAR_1 ) { TYPE_1 input = null ; final TYPE_2 output ; try { input = METHOD_2 ( ) . METHOD_3 ( ) ; output = new TYPE_3 ( VAR_1 ) ; TYPE_4 . METHOD_4 ( input , output ) ; } catch ( final IOException VAR_2 ) { throw new TYPE_5 ( VAR_2 ) ; } finally { TYPE_4 . close ( input ) ; <START> TYPE_4 . close ( output ) ; <END> } } 
private static int [ ] METHOD_1 ( ) { int [ ] result = new int [ INT_1 ] ; <START> int offset = 0 ; <END> METHOD_1 ( VAR_1 , offset , result ) ; return result ; } 
public String METHOD_1 ( ) { StringBuilder VAR_1 = new StringBuilder ( STRING_1 ) ; VAR_1 . append ( STRING_2 ) . append ( STRING_3 ) . append ( VAR_2 . getName ( ) ) . append ( STRING_4 ) . append ( STRING_5 ) . append ( STRING_3 ) <START> . append ( VAR_2 . getClass ( ) . getName ( ) ) . append ( STRING_4 ) ; <END> return VAR_1 . toString ( ) ; } 
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; <START> sb . append ( STRING_1 ) . append ( VAR_1 . toString ( ) ) . append ( CHAR_1 ) <END> . append ( VAR_2 ? STRING_2 : STRING_3 ) . append ( CHAR_1 ) . append ( VAR_3 . toString ( ) ) . append ( CHAR_1 ) . append ( VAR_4 ) . append ( CHAR_2 ) ; return sb . toString ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return create ( VAR_1 . METHOD_2 ( ) ) ; <END> } 
protected List < String > METHOD_1 ( ) { TYPE_1 p = ( TYPE_1 ) this . getClass ( ) . METHOD_2 ( ) ; <START> System . out . println ( p . VAR_1 ( ) [ 0 ] ) ; <END> return METHOD_3 ( ) ; } 
public void METHOD_1 ( ) { Assert . assertEquals ( VAR_1 . METHOD_2 ( TYPE_1 . TYPE_2 , new String [ ] { STRING_1 , STRING_2 } ) , "" ) ; <START> Assert . assertEquals ( VAR_1 . METHOD_2 ( TYPE_1 . View , new String [ ] { STRING_1 , STRING_2 } ) , "" ) ; <END> } 
public void METHOD_1 ( ) throws Exception { when ( this . source . VAR_1 ( METHOD_2 ( TYPE_1 . class ) ) ) . METHOD_3 ( null ) ; TYPE_2 VAR_2 = null ; try { this . VAR_3 . METHOD_4 ( ) . METHOD_5 ( event , source , data ) ; } catch ( TYPE_2 e ) { <START> VAR_2 = e ; <END> } Assert . VAR_4 ( VAR_2 ) ; } 
<START> public String getId ( ) <END> { return this . id ; } 
<START> private Boolean METHOD_1 ( TYPE_1 t , TYPE_2 o ) <END> { try { int id = this . VAR_1 . METHOD_2 ( t ) ; o . VAR_2 [ id ] = true ; this . VAR_1 . METHOD_3 ( id , o . VAR_2 ) ; } catch ( Exception e ) { this . logger . warn ( STRING_1 , t ) ; return false ; } return true ; } 
<START> public String METHOD_1 ( ) <END> { try { for ( TYPE_1 < String , String > VAR_1 : this . < TYPE_1 < String , String > > METHOD_2 ( STRING_1 ) ) { if ( VAR_1 . getKey ( ) . equalsIgnoreCase ( STRING_2 ) ) { return VAR_1 . getValue ( ) ; } } } catch ( Exception ex ) { return null ; } return null ; } 
private TYPE_1 METHOD_1 ( String token ) { <START> String VAR_1 = token . VAR_2 ( ) ; <END> TYPE_1 VAR_3 = null ; for ( TYPE_1 column : TYPE_1 . values ( ) ) { if ( column . getName ( ) . equals ( VAR_1 ) ) { VAR_3 = column ; } } return VAR_3 ; } 
public List < String > METHOD_1 ( ) { final List < String > TYPE_1 = new TYPE_2 < > ( ) ; TYPE_1 . add ( VAR_1 ) ; <START> Optional . VAR_2 ( VAR_3 ) . map ( Arrays : : asList ) . METHOD_2 ( TYPE_1 : : addAll ) ; <END> return Collections . VAR_4 ( TYPE_1 ) ; } 
public TYPE_1 METHOD_1 ( Object VAR_1 ) { TYPE_1 t = VAR_2 . METHOD_1 ( VAR_1 ) ; try { <START> VAR_3 . set ( t ) ; <END> } catch ( TYPE_2 VAR_4 ) { t . VAR_5 ( ) ; throw VAR_4 ; } return t ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_3 < TYPE_2 > VAR_1 = new TYPE_3 < > ( new TYPE_4 < > ( list ) ) ; <START> VAR_1 . METHOD_2 ( VAR_1 ) ; <END> return VAR_1 ; } 
private boolean METHOD_1 ( Object VAR_1 ) { for ( Object element : list ) { <START> if ( TYPE_1 . METHOD_2 ( element , VAR_1 ) ) { <END> return true ; } } return false ; } 
Class < ? > METHOD_1 ( String name ) throws TYPE_1 { if ( VAR_1 != null ) { return METHOD_2 ( name , VAR_1 ) ; } try { return METHOD_2 ( name , VAR_2 ) ; } catch ( TYPE_1 e ) { <START> if ( TYPE_2 . METHOD_3 ( VAR_3 , VAR_2 ) ) { <END> throw e ; } else { return METHOD_2 ( name , VAR_3 ) ; } } } 
private TYPE_1 METHOD_1 ( TYPE_2 type , boolean VAR_1 ) { TYPE_1 VAR_2 = get ( type ) ; <START> if ( TYPE_3 . METHOD_2 ( VAR_2 , VAR_3 ) ) { <END> return VAR_1 ? get ( TYPE_2 . VAR_4 ) : get ( TYPE_2 . VAR_5 ) ; } if ( TYPE_3 . METHOD_2 ( VAR_2 , VAR_6 ) ) { return get ( TYPE_2 . VAR_7 ) ; } if ( TYPE_3 . METHOD_2 ( VAR_2 , VAR_8 ) ) { return get ( TYPE_2 . VAR_4 ) ; } return get ( type ) ; } 
public TYPE_1 METHOD_1 ( double x , double y , double VAR_1 , double VAR_2 ) { if ( VAR_2 == 0 ) return this ; <START> return METHOD_1 ( VAR_3 . METHOD_2 ( x , y , VAR_1 , VAR_2 ) ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { <START> if ( null == VAR_1 ) { <END> throw new IllegalStateException ( STRING_1 ) ; } return VAR_1 ; } 
<START> public TYPE_1 ( String value ) { <END> this . value = value ; } 
protected Object METHOD_1 ( ) { try { return METHOD_2 ( ) ; } catch ( TYPE_1 e ) { <START> e . VAR_1 ( ) ; <END> } return null ; } 
public void METHOD_1 ( final boolean VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = TYPE_1 . METHOD_2 ( ) . getInt ( <START> TYPE_3 . VAR_4 , TYPE_2 . VAR_6 , INT_1 , null ) ; <END> VAR_7 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . VAR_4 , TYPE_2 . VAR_8 , true , null ) ; METHOD_4 ( VAR_1 ) ; } 
public static long METHOD_1 ( String VAR_1 ) { <START> long VAR_2 = TYPE_1 . parse ( VAR_1 ) . METHOD_2 ( ) ; <END> return VAR_2 ; } 
private boolean METHOD_1 ( ) { long VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; long VAR_4 = VAR_2 . METHOD_3 ( ) ; <START> return ( System . currentTimeMillis ( ) > VAR_1 + VAR_4 ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; <START> System . VAR_2 ( STRING_1 , "" ) ; <END> } 
<START> private String METHOD_1 ( TYPE_1 result , String VAR_1 ) throws TYPE_2 { <END> StringBuilder VAR_2 = new StringBuilder ( ) ; TYPE_3 it = result . VAR_3 ( ) ; while ( it . hasNext ( ) ) { if ( VAR_2 . length ( ) > 0 ) { VAR_2 . append ( STRING_1 ) ; } VAR_2 . append ( it . VAR_4 ( ) . getValue ( VAR_1 ) . getString ( ) ) ; } return VAR_2 . toString ( ) ; } 
<START> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , InterruptedException { <END> boolean VAR_2 = true ; TYPE_3 status = TYPE_3 . VAR_3 ; while ( VAR_2 ) { VAR_1 . METHOD_2 ( ) ; status = VAR_1 . METHOD_3 ( ) . getStatus ( ) ; VAR_2 = status == TYPE_3 . VAR_3 ; if ( VAR_2 ) { Thread . VAR_4 ( INT_1 ) ; } } return status == TYPE_3 . VAR_5 ; } 
public void METHOD_1 ( boolean VAR_1 ) { VAR_2 = VAR_1 ; <START> if ( VAR_1 ) { <END> VAR_3 . METHOD_2 ( TYPE_1 . VAR_5 ) ; } else { VAR_3 . METHOD_2 ( TYPE_1 . VAR_6 ) ; } } 
protected String METHOD_1 ( TYPE_1 resource ) { try { TYPE_2 VAR_1 = TYPE_1 . class . METHOD_2 ( STRING_1 ) ; return ( String ) VAR_1 . METHOD_3 ( resource ) ; <START> } catch ( TYPE_3 e ) { return "" ; } catch ( TYPE_4 e ) { return "" ; } catch ( TYPE_5 e ) { return "" ; } <END> } 
public void METHOD_1 ( ) throws Exception { final String VAR_1 = VAR_2 . get ( ) . METHOD_2 ( ) ; System . out . println ( VAR_1 ) ; <START> TYPE_1 . METHOD_3 ( VAR_1 , STRING_1 , VAR_3 ) ; <END> final TYPE_2 resource = Thread . VAR_4 ( ) . METHOD_4 ( ) . METHOD_5 ( STRING_2 ) ; METHOD_3 ( VAR_1 , STRING_3 , String . format ( STRING_4 , resource . toString ( ) ) ) ; } 
<START> protected void METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_2 . METHOD_2 ( ) ; try { if ( TYPE_2 . METHOD_3 ( ) ) { try { if ( VAR_1 != null ) { VAR_1 . METHOD_4 ( ) ; VAR_1 . METHOD_1 ( ) ; } } finally { TYPE_2 . METHOD_5 ( ) ; } } METHOD_6 ( null ) ; } catch ( Exception e ) { throw new RuntimeException ( STRING_1 , e ) ; } } 
Set < T > METHOD_1 ( Set < T > VAR_1 , Set < T > VAR_2 ) { <START> if ( VAR_2 . isEmpty ( ) ) { <END> return VAR_1 ; } else { return TYPE_1 . of ( ) ; } } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; VAR_1 . METHOD_2 ( 0 , STRING_2 ) ; <START> System . out . println ( VAR_1 . toString ( false ) ) ; <END> final TYPE_2 VAR_2 = TYPE_2 . METHOD_3 ( VAR_1 , VAR_3 ) ; assertEquals ( TYPE_2 . TYPE_3 . VAR_5 , VAR_2 . METHOD_4 ( ) ) ; } 
<START> public String METHOD_1 ( ) { <END> return x ; } 
<START> public String METHOD_1 ( ) { <END> return VAR_1 ; } 
private String METHOD_1 ( String VAR_1 , String VAR_2 ) { if ( VAR_1 == null || VAR_2 == null ) { <START> logger . debug ( STRING_1 ) ; <END> } String VAR_3 = String . format ( STRING_2 , VAR_1 , VAR_2 ) ; try { return STRING_3 + new String ( TYPE_1 . METHOD_2 ( VAR_3 . METHOD_3 ( STRING_4 ) ) ) ; } catch ( TYPE_2 e ) { throw new IllegalStateException ( STRING_5 ) ; } } 
public Response METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { context . VAR_2 ( ) . METHOD_2 ( ) . add ( TYPE_3 . Type . VAR_4 , STRING_1 ) ; TYPE_2 VAR_5 = new TYPE_2 ( context , VAR_1 . METHOD_3 ( ) ) ; <START> return Response . VAR_6 ( VAR_5 . METHOD_4 ( ) . toString ( ) ) <END> . METHOD_5 ( STRING_2 , STRING_3 ) . build ( ) ; } 
public String id ( ) { <START> return getString ( STRING_1 ) ; <END> } 
public boolean equals ( Object obj ) { boolean result ; if ( obj == null ) { result = false ; } else { <START> TYPE_1 VAR_1 = ( TYPE_1 ) obj ; <END> result = VAR_2 . equals ( VAR_1 . METHOD_1 ( ) ) && VAR_3 . equals ( VAR_1 . METHOD_2 ( ) ) ; } return result ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> super . METHOD_1 ( ) ; } 
<START> public void METHOD_1 ( ) { <END> VAR_1 . clear ( ) ; for ( TYPE_1 VAR_2 : VAR_3 ) { VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> TYPE_2 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 != null ) { return VAR_2 . METHOD_3 ( ) ; } else { Log . i ( TAG , STRING_1 ) ; } return VAR_1 ; } 
public static void METHOD_1 ( Context context , int VAR_1 ) { <START> Log . e ( Thread . VAR_2 ( ) . METHOD_2 ( ) [ VAR_3 ] . toString ( ) , context . getString ( VAR_1 ) ) ; <END> METHOD_3 ( context , context . getString ( VAR_1 ) ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { synchronized ( VAR_1 ) { <START> ArrayList < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( VAR_3 ) ; <END> Collections . VAR_4 ( VAR_2 ) ; return Collections . VAR_5 ( VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { this . VAR_2 = new TYPE_3 ( new TYPE_4 ( ) { @Override public void METHOD_2 ( TYPE_5 VAR_3 ) { <START> new TYPE_6 ( TYPE_3 . VAR_4 ) . METHOD_3 ( TYPE_9 . this ) ; <END> } } ) ; this . VAR_6 = new TYPE_7 ( ) ; METHOD_4 ( ) ; return new TYPE_8 ( ) ; } 
<START> protected void METHOD_1 ( ) { <END> super . METHOD_1 ( ) ; TYPE_1 . METHOD_2 ( this , STRING_1 ) ; TYPE_2 VAR_1 = new TYPE_2 ( this , TYPE_3 . class ) ; METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 input ) throws IOException { byte [ ] VAR_1 = new byte [ INT_1 ] ; int read = 0 ; TYPE_2 out = new TYPE_2 ( ) ; <START> while ( ( read = input . read ( VAR_1 ) ) > 0 ) <END> out . write ( VAR_1 , 0 , read ) ; this . METHOD_2 ( out . toString ( ) ) ; } 
private static boolean METHOD_1 ( TYPE_1 vm ) { <START> return ( vm instanceof TYPE_2 ) && TYPE_5 . TYPE_6 . equals ( TYPE_4 . METHOD_2 ( ( TYPE_2 ) vm ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 == null ) { <END> super . METHOD_1 ( VAR_1 ) ; } else { VAR_1 . METHOD_2 ( VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 channel , TYPE_3 key ) throws IOException { TYPE_4 e = VAR_1 . METHOD_2 ( ) ; e . VAR_2 ( false ) ; <START> if ( VAR_3 != null ) { <END> e . VAR_4 ( VAR_3 ) ; } return new TYPE_5 ( channel , e , VAR_5 , key ) ; } 
public void METHOD_1 ( ) { byte [ ] VAR_1 = METHOD_2 ( VAR_2 , TYPE_1 . VAR_3 ) ; try { METHOD_3 ( METHOD_4 ( VAR_2 , VAR_1 , TYPE_1 . class ) , TYPE_1 . VAR_3 ) ; <START> } catch ( TYPE_2 e ) { <END> e . VAR_4 ( ) ; throw e ; } } 
public static Set < TYPE_1 > METHOD_1 ( final Set < TYPE_1 > VAR_1 ) { final TYPE_1 VAR_2 = METHOD_2 ( TYPE_2 . VAR_4 ) ; <START> if ( ! VAR_1 . contains ( VAR_2 ) ) { <END> VAR_1 . add ( VAR_2 ) ; } final TYPE_1 VAR_5 = METHOD_2 ( TYPE_2 . VAR_6 ) ; if ( ! VAR_1 . contains ( VAR_5 ) ) { VAR_1 . add ( VAR_5 ) ; } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 monitor ) throws TYPE_2 { <START> if ( VAR_1 . METHOD_2 ( ) != null ) { <END> VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . VAR_2 , monitor ) ; TYPE_4 VAR_3 = new TYPE_5 ( new TYPE_3 [ ] { VAR_1 . METHOD_2 ( ) } ) ; VAR_3 . METHOD_4 ( ) ; } } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; METHOD_2 ( STRING_1 ) ; <START> } <END> 
public void METHOD_1 ( final Collection < TYPE_1 > VAR_1 ) { this . VAR_1 = VAR_1 ; if ( this . VAR_1 . size ( ) != 0 ) { <START> METHOD_2 ( STRING_1 ) ; <END> } } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { this . VAR_3 = VAR_3 ; if ( ! TYPE_1 . METHOD_2 ( VAR_1 ) ) { <START> this . VAR_2 = VAR_1 ; <END> } else if ( ! TYPE_1 . METHOD_2 ( VAR_2 ) ) { this . VAR_2 = VAR_2 ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> METHOD_2 ( ) ; <END> String path = String . format ( STRING_1 , METHOD_3 ( ) , getId ( ) , VAR_1 . METHOD_3 ( ) , VAR_1 . getId ( ) ) ; final TYPE_3 request = new TYPE_3 ( TYPE_4 . VAR_3 , path ) ; request . execute ( ) ; } 
<START> public String METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public Collection < TYPE_1 > METHOD_1 ( final Integer VAR_1 , Integer page , final Map < String , Object > VAR_2 ) <END> throws TYPE_2 { String path = String . format ( STRING_1 , METHOD_2 ( ) ) ; return METHOD_3 ( path , VAR_1 , page , VAR_2 ) ; } 
private static boolean METHOD_1 ( ArrayList < String > VAR_1 ) { for ( String VAR_2 : VAR_1 ) { <START> if ( VAR_2 == STRING_1 ) { <END> return false ; } } return true ; } 
private TYPE_1 METHOD_1 ( TYPE_2 < ? , ? > build ) { if ( build instanceof TYPE_3 ) { return ( ( TYPE_3 ) build ) . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; } else { <START> return build . VAR_1 ( ) . METHOD_4 ( ) ; <END> } } 
private void METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 ) { VAR_1 . forEach ( x - > { <START> if ( x instanceof TYPE_2 && ( ( TYPE_2 ) x ) . METHOD_2 ( ) . toString ( ) . equals ( TYPE_3 . VAR_4 ) ) { <END> METHOD_1 ( ( ( TYPE_2 ) x ) . METHOD_3 ( ) , VAR_2 ) ; } else { VAR_2 . add ( x ) ; } } ) ; } 
private TYPE_5 ( TYPE_1 VAR_2 ) throws IOException { if ( VAR_2 . name ( ) . METHOD_1 ( TYPE_2 . VAR_3 ) ) { <START> org . VAR_4 . VAR_5 . TYPE_3 VAR_7 = TYPE_3 . from ( STRING_1 , STRING_2 ) ; <END> this . VAR_8 = new TYPE_2 ( VAR_7 , true ) . METHOD_2 ( VAR_2 ) ; } else { this . VAR_8 = new TYPE_4 ( VAR_2 ) ; } } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 context ) { this . data = new TYPE_4 ( VAR_2 , VAR_3 ) ; <START> this . context = context . VAR_4 ( ) ; <END> } 
public List < Map < TYPE_1 , TYPE_2 > > METHOD_1 ( TYPE_2 VAR_1 , org . VAR_2 . VAR_3 . TYPE_3 VAR_5 ) { <START> return ( List < Map < TYPE_1 , TYPE_2 > > ) METHOD_2 ( VAR_1 , Optional . of ( 0 ) , Optional . empty ( ) , VAR_5 ) ; <END> } 
public File METHOD_1 ( ) { <START> File m = VAR_1 ; <END> if ( m == null ) { if ( parameters == null || parameters . size ( ) == 0 ) { throw TYPE_1 . METHOD_2 ( STRING_1 ) ; } m = VAR_1 = VAR_2 . get ( ) . METHOD_3 ( parameters . get ( 0 ) ) ; } return m ; } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , boolean VAR_5 ) { <START> this . VAR_3 = VAR_3 ; <END> this . VAR_4 = VAR_4 ; this . VAR_2 = VAR_2 ; this . parser = new TYPE_4 ( VAR_3 , VAR_4 , VAR_2 . VAR_6 ) ; this . VAR_5 = VAR_5 ; this . VAR_7 = new TYPE_5 ( VAR_4 ) ; this . VAR_8 = new TYPE_6 ( VAR_2 . VAR_6 ) ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 == null ) { <START> if ( VAR_2 == null || ! VAR_2 . isEmpty ( ) ) { <END> new TYPE_1 ( ) . METHOD_2 ( this ) ; } else { VAR_1 = true ; } } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_1 d ) { <START> TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( d . VAR_3 ( ) ) . METHOD_3 ( ) ; <END> TYPE_4 . TYPE_5 . Set < TYPE_2 > VAR_4 = METHOD_4 ( d . VAR_5 ( ) ) ; VAR_4 . add ( VAR_1 ) ; return TYPE_1 ( d . VAR_6 ( ) , VAR_1 , METHOD_5 ( VAR_4 ) ) ; } 
<START> public TYPE_1 < String , TYPE_2 , TYPE_3 > METHOD_1 ( TYPE_4 VAR_1 ) { <END> TYPE_5 VAR_2 = METHOD_2 ( VAR_3 . METHOD_3 ( ) ) ; return METHOD_4 ( VAR_2 , VAR_4 , VAR_1 ) ; } 
<START> public TYPE_3 ( TYPE_1 VAR_2 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_2 ; this . VAR_4 = VAR_2 ; this . VAR_5 = VAR_2 ; this . VAR_6 = TYPE_2 . METHOD_1 ( VAR_5 ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 , org . VAR_3 . VAR_4 . TYPE_6 VAR_6 ) { <START> TYPE_3 parser = new TYPE_3 ( VAR_6 ) ; <END> TYPE_4 VAR_7 = parser . VAR_8 ( VAR_1 , VAR_2 ) . METHOD_2 ( ) . METHOD_3 ( ) . get ( ) ; return TYPE_5 . apply ( VAR_7 ) ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) throws TYPE_2 { if ( VAR_2 == null ) { throw new IllegalStateException ( STRING_1 + STRING_2 + STRING_3 ) ; } <START> TYPE_1 results = VAR_3 . METHOD_2 ( null , VAR_1 , TYPE_3 . VAR_5 , VAR_6 , METHOD_3 ( VAR_2 ) . METHOD_4 ( ) , VAR_7 , false ) ; <END> METHOD_5 ( results . VAR_8 ( ) ) ; VAR_2 = null ; return results ; } 
protected Object METHOD_1 ( final Object o , final Map < Object , Object > VAR_1 ) throws TYPE_1 { <START> if ( ( o instanceof TYPE_2 && ! ( ( TYPE_2 ) o ) . METHOD_2 ( ) ) ) { <END> return o ; } else { return super . METHOD_1 ( o , VAR_1 ) ; } } 
<START> public void METHOD_1 ( File file , String content ) { <END> try { File VAR_1 = file . VAR_2 ( ) . METHOD_2 ( ) ; if ( ! VAR_1 . exists ( ) && ! VAR_1 . METHOD_3 ( ) ) { throw TYPE_1 . METHOD_4 ( STRING_1 + VAR_1 ) ; } TYPE_2 . METHOD_5 ( file , content ) ; } catch ( IOException e ) { throw TYPE_1 . METHOD_4 ( STRING_2 + file . VAR_3 ( ) , e ) ; } } 
<START> public TYPE_1 ( String name , Context context ) { <END> this . context = context ; this . VAR_2 = null ; this . VAR_3 = null ; this . VAR_4 = context == null ? null : context . VAR_4 ; this . VAR_5 = context == null ? null : context . VAR_5 ; this . name = name ; } 
<START> public boolean METHOD_1 ( ) { <END> return true ; } 
<START> public boolean METHOD_1 ( ) { <END> return VAR_1 . isEmpty ( ) && VAR_2 . isEmpty ( ) && VAR_3 . isEmpty ( ) ; } 
<START> public boolean METHOD_1 ( ) { <END> return METHOD_2 ( ) && super . METHOD_1 ( ) ; } 
<START> public boolean METHOD_1 ( ) { <END> return false ; } 
public TYPE_1 METHOD_1 ( ) { <START> return TYPE_2 . VAR_2 ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 . VAR_1 != null ) { assert false : STRING_1 ; <START> } <END> VAR_2 . VAR_1 = VAR_1 ; } 
public TYPE_6 ( Context context ) throws TYPE_1 { VAR_2 = ( TYPE_2 ) TYPE_3 . METHOD_1 ( new File ( context . VAR_3 , TYPE_7 . VAR_5 ) . toString ( ) ) ; if ( VAR_2 == null ) { throw new TYPE_1 ( STRING_1 ) ; } <START> VAR_6 = new TYPE_4 ( VAR_2 ) ; <END> this . context = VAR_2 . context ( ) ; this . context . VAR_3 = context . VAR_3 ; this . context . VAR_7 = context . VAR_7 ; VAR_8 = new TYPE_5 ( this . context ) ; } 
public void METHOD_1 ( Map < TYPE_1 , TYPE_1 > map ) { TYPE_2 . METHOD_2 ( ! VAR_1 , STRING_1 ) ; <START> for ( Map . Entry < TYPE_1 , TYPE_1 > e : map . entrySet ( ) ) { <END> VAR_2 . put ( e . getKey ( ) , e . getValue ( ) ) ; } } 
public final int METHOD_1 ( ) { if ( VAR_1 == Utils . VAR_2 ) { <START> VAR_1 = METHOD_2 ( ) ; <END> } return VAR_1 ; } 
public TYPE_3 ( String VAR_2 , List < TYPE_1 > VAR_3 , TYPE_2 VAR_4 ) { super ( VAR_2 ) ; <START> VAR_5 = "" ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
<START> public String toString ( ) { return "" + key ; } <END> 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws TYPE_4 { TYPE_1 VAR_3 ; if ( ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ) <START> VAR_3 = super . METHOD_4 ( VAR_1 . METHOD_5 ( ) . get ( 0 ) , VAR_2 ) ; <END> else VAR_3 = super . METHOD_1 ( VAR_1 , VAR_2 ) ; return VAR_3 ; } 
<START> public int METHOD_1 ( ) { <END> if ( VAR_1 ) { VAR_2 = VAR_3 != null ? VAR_3 . METHOD_1 ( ) : 0 ; VAR_2 = INT_1 * VAR_2 + VAR_4 . METHOD_1 ( ) ; for ( TYPE_1 t : VAR_5 ) VAR_2 = INT_1 * VAR_2 + t . VAR_6 ( ) ; VAR_1 = true ; } return VAR_2 ; } 
public boolean add ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 . containsKey ( VAR_1 . VAR_3 ) ) { <END> return false ; } else { VAR_2 . put ( VAR_1 . VAR_3 , VAR_1 ) ; return true ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 node ) throws TYPE_3 { TYPE_1 VAR_1 = node . VAR_2 ( ) . METHOD_2 ( this ) ; if ( VAR_1 == null ) node . VAR_3 ( TYPE_4 . VAR_4 ) ; else if ( VAR_1 instanceof TYPE_4 ) node . VAR_3 ( ( TYPE_4 ) VAR_1 ) ; <START> else { <END> TYPE_4 VAR_5 = new TYPE_4 ( ) ; VAR_5 . METHOD_3 ( ) . add ( ( TYPE_5 ) VAR_1 ) ; node . VAR_3 ( VAR_5 ) ; } return node ; } 
public String toString ( ) { String content = "" ; for ( TYPE_1 VAR_1 : VAR_2 ) if ( VAR_1 != null ) content += VAR_1 + STRING_1 ; if ( content . length ( ) > 1 ) <START> content = content . substring ( 0 , content . length ( ) - 2 ) ; <END> return STRING_2 + content + STRING_3 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_2 VAR_2 , TYPE_3 context ) { TYPE_4 matcher = new TYPE_4 ( context ) ; try { matcher . VAR_3 ( VAR_1 , VAR_2 ) ; <START> } catch ( TYPE_5 e ) { <END> return TYPE_1 . VAR_4 ; } return TYPE_1 . VAR_5 ; } 
public boolean METHOD_1 ( TYPE_1 index ) { return index instanceof TYPE_2 || equals ( index ) || ( index instanceof TYPE_3 && <START> ( ( TYPE_3 ) index ) . METHOD_2 ( ) . METHOD_3 ( ) . contains ( VAR_1 ) ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 index ) { return index instanceof TYPE_2 || equals ( index ) || ( index instanceof TYPE_3 && <START> VAR_1 . METHOD_2 ( ) . contains ( ( ( TYPE_3 ) index ) . METHOD_3 ( ) ) ) ; <END> } 
private static boolean METHOD_1 ( Class VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 field = METHOD_2 ( VAR_1 , VAR_2 . getName ( ) ) ; return field != null <START> ? VAR_2 . METHOD_3 ( ) . METHOD_4 ( Optional . VAR_3 ) . length > 0 <END> || field . VAR_4 ( Optional . VAR_3 ) . length > 0 : VAR_2 . METHOD_3 ( ) . METHOD_4 ( Optional . VAR_3 ) . length > 0 ; } 
public static TYPE_1 METHOD_1 ( ) { <START> if ( ! METHOD_2 ( ) ) { <END> return METHOD_3 ( ) ; } else { return METHOD_4 ( ) . METHOD_5 ( METHOD_3 ( ) ) ; } } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) return null ; <START> if ( VAR_1 . METHOD_2 ( STRING_1 ) ) <END> return TYPE_1 . VAR_2 ; else if ( VAR_1 . METHOD_2 ( STRING_2 ) ) return TYPE_1 . VAR_3 ; else if ( VAR_1 . METHOD_2 ( STRING_3 ) ) return TYPE_1 . VAR_4 ; else return null ; } 
private static boolean METHOD_1 ( Class VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 field = METHOD_2 ( VAR_1 , VAR_2 . getName ( ) ) ; if ( field == null ) { <START> throw new TYPE_4 . TYPE_5 ( STRING_1 + VAR_2 + STRING_2 + VAR_1 . getName ( ) + STRING_3 ) ; <END> } return ( field . VAR_3 ( Optional . VAR_4 ) . length > 0 ) ; } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return VAR_1 ; } 
static String METHOD_1 ( Iterator < TYPE_1 > VAR_1 ) { <START> String VAR_2 = "" ; <END> while ( VAR_1 . hasNext ( ) ) { VAR_2 += VAR_1 . next ( ) . METHOD_2 ( ) ; } return VAR_2 ; } 
TYPE_5 ( TYPE_1 VAR_2 , boolean VAR_3 , List < TYPE_2 > VAR_4 ) { super ( TYPE_4 . VAR_6 , VAR_2 , <START> STRING_1 + ( VAR_3 ? STRING_2 : "" ) + TYPE_3 . METHOD_1 ( VAR_4 . iterator ( ) ) + STRING_3 ) ; <END> this . VAR_3 = VAR_3 ; this . value = VAR_4 ; } 
public TYPE_3 ( ) { <START> super ( VAR_2 , STRING_1 , new TYPE_1 ( TYPE_4 . VAR_4 ) , TYPE_2 . VAR_6 . get ( ) ) ; <END> } 
public ANNOTATION_1 TYPE_1 METHOD_1 ( int index ) { final TYPE_1 VAR_1 = VAR_2 . get ( index ) ; <START> return VAR_1 . isEmpty ( ) ? VAR_3 . METHOD_1 ( index ) : VAR_1 ; <END> } 
public void METHOD_1 ( TYPE_1 target ) { if ( target == null ) { return ; } for ( TYPE_1 t : VAR_1 ) { if ( target . equals ( t ) ) { <START> VAR_1 . remove ( t ) ; <END> } } METHOD_2 ( ) ; } 
public TYPE_1 read ( ANNOTATION_1 TYPE_2 VAR_1 , ANNOTATION_1 Set < TYPE_3 > VAR_2 , ANNOTATION_1 TYPE_4 VAR_3 , ANNOTATION_2 TYPE_5 field , ANNOTATION_1 String name , ANNOTATION_2 TYPE_1 object ) throws IllegalArgumentException , TYPE_6 , TYPE_7 , TYPE_8 { if ( object == null ) { if ( VAR_3 . METHOD_1 ( name ) ) { object = TYPE_9 . METHOD_2 ( VAR_3 . METHOD_3 ( name ) ) ; <START> } else { <END> return object ; } } object . VAR_4 ( VAR_3 . METHOD_3 ( name ) ) ; return object ; } 
public final void METHOD_1 ( ) { <START> if ( TYPE_1 . VAR_2 || VAR_3 == null || VAR_3 . METHOD_2 ( ) != VAR_4 ) { <END> VAR_4 = VAR_3 . METHOD_2 ( ) ; METHOD_3 ( ) ; if ( VAR_5 && ! VAR_3 . VAR_6 ) { int VAR_7 = METHOD_4 ( INT_1 ) ; if ( ++ VAR_8 >= METHOD_5 ( ) || VAR_7 != VAR_9 ) { METHOD_6 ( ) ; VAR_9 = VAR_7 ; } } } } 
public static void METHOD_1 ( List list , TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) { return ; } String VAR_2 = null ; <START> if ( VAR_1 . METHOD_2 ( ) instanceof TYPE_2 ) { <END> VAR_2 = ( ( TYPE_2 ) VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( VAR_1 ) ; } if ( VAR_2 == null ) { VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_4 ( VAR_1 ) ; } METHOD_1 ( list , VAR_2 ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( true , false ) ) { VAR_2 . set ( false ) ; super . METHOD_1 ( ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> VAR_4 . close ( ) ; VAR_5 . METHOD_3 ( ) ; } } 
<START> private static boolean METHOD_1 ( <END> TYPE_1 description , TYPE_5 . TYPE_6 channel ) { boolean VAR_1 = false ; for ( TYPE_3 VAR_2 : description . VAR_3 ( ) ) { channel . VAR_4 ( VAR_2 ) ; VAR_1 = true ; } for ( TYPE_4 VAR_5 : description . VAR_6 ( ) ) { channel . VAR_7 ( VAR_5 ) ; VAR_1 = true ; } return VAR_1 ; } 
public void METHOD_1 ( ) { try { VAR_1 = TYPE_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( true ) ; VAR_2 = VAR_1 . METHOD_4 ( ) ; } catch ( TYPE_2 e ) { } <START> TYPE_3 . METHOD_5 ( <END> TYPE_4 . class ) ; VAR_3 = new TYPE_5 ( ) ; } 
<START> public Object [ ] METHOD_1 ( ) { <END> return new Object [ ] { new Integer ( 1 ) , new TYPE_1 ( STRING_1 ) , new TYPE_1 ( STRING_2 ) , new TYPE_1 ( STRING_3 ) , new TYPE_1 ( STRING_2 ) , new TYPE_1 ( STRING_3 ) , new TYPE_1 ( STRING_1 ) , new TYPE_1 ( STRING_2 ) , new TYPE_1 ( STRING_3 ) , new TYPE_1 ( STRING_2 ) , new TYPE_1 ( STRING_3 ) } ; } 
public void METHOD_1 ( ) throws IOException { if ( VAR_1 ) { VAR_2 . METHOD_2 ( IOException . VAR_3 ) ; VAR_2 . METHOD_3 ( STRING_1 ) ; <START> TYPE_1 . METHOD_4 ( VAR_2 ) ; <END> } TYPE_2 builder = METHOD_5 ( ) ; TYPE_1 . METHOD_6 ( builder ) ; METHOD_7 ( builder . build ( ) ) ; if ( ! VAR_1 ) { METHOD_8 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> TYPE_1 VAR_2 = null ; for ( int i = 0 ; i < VAR_3 . size ( ) ; i ++ ) { TYPE_2 child = VAR_3 . get ( i ) ; if ( child . VAR_4 ( ) != VAR_2 ) { VAR_2 = child . VAR_4 ( ) ; } } VAR_1 = VAR_2 ; } return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) + TYPE_3 . VAR_6 ) ; } 
public boolean METHOD_1 ( TYPE_1 context , int index ) throws TYPE_2 { <START> return false ; <END> } 
public TYPE_2 ( String name , String VAR_2 , TYPE_1 VAR_3 , boolean VAR_4 ) { this . name = name ; this . VAR_3 = VAR_3 ; this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; <START> this . VAR_5 = - 1 ; <END> } 
public static TYPE_1 create ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 { final TYPE_2 VAR_3 = VAR_1 . METHOD_1 ( ) ; <START> if ( VAR_2 != null && ! VAR_3 . METHOD_2 ( VAR_2 ) ) { <END> throw new TYPE_4 ( VAR_3 , VAR_2 , VAR_1 . toString ( ) ) ; } return VAR_2 == VAR_3 ? VAR_1 : VAR_1 instanceof TYPE_5 ? TYPE_5 . METHOD_3 ( ( ( TYPE_5 ) VAR_1 ) . getValue ( ) , VAR_2 ) : new TYPE_6 ( VAR_1 , VAR_2 ) ; } 
public Object METHOD_1 ( String value ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
public TYPE_2 ( TYPE_1 column ) { super ( column ) ; this . VAR_2 = column . VAR_3 ( ) . METHOD_1 ( ) ; this . VAR_4 = column . getName ( ) . METHOD_1 ( ) ; <START> this . VAR_5 = column . VAR_6 ( ) ; <END> this . VAR_7 = column . VAR_8 ( ) ; } 
public TYPE_1 ( ) { <START> VAR_2 = new HashMap < String , byte [ ] [ ] > ( ) ; <END> } 
public TYPE_2 ( String message ) { <START> super ( TYPE_1 . METHOD_1 ( VAR_2 ) . METHOD_2 ( message ) . toString ( ) , VAR_2 . METHOD_3 ( ) ) ; <END> } 
public static boolean METHOD_1 ( File file ) <START> { <END> Assert . VAR_1 ( file , STRING_1 ) ; return METHOD_1 ( file , false ) ; } 
protected boolean METHOD_1 ( T item ) { if ( VAR_1 . METHOD_2 ( VAR_2 ) ) { return matcher . VAR_3 ( item ) ; <START> } else { <END> TYPE_1 VAR_4 = new TYPE_2 ( ) . METHOD_3 ( VAR_2 ) . METHOD_4 ( VAR_1 ) ; throw new TYPE_3 ( String . format ( STRING_1 , VAR_4 ) ) ; } } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , int VAR_3 ) { <START> if ( VAR_1 . METHOD_2 ( ) == TYPE_5 . VAR_5 || VAR_3 == 0 ) { <END> return ; } VAR_2 . METHOD_3 ( ( short ) ( VAR_2 . METHOD_4 ( ) + VAR_3 ) ) ; if ( VAR_2 . METHOD_4 ( ) == VAR_6 + VAR_3 ) { TYPE_3 . METHOD_5 ( new TYPE_4 ( VAR_1 , VAR_2 ) ) ; VAR_1 . METHOD_6 ( ) . remove ( VAR_2 ) ; } } 
protected boolean METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { <START> return VAR_2 == TYPE_4 . VAR_4 || VAR_2 == TYPE_4 . VAR_5 && super . METHOD_1 ( VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { switch ( VAR_1 ) { case 0 : return TYPE_1 . NONE ; <START> case 1 : <END> return TYPE_1 . NONE ; case 2 : return TYPE_1 . VAR_2 ; case 3 : return TYPE_1 . VAR_2 ; case 4 : return TYPE_1 . VAR_3 ; case 5 : return TYPE_1 . VAR_3 ; case INT_1 : return TYPE_1 . VAR_4 ; case INT_2 : return TYPE_1 . VAR_4 ; } return TYPE_1 . NONE ; } 
public void METHOD_1 ( TYPE_1 location , TYPE_2 VAR_1 , float VAR_2 , float VAR_3 ) { if ( location == null || VAR_1 == null ) return ; <START> final double VAR_4 = Math . VAR_5 ( VAR_2 > 1 ? VAR_2 * INT_1 : INT_1 , 2 ) ; <END> for ( TYPE_3 VAR_6 : METHOD_2 ( ) ) { if ( VAR_6 . METHOD_3 ( ) . METHOD_4 ( location ) <= VAR_4 ) { VAR_6 . METHOD_1 ( location , VAR_1 , VAR_2 , VAR_3 ) ; } } } 
<START> TYPE_1 ( TYPE_2 VAR_1 , TYPE_1 VAR_2 ) { <END> this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , boolean VAR_4 ) { TYPE_1 VAR_5 = VAR_1 . METHOD_2 ( VAR_3 ) ; if ( VAR_5 == null ) { return ; } TYPE_4 VAR_6 = VAR_5 . getType ( ) ; <START> if ( VAR_6 == TYPE_4 . VAR_7 ) { <END> } else { return ; } VAR_2 . METHOD_3 ( VAR_1 , VAR_3 , INT_1 , VAR_4 ) ; } 
<START> public void METHOD_1 ( TYPE_1 location , TYPE_2 VAR_1 , TYPE_3 type ) throws TYPE_4 { <END> TYPE_5 . METHOD_2 ( location , STRING_1 ) ; TYPE_5 . METHOD_2 ( VAR_1 , STRING_2 ) ; TYPE_5 . METHOD_2 ( type , STRING_3 ) ; VAR_2 . add ( new TYPE_6 ( location . VAR_3 ( ) , location . VAR_4 ( ) , location . VAR_5 ( ) , type . getValue ( ) , VAR_1 ) ) ; } 
public boolean add ( TYPE_1 object ) { switch ( VAR_1 ) { <START> case VAR_2 : { <END> int VAR_3 = 0 ; for ( Collection < TYPE_1 > parent : VAR_4 ) { if ( parent . add ( object ) ) { VAR_3 ++ ; } } return METHOD_1 ( VAR_3 ) ; } case VAR_5 : { return VAR_4 . get ( VAR_4 . size ( ) - 1 ) . add ( object ) ; } } throw new IllegalStateException ( STRING_1 ) ; } 
<START> public TYPE_7 ( TYPE_1 location ) { <END> super ( location , TYPE_5 . VAR_3 ) ; TYPE_2 VAR_4 = new TYPE_2 ( ) ; this . VAR_5 = TYPE_6 . VAR_3 ; this . VAR_7 = TYPE_3 . values ( ) [ VAR_4 . METHOD_1 ( 4 ) ] ; this . VAR_8 = TYPE_4 . values ( ) [ VAR_4 . METHOD_1 ( INT_1 ) ] ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . VAR_4 ) ; switch ( VAR_2 . getType ( ) ) { case VAR_5 : <START> VAR_6 : <END> VAR_7 : VAR_8 : METHOD_3 ( VAR_1 ) ; } } 
public TYPE_1 getType ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_1 ( METHOD_2 ( ) ) ; <START> return ( VAR_1 == null ? TYPE_1 . VAR_2 : VAR_1 ) ; <END> } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 type = TYPE_3 . instance ( ) . METHOD_2 ( getType ( ) ) ; if ( type == null ) { return 0 ; } <START> return ( type . VAR_2 ( this , VAR_1 , false ) <END> ? METHOD_3 ( ) . METHOD_4 ( ) . METHOD_1 ( this ) : 0 ) ; } 
public void METHOD_1 ( ) { <START> METHOD_1 ( true ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { List < TYPE_2 > VAR_3 = null ; try { VAR_3 = VAR_1 . METHOD_2 ( ) ; } catch ( IOException e ) { logger . log ( Level . VAR_4 , STRING_1 + VAR_1 , e ) ; return false ; } for ( TYPE_2 VAR_5 : VAR_3 ) { <START> if ( VAR_5 . METHOD_3 ( ) != null && VAR_5 . METHOD_3 ( ) . contains ( VAR_2 ) ) { <END> return true ; } } return false ; } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> TYPE_1 VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) . get ( 0 ) ; <END> VAR_1 = VAR_2 . getId ( ) ; METHOD_2 ( ) . METHOD_4 ( ) ; return VAR_2 ; } return METHOD_2 ( ) . METHOD_5 ( VAR_1 ) ; } 
public String METHOD_1 ( TYPE_1 < ? , ? > build , TYPE_2 listener ) { <START> return STRING_1 + <END> METHOD_2 ( build ) + STRING_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 ) ; if ( VAR_2 . METHOD_3 ( ) ) { logger . log ( Level . VAR_3 , STRING_1 ) ; return ; } try { METHOD_4 ( false ) ; } catch ( IOException e ) { logger . log ( Level . VAR_4 , STRING_2 , e ) ; return ; } METHOD_5 ( VAR_5 , VAR_5 . METHOD_6 ( ) ) ; <START> METHOD_7 ( VAR_5 ) ; <END> METHOD_8 ( ) ; } 
public boolean METHOD_1 ( TYPE_1 path ) { String VAR_1 = path . VAR_2 ( 1 ) ; if ( ! VAR_1 . equals ( STRING_1 ) <START> && METHOD_2 ( VAR_1 , VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ) ) { <END> return false ; } if ( ! METHOD_5 ( path , location ) ) { return false ; } return super . METHOD_1 ( path ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == null ) return ; <END> VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( ) ; } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return null ; } <START> TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( ) ; <END> if ( VAR_1 . startsWith ( STRING_1 ) ) { return new TYPE_4 ( VAR_2 . METHOD_3 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) ) ) . METHOD_1 ( VAR_1 . METHOD_6 ( 1 ) ) ; } return null ; } 
<START> protected TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> TYPE_1 < TYPE_2 > t = new TYPE_1 < > ( TYPE_3 . METHOD_2 ( TYPE_2 : : METHOD_3 ) ) ; for ( TYPE_4 type : VAR_1 ) { try { t . add ( TYPE_2 . get ( type ) ) ; } catch ( TYPE_5 ex ) { throw new TYPE_6 ( ex ) ; } } return t ; } 
public boolean METHOD_1 ( String key , TYPE_1 value , TYPE_2 event ) { if ( event instanceof TYPE_3 ) { if ( key . equalsIgnoreCase ( STRING_1 ) ) { TYPE_4 VAR_1 = TYPE_5 . METHOD_2 ( ) . METHOD_3 ( value , TYPE_7 . VAR_3 ) ; TYPE_6 VAR_4 = new TYPE_6 ( VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_6 ( ) ) ; <START> ( ( TYPE_3 ) event ) . METHOD_7 ( VAR_4 ) ; <END> return true ; } } return false ; } 
public void METHOD_1 ( Boolean VAR_1 ) { <START> if ( TYPE_1 . METHOD_2 ( e . getClass ( ) , STRING_1 , null ) ) { <END> e . VAR_2 ( VAR_1 ) ; } } 
public TYPE_1 [ ] METHOD_1 ( ) throws TYPE_2 { return new TYPE_1 [ ] { new TYPE_1 ( STRING_1 , STRING_2 ) , <START> new TYPE_1 ( "" , STRING_3 ) , } ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 t , TYPE_3 VAR_1 , TYPE_1 ... args ) throws TYPE_4 { TYPE_5 e = TYPE_6 . METHOD_2 ( args [ 0 ] , t ) ; boolean VAR_2 = TYPE_6 . METHOD_3 ( args [ 1 ] ) ; if ( e . VAR_3 ( ) ) { <START> throw new TYPE_7 ( STRING_1 , t ) ; <END> } e . VAR_4 ( VAR_2 ) ; return TYPE_8 . VAR_6 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 target , TYPE_3 VAR_1 , TYPE_1 ... args ) throws TYPE_4 { TYPE_5 VAR_2 = VAR_1 . METHOD_2 ( TYPE_6 . class ) . METHOD_3 ( ) ; TYPE_7 VAR_3 = null ; if ( VAR_2 != null ) { VAR_3 = VAR_2 . METHOD_4 ( ) ; } TYPE_8 VAR_4 = TYPE_9 . METHOD_5 ( ) . location ( args [ 0 ] , VAR_3 , target ) ; double VAR_5 ; VAR_5 = VAR_4 . METHOD_6 ( ) . METHOD_7 ( ) ; <START> return new TYPE_10 ( VAR_5 , target ) ; <END> } 
public Boolean METHOD_1 ( ) { <START> return true ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 t , TYPE_3 VAR_1 , TYPE_1 ... args ) throws TYPE_4 { <START> if ( args . length < 1 ) { <END> throw new TYPE_4 ( STRING_1 , TYPE_7 . TYPE_8 , t ) ; } long val = TYPE_5 . getInt ( args [ 0 ] , t ) ; for ( int i = 1 ; i < args . length ; i ++ ) { val = val ^ TYPE_5 . getInt ( args [ i ] , t ) ; } return new TYPE_6 ( val , t ) ; } 
<START> TYPE_1 ( String VAR_2 ) { <END> this . VAR_3 = VAR_2 ; } 
public void METHOD_1 ( int VAR_1 ) { if ( VAR_1 == TYPE_2 . VAR_3 ) { <START> VAR_4 = true ; <END> } if ( VAR_1 >= VAR_5 . content . TYPE_2 . VAR_6 ) { TYPE_1 . METHOD_2 ( ) ; } } 
static TYPE_1 METHOD_1 ( String text , List < Pair < Integer , Integer > > VAR_1 , Context context ) { TYPE_2 VAR_2 = new TYPE_2 ( text ) ; int VAR_3 = TYPE_3 . METHOD_2 ( context ) ; for ( Pair < Integer , Integer > position : VAR_1 ) { VAR_2 . METHOD_3 ( <START> new TYPE_4 ( VAR_3 ) , <END> position . VAR_4 , position . VAR_5 , TYPE_5 . VAR_7 ) ; } return VAR_2 ; } 
public static int METHOD_1 ( Context context ) { if ( VAR_1 == - 1 ) { String VAR_2 = TYPE_1 . METHOD_2 ( context ) . getString ( STRING_1 , VAR_3 ) ; if ( VAR_2 . equals ( STRING_2 ) || VAR_2 . equals ( ( STRING_3 ) ) ) { <START> return INT_1 ; <END> } VAR_1 = TYPE_2 . METHOD_3 ( VAR_2 ) ; } return VAR_1 ; } 
public void METHOD_1 ( String VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( VAR_1 != null ) { <END> this . VAR_1 = this . VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; Pair < String , int [ ] > VAR_2 = TYPE_1 . METHOD_3 ( this . VAR_1 ) ; this . VAR_3 = VAR_2 . VAR_4 ; this . VAR_5 = VAR_2 . VAR_6 ; } } 
public int METHOD_1 ( int position ) { if ( this . VAR_1 != null ) { if ( position < this . VAR_1 . length ) { return this . VAR_1 [ position ] ; <START> } else { <END> return this . VAR_2 . length ( ) ; } } else { if ( position < this . VAR_2 . length ( ) ) { return position ; } else { return this . VAR_2 . length ( ) ; } } } 
private void METHOD_1 ( ) { <START> View view = METHOD_2 ( ) ; if ( view != null ) { <END> String VAR_1 = VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) . toString ( ) ; METHOD_5 ( ) . METHOD_6 ( ! VAR_1 . trim ( ) . isEmpty ( ) ) ; } } 
private void METHOD_1 ( ) { switch ( METHOD_2 ( ) ) { case VAR_1 : case VAR_2 : case VAR_3 : <START> case VAR_4 : <END> VAR_5 . METHOD_3 ( TYPE_1 . VAR_7 ) ; METHOD_4 ( ) ; return ; case VAR_8 : METHOD_5 ( false ) ; break ; } } 
protected void next ( String VAR_1 ) { if ( ! TYPE_1 . METHOD_1 ( METHOD_2 ( ) ) ) { return ; } if ( METHOD_3 ( VAR_1 ) ) { METHOD_4 ( ) ; METHOD_5 ( ) ; VAR_2 = VAR_1 ; VAR_3 . METHOD_6 ( TYPE_2 . METHOD_7 ( VAR_1 ) ) ; <START> VAR_4 . METHOD_8 ( ) ; <END> } else { METHOD_9 ( R . string . VAR_5 ) ; } } 
public TYPE_1 METHOD_1 ( ) { while ( ! METHOD_2 ( VAR_1 ) ) { METHOD_3 ( R . id . VAR_2 ) ; <START> METHOD_3 ( METHOD_4 ( METHOD_5 ( METHOD_6 ( R . id . VAR_3 ) , METHOD_7 ( TYPE_2 . VAR_5 ) ) ) ) ; <END> } if ( ! METHOD_8 ( ) ) { VAR_6 . METHOD_9 ( METHOD_10 ( METHOD_11 ( ) ) ) ; } return this ; } 
public static boolean METHOD_1 ( String VAR_1 ) { <START> Date VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <END> Date VAR_3 = new Date ( ) ; return VAR_2 != null && VAR_2 . METHOD_3 ( VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_1 . METHOD_2 ( VAR_2 , VAR_3 . name ( ) ) ; VAR_1 . METHOD_3 ( VAR_4 , VAR_5 ) ; <START> VAR_1 . METHOD_3 ( VAR_4 , VAR_5 ) ; <END> } 
<START> @Override public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> super . METHOD_1 ( VAR_1 ) ; TYPE_1 args = METHOD_2 ( ) ; if ( args != null ) { VAR_2 = args . VAR_3 ( VAR_4 , false ) ; } } 
public void METHOD_1 ( Context context ) { if ( context == null ) { return ; } <START> <END> VAR_1 = TYPE_1 . METHOD_2 ( context , R . VAR_2 . VAR_3 ) ; VAR_4 = TYPE_1 . METHOD_2 ( context , R . VAR_2 . VAR_5 ) ; VAR_6 = TYPE_1 . METHOD_2 ( context , R . VAR_2 . VAR_7 ) ; VAR_8 = TYPE_1 . METHOD_2 ( context , R . VAR_2 . VAR_9 ) ; VAR_10 = context . VAR_11 ( ) . METHOD_3 ( R . VAR_12 . VAR_13 ) * 2 ; } 
public void METHOD_1 ( long VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 == null ) { return ; } VAR_2 . update ( VAR_3 - > { VAR_3 . METHOD_3 ( VAR_1 ) ; METHOD_4 ( ) ; <START> if ( VAR_1 != 0 ) { <END> VAR_4 . METHOD_5 ( TYPE_4 . TYPE_3 . VAR_7 , VAR_3 , TYPE_2 . VAR_9 ) ; } return true ; } ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { METHOD_3 ( VAR_2 ) ; <START> } else if ( TYPE_1 . METHOD_4 ( ) ) { <END> TYPE_2 . METHOD_5 ( this ) ; } METHOD_6 ( ) ; } 
private static String METHOD_1 ( TYPE_1 builder , TYPE_2 parser ) { METHOD_2 ( builder ) ; parser . VAR_1 ( builder ) ; TYPE_3 . METHOD_3 ( builder , true ) ; <START> return TYPE_4 . METHOD_4 ( parser . VAR_2 ( builder , false , false ) ) ; <END> } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; TYPE_1 VAR_1 = METHOD_3 ( ) ; if ( VAR_1 != null ) { <START> TYPE_2 . METHOD_4 ( METHOD_5 ( ) , R . string . VAR_2 ) ; <END> TYPE_3 . METHOD_6 ( METHOD_7 ( ) , VAR_1 ) ; } } 
<START> ANNOTATION_1 @Override public String METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> @Override public void METHOD_1 ( <END> String VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 , int VAR_6 ) { } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , String [ ] VAR_2 , String [ ] VAR_3 ) { boolean VAR_4 = false ; if ( VAR_1 != null && VAR_2 . length == VAR_3 . length ) { for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { String VAR_5 = VAR_3 [ i ] ; boolean VAR_6 = TYPE_2 . METHOD_2 ( VAR_1 , VAR_5 , true ) ; if ( VAR_6 ) { <START> VAR_4 = true ; <END> } } } return VAR_4 ; } 
public static void METHOD_1 ( int VAR_1 , int VAR_2 ) { if ( VAR_1 == 0 || VAR_2 == 0 || METHOD_2 ( VAR_1 , VAR_2 ) ) { return ; } String key = VAR_1 + STRING_1 + VAR_2 ; <START> List < String > VAR_3 = METHOD_3 ( ) ; <END> VAR_3 . add ( key ) ; String VAR_4 = TYPE_1 . METHOD_4 ( STRING_2 , VAR_3 ) ; METHOD_5 ( TYPE_2 . VAR_6 , VAR_4 ) ; } 
protected void METHOD_1 ( TYPE_1 result ) { switch ( result ) { case VAR_1 : VAR_2 . METHOD_2 ( VAR_3 ) ; VAR_2 . METHOD_3 ( VAR_3 , VAR_4 , VAR_5 , 0 ) ; METHOD_4 ( ) ; break ; <START> case VAR_6 : <END> VAR_2 . METHOD_2 ( VAR_3 ) ; METHOD_4 ( ) ; break ; case VAR_7 : break ; } } 
private void METHOD_1 ( ) { switch ( METHOD_2 ( ) ) { case VAR_1 : METHOD_3 ( ) ; return ; case VAR_2 : METHOD_4 ( ) ; return ; case VAR_3 : <START> METHOD_5 ( false ) ; <END> return ; case VAR_4 : case VAR_5 : METHOD_5 ( false ) ; break ; } } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; VAR_3 . METHOD_5 ( VAR_4 - > { METHOD_6 ( ) ; <START> return false ; <END> } ) ; } 
public void METHOD_1 ( ) { <START> TYPE_4 . TYPE_5 . VAR_1 . TYPE_3 VAR_3 = METHOD_2 ( ) <END> . METHOD_3 ( TYPE_2 . VAR_4 ) ; if ( VAR_3 != null && VAR_3 . METHOD_4 ( ) ) { ( ( TYPE_2 ) VAR_3 ) . METHOD_5 ( ) ; } else { super . METHOD_1 ( ) ; } } 
public void start ( ArrayList < Object > VAR_1 ) { if ( ! VAR_2 ) { Map < String , Object > properties = METHOD_1 ( ) ; <START> VAR_3 = VAR_1 != null && VAR_1 . size ( ) > 0 ; <END> properties . put ( VAR_4 , VAR_1 != null ? VAR_1 : new ArrayList < > ( ) ) ; TYPE_1 . METHOD_2 ( TYPE_3 . VAR_6 , properties ) ; VAR_2 = true ; } else { TYPE_2 . METHOD_3 ( T . VAR_7 , STRING_1 + STRING_2 ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( get ( METHOD_4 ( STRING_1 ) ) . METHOD_5 ( STRING_2 ) <START> . METHOD_6 ( TYPE_1 . VAR_2 ) ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( get ( METHOD_3 ( STRING_1 ) ) . METHOD_4 ( STRING_2 ) <START> . METHOD_5 ( STRING_3 ) ) ; <END> VAR_1 = ( TYPE_1 ) TYPE_2 . METHOD_6 ( ) . METHOD_7 ( ) . METHOD_8 ( ) ; VAR_2 = TYPE_3 . builder ( ) . METHOD_9 ( VAR_1 ) . build ( ) ; } 
private void METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( this ) ; <START> VAR_1 . METHOD_2 ( false ) ; <END> VAR_1 . METHOD_3 ( true ) ; VAR_1 . METHOD_4 ( getString ( R . string . VAR_2 ) ) ; } if ( ! VAR_1 . METHOD_5 ( ) ) { VAR_1 . METHOD_6 ( ) ; } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 != null && VAR_1 != null ) { <START> VAR_3 . METHOD_2 ( View . VAR_4 ) ; <END> VAR_5 . METHOD_2 ( View . VAR_6 ) ; VAR_5 . METHOD_3 ( STRING_1 , VAR_1 . toString ( ) , STRING_2 , STRING_3 , null ) ; } VAR_7 = null ; } 
public void METHOD_1 ( boolean VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( TYPE_1 . METHOD_3 ( ) , VAR_3 ) . isEmpty ( ) ) { <START> return ; <END> } METHOD_4 ( ! VAR_1 ) ; } 
private static TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { parser = new TYPE_3 ( TYPE_4 . getInstance ( ) ) ; TYPE_1 VAR_2 = parser . VAR_3 ( VAR_1 ) ; TYPE_5 . METHOD_2 ( VAR_2 ) ; TYPE_6 VAR_4 = TYPE_6 . getInstance ( VAR_2 . METHOD_3 ( ) ) ; <START> VAR_4 . METHOD_4 ( VAR_2 ) ; <END> TYPE_5 . METHOD_5 ( VAR_2 ) ; TYPE_7 . METHOD_6 ( ) . apply ( VAR_2 ) ; return VAR_2 ; } 
<START> public void close ( ) { <END> input . close ( ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) ; <END> int count = new TYPE_3 ( ) . METHOD_3 ( VAR_1 ) ; Assert . assertEquals ( 10 , count ) ; } 
private TYPE_1 METHOD_1 ( final TYPE_2 < ? , ? > job ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> for ( TYPE_3 VAR_2 : TYPE_3 . METHOD_2 ( ) ) { try { VAR_2 . METHOD_3 ( job , VAR_1 , TYPE_4 . VAR_4 ) ; } catch ( Exception e ) { LOGGER . VAR_5 ( STRING_1 ) ; } } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 , final ArrayList < TYPE_2 > VAR_2 ) { <START> for ( TYPE_2 p : VAR_2 ) { <END> VAR_1 . METHOD_2 ( p . getName ( ) , String . valueOf ( p . getValue ( ) ) ) ; } return VAR_1 ; } 
private String METHOD_1 ( final TYPE_1 run ) { final TYPE_3 . TYPE_4 VAR_1 = ( TYPE_3 . TYPE_4 ) run . VAR_2 ( TYPE_3 . TYPE_4 . class ) ; <START> final String VAR_3 ; <END> if ( VAR_1 != null ) { VAR_3 = VAR_1 . METHOD_2 ( ) ; } else { VAR_3 = null ; } return VAR_3 == null ? "" : VAR_3 ; } 
TYPE_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 instanceof TYPE_1 ) { this . VAR_2 = ( ( TYPE_1 ) VAR_1 ) . VAR_2 ; } else { <START> this . VAR_2 = VAR_1 ; <END> } } 
private void METHOD_1 ( TYPE_1 out ) { if ( out . VAR_1 ( ) ) { try { int VAR_2 ; do { <START> VAR_2 = ( Integer ) TYPE_2 . METHOD_2 ( VAR_3 , out . VAR_4 ( ) , <END> TYPE_6 . VAR_6 ) ; } while ( VAR_2 > 0 ) ; } catch ( TYPE_3 e ) { throw new TYPE_4 ( e ) ; } catch ( TYPE_5 e ) { throw new TYPE_4 ( e ) ; } } else { METHOD_3 ( out ) ; } } 
<START> public static TYPE_1 . Builder METHOD_1 ( ) { <END> return new TYPE_1 . Builder ( ) ; } 
private static void METHOD_1 ( List < TYPE_1 > VAR_1 , TYPE_2 out ) { <START> for ( TYPE_1 VAR_2 : VAR_1 ) { <END> METHOD_2 ( VAR_2 , out ) ; } } 
public String toString ( ) { <START> return new StringBuilder ( INT_1 ) <END> . append ( TYPE_1 . METHOD_1 ( this ) ) . append ( STRING_1 ) . append ( type ( ) ) . append ( STRING_2 ) . append ( METHOD_2 ( ) ) . append ( STRING_3 ) . append ( client ( ) ) . append ( STRING_4 ) . append ( METHOD_3 ( ) ) . append ( STRING_5 ) . append ( VAR_1 . size ( ) ) . append ( CHAR_1 ) . toString ( ) ; } 
protected void METHOD_1 ( TYPE_1 ctx , TYPE_2 msg , TYPE_3 out ) throws Exception { <START> if ( msg . VAR_1 ( ) == TYPE_5 . VAR_3 ) { <END> METHOD_2 ( msg , out ) ; } else if ( msg . VAR_1 ( ) == TYPE_5 . VAR_4 ) { METHOD_3 ( msg , out ) ; } else { throw new TYPE_4 ( STRING_1 + msg . VAR_1 ( ) ) ; } } 
protected void METHOD_1 ( TYPE_1 channel ) throws Exception { channel . VAR_1 ( ) . METHOD_2 ( new TYPE_2 ( ) ) . METHOD_2 ( new TYPE_3 ( INT_1 ) ) . METHOD_2 ( TYPE_6 . VAR_3 ) . METHOD_2 ( new TYPE_4 ( VAR_4 , TYPE_5 . VAR_6 ) ) <START> . METHOD_2 ( STRING_1 , VAR_7 ) ; <END> } 
public TYPE_1 map ( String VAR_1 ) { if ( VAR_1 != null ) { VAR_1 = METHOD_1 ( VAR_1 ) ; TYPE_1 value = map . get ( VAR_1 ) ; if ( value != null ) { return value ; } int VAR_2 = VAR_1 . METHOD_2 ( CHAR_1 ) ; if ( VAR_2 != - 1 ) { <START> value = map . get ( CHAR_2 + VAR_1 . substring ( VAR_2 ) ) ; <END> if ( value != null ) { return value ; } } } return VAR_3 ; } 
public static void METHOD_1 ( TYPE_1 < ? > p , Throwable VAR_1 , TYPE_2 logger ) { if ( ! p . VAR_2 ( VAR_1 ) && logger != null ) { Throwable err = p . VAR_1 ( ) ; if ( err == null ) { logger . warn ( STRING_1 , p , VAR_1 ) ; } else { <START> if ( logger . VAR_3 ( ) ) { <END> logger . warn ( STRING_2 , p , TYPE_3 . METHOD_2 ( err ) , VAR_1 ) ; } } } } 
private void METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 ) { if ( VAR_4 . METHOD_2 ( true , VAR_1 , TYPE_2 . VAR_6 , 0 , INT_1 ) ) { VAR_7 = true ; } else if ( VAR_4 . METHOD_2 ( true , VAR_1 , TYPE_2 . VAR_8 , 0 , INT_1 ) ) { String VAR_9 = METHOD_3 ( VAR_2 , VAR_3 ) ; try { VAR_10 = TYPE_1 . of ( VAR_9 ) ; <START> } catch ( IllegalArgumentException e ) { <END> logger . debug ( STRING_1 , VAR_9 ) ; } } } 
public void METHOD_1 ( TYPE_1 ctx ) throws Exception { <START> if ( VAR_1 . equals ( "" ) ) { <END> VAR_1 = String . valueOf ( ctx . channel ( ) . METHOD_2 ( ) ) ; } else { VAR_1 += STRING_1 + ctx . channel ( ) . METHOD_2 ( ) ; } super . METHOD_1 ( ctx ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , boolean VAR_4 ) { if ( TYPE_4 . METHOD_2 ( ) ) { return VAR_4 ? ( TYPE_1 ) ( Object ) TYPE_4 . METHOD_3 ( VAR_1 , VAR_3 ) : ( TYPE_1 ) ( Object ) TYPE_4 . METHOD_4 ( VAR_1 , VAR_3 ) ; } <START> throw new RuntimeException ( STRING_1 + VAR_1 . getClass ( ) . getName ( ) ) ; <END> } 
<START> public TYPE_1 < TYPE_5 . TYPE_6 < Object , TYPE_3 > > METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_4 < TYPE_5 . TYPE_6 < Object , TYPE_3 > > ( ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( Object msg , TYPE_2 VAR_1 ) { if ( METHOD_2 ( true ) ) { if ( ! config ( ) . METHOD_3 ( ) ) { TYPE_3 < TYPE_5 . TYPE_6 < Object , TYPE_2 > > VAR_2 = METHOD_4 ( ) ; <START> if ( VAR_2 != null ) { <END> VAR_2 . add ( new TYPE_5 . TYPE_6 < Object , TYPE_2 > ( msg , VAR_1 ) ) ; } return VAR_1 ; } else { METHOD_5 ( ) . METHOD_6 ( msg ) ; } } return METHOD_7 ( VAR_1 ) ; } 
private void METHOD_1 ( TYPE_1 s ) { for ( int i = 0 , VAR_1 = s . length ( ) ; i < VAR_1 ; i ++ ) { char c = s . VAR_2 ( i ) ; if ( ! METHOD_2 ( c ) ) { <START> if ( i > 0 ) { <END> VAR_3 . append ( s , 0 , i ) ; } METHOD_3 ( s , i ) ; return ; } } VAR_3 . append ( s ) ; } 
final int METHOD_1 ( ) { int VAR_1 = 0 ; for ( ; ; ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) ; if ( VAR_2 == null ) { break ; } <START> if ( TYPE_2 . VAR_5 != VAR_2 ) { <END> VAR_1 ++ ; } } return VAR_1 ; } 
public TYPE_3 ( TYPE_1 buffer ) { TYPE_2 . METHOD_1 ( buffer , STRING_1 ) ; <START> this . buffer = buffer ; <END> VAR_2 = buffer . VAR_3 ( ) ; } 
private TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { TYPE_3 . METHOD_1 ( VAR_2 , STRING_1 ) ; <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; VAR_4 = TYPE_4 . METHOD_2 ( this ) + ( VAR_3 == TYPE_2 . VAR_5 ? STRING_2 : STRING_3 ) ; } 
public TYPE_3 ( TYPE_1 buf ) { TYPE_2 . METHOD_1 ( buf , STRING_1 ) ; <START> this . buf = buf ; <END> if ( buf . VAR_2 ( ) == TYPE_4 . VAR_4 ) { VAR_2 = TYPE_4 . VAR_5 ; } else { VAR_2 = TYPE_4 . VAR_4 ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> if ( VAR_1 == VAR_2 ) { <END> return this ; } return buf ; } 
protected TYPE_3 ( TYPE_1 VAR_2 ) { TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
public TYPE_3 ( TYPE_1 content ) { TYPE_2 . METHOD_1 ( content , STRING_1 ) ; <START> this . content = content ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 version ) { TYPE_3 . METHOD_2 ( version , STRING_1 ) ; <START> this . version = version ; <END> return this ; } 
public TYPE_1 METHOD_1 ( TYPE_2 status ) { TYPE_3 . METHOD_2 ( status , STRING_1 ) ; <START> this . status = status ; <END> return this ; } 
public void METHOD_1 ( String VAR_1 ) { TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> this . VAR_1 = VAR_1 ; <END> } 
private TYPE_3 ( TYPE_1 VAR_2 , boolean VAR_3 , int VAR_4 , int VAR_5 ) { super ( TYPE_4 . VAR_7 ) ; if ( VAR_4 < 1 ) { throw new IllegalArgumentException ( STRING_1 + VAR_4 + STRING_2 ) ; } <START> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 , STRING_3 ) ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_8 = METHOD_2 ( VAR_5 , VAR_4 ) ; } 
public static void METHOD_1 ( Thread VAR_1 , TYPE_1 task ) { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; if ( ! VAR_1 . METHOD_3 ( ) ) { throw new IllegalArgumentException ( STRING_2 ) ; } <START> METHOD_4 ( VAR_1 , TYPE_2 . METHOD_2 ( task , STRING_3 ) , true ) ; <END> } 
public boolean METHOD_1 ( long VAR_1 , TimeUnit VAR_2 ) throws InterruptedException { final Thread VAR_3 = this . VAR_3 ; if ( VAR_3 == null ) { throw new IllegalStateException ( STRING_1 ) ; } <START> VAR_3 . METHOD_2 ( TYPE_1 . METHOD_3 ( VAR_2 , STRING_2 ) . METHOD_4 ( VAR_1 ) ) ; <END> return ! VAR_3 . METHOD_5 ( ) ; } 
public boolean METHOD_1 ( long VAR_1 , TimeUnit VAR_2 ) throws InterruptedException { if ( METHOD_2 ( ) ) { throw new IllegalStateException ( STRING_1 ) ; } <START> VAR_3 . METHOD_3 ( VAR_1 , TYPE_1 . METHOD_4 ( VAR_2 , STRING_2 ) ) ; <END> return METHOD_5 ( ) ; } 
public TYPE_3 ( TYPE_1 file , long offset , long length , int VAR_2 ) throws IOException { TYPE_2 . METHOD_1 ( offset , STRING_1 ) ; TYPE_2 . METHOD_1 ( length , STRING_2 ) ; <START> this . file = TYPE_2 . METHOD_2 ( file , STRING_3 ) ; <END> this . VAR_2 = TYPE_2 . METHOD_3 ( VAR_2 , STRING_4 ) ; this . offset = VAR_3 = offset ; VAR_4 = offset + length ; file . VAR_5 ( offset ) ; } 
public boolean clear ( String VAR_1 ) { return VAR_2 . clear ( METHOD_1 ( <START> METHOD_2 ( VAR_1 , STRING_1 ) ) ) ; <END> } 
public TYPE_5 ( TYPE_1 message , TYPE_2 VAR_2 , TYPE_2 VAR_3 ) { if ( VAR_2 == null && VAR_3 == null ) { throw new TYPE_3 ( STRING_1 ) ; } <START> this . message = TYPE_4 . METHOD_1 ( message , STRING_2 ) ; <END> this . VAR_3 = VAR_3 ; this . VAR_2 = VAR_2 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { VAR_2 = null ; try { this . VAR_3 = new TYPE_3 ( VAR_1 ) ; } catch ( Exception e ) { <START> throw new TYPE_4 ( e . toString ( ) ) ; <END> } return this ; } 
protected TYPE_1 [ ] METHOD_1 ( ) { <START> TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; <END> return new TYPE_1 [ ] { VAR_1 } ; } 
TYPE_3 ( TYPE_1 VAR_2 ) { TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
TYPE_3 ( TYPE_1 VAR_2 ) throws Exception { TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
<START> TYPE_1 METHOD_1 ( Thread VAR_1 ) { <END> return TYPE_1 . METHOD_2 ( this , VAR_1 ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( this . VAR_1 != VAR_1 ) { <END> METHOD_2 ( VAR_2 ) ; } this . VAR_1 = VAR_1 ; } 
public TYPE_4 ( TYPE_1 VAR_2 ) { if ( VAR_2 == null ) { throw new TYPE_2 ( STRING_1 ) ; } <START> this . VAR_3 = TYPE_3 . METHOD_1 ( VAR_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 request , String name ) { <START> TYPE_1 VAR_1 ; <END> if ( VAR_2 ) { VAR_1 = new TYPE_3 ( name , VAR_3 ) ; } else if ( VAR_4 ) { VAR_1 = new TYPE_4 ( name , VAR_5 , VAR_3 ) ; } else { VAR_1 = new TYPE_5 ( name ) ; } VAR_1 . METHOD_2 ( VAR_6 ) ; List < TYPE_6 > list = METHOD_3 ( request ) ; list . add ( VAR_1 ) ; return VAR_1 ; } 
protected final boolean METHOD_1 ( TYPE_1 result ) { boolean VAR_1 = super . METHOD_2 ( result ) ; <START> return METHOD_3 ( VAR_1 , VAR_2 ) ; <END> } 
public boolean METHOD_1 ( boolean VAR_1 ) { boolean VAR_2 = super . METHOD_1 ( VAR_1 ) ; <START> return METHOD_2 ( VAR_2 , VAR_3 ) ; <END> } 
protected final boolean METHOD_1 ( Throwable VAR_1 ) { boolean VAR_2 = super . METHOD_2 ( VAR_1 ) ; <START> return METHOD_3 ( VAR_2 , VAR_3 ) ; <END> } 
<START> private boolean METHOD_1 ( char VAR_1 ) { <END> return VAR_1 >= CHAR_1 && VAR_1 <= CHAR_2 || VAR_1 >= CHAR_3 && VAR_1 <= CHAR_4 || VAR_1 >= CHAR_5 && VAR_1 <= CHAR_6 || VAR_1 == CHAR_7 || VAR_1 == CHAR_8 || VAR_1 == CHAR_9 || VAR_1 == CHAR_10 ; } 
void add ( TYPE_1 buffer , boolean VAR_1 ) throws Exception { VAR_2 . VAR_1 = VAR_1 ; try { buffer . VAR_3 ( VAR_2 ) ; } finally { VAR_2 . VAR_1 = false ; <START> } <END> } 
public void METHOD_1 ( ) throws InterruptedException , TYPE_1 , TYPE_2 { final TYPE_3 < TYPE_4 > VAR_1 = new TYPE_5 < TYPE_4 > ( TYPE_7 . VAR_3 ) ; <START> VAR_1 . METHOD_2 ( false ) ; <END> assertThat ( VAR_1 . METHOD_3 ( ) , METHOD_4 ( TYPE_6 . class ) ) ; } 
TYPE_1 METHOD_1 ( ) { <START> return ( VAR_1 == VAR_2 ? VAR_2 : VAR_2 . METHOD_2 ( ) ) . METHOD_1 ( ) ; <END> } 
TYPE_1 METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 : ( VAR_1 = VAR_2 . METHOD_1 ( METHOD_2 ( offset ) , length ( ) ) ) ; <END> } 
protected final TYPE_1 METHOD_1 ( long VAR_1 ) { assert METHOD_2 ( ) ; TYPE_2 < TYPE_3 < ? > > VAR_2 = this . VAR_2 ; TYPE_3 < ? > VAR_3 = VAR_2 == null ? null : VAR_2 . METHOD_3 ( ) ; <START> if ( VAR_3 == null || VAR_3 . METHOD_4 ( ) > VAR_1 ) { <END> return null ; } VAR_2 . remove ( ) ; return VAR_3 ; } 
private boolean METHOD_1 ( ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return true ; } long VAR_2 = TYPE_1 . METHOD_2 ( ) ; <START> for ( TYPE_2 VAR_3 ; ( VAR_3 = METHOD_3 ( VAR_2 ) ) != null ; ) { <END> if ( ! VAR_4 . METHOD_4 ( VAR_3 ) ) { VAR_1 . add ( ( TYPE_3 < ? > ) VAR_3 ) ; return false ; } } return true ; } 
public static Set < String > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
void METHOD_1 ( TYPE_1 VAR_1 ) { assert METHOD_2 ( ) . METHOD_3 ( ) ; if ( ! METHOD_4 ( ) ) { TYPE_2 . METHOD_5 ( VAR_1 ) ; } else { final TYPE_4 . TYPE_5 VAR_2 = VAR_3 . METHOD_6 ( ) ; VAR_4 += VAR_3 . METHOD_7 ( VAR_1 , VAR_2 ) ; if ( VAR_2 . METHOD_8 ( ) ) { if ( ! VAR_5 ) { VAR_5 = true ; METHOD_9 ( ) ; } } else { <START> VAR_3 . METHOD_10 ( VAR_2 , true ) ; <END> } } } 
public void METHOD_1 ( TYPE_1 ctx , Object VAR_1 ) throws Exception { System . out . println ( STRING_1 ) ; if ( VAR_1 instanceof TYPE_2 && TYPE_3 . VAR_3 == ( ( TYPE_2 ) VAR_1 ) . state ( ) ) { <START> ctx . channel ( ) . close ( ) ; <END> } } 
<START> public static void METHOD_1 ( String name , TYPE_1 buf ) { <END> if ( TYPE_2 . equals ( name ) ) { buf . VAR_1 ( 0 ) ; return ; } final String [ ] VAR_2 = name . split ( STRING_1 ) ; for ( String VAR_3 : VAR_2 ) { final int VAR_4 = VAR_3 . length ( ) ; if ( VAR_4 == 0 ) { break ; } buf . VAR_1 ( VAR_4 ) ; TYPE_3 . METHOD_2 ( buf , VAR_3 ) ; } buf . VAR_1 ( 0 ) ; } 
public int METHOD_1 ( ) { int size = VAR_1 ; if ( size != - 1 ) { <START> return size ; <END> } size = 0 ; for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { size += VAR_3 . VAR_4 . VAR_5 . TYPE_1 . METHOD_2 ( 1 , VAR_2 . get ( i ) ) ; } size += METHOD_3 ( ) . METHOD_1 ( ) ; VAR_1 = size ; return size ; } 
public final boolean METHOD_1 ( ) { byte VAR_1 = VAR_2 ; if ( VAR_1 != - 1 ) { <START> return VAR_1 == 1 ; <END> } for ( int i = 0 ; i < METHOD_2 ( ) ; i ++ ) { if ( ! METHOD_3 ( i ) . METHOD_1 ( ) ) { VAR_2 = 0 ; return false ; } } VAR_2 = 1 ; return true ; } 
<START> private TYPE_1 ( int VAR_2 ) { <END> super ( VAR_2 ) ; } 
protected void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { VAR_1 . METHOD_2 ( ) ; } <START> final TYPE_2 < TYPE_3 > VAR_3 = this . VAR_3 ; <END> if ( VAR_3 != null ) { boolean VAR_4 = VAR_3 . close ( this ) ; assert VAR_4 ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 buf , int VAR_3 , int VAR_4 ) { VAR_1 . METHOD_2 ( ) ; VAR_2 . METHOD_2 ( ) ; VAR_1 . update ( VAR_5 , VAR_3 , VAR_4 ) ; VAR_2 . update ( buf , VAR_3 , VAR_4 ) ; <START> assertEquals ( VAR_1 . getValue ( ) , VAR_2 . getValue ( ) ) ; <END> } 
public static void METHOD_1 ( ByteBuffer buffer ) { TYPE_1 VAR_1 = TYPE_3 . VAR_3 ; <START> if ( ! VAR_4 || VAR_1 == null ) { <END> TYPE_2 . METHOD_1 ( buffer ) ; } else { VAR_1 . METHOD_2 ( buffer ) ; } } 
void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { TYPE_3 VAR_3 = METHOD_2 ( VAR_1 , VAR_2 == TYPE_2 . TYPE_5 ) ; <START> if ( VAR_3 . equals ( VAR_2 == TYPE_2 . TYPE_6 ? VAR_6 : VAR_7 ) ) { <END> throw new IOException ( STRING_1 + VAR_2 ) ; } final TYPE_4 VAR_8 = TYPE_4 . METHOD_3 ( VAR_3 ) ; METHOD_4 ( METHOD_5 ( ) , VAR_9 , VAR_8 . METHOD_6 ( ) , VAR_8 . METHOD_7 ( ) , METHOD_8 ( VAR_1 ) ) ; } 
public TYPE_1 bind ( TYPE_2 VAR_1 ) { METHOD_1 ( ) ; TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> return METHOD_3 ( VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> this . VAR_1 = VAR_1 ; <END> return METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> this . VAR_1 = VAR_1 ; <END> return this ; } 
TYPE_4 ( TYPE_1 exception , TYPE_2 VAR_2 ) { super ( exception . getMessage ( ) + STRING_1 + VAR_2 ) ; METHOD_1 ( exception ) ; <START> METHOD_2 ( TYPE_3 . VAR_4 ) ; <END> } 
TYPE_3 ( TYPE_1 exception , TYPE_2 VAR_2 ) { super ( exception . getMessage ( ) + STRING_1 + VAR_2 ) ; METHOD_1 ( exception ) ; <START> METHOD_2 ( TYPE_4 . VAR_4 ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> while ( true ) { <END> TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( VAR_3 == null ) { return ; } VAR_2 . METHOD_3 ( VAR_3 ) ; } } 
public String toString ( ) { <START> return METHOD_1 ( ) + STRING_1 + METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 < TYPE_2 , TYPE_3 > entry ) { int i = index ( entry . VAR_1 ) ; TYPE_1 < TYPE_2 , TYPE_3 > e = VAR_2 [ i ] ; if ( e == entry ) { VAR_2 [ i ] = entry . next ; } entry . remove ( ) ; <START> } <END> 
public TYPE_1 METHOD_1 ( ) { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 sb , TYPE_1 VAR_1 ) throws Throwable { <START> sb . VAR_2 ( TYPE_2 . VAR_4 , true ) ; <END> super . METHOD_1 ( sb , VAR_1 ) ; sb . VAR_2 ( TYPE_2 . VAR_4 , false ) ; } 
protected static TYPE_1 METHOD_1 ( <START> File VAR_1 , TYPE_1 VAR_2 , String VAR_3 ) <END> throws TYPE_2 , TYPE_3 , TYPE_4 , IOException { TYPE_5 [ ] VAR_4 = METHOD_2 ( VAR_1 ) ; return METHOD_1 ( VAR_4 , VAR_2 , VAR_3 ) ; } 
public TYPE_5 ( File VAR_2 , <START> TYPE_1 VAR_3 ) throws TYPE_2 { <END> this ( VAR_2 , VAR_3 , null , null , null , null , null , TYPE_4 . VAR_5 , null , 0 , 0 , TYPE_3 . METHOD_1 ( ) ) ; } 
TYPE_4 ( TYPE_1 VAR_2 , String name , TYPE_2 VAR_3 ) { this . name = METHOD_1 ( name , STRING_1 ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_4 = TYPE_3 . METHOD_2 ( VAR_3 . getClass ( ) ) ; <END> this . VAR_3 = VAR_3 ; } 
public TYPE_3 ( int VAR_2 , TYPE_1 VAR_3 ) { super ( VAR_2 , VAR_3 ) ; <START> this . METHOD_1 ( TYPE_2 . apply ( METHOD_2 ( ) , this ) ) ; <END> } 
public < T > T METHOD_1 ( TYPE_1 < T > VAR_1 ) { if ( VAR_1 == TYPE_2 . VAR_3 ) { return ( T ) METHOD_2 ( ) ; } <START> if ( VAR_1 == TYPE_2 . VAR_4 ) { <END> return ( T ) Boolean . valueOf ( METHOD_3 ( ) ) ; } return super . METHOD_1 ( VAR_1 ) ; } 
public Map < TYPE_1 < ? > , Object > METHOD_1 ( ) { <START> return METHOD_1 ( super . METHOD_1 ( ) , TYPE_2 . VAR_2 , TYPE_1 . VAR_3 ) ; <END> } 
public final void METHOD_1 ( TYPE_1 ctx ) throws Exception { if ( VAR_1 == VAR_2 ) { VAR_1 = VAR_3 ; return ; } TYPE_2 buf = VAR_4 ; if ( buf != null ) { VAR_4 = null ; int VAR_5 = buf . VAR_6 ( ) ; if ( VAR_5 > 0 ) { ctx . VAR_7 ( buf ) ; ctx . VAR_8 ( ) ; } else { buf . VAR_9 ( ) ; } } METHOD_2 ( ctx ) ; <START> VAR_1 = VAR_10 ; <END> } 
public static boolean METHOD_1 ( TYPE_1 message ) { boolean VAR_1 = message . VAR_2 ( ) . METHOD_2 ( TYPE_2 . VAR_4 , TYPE_3 . VAR_6 , true ) ; if ( VAR_1 ) { return false ; } if ( message . VAR_7 ( ) . METHOD_3 ( ) ) { <START> return ! VAR_1 ; <END> } else { return message . VAR_2 ( ) . METHOD_2 ( TYPE_2 . VAR_4 , TYPE_3 . VAR_8 , true ) ; } } 
protected void METHOD_1 ( TYPE_1 ctx , TYPE_2 VAR_1 , List < Object > out ) throws Exception { if ( VAR_1 instanceof TYPE_3 ) { VAR_2 = true ; <START> VAR_1 . METHOD_2 ( ) ; <END> return ; } super . METHOD_1 ( ctx , VAR_1 , out ) ; } 
public TYPE_1 METHOD_1 ( long VAR_1 ) { <START> this . VAR_1 = VAR_1 ; <END> return this ; } 
<START> private TYPE_2 ( int VAR_2 ) { <END> this . VAR_2 = VAR_2 ; METHOD_1 ( new TYPE_1 ( ) ) ; } 
private boolean METHOD_1 ( int VAR_1 ) { int VAR_2 = METHOD_2 ( ) , VAR_3 = METHOD_3 ( VAR_2 , VAR_1 ) ; if ( VAR_1 == VAR_3 ) { if ( VAR_4 . METHOD_4 ( this , VAR_2 , 1 ) ) { <START> METHOD_5 ( - METHOD_6 ( ) ) ; <END> METHOD_7 ( ) ; return true ; } return METHOD_8 ( VAR_1 ) ; } return METHOD_9 ( VAR_1 , VAR_2 , VAR_3 ) ; } 
public final void METHOD_1 ( ) { <START> METHOD_2 ( - METHOD_3 ( ) ) ; <END> VAR_1 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> String VAR_1 = STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 + STRING_7 ; METHOD_3 ( VAR_1 ) ; } 
TYPE_1 ( TYPE_2 VAR_1 ) { <START> super ( VAR_1 , VAR_1 . channel . METHOD_1 ( ) , VAR_2 , TYPE_1 . class ) ; <END> VAR_3 = VAR_1 . channel ( ) . METHOD_2 ( ) ; METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { synchronized ( VAR_1 ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> return null ; } return VAR_1 . get ( 0 ) ; } } 
public TYPE_1 METHOD_1 ( ) { synchronized ( VAR_1 ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> return null ; } return VAR_1 . get ( VAR_1 . size ( ) - 1 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { for ( int i = 0 ; i < 100 ; i ++ ) { <START> VAR_2 . METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( i ) ; } } 
<START> public static TYPE_9 . TYPE_7 METHOD_1 ( final TYPE_2 VAR_1 , <END> final TYPE_3 VAR_2 ) { TYPE_4 . METHOD_2 ( VAR_1 , STRING_1 ) ; TYPE_4 . METHOD_2 ( VAR_2 , STRING_2 ) ; return new TYPE_9 . TYPE_7 ( ) { @Override public TYPE_9 . TYPE_8 METHOD_3 ( ) { return new TYPE_6 ( VAR_1 , VAR_2 . METHOD_4 ( ) ) ; } } ; } 
<START> public static TYPE_8 . TYPE_6 METHOD_1 ( final int VAR_1 , <END> final TYPE_2 VAR_2 ) { TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; TYPE_3 . METHOD_3 ( VAR_2 , STRING_2 ) ; return new TYPE_8 . TYPE_6 ( ) { @Override public TYPE_8 . TYPE_7 METHOD_4 ( ) { return new TYPE_5 ( VAR_1 , VAR_2 . METHOD_5 ( ) ) ; } } ; } 
<START> protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , Object ... args ) throws Exception { <END> return new TYPE_3 ( this , VAR_1 ) ; } 
boolean METHOD_1 ( TYPE_1 < T > buf , int VAR_1 , int VAR_2 ) { final long VAR_3 ; if ( ( VAR_2 & VAR_4 ) != 0 ) { VAR_3 = METHOD_2 ( VAR_2 ) ; } else { VAR_3 = METHOD_3 ( VAR_2 ) ; } <START> if ( VAR_3 > 0 ) { <END> ByteBuffer VAR_5 = VAR_6 != null ? VAR_6 . METHOD_4 ( ) : null ; METHOD_5 ( buf , VAR_5 , VAR_3 , VAR_1 ) ; return true ; } return false ; } 
public void trace ( String format , Object VAR_1 ) { if ( METHOD_1 ( ) ) { <START> log ( VAR_2 , org . VAR_3 . VAR_4 . TYPE_1 . format ( format , VAR_1 ) . getMessage ( ) , VAR_1 ) ; <END> } } 
<START> public synchronized void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( false , true ) ) { while ( true ) { <START> if ( VAR_2 . METHOD_3 ( VAR_3 ) ) { <END> break ; } } try { VAR_4 . METHOD_4 ( ) ; } catch ( InterruptedException e ) { } } } 
public TYPE_4 ( int VAR_2 ) { VAR_3 = TYPE_1 . METHOD_1 ( VAR_2 ) ; VAR_4 = new Thread ( new TYPE_2 ( ) { @Override public void run ( ) { final TYPE_3 < TYPE_2 > VAR_3 = TYPE_4 . VAR_5 . VAR_3 ; while ( true ) { final TYPE_2 task = VAR_3 . METHOD_2 ( ) ; if ( task != null ) { if ( task == VAR_6 ) { return ; <START> } else { <END> task . run ( ) ; } } } } } ) ; VAR_4 . start ( ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 ctx ) { final TYPE_1 VAR_1 = ctx . channel ( ) ; <START> return ( VAR_1 instanceof TYPE_3 ) ? VAR_1 . parent ( ) : VAR_1 ; <END> } 
<START> private void METHOD_1 ( TYPE_1 ctx , TYPE_2 out ) { <END> final TYPE_3 VAR_1 = ctx . VAR_1 ( ) ; for ( int i = 0 ; i < out . size ( ) ; i ++ ) { ctx . write ( out . VAR_2 ( i ) , VAR_1 ) ; } } 
<START> private void METHOD_1 ( TYPE_1 ctx , TYPE_2 out , TYPE_3 VAR_1 ) { <END> final TYPE_4 VAR_2 = new TYPE_4 ( ) ; for ( int i = 0 ; i < out . size ( ) ; i ++ ) { VAR_2 . add ( ctx . write ( out . VAR_3 ( i ) ) ) ; } VAR_2 . METHOD_2 ( VAR_1 ) ; } 
public boolean METHOD_1 ( ) { String version = METHOD_2 ( ) ; <START> if ( StringUtils . VAR_1 ( version ) ) { <END> if ( version . contains ( STRING_1 ) ) { return true ; } } return false ; } 
public boolean METHOD_1 ( ) { if ( containsKey ( TYPE_1 . VAR_2 ) ) { String value = METHOD_2 ( TYPE_1 . VAR_2 , STRING_1 ) ; <START> if ( StringUtils . VAR_3 ( value ) && value . equals ( STRING_2 ) ) { <END> return true ; } else { return false ; } } else { if ( METHOD_3 ( ) ) { return true ; } else { return false ; } } } 
<START> public String METHOD_1 ( String VAR_1 ) { <END> return TYPE_1 . METHOD_2 ( ) + STRING_1 + VAR_1 + STRING_2 + TYPE_2 . VAR_3 ; } 
public boolean METHOD_1 ( String VAR_1 ) { boolean VAR_2 = false ; try { TYPE_1 VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_3 != null ) { <END> VAR_2 = VAR_3 . METHOD_3 ( ) ; } } catch ( TYPE_3 e ) { } return VAR_2 ; } 
protected TYPE_1 < TYPE_2 > METHOD_1 ( int id , TYPE_3 VAR_1 ) { if ( id == VAR_2 ) { METHOD_2 ( ) ; return new TYPE_4 ( METHOD_3 ( ) , TYPE_5 . METHOD_4 ( VAR_3 . getId ( ) ) ) ; } else if ( id == VAR_4 ) { METHOD_2 ( ) ; return new TYPE_4 ( METHOD_3 ( ) , TYPE_5 . METHOD_5 ( VAR_5 , VAR_6 ) ) ; } <START> return null ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = METHOD_2 ( VAR_1 ) ; TYPE_2 VAR_3 = METHOD_3 ( VAR_1 , VAR_4 ) ; try { <START> METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( TYPE_4 . VAR_6 , VAR_3 ) ; <END> } catch ( TYPE_3 ex ) { METHOD_4 ( ) . METHOD_5 ( ) . update ( TYPE_4 . VAR_6 , VAR_3 , TYPE_4 . TYPE_5 . VAR_8 + STRING_1 , new String [ ] { String . valueOf ( VAR_1 . METHOD_7 ( ) ) } ) ; } } 
public void METHOD_1 ( ) { context . VAR_1 ( STRING_1 , STRING_2 ) ; context . VAR_1 ( STRING_3 , STRING_4 ) ; context . VAR_1 ( STRING_5 , STRING_6 ) ; <START> context . VAR_1 ( STRING_7 , STRING_8 ) ; <END> context . VAR_1 ( STRING_9 , STRING_10 ) ; String result = TYPE_1 . METHOD_2 ( STRING_11 , context ) ; assertEquals ( STRING_12 , result ) ; } 
TYPE_1 ( String VAR_2 ) { <START> VAR_3 = STRING_1 + VAR_2 ; <END> } 
public void start ( ) throws Exception { LOG . info ( STRING_1 ) ; METHOD_1 ( ) ; LOG . info ( STRING_2 ) ; VAR_1 . start ( ) ; LOG . info ( STRING_3 ) ; <START> String VAR_2 = VAR_3 + STRING_4 + Integer . toString ( VAR_4 ) ; <END> VAR_5 . METHOD_2 ( VAR_6 . getName ( ) , VAR_7 , VAR_2 ) ; } 
<START> private static boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { <END> if ( VAR_1 == null && VAR_2 == null ) { return true ; } return VAR_1 . equals ( VAR_2 ) ; } 
<START> public TYPE_5 ( TYPE_1 VAR_2 , <END> TYPE_2 view , TYPE_3 VAR_3 ) { super ( VAR_2 , view , VAR_3 , TYPE_4 . TYPE_6 ) ; } 
public TYPE_1 ( String VAR_2 , String VAR_3 , String VAR_4 ) { <START> String s = null ; if ( VAR_4 != null ) { s = VAR_4 . startsWith ( STRING_1 ) ? STRING_2 : STRING_3 ; } VAR_5 = Arrays . asList ( s ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_6 = VAR_4 ; } 
<START> public static String METHOD_1 ( String VAR_1 , String VAR_2 ) { <END> if ( VAR_1 == null | VAR_1 == "" ) { return VAR_1 ; } int VAR_3 = VAR_1 . METHOD_2 ( STRING_1 ) ; if ( VAR_3 != - 1 ) { return VAR_1 . substring ( 0 , VAR_3 ) + STRING_1 + VAR_2 ; } else if ( VAR_2 != "" ) { return VAR_1 + STRING_1 + VAR_2 ; } else { return VAR_1 ; } } 
public void METHOD_1 ( Long VAR_1 ) { try { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( TYPE_1 . class , VAR_1 ) ; Long VAR_4 = VAR_2 . METHOD_3 ( ) ; VAR_4 ++ ; VAR_2 . METHOD_4 ( VAR_4 ) ; VAR_3 . METHOD_5 ( VAR_2 ) ; } catch ( Exception e ) { <START> logger . log ( Level . VAR_5 , STRING_1 , VAR_1 ) ; <END> } } 
public boolean METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { <START> boolean VAR_3 = VAR_4 . METHOD_2 ( STRING_1 ) <END> . METHOD_3 ( STRING_2 , VAR_1 ) . METHOD_3 ( STRING_3 , VAR_2 . METHOD_4 ( ) ) . METHOD_3 ( STRING_4 , VAR_2 . METHOD_5 ( ) ) . METHOD_6 ( ) . isEmpty ( ) ; return VAR_3 ; } 
public void METHOD_1 ( ) { <START> System . out . METHOD_2 ( STRING_1 ) ; <END> this . VAR_1 = ! this . VAR_1 ; METHOD_3 ( this . VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( VAR_1 == null ) { throw new TYPE_2 ( STRING_1 ) ; } String query = STRING_2 + STRING_3 + VAR_1 . getId ( ) + STRING_4 + STRING_5 + VAR_2 + STRING_6 ; TYPE_3 VAR_3 = VAR_4 . METHOD_2 ( query ) ; <START> List < String > VAR_5 = VAR_3 . METHOD_3 ( ) ; <END> return VAR_5 . size ( ) > 0 ; } 
public TYPE_1 METHOD_1 ( ) { return ( TYPE_1 ) VAR_1 . METHOD_2 ( STRING_1 ) . METHOD_3 ( ) ; <START> } <END> 
public List < Object [ ] > METHOD_1 ( List < Long > VAR_1 ) { String VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { return null ; } String VAR_3 = STRING_1 ; VAR_3 += STRING_2 ; VAR_3 += STRING_3 + VAR_2 ; VAR_3 += STRING_4 ; <START> return VAR_4 . METHOD_3 ( VAR_3 , Object [ ] . class ) . METHOD_4 ( ) ; <END> } 
public String METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> if ( ( session . VAR_1 ( ) != null ) && ( session . VAR_1 ( ) . METHOD_2 ( ) ) && ( session . VAR_1 ( ) . METHOD_3 ( ) ) ) { VAR_2 = ( TYPE_1 ) session . VAR_1 ( ) ; VAR_3 = new TYPE_2 ( VAR_4 ) ; METHOD_4 ( ) ; } else { return VAR_5 . METHOD_5 ( ) ; } return null ; } 
public Long METHOD_1 ( ) { return METHOD_2 ( null ) ; <START> } <END> 
void METHOD_1 ( ) { class TYPE_1 { ANNOTATION_1 ( VAR_1 = TYPE_4 . VAR_3 ) ANNOTATION_2 TYPE_2 id ; } TYPE_1 entity = new TYPE_1 ( ) ; TYPE_3 VAR_4 = new TYPE_3 ( ) ; VAR_5 . write ( entity , VAR_4 ) ; assertThat ( VAR_4 . getId ( ) ) . METHOD_2 ( entity . id . toString ( ) ) ; <START> System . out . println ( entity . id ) ; <END> } 
public T METHOD_1 ( final String id ) { try { return VAR_1 . METHOD_1 ( id ) . METHOD_2 ( ) ; } catch ( TYPE_1 VAR_2 ) { <START> VAR_2 . METHOD_3 ( ) ; <END> return null ; } } 
public TYPE_1 getParameters ( ) { <START> return parameters ; <END> } 
private Boolean METHOD_1 ( TYPE_1 builder ) throws Exception { try { TYPE_2 request = new TYPE_2 ( builder . build ( ) ) ; TYPE_3 client = TYPE_4 . create ( ) . build ( ) ; TYPE_5 response = client . execute ( request ) ; int status = response . VAR_1 ( ) . METHOD_2 ( ) ; <START> if ( status < INT_1 || status > INT_2 ) { <END> return false ; } return true ; } catch ( Exception ex ) { Thread . VAR_2 ( INT_3 ) ; throw ex ; } } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> this . VAR_1 = VAR_1 ; return this ; } 
protected Object METHOD_1 ( TYPE_1 ctx , TYPE_2 in ) throws Exception { TYPE_2 VAR_1 = ( TYPE_2 ) super . METHOD_1 ( ctx , in ) ; assert VAR_2 != null ; if ( VAR_1 == null ) { <START> return null ; <END> } else { TYPE_3 VAR_3 = VAR_4 . METHOD_1 ( VAR_2 , VAR_1 ) ; VAR_2 = null ; return VAR_3 ; } } 
private Optional < Long > METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; int VAR_3 = VAR_1 . METHOD_3 ( VAR_2 ) ; if ( VAR_3 != 0 ) { <START> LOG . info ( STRING_1 + VAR_3 ) ; <END> return Optional . empty ( ) ; } return Optional . of ( VAR_2 . METHOD_4 ( ) * INT_1 + VAR_2 . METHOD_5 ( ) ) ; } 
<START> public static String METHOD_1 ( ) { <END> return TYPE_1 . name ( ) . METHOD_2 ( VAR_1 ) ; } 
public boolean equals ( Object o ) { <START> if ( this == o ) return true ; <END> if ( ! ( o instanceof TYPE_1 ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; return VAR_1 == that . VAR_1 && VAR_2 == that . VAR_2 ; } 
public TYPE_6 ( ANNOTATION_1 TYPE_1 < TYPE_2 > VAR_2 , ANNOTATION_1 TYPE_3 < TYPE_4 > VAR_3 ) { <START> this . VAR_2 = TYPE_5 . METHOD_1 ( VAR_2 , STRING_1 ) ; <END> this . VAR_3 = TYPE_5 . METHOD_1 ( VAR_3 , STRING_2 ) ; } 
<START> public static void METHOD_1 ( TYPE_1 session ) throws Exception { <END> session . execute ( TYPE_2 . METHOD_2 ( STRING_1 ) . METHOD_3 ( STRING_2 ) ) ; session . execute ( STRING_3 ) ; for ( String VAR_1 : METHOD_4 ( STRING_4 ) ) { session . execute ( TYPE_2 . METHOD_2 ( VAR_1 ) . METHOD_3 ( STRING_2 ) ) ; } } 
<START> boolean METHOD_1 ( TYPE_1 VAR_1 , Class < ? > VAR_2 ) { <END> Optional < TYPE_2 > VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; if ( VAR_3 . isPresent ( ) ) { for ( TYPE_3 VAR_4 : VAR_3 . get ( ) . METHOD_3 ( ) . keySet ( ) ) { if ( VAR_4 . METHOD_4 ( ) . METHOD_5 ( STRING_1 ) ) { return true ; } } } return false ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 type , TYPE_1 VAR_2 , String VAR_3 , TYPE_3 . Builder VAR_4 , TYPE_4 VAR_5 ) { METHOD_1 ( VAR_1 , type , VAR_2 , VAR_3 , VAR_4 , VAR_5 , <START> TYPE_1 . of ( STRING_1 , TYPE_5 . class , TYPE_5 . VAR_6 ) ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , List < TYPE_3 > VAR_3 ) { <START> String VAR_4 = VAR_5 . METHOD_2 ( VAR_1 . METHOD_3 ( ) . toString ( ) + STRING_1 ) ; <END> List < String > VAR_6 = new ArrayList < > ( ) ; for ( TYPE_3 type : VAR_3 ) { VAR_6 . add ( METHOD_4 ( type ) ) ; } VAR_7 . add ( new TYPE_4 ( VAR_1 , VAR_4 , VAR_2 , VAR_6 ) ) ; return VAR_4 ; } 
private TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> TYPE_3 . METHOD_1 ( VAR_2 == null ^ VAR_3 == null ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public TYPE_1 builder ( ) { <START> return TYPE_2 . builder ( METHOD_1 ( ) ) . METHOD_2 ( VAR_1 ) ; <END> } 
public ByteBuffer METHOD_1 ( ANNOTATION_1 T value , ANNOTATION_2 TYPE_1 VAR_1 ) { if ( value == null ) return null ; try { return ByteBuffer . VAR_2 ( VAR_3 . METHOD_2 ( value ) ) ; } catch ( TYPE_2 e ) { <START> throw new TYPE_3 ( e . getMessage ( ) , e ) ; <END> } } 
public T parse ( String value ) { <START> if ( value == null || value . isEmpty ( ) || value . equalsIgnoreCase ( STRING_1 ) ) return null ; <END> if ( ! TYPE_1 . METHOD_1 ( value ) ) throw new IllegalArgumentException ( STRING_2 ) ; String VAR_1 = TYPE_1 . METHOD_2 ( value ) ; try { return ( T ) VAR_2 . METHOD_3 ( VAR_1 , METHOD_4 ( ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( e . getMessage ( ) , e ) ; } } 
private boolean METHOD_1 ( Throwable error ) { boolean VAR_1 = true ; if ( error instanceof TYPE_1 ) { <START> Collection < Throwable > VAR_2 = ( ( TYPE_1 ) error ) . METHOD_2 ( ) . values ( ) ; <END> for ( Throwable VAR_3 : VAR_2 ) { if ( ! ( VAR_3 instanceof TYPE_2 ) ) { VAR_1 = false ; break ; } } } return VAR_1 ; } 
private boolean METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
public TYPE_1 build ( ) { return new TYPE_2 ( VAR_1 , VAR_2 . build ( ) , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , METHOD_1 ( ) , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 , VAR_16 , <START> null ) ; <END> } 
private Builder ( ) { try { this . VAR_1 = TYPE_1 . METHOD_1 ( STRING_1 ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } METHOD_2 ( STRING_2 , STRING_3 ) ; if ( this . VAR_1 != null ) { <START> this . VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ; <END> } } 
private static File METHOD_1 ( String VAR_1 ) { File f = null ; try ( TYPE_1 VAR_2 = new TYPE_2 ( f = File . VAR_3 ( STRING_1 , STRING_2 ) ) ) { TYPE_3 . METHOD_2 ( TYPE_4 . class . METHOD_3 ( VAR_1 ) , VAR_2 ) ; } catch ( IOException e ) { logger . warn ( STRING_3 , e ) ; <START> } finally { <END> if ( f != null ) { f . VAR_4 ( ) ; } } return f ; } 
public static < T > void METHOD_1 ( ANNOTATION_1 T [ ] VAR_1 , int n ) { <START> METHOD_1 ( VAR_1 , n , TYPE_1 . METHOD_2 ( ) : : METHOD_3 ) ; <END> } 
boolean METHOD_1 ( ) { if ( VAR_1 && VAR_2 != null ) { return true ; } <START> return false ; <END> } 
TYPE_2 ( String name , boolean VAR_2 , Map < String , String > VAR_3 ) { this . name = name ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = TYPE_1 . create ( VAR_3 ) ; <START> this . VAR_5 = false ; <END> } 
<START> public Class < ? > METHOD_1 ( ) { <END> return token . VAR_1 ( ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 context ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = context . VAR_4 ( ) . METHOD_1 ( this ) ; <END> this . state = TYPE_3 . VAR_6 ; this . VAR_7 = TYPE_4 . VAR_9 ; this . VAR_10 = Collections . VAR_11 ( ) ; this . VAR_12 = Collections . VAR_13 ( ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> METHOD_2 ( VAR_1 == TYPE_1 . VAR_3 || VAR_1 == TYPE_1 . VAR_4 || VAR_1 == TYPE_1 . VAR_5 , <END> STRING_1 ) ; } 
public void METHOD_1 ( ) { ByteBuffer VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 ) ; TYPE_2 VAR_2 = factory . VAR_3 ( VAR_1 ) ; TYPE_2 VAR_4 = factory . VAR_3 ( VAR_1 ) ; assertThat ( VAR_2 ) . METHOD_3 ( factory . VAR_5 ( STRING_2 ) ) ; <START> assertThat ( VAR_2 ) . METHOD_3 ( VAR_4 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) . VAR_4 . id , VAR_1 ) ; if ( VAR_2 != null ) { logger . warn ( STRING_1 + STRING_2 , VAR_1 . METHOD_4 ( ) ) ; if ( VAR_5 . VAR_6 . VAR_7 . VAR_8 . TYPE_2 . METHOD_5 ( VAR_2 . METHOD_3 ( ) . VAR_10 . id , VAR_1 . METHOD_3 ( ) . VAR_10 . id ) ) <START> return VAR_2 ; <END> } return VAR_1 ; } 
String METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . get ( ) ; <START> return VAR_1 == null ? null : VAR_1 . VAR_3 ; <END> } 
public void METHOD_1 ( ) { <START> assertEquals ( STRING_1 , new TYPE_1 ( null , STRING_2 ) . getMessage ( ) ) ; <END> } 
static < T extends TYPE_1 > T METHOD_1 ( Class < T > VAR_1 , Class < ? > VAR_2 ) { T instance = VAR_2 . METHOD_2 ( VAR_1 ) ; if ( instance == null ) <START> throw new IllegalStateException ( String . format ( STRING_1 , <END> VAR_1 . METHOD_3 ( ) , VAR_2 ) ) ; METHOD_4 ( VAR_2 , VAR_1 ) ; return instance ; } 
private String METHOD_1 ( ) { StringBuilder VAR_1 = new StringBuilder ( "" ) ; for ( String VAR_2 : VAR_3 ) { <START> String VAR_4 = METHOD_2 ( ) ? STRING_1 : "" ; <END> VAR_1 . append ( STRING_2 ) ; VAR_1 . append ( VAR_4 ) ; VAR_1 . append ( STRING_3 ) ; VAR_1 . append ( METHOD_3 ( VAR_2 ) ) ; VAR_1 . append ( VAR_4 ) ; } return VAR_1 . toString ( ) ; } 
private < TYPE_1 > TYPE_1 METHOD_1 ( TYPE_2 < TYPE_1 > VAR_1 ) { <START> if ( TYPE_3 . equals ( VAR_1 ) ) { <END> ANNOTATION_1 ( STRING_1 ) TYPE_1 v = ( TYPE_1 ) METHOD_2 ( ) ; return v ; } else { assert VAR_1 != null ; return METHOD_3 ( METHOD_4 ( VAR_1 ) ) ; } } 
public void METHOD_1 ( ) throws Exception { VAR_1 . update ( uri , METHOD_2 ( ) . read ( new TYPE_1 ( VAR_2 ) , "" , STRING_1 ) ) ; METHOD_3 ( 3 ) ; assertEquals ( STRING_2 , 3 , METHOD_4 ( uri ) ) ; final String VAR_3 = STRING_3 + STRING_4 + STRING_5 + STRING_6 ; <START> assertEquals ( STRING_7 , 3 , METHOD_5 ( VAR_3 ) ) ; <END> VAR_1 . remove ( uri ) ; METHOD_3 ( 0 ) ; assertTrue ( STRING_8 , METHOD_4 ( uri ) == 0 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( true ) ; <START> TYPE_1 VAR_2 = new TYPE_2 ( false ) ; <END> String x = STRING_1 ; if ( VAR_1 . count ( ) | VAR_2 . count ( ) ) { x = STRING_2 ; } assertEquals ( x , VAR_3 ) ; assertEquals ( VAR_1 . count , VAR_3 ) ; assertEquals ( VAR_2 . count , VAR_3 ) ; } 
public static boolean METHOD_1 ( int VAR_1 ) { <START> return VAR_1 == INT_1 || VAR_1 == INT_2 || VAR_1 == INT_3 || VAR_1 == INT_4 || VAR_1 == INT_5 || VAR_1 == INT_6 ; <END> } 
public boolean METHOD_1 ( ) { <START> return ( VAR_1 . get ( ) && ! VAR_2 . get ( ) ) || VAR_3 . get ( ) ; <END> } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) { <START> TYPE_5 . TYPE_6 . VAR_2 . VAR_3 . TYPE_3 request = METHOD_2 ( ) ; <END> if ( VAR_1 ) request . VAR_4 ( true ) ; synchronized ( VAR_5 ) { if ( ! VAR_5 . METHOD_3 ( ) ) { TYPE_4 VAR_6 = VAR_5 . METHOD_1 ( request ) ; VAR_7 . add ( VAR_6 ) ; VAR_8 . put ( VAR_6 , request ) ; } } return this ; } 
private void METHOD_1 ( String VAR_1 ) { <START> Log . e ( TAG , STRING_1 + VAR_1 ) ; <END> try { METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; } catch ( TYPE_1 e ) { Log . VAR_2 ( TAG , STRING_2 + VAR_1 , e ) ; } } 
protected void METHOD_1 ( Throwable VAR_1 ) { if ( VAR_1 != this . error ) { Log . e ( Log . VAR_2 , STRING_1 , this , VAR_1 ) ; VAR_3 . METHOD_2 ( VAR_1 ) ; this . error = VAR_1 ; if ( Utils . VAR_4 ( this . error ) ) { METHOD_3 ( ) ; } <START> { <END> TYPE_2 . TYPE_3 VAR_5 = new TYPE_2 . TYPE_3 ( this ) ; VAR_5 . METHOD_1 ( this . error ) ; METHOD_4 ( VAR_5 ) ; } } } 
protected void METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) return ; VAR_1 . clear ( ) ; METHOD_3 ( TYPE_3 . TYPE_2 . VAR_4 ) ; METHOD_4 ( ) ; while ( ! VAR_5 . isEmpty ( ) ) { TYPE_1 VAR_6 = VAR_5 . METHOD_5 ( ) ; <START> if ( VAR_6 != null && ! VAR_6 . METHOD_6 ( ) && VAR_6 . METHOD_7 ( ) ) { <END> VAR_6 . METHOD_8 ( true ) ; } } } 
public TYPE_1 METHOD_1 ( ) throws InterruptedException { TYPE_1 e = super . METHOD_1 ( ) ; <START> if ( listener != null ) listener . VAR_1 ( TYPE_3 . TYPE_2 . VAR_4 , e , this ) ; <END> return e ; } 
public T METHOD_1 ( TYPE_1 parser , TYPE_2 VAR_1 , String value ) throws TYPE_3 { for ( T t : VAR_2 . METHOD_2 ( ) ) { if ( t . toString ( ) . equals ( value ) ) { return t ; } } String VAR_3 = TYPE_4 . METHOD_3 ( VAR_2 . METHOD_2 ( ) , 0 , STRING_1 , STRING_2 , STRING_3 ) ; throw new TYPE_3 ( String . format ( TYPE_4 . VAR_4 , STRING_4 , value , VAR_3 ) , <START> null , parser , VAR_1 ) ; <END> } 
<START> private static final TYPE_1 METHOD_1 ( ) { <END> return Utils . VAR_1 ( TYPE_1 . class ) ; } 
<START> private static final TYPE_1 METHOD_1 ( ) { <END> return METHOD_2 ( ) . METHOD_3 ( ) ; } 
public void METHOD_1 ( String content ) { <START> this . content = Optional . VAR_1 ( content ) ; <END> } 
public String getValue ( ) { <START> return content . VAR_1 ( ) ; <END> } 
public ANNOTATION_1 TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 ) { <START> TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) . get ( ) ; <END> if ( VAR_2 != null ) { return new TYPE_1 ( VAR_2 ) ; } return new TYPE_1 ( TYPE_2 . VAR_3 , VAR_1 , null ) ; } 
public ANNOTATION_1 TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 ) { if ( TYPE_2 . METHOD_2 ( VAR_1 ) . isPresent ( ) ) { TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) . get ( ) ; <START> if ( VAR_2 != null ) { <END> return new TYPE_1 ( VAR_2 ) ; } } return new TYPE_1 ( TYPE_2 . VAR_3 , VAR_1 , null ) ; } 
public Optional < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , int VAR_3 ) { TYPE_1 VAR_4 = null ; List < TYPE_1 > VAR_5 = METHOD_2 ( VAR_1 , VAR_2 ) ; for ( TYPE_1 VAR_6 : VAR_5 ) { if ( VAR_6 . METHOD_3 ( ) == VAR_3 ) { <START> VAR_4 = VAR_6 ; <END> } } return Optional . VAR_7 ( VAR_4 ) ; } 
public Optional < TYPE_1 > METHOD_1 ( String VAR_1 ) { <START> METHOD_2 ( ) ; <END> return Optional . VAR_2 ( METHOD_3 ( ) . get ( VAR_1 ) ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { <START> String msg = STRING_1 ; <END> METHOD_2 ( ! METHOD_3 ( VAR_1 ) , TYPE_2 . format ( msg , VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 ) { <START> String name = VAR_1 . getName ( ) + VAR_2 ; <END> TYPE_2 parent = TYPE_3 . METHOD_2 ( VAR_1 , TYPE_2 . class ) . get ( ) ; return TYPE_3 . create ( TYPE_1 . class , name , parent ) ; } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( ( VAR_2 != null ) && ( VAR_2 . METHOD_3 ( TYPE_3 . VAR_4 ) != null ) ) { <START> return VAR_2 . METHOD_3 ( TYPE_3 . VAR_4 ) ; <END> } return TYPE_3 . VAR_5 ; } 
public boolean METHOD_1 ( String name ) { for ( TYPE_1 VAR_1 : VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) . equals ( name ) ) { return VAR_1 . METHOD_1 ( ) ; } } <START> try { <END> return Utils . VAR_3 ( ) . METHOD_3 ( TYPE_2 . class , name ) . METHOD_1 ( ) ; } catch ( TYPE_3 VAR_4 ) { LOGGER . debug ( STRING_1 , name ) ; return false ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { System . out . println ( STRING_1 + this ) ; <START> System . out . println ( STRING_2 + VAR_1 ) ; <END> return ( this . VAR_2 != null ) && ( this . VAR_3 != null ) && ( this . VAR_3 >= 0 ) && TYPE_2 . equals ( this . VAR_2 , VAR_1 . VAR_2 ) && TYPE_2 . equals ( this . VAR_3 , VAR_1 . VAR_3 ) ; } 
public TYPE_1 parse ( String string ) throws Exception { TYPE_1 VAR_1 ; TYPE_2 VAR_2 = this . METHOD_1 ( ) ; TYPE_3 . METHOD_2 ( this . VAR_3 , STRING_1 ) ; <START> VAR_1 = TYPE_1 . parse ( string , VAR_2 ) ; <END> return VAR_1 ; } 
private Map < String , TYPE_1 > METHOD_1 ( TYPE_2 model , TYPE_3 VAR_1 , File input ) throws Exception { try { return METHOD_1 ( model , VAR_1 , TYPE_4 . read ( input ) ) ; } catch ( IOException e ) { LOG . error ( STRING_1 ) ; <START> throw new Exception ( STRING_1 , e ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) { <START> if ( this . VAR_1 == null ) { <END> return METHOD_2 ( ) . METHOD_1 ( ) ; } return this . VAR_1 ; } 
protected TYPE_1 METHOD_1 ( String uri , String VAR_1 , Map < String , Object > parameters ) throws Exception { TYPE_2 VAR_2 = new TYPE_2 ( ) ; <START> METHOD_2 ( VAR_2 , parameters ) ; <END> this . VAR_3 = METHOD_3 ( VAR_2 ) ; this . VAR_2 = VAR_2 ; TYPE_1 VAR_4 = new TYPE_3 ( uri , this ) ; METHOD_2 ( VAR_4 , parameters ) ; return VAR_4 ; } 
protected String METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = METHOD_2 ( VAR_1 ) ; boolean VAR_3 = VAR_4 != null && VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; <START> if ( VAR_3 != null && VAR_3 ) { <END> VAR_2 = TYPE_2 . METHOD_6 ( VAR_2 ) ; } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { METHOD_2 ( VAR_1 , TYPE_4 . VAR_3 ) ; TYPE_2 message = VAR_1 . METHOD_3 ( ) ; String VAR_4 = message . VAR_5 ( TYPE_4 . VAR_3 , String . VAR_6 ) ; <START> Boolean VAR_7 = Boolean . valueOf ( message . VAR_5 ( TYPE_4 . VAR_8 , String . VAR_6 ) ) ; <END> TYPE_3 VAR_9 = ( TYPE_3 ) METHOD_4 ( ) . METHOD_5 ( VAR_4 ) ; VAR_9 . METHOD_6 ( VAR_7 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; this . VAR_2 = true ; <START> System . out . println ( STRING_1 ) ; <END> } 
<START> public boolean METHOD_1 ( Set < String > VAR_1 , List < String > VAR_2 ) throws Exception { <END> for ( String VAR_3 : VAR_2 ) { if ( VAR_1 . contains ( VAR_3 ) ) { return true ; } } return false ; } 
protected TYPE_1 METHOD_1 ( ) throws Exception { TYPE_1 context = super . METHOD_1 ( ) ; context . VAR_1 ( ) . METHOD_2 ( STRING_1 ) ; ( ( TYPE_2 ) context . VAR_2 ( STRING_2 ) ) . METHOD_3 ( METHOD_4 ( ) ) ; ( ( TYPE_2 ) context . VAR_2 ( STRING_2 ) ) . METHOD_5 ( METHOD_6 ( ) ) ; <START> ( ( TYPE_2 ) context . VAR_2 ( STRING_2 ) ) . METHOD_7 ( METHOD_8 ( ) ) ; <END> return context ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 { LOG . trace ( STRING_1 , VAR_2 ) ; TYPE_3 connection = VAR_3 . METHOD_2 ( ) ; try { TYPE_4 VAR_4 = ( TYPE_4 ) VAR_1 . METHOD_3 ( ) . METHOD_4 ( TYPE_6 . VAR_6 ) ; TYPE_5 builder = ( TYPE_5 ) VAR_1 . METHOD_3 ( ) . METHOD_4 ( TYPE_6 . VAR_7 ) ; connection . VAR_8 ( VAR_2 , VAR_4 , builder ) ; <START> } catch ( Throwable t ) { <END> t . VAR_9 ( ) ; throw t ; } } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; TYPE_2 < TYPE_3 > VAR_3 = VAR_1 . METHOD_3 ( STRING_2 ) ; if ( VAR_3 . count ( ) == 0 ) { <START> VAR_3 . METHOD_4 ( TYPE_3 . parse ( STRING_3 + STRING_4 <END> + STRING_5 + STRING_6 + STRING_7 + STRING_8 + STRING_9 + STRING_10 + STRING_11 + STRING_12 + STRING_13 + STRING_14 + STRING_15 + STRING_16 + STRING_17 + STRING_18 + STRING_13 + STRING_19 + STRING_20 + "" ) ) ; } } 
public void add ( String ... values ) { <START> for ( String value : values ) { <END> VAR_1 . add ( value ) ; } } 
<START> private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <END> return VAR_1 . type ( ) . equals ( TYPE_1 . Type . VAR_2 ) ; } 
protected static boolean METHOD_1 ( final Object field ) { <START> return field == null || TYPE_1 . isEmpty ( field ) ; <END> } 
public static void METHOD_1 ( String [ ] args ) throws Exception { <START> System . out . println ( STRING_1 ) ; <END> TYPE_1 context = new TYPE_2 ( ) ; context . start ( ) ; context . VAR_1 ( new TYPE_3 ( ) ) ; context . VAR_2 ( new TYPE_4 ( ) ) ; } 
public TYPE_1 ( ) { <START> super ( ) ; <END> METHOD_1 ( ) . METHOD_2 ( STRING_1 ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <END> TYPE_2 < TYPE_3 > VAR_3 = VAR_2 . METHOD_2 ( ) ; for ( TYPE_3 child : VAR_3 ) { if ( child instanceof TYPE_4 ) { ( ( TYPE_4 ) child ) . METHOD_3 ( VAR_1 ) ; } else if ( child instanceof TYPE_1 ) { METHOD_4 ( VAR_1 , ( TYPE_1 ) child ) ; } } } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_1 client = METHOD_2 ( ) . METHOD_3 ( ) ; <END> if ( ! client . VAR_1 ( ) ) client . VAR_2 ( ) ; return client ; } 
<START> public String METHOD_1 ( String input ) throws TYPE_1 { <END> if ( ! VAR_1 ) { return METHOD_2 ( null ) ; } TYPE_2 VAR_2 = new TYPE_2 ( this . VAR_3 , this . VAR_4 , input ) ; return METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; } 
private TYPE_1 METHOD_1 ( String message ) throws TYPE_2 { TYPE_1 VAR_1 = null ; try { VAR_1 = VAR_2 . METHOD_2 ( message , TYPE_1 . class ) ; } catch ( Exception e ) { e . VAR_3 ( ) ; <START> throw new TYPE_2 ( STRING_1 + e . getMessage ( ) ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 event ) { LOG . debug ( STRING_1 , event ) ; <START> if ( event instanceof TYPE_2 && ( ( TYPE_2 ) event ) . METHOD_2 ( ) . getId ( ) . equals ( this . VAR_1 . getId ( ) ) ) { <END> start ( ) ; } if ( VAR_2 != null ) { VAR_2 . METHOD_1 ( event ) ; } } 
public void METHOD_1 ( ) { byte [ ] result = VAR_1 . METHOD_1 ( STRING_1 , value ) ; <START> System . out . println ( Arrays . toString ( result ) ) ; <END> METHOD_2 ( VAR_2 , result ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( VAR_2 , null ) ; <END> VAR_1 . VAR_3 = VAR_4 ; when ( VAR_4 . filter ( STRING_1 ) ) . METHOD_2 ( STRING_2 ) ; } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 . METHOD_2 ( STRING_1 ) ) { <END> return true ; } return false ; } 
public TYPE_1 put ( String VAR_1 , String VAR_2 , TYPE_2 VAR_3 ) throws TYPE_3 { String VAR_4 = VAR_2 == null ? VAR_1 : VAR_2 ; TYPE_4 entry ; try { <START> entry = client . VAR_5 ( ) . METHOD_1 ( VAR_1 ) ; <END> } catch ( TYPE_5 e ) { throw new TYPE_3 ( VAR_4 + STRING_1 ) ; } if ( VAR_1 != null ) { return METHOD_2 ( VAR_1 , VAR_3 , VAR_4 , entry ) ; } else { return METHOD_3 ( VAR_6 , VAR_3 , VAR_4 , entry ) ; } } 
public TYPE_1 ( ) { <START> super ( ) ; <END> this . VAR_2 = false ; } 
public String METHOD_1 ( String id ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( id , TYPE_1 . class ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_3 ( true ) ; } else { String description = STRING_1 + VAR_2 . METHOD_4 ( id ) ; TYPE_2 < ? > VAR_3 = TYPE_2 . status ( TYPE_4 . VAR_5 ) . METHOD_5 ( description ) ; TYPE_3 VAR_6 = new TYPE_3 ( ) ; return VAR_6 . METHOD_6 ( VAR_3 ) ; } <START> return null ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 item ) { TYPE_3 VAR_1 = METHOD_2 ( item ) ; <START> TYPE_4 VAR_2 = VAR_1 . METHOD_3 ( ) ; <END> if ( VAR_1 != null && VAR_2 != null ) { return VAR_2 . METHOD_4 ( ) ; } return null ; } 
public boolean METHOD_1 ( ) { boolean VAR_1 = true ; try { METHOD_2 ( ) ; } catch ( IOException VAR_2 ) { VAR_1 = false ; <START> log . error ( STRING_1 , VAR_2 ) ; <END> } return VAR_1 ; } 
<START> protected void METHOD_1 ( ) { <END> METHOD_2 ( ) ; } 
public static synchronized TYPE_1 get ( TYPE_2 context ) { if ( ! VAR_1 . containsKey ( context ) ) { TYPE_3 VAR_2 = METHOD_1 ( context ) ; try { context . VAR_3 ( VAR_2 , true , true ) ; } catch ( Exception ex ) { throw new IllegalStateException ( STRING_1 , ex ) ; } VAR_1 . put ( context , new TYPE_1 ( VAR_2 ) ) ; } <START> return VAR_1 . get ( context ) ; <END> } 
TYPE_2 ( ANNOTATION_1 ( STRING_1 ) final String VAR_2 , ANNOTATION_1 ( STRING_2 ) final String id , ANNOTATION_1 ( STRING_3 ) final List < TYPE_1 > VAR_3 ) { this . VAR_2 = VAR_2 ; this . id = id ; <START> this . VAR_3 = Optional . VAR_4 ( VAR_3 ) . METHOD_1 ( Collections . VAR_5 ( ) ) ; <END> } 
public boolean containsKey ( Object key ) { <START> return cache . containsKey ( key ) ; <END> } 
public static TYPE_1 METHOD_1 ( final String command ) { <START> return METHOD_1 ( command , TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) , "" ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_2 { TYPE_3 stream = TYPE_4 . class . METHOD_2 ( ) . METHOD_3 ( VAR_3 . METHOD_4 ( File . VAR_4 ) . METHOD_4 ( VAR_1 ) ) ; <START> if ( null != stream ) { <END> return new TYPE_5 ( stream ) ; } else { if ( null != VAR_5 ) { return VAR_5 . METHOD_1 ( VAR_1 , VAR_2 ) ; } else { return new TYPE_5 ( stream ) ; } } } 
public TYPE_1 METHOD_1 ( ) throws Exception { if ( VAR_1 == TYPE_4 . VAR_3 ) { return new TYPE_2 ( this ) ; } <START> else if ( VAR_1 == TYPE_4 . VAR_4 ) { <END> return new TYPE_3 ( this ) ; } else return null ; } 
private TYPE_1 METHOD_1 ( ) throws Exception { if ( VAR_1 == null ) { VAR_1 = VAR_2 . create ( ) ; VAR_1 . METHOD_2 ( ) ; } <START> LOG . info ( STRING_1 , VAR_1 ) ; <END> return VAR_1 ; } 
public Builder ( String VAR_1 ) { <START> VAR_2 = new TYPE_1 ( ) ; <END> if ( isEmpty ( VAR_1 ) ) { throw new IllegalStateException ( STRING_1 ) ; } VAR_2 . METHOD_1 ( ! VAR_1 . METHOD_2 ( STRING_2 ) ? VAR_1 + CHAR_1 : VAR_1 ) ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; TYPE_2 . get ( ) . add ( VAR_1 ) ; TYPE_3 VAR_2 = METHOD_2 ( VAR_1 ) ; <START> assertTrue ( METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ) ; <END> VAR_2 . METHOD_4 ( ) ; METHOD_5 ( METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ) ; VAR_1 . METHOD_6 ( ) ; } 
public final < TYPE_1 extends TYPE_2 > TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( ) ; <END> } 
public static Path METHOD_1 ( String VAR_1 ) { try { <START> Path path = TYPE_1 . METHOD_1 ( STRING_1 , System . VAR_2 ( ) + CHAR_1 + VAR_1 ) ; <END> path . VAR_3 ( ) . METHOD_2 ( ) ; return path ; } catch ( IOException e ) { throw new TYPE_2 ( STRING_2 + VAR_1 ) ; } } 
public TYPE_1 ( File VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; } 
public static synchronized void METHOD_1 ( Context context , String name ) { <START> METHOD_2 ( context , false , name ) ; <END> } 
<START> public TYPE_1 getInstance ( ) { <END> return VAR_1 ; } 
private Object METHOD_1 ( ) { METHOD_2 ( ) ; Object key = TYPE_1 . METHOD_3 ( ( VAR_1 != null ) ? VAR_1 . getName ( ) : null , TYPE_2 . METHOD_4 ( VAR_2 ) , filter == VAR_3 ? null : new TYPE_3 < TYPE_4 > ( filter ) , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) ; this . VAR_8 = key ; <START> return super . create ( key ) ; <END> } 
protected Object METHOD_1 ( Object VAR_1 ) { if ( VAR_2 instanceof TYPE_1 ) { <START> return ( ( TYPE_2 < TYPE_3 > ) VAR_1 ) . get ( ) ; <END> } return super . METHOD_1 ( VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 request ) { String VAR_1 = request . VAR_2 ( STRING_1 ) ; <START> return StringUtils . VAR_3 ( VAR_1 , STRING_2 ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 request ) { if ( METHOD_2 ( request ) && METHOD_3 ( ) ) { return true ; } <START> return request . VAR_1 ( TYPE_2 . VAR_3 ) != null && METHOD_4 ( ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , ANNOTATION_1 Object VAR_2 , Object VAR_3 ) throws TYPE_2 { if ( VAR_2 == null ) { String VAR_4 = VAR_3 . toString ( ) ; TYPE_3 VAR_5 = METHOD_2 ( VAR_1 ) ; <START> return VAR_5 . METHOD_3 ( VAR_4 ) ; <END> } return false ; } 
protected void METHOD_1 ( Object VAR_1 , List < TYPE_1 > VAR_2 ) throws TYPE_2 { <START> if ( logger . VAR_3 ( ) ) { logger . debug ( STRING_1 + STRING_2 ) ; } <END> METHOD_2 ( VAR_2 , TYPE_1 . VAR_4 ) ; } 
public static TYPE_1 method ( TYPE_2 method , String uri ) { <START> return new TYPE_3 ( method , new TYPE_4 ( uri ) ) ; <END> } 
private TYPE_1 . Builder METHOD_1 ( Class < ? > VAR_1 ) { <START> try { <END> assert METHOD_2 ( VAR_1 ) ; TYPE_2 method = VAR_2 . get ( VAR_1 ) ; if ( method == null ) { method = VAR_1 . METHOD_3 ( STRING_1 ) ; VAR_2 . put ( VAR_1 , method ) ; } return ( TYPE_1 . Builder ) method . VAR_3 ( VAR_1 ) ; } catch ( Exception ex ) { throw new TYPE_3 ( STRING_2 + VAR_1 , ex ) ; } } 
public TYPE_4 ( TYPE_2 . TYPE_3 . VAR_2 . TYPE_5 VAR_4 ) { <START> this ( false , VAR_4 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 method = TYPE_1 . METHOD_2 ( this . VAR_1 . METHOD_1 ( ) ) ; <START> Assert . VAR_2 ( method , STRING_1 ) ; <END> return method ; } 
public TYPE_1 METHOD_1 ( ) { <START> return ( VAR_1 != null ) ? VAR_1 : TYPE_1 . VAR_2 ; <END> } 
protected void METHOD_1 ( TYPE_1 context , TYPE_2 VAR_1 ) { context . VAR_2 ( ) . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; TYPE_3 . METHOD_4 ( context , VAR_1 . METHOD_5 ( ) ) ; TYPE_3 . METHOD_6 ( context , VAR_1 . METHOD_7 ( ) ) ; METHOD_8 ( context , VAR_1 ) ; for ( TYPE_4 VAR_3 : VAR_1 . METHOD_9 ( ) ) { VAR_3 . METHOD_1 ( context , VAR_1 ) ; <START> } <END> } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return this . VAR_1 ; <END> } 
protected TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_3 < TYPE_2 > VAR_1 = new TYPE_3 < > ( ) ; <START> if ( this . VAR_2 != null ) { <END> for ( TYPE_2 VAR_3 : this . VAR_2 ) { try { VAR_3 . METHOD_2 ( ) ; VAR_1 . add ( VAR_3 ) ; } catch ( TYPE_4 e ) { } } } return VAR_1 ; } 
private TYPE_2 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
public long length ( ) throws IOException { <START> return exists ( ) ? METHOD_1 ( ) . length ( ) : - 1 ; <END> } 
public long offset ( ) throws IOException { <START> return exists ( ) ? writer ( ) . METHOD_1 ( ) : 0 ; <END> } 
public void METHOD_1 ( final Object o ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 == null ) { <END> return ; } VAR_1 . METHOD_1 ( o ) ; } 
public TYPE_1 METHOD_1 ( final Object o ) { <START> if ( ! ( o instanceof TYPE_2 ) || ! ( o instanceof TYPE_3 ) ) { <END> return null ; } final String id = ( ( TYPE_2 ) o ) . METHOD_2 ( ) ; final String url = ( ( TYPE_3 ) o ) . METHOD_3 ( ) ; if ( ! VAR_1 . containsKey ( id ) ) VAR_1 . put ( id , new TYPE_1 ( id , url ) ) ; return VAR_1 . get ( id ) ; } 
public static void METHOD_1 ( String name , double VAR_1 , int VAR_2 ) { <START> METHOD_2 ( name , STRING_1 , String . format ( STRING_2 , VAR_1 , VAR_2 ) ) ; <END> } 
public int METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) == null ) { <START> if ( VAR_2 . METHOD_2 ( ) == null ) <END> return 0 ; else return - 1 ; } else { if ( VAR_2 . METHOD_2 ( ) == null ) return 1 ; else return VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 . METHOD_2 ( ) ) ; } } 
private static void log ( Level VAR_1 , Throwable ex , String msg , Object ... data ) { <START> VAR_2 . log ( VAR_1 , ( ) - > data == null ? msg : String . format ( msg , data ) , ex ) ; <END> } 
public static int [ ] METHOD_1 ( Object VAR_1 ) { if ( VAR_1 instanceof int [ ] ) <START> return ( int [ ] ) VAR_1 ; <END> else if ( VAR_1 instanceof byte [ ] ) return METHOD_1 ( ( byte [ ] ) VAR_1 ) ; else return new int [ 0 ] ; } 
private String [ ] METHOD_1 ( Object content ) { String [ ] VAR_1 = null ; if ( content instanceof List ) { VAR_1 = from ( ( List < String > ) content ) . METHOD_2 ( String . VAR_2 ) ; } else { VAR_1 = new String [ ] { ( String ) content } ; } <START> return VAR_1 ; <END> } 
public void METHOD_1 ( List < String > VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
<START> public static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { <END> return VAR_2 . get ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . VAR_4 ) ) ; } 
private void METHOD_1 ( final TYPE_1 result ) { if ( result != null && result . VAR_1 ( ) != null ) { String VAR_2 = METHOD_2 ( result . VAR_1 ( ) ) ; String VAR_3 = METHOD_2 ( result . VAR_4 ( ) ) ; <START> Logger . i ( TAG , STRING_1 , String . format ( <END> STRING_2 , VAR_2 , VAR_3 ) ) ; } } 
} catch ( TYPE_1 e ) { <START> throw new RuntimeException ( e ) ; <END> } 
<START> public void METHOD_1 ( final TYPE_1 VAR_1 , final boolean VAR_2 ) { <END> if ( VAR_2 ) { VAR_3 = new TYPE_2 ( VAR_1 ) ; } else { VAR_3 = new TYPE_3 ( VAR_1 ) ; } } 
public TYPE_1 [ ] METHOD_1 ( ) throws TYPE_2 , TYPE_3 , IOException { if ( TYPE_4 . METHOD_2 ( ) == TYPE_4 . METHOD_3 ( ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( METHOD_4 ( ) ) { return TYPE_5 . getInstance ( ) . METHOD_1 ( VAR_1 ) ; <START> } else { <END> return METHOD_5 ( ) ; } } 
TYPE_3 ( final Context context , final TYPE_1 VAR_2 , final TYPE_2 VAR_3 ) { VAR_4 = context ; VAR_5 = VAR_3 ; VAR_6 = VAR_2 ; if ( VAR_5 != null ) { <START> VAR_5 . METHOD_1 ( VAR_2 ) ; <END> } } 
void METHOD_1 ( final String VAR_1 , final TYPE_1 VAR_2 ) { List < TYPE_1 > VAR_3 = METHOD_2 ( VAR_1 ) ; if ( VAR_3 == null ) { VAR_3 = new ArrayList < > ( ) ; } VAR_3 . add ( VAR_2 ) ; METHOD_3 ( ) . put ( VAR_1 , VAR_3 ) ; <START> METHOD_4 ( ) ; <END> } 
TYPE_1 METHOD_1 ( final String resource , final String VAR_1 , final String user ) { <START> TYPE_2 VAR_2 = METHOD_2 ( TYPE_5 . VAR_4 ) ; <END> final String VAR_5 = TYPE_3 . METHOD_3 ( VAR_6 , resource , VAR_1 , user ) ; final TYPE_1 item = VAR_7 . METHOD_4 ( VAR_5 ) ; if ( item != null ) { VAR_2 . METHOD_5 ( true ) ; } TYPE_4 . getInstance ( ) . METHOD_6 ( VAR_8 , VAR_2 , TYPE_5 . VAR_9 ) ; return item ; } 
private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } return new TYPE_1 ( ) { <START> TYPE_2 VAR_2 = VAR_1 ; <END> @Override public void METHOD_2 ( TYPE_3 VAR_3 , int VAR_4 ) { if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( VAR_3 , VAR_4 ) ; } } } ; } 
private TYPE_1 METHOD_1 ( final String VAR_1 , final String resource , final String VAR_2 , final boolean VAR_3 ) { final TYPE_1 VAR_4 = new TYPE_1 ( VAR_1 , resource , VAR_2 , VAR_3 ) ; <START> return VAR_4 ; <END> } 
public void METHOD_1 ( ) throws IllegalArgumentException , TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 { assertTrue ( STRING_1 , TYPE_6 . METHOD_2 ( "" ) ) ; <START> assertTrue ( STRING_1 , TYPE_6 . METHOD_2 ( STRING_2 ) ) ; <END> assertTrue ( STRING_1 , TYPE_6 . METHOD_2 ( STRING_3 ) ) ; } 
<START> public boolean METHOD_1 ( ) { <END> if ( VAR_1 ) { return TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) ; } else { return TYPE_1 . METHOD_2 ( METHOD_4 ( ) ) ; } } 
TYPE_2 ( String VAR_2 , String VAR_3 , Date VAR_4 , boolean VAR_5 , TYPE_1 VAR_6 , String VAR_7 , String VAR_8 , Date VAR_9 ) { VAR_10 = null ; VAR_11 = VAR_2 ; VAR_12 = VAR_3 ; VAR_13 = VAR_4 ; VAR_14 = VAR_5 ; VAR_15 = TYPE_3 . TYPE_4 ; VAR_18 = VAR_6 ; VAR_19 = VAR_7 ; VAR_20 = VAR_8 ; <START> if ( VAR_9 != null ) { <END> VAR_21 = VAR_9 ; } } 
final void METHOD_1 ( final boolean VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
final void METHOD_1 ( final Date VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
<START> final public boolean METHOD_1 ( ) { <END> return VAR_1 ; } 
final public Date METHOD_1 ( ) { <START> return this . VAR_1 ; <END> } 
final Date METHOD_1 ( ) { <START> return this . VAR_1 ; <END> } 
public TYPE_1 ( String msg , Throwable VAR_2 ) { super ( TYPE_2 . VAR_4 , msg , VAR_2 ) ; <START> } <END> 
protected void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; METHOD_2 ( ) . METHOD_3 ( ) ; System . VAR_1 ( STRING_1 , METHOD_2 ( ) . METHOD_3 ( ) . getPath ( ) ) ; METHOD_2 ( ) . METHOD_3 ( ) ; <START> System . VAR_1 ( STRING_1 , METHOD_2 ( ) . METHOD_3 ( ) . getPath ( ) ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( ) . METHOD_3 ( VAR_1 , 0 ) ; <START> return ( VAR_2 != null ) ; <END> } 
private boolean METHOD_1 ( ) { ANNOTATION_1 ( STRING_1 ) Class < TYPE_1 > VAR_1 = ( Class < TYPE_1 > ) TYPE_3 . TYPE_4 . METHOD_2 ( ) ; <START> return ( VAR_1 != null ) ; <END> } 
private TYPE_1 METHOD_1 ( Class < TYPE_1 > VAR_1 ) throws TYPE_2 { <START> TYPE_1 VAR_2 ; <END> TYPE_3 < ? > VAR_3 ; try { VAR_3 = VAR_1 . METHOD_2 ( ) ; VAR_2 = ( TYPE_1 ) VAR_3 . METHOD_3 ( ( Object [ ] ) null ) ; } catch ( TYPE_4 | TYPE_5 | TYPE_6 | IllegalArgumentException | TYPE_7 e ) { throw new TYPE_2 ( TYPE_8 . VAR_5 , STRING_1 , e ) ; } return VAR_2 ; } 
public List < TYPE_1 > METHOD_1 ( String resource ) { Iterator < TYPE_1 > results = this . METHOD_2 ( ) ; <START> List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; <END> while ( results . hasNext ( ) ) { final TYPE_1 VAR_2 = results . next ( ) ; if ( resource . equals ( VAR_2 . METHOD_3 ( ) ) ) { VAR_1 . add ( VAR_2 ) ; } } return VAR_1 ; } 
public List < TYPE_1 > METHOD_1 ( String VAR_1 ) { Iterator < TYPE_1 > results = this . METHOD_2 ( ) ; <START> List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; <END> while ( results . hasNext ( ) ) { final TYPE_1 VAR_3 = results . next ( ) ; if ( VAR_3 . METHOD_3 ( ) != null && VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) . equalsIgnoreCase ( VAR_1 ) ) { VAR_2 . add ( VAR_3 ) ; } } return VAR_2 ; } 
private boolean METHOD_1 ( Date VAR_1 ) { Date VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; <START> return ( VAR_1 != null && VAR_1 . METHOD_4 ( VAR_2 ) ) ; <END> } 
private static HashMap < String , String > METHOD_1 ( final String VAR_1 ) throws TYPE_1 { final TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; <START> final HashMap < String , String > VAR_3 = new HashMap < > ( ) ; <END> final Iterator < ? > i = VAR_2 . METHOD_2 ( ) ; while ( i . hasNext ( ) ) { final String key = ( String ) i . next ( ) ; VAR_3 . put ( key , VAR_2 . getString ( key ) ) ; } return VAR_3 ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException , TYPE_2 { <START> String VAR_2 ; <END> if ( VAR_3 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } try { VAR_2 = METHOD_2 ( VAR_1 ) ; } catch ( TYPE_3 VAR_4 ) { Logger . e ( TAG , VAR_4 . getMessage ( ) , "" , TYPE_4 . VAR_6 , VAR_4 ) ; return null ; } HashMap < String , String > VAR_7 = METHOD_3 ( ) ; return METHOD_4 ( VAR_2 , VAR_7 ) ; } 
private HashMap < String , String > METHOD_1 ( ) { <START> HashMap < String , String > VAR_1 = new HashMap < > ( ) ; <END> VAR_1 . put ( STRING_1 , STRING_2 ) ; return VAR_1 ; } 
private TYPE_1 METHOD_1 ( final String VAR_1 ) throws TYPE_2 , TYPE_3 { <START> HashMap < String , String > VAR_2 = new HashMap < > ( ) ; <END> METHOD_2 ( VAR_2 , VAR_1 ) ; return METHOD_3 ( VAR_2 ) ; } 
private boolean METHOD_1 ( final String user , final TYPE_1 VAR_1 ) { if ( ! TYPE_2 . METHOD_2 ( user ) ) { <START> return ! user . equalsIgnoreCase ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) <END> && ! user . equalsIgnoreCase ( VAR_1 . METHOD_3 ( ) . METHOD_5 ( ) ) ; } return false ; } 
private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } final String VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . TYPE_4 . VAR_5 ) ; return ! TYPE_2 . METHOD_3 ( VAR_2 ) <START> && TYPE_3 . TYPE_4 . VAR_6 . equalsIgnoreCase ( VAR_2 ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { return VAR_1 == TYPE_1 . TYPE_2 || VAR_1 == TYPE_1 . VAR_3 <START> || TYPE_1 . VAR_4 == VAR_1 ; <END> } 
public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) VAR_2 . METHOD_2 ( Context . VAR_3 ) ; TYPE_2 VAR_4 = VAR_1 . METHOD_3 ( ) ; boolean VAR_5 = VAR_4 != null && VAR_4 . METHOD_4 ( ) ; <START> return VAR_5 ; <END> } 
private synchronized TYPE_1 getKey ( final String VAR_1 ) throws TYPE_2 , IOException { switch ( VAR_1 ) { case VAR_2 : return METHOD_1 ( TYPE_4 . TYPE_5 . METHOD_2 ( ) ) ; case VAR_3 : <START> if ( TYPE_6 . VAR_5 . VAR_6 >= INT_1 ) { <END> VAR_7 = METHOD_3 ( ) ; VAR_8 = METHOD_4 ( ) ; return VAR_8 ; } default : throw new IOException ( STRING_1 ) ; } } 
<START> private String METHOD_1 ( String value ) { <END> try { return METHOD_2 ( ) . METHOD_1 ( VAR_1 , value ) ; } catch ( TYPE_1 | IOException e ) { Logger . e ( TAG , STRING_1 , "" , TYPE_2 . VAR_3 , e ) ; } return null ; } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> synchronized ( VAR_1 ) { if ( VAR_2 == null ) { Logger . v ( TAG , STRING_1 ) ; VAR_2 = new TYPE_1 ( VAR_3 ) ; Logger . v ( TAG , STRING_2 ) ; } } return VAR_2 ; } 
public TYPE_1 [ ] METHOD_1 ( ) throws TYPE_2 , TYPE_3 , IOException { if ( VAR_1 != null ) { <START> return VAR_1 . METHOD_1 ( ) ; <END> } return null ; } 
public boolean METHOD_1 ( ) { return METHOD_2 ( ) <START> && METHOD_3 ( VAR_1 ) <END> && ! VAR_2 . METHOD_4 ( ) . equalsIgnoreCase ( TYPE_2 . TYPE_3 . METHOD_5 ( ) ) ; } 
<START> public void METHOD_1 ( String VAR_1 ) { <END> if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) return ; TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_4 , TYPE_3 . VAR_6 ) ; String VAR_7 = VAR_2 . getString ( VAR_8 , "" ) ; VAR_7 += VAR_9 + VAR_1 ; TYPE_2 VAR_10 = VAR_2 . METHOD_3 ( ) ; VAR_10 . METHOD_4 ( VAR_8 , VAR_7 ) ; VAR_10 . apply ( ) ; } 
private String METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { if ( ! TYPE_1 . METHOD_2 ( VAR_2 ) && ! TYPE_1 . METHOD_2 ( VAR_3 ) ) { try { return VAR_1 + STRING_1 + TYPE_2 . METHOD_3 ( VAR_2 , TYPE_4 . VAR_5 ) <START> + STRING_2 + VAR_3 ; <END> } catch ( TYPE_3 e ) { Log . e ( TAG , STRING_3 , e ) ; } } return VAR_1 ; } 
<START> public int METHOD_1 ( final String VAR_1 ) { <END> int VAR_2 = 0 ; try { TYPE_1 info = VAR_3 . METHOD_2 ( ) . METHOD_3 ( VAR_1 , 0 ) ; VAR_2 = info . VAR_4 ; } catch ( TYPE_2 e ) { Logger . e ( TAG , STRING_1 + VAR_1 + STRING_2 , "" , TYPE_3 . VAR_6 , e ) ; } return VAR_2 ; } 
private TYPE_1 METHOD_1 ( TYPE_1 [ ] VAR_1 , String VAR_2 ) { if ( VAR_1 != null ) { for ( TYPE_1 VAR_3 : VAR_1 ) { <START> if ( VAR_3 . name . equals ( VAR_2 ) ) { <END> return VAR_3 ; } } } return null ; } 
public static TYPE_1 get ( TYPE_2 VAR_1 , TYPE_3 < ? extends TYPE_4 > VAR_2 ) { ArrayList < TYPE_4 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_4 VAR_4 : VAR_2 ) { VAR_3 . add ( VAR_4 ) ; } <START> return get ( VAR_1 , VAR_3 . METHOD_1 ( new TYPE_4 [ 0 ] ) ) ; <END> } 
public static Builder builder ( String VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 . METHOD_1 ( VAR_1 , STRING_1 ) ; <START> TYPE_2 . METHOD_1 ( VAR_2 , STRING_2 ) ; <END> return new Builder ( VAR_1 , VAR_2 ) ; } 
public static Builder METHOD_1 ( String name ) { <START> return new Builder ( TYPE_2 . VAR_2 , TYPE_1 . METHOD_2 ( name , STRING_1 ) , null ) ; <END> } 
ANNOTATION_1 ANNOTATION_2 public void METHOD_1 ( ) { TYPE_1 type = TYPE_2 . of ( TYPE_3 . get ( Object . VAR_1 ) ) . METHOD_2 ( VAR_2 ) ; <START> assertThat ( type . toString ( ) ) . METHOD_3 ( STRING_1 + VAR_3 + STRING_2 ) ; <END> } 
ANNOTATION_1 public void METHOD_1 ( ) { assertThat ( TYPE_1 . get ( Object . VAR_1 ) . toString ( ) ) . METHOD_2 ( STRING_1 ) ; assertThat ( TYPE_1 . get ( TYPE_3 . TYPE_4 . class ) . toString ( ) ) . METHOD_2 ( STRING_2 ) ; try { assertThat ( ( TYPE_1 . get ( new Object ( ) { } . getClass ( ) ) ) . toString ( ) ) . METHOD_2 ( STRING_3 ) ; } catch ( IllegalArgumentException e ) { <START> METHOD_3 ( ) ; <END> } } 
TYPE_4 ( TYPE_1 VAR_2 , List < TYPE_2 > VAR_3 , List < TYPE_3 > VAR_4 ) { this ( VAR_2 , <START> VAR_2 . METHOD_1 ( ) != null ? VAR_2 . METHOD_1 ( ) : VAR_2 , <END> VAR_2 . METHOD_1 ( ) != null ? VAR_2 . METHOD_2 ( ) : null , VAR_3 , VAR_4 ) ; } 
public Builder METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! ( VAR_2 == TYPE_3 . VAR_4 || VAR_2 == TYPE_3 . VAR_5 ) ) { <END> throw new TYPE_2 ( VAR_2 + STRING_1 ) ; } VAR_6 . add ( STRING_2 ) . METHOD_2 ( ) . add ( VAR_1 ) . METHOD_3 ( ) . add ( STRING_3 ) ; return this ; } 
public TYPE_1 build ( ) { <START> Collections . VAR_1 ( VAR_2 ) ; <END> return new TYPE_1 ( this ) ; } 
private TYPE_1 METHOD_1 ( Collection < TYPE_1 > VAR_1 , String name ) { for ( TYPE_1 VAR_2 : VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( ) . toString ( ) . equals ( name ) ) <END> return VAR_2 ; } throw new IllegalArgumentException ( name + STRING_1 + VAR_1 ) ; } 
public Builder METHOD_1 ( List < ? extends TYPE_1 > values , Entry entry ) { <START> TYPE_2 VAR_1 = new TYPE_2 ( builder ) ; <END> for ( TYPE_1 value : values ) { value . VAR_2 ( VAR_1 , new Entry ( entry . name , value ) ) ; } return builder ; } 
public Builder METHOD_1 ( ) { Builder builder = new Builder ( type , name ) ; builder . VAR_1 . add ( VAR_1 ) ; builder . VAR_2 . addAll ( VAR_2 ) ; builder . VAR_3 . addAll ( VAR_3 ) ; <START> builder . VAR_4 = VAR_4 ; <END> return builder ; } 
<START> public Builder ( String VAR_1 , TYPE_1 VAR_2 ) { <END> this . VAR_1 = METHOD_1 ( VAR_1 , STRING_1 ) ; this . VAR_2 = METHOD_1 ( VAR_2 , STRING_2 ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( VAR_2 ) ; <START> VAR_1 . METHOD_3 ( VAR_3 ) ; <END> VAR_1 . METHOD_1 ( STRING_1 , type , name ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 . isPresent ( ) ) { throw new IllegalStateException ( STRING_1 + METHOD_2 ( VAR_2 . get ( ) ) ) ; } <START> METHOD_3 ( ! VAR_3 , STRING_2 ) ; <END> VAR_2 = Optional . of ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 parameters ) { <START> this . VAR_1 = Optional . of ( parameters ) ; <END> } 
private void METHOD_1 ( Set < TYPE_1 > VAR_1 ) throws IOException { if ( ! ( VAR_1 instanceof TYPE_2 ) ) { if ( VAR_1 . isEmpty ( ) ) VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; else VAR_1 = TYPE_2 . METHOD_3 ( VAR_1 ) ; } <START> for ( TYPE_1 VAR_2 : VAR_1 ) { <END> out . append ( VAR_2 . toString ( ) ) . append ( CHAR_1 ) ; } } 
public void METHOD_1 ( ) { this . view . VAR_1 ( ) ; this . view . VAR_2 ( ) ; <START> this . METHOD_2 ( ) . METHOD_3 ( ) . remove ( this . view ) ; <END> this . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; this . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_5 ( ) ; this . VAR_3 = null ; this . VAR_4 = null ; this . VAR_5 = null ; this . view = null ; } 
public static String METHOD_1 ( boolean VAR_1 ) throws IOException , InterruptedException { <START> if ( VAR_2 != null ) <END> return VAR_2 ; String command = STRING_1 ; if ( VAR_1 ) command = command + STRING_2 ; TYPE_1 p = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( command ) ; TYPE_3 input = new TYPE_3 ( new TYPE_4 ( p . VAR_3 ( ) ) ) ; p . VAR_4 ( ) ; VAR_2 = input . VAR_5 ( ) ; return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 stream ) { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_1 ( stream ) ; <END> } } 
private void METHOD_1 ( HashMap < String , Object > VAR_1 , TYPE_1 VAR_2 ) { <START> HashMap < String , Object > TYPE_2 = new HashMap < > ( ) ; <END> TYPE_2 . put ( STRING_1 , VAR_2 . METHOD_2 ( ) * INT_1 / INT_2 ) ; VAR_1 . put ( STRING_2 , TYPE_2 ) ; } 
protected void METHOD_1 ( String VAR_1 , final TYPE_1 VAR_2 ) { logger . debug ( STRING_1 + VAR_1 + STRING_2 ) ; <START> TYPE_2 VAR_3 = null ; <END> synchronized ( VAR_4 ) { if ( VAR_4 . containsKey ( VAR_1 ) ) { VAR_3 = VAR_4 . get ( VAR_1 ) ; VAR_3 . METHOD_2 ( ) ; } else { logger . error ( STRING_3 + VAR_1 + STRING_4 ) ; } } } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 , TYPE_3 { byte [ ] VAR_2 = TYPE_4 . METHOD_2 ( VAR_1 ) ; TYPE_5 VAR_3 = TYPE_5 . getInstance ( VAR_4 , VAR_5 ) ; TYPE_6 VAR_6 ; <START> VAR_6 = TYPE_7 . METHOD_3 ( VAR_7 ) ; <END> TYPE_8 VAR_8 = VAR_6 . METHOD_4 ( ) ; TYPE_9 VAR_9 = VAR_8 . METHOD_5 ( VAR_2 ) ; TYPE_10 VAR_10 = new TYPE_10 ( VAR_9 , VAR_6 ) ; return VAR_3 . METHOD_6 ( VAR_10 ) ; } 
private void METHOD_1 ( ) { <START> VAR_1 = TYPE_1 . METHOD_2 ( ) ; <END> VAR_2 = new TYPE_2 ( VAR_3 ) ; VAR_1 . execute ( VAR_2 ) ; logger . debug ( STRING_1 , TYPE_2 . class ) ; } 
public void METHOD_1 ( String message ) { <START> TYPE_1 . logger . warn ( format ( message ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( null ) ; <START> METHOD_3 ( VAR_1 ) ; <END> VAR_2 . METHOD_4 ( VAR_1 ) ; } 
<START> private TYPE_1 < TYPE_2 > METHOD_1 ( boolean VAR_1 ) { <END> return VAR_1 ? new TYPE_3 ( ) : null ; } 
<START> private TYPE_1 [ ] METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <END> return Arrays . stream ( VAR_1 ) . map ( TYPE_1 : : METHOD_1 ) . METHOD_2 ( TYPE_1 [ ] : : new ) ; } 
default TYPE_1 [ ] VAR_2 ( ) { <START> return null ; <END> } 
default TYPE_1 VAR_2 ( TYPE_2 result ) { <START> return null ; <END> } 
<START> private long time ( TYPE_1 VAR_1 ) { <END> return VAR_1 . METHOD_1 ( ) - VAR_1 . METHOD_2 ( ) ; } 
private List < TYPE_1 > METHOD_1 ( ) { final List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( ) ; final List < TYPE_1 > VAR_2 = this . VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ; <START> if ( VAR_2 != null ) <END> VAR_1 . addAll ( VAR_2 ) ; final List < TYPE_1 > VAR_4 = this . VAR_3 . METHOD_4 ( ) ; if ( VAR_4 != null ) VAR_1 . addAll ( VAR_4 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = create ( TYPE_2 . class ) ; TYPE_3 VAR_2 = new TYPE_3 ( ) ; <START> VAR_1 . METHOD_2 ( ( TYPE_4 ) VAR_2 ) ; <END> VAR_1 . run ( ) ; Assert . assertEquals ( VAR_2 . METHOD_3 ( ) , 1 ) ; } 
default void VAR_1 ( TYPE_1 VAR_3 ) { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } 
<START> default void VAR_1 ( ) { <END> throw new TYPE_1 ( STRING_1 ) ; } 
<START> public String [ ] METHOD_1 ( ) { <END> String [ ] result = new String [ 0 ] ; TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( METHOD_3 ( ) , TYPE_1 . class ) ; if ( VAR_1 != null ) { result = VAR_1 . METHOD_1 ( ) ; } return result ; } 
public void METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = METHOD_2 ( TYPE_3 . class ) ; assertThat ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( 2 ) ; <START> assertThat ( VAR_1 . METHOD_5 ( ) . isEmpty ( ) ) ; <END> } 
private String [ ] METHOD_1 ( Class < ? extends TYPE_1 > VAR_1 , String [ ] VAR_2 ) { <START> TYPE_1 VAR_3 = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) , VAR_1 ) ; <END> if ( VAR_2 == null || VAR_2 . length == 0 ) { VAR_2 = null != VAR_3 ? VAR_3 . METHOD_5 ( ) : null ; } return VAR_2 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = create ( TYPE_2 . class ) ; TYPE_3 VAR_2 = new TYPE_3 ( ) ; TYPE_4 listener = new TYPE_4 ( ) ; VAR_1 . METHOD_2 ( ( TYPE_5 ) VAR_2 ) ; VAR_1 . METHOD_2 ( listener ) ; <START> VAR_1 . run ( ) ; <END> assertThat ( VAR_2 . METHOD_3 ( ) ) . size ( ) . METHOD_4 ( 1 ) ; assertThat ( VAR_2 . METHOD_5 ( ) ) . size ( ) . METHOD_4 ( 2 ) ; } 
private Map < String , String > METHOD_1 ( List < String > VAR_1 ) { <START> return TYPE_1 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = METHOD_2 ( TYPE_3 . class ) ; assertThat ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( 2 ) ; <START> for ( Map . Entry < TYPE_2 , List < TYPE_1 . TYPE_5 < TYPE_2 > > > VAR_2 : VAR_1 . METHOD_5 ( ) . entrySet ( ) ) { <END> assertThat ( VAR_2 . getValue ( ) ) . isEmpty ( ) ; } } 
public boolean METHOD_1 ( List < String > VAR_1 ) { <START> for ( String name : VAR_1 ) { <END> if ( getName ( ) . equals ( name ) ) { return true ; } } return false ; } 
public static boolean METHOD_1 ( String uri ) { TYPE_1 VAR_1 = METHOD_2 ( uri ) ; if ( VAR_1 == null ) { <START> VAR_1 = new File ( uri ) . METHOD_3 ( ) ; <END> } String VAR_2 = VAR_1 . METHOD_4 ( ) ; return VAR_2 == null || STRING_1 . equalsIgnoreCase ( VAR_2 ) ; } 
<START> public String METHOD_1 ( ) { <END> return this . VAR_1 ; } 
private static Throwable METHOD_1 ( TYPE_1 context ) { Throwable t = null ; for ( TYPE_2 method : context . VAR_1 ( ) . METHOD_2 ( ) ) { TYPE_3 m = method . VAR_2 ( ) ; if ( m . VAR_3 ( ) && ( ! method . VAR_4 ( ) . METHOD_3 ( ) ) ) { return method . VAR_4 ( ) . METHOD_4 ( ) ; } } <START> return t ; <END> } 
public Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] { <START> { TYPE_1 . class , INT_1 } , <END> { TYPE_2 . class , 4 } , { TYPE_3 . class , INT_1 } } ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = create ( TYPE_2 . class ) ; VAR_1 . run ( ) ; <START> assertEquals ( VAR_1 . getStatus ( ) , 5 ) ; <END> } 
private static boolean METHOD_1 ( Collection < String > VAR_1 , String ... VAR_2 ) { <START> boolean VAR_3 = ( VAR_2 == null || VAR_2 . length == 0 ) ; <END> if ( ! VAR_1 . isEmpty ( ) && VAR_3 ) { return true ; } return METHOD_2 ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = create ( TYPE_2 . class ) ; VAR_1 . METHOD_2 ( ( TYPE_3 ) new TYPE_4 ( ) ) ; VAR_1 . run ( ) ; <START> TYPE_5 . assertThat ( TYPE_2 . VAR_2 ) . METHOD_3 ( STRING_1 , STRING_2 , STRING_1 ) ; <END> } 
<START> private static boolean METHOD_1 ( String [ ] VAR_1 , Collection < String > VAR_2 , boolean VAR_3 ) { <END> if ( VAR_3 ) { return METHOD_2 ( VAR_1 , VAR_2 ) ; } if ( VAR_2 . size ( ) == 0 ) { return true ; } else { return METHOD_2 ( VAR_1 , VAR_2 ) ; } } 
<START> static public void assertEquals ( byte [ ] VAR_1 , byte [ ] VAR_2 ) { <END> assertEquals ( VAR_1 , VAR_2 , "" ) ; } 
public static TYPE_1 [ ] METHOD_1 ( Class < ? > VAR_1 ) { TYPE_1 [ ] VAR_2 = VAR_1 . METHOD_2 ( ) ; List < TYPE_1 > VAR_3 = new TYPE_2 < > ( ) ; for ( TYPE_1 VAR_4 : VAR_2 ) { if ( STRING_1 . equals ( VAR_4 . getName ( ) ) && METHOD_3 ( VAR_4 ) && METHOD_4 ( VAR_4 ) ) { continue ; } VAR_3 . add ( VAR_4 ) ; } <START> return VAR_3 . METHOD_5 ( new TYPE_1 [ 0 ] ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; VAR_1 . METHOD_3 ( true ) ; METHOD_4 ( VAR_1 , STRING_2 , TYPE_2 . class ) ; <START> TYPE_3 VAR_2 = create ( ) ; <END> VAR_2 . METHOD_5 ( Collections . VAR_3 ( VAR_1 ) ) ; VAR_2 . run ( ) ; Assert . assertEquals ( VAR_2 . getStatus ( ) , 0 ) ; } 
private static Map < String , String > getParameters ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_1 ( ) . METHOD_2 ( ) ; <START> Map < String , String > params = VAR_2 . METHOD_3 ( ) ; <END> params . VAR_3 ( VAR_1 . METHOD_1 ( ) . METHOD_4 ( VAR_2 ) ) ; return params ; } 
<START> private String METHOD_1 ( TYPE_1 method ) { <END> return method . VAR_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) + STRING_1 + method . VAR_2 ( ) ; } 
private void METHOD_1 ( Class < ? > VAR_1 , Object instance ) { <START> synchronized ( this ) { <END> Set < Object > VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_2 = TYPE_1 . METHOD_2 ( ) ; VAR_3 . put ( VAR_1 , VAR_2 ) ; } VAR_2 . add ( instance ) ; } } 
public String toString ( ) { <START> return name ( ) . METHOD_1 ( ) ; <END> } 
private void METHOD_1 ( ) { if ( null == VAR_1 ) { return ; } for ( TYPE_1 s : VAR_1 ) { if ( VAR_2 ) { <START> s . VAR_3 ( VAR_4 ) ; <END> } s . VAR_5 ( VAR_6 ) ; if ( VAR_7 != null ) { s . VAR_8 ( VAR_7 . toString ( ) ) ; } } } 
private static List < TYPE_1 > METHOD_1 ( Class < ? > VAR_1 ) { <START> List < TYPE_1 > result = null ; <END> for ( Class < ? > VAR_2 : VAR_1 . METHOD_2 ( ) ) { for ( TYPE_1 VAR_3 : VAR_2 . METHOD_3 ( ) ) { if ( ! TYPE_2 . METHOD_4 ( VAR_3 . METHOD_5 ( ) ) ) { if ( result == null ) { result = new TYPE_3 < TYPE_1 > ( ) ; } result . add ( VAR_3 ) ; } } } return result ; } 
public Object [ ] next ( ) { <START> if ( VAR_1 < VAR_2 . length ) { <END> return VAR_2 [ VAR_1 ++ ] ; } else { throw new TYPE_1 ( ) ; } } 
<START> public static void METHOD_1 ( int n ) { <END> VAR_1 = n ; } 
<START> public static int METHOD_1 ( List < TYPE_1 > VAR_1 ) { <END> log . debug ( STRING_1 ) ; TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( ) ; VAR_1 . forEach ( VAR_3 - > { TYPE_4 task = new TYPE_4 ( VAR_3 ) ; log . debug ( STRING_2 , task ) ; VAR_2 . METHOD_3 ( task ) ; } ) ; log . debug ( STRING_3 , VAR_1 . size ( ) ) ; VAR_2 . METHOD_4 ( ) ; return VAR_1 . size ( ) ; } 
<START> public synchronized long METHOD_1 ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( ) throws IOException { if ( VAR_1 != - 1 ) { if ( VAR_2 != null ) { <START> METHOD_2 ( ) . METHOD_3 ( ) ; <END> VAR_2 . close ( ) ; VAR_2 = null ; VAR_3 = null ; } METHOD_4 ( VAR_4 ) ; VAR_5 . clear ( ) ; VAR_4 . clear ( ) ; VAR_6 . clear ( ) ; VAR_1 = - 1 ; } else { METHOD_4 ( VAR_4 ) ; } size = 0 ; } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ) ; <START> TYPE_1 . METHOD_3 ( this ) ; <END> super . METHOD_1 ( ) ; } 
public TYPE_5 ( String VAR_2 , String configuration , String VAR_3 ) { File file = TYPE_1 . METHOD_1 ( VAR_2 , configuration , VAR_3 ) ; TYPE_2 p = new TYPE_2 ( ) ; TYPE_3 VAR_4 = null ; try { VAR_4 = new TYPE_3 ( file ) ; p . VAR_5 ( VAR_4 ) ; properties = p ; } catch ( IOException e ) { throw new IllegalStateException ( STRING_1 , e ) ; } finally { <START> if ( VAR_4 != null ) { <END> TYPE_4 . METHOD_2 ( VAR_4 ) ; } } } 
public String METHOD_1 ( ) { <START> return STRING_1 ; <END> } 
private boolean METHOD_1 ( Map . Entry < String , String > VAR_1 ) { if ( VAR_1 . getValue ( ) . contains ( STRING_1 . METHOD_2 ( VAR_1 . getKey ( ) ) . METHOD_2 ( STRING_2 ) ) ) { return true ; } <START> if ( VAR_1 . getValue ( ) . contains ( STRING_3 . METHOD_2 ( VAR_1 . getKey ( ) ) ) ) { <END> return true ; } return false ; } 
private static String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) { TYPE_1 . TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; return VAR_2 . METHOD_1 ( ) ; <START> } else if ( VAR_1 instanceof TYPE_4 ) { <END> TYPE_1 . TYPE_4 VAR_3 = ( TYPE_4 ) VAR_1 ; return VAR_3 . METHOD_1 ( ) ; } return null ; } 
private static String METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 instanceof TYPE_2 ) { <END> TYPE_1 . TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; return VAR_2 . METHOD_1 ( ) ; } return null ; } 
public void METHOD_1 ( ) { VAR_1 = null ; <START> VAR_2 = new TYPE_1 ( ) ; <END> VAR_3 = new TYPE_2 ( ) ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) . getInstance ( ) ; final TYPE_2 < TYPE_3 > VAR_2 = VAR_1 . METHOD_4 ( ) ; <START> assertTrue ( VAR_2 . iterator ( ) . hasNext ( ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { version = TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 , STRING_2 ) ; String VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 , STRING_3 ) ; if ( VAR_3 != null ) try { VAR_4 = TYPE_4 . METHOD_3 ( VAR_3 ) ; } catch ( TYPE_5 e ) { <START> throw new TYPE_2 ( String . format ( STRING_4 , VAR_3 ) , e ) ; <END> } METHOD_4 ( VAR_1 ) ; VAR_5 = METHOD_5 ( VAR_1 ) ; } 
public static void METHOD_1 ( String [ ] args ) throws Exception { TYPE_1 VAR_1 = TYPE_2 . METHOD_1 ( args , props ) ; TYPE_2 . METHOD_2 ( VAR_1 , props ) ; if ( VAR_1 . METHOD_3 ( ) ) { return ; } if ( VAR_2 != null ) { METHOD_4 ( VAR_2 ) ; } <START> if ( VAR_3 && VAR_4 <= VAR_5 ) { <END> throw new RuntimeException ( STRING_1 ) ; } TYPE_2 . METHOD_5 ( ) ; } 
private static String [ ] METHOD_1 ( String [ ] VAR_1 ) { List < String > VAR_2 = new ArrayList ( Arrays . asList ( VAR_1 ) ) ; VAR_2 . METHOD_2 ( Collections . VAR_3 ( null ) ) ; <START> return VAR_2 . METHOD_3 ( new String [ 0 ] ) ; <END> } 
public static List < TYPE_1 > METHOD_1 ( Collection < TYPE_1 > VAR_1 , String VAR_2 ) { List < TYPE_1 > VAR_3 = new ArrayList < TYPE_1 > ( ) ; <START> if ( VAR_1 != null || VAR_2 == null ) { <END> for ( TYPE_1 VAR_4 : VAR_1 ) { if ( VAR_4 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ) { VAR_3 . add ( VAR_4 ) ; } } } return VAR_3 ; } 
<START> public static void METHOD_1 ( TYPE_1 VAR_1 , <END> String VAR_2 , File VAR_3 , Logger log ) { try { VAR_1 . METHOD_2 ( VAR_3 , VAR_2 , log ) ; } catch ( TYPE_2 e ) { e . VAR_4 ( ) ; log . error ( e . VAR_5 ( ) + e . getMessage ( ) ) ; } catch ( Exception e ) { e . VAR_4 ( ) ; log . error ( e . VAR_5 ( ) + e . getMessage ( ) ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { Map < String , String > VAR_2 = new HashMap < String , String > ( ) ; VAR_2 . put ( STRING_1 , VAR_3 ) ; VAR_2 . put ( STRING_2 , STRING_3 ) ; VAR_2 . put ( STRING_4 , STRING_5 ) ; <START> return METHOD_1 ( VAR_1 , TYPE_2 . VAR_5 , new HashMap < String , String > ( ) ) ; <END> } 
<START> public static final Builder METHOD_1 ( String name ) { <END> return new Builder ( name , TYPE_1 . METHOD_2 ( ) , TYPE_1 . METHOD_3 ( ) , TYPE_2 . METHOD_4 ( ) , TYPE_2 . METHOD_5 ( ) ) ; } 
public String METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> return VAR_1 ; } else { return METHOD_2 ( ) ; } } 
public int METHOD_1 ( ) { <START> if ( VAR_1 > 0 ) { <END> return VAR_1 ; } else { return METHOD_2 ( ) ; } } 
protected void METHOD_1 ( TYPE_1 < ? > request , byte [ ] VAR_1 , byte [ ] VAR_2 , TYPE_2 VAR_3 ) { <START> if ( METHOD_2 ( request ) && this . VAR_4 ) { <END> TYPE_3 VAR_5 = new TYPE_3 ( request . VAR_6 ( ) , VAR_2 , VAR_3 . METHOD_3 ( ) , VAR_3 . METHOD_4 ( ) , TYPE_4 . METHOD_5 ( VAR_1 ) , this ) ; request . VAR_7 ( VAR_5 ) ; } } 
private static void METHOD_1 ( ) { <START> String VAR_1 = System . getProperty ( VAR_2 ) ; <END> if ( VAR_1 == null ) { TYPE_1 factory = TYPE_1 . METHOD_2 ( ) ; if ( TYPE_2 . equals ( factory . getClass ( ) . getName ( ) ) ) { System . VAR_3 ( VAR_2 , TYPE_2 ) ; } } } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { synchronized ( this ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_2 ( ) ; } } } <START> if ( TYPE_2 . TYPE_4 . equals ( VAR_2 ) ) { <END> String VAR_3 = System . VAR_4 ( TYPE_2 . VAR_5 ) ; VAR_3 = StringUtils . trim ( VAR_3 ) ; if ( ! StringUtils . VAR_6 ( VAR_3 ) ) { return VAR_1 . METHOD_1 ( VAR_3 ) ; } } return VAR_1 . METHOD_1 ( VAR_2 ) ; } 
private static int METHOD_1 ( String VAR_1 ) { int value = 0 ; int i = 0 ; for ( int j = VAR_1 . length ( ) - 1 ; j >= 0 ; j -- , i ++ ) { if ( VAR_1 . METHOD_2 ( j ) == CHAR_1 ) { <START> value += ( int ) Math . VAR_2 ( FLOAT_1 , ( double ) i ) ; <END> } } return value ; } 
protected void METHOD_1 ( byte [ ] VAR_1 , int offset , int VAR_2 ) { LOGGER . VAR_3 ( ( ) - > STRING_1 + VAR_2 + STRING_2 + VAR_4 ) ; try { VAR_5 . METHOD_2 ( ByteBuffer . VAR_6 ( VAR_1 , offset , VAR_2 ) ) ; <START> } catch ( IOException e ) { error ( e ) ; } catch ( InterruptedException e ) { <END> error ( e ) ; } } 
private List < TYPE_1 < T > > METHOD_1 ( ) { if ( VAR_1 != null ) return VAR_1 ; <START> if ( VAR_2 != null && VAR_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . VAR_4 ) < 0 ) <END> return VAR_5 ; synchronized ( METHOD_4 ( ) ) { if ( VAR_1 == null ) { List < TYPE_1 < T > > r = METHOD_5 ( ) ; r . addAll ( VAR_5 ) ; VAR_1 = METHOD_6 ( r ) ; } return VAR_1 ; } } 
public void METHOD_1 ( Set < String > VAR_1 ) { <START> this . VAR_1 = VAR_1 ; <END> } 
<START> public Set < String > METHOD_1 ( ) { <END> return VAR_1 ; } 
public Set < String > METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> return VAR_1 ; } } 
<START> public synchronized void METHOD_1 ( Set < String > VAR_1 ) { synchronized ( this . VAR_1 ) { <END> this . VAR_1 . clear ( ) ; this . VAR_1 . addAll ( VAR_1 ) ; } } 
private Object METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new ArrayList < > ( ) ; } <START> if ( ! VAR_2 . isEmpty ( ) ) { <END> VAR_1 . addAll ( VAR_2 . METHOD_2 ( ) ) ; } if ( ! VAR_1 . isEmpty ( ) ) { VAR_2 . addAll ( VAR_1 ) ; } return this ; } 
public void METHOD_1 ( TYPE_1 req , TYPE_2 VAR_1 ) throws IOException , TYPE_3 { <START> TYPE_4 . get ( ) . METHOD_2 ( TYPE_4 . VAR_2 ) ; <END> TYPE_5 . METHOD_1 ( req , VAR_1 , METHOD_3 ( ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 String VAR_1 ) throws IOException { METHOD_2 ( VAR_2 ) ; <START> this . description = description ; <END> METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( ! TYPE_2 . get ( ) . METHOD_2 ( TYPE_2 . VAR_1 ) ) return null ; <END> return new TYPE_1 ( this ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) . METHOD_3 ( STRING_2 ) . METHOD_4 ( ) ; try { VAR_1 . METHOD_5 ( ) ; METHOD_6 ( ) ; } catch ( IOException ex ) { METHOD_7 ( ex , STRING_3 , STRING_4 ) ; } <START> TYPE_2 . METHOD_8 ( VAR_2 ) ; <END> } 
public int METHOD_1 ( TYPE_1 o ) { <START> return ( Integer . VAR_1 ( this . VAR_2 , o . VAR_2 ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 < ? , ? > job , List < TYPE_2 > VAR_1 ) throws IOException , InterruptedException { for ( TYPE_2 VAR_2 : VAR_1 ) { if ( job . VAR_3 ( ) . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ) { VAR_2 . METHOD_4 ( ) . METHOD_5 ( job ) ; return ; } } <START> <END> LOGGER . log ( VAR_4 , Messages . TYPE_3 ( job . VAR_3 ( ) ) ) ; } 
public int METHOD_1 ( ) throws IOException , InterruptedException { if ( METHOD_2 ( ) == null ) { <START> return - 1 ; <END> } return channel . call ( new TYPE_1 ( false ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> j . VAR_1 . get ( ) . METHOD_2 ( ) ; <END> TYPE_1 . METHOD_3 ( j ) ; final TYPE_3 . TYPE_4 result = command . VAR_2 ( TYPE_5 . VAR_4 , TYPE_5 . VAR_5 ) . METHOD_4 ( ) ; assertThat ( result , METHOD_5 ( ) ) ; TYPE_1 . METHOD_6 ( j ) ; } 
public static final void METHOD_1 ( final TYPE_1 j ) { METHOD_2 ( ) . METHOD_3 ( INT_1 , TimeUnit . VAR_1 ) . METHOD_4 ( 10 , TimeUnit . VAR_2 ) <START> . METHOD_5 ( ( ) - > j . VAR_3 . get ( ) . METHOD_6 ( ) . METHOD_7 ( task ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 req , TYPE_2 VAR_1 , Object node ) throws IOException , TYPE_3 { if ( ! TYPE_4 . METHOD_2 ( req ) && TYPE_4 . METHOD_3 ( ) ) { <START> VAR_2 = TYPE_5 . METHOD_4 ( TYPE_6 . class ) . METHOD_5 ( this , req ) ; <END> } try { METHOD_6 ( req , VAR_1 , VAR_3 , VAR_4 , VAR_5 ) ; } catch ( InterruptedException e ) { throw new IOException ( STRING_1 , e ) ; } } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 ) throws IOException { <START> TYPE_2 . get ( ) . METHOD_2 ( TYPE_2 . VAR_2 ) ; <END> if ( VAR_1 != null ) { METHOD_3 ( true ) ; return TYPE_3 . METHOD_4 ( STRING_1 ) ; } else { return TYPE_3 . METHOD_5 ( STRING_2 ) ; } } 
public TYPE_1 METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . add ( Messages . TYPE_4 ( ) , "" ) ; for ( String id : TYPE_2 . METHOD_3 ( ) ) { if ( id . equalsIgnoreCase ( VAR_1 ) ) { VAR_2 . add ( new TYPE_3 ( id , id , true ) ) ; } else { VAR_2 . add ( id ) ; } } <START> Messages . TYPE_5 ( ) ; <END> return VAR_2 ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 request ) { <END> TYPE_3 . get ( ) . METHOD_2 ( TYPE_3 . VAR_1 ) ; final String VAR_2 = STRING_1 ; final String value = METHOD_3 ( request . VAR_3 ( STRING_2 ) ) ; if ( ! VAR_2 . equals ( value ) ) return TYPE_1 . METHOD_4 ( VAR_4 . model . Messages . TYPE_4 ( ) ) ; return TYPE_1 . METHOD_5 ( ) ; } 
public void METHOD_1 ( ) { <START> Assert . assertEquals ( 1 , TYPE_1 . VAR_2 ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { TYPE_2 < List < TYPE_3 > , TYPE_4 > VAR_1 = TYPE_5 . VAR_3 . METHOD_2 ( ) ; <START> if ( LOGGER . VAR_4 ( Level . VAR_5 ) ) LOGGER . VAR_6 ( STRING_1 ) ; <END> return METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = r . VAR_2 ( STRING_1 , "" , null ) ; TYPE_1 VAR_3 = r . VAR_2 ( STRING_1 , "" , null ) ; r . VAR_4 . METHOD_2 ( VAR_1 ) ; r . VAR_4 . METHOD_3 ( ) . METHOD_4 ( VAR_1 , VAR_3 ) ; r . VAR_4 . METHOD_3 ( ) . METHOD_5 ( ) ; <START> assertNotNull ( r . VAR_4 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ) ; <END> } 
<START> protected Object METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = true ; } if ( VAR_2 == null ) { VAR_2 = true ; } return this ; } 
public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) ; <START> if ( METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ) { return false ; } if ( METHOD_5 ( ) . METHOD_6 ( VAR_1 ) ) { return false ; } return true ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { try { if ( VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ) ) { return true ; } } catch ( TYPE_3 | TYPE_4 VAR_3 ) { } try { if ( VAR_1 . METHOD_2 ( TYPE_5 . METHOD_5 ( ) . METHOD_6 ( VAR_2 ) ) ) { return true ; } <START> } catch ( TYPE_3 VAR_3 ) { <END> } return false ; } 
public boolean METHOD_1 ( ) { <START> return ! ( TYPE_1 . get ( ) ) . METHOD_2 ( ) . contains ( id ) ; <END> } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 ) throws IOException { TYPE_3 e = new TYPE_3 ( VAR_3 . METHOD_2 ( CHAR_1 , CHAR_2 ) ) ; e . VAR_4 ( VAR_2 . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( e ) ; try ( TYPE_4 in = VAR_2 . METHOD_5 ( ) ) { TYPE_5 . METHOD_6 ( in , VAR_1 ) ; } <START> VAR_1 . METHOD_7 ( ) ; <END> } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , Map < String , TYPE_2 > VAR_3 ) throws IOException { for ( Map . Entry < String , TYPE_2 > entry : VAR_3 . entrySet ( ) ) { String n = entry . getKey ( ) ; <START> String VAR_4 ; <END> VAR_4 = VAR_2 . getName ( ) + CHAR_1 + n ; TYPE_2 f = entry . getValue ( ) ; METHOD_2 ( VAR_1 , f , VAR_4 ) ; } } 
public TYPE_1 METHOD_1 ( ) throws IOException { TYPE_2 . getInstance ( ) . METHOD_2 ( TYPE_2 . VAR_1 ) ; <START> LOGGER . info ( STRING_1 ) ; <END> clear ( ) ; return TYPE_3 . METHOD_3 ( STRING_2 ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . println ( Messages . TYPE_2 ( ) ) ; <END> } 
private Set < String > METHOD_1 ( TYPE_1 VAR_1 ) { Set < String > VAR_2 ; switch ( VAR_1 ) { case VAR_3 : VAR_2 = TYPE_2 . METHOD_2 ( this . METHOD_3 ( ) , this . METHOD_4 ( ) ) ; break ; case VAR_4 : VAR_2 = this . METHOD_3 ( ) ; break ; <START> case NONE : <END> default : VAR_2 = TYPE_2 . METHOD_2 ( this . METHOD_3 ( ) , this . METHOD_4 ( ) ) ; } return VAR_2 ; } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > result = new ArrayList < TYPE_1 > ( ) ; result . addAll ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <START> synchronized ( this ) { <END> result . addAll ( TYPE_2 . METHOD_4 ( this ) ) ; } return result ; } 
public TYPE_1 METHOD_1 ( ) { long VAR_1 = - ( System . currentTimeMillis ( ) - VAR_2 . METHOD_2 ( ) ) ; <START> if ( VAR_1 > 100 ) <END> return TYPE_1 . METHOD_3 ( Messages . VAR_3 ( TYPE_2 . METHOD_4 ( VAR_1 ) ) ) ; else return TYPE_1 . METHOD_3 ( Messages . VAR_4 ( ) ) ; } 
protected void METHOD_1 ( String VAR_1 ) throws TYPE_1 { <START> TYPE_2 . get ( ) . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> if ( METHOD_4 ( ) ) { throw new TYPE_1 ( Messages . TYPE_3 ( ) ) ; } } 
public TYPE_3 ( TYPE_1 VAR_2 ) throws IOException { <START> this ( new TYPE_2 ( VAR_2 ) , TYPE_4 . VAR_4 ) ; <END> } 
protected TYPE_1 ( ) { <START> super ( ) ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 next = METHOD_2 ( VAR_1 ) ; <START> LOGGER . log ( TYPE_3 . VAR_3 ? Level . VAR_4 : Level . VAR_5 , STRING_1 + VAR_1 + STRING_2 + next ) ; <END> if ( next != null ) { TYPE_2 . getInstance ( ) . METHOD_3 ( next ) ; } } 
private static void METHOD_1 ( File f , int VAR_1 ) throws IOException { if ( File . VAR_2 == CHAR_1 ) return ; if ( TYPE_1 . VAR_3 ) { TYPE_2 . METHOD_2 ( ) . METHOD_3 ( f . VAR_4 ( ) , VAR_1 ) ; } else { <START> TYPE_3 . METHOD_4 ( TYPE_1 . METHOD_5 ( f ) . METHOD_6 ( ) , TYPE_1 . METHOD_7 ( VAR_1 ) ) ; <END> } } 
public boolean METHOD_1 ( TYPE_1 request , TYPE_2 response , TYPE_3 VAR_1 ) throws IOException , TYPE_4 { Object VAR_2 = request . VAR_3 ( TYPE_5 . class . getName ( ) ) ; <START> if ( VAR_2 != null && VAR_2 == Boolean . VAR_4 ) { <END> VAR_1 . METHOD_2 ( request , response ) ; return true ; } return false ; } 
private void METHOD_1 ( String VAR_1 ) throws IOException , TYPE_1 { TYPE_2 req = new TYPE_2 ( new TYPE_3 ( j . VAR_2 ( ) , STRING_1 ) ) ; req . VAR_3 ( TYPE_5 . VAR_5 ) ; req . VAR_6 ( null ) ; TYPE_4 p = VAR_7 . METHOD_2 ( req ) ; <START> assertEquals ( VAR_1 , p . VAR_8 ( ) . METHOD_3 ( ) . trim ( ) ) ; <END> } 
private void METHOD_1 ( String VAR_1 , String VAR_2 ) throws IOException , TYPE_1 { TYPE_2 req = new TYPE_2 ( new TYPE_3 ( j . VAR_3 ( ) , STRING_1 ) ) ; req . VAR_4 ( null ) ; if ( VAR_1 != null ) req . VAR_5 ( STRING_2 , VAR_1 ) ; TYPE_4 p = VAR_6 . METHOD_2 ( req ) ; <START> assertEquals ( VAR_2 , p . VAR_7 ( ) . METHOD_3 ( ) . trim ( ) ) ; <END> } 
<START> public TYPE_4 . TYPE_5 . TYPE_2 METHOD_1 ( ) { <END> final TYPE_4 . TYPE_5 . TYPE_2 VAR_1 = new TYPE_4 . TYPE_5 . TYPE_3 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> if ( VAR_1 == null ) { <END> if ( TYPE_2 . METHOD_2 ( ) && ! TYPE_2 . METHOD_3 ( ) ) throw new TYPE_1 ( STRING_1 ) ; if ( args == null ) throw new TYPE_1 ( STRING_2 , VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 req , TYPE_3 VAR_1 ) throws TYPE_4 { if ( VAR_1 == null ) { return null ; } TYPE_5 VAR_2 = METHOD_2 ( ) ; <START> return VAR_2 == null ? null : VAR_2 . METHOD_3 ( req , VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 req , ANNOTATION_2 TYPE_3 VAR_1 ) throws TYPE_4 { String name = VAR_1 . getString ( STRING_1 ) ; String VAR_2 = VAR_1 . getString ( STRING_2 ) ; String VAR_3 = VAR_1 . getString ( STRING_3 ) ; TYPE_5 VAR_4 = new TYPE_5 ( name , VAR_2 ) ; <START> VAR_4 . METHOD_2 ( VAR_3 ) ; <END> return VAR_4 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) . METHOD_2 ( this ) ; VAR_1 . add ( new TYPE_2 < TYPE_3 > ( ) { protected TYPE_3 get ( String key ) { return METHOD_3 ( key ) ; } protected Collection < TYPE_3 > METHOD_4 ( ) { return METHOD_5 ( ) ; } @Override protected String getName ( TYPE_3 o ) { return o . getName ( ) ; } } ) ; <START> METHOD_6 ( VAR_1 , METHOD_5 ( false ) ) ; <END> return VAR_1 ; } 
protected TYPE_4 ( TYPE_1 < ? , ? > run , TYPE_2 < ? > VAR_2 ) { this . run = run ; build = run instanceof TYPE_3 ? ( TYPE_3 ) run : null ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = null ; <END> } 
public TYPE_2 ( ) { <START> super ( TYPE_1 . class . getName ( ) + STRING_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; try { VAR_1 = VAR_2 == null ? null : new TYPE_1 ( VAR_2 ) ; } catch ( TYPE_2 VAR_3 ) { } for ( TYPE_3 p : METHOD_2 ( ) ) { <START> TYPE_1 v = new TYPE_1 ( p . version ) ; <END> if ( VAR_1 == null || v . VAR_4 ( VAR_1 ) ) VAR_1 = v ; } return VAR_1 ; } 
public View METHOD_1 ( String name ) { for ( View v : VAR_1 ) { if ( v . VAR_2 ( ) . equals ( name ) ) return v ; <START> if ( v instanceof TYPE_1 ) { <END> View VAR_3 = ( ( TYPE_1 ) v ) . METHOD_1 ( name ) ; if ( VAR_3 != null ) { return VAR_3 ; } } } return null ; } 
public ANNOTATION_1 String METHOD_1 ( ) { TYPE_1 node = METHOD_2 ( ) ; <START> return ( node != null ) ? node . VAR_1 ( ) : "" ; <END> } 
public void METHOD_1 ( String token , List < TYPE_1 > result ) { boolean VAR_1 = TYPE_2 . METHOD_2 ( ) ; for ( TYPE_1 i : VAR_2 ) { String name = i . VAR_3 ( ) ; if ( VAR_1 ) { token = token . VAR_4 ( ) ; name = name . VAR_4 ( ) ; } <START> if ( token . equals ( name ) ) <END> result . add ( i ) ; } } 
public void METHOD_1 ( ) throws IOException { super . METHOD_1 ( ) ; for ( int i = size - 1 ; i >= 0 ; i -- ) { File VAR_1 = METHOD_2 ( i ) ; if ( VAR_1 . exists ( ) ) { File next = METHOD_2 ( i + 1 ) ; if ( ! next . VAR_2 ( ) ) { <START> throw new IOException ( String . format ( STRING_1 , next . VAR_3 ( ) ) ) ; <END> } VAR_1 . METHOD_3 ( next ) ; } } } 
public boolean METHOD_1 ( Collection < ? > c ) { try { boolean VAR_1 = false ; for ( Object o : c ) { VAR_1 |= METHOD_2 ( o ) ; } return VAR_1 ; } finally { if ( VAR_2 != null ) { <START> METHOD_3 ( ) ; <END> } } } 
public List < TYPE_1 < TYPE_2 > > METHOD_1 ( ) { TYPE_3 request = TYPE_4 . METHOD_2 ( ) ; <START> View view = request . VAR_1 ( VAR_2 ) ; <END> return view == null ? TYPE_5 . METHOD_3 ( VAR_2 , TYPE_2 . METHOD_4 ( ) ) : TYPE_5 . apply ( view , TYPE_2 . METHOD_4 ( ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_3 . TYPE_4 VAR_1 , ANNOTATION_1 TYPE_2 node , ANNOTATION_1 Throwable t ) { <START> ; <END> } 
<START> private Object METHOD_1 ( ) { <END> if ( StringUtils . VAR_1 ( name ) ) { LOGGER . log ( Level . VAR_2 , STRING_1 , name ) ; return VAR_3 ; } TYPE_1 state = TYPE_1 . valueOf ( name ) ; if ( state == null ) { LOGGER . log ( Level . VAR_2 , STRING_2 , name ) ; return VAR_3 ; } return state ; } 
<START> public final Integer METHOD_1 ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . write ( VAR_2 , 0 , VAR_2 . length ( ) ) ; VAR_1 . METHOD_2 ( ) ; assertTrue ( STRING_1 , <START> TYPE_1 . size ( VAR_1 . METHOD_3 ( ) ) == VAR_2 . length ( ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { <START> throw new IllegalStateException ( STRING_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; while ( VAR_1 != null && VAR_1 . METHOD_3 ( ) ) VAR_1 = VAR_1 . METHOD_4 ( ) ; if ( TYPE_3 . METHOD_5 ( this ) ) <START> return METHOD_6 ( ) ? TYPE_1 . VAR_2 : TYPE_1 . VAR_3 ; <END> else if ( VAR_1 != null ) return VAR_1 . METHOD_1 ( ) ; else return TYPE_1 . VAR_4 ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 != null ) { return VAR_1 ; } else { return VAR_2 ; } } 
public static String METHOD_1 ( ANNOTATION_1 File VAR_1 ) throws InterruptedException , IOException { try { Path path = VAR_1 . METHOD_2 ( ) ; return TYPE_1 . METHOD_3 ( path ) . toString ( ) ; } catch ( TYPE_2 | TYPE_3 x ) { <START> return null ; <END> } catch ( Exception x ) { throw ( IOException ) new IOException ( x . toString ( ) ) . METHOD_4 ( x ) ; } } 
static void METHOD_1 ( File VAR_1 , File VAR_2 ) throws IOException { try { <START> TYPE_1 . METHOD_1 ( VAR_1 . METHOD_2 ( ) , VAR_2 . METHOD_2 ( ) ) ; <END> } catch ( Exception x ) { throw new IOException ( x ) ; } } 
private Object METHOD_1 ( List < TYPE_1 > list ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( list ) ; Collections . VAR_2 ( VAR_1 , new TYPE_2 < TYPE_1 > ( ) { public int METHOD_2 ( TYPE_1 VAR_3 , TYPE_1 VAR_4 ) { return VAR_3 . getString ( STRING_1 ) . METHOD_3 ( VAR_4 . getString ( STRING_1 ) ) ; } <START> ; <END> } ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( null ) ; <START> throw new TYPE_1 ( ) ; <END> } 
void METHOD_1 ( ) throws IOException { <START> List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; <END> for ( TYPE_1 d : VAR_2 ) { if ( parent . VAR_3 ( d . VAR_4 ) == null ) VAR_1 . add ( d ) ; } if ( ! VAR_1 . isEmpty ( ) ) throw new TYPE_2 ( VAR_1 ) ; for ( TYPE_1 d : VAR_5 ) { if ( parent . VAR_3 ( d . VAR_4 ) != null ) VAR_2 . add ( d ) ; } } 
public TYPE_3 ( String VAR_2 , String name , String VAR_3 , String properties , String VAR_4 , boolean VAR_5 , TYPE_1 VAR_6 , TYPE_2 VAR_7 ) { <START> this ( VAR_2 , name , VAR_3 , properties , VAR_4 , VAR_5 , VAR_6 , VAR_7 , true ) ; <END> } 
<START> private boolean isEmpty ( ) { <END> for ( TYPE_1 f : data ) { if ( f . VAR_1 . length > 0 ) return false ; } return true ; } 
public void METHOD_1 ( boolean b ) throws IOException { if ( VAR_1 == b ) return ; if ( b && ! METHOD_2 ( ) ) return ; this . VAR_1 = b ; if ( b ) { this . VAR_2 = System . currentTimeMillis ( ) ; TYPE_1 . getInstance ( ) . METHOD_3 ( ) . METHOD_4 ( this ) ; <START> } <END> METHOD_5 ( ) ; TYPE_2 . METHOD_6 ( this ) ; } 
protected int run ( ) throws Exception { boolean VAR_1 = false ; try { TYPE_1 . METHOD_1 ( ) . METHOD_2 ( ) ; } catch ( TYPE_2 e ) { VAR_2 . println ( e . getMessage ( ) ) ; VAR_1 = true ; } catch ( Exception e ) { <START> final String VAR_3 = String . format ( STRING_1 , <END> e . getMessage ( ) ) ; VAR_2 . println ( VAR_3 ) ; LOGGER . VAR_4 ( VAR_3 ) ; VAR_1 = true ; } return VAR_1 ? 1 : 0 ; } 
<START> public void METHOD_1 ( TYPE_1 a ) { <END> super . METHOD_1 ( a ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 f : TYPE_2 . METHOD_2 ( ) ) { try { VAR_1 = f . VAR_2 ( this , VAR_1 ) ; } catch ( IOException | InterruptedException e ) { <START> logger . log ( Level . VAR_3 , STRING_1 + f , e ) ; <END> } } return VAR_1 ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { <END> TYPE_2 VAR_2 = new TYPE_2 ( this ) ; try { METHOD_2 ( TYPE_3 . class ) ; if ( VAR_1 != null ) { METHOD_3 ( new TYPE_3 ( VAR_1 ) ) ; } VAR_2 . commit ( ) ; } finally { VAR_2 . METHOD_4 ( ) ; } } 
<START> public void METHOD_1 ( final TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <END> for ( TYPE_1 VAR_3 : TYPE_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_4 , TYPE_1 . class ) ) { VAR_2 . METHOD_4 ( new TYPE_2 . TYPE_8 ( VAR_3 , VAR_1 ) { @Override public boolean METHOD_5 ( TYPE_5 VAR_5 , TYPE_6 listener , List < TYPE_7 > VAR_6 ) { return METHOD_6 ( VAR_5 , listener ) ; } } ) ; } } 
private File METHOD_1 ( File VAR_1 , File VAR_2 ) throws Exception { File VAR_3 = new File ( VAR_1 , STRING_1 ) ; String cmd = STRING_2 + VAR_3 . getPath ( ) + STRING_3 + VAR_2 . getPath ( ) + STRING_4 ; TYPE_1 VAR_4 = new TYPE_1 ( STRING_5 , STRING_6 , cmd ) ; VAR_4 . METHOD_2 ( ) ; TYPE_2 p = VAR_4 . start ( ) ; <START> assertTrue ( STRING_7 + cmd + STRING_8 , p . VAR_5 ( ) == 0 ) ; <END> return VAR_3 ; } 
<START> @Override public TYPE_1 METHOD_1 ( ) { <END> if ( METHOD_2 ( ) && ! METHOD_3 ( ) ) { return new TYPE_2 ( METHOD_4 ( ) ) ; } if ( METHOD_5 ( ) ) { TYPE_3 < ? , ? > VAR_1 = METHOD_6 ( ) ; if ( VAR_1 != null ) return new TYPE_4 ( VAR_1 ) ; } if ( METHOD_7 ( ) ) { TYPE_3 < ? , ? > VAR_1 = METHOD_8 ( ) ; if ( VAR_1 != null ) return new TYPE_5 ( VAR_1 ) ; } return null ; } 
<START> public void METHOD_1 ( Collection < ? extends TYPE_1 > VAR_1 ) { <END> this . VAR_1 = new ArrayList < TYPE_1 > ( VAR_1 ) ; } 
public static List < TYPE_1 > METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_2 . getInstance ( ) ; <START> if ( null == VAR_1 ) return Collections . VAR_2 ( ) ; <END> return VAR_1 . METHOD_2 ( TYPE_1 . class ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ; Class < ? > VAR_3 = VAR_1 . VAR_4 . METHOD_4 ( STRING_2 ) ; TYPE_2 VAR_5 = VAR_3 . METHOD_5 ( ) ; TYPE_3 url = VAR_5 . METHOD_6 ( STRING_3 ) ; <START> assert url != null ; <END> assertTrue ( STRING_4 , url . toString ( ) . contains ( STRING_5 ) ) ; } 
<START> public TYPE_1 ( String message ) { <END> super ( message ) ; } 
public boolean METHOD_1 ( int VAR_1 ) { <START> return METHOD_2 ( VAR_1 ) > - 1 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { for ( Object o : this ) { if ( o instanceof TYPE_3 ) { TYPE_3 VAR_3 = ( TYPE_3 ) o ; try { VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; } catch ( RuntimeException e ) { String VAR_4 = VAR_1 == null ? STRING_1 : VAR_1 . METHOD_2 ( ) ; <START> LOGGER . log ( Level . VAR_5 , STRING_2 + VAR_4 , e ) ; <END> } } } } 
<START> public static boolean METHOD_1 ( String name ) { <END> if ( name != null ) { return false ; } else if ( name . equals ( TYPE_1 ) ) { return false ; } else if ( name . equals ( STRING_1 ) ) { return false ; } return true ; } 
public TYPE_3 ( TYPE_1 VAR_2 , int VAR_3 , <START> Collection < ? extends TYPE_2 > VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = new ArrayList < TYPE_2 > ( VAR_4 ) ; } 
<START> public int size ( ) { <END> return VAR_1 . size ( ) ; } 
public TYPE_1 ( String command ) { <START> this ( command , 0 ) ; <END> } 
public byte [ ] METHOD_1 ( File file ) throws IOException { TYPE_1 in = null ; try { in = org . VAR_1 . VAR_2 . VAR_3 . TYPE_3 . METHOD_2 ( file ) ; return org . VAR_1 . VAR_2 . VAR_3 . TYPE_2 . METHOD_3 ( in ) ; } finally { org . VAR_1 . VAR_2 . VAR_3 . TYPE_2 . METHOD_4 ( in ) ; <START> } <END> } 
public TYPE_1 ( String VAR_2 , String VAR_3 , boolean VAR_4 ) { <START> this ( VAR_2 , VAR_3 , VAR_4 , false , false , true ) ; <END> } 
public byte [ ] get ( ) { try { TYPE_1 VAR_1 = null ; try { VAR_1 = new TYPE_1 ( file ) ; return TYPE_2 . METHOD_1 ( VAR_1 ) ; } finally { if ( VAR_1 != null ) { VAR_1 . close ( ) ; } <START> } <END> } catch ( IOException e ) { throw new TYPE_3 ( e ) ; } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; this . VAR_1 . METHOD_2 ( version ) ; File VAR_2 = this . VAR_1 . METHOD_3 ( ) ; if ( VAR_2 != null ) { this . VAR_3 = new TYPE_2 ( VAR_2 ) ; } else { <START> VAR_3 = new TYPE_2 ( ) ; <END> } TYPE_3 . getInstance ( ) . METHOD_4 ( this . VAR_3 ) ; } 
private void METHOD_1 ( ) { try { if ( METHOD_2 ( STRING_1 ) ) { VAR_1 = Boolean . valueOf ( getProperty ( STRING_1 ) ) ; } if ( METHOD_2 ( STRING_2 ) ) { VAR_2 = getProperty ( STRING_2 ) ; } VAR_3 = getProperty ( STRING_3 ) ; VAR_4 = getProperty ( STRING_4 ) ; } catch ( Exception e ) { e . VAR_5 ( ) ; <START> System . VAR_6 ( 1 ) ; <END> } } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 project ) throws TYPE_4 , TYPE_5 { <END> TYPE_1 < TYPE_2 > VAR_1 = super . METHOD_1 ( project ) ; if ( configuration . VAR_2 ( ) ) { return VAR_3 . METHOD_2 ( project , VAR_1 ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . assertThat ( STRING_1 , new TYPE_5 . TYPE_6 ( new TYPE_3 ( ) . METHOD_2 ( ) . get ( STRING_2 ) ) . exists ( ) , <START> new TYPE_4 < > ( true ) <END> ) ; } 
<START> private Long METHOD_1 ( final TYPE_1 VAR_1 ) { <END> Long result = INT_1 ; try { final Date VAR_2 = this . METHOD_2 ( VAR_1 ) . METHOD_1 ( ) ; if ( VAR_2 != null ) { result = VAR_2 . METHOD_3 ( ) ; } } catch ( final IOException VAR_3 ) { throw new IllegalArgumentException ( VAR_3 ) ; } return result ; } 
public void METHOD_1 ( ) throws Exception { <START> final TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 . create ( STRING_1 ) ) ; <END> TYPE_3 . assertThat ( VAR_1 . entry ( ) . uri ( ) . toString ( ) , TYPE_4 . METHOD_2 ( STRING_2 ) ) ; } 
<START> public void METHOD_1 ( ) throws IOException { <END> final TYPE_1 VAR_1 = TYPE_2 . commit ( ) ; TYPE_3 . assertThat ( new Status . TYPE_7 ( new TYPE_4 ( VAR_1 , TYPE_5 . METHOD_2 ( ) . build ( ) ) ) . commit ( ) , TYPE_6 . METHOD_3 ( VAR_1 ) ) ; } 
private static long METHOD_1 ( ) { final long VAR_1 = new Date ( ) . METHOD_2 ( ) ; <START> return VAR_1 - ( VAR_1 % TYPE_1 . VAR_3 ) ; <END> } 
<START> public String METHOD_1 ( ) { <END> return String . format ( STRING_1 , this . VAR_1 , this . VAR_2 ) ; } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; VAR_1 . METHOD_2 ( ) . create ( TYPE_2 . METHOD_3 ( ) . add ( STRING_2 , STRING_3 ) . build ( ) ) ; <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; <END> TYPE_3 . assertThat ( VAR_1 . METHOD_6 ( ) . METHOD_7 ( STRING_1 , STRING_4 , STRING_5 ) , TYPE_4 . METHOD_8 ( TYPE_4 . METHOD_9 ( ) ) ) ; } 
public final void METHOD_1 ( ) throws Exception { TYPE_1 . assertThat ( new TYPE_2 ( ) . METHOD_2 ( TYPE_3 . METHOD_3 ( ) . add ( STRING_1 , STRING_2 ) . build ( ) ) , <START> TYPE_4 . METHOD_4 ( STRING_3 ) <END> ) ; } 
public final String METHOD_1 ( ANNOTATION_1 ( message = STRING_1 ) final String text ) throws IOException { <START> throw new TYPE_1 ( STRING_2 ) ; <END> } 
public void METHOD_1 ( ) throws IOException { final String user = STRING_1 ; final TYPE_1 VAR_1 = new TYPE_2 ( new TYPE_9 . TYPE_10 ( ) , user , new TYPE_7 . TYPE_8 ( user , STRING_2 ) ) ; TYPE_5 . assertThat ( VAR_1 . METHOD_2 ( TYPE_11 < String , String > METHOD_3 ( ) ) , <START> TYPE_6 . METHOD_4 ( ) <END> ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( this . entry , this . entry , this . VAR_1 ) ; <END> } 
<START> public static TYPE_1 repo ( ) { <END> final String key = System . getProperty ( STRING_1 ) ; TYPE_2 . METHOD_1 ( key , TYPE_3 . METHOD_2 ( ) ) ; final String VAR_1 = System . getProperty ( STRING_2 ) ; TYPE_2 . METHOD_1 ( VAR_1 , TYPE_3 . METHOD_2 ( ) ) ; return new TYPE_4 ( key ) . METHOD_3 ( ) . get ( new TYPE_6 . TYPE_7 ( VAR_1 ) ) ; } 
<START> public TYPE_4 ( final TYPE_1 req , final TYPE_2 repo ) { <END> this . entry = req ; final TYPE_3 VAR_2 = repo . VAR_3 ( ) ; this . request = this . entry . uri ( ) . path ( STRING_1 ) . path ( VAR_2 . user ( ) ) . path ( VAR_2 . repo ( ) ) . path ( STRING_2 ) . METHOD_1 ( ) ; this . VAR_4 = repo ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final Map < String , String > params ) { return new TYPE_3 < TYPE_2 > ( this . request . uri ( ) . METHOD_2 ( params ) . METHOD_3 ( ) , new TYPE_3 . TYPE_7 < TYPE_2 , TYPE_5 > ( ) { @Override public TYPE_2 map ( final TYPE_5 value ) { <START> return new TYPE_6 ( <END> TYPE_8 . this . request , TYPE_8 . VAR_2 . VAR_3 , value . getInt ( STRING_1 ) ) ; } } ) ; } 
private static TYPE_1 METHOD_1 ( <START> final String VAR_1 ) throws Exception { <END> return TYPE_2 . METHOD_2 ( ) . add ( STRING_1 , 1 ) . add ( VAR_2 , VAR_1 ) . build ( ) ; } 
public void METHOD_1 ( ) throws IOException { final TYPE_1 container = new TYPE_2 ( ) . next ( new TYPE_10 . TYPE_11 ( TYPE_12 . VAR_2 , STRING_1 ) ) . start ( ) ; <START> final TYPE_4 VAR_3 = new TYPE_5 ( <END> new TYPE_6 ( container . VAR_4 ( ) ) , TYPE_7 . repo ( ) ) ; TYPE_8 . assertThat ( VAR_3 . METHOD_2 ( STRING_2 ) , TYPE_9 . METHOD_3 ( ) ) ; container . VAR_5 ( ) ; } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( ) , this . repo ( ) ) ; TYPE_3 . assertThat ( VAR_1 . METHOD_2 ( STRING_1 ) , <START> TYPE_4 . METHOD_3 ( ) <END> ) ; } 
public void METHOD_1 ( ) throws Exception { final String VAR_1 = STRING_1 ; final TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( ) ; final TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; <START> final TYPE_4 org = VAR_3 . get ( VAR_1 ) ; <END> TYPE_5 . assertThat ( org . VAR_1 ( ) , TYPE_6 . METHOD_6 ( VAR_1 ) ) ; } 
TYPE_3 ( final TYPE_1 VAR_2 , final TYPE_2 req ) { this . VAR_3 = VAR_2 ; this . entry = req ; this . VAR_4 = this . entry . uri ( ) . path ( STRING_1 ) . METHOD_1 ( ) ; <START> this . VAR_5 = this . entry . uri ( ) . path ( STRING_2 ) . METHOD_1 ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; final TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 , INT_1 ) ; TYPE_2 . when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_4 . METHOD_5 ( ) . add ( STRING_1 , STRING_2 ) . build ( ) ) ; <START> VAR_2 . METHOD_3 ( ) ; <END> TYPE_5 . assertThat ( VAR_1 . METHOD_3 ( ) . toString ( ) , TYPE_6 . METHOD_6 ( STRING_3 ) ) ; } 
public boolean METHOD_1 ( ) throws IOException { final List < String > VAR_1 = this . VAR_2 . METHOD_2 ( ) . METHOD_3 ( String <START> . format ( STRING_1 , this . METHOD_3 ( ) ) <END> ) ; return ! VAR_1 . isEmpty ( ) && StringUtils . equalsIgnoreCase ( TYPE_1 . VAR_4 , VAR_1 . get ( 0 ) ) ; } 
public void METHOD_1 ( ) throws IOException { <START> final TYPE_1 VAR_1 = new TYPE_1 ( ) . METHOD_2 ( <END> this . METHOD_2 ( ) ) ; final TYPE_1 VAR_2 = VAR_1 . METHOD_3 ( STRING_1 , TYPE_2 . VAR_4 ) ; this . VAR_5 . apply ( VAR_2 ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 location = Context . VAR_1 ( ) . METHOD_2 ( 1 ) ; List < TYPE_2 > results = VAR_2 . METHOD_3 ( location , false ) ; Assert . assertNotNull ( results ) ; Assert . assertEquals ( 1 , results . size ( ) ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> VAR_1 . METHOD_2 ( Context . VAR_2 ( ) . METHOD_3 ( 1 ) , STRING_1 , false ) ; } 
public static TYPE_1 of ( TYPE_2 VAR_1 ) { final Builder builder = new Builder ( ) ; if ( VAR_1 == null ) { return builder . build ( ) ; } <START> ; <END> VAR_1 . forEach ( new TYPE_2 . TYPE_4 ( ) { @Override public void METHOD_1 ( String key , Object value ) { if ( null != value ) { builder . add ( key , value . toString ( ) ) ; } } } ) ; return builder . build ( ) ; } 
<START> public static String METHOD_1 ( ) { <END> String VAR_1 = STRING_1 + System . getProperty ( STRING_2 ) ; String VAR_2 = System . getProperty ( STRING_3 ) + STRING_4 + System . getProperty ( STRING_5 ) + STRING_4 + System . getProperty ( STRING_6 ) ; String VAR_3 = STRING_7 + Constants . VAR_4 ; return VAR_3 + STRING_8 + VAR_2 + STRING_9 + VAR_1 ; } 
public String METHOD_1 ( String VAR_1 ) throws Exception { <START> String VAR_2 = String . format ( STRING_1 , host + STRING_2 , VAR_1 ) ; <END> TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( VAR_2 , STRING_3 , null , null ) ; Response response = client . VAR_5 ( VAR_2 , VAR_3 ) ; String [ ] VAR_6 = response . VAR_7 ( ) . split ( STRING_4 ) ; return response . VAR_8 + STRING_4 + VAR_6 [ 2 ] ; } 
private String METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( host ) ; <START> builder . append ( STRING_1 + VAR_1 + STRING_2 ) ; <END> if ( VAR_2 != null ) { builder . append ( STRING_3 + VAR_2 + STRING_3 ) ; } builder . append ( VAR_3 ) ; return builder . toString ( ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , String key ) throws TYPE_2 { <START> if ( key != null && key . trim ( ) . length ( ) > 0 ) { <END> VAR_1 . METHOD_2 ( STRING_1 , new TYPE_3 ( key , TYPE_4 . METHOD_3 ( STRING_2 ) ) ) ; } } 
public TYPE_1 ( String VAR_2 , long VAR_3 ) { if ( VAR_3 <= 0 ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( VAR_2 == null || VAR_2 . trim ( ) . length ( ) == 0 ) { <START> throw new IllegalArgumentException ( STRING_2 ) ; <END> } this . VAR_2 = VAR_2 ; this . VAR_3 = System . currentTimeMillis ( ) / INT_1 + VAR_3 ; } 
public TYPE_1 ( String VAR_2 , long VAR_3 ) { <START> if ( VAR_2 == null || VAR_2 . trim ( ) . length ( ) == 0 ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } if ( VAR_3 <= 0 ) { throw new IllegalArgumentException ( STRING_2 ) ; } this . VAR_3 = System . currentTimeMillis ( ) / INT_1 + VAR_3 ; this . VAR_2 = VAR_2 ; } 
<START> public String METHOD_1 ( String url ) { <END> return url + STRING_1 ; } 
<START> public String METHOD_1 ( String url , String params ) { <END> return url + STRING_1 + params ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 ) { <END> String VAR_5 = VAR_1 + STRING_1 + VAR_2 ; String VAR_6 = TYPE_2 . METHOD_2 ( VAR_5 ) ; String url = VAR_3 + STRING_2 + VAR_4 + STRING_3 + VAR_6 ; TYPE_1 VAR_7 = VAR_8 . call ( url ) ; return VAR_7 ; } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( new TYPE_1 ( ) ) ; <END> } 
public TYPE_9 ( TYPE_1 configuration , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 , TYPE_5 VAR_5 ) { this . configuration = configuration ; this . VAR_2 = VAR_2 ; this . VAR_5 = VAR_5 ; this . VAR_4 = VAR_4 ; this . VAR_3 = VAR_3 ; this . VAR_6 = TYPE_6 . METHOD_1 ( configuration : : METHOD_2 ) . build ( ) ; <START> this . VAR_7 = TYPE_7 . METHOD_3 ( new TYPE_8 ( ) . METHOD_4 ( STRING_1 ) . build ( ) ) ; <END> } 
private double METHOD_1 ( ) { switch ( VAR_1 ) { case VAR_2 : return VAR_3 . METHOD_2 ( ) ; case VAR_4 : return VAR_3 . METHOD_3 ( ) ; case VAR_5 : default : return VAR_3 . METHOD_4 ( ) ; <START> } <END> } 
<START> public long METHOD_1 ( String VAR_1 , String name ) { <END> final long start = System . currentTimeMillis ( ) ; LOG . trace ( STRING_1 , name , VAR_1 ) ; TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , ( r ) - > new TYPE_1 ( ) ) ; VAR_2 . METHOD_1 ( ) ; LOG . trace ( STRING_2 , name , VAR_1 , TYPE_2 . METHOD_3 ( start ) ) ; return System . currentTimeMillis ( ) ; } 
<START> public void METHOD_1 ( String VAR_1 , String name , long start ) { <END> LOG . trace ( STRING_1 , name , VAR_1 , TYPE_1 . METHOD_2 ( start ) ) ; TYPE_2 VAR_2 = VAR_3 . METHOD_3 ( VAR_1 , ( r ) - > new TYPE_2 ( ) ) ; VAR_2 . METHOD_1 ( ) ; } 
<START> public Optional < List < TYPE_1 > > METHOD_1 ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , TYPE_2 . VAR_4 ) ; VAR_5 . METHOD_2 ( VAR_1 . build ( ) ) ; METHOD_3 ( STRING_1 ) ; <START> VAR_5 . METHOD_4 ( VAR_2 , Optional . VAR_6 ( ) ) ; <END> METHOD_5 ( ) ; } 
private void METHOD_1 ( ) { LOG . trace ( STRING_1 , VAR_1 ) ; <START> TYPE_1 . METHOD_2 ( VAR_2 == TYPE_2 . VAR_4 , STRING_2 , VAR_1 , VAR_2 ) ; <END> this . VAR_2 = TYPE_2 . VAR_5 ; } 
<START> public Long METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( VAR_1 , VAR_2 + 1 , VAR_3 , VAR_4 , true , VAR_5 , VAR_6 , System . currentTimeMillis ( ) ) ; <END> } 
<START> private static Boolean METHOD_1 ( TYPE_1 r ) { <END> return r . VAR_1 ( ) && ! r . VAR_2 ( ) . equals ( STRING_1 ) ; } 
public void METHOD_1 ( String uri , File target ) { TYPE_1 m = METHOD_2 ( uri ) ; if ( m . VAR_1 ( ) ) { try { <START> TYPE_2 s = VAR_2 . METHOD_3 ( m . group ( STRING_1 ) , m . group ( STRING_2 ) ) ; <END> TYPE_3 . METHOD_4 ( s , target ) ; } catch ( Exception ex ) { TYPE_4 . METHOD_5 ( ex ) ; } } } 
public void METHOD_1 ( boolean VAR_1 ) { <START> logger . log ( Level . VAR_2 , STRING_1 . METHOD_2 ( ( VAR_1 ) ? STRING_2 : STRING_3 ) ) ; <END> this . VAR_1 = VAR_1 ; METHOD_3 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) ) { if ( ! StringUtils . equalsIgnoreCase ( VAR_2 , VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ) ) { VAR_2 = VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ; TYPE_2 . METHOD_5 ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ) ; METHOD_6 ( ) ; <START> } else if ( ! StringUtils . equalsIgnoreCase ( VAR_4 , VAR_3 . METHOD_3 ( ) . METHOD_7 ( ) ) ) { <END> METHOD_6 ( ) ; } } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( ) ; METHOD_2 ( ) . METHOD_1 ( VAR_1 ) ; super . METHOD_1 ( VAR_1 ) ; <START> TYPE_2 . METHOD_4 ( this ) ; <END> } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_2 . getInstance ( ) ) ; <START> VAR_1 . METHOD_3 ( ) . METHOD_4 ( STRING_1 , true ) . commit ( ) ; <END> } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( STRING_1 + METHOD_4 ( ) + STRING_2 + TYPE_1 . VAR_3 + STRING_3 , new Object [ ] { METHOD_4 ( ) } ) != 0 ; <END> } 
public void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> return ; } VAR_1 = new TYPE_1 < TYPE_2 > ( ( ) - > new TYPE_2 ( VAR_2 ) . METHOD_1 ( METHOD_2 ( STRING_1 ) ) ) ; new Thread ( VAR_1 ) . start ( ) ; } 
public void METHOD_1 ( ) { <START> if ( TYPE_1 . METHOD_2 ( TYPE_4 . this ) ) { METHOD_3 ( TYPE_2 . parse ( METHOD_4 ( ) . getString ( R . string . VAR_2 ) ) ) ; } else { TYPE_3 . METHOD_5 ( TYPE_4 . VAR_3 , METHOD_4 ( ) . getString ( R . string . VAR_4 ) + METHOD_4 ( ) . getString ( R . string . VAR_2 ) , false ) ; <END> } } 
public Long [ ] METHOD_1 ( ) { Long [ ] VAR_1 ; <START> if ( VAR_2 < 0 ) { <END> VAR_1 = Utils . VAR_3 ( VAR_4 . METHOD_2 ( ) . METHOD_3 ( Long . VAR_5 , STRING_1 , 0 ) ) ; } else { VAR_1 = VAR_4 . METHOD_4 ( ) . METHOD_5 ( VAR_2 , true ) ; } VAR_6 = VAR_1 . length ; return VAR_1 ; } 
public TYPE_1 ( Collection VAR_2 ) { VAR_3 = VAR_2 ; VAR_4 = null ; <START> VAR_5 = null ; <END> } 
public static ANNOTATION_1 TYPE_1 METHOD_1 ( ANNOTATION_2 String VAR_1 ) { TYPE_2 . d ( STRING_1 , VAR_1 ) ; try ( TYPE_3 target = new TYPE_3 ( ) ) { TYPE_4 . METHOD_2 ( ) . METHOD_3 ( VAR_1 , target ) ; return new TYPE_1 ( target . toString ( ) ) ; <START> } catch ( IOException | TYPE_5 e ) { <END> TYPE_2 . e ( e , STRING_2 , VAR_1 ) ; return null ; } } 
public static void METHOD_1 ( String VAR_1 ) { TYPE_1 config = getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_2 VAR_2 = TYPE_3 . METHOD_4 ( VAR_1 ) ; config . VAR_3 = VAR_2 ; getInstance ( ) . METHOD_2 ( ) . METHOD_5 ( config , getInstance ( ) . METHOD_2 ( ) . METHOD_6 ( ) ) ; <START> TYPE_4 . getInstance ( ) . METHOD_7 ( ) ; <END> } 
<START> public static String getName ( TYPE_1 channel , TYPE_2 res ) { <END> switch ( channel ) { case VAR_1 : return res . getString ( R . string . VAR_2 ) ; case VAR_3 : return res . getString ( R . string . VAR_4 ) ; case VAR_5 : return res . getString ( R . string . VAR_6 ) ; case VAR_7 : default : return res . getString ( R . string . VAR_8 ) ; } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( ) . METHOD_4 ( VAR_3 , VAR_2 ) . apply ( ) ; String [ ] VAR_4 = { STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 } ; METHOD_5 ( METHOD_6 ( ) . METHOD_7 ( VAR_4 ) ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_1 = VAR_1 ; TYPE_2 . METHOD_2 ( this , VAR_1 ) ; } 
private void METHOD_1 ( ) { boolean VAR_1 = VAR_2 . size ( ) < METHOD_2 ( ) . size ( ) ; if ( VAR_1 ) { <START> for ( int i = 0 ; i < VAR_3 . size ( ) ; i ++ ) <END> VAR_2 . add ( i ) ; } else { VAR_2 . clear ( ) ; } METHOD_3 ( ) ; VAR_4 . setText ( Integer . toString ( VAR_2 . size ( ) ) ) ; VAR_5 . METHOD_4 ( ) ; } 
private static String METHOD_1 ( Collection VAR_1 , String VAR_2 , TYPE_1 model ) { String VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; String VAR_4 = STRING_1 ; <START> if ( model . VAR_5 ( STRING_2 , false ) ) <END> VAR_4 = STRING_3 ; String VAR_6 = STRING_4 + Utils . VAR_7 ( VAR_3 ) + STRING_5 + VAR_4 ; return STRING_6 + VAR_6 + STRING_7 ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 ) <END> return ; METHOD_2 ( ) ; METHOD_3 ( this ) ; VAR_2 = true ; } 
public long METHOD_1 ( ) throws TYPE_1 { <START> return METHOD_2 ( METHOD_3 ( STRING_1 , new TYPE_2 ( ) ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> METHOD_2 ( METHOD_3 ( STRING_1 , VAR_1 ) ) ; <END> } 
private String METHOD_1 ( String VAR_1 , TYPE_1 uri ) { String format = STRING_1 ; String path = uri == null ? null : uri . getPath ( ) ; if ( TYPE_3 . VAR_3 . VAR_4 < TYPE_3 . VAR_5 . VAR_6 ) { return String . format ( format , TYPE_2 . class . METHOD_2 ( ) , VAR_1 , path ) ; } else { <START> return String . format ( format + STRING_2 , TYPE_2 . class . METHOD_2 ( ) , VAR_1 , path , METHOD_3 ( ) ) ; <END> } } 
public int METHOD_1 ( ) { try { TYPE_1 info = VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_4 . VAR_3 , TYPE_3 . VAR_5 ) ; if ( info == null ) { return - 1 ; } TYPE_2 VAR_6 = info . VAR_6 ; if ( VAR_6 == null ) { return VAR_7 ; } if ( info . VAR_6 . containsKey ( VAR_8 ) ) { return info . VAR_6 . getInt ( VAR_8 ) ; } else { return VAR_7 ; } } <START> catch ( Throwable t ) { <END> return - 2 ; } } 
public TYPE_1 ( final int VAR_2 , final String VAR_3 ) { this ( VAR_2 , VAR_3 , String . format ( STRING_1 , String . valueOf ( VAR_2 ) , String . valueOf ( VAR_3 ) ) ) ; <START> } <END> 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> logger . info ( <END> STRING_1 , new Object [ ] { VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) } ) ; } 
<START> public List < TYPE_1 > METHOD_1 ( String VAR_1 , TYPE_2 user ) { <END> final TYPE_3 < TYPE_1 > VAR_2 = info - > info . VAR_3 ( ) != null && VAR_1 != null && VAR_1 . equals ( info . VAR_3 ( ) . METHOD_2 ( ) ) ; return VAR_4 . get ( user ) . stream ( ) . filter ( VAR_2 ) . collect ( Collectors . VAR_5 ( ) ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 options = this . VAR_1 . METHOD_2 ( ) ; if ( options . VAR_2 ( ) == null && METHOD_3 ( ) != null ) { options = TYPE_2 . METHOD_4 ( options ) ; <START> options . VAR_3 ( new String [ ] { METHOD_3 ( ) } ) ; <END> } return options ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 options = this . VAR_1 . METHOD_2 ( ) ; if ( options . VAR_2 ( ) == null && METHOD_3 ( ) != null ) { <START> if ( options . VAR_2 ( ) == null && METHOD_3 ( ) != null ) { <END> options = TYPE_2 . METHOD_4 ( options ) ; options . VAR_3 ( new String [ ] { METHOD_3 ( ) } ) ; } options . VAR_3 ( new String [ ] { METHOD_3 ( ) } ) ; } return options ; } 
<START> public final void METHOD_1 ( TYPE_1 VAR_1 ) { <END> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; this . VAR_1 = VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { this . VAR_1 . close ( ) ; <START> this . VAR_1 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . METHOD_2 ( VAR_1 ) ; <END> } 
public Integer getId ( ) { <START> return id ; <END> } 
public void METHOD_1 ( ) { if ( this . VAR_1 != null || ! this . VAR_1 . equals ( TYPE_2 . this . client ) ) { try { this . VAR_1 . METHOD_2 ( this . id , this . VAR_3 ) ; } catch ( TYPE_1 e ) { throw new IllegalStateException ( e ) ; } } else { <START> throw new IllegalStateException ( STRING_1 ) ; <END> } } 
public void METHOD_1 ( String key , TYPE_1 < TYPE_2 > factory ) { <START> this . VAR_1 . put ( key , factory ) ; <END> } 
<START> TYPE_2 ( TYPE_1 VAR_2 ) { <END> super ( VAR_2 , false ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 ) { Assert . VAR_3 ( VAR_2 , STRING_1 ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_4 . METHOD_1 ( TYPE_3 . TYPE_2 . VAR_7 ) ; <END> } 
public void METHOD_1 ( TYPE_1 < ? super TYPE_2 < ? > > VAR_1 ) { this . VAR_2 . METHOD_2 ( ( s ) - > this . VAR_3 . METHOD_3 ( this . VAR_2 . METHOD_4 ( ) ) ) . METHOD_1 ( VAR_1 ) ; if ( this . VAR_2 . METHOD_4 ( ) ) { <START> this . VAR_3 . METHOD_3 ( true ) ; <END> } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( this . VAR_2 != null ) { <END> METHOD_2 ( VAR_1 , this . VAR_3 , this . VAR_2 , STRING_1 ) ; } } 
<START> private TYPE_1 ( ) { <END> } 
protected TYPE_1 METHOD_1 ( ) { <START> if ( this . VAR_1 == null ) { <END> return VAR_2 ; } return this . VAR_1 ; } 
public String toString ( ) { return STRING_1 + this . VAR_1 + STRING_2 + this . file + STRING_3 <START> + this . VAR_2 + STRING_4 + this . VAR_3 + STRING_5 <END> + METHOD_1 ( ) . METHOD_2 ( ) + STRING_6 ; } 
public Object METHOD_1 ( ) { TYPE_1 VAR_1 ; try { VAR_1 = METHOD_2 ( ) ; } catch ( IOException VAR_2 ) { <START> throw new TYPE_2 ( new TYPE_3 ( STRING_1 , VAR_2 ) ) ; <END> } try { return METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } } 
public String toString ( ) { return STRING_1 + STRING_2 + this . VAR_1 + CHAR_1 + <START> STRING_3 + Arrays . toString ( this . data . VAR_2 ( ) . METHOD_1 ( ) ) + <END> STRING_4 + this . VAR_3 + CHAR_2 ; } 
public String toString ( ) { return STRING_1 + STRING_2 + this . VAR_1 + CHAR_1 + <START> STRING_3 + this . data . VAR_2 ( ) . METHOD_1 ( ) . length + <END> STRING_4 + this . VAR_3 + CHAR_2 ; } 
public < TYPE_1 > TYPE_2 METHOD_1 ( TYPE_3 < TYPE_4 < TYPE_1 > , Object > VAR_1 ) { <START> return METHOD_2 ( VAR_1 , null ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> List < String > VAR_2 = new ArrayList < String > ( ) ; <END> String [ ] VAR_3 = this . VAR_4 . METHOD_2 ( STRING_1 ) ; for ( String VAR_5 : VAR_3 ) { String VAR_6 = this . VAR_7 . METHOD_3 ( VAR_5 ) ; VAR_2 . addAll ( Arrays . asList ( StringUtils . VAR_8 ( VAR_6 ) ) ) ; } VAR_1 . METHOD_4 ( VAR_2 . METHOD_5 ( new String [ VAR_2 . size ( ) ] ) ) ; } 
public String [ ] METHOD_1 ( ) { <START> return this . VAR_1 . keySet ( ) . METHOD_2 ( new String [ this . VAR_1 . size ( ) ] ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> String VAR_1 = this . VAR_2 ; <END> if ( VAR_1 != null ) { this . VAR_3 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; this . VAR_2 = null ; } return this . VAR_3 ; } 
<START> public void METHOD_1 ( ) { <END> if ( this . VAR_1 != null ) { this . VAR_1 . METHOD_2 ( this ) ; } } 
public boolean METHOD_1 ( TYPE_1 result ) { <START> Assert . VAR_1 ( result , STRING_1 ) ; <END> Object VAR_2 = result . VAR_3 ( ) ; return VAR_2 instanceof TYPE_2 && TYPE_3 . class . METHOD_2 ( ( ( TYPE_2 ) VAR_2 ) . METHOD_3 ( ) ) ; } 
<START> TYPE_1 < ? > METHOD_1 ( ) { <END> TYPE_1 < ? > message = this . VAR_1 . METHOD_2 ( this . VAR_2 ) ; this . VAR_3 . METHOD_3 ( ) ; return message ; } 
public Set < String > keySet ( ) { Set < String > VAR_1 = new HashSet < > ( ) ; <START> VAR_1 . addAll ( this . VAR_2 . METHOD_1 ( this . VAR_3 , new Object [ ] { this . VAR_4 } , String . VAR_5 ) ) ; <END> return Collections . VAR_6 ( VAR_1 ) ; } 
protected TYPE_1 < ? > METHOD_1 ( ) { <START> return from ( ( TYPE_2 < ? > ) ( ) - > new TYPE_3 < > ( STRING_1 ) , <END> e - > e . VAR_1 ( p - > p . VAR_2 ( ctx - > this . VAR_3 . METHOD_2 ( null ) ) ) ) . channel ( TYPE_4 . METHOD_3 ( STRING_2 ) ) ; } 
public void METHOD_1 ( ) throws Exception { this . VAR_1 . start ( ) ; <START> this . VAR_1 . METHOD_2 ( ) ; <END> TYPE_1 VAR_2 = ( TYPE_1 ) TYPE_2 . METHOD_3 ( this . VAR_1 , STRING_1 ) ; assertTrue ( VAR_2 . METHOD_4 ( ) ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 , int VAR_3 ) { super ( VAR_2 ) ; <START> Assert . VAR_4 ( VAR_2 , STRING_1 ) ; <END> this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( ) { this . input . VAR_1 ( new TYPE_1 < String > ( STRING_1 ) ) ; TYPE_2 < ? > message = this . output . VAR_2 ( 100 ) ; assertNotNull ( message ) ; assertEquals ( STRING_2 , message . VAR_3 ( ) ) ; assertEquals ( 1 , count ) ; assertTrue ( this . VAR_4 . METHOD_2 ( STRING_3 ) ) ; assertTrue ( this . VAR_4 . METHOD_2 ( STRING_4 ) ) ; <START> assertTrue ( this . VAR_4 . METHOD_2 ( STRING_5 ) ) ; <END> } 
<START> public boolean METHOD_1 ( ) { <END> return this . VAR_1 ; } 
public void in ( String in ) { <START> this . VAR_1 . METHOD_1 ( ) ; <END> if ( STRING_1 . equals ( in ) ) { throw new RuntimeException ( STRING_2 ) ; } else { this . VAR_2 = in ; } } 
protected TYPE_3 ( ) { this . VAR_2 = new TYPE_1 ( ) ; <START> this . VAR_3 = new TYPE_2 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <START> this . VAR_3 . METHOD_1 ( VAR_1 ) ; <END> this . VAR_4 = true ; } 
public boolean equals ( Object o ) { if ( this == o ) return true ; <START> if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; <END> TYPE_1 VAR_1 = ( TYPE_1 ) o ; return TYPE_2 . equals ( this . VAR_2 , VAR_1 . VAR_2 ) ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return this . VAR_1 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { if ( this . VAR_1 . get ( ) > 0 ) { <START> return this . VAR_2 . get ( ) ; <END> } else { return this . VAR_3 . METHOD_1 ( ) ; } } 
public TYPE_1 create ( Object key ) { Assert . VAR_1 ( key , STRING_1 ) ; <START> if ( ! TYPE_2 . METHOD_1 ( key ) ) { <END> TYPE_3 VAR_2 = new TYPE_3 ( key ) ; TYPE_2 . METHOD_2 ( key , VAR_2 . METHOD_3 ( ) ) ; return VAR_2 ; } return null ; } 
public TYPE_3 ( String VAR_2 ) { super ( new TYPE_1 < Object > ( TYPE_2 . METHOD_1 ( VAR_2 ) ) ) ; <START> METHOD_2 ( METHOD_3 ( ) ) ; <END> } 
protected TYPE_7 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 < TYPE_4 < TYPE_2 > > VAR_3 ) { this . VAR_4 = VAR_2 ; this . VAR_3 = VAR_3 ; if ( TYPE_5 . METHOD_1 ( ) ) { <START> this . VAR_5 = TYPE_6 . METHOD_2 ( false ) . build ( ) ; <END> } else { this . VAR_5 = null ; } } 
<START> public void METHOD_1 ( TYPE_1 < TYPE_2 > filter ) { <END> this . filter = filter ; } 
TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . target = new TYPE_3 ( VAR_2 , VAR_3 ) ; this . target . VAR_4 ( this . VAR_5 ) ; <START> this . target . VAR_6 ( this . VAR_7 ) ; <END> this . VAR_3 = VAR_3 ; } 
TYPE_2 ( TYPE_1 writer ) { this . writer = writer ; this . stream = null ; <START> this . VAR_2 = System . currentTimeMillis ( ) ; <END> } 
public TYPE_2 ( String uri ) { <START> this ( uri , ( TYPE_1 ) null ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( this . METHOD_2 ( ) ) { <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> } this . VAR_2 . METHOD_1 ( VAR_1 ) ; } 
private void METHOD_1 ( long VAR_1 ) { if ( this . VAR_2 != null && METHOD_2 ( ) . exists ( ) ) { TYPE_1 event = new TYPE_1 ( this , this . file , VAR_1 ) ; this . VAR_2 . METHOD_3 ( event ) ; } else { <START> logger . info ( STRING_1 ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = super . METHOD_1 ( ) ; if ( VAR_1 instanceof TYPE_2 ) { ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( Object . VAR_2 , Object . VAR_2 ) ; if ( VAR_3 ) { try { Class < ? > VAR_4 = Class . VAR_5 ( VAR_6 ) ; <START> ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( ( TYPE_3 ) VAR_4 . METHOD_4 ( ) ) ; <END> } catch ( Exception VAR_7 ) { } } } return VAR_1 ; } 
public int METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 instanceof TYPE_2 ) { return ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( ) ; } <START> return this . VAR_2 . get ( ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 ... VAR_1 ) { <END> this . target . VAR_2 ( Arrays . asList ( VAR_1 ) ) ; return this ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) { <END> this . target = VAR_2 ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { <START> return new TYPE_2 ( VAR_1 ) ; <END> } 
private static boolean METHOD_1 ( File source , File target ) throws IOException { TYPE_1 . METHOD_2 ( source . VAR_1 ( ) , target . VAR_1 ( ) , TYPE_2 . VAR_3 ) ; <START> return true ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_6 . TYPE_7 . TYPE_8 request = VAR_1 . METHOD_2 ( VAR_3 ) ; final TYPE_6 . TYPE_7 . TYPE_8 VAR_4 = request ; try { VAR_1 . METHOD_3 ( request . VAR_5 ( ) , ( TYPE_3 ) session - > VAR_4 ) ; } catch ( TYPE_4 e ) { } <START> catch ( TYPE_5 e ) { <END> } } 
public void METHOD_1 ( ) { new TYPE_1 ( this . VAR_1 ) . execute ( status - > { final int VAR_2 = VAR_3 . update ( STRING_1 ) ; final int VAR_4 = VAR_3 . update ( STRING_2 ) ; final int VAR_5 = VAR_3 . update ( STRING_3 ) ; <START> LOG . info ( String . format ( STRING_4 + <END> STRING_5 , VAR_4 , VAR_2 , VAR_5 ) ) ; return null ; } ) ; } 
<START> public TYPE_1 ( String path , String [ ] VAR_2 ) { <END> this . path = path ; this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( boolean VAR_1 ) { <START> if ( ! this . VAR_2 ) { <END> METHOD_2 ( new TYPE_1 ( ) ) ; } this . VAR_1 = VAR_1 ; } 
protected TYPE_1 < ? > METHOD_1 ( ) { if ( this . VAR_1 != null ) { return this . VAR_1 . METHOD_2 ( this . VAR_2 ) ; } else { <START> return this . source . VAR_3 ( ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 channel = new TYPE_1 ( METHOD_2 ( TYPE_2 . class ) ) ; try { <START> channel . VAR_1 ( METHOD_2 ( TYPE_3 . class ) ) ; <END> METHOD_3 ( STRING_1 ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , METHOD_4 ( STRING_2 + STRING_3 ) ) ; } channel . VAR_2 ( METHOD_2 ( TYPE_4 . class ) ) ; channel . VAR_3 ( ) ; channel . VAR_1 ( METHOD_2 ( TYPE_3 . class ) ) ; } 
public static < T > TYPE_1 < T > METHOD_1 ( TYPE_2 < T > message ) { Assert . VAR_1 ( message , STRING_1 ) ; if ( message instanceof TYPE_3 ) { return ( ( TYPE_3 < T > ) message ) . METHOD_2 ( ) ; } else { return new TYPE_1 < T > ( message . VAR_2 ( ) , message ) ; <START> } <END> } 
public Map < String , Object > METHOD_1 ( ) { <START> return this . properties ; <END> } 
public Map < String , Object > METHOD_1 ( ) { <START> return this . properties == null ? null : this . properties ; <END> } 
<START> public static TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return TYPE_3 . METHOD_2 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return this . VAR_1 == null ? null : this . VAR_1 ; <END> } 
private TYPE_1 METHOD_1 ( String name , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> String VAR_3 = VAR_2 == null ? STRING_1 : VAR_2 . toString ( ) ; <END> return new TYPE_1 ( this . VAR_4 . METHOD_3 ( ) , name , VAR_1 , VAR_3 ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { if ( this . VAR_2 == null ) { METHOD_2 ( VAR_1 ? TYPE_1 . METHOD_3 ( STRING_1 ) : TYPE_1 . METHOD_3 ( STRING_2 ) ) ; <START> } <END> } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; this . VAR_1 = VAR_1 ; } 
protected void METHOD_1 ( ) { Assert . state ( this . VAR_1 != null || StringUtils . VAR_2 ( this . VAR_3 ) , STRING_1 ) ; if ( this . VAR_3 != null ) { <START> synchronized ( this ) { <END> if ( this . VAR_3 != null ) { this . VAR_1 = METHOD_2 ( ) . METHOD_3 ( this . VAR_3 ) ; this . VAR_3 = null ; } } } } 
protected void METHOD_1 ( ) { try { this . VAR_1 = false ; <START> this . VAR_2 . METHOD_2 ( Math . VAR_3 ( this . VAR_4 , this . VAR_5 ) , TimeUnit . VAR_6 ) ; <END> } catch ( InterruptedException e ) { logger . debug ( STRING_1 ) ; Thread . VAR_7 ( ) . METHOD_3 ( ) ; } finally { this . VAR_8 = false ; } } 
public void METHOD_1 ( TYPE_1 session , Throwable exception ) { if ( exception instanceof TYPE_2 ) { this . session = null ; TYPE_4 . this . VAR_2 = false ; <START> METHOD_2 ( ) ; <END> } synchronized ( this . VAR_3 ) { for ( TYPE_3 VAR_4 : this . VAR_3 ) { VAR_4 . METHOD_1 ( session , exception ) ; } } } 
public Object METHOD_1 ( TYPE_1 < ? > message , Class < ? > VAR_1 ) { try { TYPE_1 < ? > VAR_2 = TYPE_2 . METHOD_1 ( message ) . build ( ) ; <START> return this . VAR_3 . METHOD_2 ( VAR_2 ) ; <END> } catch ( IOException e ) { throw new TYPE_3 ( message , e ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { int id = VAR_2 . getId ( ) ; TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( id ) ; if ( VAR_3 != null ) { <START> throw new TYPE_3 ( ( String . format ( STRING_1 , VAR_3 ) ) ) ; <END> } if ( log . VAR_4 ( ) ) { log . info ( String . format ( STRING_2 , VAR_2 , VAR_2 . METHOD_3 ( ) . getClass ( ) . getName ( ) ) ) ; } VAR_1 . METHOD_1 ( VAR_2 ) ; } 
public TYPE_1 ( ) { <START> super ( ) ; <END> this . VAR_2 = VAR_3 ; } 
public TYPE_4 ( TYPE_1 VAR_2 ) { Assert . VAR_3 ( VAR_2 , STRING_1 ) ; this . VAR_2 = VAR_2 ; if ( ! VAR_4 ) { <START> this . VAR_5 = new TYPE_2 < String , TYPE_3 > ( ) { <END> @Override protected boolean METHOD_1 ( Entry < String , TYPE_3 > VAR_6 ) { return size ( ) > VAR_7 ; } } ; } else { this . VAR_5 = null ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = super . METHOD_1 ( VAR_1 ) && VAR_1 instanceof TYPE_2 && this . VAR_3 . remove ( VAR_1 ) ; if ( VAR_2 ) { this . VAR_4 -- ; return true ; } else { <START> return false ; <END> } } 
public void METHOD_1 ( boolean VAR_1 ) { <START> VAR_2 . METHOD_1 ( VAR_1 ) ; <END> } 
public boolean remove ( TYPE_1 VAR_1 ) { this . size -- ; <START> return this . VAR_2 . remove ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = this . METHOD_2 ( VAR_2 ) ; <START> TYPE_2 VAR_3 = new TYPE_2 ( VAR_1 ) ; <END> VAR_4 = new TYPE_3 ( VAR_3 ) ; } 
public void METHOD_1 ( ) throws Exception { boolean VAR_1 = VAR_2 . METHOD_2 ( VAR_3 , VAR_4 , STRING_1 ) ; METHOD_3 ( VAR_1 ) ; <START> <END> String VAR_5 = VAR_2 . METHOD_4 ( VAR_3 , VAR_4 ) ; METHOD_5 ( VAR_5 ) ; VAR_1 = VAR_2 . METHOD_2 ( VAR_3 , VAR_4 , STRING_1 ) ; assertTrue ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = VAR_2 . remove ( VAR_3 ) ; METHOD_2 ( VAR_1 ) ; VAR_1 = VAR_2 . METHOD_3 ( VAR_3 , VAR_4 ) ; METHOD_2 ( VAR_1 ) ; VAR_1 = VAR_2 . remove ( VAR_3 ) ; assertNotNull ( VAR_1 ) ; <START> assertEquals ( VAR_4 , VAR_1 ) ; <END> } 
public TYPE_3 ( TYPE_1 factory , String VAR_2 ) { Assert . VAR_3 ( factory , STRING_1 ) ; Assert . VAR_4 ( VAR_2 , STRING_2 ) ; VAR_5 = new TYPE_2 ( factory ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
public void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 ) { this . VAR_2 = true ; } this . VAR_1 = VAR_1 ; <START> if ( this . VAR_3 != null ) { <END> this . VAR_3 . METHOD_2 ( VAR_1 ) ; } } 
TYPE_1 < ? > METHOD_1 ( Object target ) throws TYPE_2 { if ( target instanceof String ) { try { TYPE_3 VAR_1 = this . VAR_2 . METHOD_2 ( ( String ) target ) ; return METHOD_3 ( VAR_1 ) ; } catch ( TYPE_4 e ) { throw new TYPE_2 ( STRING_1 , e ) ; } catch ( IOException e ) { throw new TYPE_2 ( STRING_1 , e ) ; } } else { <START> throw new IllegalStateException ( STRING_2 ) ; <END> } } 
public TYPE_2 ( ) { <START> this . parser = new TYPE_1 ( ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 < ? > VAR_1 = this . VAR_2 . METHOD_2 ( new TYPE_2 < String > ( STRING_1 ) ) ; Object VAR_3 = VAR_1 . METHOD_3 ( ) ; assertThat ( VAR_3 , METHOD_4 ( List . VAR_4 ) ) ; <START> assertThat ( ( ( List ) VAR_3 ) . size ( ) , METHOD_5 ( 1 ) ) ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; <START> return ! ( node != null ? ! node . equals ( that . node ) : that . node != null ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return this . VAR_1 ; } 
public void METHOD_1 ( Map < String , String > VAR_1 ) { Assert . VAR_2 ( VAR_1 ) ; TYPE_1 VAR_3 = new TYPE_1 ( ) ; <START> for ( String key : VAR_1 . keySet ( ) ) { <END> String value = VAR_1 . get ( key ) ; String [ ] values = StringUtils . VAR_4 ( value ) ; for ( String v : values ) { VAR_3 . add ( key , v ) ; } } METHOD_2 ( VAR_3 ) ; } 
<START> public long METHOD_1 ( ) { <END> return VAR_1 . get ( ) ; } 
protected Collection < TYPE_1 > METHOD_1 ( TYPE_2 < ? > message ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; <START> TYPE_3 < TYPE_4 > VAR_2 = this . VAR_3 ; <END> for ( TYPE_4 VAR_4 : VAR_2 ) { if ( VAR_4 . METHOD_2 ( message ) ) { VAR_1 . add ( VAR_4 . METHOD_3 ( ) ) ; } } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { return VAR_1 ; <START> } <END> 
public void METHOD_1 ( ) { this . METHOD_2 ( false ) ; if ( this . VAR_1 != null ) { try { <START> this . VAR_1 . close ( ) ; <END> } catch ( Exception e ) { logger . error ( STRING_1 , e ) ; } } if ( this . VAR_2 == null ) { return ; } try { this . VAR_2 . close ( ) ; } catch ( IOException e ) { } this . VAR_2 = null ; super . METHOD_1 ( ) ; } 
protected void METHOD_1 ( ) { <START> if ( this . METHOD_2 ( ) != null ) { <END> Integer VAR_1 = TYPE_1 . METHOD_3 ( this . METHOD_2 ( ) ) ; if ( VAR_1 != null ) { if ( TYPE_1 . VAR_2 == VAR_1 ) { VAR_3 . METHOD_4 ( true ) ; } else { VAR_3 . METHOD_5 ( VAR_1 ) ; } } } } 
public TYPE_3 ( TYPE_1 VAR_2 , String VAR_3 ) throws IOException { <START> this ( VAR_2 , TYPE_2 . valueOf ( VAR_3 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { try { this . VAR_2 . METHOD_1 ( VAR_1 ) ; } finally { <START> this . VAR_3 = new TYPE_2 ( 1 ) ; <END> } } 
protected void METHOD_1 ( ) { try { this . VAR_1 = false ; this . VAR_2 . METHOD_2 ( Math . VAR_3 ( this . VAR_4 , this . VAR_5 ) , TimeUnit . VAR_6 ) ; <START> this . VAR_7 = false ; <END> } catch ( InterruptedException e ) { logger . debug ( STRING_1 ) ; Thread . VAR_8 ( ) . METHOD_3 ( ) ; } } 
public static void METHOD_1 ( String [ ] args ) throws Exception { TYPE_1 ctx = new TYPE_2 ( STRING_1 , TYPE_3 . class ) ; System . out . println ( STRING_2 ) ; System . in . read ( ) ; <START> ctx . close ( ) ; <END> ctx . VAR_1 ( ) ; } 
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( STRING_1 ) . append ( this . name ) . append ( STRING_2 ) . append ( this . value ) . append ( STRING_3 ) . append ( this . VAR_1 ) <START> . append ( STRING_4 ) . append ( this . VAR_2 ) <END> . append ( STRING_5 ) ; return builder . toString ( ) ; } 
<START> public TYPE_1 getMessage ( ) { <END> return message ; } 
protected TYPE_1 METHOD_1 ( ) { if ( this . VAR_1 != null ) { return TYPE_2 . METHOD_1 ( this . VAR_1 ) ; } else { <START> return null ; <END> } } 
public boolean METHOD_1 ( ) { if ( this . VAR_1 < 0 ) { return false ; } long time = System . currentTimeMillis ( ) ; <START> if ( this . VAR_1 == 0 || ( time - this . VAR_2 . get ( ) ) > this . VAR_1 ) { <END> this . VAR_2 . set ( time ) ; boolean VAR_3 = this . source . VAR_4 ( ) ; if ( VAR_3 ) { this . VAR_5 = null ; } return VAR_3 ; } return false ; } 
public void put ( String key , String value ) { Assert . VAR_1 ( key , STRING_1 ) ; Assert . VAR_1 ( value , STRING_2 ) ; <START> TYPE_1 < String , String > VAR_2 = VAR_3 . METHOD_1 ( key ) ; <END> VAR_2 . set ( value ) ; } 
public String get ( String key ) { Assert . VAR_1 ( key , STRING_1 ) ; <START> TYPE_1 < String , String > VAR_2 = VAR_3 . METHOD_1 ( key ) ; <END> return VAR_2 . get ( ) ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; this . VAR_1 . METHOD_2 ( this . METHOD_3 ( ) ) ; if ( this . VAR_2 == null ) { this . VAR_2 = TYPE_1 . METHOD_4 ( METHOD_3 ( ) ) ; <START> } <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( this . VAR_2 != null ) { VAR_1 . METHOD_2 ( this . VAR_2 ) ; } if ( this . VAR_3 != null ) { VAR_1 . METHOD_3 ( this . VAR_3 ) ; } else { <START> VAR_1 . METHOD_3 ( true ) ; <END> } if ( this . VAR_4 != null ) { logger . warn ( STRING_1 ) ; VAR_1 . METHOD_4 ( this . VAR_4 ) ; } } 
TYPE_1 METHOD_1 ( Object VAR_1 , String VAR_2 ) { TYPE_1 VAR_3 = null ; VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; if ( VAR_3 != null ) { return VAR_3 ; } <START> else { <END> TYPE_2 VAR_4 = ( StringUtils . VAR_5 ( VAR_2 ) ) ? new TYPE_2 ( VAR_1 , VAR_2 ) : new TYPE_2 ( VAR_1 ) ; return this . METHOD_3 ( VAR_4 ) ; } } 
public TYPE_1 < ? > METHOD_1 ( long VAR_1 ) { try { if ( this . VAR_2 < 0 ) { this . VAR_3 . METHOD_2 ( ) ; } else { if ( ! this . VAR_3 . METHOD_2 ( this . VAR_2 , TimeUnit . VAR_4 ) ) { this . VAR_5 = true ; } } } catch ( InterruptedException e ) { Thread . VAR_6 ( ) . METHOD_3 ( ) ; } <START> this . VAR_7 = true ; <END> return this . message ; } 
protected boolean METHOD_1 ( ) { <START> return this . METHOD_2 ( ) ? this . VAR_1 : true ; <END> } 
<START> protected Object METHOD_1 ( TYPE_1 < ? > VAR_1 ) { <END> Object result = this . METHOD_2 ( VAR_1 ) ; if ( this . METHOD_3 ( ) ) { this . METHOD_4 ( VAR_1 , result ) ; } return result ; } 
public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { List < TYPE_2 > VAR_2 = new ArrayList < > ( this . VAR_3 ) ; VAR_2 . addAll ( VAR_1 ) ; <START> return new TYPE_1 ( VAR_2 ) ; <END> } 
<START> public synchronized TYPE_1 METHOD_1 ( <END> int VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 type , boolean VAR_4 ) { byte [ ] VAR_5 = VAR_2 . METHOD_2 ( ) ; return METHOD_1 ( VAR_1 , VAR_5 , VAR_3 , type , VAR_4 ) ; } 
public int METHOD_1 ( ) { int VAR_1 = ( int ) version ^ STRING_1 . METHOD_1 ( ) ^ VAR_2 . METHOD_1 ( ) ; <START> return VAR_3 . METHOD_1 ( VAR_1 ) ; <END> } 
public byte [ ] METHOD_1 ( ) { try { if ( VAR_1 != null ) return Arrays . VAR_2 ( VAR_1 , VAR_1 . length ) ; TYPE_1 VAR_3 = new TYPE_1 ( ) ; for ( TYPE_2 VAR_4 : VAR_5 ) { <START> VAR_3 . write ( VAR_4 . METHOD_2 ( ) ) ; <END> } VAR_1 = VAR_3 . METHOD_2 ( ) ; return VAR_1 ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
public TYPE_1 getKey ( ) { <START> final TYPE_1 key = TYPE_1 . METHOD_1 ( Arrays . VAR_1 ( VAR_2 , INT_1 ) ) ; <END> return METHOD_2 ( ) ? key : key . VAR_3 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 output ) throws IOException { TYPE_5 . TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; <START> int VAR_3 = VAR_2 . METHOD_3 ( ) ; <END> int VAR_4 = VAR_3 > this . VAR_5 ? this . VAR_5 : VAR_3 ; final TYPE_4 VAR_6 = TYPE_4 . METHOD_4 ( output , VAR_4 ) ; VAR_2 . METHOD_5 ( VAR_6 ) ; VAR_6 . METHOD_6 ( ) ; } 
public static byte [ ] METHOD_1 ( final int VAR_1 , final int VAR_2 ) { final int VAR_3 = 4 ; METHOD_2 ( VAR_2 <= VAR_3 ) ; final byte [ ] VAR_4 = ByteBuffer . VAR_5 ( VAR_3 ) . METHOD_3 ( TYPE_1 . VAR_7 ) . METHOD_4 ( VAR_1 ) . METHOD_5 ( ) ; <START> if ( VAR_2 != VAR_3 ) { <END> return Arrays . VAR_8 ( VAR_4 , VAR_2 ) ; } else { return VAR_4 ; } } 
<START> public final TYPE_1 METHOD_1 ( ) { <END> if ( null == this . VAR_1 ) { this . VAR_1 = METHOD_2 ( false , false ) ; } return VAR_1 ; } 
TYPE_6 ( TYPE_1 params , TYPE_2 VAR_2 , TYPE_3 output ) { super ( params ) ; long VAR_3 = output . VAR_4 ( ) ; try { VAR_5 = new TYPE_4 ( params , VAR_3 , output . VAR_6 ( ) ) ; <START> } catch ( TYPE_5 e ) { <END> VAR_5 = new TYPE_4 ( params , output ) ; } VAR_7 = VAR_8 ; VAR_9 = VAR_10 ; METHOD_1 ( VAR_2 ) ; this . value = output . getValue ( ) ; length = INT_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , byte [ ] data ) throws Exception { String id = METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( ) ; try { <START> if ( VAR_3 . containsKey ( id ) ) <END> return ; else { VAR_1 . METHOD_5 ( this , data ) ; METHOD_6 ( VAR_1 ) ; } } finally { VAR_2 . METHOD_7 ( ) ; } } 
public boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> return METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 event ) { if ( event instanceof TYPE_2 ) { TYPE_3 VAR_1 = METHOD_2 ( event ) ; if ( ( VAR_1 != null && VAR_1 . METHOD_3 ( ) ) <START> || this . METHOD_4 ( ) . METHOD_5 ( ) ) { <END> METHOD_6 ( ) . remove ( ( TYPE_2 ) event ) ; } } } 
public void run ( ) { TYPE_1 VAR_1 = METHOD_1 ( ) ; if ( VAR_1 == null ) { return ; } if ( StringUtils . isEmpty ( VAR_1 . METHOD_2 ( ) ) ) { return ; } <START> if ( ! VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) { <END> return ; } VAR_1 . METHOD_5 ( ) ; } 
<START> public long METHOD_1 ( ) { <END> long VAR_1 = 0 ; for ( TYPE_1 server : TYPE_2 . METHOD_2 ( ) ) { VAR_1 += server . VAR_2 ( ) . METHOD_3 ( ) ; } long VAR_3 = VAR_1 / Math . max ( 1 , TYPE_2 . METHOD_2 ( ) . size ( ) ) ; return Math . max ( TYPE_3 . VAR_5 , VAR_3 ) ; } 
public void METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) { if ( this . VAR_1 != null ) { this . VAR_2 = true ; } } else { if ( ! VAR_1 . equals ( this . VAR_1 ) ) { <START> this . VAR_2 = true ; <END> } else { this . VAR_2 = false ; } } this . VAR_1 = VAR_1 ; } 
public void run ( ) { TYPE_1 VAR_1 = METHOD_1 ( ) ; if ( VAR_1 == null ) { return ; } <START> if ( VAR_1 . METHOD_2 ( ) == null || VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) { <END> return ; } VAR_1 . METHOD_3 ( ) ; } 
TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; <START> } <END> return VAR_1 ; } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { final List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( VAR_1 . METHOD_2 ( ) . length ) ; for ( Entry entry : VAR_1 . METHOD_2 ( ) ) { if ( entry == null ) { continue ; } <START> VAR_2 . add ( entry . VAR_3 ( ) ) ; <END> } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 event , TYPE_2 r , String VAR_1 ) { TYPE_3 VAR_2 = METHOD_2 ( event ) ; if ( VAR_2 != null ) { Entry entry = VAR_2 . METHOD_3 ( r . VAR_3 ( ) ) ; if ( entry != null ) { <START> logger . info ( STRING_1 , event , VAR_1 ) ; <END> entry . VAR_4 ( VAR_1 ) ; } } } 
public static TYPE_1 getInstance ( ) { TYPE_2 < TYPE_1 > VAR_1 = TYPE_3 . getInstance ( ) . METHOD_1 ( TYPE_1 . class ) ; <START> if ( VAR_1 == null ) { <END> return null ; } return VAR_1 . get ( 0 ) ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 == null ) { try { VAR_1 = TYPE_1 . METHOD_2 ( ) <START> . METHOD_3 ( VAR_2 . METHOD_4 ( VAR_3 ) , TimeUnit . VAR_4 ) <END> . build ( ) ; logger . info ( STRING_1 , VAR_2 , VAR_3 ) ; } catch ( Exception ex ) { logger . warn ( STRING_2 , VAR_2 , VAR_3 ) ; return false ; } } return true ; } 
public List < TYPE_1 > METHOD_1 ( List < TYPE_2 > list ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( list . size ( ) ) ; for ( TYPE_2 VAR_2 : list ) { try { TYPE_3 VAR_3 = VAR_4 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; VAR_1 . add ( new TYPE_1 ( VAR_2 , VAR_3 ) ) ; <START> } catch ( TYPE_4 e ) { <END> } } return VAR_1 ; } 
public void METHOD_1 ( int VAR_1 , int VAR_2 ) { VAR_3 . update ( STRING_1 , <START> new Object [ ] { new Integer ( VAR_1 ) , new Integer ( VAR_2 ) } <END> ) ; } 
public String METHOD_1 ( ) { String VAR_1 [ ] = this . id . split ( STRING_1 ) ; int VAR_2 = VAR_1 . length ; String VAR_3 = "" ; <START> if ( VAR_1 != null && VAR_1 . length > 0 ) { <END> VAR_3 = VAR_1 [ VAR_2 - 1 ] ; } return VAR_3 ; } 
public Set < String > METHOD_1 ( ) { <START> String [ ] VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 ) ; <END> TYPE_2 < String > VAR_2 = new TYPE_2 < String > ( ) ; VAR_2 . addAll ( Arrays . asList ( VAR_1 ) ) ; if ( ! this . VAR_3 ) { VAR_2 . remove ( VAR_4 ) ; } return VAR_2 ; } 
private int METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public void METHOD_1 ( List < Response . TYPE_1 > VAR_2 , Response response ) { for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { <START> Response . TYPE_1 listener = VAR_2 . get ( i ) ; <END> if ( listener instanceof Response . TYPE_2 ) METHOD_1 ( ( Response . TYPE_2 ) listener , response ) ; } } 
<START> public TYPE_2 . TYPE_3 METHOD_1 ( ) <END> { return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { start ( VAR_1 , new TYPE_2 ( ) ) ; Response response = client . VAR_2 ( STRING_1 , VAR_3 . METHOD_2 ( ) ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) . path ( STRING_2 ) . METHOD_5 ( 5 , TimeUnit . VAR_4 ) . METHOD_6 ( ) ; assertNotNull ( response ) ; assertEquals ( INT_1 , response . getStatus ( ) ) ; <START> METHOD_7 ( response . VAR_5 ( ) . contains ( TYPE_4 . TYPE_5 . METHOD_8 ( ) ) ) ; <END> } 
public String METHOD_1 ( ) { <START> return VAR_1 == null ? null : VAR_1 . toString ( ) ; <END> } 
public void METHOD_1 ( int VAR_1 ) { VAR_2 = VAR_1 ; <START> System . err . println ( STRING_1 + VAR_1 ) ; <END> if ( LOG . VAR_3 ( ) ) { if ( VAR_2 <= 0 ) LOG . debug ( STRING_2 , VAR_2 ) ; else LOG . debug ( STRING_3 , VAR_2 ) ; } } 
public int METHOD_1 ( ) { <START> System . err . println ( STRING_1 ) ; <END> if ( ! METHOD_2 ( ) ) throw new IllegalStateException ( ) ; if ( ! VAR_1 ) throw new TYPE_1 ( ) ; int VAR_2 = - 1 ; if ( VAR_3 != null ) { VAR_2 = VAR_3 . METHOD_3 ( ) ; System . err . println ( STRING_2 + VAR_2 ) ; } return ( int ) TimeUnit . VAR_4 . METHOD_4 ( VAR_2 ) ; } 
protected void METHOD_1 ( TYPE_1 field , Throwable t ) { LOG . warn ( STRING_1 , field , t ) ; <START> throw new TYPE_2 ( STRING_2 + field . getName ( ) ) ; <END> } 
public TYPE_1 ( String instance ) { this . VAR_2 = Utils . VAR_3 ( instance ) ; <START> this . url = Constants . VAR_4 ; <END> VAR_5 . start ( ) ; VAR_6 . start ( ) ; } 
protected void METHOD_1 ( ) { METHOD_1 ( false ) ; <START> if ( VAR_1 ) { <END> TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; } } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> if ( VAR_2 . size ( ) == 0 ) { <END> return VAR_1 ; } for ( String key : VAR_3 ) { if ( VAR_2 . contains ( key ) ) { try { VAR_1 . put ( key , false ) ; } catch ( TYPE_2 e ) { TYPE_3 . METHOD_2 ( ) . e ( TAG , e . toString ( ) ) ; } } } return VAR_1 ; } 
private String METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) context . VAR_2 ( Context . VAR_3 ) ; try { if ( VAR_1 . METHOD_2 ( ) != TYPE_1 . VAR_4 ) { String VAR_5 = VAR_1 . METHOD_3 ( ) ; if ( VAR_5 != null ) { return VAR_5 . METHOD_4 ( TYPE_6 . VAR_7 ) ; } } <START> } catch ( TYPE_2 e ) { <END> } catch ( TYPE_4 . TYPE_5 e ) { } return null ; } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return Arrays . asList ( METHOD_2 ( 0 , 0 ) , METHOD_2 ( 1 , 2 ) , METHOD_2 ( 0 , 1 ) ) ; } 
public void setText ( final String text ) { <START> if ( this . text != null ) { <END> this . text . setText ( text ) ; return ; } this . text = new TYPE_1 ( text ) ; add ( this . text , ( TYPE_2 ) METHOD_1 ( ) ) ; } 
public TYPE_2 ( final TYPE_1 VAR_2 , final TYPE_1 ... VAR_3 ) { METHOD_1 ( VAR_2 , VAR_3 ) ; <START> METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( int index ) { <START> if ( index < 0 || index > Constants . VAR_1 ) { <END> throw new TYPE_2 ( ) ; } final TYPE_1 VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; final int x = VAR_2 . x - 3 + ( index % 4 ) * VAR_3 ; final int y = VAR_2 . y - 2 + ( index / 4 ) * VAR_4 ; return new TYPE_1 ( x + VAR_3 / 2 , y + VAR_4 / 2 ) ; } 
public boolean METHOD_1 ( ) { <START> return ctx . VAR_1 . METHOD_2 ( ) . size ( ) > Constants . VAR_2 - 1 ; <END> } 
public void METHOD_1 ( ) { if ( METHOD_2 ( ) > 0 && ! METHOD_3 ( ) ) { METHOD_4 ( ) ; } else if ( ! METHOD_3 ( ) ) { METHOD_5 ( ) ; } else if ( METHOD_3 ( ) && METHOD_2 ( ) > 0 ) { METHOD_6 ( ) ; <START> } else { <END> METHOD_7 ( ) ; } } 
public boolean METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( INT_1 , INT_2 ) , new TYPE_2 ( INT_3 , INT_4 ) ) ; <END> return VAR_1 . contains ( ctx . VAR_2 . METHOD_2 ( ) ) ; } 
public void start ( ) { <START> if ( ! ctx . VAR_1 . METHOD_1 ( ) ) { <END> ctx . VAR_2 . METHOD_2 ( ) ; return ; } System . out . println ( STRING_1 ) ; TYPE_1 . METHOD_3 ( new TYPE_2 ( ) { @Override public void run ( ) { new TYPE_3 ( ) ; } } ) ; } 
public TYPE_1 METHOD_1 ( ) { for ( TYPE_1 b : TYPE_1 . values ( ) ) { <START> if ( ( ctx . VAR_1 . METHOD_2 ( Constants . VAR_2 ) & INT_1 ) == <END> b . VAR_3 ) return b ; } return TYPE_1 . VAR_4 ; } 
public boolean METHOD_1 ( final boolean key ) { <START> final TYPE_1 c = METHOD_2 ( ) ; <END> if ( c != null ) { if ( key ) { ctx . input . METHOD_3 ( STRING_1 ) ; return true ; } else { return c . VAR_1 ( ) ; } } return false ; } 
public TYPE_2 ( ) { VAR_2 = new TYPE_1 ( ) ; file = new File ( ) ; path = new Path ( ) ; <START> VAR_3 = new HashMap < > ( ) ; <END> } 
public static String METHOD_1 ( File file ) { String VAR_1 ; try { VAR_1 = TYPE_1 . METHOD_2 ( file . VAR_2 ( ) ) ; <START> } catch ( Exception e ) { <END> VAR_1 = null ; } return VAR_1 . METHOD_3 ( ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 , String content ) throws IOException { logger . info ( STRING_1 , VAR_1 , content == null ? "" : STRING_2 + content + STRING_3 ) ; String VAR_2 = STRING_4 + VAR_1 + STRING_5 ; if ( content != null ) { VAR_2 += STRING_6 + content ; } <START> TYPE_1 response = VAR_3 . METHOD_2 ( STRING_7 , null , VAR_2 , 10 , STRING_8 ) ; <END> assertThat ( response . VAR_4 ( ) . METHOD_3 ( ) , is ( INT_1 ) ) ; return response ; } 
private void METHOD_1 ( ) { <START> if ( ! options . VAR_1 ( ) ) <END> VAR_2 = VAR_3 == 0 ? INT_1 : System . currentTimeMillis ( ) + VAR_3 * INT_2 ; else { long VAR_4 = System . currentTimeMillis ( ) ; long VAR_5 = options . VAR_6 ( ) * INT_2 - ( VAR_4 - VAR_7 ) ; VAR_2 = VAR_3 == 0 || ( VAR_5 <= 0 ) ? INT_1 : Math . VAR_8 ( VAR_4 + VAR_3 * INT_2 , VAR_4 + VAR_5 ) ; } listener . VAR_9 ( ) ; } 
public boolean METHOD_1 ( ) { long VAR_1 = System . currentTimeMillis ( ) ; <START> return VAR_2 == 0 || VAR_1 <= VAR_2 && ( ! options . VAR_3 ( ) || options . VAR_4 ( ) * INT_1 > VAR_1 - VAR_5 ) ; <END> } 
public void METHOD_1 ( ) { final int VAR_1 = INT_1 ; final TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) . METHOD_3 ( VAR_4 - > { } ) . METHOD_4 ( VAR_1 , METHOD_5 ( s - > VAR_3 . METHOD_6 ( ) . METHOD_7 ( VAR_4 - > { } ) . METHOD_4 ( VAR_1 , METHOD_8 ( error - > { assertNotNull ( error ) ; METHOD_9 ( ) ; } ) ) ) ) ; METHOD_10 ( ) ; <START> VAR_2 . close ( ) ; <END> } 
void METHOD_1 ( ) { <START> METHOD_1 ( VAR_1 , true , TYPE_1 . METHOD_2 ( ) ) ; <END> } 
public < T > T METHOD_1 ( Class < T > type ) { try { if ( type == TYPE_1 . class || type == TYPE_2 . class ) { return ( T ) TYPE_3 . METHOD_2 ( buffer . toString ( ) ) ; } else { return TYPE_3 . METHOD_2 ( buffer . toString ( ) , type ) ; } } catch ( Exception e ) { <START> e . VAR_1 ( ) ; <END> throw new TYPE_4 ( e . getMessage ( ) ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . from ( STRING_1 ) ; <START> TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( TYPE_2 . create ( STRING_2 ) ) ; <END> TYPE_1 VAR_3 = TYPE_1 . create ( ) . append ( STRING_3 ) . append ( STRING_4 ) ; } 
void METHOD_1 ( ) { if ( status . VAR_1 ( Status . VAR_2 , Status . VAR_3 ) ) { <START> VAR_4 . METHOD_2 ( TYPE_1 . METHOD_3 ( new TYPE_2 ( STRING_1 ) ) ) ; <END> } } 
void METHOD_1 ( ) { <START> TYPE_1 < TYPE_2 > VAR_1 = this . VAR_1 ; <END> synchronized ( VAR_2 ) { METHOD_2 ( ) ; TYPE_1 < TYPE_2 > VAR_3 = this . VAR_3 ; if ( VAR_3 != null ) { VAR_2 . METHOD_3 ( ) . METHOD_4 ( VAR_3 ) ; } } if ( VAR_1 != null ) { VAR_1 . METHOD_5 ( null ) ; } } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> if ( VAR_1 ) { <END> assertTrue ( STRING_1 , VAR_2 ) ; VAR_3 = TYPE_1 . METHOD_2 ( STRING_2 , STRING_3 ) ; VAR_4 = TYPE_2 . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ; } else { VAR_4 = TYPE_2 . METHOD_5 ( INT_1 , STRING_4 ) ; } VAR_5 = VAR_6 . METHOD_6 ( ) ; } 
protected < T > TYPE_1 < T > METHOD_1 ( String VAR_1 , TYPE_2 < T > TYPE_3 , boolean VAR_2 , boolean VAR_3 ) { TYPE_4 . METHOD_2 ( TYPE_3 . METHOD_3 ( ) , STRING_1 ) ; TYPE_5 result = METHOD_4 ( VAR_1 , TYPE_3 , VAR_2 , VAR_3 ) ; METHOD_1 ( result . VAR_4 , VAR_1 , VAR_2 , VAR_3 , TYPE_3 : : METHOD_5 ) ; <START> return result . VAR_5 ; <END> } 
public synchronized void close ( ) { <START> synchronized ( this ) { <END> if ( VAR_1 >= 0 ) { client . VAR_2 ( ) . METHOD_1 ( VAR_1 ) ; VAR_1 = - 1 ; } } VAR_3 . clear ( ) ; for ( TYPE_1 VAR_4 : VAR_5 . values ( ) ) { VAR_4 . close ( ) ; } } 
private synchronized void METHOD_1 ( ) { <START> if ( VAR_1 >= 0 ) { <END> long VAR_2 = System . currentTimeMillis ( ) ; VAR_3 . values ( ) . forEach ( e - > e . VAR_4 . METHOD_2 ( VAR_2 ) ) ; VAR_1 = client . VAR_5 ( ) . METHOD_3 ( 1 , id - > METHOD_1 ( ) ) ; } } 
static void METHOD_1 ( Object obj ) { if ( obj instanceof String || obj instanceof Integer || obj instanceof Long || obj instanceof Boolean || obj instanceof Double || obj instanceof TYPE_1 || obj instanceof TYPE_2 || obj instanceof TYPE_3 || obj instanceof TYPE_4 || obj instanceof byte [ ] || <START> obj instanceof TYPE_5 || <END> obj instanceof TYPE_6 || obj instanceof TYPE_7 ) { } else { throw new IllegalArgumentException ( STRING_1 + obj . getClass ( ) . getName ( ) ) ; } } 
void METHOD_1 ( TYPE_1 data ) { synchronized ( VAR_1 ) { <START> VAR_2 += data . VAR_3 ( ) . METHOD_2 ( ) ; <END> if ( VAR_4 != null ) { try { VAR_4 . METHOD_3 ( new TYPE_2 ( data . VAR_3 ( ) ) ) ; } catch ( TYPE_4 . TYPE_5 e ) { METHOD_4 ( e ) ; } } if ( VAR_5 != null ) { VAR_5 . METHOD_5 ( data ) ; } } } 
<START> void add ( TYPE_1 VAR_1 ) { <END> if ( VAR_2 == null ) { VAR_2 = new TYPE_2 < > ( ) ; } VAR_2 . add ( VAR_1 ) ; } 
boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) ; <END> } 
private List < String > METHOD_1 ( ) { List < String > args = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 != null ) { <START> args . addAll ( <END> VAR_2 . stream ( ) . map ( entry - > STRING_1 + entry ) . collect ( Collectors . VAR_3 ( ) ) ) ; } args . add ( STRING_2 + getId ( ) ) ; return args ; } 
public List < String > METHOD_1 ( ) { <START> final List < String > VAR_1 = TYPE_1 . METHOD_2 ( ) ; <END> return VAR_1 != null ? VAR_1 : TYPE_2 . VAR_3 ; } 
public void METHOD_1 ( ) throws Exception { <START> String [ ] args = new String [ ] { STRING_1 } ; <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . run ( args ) ; assertEquals ( System . getProperty ( STRING_2 ) , VAR_1 . METHOD_2 ( ) ) ; } 
<START> protected String METHOD_1 ( String s ) { <END> if ( s == null || s . length ( ) == 0 ) { return s ; } int VAR_1 = s . length ( ) ; while ( VAR_1 > 0 && TYPE_1 . METHOD_2 ( s . VAR_2 ( VAR_1 - 1 ) ) ) { -- VAR_1 ; } return s . substring ( 0 , VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 request ) { if ( ! METHOD_2 ( ) ) return ; <START> VAR_1 . put ( request , time ( null , null ) ) ; <END> } 
public Boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 String name ) { final TYPE_2 parent = VAR_1 . METHOD_2 ( ) ; if ( parent instanceof TYPE_3 && METHOD_3 ( ( TYPE_3 ) parent ) ) { <START> return TYPE_5 . TYPE_6 . equals ( name ) ? Boolean . VAR_2 : null ; <END> } return null ; } 
public TYPE_1 METHOD_1 ( ) throws IOException { <START> final TYPE_1 VAR_1 = this . METHOD_2 ( ) . METHOD_1 ( ) ; <END> return this . out ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 { <START> List < TYPE_3 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 . getKey ( ) , TYPE_5 . VAR_5 ) ; <END> Set < String > VAR_6 = VAR_2 . stream ( ) . map ( TYPE_3 : : getPath ) . collect ( Collectors . VAR_7 ( ) ) ; for ( String path : VAR_6 ) { VAR_8 . METHOD_3 ( VAR_1 , path , new TYPE_4 ( ) . set ( VAR_9 , Boolean . VAR_10 ) ) ; } } 
public String METHOD_1 ( String VAR_1 ) { if ( StringUtils . VAR_2 ( VAR_3 ) || ! VAR_1 . contains ( VAR_3 ) ) { return VAR_1 ; } final int VAR_4 = VAR_1 . METHOD_2 ( VAR_3 ) + VAR_3 . length ( ) ; final String VAR_5 = VAR_1 . substring ( VAR_4 ) ; <START> return VAR_5 . startsWith ( STRING_1 ) ? VAR_5 : STRING_1 + VAR_5 ; <END> } 
public String toString ( ) { return STRING_1 + STRING_2 + name + CHAR_1 + STRING_3 + url + CHAR_1 + STRING_4 + user + CHAR_1 <START> + STRING_5 + VAR_1 + CHAR_1 + STRING_6 + VAR_2 + CHAR_1 <END> + STRING_7 + VAR_3 + CHAR_1 + STRING_8 + VAR_4 + STRING_9 + VAR_5 + STRING_10 + properties + CHAR_2 ; } 
private void METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) { logger . info ( STRING_1 ) ; return ; } TYPE_1 builder = new TYPE_1 ( ) ; <START> builder . VAR_2 ( ) . host ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; <END> VAR_3 = new TYPE_2 ( builder . build ( ) ) ; logger . info ( STRING_2 ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> VAR_2 = new TYPE_1 ( VAR_1 , VAR_3 ) ; <END> VAR_2 . METHOD_2 ( VAR_4 ) ; for ( TYPE_2 VAR_5 : VAR_6 ) { VAR_5 . METHOD_3 ( VAR_2 . format ( VAR_5 . METHOD_4 ( ) ) ) ; } METHOD_5 ( ) ; } 
public View METHOD_1 ( int position , View VAR_1 , TYPE_1 parent ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; if ( VAR_2 == null ) { VAR_2 = TYPE_2 . create ( parent , VAR_3 , VAR_4 , listener , VAR_5 ) ; } <START> VAR_2 . METHOD_2 ( this . VAR_6 ) ; <END> VAR_2 . METHOD_3 ( VAR_7 . get ( position ) , VAR_8 . get ( position ) ) ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( Collection < Date > VAR_1 ) { <START> if ( VAR_1 != null ) { <END> METHOD_2 ( VAR_1 ) ; } return this ; } 
public int METHOD_1 ( TYPE_1 o ) { if ( VAR_1 == o . VAR_1 ) { if ( VAR_2 == o . VAR_2 ) { return 0 ; } <START> return VAR_2 < o . VAR_2 ? - 1 : 1 ; <END> } return VAR_1 < o . VAR_1 ? - 1 : 1 ; } 
public boolean METHOD_1 ( Class < ? > VAR_1 ) { return VAR_1 . METHOD_2 ( ) || VAR_1 . METHOD_3 ( ) || TYPE_1 . class . METHOD_4 ( VAR_1 ) || String . VAR_2 . equals ( VAR_1 ) || TYPE_2 . VAR_2 . equals ( VAR_1 ) || Boolean . VAR_2 . equals ( VAR_1 ) || TYPE_4 . TYPE_5 . Date . VAR_2 . METHOD_4 ( VAR_1 ) <START> || TYPE_4 . TYPE_5 . TYPE_6 . VAR_2 . METHOD_4 ( VAR_1 ) ; <END> } 
private boolean METHOD_1 ( ) { return Optional . VAR_1 ( VAR_2 ) <START> . map ( TYPE_1 : : METHOD_2 ) <END> . isPresent ( ) ; } 
public TYPE_1 METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; <START> return VAR_1 ; <END> } 
public int METHOD_1 ( TYPE_1 state ) { int i = 0 ; if ( state . getValue ( VAR_1 ) ) { i = 1 ; } <START> return i ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 state , TYPE_5 entity ) { double VAR_4 = 1 ; double VAR_5 = FLOAT_1 ; double VAR_6 = FLOAT_2 ; entity . VAR_7 = 0 ; TYPE_6 VAR_8 = ( TYPE_6 ) VAR_1 ; <START> entity . VAR_4 = VAR_4 + VAR_5 * ( VAR_8 . METHOD_2 ( 0 ) . METHOD_3 ( ) - 1 ) + VAR_6 * ( VAR_8 . METHOD_2 ( 1 ) . METHOD_3 ( ) - 1 ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { <START> return new TYPE_2 ( STRING_1 + getName ( ) + STRING_2 ) . METHOD_2 ( ) + STRING_3 + VAR_2 ; <END> } 
public String METHOD_1 ( ) { <START> return new TYPE_1 ( STRING_1 ) . METHOD_2 ( ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { <START> return new TYPE_2 ( STRING_1 ) . METHOD_2 ( ) ; <END> } 
public String METHOD_1 ( ) { <START> return new TYPE_1 ( STRING_1 + getName ( ) + STRING_2 , METHOD_2 ( ) ) . METHOD_3 ( ) ; <END> } 
public static void METHOD_1 ( TYPE_1 event ) { if ( ! TYPE_3 . values . VAR_2 ) { <START> if ( event . VAR_3 ( ) . equals ( TYPE_2 . VAR_5 . VAR_6 . TYPE_4 . VAR_8 ) ) { <END> event . VAR_9 ( ) . clear ( ) ; } } } 
public static TYPE_1 METHOD_1 ( TYPE_1 [ ] VAR_1 , TYPE_2 VAR_2 ) { for ( TYPE_3 VAR_3 : VAR_4 ) { TYPE_1 VAR_5 = VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; <START> if ( VAR_5 != null && VAR_5 != TYPE_1 . VAR_6 ) { <END> return VAR_5 ; } } return null ; } 
<START> public boolean equals ( Object o ) { <END> if ( o instanceof TYPE_1 ) return ( ( TYPE_1 ) o ) . METHOD_1 ( ) . equals ( description ) ; return false ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; METHOD_1 ( true ) ; <START> METHOD_2 ( 0 ) ; <END> } 
<START> public TYPE_2 ( TYPE_1 item , int VAR_2 ) { <END> this ( item , VAR_2 , 0 , null ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . getClass ( ) . getName ( ) ; <START> return TYPE_2 . class . METHOD_2 ( ) . length > 0 <END> && ! VAR_2 . equals ( STRING_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( ! METHOD_2 ( VAR_1 ) ) return ; for ( TYPE_3 config : VAR_3 ) { List < TYPE_1 > VAR_4 = config . VAR_5 ( VAR_1 . METHOD_3 ( ) , null ) ; <START> for ( TYPE_1 project : VAR_4 ) <END> TYPE_4 . add ( VAR_1 , project , config , VAR_2 ) ; } } 
public static void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> TYPE_2 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } 
public static void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } 
public boolean run ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 cmd , String VAR_3 , String [ ] args , boolean VAR_4 ) { <START> if ( args . length != 2 ) <END> { return false ; } final TYPE_2 VAR_5 = METHOD_1 ( args [ 0 ] ) ; if ( VAR_5 == null ) { METHOD_2 ( TYPE_4 . VAR_7 ) ; return true ; } METHOD_3 ( VAR_5 ) ; return true ; } 
<START> private String METHOD_1 ( final String VAR_1 ) { <END> final int VAR_2 = VAR_1 . METHOD_2 ( CHAR_1 ) ; return VAR_2 == - 1 ? "" : VAR_1 . substring ( VAR_2 + 1 ) ; } 
private String METHOD_1 ( final String VAR_1 , final TYPE_1 v ) { if ( v != null && ( v . VAR_2 ( TYPE_1 . VAR_3 ) == - 1 <START> || v . VAR_2 ( TYPE_1 . VAR_4 ) == 1 ) ) { <END> return String . format ( STRING_1 , VAR_1 , v ) ; } return null ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( STRING_1 , TYPE_1 . VAR_2 , 0 , 0 ) ; <END> METHOD_2 ( STRING_2 , TYPE_1 . VAR_2 , 0 , 2 ) ; METHOD_2 ( STRING_3 , TYPE_1 . VAR_2 , 0 , 0 ) ; METHOD_2 ( STRING_4 , TYPE_1 . VAR_2 , 0 , 0 ) ; } 
public void METHOD_1 ( final int version , final int VAR_1 , final String name , final String VAR_2 , final String VAR_3 , final String [ ] VAR_4 ) { <START> VAR_5 . clear ( ) ; <END> VAR_6 . METHOD_2 ( VAR_7 . get ( VAR_2 ) ) ; VAR_6 . METHOD_3 ( VAR_7 . get ( VAR_3 ) ) ; VAR_6 . METHOD_4 ( VAR_7 . get ( VAR_4 ) ) ; } 
public void METHOD_1 ( final byte [ ] buffer , final String location ) throws IOException { try { METHOD_1 ( new TYPE_1 ( buffer ) ) ; <START> } catch ( final Exception VAR_1 ) { <END> throw METHOD_2 ( location , VAR_1 ) ; } } 
public void METHOD_1 ( final TYPE_1 input , final TYPE_2 output , final String name ) throws IOException { try { output . write ( METHOD_1 ( input , name ) ) ; } catch ( final RuntimeException e ) { <START> throw METHOD_2 ( name , e ) ; <END> } } 
public byte [ ] METHOD_1 ( final byte [ ] buffer , final String name ) throws IOException { try { if ( TYPE_1 . METHOD_2 ( buffer ) ) { final byte [ ] result = METHOD_1 ( new TYPE_2 ( TYPE_1 . METHOD_3 ( buffer ) ) ) ; TYPE_1 . METHOD_4 ( result ) ; return result ; } else { return METHOD_1 ( new TYPE_2 ( buffer ) ) ; } } catch ( final RuntimeException e ) { <START> throw METHOD_5 ( STRING_1 + name , e ) ; <END> } } 
private static boolean METHOD_1 ( final int size , TYPE_1 e , TYPE_1 n ) { for ( int i = 0 ; i < size ; i ++ ) { <START> if ( e . VAR_1 ( ) != n . VAR_1 ( ) ) { <END> return false ; } e = next ( e ) ; n = next ( n ) ; } return true ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( TYPE_3 . VAR_3 ) , INT_1 ) ; VAR_4 . METHOD_2 ( VAR_1 , 0 ) ; assertEquals ( 1 , VAR_1 . METHOD_3 ( ) ) ; try { VAR_4 . METHOD_2 ( VAR_1 , 0 ) ; METHOD_4 ( STRING_1 ) ; <START> } catch ( IllegalStateException e ) { <END> } } 
protected void METHOD_1 ( ) { final String name = METHOD_2 ( ) ; final TYPE_1 VAR_1 = METHOD_3 ( ) . METHOD_4 ( ) ; final String VAR_2 = VAR_1 . getProperty ( name ) ; if ( VAR_2 == null ) { METHOD_5 ( ) . info ( name + STRING_1 ) ; VAR_1 . METHOD_6 ( name , "" ) ; } else { <START> METHOD_5 ( ) . info ( name + STRING_2 + VAR_2 ) ; <END> } } 
public void METHOD_1 ( ) { <START> TYPE_1 options = new TYPE_1 ( ) ; <END> TYPE_1 options = new TYPE_1 ( STRING_1 ) ; assertEquals ( STRING_2 , options . VAR_1 ( ) ) ; } 
<START> public double METHOD_1 ( final TYPE_1 entity ) { <END> double VAR_1 = VAR_2 ; if ( this . configuration . get ( entity ) != null ) { VAR_1 = this . configuration . get ( entity ) . METHOD_2 ( ) ; } return VAR_1 ; } 
<START> public TYPE_4 ( TYPE_1 VAR_2 , String VAR_3 , TYPE_2 VAR_4 ) { <END> this ( ) ; TYPE_3 . METHOD_1 ( VAR_2 , STRING_1 ) ; TYPE_3 . METHOD_1 ( VAR_3 , STRING_2 ) ; METHOD_2 ( VAR_2 ) ; METHOD_3 ( VAR_3 ) ; if ( VAR_4 != null ) { METHOD_4 ( VAR_4 ) ; } } 
public void METHOD_1 ( TYPE_1 query , String VAR_1 , Class < ? > type ) { if ( query instanceof TYPE_2 ) { <START> query . VAR_2 ( TYPE_2 . class ) . METHOD_1 ( VAR_1 , type ) ; <END> } else { throw new IllegalArgumentException ( String . format ( STRING_1 , query . getClass ( ) ) ) ; } } 
private static String METHOD_1 ( String name ) { if ( TYPE_1 . METHOD_2 ( name ) ) { name = name + STRING_1 ; } <START> if ( ! TYPE_2 . METHOD_3 ( name . VAR_1 ( 0 ) ) ) { <END> name = STRING_2 + name ; } return name ; } 
<START> public TYPE_1 ( Type type , Set < TYPE_2 > VAR_1 , TYPE_3 < TYPE_1 , String > VAR_2 ) { <END> super ( type ) ; this . VAR_3 = VAR_2 . apply ( this ) ; this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; } 
public TYPE_3 ( Type type , Set < TYPE_1 > VAR_2 ) { super ( type ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = new TYPE_2 ( ) . apply ( this ) ; <END> } 
private < TYPE_1 > TYPE_2 < TYPE_1 , TYPE_3 < TYPE_1 > > METHOD_1 ( TYPE_4 < TYPE_1 > VAR_1 ) { <START> return new TYPE_2 < TYPE_1 , TYPE_3 < TYPE_1 > > ( ( Class ) VAR_1 . getType ( ) ) { <END> @Override protected TYPE_3 < TYPE_1 > METHOD_2 ( Class < TYPE_1 > type , TYPE_4 < TYPE_1 > VAR_2 ) { return TYPE_5 . METHOD_3 ( type , TYPE_6 . VAR_4 , VAR_2 ) ; } } . METHOD_4 ( when , VAR_1 ) ; } 
public static String METHOD_1 ( Path < ? > path , int VAR_1 ) { <START> String VAR_2 = path . VAR_3 ( TYPE_1 . VAR_5 , VAR_6 ) . METHOD_2 ( CHAR_1 , CHAR_2 ) ; <END> return VAR_2 + STRING_1 + VAR_1 ; } 
private String METHOD_1 ( TYPE_1 < ? > VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( ) { @Override protected TYPE_3 exists ( Context c , TYPE_3 VAR_3 ) { return VAR_3 ; } } ; <START> TYPE_1 < ? > VAR_4 = VAR_1 . METHOD_2 ( VAR_2 , new Context ( ) ) ; <END> return VAR_4 . toString ( ) ; } 
public void TYPE_1 ( ) { <START> < < < < < < < VAR_2 <END> assertEquals ( ImmutableList . of ( 1 , 2 , 2 , 2 , 2 , 2 ) , query ( ) . from ( VAR_3 ) . VAR_4 ( VAR_3 . id . VAR_5 ( ) ) . VAR_6 ( VAR_3 . name . when ( STRING_1 ) . VAR_7 ( 1 ) . VAR_8 ( 2 ) ) . VAR_9 ( ) ) ; } 
public static boolean isEmpty ( Object [ ] VAR_1 ) { <START> return VAR_1 == null ? true : VAR_1 . length == 0 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return ; } try { VAR_1 . METHOD_2 ( ) ; <START> } catch ( TYPE_2 ex ) { <END> logger . error ( STRING_1 , VAR_2 , ex ) ; } } 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { synchronized ( this ) { if ( VAR_1 == null ) { try { VAR_1 = ( TYPE_1 ) Class . VAR_2 ( ( String ) getProperty ( TYPE_5 . TYPE_6 ) ) . METHOD_2 ( ) ; <START> } catch ( TYPE_2 | TYPE_3 | TYPE_4 e ) { <END> LOG . error ( STRING_1 , e ) ; } } } } return VAR_1 ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { TYPE_1 VAR_2 = VAR_1 . get ( ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( VAR_3 ) ; } } <START> VAR_4 . METHOD_3 ( ) ; <END> } 
TYPE_1 < T > METHOD_1 ( Object obj ) { if ( VAR_1 == null ) { return null ; } TYPE_2 < T > VAR_2 = VAR_1 . get ( obj ) ; if ( VAR_2 == null ) { VAR_2 = new TYPE_2 < T > ( this ) ; <START> } <END> TYPE_2 < T > VAR_3 = VAR_1 . METHOD_2 ( obj , VAR_2 ) ; if ( VAR_3 != null ) { return VAR_3 ; } else { return VAR_2 ; } } 
<START> public void METHOD_1 ( ) { <END> if ( VAR_1 . METHOD_2 ( false , true ) ) { for ( TYPE_1 < TYPE_2 , TYPE_3 > listener : VAR_2 ) { try { listener . VAR_3 ( context . VAR_4 ( listener ) ) ; } catch ( Throwable e ) { if ( e instanceof TYPE_4 ) { throw ( TYPE_4 ) e ; } logger . error ( STRING_1 + listener , e ) ; } } } } 
void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 = Integer . parseInt ( VAR_1 . getProperty ( <END> TYPE_2 . TYPE_3 , VAR_5 ) . toString ( ) ) ; boolean VAR_6 = this . METHOD_2 ( ) ; this . METHOD_3 ( false ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; if ( VAR_6 && this . METHOD_6 ( ) != null ) { this . METHOD_6 ( ) . METHOD_7 ( METHOD_8 ( true ) ) ; } this . METHOD_3 ( VAR_6 ) ; } 
static List < Date > METHOD_1 ( long VAR_1 , ANNOTATION_1 Long VAR_2 ) { List < Date > result = new ArrayList < > ( ) ; <START> for ( Long VAR_3 : TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 ) ) { <END> result . add ( new Date ( VAR_3 ) ) ; } return result ; } 
<START> Optional < String > METHOD_1 ( ) { <END> return Optional . VAR_1 ( VAR_2 ) ; } 
public void METHOD_1 ( Integer VAR_1 ) { <START> this . VAR_1 = VAR_1 * INT_1 ; <END> } 
public TYPE_1 execute ( TYPE_2 ctx , TYPE_3 req ) throws Exception { String VAR_1 = VAR_2 . METHOD_1 ( ) ; <START> if ( TYPE_4 . METHOD_2 ( VAR_1 ) ) { <END> ctx . VAR_3 ( TYPE_5 . VAR_5 , VAR_1 ) ; } return METHOD_3 ( ) . execute ( ctx , req ) ; } 
@Override public TYPE_1 < TYPE_2 > METHOD_1 ( List < TYPE_3 > VAR_1 ) { TYPE_1 < TYPE_2 > call = VAR_2 . METHOD_1 ( VAR_1 ) ; <START> if ( METHOD_2 ( ) ) return call ; <END> return new TYPE_4 < > ( VAR_3 , VAR_2 . METHOD_1 ( VAR_1 ) , STRING_1 ) ; } 
@Override protected void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( ( response , t ) - > { if ( t != null ) { VAR_1 . METHOD_4 ( t ) ; } else { try { VAR_1 . METHOD_5 ( METHOD_6 ( response , VAR_2 ) ) ; <START> } catch ( Throwable e ) { <END> VAR_1 . METHOD_4 ( e ) ; } } return null ; } ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 parser , String path ) throws IOException { if ( ! parser . VAR_1 ( ) ) return null ; TYPE_2 value ; while ( ( value = parser . VAR_2 ( ) ) != TYPE_2 . VAR_3 ) { if ( value == null ) { <START> throw new IOException ( STRING_1 ) ; <END> } if ( parser . VAR_4 ( ) . equals ( path ) && value != TYPE_2 . VAR_5 ) { return parser ; } else { parser . VAR_6 ( ) ; } } return null ; } 
public TYPE_1 METHOD_1 ( TYPE_2 ctx , TYPE_3 req , Throwable VAR_1 ) { TYPE_4 . VAR_3 . METHOD_2 ( ) ; <START> LOGGER . warn ( STRING_1 , VAR_1 ) ; <END> String message = VAR_1 . getMessage ( ) != null ? VAR_1 . getMessage ( ) : "" ; if ( VAR_1 instanceof IllegalArgumentException ) { return TYPE_1 . of ( VAR_4 , TYPE_5 . VAR_6 , message ) ; } else { return TYPE_1 . of ( VAR_7 , TYPE_5 . VAR_6 , message ) ; } } 
@Override final String METHOD_1 ( int length ) { <START> String result = new String ( buf , VAR_1 , length , VAR_2 ) ; <END> VAR_1 += length ; return result ; } 
public void close ( ) { TYPE_1 VAR_1 = METHOD_1 ( ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; try { <START> VAR_1 . METHOD_3 ( 5 , TimeUnit . VAR_2 ) ; <END> } catch ( InterruptedException e ) { } } } 
TYPE_3 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_2 . METHOD_1 ( ) ; <START> this . VAR_4 = Collections . VAR_5 ( new TYPE_2 < String , Set < Pair < String > > > ( ) { <END> @Override protected boolean METHOD_2 ( Map . Entry < String , Set < Pair < String > > > VAR_6 ) { return size ( ) > VAR_7 ; } } ) ; } 
<START> public void METHOD_1 ( String VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
public void METHOD_1 ( ) { assertThat ( TYPE_1 . METHOD_1 ( TYPE_2 . builder ( ) . METHOD_2 ( INT_1 ) . METHOD_3 ( STRING_1 ) . METHOD_4 ( Constants . VAR_1 ) . METHOD_5 ( TYPE_3 . VAR_3 , STRING_2 ) . build ( ) ) ) <START> . METHOD_6 ( STRING_1 , STRING_3 , STRING_4 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> final TYPE_1 VAR_1 = ( ) - > Collections . VAR_2 ( new TYPE_2 < TYPE_3 > ( STRING_1 , INT_1 ) ) ; <END> final TYPE_4 < String > response = METHOD_2 ( VAR_1 ) ; assertThat ( response . VAR_3 ( ) , METHOD_3 ( TYPE_5 . VAR_5 ) ) ; assertThat ( response . VAR_6 ( ) . METHOD_4 ( ) . toString ( ) , METHOD_3 ( STRING_2 ) ) ; } 
private boolean METHOD_1 ( ) { if ( VAR_1 != null ) { return VAR_1 . METHOD_2 ( ) ; } <START> VAR_1 = METHOD_3 ( VAR_2 ) ; <END> return VAR_1 . METHOD_2 ( ) ; } 
<START> <END> <END> default <END> <END> <END> VAR_1 VAR_2 <END> ( <END> <END> TYPE_1 ... VAR_2 <END> ) <END> { <END> VAR_2 ( new HashSet <END> <END> < <END> > <END> ( <END> Arrays 
protected int METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 instanceof Double ) { return TYPE_2 . METHOD_1 ( ( Double ) VAR_1 , VAR_2 , TYPE_4 . VAR_4 ) ; } if ( VAR_1 instanceof TYPE_3 ) { return TYPE_2 . METHOD_1 ( ( TYPE_3 ) VAR_1 , VAR_2 , TYPE_4 . VAR_4 ) ; <START> } <END> return TYPE_2 . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
public Optional < TYPE_1 > METHOD_1 ( Class < ? > VAR_1 , String VAR_2 ) { TYPE_2 . assertNotNull ( VAR_1 , TYPE_3 . METHOD_2 ( ) ) ; TYPE_4 field = run ( TYPE_5 . action ( VAR_1 , VAR_2 ) ) ; <START> String VAR_3 = VAR_4 . getName ( METHOD_3 ( VAR_1 , VAR_2 ) ) ; <END> return Optional . VAR_5 ( field ) . map ( f - > new TYPE_1 ( f , VAR_3 ) ) ; } 
<START> @Override public Type [ ] METHOD_1 ( ) { <END> return method . VAR_1 ( ) ; } 
public TYPE_1 < ? > METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 instanceof TYPE_3 ) { return new TYPE_4 ( ( TYPE_3 < ? > ) VAR_1 ) ; } <START> return METHOD_1 ( VAR_1 . METHOD_2 ( ) , ( ( TYPE_5 ) VAR_1 ) ) ; <END> } 
@Override public Class < ? > METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , Set < TYPE_1 > VAR_2 ) { if ( ! VAR_2 . add ( VAR_1 ) ) { return false ; } Class < ? extends TYPE_1 > VAR_3 = VAR_1 . METHOD_2 ( ) ; return TYPE_2 . contains ( VAR_3 ) || Arrays . stream ( VAR_3 . METHOD_3 ( ) ) <START> . METHOD_4 ( VAR_4 - > METHOD_1 ( VAR_4 , VAR_2 ) ) ; <END> } 
TYPE_9 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 , T VAR_7 , Class < T > VAR_8 , TYPE_6 < T > VAR_9 , TYPE_7 VAR_10 , Optional < TYPE_8 > VAR_11 , Object VAR_12 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , METHOD_1 ( VAR_11 ) ) ; this . VAR_10 = VAR_10 ; this . VAR_12 = VAR_12 ; <START> this . VAR_11 = VAR_11 ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } <START> if ( o == null || o . getClass ( ) != TYPE_1 . class ) { <END> return false ; } TYPE_1 that = ( TYPE_1 ) o ; if ( VAR_1 != that . VAR_1 ) { return false ; } if ( ! group . equals ( that . group ) ) { return false ; } return true ; } 
public boolean equals ( Object o ) { TYPE_1 that = ( TYPE_1 ) o ; if ( VAR_1 != that . VAR_1 ) { return false ; } if ( VAR_2 != that . VAR_2 ) { return false ; } if ( ! path . equals ( that . path ) ) { return false ; } <START> <END> return true ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 , TYPE_3 VAR_2 ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; METHOD_3 ( VAR_3 ) ; this . VAR_4 = VAR_3 . METHOD_4 ( ) ; this . VAR_5 = VAR_3 . METHOD_5 ( ) ; <START> this . VAR_6 = TYPE_4 . METHOD_6 ( VAR_3 . METHOD_5 ( ) ) ; <END> METHOD_7 ( VAR_2 ) ; } 
public < T > T METHOD_1 ( String VAR_1 , Class < T > type ) { <START> if ( ! parameters . containsKey ( VAR_1 ) ) { <END> throw LOG . VAR_2 ( VAR_1 , null ) ; } Object VAR_3 = parameters . get ( VAR_1 ) ; if ( ! type . VAR_4 ( VAR_3 . getClass ( ) ) ) { throw LOG . VAR_5 ( type , VAR_3 . getClass ( ) ) ; } return ( T ) VAR_3 ; } 
private static int METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < ? > VAR_2 ) { <START> int result = VAR_1 != null ? VAR_1 . METHOD_2 ( ) : 0 ; <END> result = INT_1 * result + VAR_2 . METHOD_2 ( ) ; return result ; } 
public TYPE_1 < T > METHOD_1 ( ) { <START> if ( VAR_1 != null && VAR_2 == null ) { <END> VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; } return VAR_2 ; } 
private static int METHOD_1 ( TYPE_1 < ? > VAR_1 , TYPE_2 location , List < TYPE_3 > VAR_2 ) { final int VAR_3 = INT_1 ; int result = 1 ; <START> result = VAR_3 * result + ( VAR_1 != null ? VAR_1 . METHOD_2 ( ) : 0 ) ; <END> result = VAR_3 * result + ( location != null ? location . VAR_4 ( ) : 0 ) ; return result ; } 
public static < T > ArrayList < T > METHOD_1 ( int size ) { <START> return new ArrayList < T > ( METHOD_2 ( size ) ) ; <END> } 
Type METHOD_1 ( ) { return VAR_1 ; <START> } <END> 
private TYPE_1 METHOD_1 ( TYPE_2 < ? > config ) { TYPE_3 VAR_1 = config . VAR_2 ( ) ; String VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( VAR_3 == null ) { return config . VAR_4 ( ) ; } ANNOTATION_1 ( STRING_1 ) <START> Class < TYPE_1 > VAR_5 = ( Class < TYPE_1 > ) run ( <END> TYPE_4 . action ( VAR_3 , null ) ) ; return METHOD_3 ( VAR_5 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; Set < TYPE_3 < TYPE_2 > > VAR_3 = VAR_1 . METHOD_3 ( VAR_2 , STRING_1 ) ; <START> METHOD_4 ( VAR_3 , 1 ) ; <END> METHOD_5 ( VAR_3 , STRING_1 ) ; } 
public void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { <START> VAR_1 . forEach ( this : : METHOD_2 ) ; <END> } 
<START> protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_2 . contains ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . toString ( ) ) ; } 
protected TYPE_2 ( Set < ? extends TYPE_1 < ? > > VAR_2 ) { <START> super ( new ArrayList ( VAR_2 ) ) ; <END> this . VAR_2 = VAR_2 ; } 
protected TYPE_2 ( Set < TYPE_1 > VAR_2 ) { <START> super ( new ArrayList ( VAR_2 ) ) ; <END> this . VAR_2 = VAR_2 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { for ( TYPE_2 e : VAR_1 . METHOD_2 ( ) ) { TYPE_1 method = e . VAR_2 ( new TYPE_3 < TYPE_1 , TYPE_4 > ( ) { @Override public TYPE_1 METHOD_3 ( TYPE_1 e , TYPE_4 p ) { if ( e . VAR_3 ( ) . METHOD_4 ( STRING_1 ) ) { return e ; } <START> return super . METHOD_3 ( e , p ) ; <END> } } , null ) ; if ( method != null ) { return method ; } } return null ; } 
public static String METHOD_1 ( TYPE_1 < ? > VAR_1 , String VAR_2 ) { StringBuilder sb = new StringBuilder ( ) ; boolean VAR_3 = true ; for ( Object object : VAR_1 ) { if ( ! VAR_3 ) { sb . append ( VAR_2 ) ; } else { VAR_3 = false ; } <START> sb . append ( object ) ; <END> } return sb . toString ( ) ; } 
public Object METHOD_1 ( TYPE_1 context , Object VAR_1 , Object method , Class < ? > [ ] VAR_2 , Object [ ] params ) { if ( METHOD_2 ( context , VAR_1 , method ) ) { throw new TYPE_2 ( STRING_1 ) ; } Object VAR_3 = null ; <START> if ( VAR_1 instanceof TYPE_3 ) { <END> VAR_3 = METHOD_3 ( context , VAR_1 , method , VAR_2 , params ) ; } return VAR_3 ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> METHOD_2 ( this , STRING_1 , VAR_1 ) ; } 
public void METHOD_1 ( int VAR_1 , int VAR_2 ) { boolean VAR_3 = ! VAR_4 && VAR_1 > 0 ; boolean VAR_5 = VAR_1 > 0 ; boolean VAR_6 = VAR_2 > 0 ; String VAR_7 = VAR_1 > 1 ? <START> TYPE_1 . METHOD_2 ( ) : TYPE_1 . METHOD_3 ( ) ; <END> VAR_8 . METHOD_4 ( VAR_9 , VAR_7 ) ; VAR_8 . METHOD_5 ( TYPE_1 . METHOD_6 ( ) , VAR_3 ) ; VAR_8 . METHOD_7 ( VAR_9 , VAR_5 ) ; VAR_8 . METHOD_5 ( TYPE_1 . METHOD_8 ( ) , VAR_6 ) ; } 
public final boolean METHOD_1 ( ) { if ( VAR_1 >= TYPE_2 . VAR_3 ) { return ( VAR_4 != null && TYPE_1 . METHOD_2 ( VAR_4 ) ) ; } <START> else <END> return ( VAR_4 != null ) ; } 
public int METHOD_1 ( ) { try { <START> return ( int ) Math . VAR_1 ( Double . VAR_2 ( METHOD_2 ( VAR_3 ) ) ) ; <END> } catch ( TYPE_1 e ) { return 0 ; } } 
public int METHOD_1 ( ) { try { <START> return ( int ) Math . VAR_1 ( Double . VAR_2 ( METHOD_2 ( VAR_3 ) ) ) ; <END> } catch ( TYPE_1 e ) { return 0 ; } } 
<START> public void METHOD_1 ( boolean b ) { <END> VAR_1 = b ; } 
public TYPE_3 ( TYPE_1 view ) { super ( view . VAR_2 ( ) . METHOD_1 ( ) ) ; <START> this . view = view ; <END> VAR_3 = new TYPE_2 ( ) ; METHOD_2 ( ) ; METHOD_3 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { List < String > VAR_2 = VAR_1 . METHOD_2 ( ) ; for ( String column : VAR_2 ) { TYPE_2 data = new TYPE_2 ( VAR_3 ) ; METHOD_3 ( data ) ; <START> data . VAR_4 ( TYPE_3 . this ) ; <END> data . VAR_6 ( STRING_1 , column ) ; data . VAR_6 ( STRING_2 , column ) ; data . VAR_6 ( STRING_3 , VAR_1 . getName ( ) ) ; } } 
public List < List < String > > METHOD_1 ( List < String > VAR_1 ) { <START> ArrayList < List < String > > VAR_2 = new ArrayList < List < String > > ( ) ; <END> for ( String column : VAR_1 ) { int index = VAR_3 . METHOD_2 ( column ) ; List < String > VAR_4 = METHOD_3 ( index ) ; VAR_2 . add ( VAR_4 ) ; } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! this . VAR_1 . equals ( VAR_1 ) ) { <END> return ; } METHOD_2 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . remove ( VAR_1 ) ; <END> if ( VAR_2 . isEmpty ( ) ) { VAR_3 . METHOD_2 ( ) ; VAR_3 = null ; } } 
public void METHOD_1 ( String VAR_1 ) { this . VAR_1 = VAR_1 ; VAR_2 = context . VAR_3 ( VAR_1 , Context . VAR_4 ) ; <START> if ( VAR_5 != null ) { <END> VAR_2 . METHOD_2 ( VAR_5 ) ; } VAR_5 = new TYPE_2 . TYPE_3 ( ) { @Override public void METHOD_3 ( TYPE_2 VAR_2 , String key ) { METHOD_4 ( key , METHOD_5 ( key , null ) ) ; } } ; VAR_2 . METHOD_6 ( VAR_5 ) ; } 
<START> public List METHOD_1 ( String key ) { <END> Object value = METHOD_2 ( key , new ArrayList ( ) ) ; if ( value instanceof List ) { return ( List ) value ; } return new ArrayList ( ) ; } 
public synchronized T METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 < TYPE_1 > VAR_1 ) { try { return VAR_2 . METHOD_2 ( VAR_1 ) <START> . get ( ) ; <END> } catch ( InterruptedException e ) { e . VAR_3 ( ) ; } catch ( TYPE_3 e ) { e . VAR_3 ( ) ; } return new TYPE_1 ( ) ; } 
public void METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 ) { VAR_4 = VAR_1 ; VAR_5 = VAR_2 ; VAR_6 = VAR_2 ; VAR_7 = VAR_1 ; VAR_8 = VAR_3 ; METHOD_2 ( ) ; <START> if ( VAR_9 ) <END> METHOD_3 ( VAR_6 , VAR_7 ) ; else METHOD_3 ( VAR_1 , VAR_2 ) ; } 
private void METHOD_1 ( String value ) { VAR_1 = value ; TYPE_1 VAR_2 = ( TYPE_1 ) properties . getProperty ( VAR_3 ) . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; <START> if ( ! VAR_4 . isEmpty ( ) ) { <END> METHOD_4 ( VAR_4 ) ; } } 
public void METHOD_1 ( int VAR_1 ) { <START> if ( VAR_1 > INT_1 ) <END> VAR_2 = INT_2 ; else VAR_2 = VAR_1 ; METHOD_2 ( ) ; } 
public void METHOD_1 ( int VAR_1 , int VAR_2 , TYPE_1 data ) { if ( VAR_1 == this . VAR_1 && VAR_2 == TYPE_2 . VAR_4 ) { if ( data . VAR_5 ( TYPE_3 . VAR_7 ) ) { ArrayList < String > results = data . VAR_8 ( ) . METHOD_2 ( TYPE_3 . VAR_7 ) ; result = results . get ( 0 ) ; VAR_9 . METHOD_3 ( result ) ; } else { result = "" ; <START> } <END> } } 
public void METHOD_1 ( String text ) { result = text ; <START> METHOD_2 ( result ) ; <END> } 
public void METHOD_1 ( String text ) { result = text ; METHOD_2 ( result , false ) ; <START> METHOD_3 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( boolean VAR_1 ) { final TYPE_2 VAR_2 = new TYPE_2 ( ) ; <START> VAR_2 . METHOD_2 ( ) ; <END> return VAR_2 ; } 
private Integer METHOD_1 ( TYPE_1 VAR_1 , TYPE_3 . TYPE_4 VAR_2 ) { if ( VAR_2 == TYPE_3 . TYPE_4 . VAR_3 ) { <START> return ( VAR_1 . METHOD_2 ( ) + VAR_2 . METHOD_2 ( ) ) * 2 + 1 ; <END> } else { return ( VAR_1 . METHOD_2 ( ) + VAR_2 . METHOD_2 ( ) ) * 2 ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_3 . TYPE_4 VAR_2 ) { <START> for ( Integer key : VAR_3 . keySet ( ) ) { <END> VAR_3 . remove ( METHOD_2 ( VAR_1 , VAR_2 ) ) ; } } 
private TYPE_1 METHOD_1 ( String VAR_1 , int VAR_2 ) { <START> new TYPE_1 ( <END> new TYPE_1 . TYPE_5 ( VAR_3 . getName ( ) + STRING_1 + VAR_3 . METHOD_2 ( ) , VAR_2 ) , new TYPE_1 . TYPE_6 ( listener . VAR_4 ( ) , VAR_3 . METHOD_3 ( ) , null ) , VAR_1 , TYPE_4 . getInstance ( ) . config . VAR_5 ( ) ) ; } 
public TYPE_1 append ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <START> TYPE_2 VAR_3 = VAR_4 . get ( VAR_4 . size ( ) - 1 ) ; <END> if ( VAR_3 == null ) { VAR_3 = VAR_5 ; VAR_5 = null ; } if ( VAR_3 != null ) { VAR_1 . METHOD_1 ( VAR_3 , VAR_2 , false ) ; } VAR_4 . add ( VAR_1 ) ; METHOD_2 ( ) ; return this ; } 
<START> TYPE_1 ( TYPE_1 VAR_1 ) <END> { this ( ) ; METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { this . VAR_2 = true ; <START> VAR_3 . close ( VAR_4 . METHOD_2 ( STRING_1 , TYPE_2 . getInstance ( ) . METHOD_3 ( ) ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_1 ( VAR_1 , TYPE_2 . VAR_3 , false ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( METHOD_3 ( ) , this , VAR_1 ) [ 0 ] ; <END> VAR_2 = TYPE_2 . getInstance ( ) . METHOD_2 ( METHOD_3 ( ) , this , VAR_2 ) [ 0 ] ; METHOD_4 ( ) . METHOD_5 ( new TYPE_3 ( TYPE_4 . toString ( VAR_1 ) , TYPE_4 . toString ( VAR_2 ) ) ) ; } 
public TYPE_1 append ( String text , TYPE_2 VAR_1 ) { VAR_2 . add ( VAR_3 ) ; <START> <END> TYPE_3 VAR_4 = new TYPE_3 ( VAR_3 ) ; VAR_4 . setText ( text ) ; VAR_3 = VAR_4 ; METHOD_1 ( VAR_1 ) ; return this ; } 
public boolean METHOD_1 ( ) { <START> return ( VAR_1 != null ) ? VAR_1 . METHOD_2 ( ) : true ; <END> } 
public TYPE_3 ( TYPE_1 element , TYPE_2 options ) { this . VAR_2 = METHOD_1 ( element ) ; this . options = METHOD_2 ( options ) ; if ( options . VAR_3 ( ) != null ) { this . VAR_4 = options . VAR_3 ( ) . METHOD_3 ( ) ; } else { this . VAR_4 = METHOD_4 ( ) . METHOD_3 ( ) ; } <START> <END> METHOD_5 ( ) ; } 
public Integer METHOD_1 ( String s ) { <START> try { <END> return Integer . parseInt ( s ) ; } catch ( TYPE_1 e ) { TYPE_2 . log ( STRING_1 + s + STRING_2 ) ; return null ; } } 
<START> public static TYPE_1 METHOD_1 ( TYPE_2 context , TYPE_3 VAR_1 ) { <END> TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ; VAR_2 . METHOD_1 ( context ) ; return VAR_2 ; } 
private static TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { TYPE_3 VAR_2 = null ; TYPE_3 VAR_3 = null ; for ( TYPE_2 child : VAR_1 ) { if ( child . VAR_4 ( ) == TYPE_2 . VAR_5 ) { if ( VAR_2 == null ) { VAR_2 = ( TYPE_3 ) child ; } VAR_3 = ( TYPE_3 ) child ; } } <START> return new TYPE_1 ( VAR_2 , VAR_3 ) ; <END> } 
private static void METHOD_1 ( Exception e , TYPE_1 context , TYPE_2 VAR_1 ) { METHOD_2 ( e , context , VAR_1 ) ; <START> throw new IllegalStateException ( STRING_1 + VAR_1 . uri ( ) , e ) ; <END> } 
private void METHOD_1 ( TYPE_1 context , List < TYPE_2 > VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = context . VAR_4 ( ) . METHOD_2 ( VAR_2 ) ; for ( TYPE_2 VAR_5 : VAR_1 ) { <START> VAR_3 . METHOD_3 ( VAR_5 . METHOD_4 ( ) , VAR_5 . METHOD_5 ( ) , VAR_5 . METHOD_6 ( ) ) ; <END> } VAR_3 . METHOD_7 ( ) ; } 
<START> private static boolean METHOD_1 ( int line , int column , boolean VAR_1 ) { <END> if ( line == 1 ) { return column > ( VAR_1 ? 1 : 0 ) ; } return true ; } 
public List METHOD_1 ( ) { return ImmutableList . of ( TYPE_1 . builder ( TYPE_8 . VAR_2 ) . name ( STRING_1 ) . description ( STRING_2 ) . METHOD_2 ( STRING_3 ) . METHOD_3 ( STRING_4 ) . METHOD_4 ( TYPE_9 . VAR_4 ) . build ( ) , TYPE_2 . class , TYPE_3 . class , TYPE_4 . class , TYPE_5 . class , <START> TYPE_6 . class , <END> TYPE_7 . class ) ; } 
<START> protected TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , String VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
<START> public void METHOD_1 ( TYPE_1 parent ) { <END> this . VAR_1 . add ( parent ) ; parent . getKey ( ) . VAR_2 . add ( this ) ; } 
<START> private TYPE_1 < TYPE_2 > METHOD_1 ( String VAR_1 ) throws TYPE_3 { <END> TYPE_2 user ; try { user = VAR_2 . get ( ) . METHOD_2 ( STRING_1 + STRING_2 , TYPE_2 . class ) . METHOD_3 ( STRING_3 , VAR_1 ) . METHOD_4 ( ) ; return TYPE_1 . of ( user ) ; } catch ( TYPE_3 e ) { return TYPE_1 . METHOD_5 ( ) ; } } 
<START> public TYPE_1 ( double value ) { <END> this ( value , VAR_2 ) ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; Iterator < TYPE_1 > i = this . METHOD_2 ( TYPE_1 . class ) . iterator ( ) ; <START> while ( i . hasNext ( ) ) { <END> TYPE_1 a = i . next ( ) ; a . VAR_1 ( this ) ; } } 
public TYPE_1 METHOD_1 ( ) <START> { <END> if ( parent == null ) { try { parent = ( TYPE_1 ) TYPE_2 . METHOD_2 ( VAR_1 ) ; } catch ( Exception e ) { parent = null ; } } return parent ; } 
public void METHOD_1 ( ) throws IOException { super . METHOD_1 ( ) ; for ( TYPE_1 run : METHOD_2 ( ) ) { <START> if ( run . VAR_1 ( ) != null ) continue ; <END> run . VAR_2 ( ) ; } } 
<START> public TYPE_1 < String > METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( String key ) { for ( TYPE_2 channel : VAR_1 . get ( ) ) { <START> if ( TYPE_3 . METHOD_2 ( channel . getKey ( ) ) && channel . getKey ( ) . equals ( key ) ) { <END> return TYPE_1 . METHOD_3 ( channel ) ; } } return TYPE_1 . METHOD_4 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 entity ) { entity . VAR_2 ( TYPE_3 . METHOD_2 ( VAR_1 , <START> VAR_3 , new TYPE_4 < TYPE_1 , TYPE_5 > ( ) { <END> @Override public TYPE_5 apply ( TYPE_1 input ) { return VAR_4 . METHOD_3 ( input , new TYPE_5 ( ) ) ; } } ) . METHOD_4 ( TYPE_6 < TYPE_5 > of ( ) ) ) ; } 
public TYPE_6 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 VAR_3 ) { this . VAR_3 = METHOD_1 ( VAR_3 ) ; this . VAR_2 = METHOD_1 ( VAR_2 ) ; VAR_4 = new TYPE_4 ( ) ; <START> VAR_5 = TYPE_5 . METHOD_2 ( ) ; <END> } 
<START> protected String METHOD_1 ( ) { <END> return new TYPE_1 ( ) . METHOD_2 ( ) ; } 
private TYPE_1 METHOD_1 ( ) throws IOException { TYPE_1 next = in . next ( ) ; if ( next == null ) { throw new TYPE_2 ( ) ; } <START> VAR_1 += buffer . size ( ) ; <END> return next ; } 
public TYPE_1 METHOD_1 ( int index ) { <START> if ( VAR_1 . length < index && index >= 0 ) { <END> return VAR_1 [ index ] ; } return TYPE_2 . get ( ) ; } 
public void METHOD_1 ( TYPE_1 out ) throws IOException { <START> this . out = out ; <END> } 
public TYPE_2 ( byte [ ] VAR_2 , int offset , int length ) { this . buffer = TYPE_1 . METHOD_1 ( METHOD_2 ( VAR_2 , STRING_1 ) ) . METHOD_3 ( offset , length ) ; <START> METHOD_4 ( length <= VAR_2 . length ) ; <END> this . length = length ; } 
<START> public boolean METHOD_1 ( ) throws IOException { <END> int VAR_1 = 1 ; while ( VAR_1 > 0 ) { TYPE_1 f = METHOD_2 ( ) ; if ( f == TYPE_1 . VAR_2 ) return false ; VAR_1 += f . VAR_3 ( this ) ; VAR_1 -- ; } return true ; } 
public String toString ( ) { <START> return String . format ( STRING_1 , TYPE_1 . METHOD_1 ( METHOD_2 ( ) ) , Double . toString ( getValue ( ) ) ) ; <END> } 
public String toString ( ) { <START> return String . format ( STRING_1 , TYPE_1 . METHOD_1 ( METHOD_2 ( ) ) , TYPE_2 . toString ( getValue ( ) ) ) ; <END> } 
<START> public byte METHOD_1 ( TYPE_1 key , TYPE_2 value ) { <END> return TYPE_3 . METHOD_2 ( this , key , value ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_3 . TYPE_4 . METHOD_2 ( ) ; assertNotNull ( STRING_1 , VAR_1 ) ; <START> METHOD_3 ( STRING_2 , VAR_1 . METHOD_4 ( ) . equals ( TYPE_5 . VAR_3 ) ) ; <END> } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , String key , String value ) { <START> return METHOD_1 ( VAR_1 , key , value , TYPE_2 . VAR_3 ) ; <END> } 
private String METHOD_1 ( String query ) { TYPE_1 VAR_1 = null ; String result ; try { VAR_1 = TYPE_4 . TYPE_5 . METHOD_2 ( null , STRING_1 , query , TYPE_7 . VAR_3 . TYPE_6 ) ; result = TYPE_3 . METHOD_3 ( ) ; } finally { if ( VAR_1 != null ) { TYPE_4 . TYPE_5 . METHOD_4 ( VAR_1 ) ; } } <START> System . out . println ( result ) ; <END> return result ; } 
protected List METHOD_1 ( ) { return Arrays . asList ( new String [ ] { STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , STRING_8 , STRING_9 , STRING_10 , STRING_11 , STRING_12 , STRING_13 , STRING_14 , STRING_15 , STRING_16 , STRING_17 } ) ; <START> } <END> 
public static final void METHOD_1 ( String VAR_1 , String VAR_2 ) { File VAR_3 = new File ( VAR_2 ) ; if ( ! VAR_3 . METHOD_2 ( ) ) { synchronized ( VAR_4 ) { List VAR_5 = ( List ) VAR_4 . get ( VAR_1 ) ; if ( VAR_5 == null ) { VAR_5 = Collections . VAR_6 ( new TYPE_1 ( ) ) ; <START> VAR_4 . put ( VAR_1 , VAR_5 ) ; <END> } VAR_5 . add ( VAR_2 ) ; } } } 
public void METHOD_1 ( ) { int VAR_1 = TYPE_13 . VAR_3 . NONE . VAR_4 ( ) ; TYPE_1 VAR_5 = new TYPE_1 ( ) ; TYPE_2 token = null ; TYPE_3 VAR_6 = TYPE_12 . TYPE_14 ; TYPE_4 VAR_9 = TYPE_11 . TYPE_10 . METHOD_2 ( VAR_6 , VAR_1 , token , VAR_5 ) ; <START> TYPE_9 . TYPE_10 . METHOD_3 ( new TYPE_7 ( VAR_5 . METHOD_4 ( ) . METHOD_5 ( 0 ) ) ) ; <END> assertTrue ( TYPE_8 . METHOD_6 ( VAR_9 . METHOD_7 ( ) ) ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 ) { <START> TYPE_2 . METHOD_1 ( true ) ; <END> this . VAR_3 = VAR_2 ; } 
<START> public void METHOD_1 ( ) { <END> System . out . println ( STRING_1 ) ; TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( INT_1 ) ) ; TYPE_3 VAR_2 = TYPE_5 . TYPE_6 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; assertTrue ( STRING_2 + VAR_2 . METHOD_4 ( ) , VAR_2 . METHOD_4 ( ) == 0 ) ; System . out . println ( VAR_1 . toString ( true ) ) ; System . out . println ( STRING_1 ) ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 TYPE_3 = new TYPE_2 . TYPE_9 ( ) ; TYPE_3 . VAR_2 . METHOD_2 ( VAR_3 + 1 ) ; TYPE_3 . VAR_4 . METHOD_2 ( TYPE_3 . size ( ) ) ; VAR_1 . METHOD_2 ( TYPE_10 . VAR_6 ) ; TYPE_5 result = TYPE_7 . TYPE_8 . METHOD_3 ( VAR_1 , TYPE_3 ) ; <START> assertNotNull ( result ) ; <END> } 
public void METHOD_1 ( ) { String results = ( String ) TYPE_1 . execute ( new String [ ] { STRING_1 , STRING_2 , TYPE_2 . VAR_2 , STRING_3 , VAR_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , STRING_8 , STRING_9 , STRING_10 , STRING_11 } ) ; <START> Assert . assertTrue ( STRING_12 , results . startsWith ( STRING_13 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 msg ) { switch ( VAR_1 . VAR_2 ) { case VAR_3 : <START> case VAR_4 : <END> if ( VAR_5 . contains ( VAR_1 ) ) break ; case VAR_6 : VAR_7 ++ ; VAR_8 . METHOD_2 ( msg ) ; break ; case VAR_9 : VAR_10 ++ ; VAR_8 . error ( msg ) ; break ; } VAR_5 . add ( VAR_1 ) ; } 
public boolean METHOD_1 ( ) { String VAR_1 = TYPE_4 . VAR_3 + STRING_1 + METHOD_2 ( ) + STRING_1 + METHOD_2 ( ) + TYPE_1 . VAR_4 ; TYPE_2 url = Thread . VAR_5 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; TYPE_1 result = null ; try { <START> result = new TYPE_3 ( url ) ; <END> } catch ( IllegalArgumentException VAR_6 ) { result = null ; } return result != null ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) throws TYPE_2 { TYPE_1 t = METHOD_2 ( ) ; if ( t . getType ( ) == VAR_1 ) { <START> if ( t . getType ( ) == TYPE_1 . VAR_2 ) { <END> VAR_3 = true ; } VAR_4 . METHOD_3 ( this ) ; METHOD_4 ( ) ; } else { t = VAR_4 . METHOD_5 ( this ) ; if ( VAR_5 && t . VAR_6 ( ) == - 1 ) { VAR_7 . METHOD_6 ( t ) ; } } return t ; } 
public TYPE_1 ( int VAR_2 ) { if ( VAR_2 < 0 ) { throw new IllegalArgumentException ( ) ; } if ( VAR_2 > VAR_3 ) <START> throw new IllegalArgumentException ( ) ; <END> if ( VAR_2 == 0 ) { VAR_4 = VAR_5 ; } else { VAR_4 = new int [ VAR_2 ] ; } } 
public final int METHOD_1 ( int VAR_1 , int VAR_2 , int key ) { if ( VAR_1 < 0 || VAR_2 < 0 || VAR_1 > VAR_3 || VAR_2 > VAR_3 ) { throw new TYPE_1 ( ) ; } <START> if ( VAR_1 > VAR_2 ) <END> throw new IllegalArgumentException ( ) ; return Arrays . VAR_4 ( VAR_5 , VAR_1 , VAR_2 , key ) ; } 
<START> public TYPE_1 METHOD_1 ( boolean VAR_1 ) { <END> TYPE_2 VAR_2 = METHOD_2 ( ) ; if ( VAR_1 ) { METHOD_3 ( new TYPE_3 ( this ) ) ; } else { if ( VAR_2 != null ) { TYPE_2 VAR_3 = new TYPE_2 ( this , METHOD_4 ( ) , VAR_2 . VAR_4 , VAR_2 . METHOD_5 ( ) ) ; METHOD_3 ( VAR_3 ) ; } } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_1 ( ) ; <END> TYPE_2 version = VAR_1 . METHOD_3 ( STRING_1 ) ; if ( version == null || ! version . VAR_2 ( ) . equals ( TYPE_4 . VAR_4 ) ) { VAR_5 . VAR_6 . METHOD_4 ( TYPE_3 . VAR_8 , version , TYPE_4 . VAR_4 , VAR_9 ) ; } return VAR_1 ; } 
<START> public void METHOD_1 ( TYPE_1 p , String VAR_1 , boolean VAR_2 ) { <END> if ( ! VAR_2 ) { p . VAR_3 ( STRING_1 ) ; } } 
public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { boolean VAR_2 = false ; if ( METHOD_2 ( ) ) { VAR_2 = true ; } else { if ( METHOD_3 ( ) ) { List < ? extends TYPE_2 > VAR_3 = VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; if ( TYPE_3 . METHOD_6 ( VAR_3 ) ) { VAR_2 = true ; METHOD_7 ( ) ; } } } return VAR_2 ; <START> } <END> 
protected TYPE_5 ( String VAR_2 , ANNOTATION_1 String VAR_3 ) { VAR_4 = TYPE_1 . getInstance ( ) ; if ( VAR_5 == null ) { VAR_5 = ( TYPE_2 ) TYPE_3 . METHOD_1 ( STRING_1 ) ; } this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_6 = new TYPE_4 ( ) ; <END> } 
public static TYPE_1 METHOD_1 ( List < ? extends TYPE_1 > VAR_1 ) { if ( VAR_1 != null ) { for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_2 . METHOD_2 ( ) ) { TYPE_2 config = TYPE_2 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <START> if ( ( config != null ) && config . VAR_3 . METHOD_5 ( ) ) { <END> return VAR_2 ; } } } } return null ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . create ( VAR_2 , getString ( VAR_3 ) ) ; <START> VAR_1 . METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 data ) { String VAR_1 = data . VAR_2 ( TYPE_3 . VAR_4 ) ; boolean VAR_5 = data . VAR_6 ( TYPE_3 . VAR_7 , false ) ; if ( VAR_5 ) { } else { VAR_1 = data . VAR_2 ( TYPE_3 . VAR_8 ) ; <START> ; <END> } Log . d ( STRING_1 , VAR_5 + "" ) ; TYPE_2 VAR_9 = new TYPE_2 ( ) ; VAR_9 . execute ( VAR_1 ) ; } 
private void METHOD_1 ( TYPE_1 event , TYPE_3 . TYPE_4 params ) { int VAR_1 = params . VAR_2 ( ) ; int VAR_3 = params . VAR_4 ( ) ; float VAR_5 = METHOD_2 ( event ) ; if ( VAR_5 > VAR_6 ) { if ( VAR_3 < VAR_1 ) VAR_3 += INT_1 ; } else if ( VAR_5 < VAR_6 ) { <START> if ( VAR_3 > 0 ) <END> VAR_3 -= INT_1 ; } VAR_6 = VAR_5 ; params . VAR_7 ( VAR_3 ) ; VAR_8 . METHOD_3 ( params ) ; } 
public void METHOD_1 ( ) <START> { <END> for ( TYPE_1 VAR_1 : VAR_2 ) { VAR_1 . VAR_3 = true ; VAR_4 . add ( VAR_1 . path ) ; } METHOD_2 ( ) ; } 
public TYPE_2 ( Context c ) { VAR_2 = ( TYPE_1 ) METHOD_1 ( ) . METHOD_2 ( Context . VAR_3 ) ; path = VAR_4 . split ( STRING_1 ) ; if ( path . length > 0 ) { VAR_5 . METHOD_3 ( View . VAR_6 ) ; <START> Log . e ( STRING_2 , STRING_3 ) ; <END> } } 
private boolean METHOD_1 ( TYPE_1 request ) { <START> boolean VAR_1 = true ; <END> if ( request . VAR_2 ( ) != null ) { if ( request . VAR_2 ( ) instanceof TYPE_2 ) { VAR_1 = ( ( TYPE_2 ) request . VAR_2 ( ) ) . METHOD_2 ( ) . METHOD_3 ( ) ; } } return VAR_1 ; } 
private Throwable METHOD_1 ( Throwable VAR_1 ) { if ( VAR_1 . getClass ( ) . equals ( TYPE_1 . class ) ) { return VAR_1 . METHOD_2 ( ) != null <START> ? METHOD_3 ( VAR_1 . METHOD_2 ( ) , TYPE_2 . class ) <END> : new TYPE_3 ( METHOD_4 ( VAR_1 . getMessage ( ) ) ) ; } else { return VAR_1 ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 target , Object VAR_1 , TYPE_3 VAR_2 ) throws Exception { if ( VAR_1 != null ) { METHOD_2 ( VAR_1 ) . when ( VAR_2 ) . METHOD_3 ( METHOD_4 ( VAR_3 ) ) ; } else { METHOD_2 ( target ) . when ( VAR_2 ) . METHOD_3 ( METHOD_4 ( VAR_3 ) ) ; } <START> return METHOD_5 ( TYPE_4 . VAR_5 , STRING_1 , VAR_2 ) ; <END> } 
public boolean equals ( Object o ) { <START> if ( this == o ) return true ; <END> if ( ! ( o instanceof TYPE_1 ) ) return false ; if ( ! super . equals ( o ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; return VAR_1 == that . VAR_1 ; } 
TYPE_3 ( boolean VAR_2 ) { <START> VAR_3 = new TYPE_1 < > ( ( ) - > new TYPE_2 ( ! VAR_2 ) ) ; <END> } 
protected TYPE_1 METHOD_1 ( ) { if ( VAR_1 != null ) { return VAR_1 . get ( ) ; } <START> return new TYPE_2 ( VAR_2 , VAR_3 , VAR_4 , VAR_5 . METHOD_2 ( ) ) ; <END> } 
private Map < Integer , Integer > METHOD_1 ( ) { if ( this . VAR_1 == null ) { <START> this . VAR_1 = new TYPE_1 < > ( ) ; <END> } return this . VAR_1 ; } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 message = new TYPE_2 ( STRING_1 , VAR_1 ) ; TYPE_3 VAR_2 = new TYPE_4 ( ) ; <START> String VAR_3 = new String ( TYPE_5 . METHOD_2 ( TYPE_6 . METHOD_3 ( new HashSet < String > ( ) ) ) ) ; <END> message . VAR_4 ( VAR_5 , VAR_3 ) ; TYPE_7 session = VAR_2 . METHOD_4 ( message ) ; METHOD_5 ( session ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , Class VAR_4 ) throws IOException , TYPE_3 { super ( VAR_2 , VAR_3 ) ; this . VAR_4 = VAR_4 ; <START> this . VAR_5 = true ; <END> } 
public synchronized void METHOD_1 ( String VAR_1 ) throws TYPE_1 { <START> VAR_2 . METHOD_2 ( ) ; <END> try { super . METHOD_1 ( VAR_1 ) ; } finally { VAR_2 . METHOD_3 ( ) ; } } 
public void METHOD_1 ( ) throws Exception { when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( null ) ; <START> when ( VAR_1 . METHOD_4 ( ) . getId ( ) ) . METHOD_3 ( STRING_1 ) ; <END> METHOD_5 ( null ) ; } 
public TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( ) { <START> if ( this instanceof TYPE_4 ) { <END> return this ; } if ( this . isEmpty ( ) && VAR_1 != null ) { return VAR_1 ; } return new TYPE_4 < > ( this ) ; } 
public TYPE_1 build ( ) { Optional < TYPE_2 > VAR_1 = empty ( ) ; if ( VAR_2 || VAR_3 ) { VAR_1 = METHOD_1 ( ) ; } if ( VAR_2 ) { VAR_1 . METHOD_2 ( this : : METHOD_3 ) ; } if ( VAR_3 ) { VAR_1 . METHOD_2 ( this : : METHOD_4 ) ; } <START> VAR_4 . METHOD_5 ( VAR_5 ) ; <END> VAR_6 . METHOD_5 ( VAR_7 ) ; return super . build ( ) ; } 
public void METHOD_1 ( TYPE_1 response , Map < String , Object > parameters , TYPE_2 < TYPE_3 > VAR_1 ) { <START> ( ( TYPE_4 ) response . VAR_2 ( ) ) . METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( ) { try { TYPE_1 VAR_1 = TYPE_1 . builder ( TYPE_2 . create ( VAR_2 , METHOD_2 ( ) ) ) . message ( TYPE_3 . of ( null ) ) . build ( ) ; METHOD_3 ( VAR_1 ) ; <START> VAR_3 <END> . METHOD_4 ( VAR_4 , VAR_5 ) ; } catch ( Exception e ) { VAR_6 . METHOD_5 ( ) . METHOD_6 ( e ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 config = new TYPE_1 ( TYPE_5 . VAR_2 ) ; TYPE_2 VAR_3 = METHOD_2 ( config ) ; Object result = VAR_3 . execute ( METHOD_3 ( ) ) ; assertThat ( result , is ( VAR_4 ) ) ; <START> assertThat ( TYPE_3 . getInstance ( ) . METHOD_4 ( ) , TYPE_4 . METHOD_5 ( ) ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws InterruptedException { TYPE_4 VAR_3 = METHOD_2 ( TYPE_4 . class ) ; <START> when ( VAR_3 . METHOD_3 ( METHOD_4 ( ) , METHOD_5 ( TimeUnit . VAR_4 ) ) ) . METHOD_6 ( ( TYPE_5 < Boolean > ) VAR_5 - > { <END> METHOD_7 ( VAR_5 . METHOD_8 ( 0 , Long . VAR_6 ) / 2 ) ; return true ; } ) ; return new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( METHOD_2 ( ) && METHOD_3 ( ) && TYPE_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , TYPE_3 . class ) ) <END> { VAR_1 . METHOD_5 ( ) . add ( new TYPE_4 ( ) ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; return VAR_2 . equals ( VAR_3 ) || VAR_2 . equals ( VAR_4 ) <START> || VAR_2 . equals ( VAR_5 ) || VAR_2 . equals ( VAR_6 ) <END> || VAR_2 . equals ( VAR_7 ) || VAR_2 . equals ( VAR_8 ) || VAR_2 . equals ( VAR_9 ) || VAR_2 . equals ( VAR_10 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 config = METHOD_2 ( STRING_1 , STRING_2 , STRING_3 ) ; try { METHOD_3 ( config , INT_1 , INT_2 ) ; METHOD_4 ( STRING_4 ) ; } catch ( TYPE_2 e ) { <START> assertThat ( e . getMessage ( ) , is ( METHOD_5 ( STRING_4 ) ) ) ; <END> } METHOD_6 ( config ) ; VAR_1 . METHOD_7 ( ) ; METHOD_3 ( config , INT_3 , 100 ) ; } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { VAR_1 . METHOD_2 ( TYPE_2 . class ) ; VAR_2 . METHOD_3 ( VAR_3 ) ; METHOD_4 ( VAR_4 ) . METHOD_3 ( VAR_3 ) ; <START> METHOD_5 ( VAR_4 ) ; <END> } 
protected void METHOD_1 ( TYPE_1 event ) throws TYPE_2 { if ( ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( event ) ) { TYPE_2 exception = new TYPE_2 ( VAR_1 . getName ( ) ) ; <START> throw exception ; <END> } } 
public void METHOD_1 ( TYPE_1 event ) throws TYPE_2 { <START> if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) == TYPE_4 . TYPE_3 . VAR_4 ) { <END> METHOD_4 ( event ) ; } else { METHOD_5 ( event ) ; } } 
private static void METHOD_1 ( TYPE_1 factory ) { String VAR_1 = getProperty ( VAR_2 ) ; if ( VAR_1 != null ) { Integer VAR_3 = parseInt ( VAR_1 ) ; if ( VAR_3 > 0 ) { factory . VAR_4 ( VAR_5 , VAR_1 ) ; return ; } else if ( LOGGER . VAR_6 ( ) ) { <START> LOGGER . debug ( STRING_1 + VAR_5 + STRING_2 ) ; <END> } } factory . VAR_4 ( VAR_5 , VAR_7 ) ; } 
private TYPE_1 < Throwable , Object > METHOD_1 ( ) { return ( error , event ) - > { final TYPE_2 VAR_1 = ( TYPE_2 ) ( ( TYPE_3 ) error ) . METHOD_2 ( ) ; <START> System . out . println ( STRING_1 + VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> VAR_1 . METHOD_3 ( ) . error ( error ) ; } ; } 
private TYPE_1 < Throwable , Object > METHOD_1 ( ) { return ( error , event ) - > { final TYPE_2 VAR_1 = ( TYPE_2 ) ( ( TYPE_3 ) error ) . METHOD_2 ( ) ; <START> System . out . println ( STRING_1 + VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> ( VAR_1 . METHOD_3 ( ) ) . METHOD_5 ( VAR_1 ) ; } ; } 
private TYPE_1 METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 == null ) { <START> METHOD_2 ( ) ; <END> } return VAR_1 . METHOD_3 ( ) . METHOD_4 ( TYPE_1 . class ) . get ( ) ; } 
public static boolean METHOD_1 ( File file ) { <START> boolean VAR_1 = TYPE_1 . METHOD_2 ( ) ; <END> if ( VAR_1 ) { if ( METHOD_3 ( file ) ) { TYPE_2 message = TYPE_3 . METHOD_4 ( STRING_1 + file ) ; throw new TYPE_4 ( message ) ; } } else if ( METHOD_5 ( ) ) { if ( METHOD_3 ( file ) ) { logger . warn ( STRING_1 + file ) ; } } return file . VAR_2 ( ) ; } 
public void METHOD_1 ( ) throws IOException { File file = TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> assertThat ( TYPE_1 . METHOD_3 ( file ) , is ( false ) ) ; <END> TYPE_2 outputStream = new TYPE_2 ( file ) ; assertThat ( TYPE_1 . METHOD_3 ( file ) , is ( true ) ) ; outputStream . close ( ) ; assertThat ( TYPE_1 . METHOD_3 ( file ) , is ( false ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 event , Context ctx ) { <START> final TYPE_1 VAR_1 ; <END> if ( ctx . VAR_2 ( VAR_3 ) ) { return METHOD_2 ( event , METHOD_3 ( VAR_4 , ( TYPE_2 < Context , Context > ) ( VAR_5 - > VAR_5 . put ( VAR_3 , ctx . get ( VAR_3 ) ) ) ) ) ; } else { return event ; } } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , int ... VAR_2 ) { return VAR_1 != null <START> && Arrays . stream ( VAR_2 ) . METHOD_2 ( VAR_3 - > VAR_3 == VAR_1 . getType ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . VAR_4 ) ; final TYPE_1 VAR_5 = VAR_2 . METHOD_3 ( ) ; if ( VAR_1 . METHOD_4 ( ) != 1 <START> && ( VAR_6 || ! TYPE_2 . METHOD_5 ( VAR_2 , VAR_5 ) ) && ( VAR_6 || ! TYPE_2 . METHOD_5 ( VAR_1 , VAR_5 ) ) <END> && VAR_5 . getType ( ) != TYPE_3 . VAR_7 ) { log ( VAR_5 , VAR_8 ) ; } } 
public void METHOD_1 ( ) throws Exception { final File VAR_1 = new File ( getPath ( STRING_1 ) ) ; final TYPE_1 VAR_2 = METHOD_2 ( TYPE_2 . class ) ; final String [ ] VAR_3 = { <START> STRING_2 + METHOD_3 ( TYPE_3 . class , <END> TYPE_2 . VAR_4 ) , } ; final List < String > VAR_5 = Collections . VAR_6 ( STRING_3 + STRING_4 ) ; METHOD_4 ( VAR_2 , VAR_1 , VAR_3 , VAR_5 ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> boolean result = false ; final TYPE_1 parent = VAR_1 . METHOD_2 ( ) ; if ( parent . getType ( ) == TYPE_2 . VAR_3 || parent . getType ( ) == TYPE_2 . VAR_4 ) { result = true ; } return result ; <END> } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = METHOD_2 ( TYPE_2 . class ) ; final String [ ] VAR_2 = { <START> STRING_1 + METHOD_3 ( VAR_3 , STRING_2 ) , <END> STRING_3 + METHOD_3 ( VAR_3 , STRING_4 ) , } ; METHOD_4 ( VAR_1 , METHOD_5 ( STRING_5 ) , VAR_2 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { final boolean VAR_2 = VAR_1 . METHOD_2 ( TYPE_2 . VAR_4 ) != null ; final boolean VAR_5 = VAR_1 . METHOD_2 ( TYPE_2 . VAR_6 ) != null ; final boolean VAR_7 = VAR_8 && VAR_2 ; final boolean VAR_9 = VAR_10 && VAR_5 ; final boolean result ; if ( VAR_11 ) { result = VAR_2 && VAR_5 || VAR_9 || VAR_7 ; } else { result = VAR_9 && ! VAR_2 <START> || VAR_7 && ! VAR_5 ; <END> } return result ; } 
public void METHOD_1 ( ) { this . METHOD_2 ( new TYPE_1 ( ) { private int VAR_1 ; <START> @Override <END> public void METHOD_3 ( ) { this . VAR_1 ++ ; } } ) ; } 
private static int METHOD_1 ( List < TYPE_1 > VAR_1 , String VAR_2 ) { final Iterator < TYPE_1 > VAR_3 = VAR_1 . iterator ( ) ; int VAR_4 = - 1 ; int index = 0 ; while ( VAR_3 . hasNext ( ) ) { <START> final TYPE_1 VAR_5 = VAR_3 . next ( ) ; <END> if ( VAR_5 . METHOD_2 ( TYPE_2 . VAR_7 ) . METHOD_3 ( ) . equals ( VAR_2 ) ) { VAR_4 = index ; break ; } index ++ ; } return VAR_4 ; } 
void METHOD_1 ( ) { <START> TYPE_1 < String , String > VAR_1 = s - > s . trim ( ) ; <END> } 
<START> public static boolean METHOD_1 ( TYPE_1 node ) { <END> return node . getType ( ) == TYPE_2 . VAR_2 || node . getType ( ) == TYPE_2 . VAR_3 || node . getType ( ) == TYPE_2 . VAR_4 ; } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { int result = 0 ; if ( VAR_1 instanceof TYPE_2 ) { <START> result = METHOD_2 ( ) - ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; <END> if ( result == 0 ) { final TYPE_2 [ ] VAR_2 = METHOD_3 ( VAR_1 ) ; result = VAR_2 [ 0 ] . VAR_3 - VAR_2 [ 1 ] . VAR_3 ; } } return result ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { if ( ! VAR_2 && VAR_1 . getType ( ) == TYPE_2 . VAR_4 ) { final TYPE_1 VAR_5 = VAR_1 . METHOD_2 ( ) ; METHOD_3 ( VAR_5 ) ; } else if ( ! VAR_6 ) { <START> final TYPE_1 VAR_5 = VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; <END> METHOD_3 ( VAR_5 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . VAR_4 ) ; final TYPE_1 VAR_5 = VAR_2 . METHOD_3 ( ) ; if ( VAR_1 . METHOD_4 ( ) != 1 && ! TYPE_2 . METHOD_5 ( VAR_2 , VAR_5 ) && ! TYPE_2 . METHOD_5 ( VAR_1 , VAR_5 ) && VAR_5 . getType ( ) != TYPE_3 . VAR_6 ) { <START> log ( VAR_2 , VAR_7 ) ; <END> } } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { <START> int VAR_2 = METHOD_2 ( ) - VAR_1 . METHOD_2 ( ) ; <END> if ( VAR_2 == 0 ) { VAR_2 = METHOD_3 ( ) - VAR_1 . METHOD_3 ( ) ; if ( VAR_2 == 0 ) { VAR_2 = METHOD_4 ( ) . METHOD_5 ( VAR_1 . METHOD_4 ( ) ) ; } } return VAR_2 ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = true ; if ( VAR_1 . METHOD_2 ( ) != null ) { <START> final TYPE_1 VAR_3 = VAR_1 . METHOD_2 ( ) ; <END> if ( VAR_3 . getType ( ) == TYPE_2 . VAR_5 ) { VAR_2 = false ; } else if ( VAR_3 . getType ( ) == TYPE_2 . VAR_6 ) { VAR_2 = VAR_3 . METHOD_3 ( ) . getType ( ) != TYPE_2 . VAR_5 ; } } return VAR_2 ; } 
private static Set < String > METHOD_1 ( TYPE_1 VAR_1 , String id ) { final TYPE_1 node = TYPE_2 . METHOD_2 ( VAR_1 , id ) ; <START> assertNotNull ( node , STRING_1 + id ) ; <END> return TYPE_2 . METHOD_3 ( node ) . stream ( ) . map ( TYPE_1 : : METHOD_4 ) . collect ( Collectors . VAR_2 ( ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_2 TYPE_1 VAR_2 ) throws Exception { VAR_1 . METHOD_2 ( ) ; <START> VAR_2 . METHOD_2 ( ) ; <END> TYPE_2 . METHOD_3 ( STRING_1 ) ; final String VAR_3 = String . format ( TYPE_3 . VAR_5 , STRING_2 + STRING_3 ) + VAR_6 ; assertEquals ( VAR_3 , VAR_1 . METHOD_4 ( ) , STRING_4 ) ; assertEquals ( "" , VAR_2 . METHOD_4 ( ) , STRING_5 ) ; } 
public void METHOD_1 ( ) { final String VAR_1 = TYPE_1 . METHOD_2 ( ) ; <START> if ( ! TYPE_5 . TYPE_7 . METHOD_2 ( ) . equals ( VAR_1 ) <END> && ! TYPE_5 . TYPE_6 . METHOD_2 ( ) . equals ( VAR_1 ) ) { final TYPE_4 VAR_2 = METHOD_3 ( ) ; assertThat ( STRING_1 + TYPE_1 , VAR_2 . getMessage ( ) , METHOD_4 ( STRING_2 ) ) ; } } 
private boolean METHOD_1 ( TYPE_1 event ) { final boolean VAR_1 ; if ( VAR_2 == null ) { VAR_1 = true ; <START> } <END> else { final TYPE_2 VAR_3 = VAR_2 . matcher ( event . getMessage ( ) ) ; VAR_1 = VAR_3 . METHOD_2 ( ) ; } return VAR_1 ; } 
private static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 node = VAR_1 . METHOD_2 ( ) ; while ( node . VAR_2 ( ) != null ) { node = node . VAR_2 ( ) ; <START> } <END> return node ; } 
public boolean METHOD_1 ( TYPE_1 event ) { boolean VAR_1 = false ; if ( METHOD_2 ( event ) ) { <START> if ( METHOD_3 ( event ) ) { <END> VAR_1 = METHOD_4 ( event ) ; } else if ( METHOD_5 ( event ) ) { VAR_1 = METHOD_4 ( event ) ; } } return VAR_1 ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( ) ; return VAR_2 != null && VAR_2 . getType ( ) == TYPE_2 . VAR_4 <START> && ! STRING_1 . equals ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { return ! METHOD_2 ( VAR_1 , VAR_2 ) && ! METHOD_3 ( VAR_1 . VAR_3 ) <START> && ! METHOD_4 ( VAR_1 ) ; <END> } 
public int [ ] METHOD_1 ( ) { return new int [ ] { TYPE_1 . VAR_2 , TYPE_1 . VAR_3 , TYPE_1 . VAR_4 , TYPE_1 . VAR_5 , TYPE_1 . VAR_6 , <START> TYPE_1 . VAR_7 , <END> TYPE_1 . VAR_8 , TYPE_1 . VAR_9 , TYPE_1 . VAR_10 , TYPE_1 . VAR_11 , TYPE_1 . VAR_12 , TYPE_1 . VAR_13 , TYPE_1 . VAR_14 , TYPE_1 . VAR_15 , TYPE_1 . VAR_16 , TYPE_1 . VAR_17 , TYPE_1 . VAR_18 , } ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> final TYPE_2 VAR_2 = METHOD_2 ( ) ; <END> return VAR_2 . METHOD_1 ( VAR_1 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( VAR_1 ) ) { <START> METHOD_3 ( VAR_1 . METHOD_4 ( TYPE_2 . VAR_3 ) ) ; <END> METHOD_5 ( VAR_1 ) ; final TYPE_1 VAR_4 = VAR_1 . METHOD_4 ( TYPE_2 . VAR_5 ) ; if ( VAR_4 != null ) { METHOD_6 ( VAR_4 ) ; } final TYPE_1 VAR_6 = VAR_1 . METHOD_4 ( TYPE_2 . VAR_7 ) ; if ( VAR_6 != null ) { METHOD_6 ( VAR_6 ) ; } } } 
private static void METHOD_1 ( ) { TYPE_1 . put ( STRING_1 , VAR_1 + STRING_2 ) ; TYPE_1 . put ( STRING_3 , VAR_1 + STRING_4 ) ; TYPE_1 . put ( STRING_5 , <START> VAR_1 + STRING_6 ) ; <END> } 
protected static TYPE_1 METHOD_1 ( TYPE_2 config ) { final TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; <START> if ( config != null ) { <END> VAR_1 . METHOD_2 ( config ) ; } return VAR_1 ; } 
<START> public TYPE_1 ( int VAR_2 , String VAR_3 , Object ... VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 . METHOD_1 ( ) ; } 
private String METHOD_1 ( int VAR_1 ) { <START> String VAR_2 = METHOD_2 ( ) . get ( VAR_1 ) ; <END> if ( VAR_2 . isEmpty ( ) ) { VAR_2 = VAR_3 ; } return VAR_2 ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) throws IOException { final TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; try { while ( true ) { <START> final String line = VAR_2 . METHOD_2 ( ) ; <END> if ( line == null ) { break ; } VAR_3 . add ( line ) ; } METHOD_3 ( ) ; } finally { TYPE_3 . METHOD_4 ( VAR_2 ) ; } } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = METHOD_2 ( TYPE_2 . class ) ; VAR_1 . METHOD_3 ( STRING_1 , getPath ( STRING_2 ) ) ; <START> VAR_1 . METHOD_3 ( STRING_3 , "" ) ; <END> METHOD_4 ( VAR_1 , getPath ( STRING_4 ) ) ; } 
<START> public static void METHOD_1 ( ArrayList < TYPE_1 > VAR_1 ) { <END> if ( VAR_1 == null ) { return ; } for ( TYPE_1 VAR_2 : VAR_1 ) { String VAR_3 = METHOD_2 ( null , VAR_2 . METHOD_3 ( ) ) ; String VAR_4 = VAR_2 . METHOD_3 ( ) . split ( STRING_1 , 2 ) [ 1 ] ; String VAR_5 = METHOD_4 ( "" , VAR_4 ) ; TYPE_2 . METHOD_5 ( VAR_3 , null , VAR_5 ) ; VAR_2 . METHOD_6 ( VAR_5 ) ; } } 
<START> synchronized public static TYPE_1 getInstance ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 ) { <END> TYPE_2 . METHOD_2 ( new TYPE_2 . TYPE_5 . Builder ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) . build ( ) ) ; TYPE_2 . METHOD_7 ( new TYPE_2 . TYPE_6 . Builder ( ) . METHOD_8 ( ) . METHOD_9 ( ) . METHOD_6 ( ) . METHOD_10 ( ) . build ( ) ) ; } super . METHOD_1 ( VAR_1 ) ; METHOD_11 ( ) ; METHOD_12 ( ) ; } 
<START> public String METHOD_1 ( String VAR_1 , String page ) { <END> if ( VAR_1 == null ) { VAR_1 = VAR_2 + VAR_3 ; } return VAR_1 + STRING_1 + page ; } 
protected TYPE_1 execute ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws TYPE_4 , IOException { TYPE_5 VAR_3 = METHOD_1 ( ) . METHOD_2 ( TYPE_5 . class ) ; TYPE_6 < ? extends TYPE_7 > VAR_4 ; try { VAR_4 = VAR_3 . METHOD_3 ( VAR_5 , VAR_6 ) ; } catch ( TYPE_8 e ) { <START> throw new IllegalStateException ( ) ; <END> } super . METHOD_4 ( VAR_4 ) ; return super . execute ( VAR_1 , VAR_2 ) ; } 
public boolean METHOD_1 ( ) { if ( METHOD_2 ( ) ) { TYPE_1 VAR_1 = METHOD_3 ( this , TYPE_2 . VAR_3 ) ; return ! VAR_1 . METHOD_4 ( ) ; } <START> else if ( METHOD_5 ( ) ) { <END> return false ; } else { return true ; } } 
public boolean isEmpty ( ) { <START> return size > 0 ; <END> } 
protected TYPE_1 create ( String VAR_1 , TYPE_2 element ) { if ( element . getName ( ) . equals ( STRING_1 ) ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 , element ) ; <START> if ( ! VAR_2 . METHOD_1 ( ) ) <END> return VAR_2 ; } return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_2 , TYPE_2 . of ( VAR_1 ) ) ; <END> } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) return false ; TYPE_2 [ ] VAR_2 = VAR_1 . METHOD_2 ( ) ; boolean VAR_3 = false ; try { VAR_3 = TYPE_3 . METHOD_3 ( VAR_2 ) ; } catch ( IllegalArgumentException ex ) { <START> System . err . println ( STRING_1 ) ; <END> } return VAR_3 ; } 
private boolean METHOD_1 ( ) { <START> if ( VAR_1 . length > 1 && VAR_2 . length == 1 && VAR_2 [ 0 ] instanceof TYPE_1 ) { <END> return true ; } return false ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { <START> HashMap < String , String > map = new HashMap < String , String > ( ) ; <END> map . put ( TYPE_5 . VAR_2 , name ) ; map . put ( TYPE_5 . VAR_3 , url ) ; map . put ( TYPE_5 . VAR_4 , VAR_5 ) ; map . put ( TYPE_5 . VAR_6 , VAR_7 ) ; TYPE_3 VAR_8 = TYPE_4 . METHOD_2 ( TYPE_5 . VAR_9 ) ; return VAR_8 . METHOD_3 ( map ) ; } 
public TYPE_3 ( ) { VAR_2 = TYPE_1 . METHOD_1 ( ) ; <START> VAR_3 = new HashMap < String , TYPE_2 > ( ) ; <END> } 
protected String METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { String VAR_2 = METHOD_2 ( ) ; String VAR_3 = METHOD_3 ( ) ; String VAR_4 = METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; <START> String command = STRING_1 + VAR_3 + STRING_2 + VAR_4 + STRING_3 + TYPE_3 . VAR_6 + VAR_2 + STRING_4 ; <END> return command ; } 
<START> public static void METHOD_1 ( ) { <END> try { final TYPE_1 listener = new TYPE_1 ( ) ; final TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( listener , TYPE_5 . VAR_3 | TYPE_5 . VAR_4 ) ; } catch ( Exception e ) { TYPE_4 . log ( STRING_1 , e ) ; } } 
protected char METHOD_1 ( TYPE_1 server ) { char VAR_1 = File . VAR_2 ; <START> TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( server ) ; <END> if ( VAR_3 != null ) { try { TYPE_4 VAR_4 = ( TYPE_4 ) VAR_3 . METHOD_3 ( TYPE_4 . VAR_5 ) ; if ( VAR_4 != null ) { VAR_1 = VAR_4 . METHOD_4 ( ) ; } } catch ( TYPE_5 VAR_6 ) { } } return VAR_1 ; } 
private int METHOD_1 ( TYPE_1 [ ] VAR_1 , TYPE_2 monitor ) throws TYPE_3 { <START> TYPE_4 VAR_2 = TYPE_5 . METHOD_2 ( METHOD_3 ( ) ) ; <END> if ( VAR_2 != null ) { TYPE_6 VAR_3 = ( TYPE_6 ) VAR_2 . METHOD_4 ( TYPE_6 . VAR_4 ) ; if ( VAR_3 instanceof TYPE_7 ) { return ( ( TYPE_7 ) VAR_3 ) . METHOD_1 ( VAR_1 , monitor ) ; } } return TYPE_8 . VAR_6 ; } 
<START> public static String METHOD_1 ( String [ ] VAR_1 ) { <END> TYPE_1 buffer = new TYPE_1 ( ) ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) buffer . append ( VAR_1 [ i ] ) . append ( CHAR_1 ) ; return buffer . toString ( ) ; } 
public void METHOD_1 ( TYPE_1 monitor ) throws TYPE_2 { super . METHOD_1 ( monitor ) ; <START> METHOD_2 ( TYPE_3 . VAR_2 ) ; <END> } 
private TYPE_1 [ ] METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> ArrayList < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; <END> TYPE_1 VAR_3 = null ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { VAR_3 = METHOD_2 ( VAR_1 [ i ] ) ; if ( VAR_3 != null ) VAR_2 . add ( VAR_3 ) ; } return VAR_2 . METHOD_3 ( new TYPE_1 [ VAR_2 . size ( ) ] ) ; } 
public boolean METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> if ( VAR_1 . length == 1 ) <END> return true ; return false ; } 
protected TYPE_1 METHOD_1 ( ArrayList < TYPE_1 > VAR_1 ) { if ( VAR_1 . size ( ) == 1 ) return VAR_1 . get ( 0 ) ; <START> return VAR_1 . get ( 0 ) ; <END> } 
protected synchronized void METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> if ( METHOD_2 ( ) ) { try { VAR_1 . METHOD_3 ( ) ; METHOD_4 ( ) ; } catch ( TYPE_1 e ) { METHOD_5 ( e ) ; } } VAR_1 = null ; METHOD_6 ( ) . METHOD_7 ( ) ; VAR_2 = false ; } 
private synchronized void METHOD_1 ( TYPE_1 listener ) { if ( listener . VAR_1 != null && ! listener . VAR_1 . equals ( METHOD_2 ( ) ) ) return ; <START> System . out . println ( METHOD_2 ( ) ) ; <END> if ( METHOD_3 ( ) . METHOD_4 ( ) != TYPE_3 . VAR_3 ) { METHOD_5 ( ) ; METHOD_6 ( ) ; METHOD_7 ( ) . METHOD_8 ( ) ; } TYPE_2 . METHOD_9 ( ) . METHOD_10 ( listener ) ; VAR_4 = null ; VAR_5 = null ; VAR_6 = false ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = ( TYPE_2 ) METHOD_2 ( ) ; VAR_2 . METHOD_3 ( this ) ; TYPE_3 . METHOD_4 ( this , STRING_1 ) ; TYPE_3 . METHOD_5 ( STRING_2 , TYPE_5 . VAR_4 ) ; <START> VAR_2 = ( TYPE_2 ) METHOD_2 ( ) ; <END> METHOD_6 ( R . VAR_5 . VAR_6 ) ; METHOD_7 ( ) ; VAR_7 = new TYPE_4 ( ) ; METHOD_8 ( ) ; METHOD_9 ( ) ; METHOD_10 ( ) ; METHOD_11 ( ) ; } 
public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> return ( VAR_1 != null ) ? true : false ; <END> } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_3 ( new TYPE_2 ( ) { @Override public void run ( ) { METHOD_4 ( ) ; METHOD_5 ( ) ; } } <START> , INT_1 ) ; <END> } 
protected void METHOD_1 ( int VAR_1 ) { Logger . e ( TAG + STRING_1 + VAR_2 + STRING_2 + VAR_1 ) ; <START> if ( TYPE_1 . METHOD_2 ( ) != null ) { <END> TYPE_1 . METHOD_3 ( null ) ; } } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( TYPE_3 . VAR_2 . METHOD_3 ( ) ) ; <END> TYPE_1 VAR_3 = TYPE_2 . METHOD_4 ( ) ; assertThat ( VAR_3 . METHOD_5 ( R . id . VAR_4 ) ) . METHOD_6 ( ) ; } 
public TYPE_4 ( Context context , TYPE_1 VAR_2 , String [ ] VAR_3 ) { super ( context , new TYPE_2 ( VAR_3 ) , 0 ) ; this . context = context ; this . VAR_4 = ( TYPE_3 ) VAR_2 . METHOD_1 ( ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
private void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( this ) ; <START> VAR_1 . METHOD_3 ( VAR_2 ) ; <END> VAR_1 . METHOD_4 ( new TYPE_2 ( this , METHOD_5 ( ) ) ) ; VAR_1 . METHOD_6 ( VAR_3 ) ; } 
public TYPE_5 ( final TYPE_1 context , final TYPE_2 configuration ) { this . configuration = configuration ; this . context = context ; <START> this . context . VAR_2 ( TYPE_3 . class . getName ( ) , TYPE_4 . getInstance ( ) ) ; <END> TYPE_4 . getInstance ( ) . METHOD_1 ( this . context ) ; } 
public static boolean METHOD_1 ( String VAR_1 ) { boolean VAR_2 = false ; try { TYPE_1 VAR_3 = new TYPE_1 ( VAR_1 ) ; VAR_3 . METHOD_2 ( ) ; VAR_2 = true ; } catch ( TYPE_2 ex ) { VAR_2 = false ; <START> logger . error ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } return VAR_2 ; } 
private void METHOD_1 ( TYPE_1 message , TYPE_2 VAR_1 , TYPE_2 VAR_2 ) throws Exception { if ( logger . VAR_3 ( ) ) { logger . info ( STRING_1 ) ; } <START> METHOD_2 ( new TYPE_3 ( VAR_4 ) , VAR_1 , VAR_2 ) ; <END> } 
public TYPE_3 ( ) { super ( ) ; VAR_2 = context ( ) . METHOD_1 ( ) ; VAR_3 = new TYPE_1 < TYPE_2 , TYPE_2 > ( ) ; <START> VAR_4 = new TYPE_1 < String , String > ( ) ; <END> } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 version ) { <START> super ( VAR_2 . METHOD_1 ( ) . METHOD_2 ( TYPE_4 . class . getName ( ) ) , VAR_3 , version ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; this . client = new TYPE_2 ( VAR_2 ) ; String VAR_3 = VAR_2 . METHOD_1 ( ) ; if ( VAR_3 == null ) { VAR_3 = "" ; } this . index = VAR_3 ; this . resource = new TYPE_3 ( index ) ; <START> if ( this . VAR_2 . METHOD_2 ( ) != null ) <END> VAR_4 = true ; else VAR_4 = false ; trace = log . VAR_5 ( ) ; } 
public void METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = new TYPE_1 ( ) ; METHOD_2 ( VAR_1 , INT_1 * 10 ) ; long start = TYPE_2 . METHOD_3 ( ) ; METHOD_4 ( VAR_1 . METHOD_5 ( VAR_2 ) ) ; <START> System . out . println ( TYPE_2 . METHOD_3 ( ) - start ) ; <END> assertTrue ( TYPE_2 . METHOD_3 ( ) - start >= ( VAR_2 - VAR_3 ) ) ; } 
<START> public void METHOD_1 ( Throwable VAR_1 ) { <END> if ( VAR_1 == null ) { VAR_1 = new Exception ( ) ; } synchronized ( VAR_2 ) { this . VAR_1 = VAR_1 ; if ( ! METHOD_2 ( ) ) { return ; } } VAR_3 . METHOD_3 ( ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> switch ( VAR_1 ) { case TYPE_4 : return VAR_3 ; case TYPE_5 : return VAR_5 ; default : throw new TYPE_3 ( ) ; } } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { METHOD_2 ( ) ; <START> synchronized ( VAR_2 ) { <END> METHOD_3 ( VAR_3 , VAR_1 ) ; } synchronized ( VAR_4 . METHOD_4 ( ) ) { METHOD_3 ( VAR_4 , VAR_1 ) ; } } 
<START> public String METHOD_1 ( TYPE_1 request ) { <END> String VAR_1 = request . VAR_2 ( STRING_1 ) ; if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_2 ) ; } return VAR_1 . substring ( STRING_3 . length ( ) , VAR_1 . length ( ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( METHOD_2 ( ) , VAR_1 ) ; <START> if ( VAR_3 . METHOD_3 ( ) != 0 ) { <END> VAR_3 . METHOD_4 ( VAR_1 . METHOD_5 ( ) + VAR_3 . METHOD_3 ( ) , VAR_2 ) ; } else { VAR_3 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_2 ) ; } VAR_3 . METHOD_6 ( VAR_2 ) ; VAR_4 . METHOD_7 ( VAR_5 , VAR_6 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return METHOD_2 ( TYPE_1 . class ) ; } 
<START> public void METHOD_1 ( String VAR_1 , String key ) { <END> Map < String , Object > VAR_2 = METHOD_2 ( VAR_1 ) ; VAR_2 . remove ( key ) ; } 
public boolean METHOD_1 ( TYPE_1 context , TYPE_2 metadata ) { <START> return context . VAR_1 ( ) . METHOD_2 ( STRING_1 ) != null ; <END> } 
public String METHOD_1 ( ) { try { throw new TYPE_1 ( STRING_1 , String . VAR_1 ) ; } catch ( TYPE_1 ex ) { VAR_2 . METHOD_2 ( ex ) ; } <START> return STRING_2 ; <END> } 
TYPE_6 ( String VAR_2 ) { this . VAR_2 = VAR_2 ; METHOD_1 ( new TYPE_1 ( this ) ) ; METHOD_1 ( new TYPE_2 ( ) ) ; TYPE_2 . METHOD_2 ( ) ; if ( TYPE_3 . METHOD_3 ( ) ) { METHOD_1 ( new TYPE_3 ( ) ) ; } <START> VAR_3 = new TYPE_4 ( ) ; <END> ( ( TYPE_5 ) VAR_3 ) . METHOD_4 ( STRING_1 ) ; } 
TYPE_4 ( Collection < TYPE_1 > VAR_2 , TYPE_2 configuration ) { <START> this . VAR_2 . addAll ( VAR_2 ) ; <END> VAR_3 = new TYPE_3 ( configuration ) ; } 
<START> public List < Exception > METHOD_1 ( ) { <END> List < Exception > VAR_1 = new ArrayList < Exception > ( ) ; Throwable VAR_2 = VAR_3 ; while ( VAR_2 != null ) { VAR_1 . add ( new Exception ( config , VAR_2 ) ) ; VAR_2 = VAR_2 . METHOD_2 ( ) ; } return VAR_1 ; } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> return config . VAR_1 ? TYPE_1 . METHOD_2 ( config ) : null ; } 
<START> public TYPE_2 ( TYPE_1 config , Throwable VAR_2 ) { <END> this . config = config ; this . VAR_2 = VAR_2 ; } 
public TYPE_1 METHOD_1 ( final String VAR_1 , final String VAR_2 , boolean VAR_3 ) throws TYPE_2 { <START> return this . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , true ) ; <END> } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( VAR_2 . size ( ) > VAR_3 ) { throw new TYPE_2 ( STRING_1 ) ; } else { if ( VAR_2 . size ( ) > FLOAT_1 * VAR_3 ) { LOG . warn ( STRING_2 ) ; } <START> VAR_2 . put ( VAR_1 . METHOD_2 ( ) , VAR_1 ) ; <END> } } 
<START> public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { <END> List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; final String VAR_4 = METHOD_2 ( VAR_2 , VAR_1 . METHOD_3 ( ) ) ; VAR_3 . add ( new TYPE_1 ( VAR_5 , VAR_6 , VAR_4 ) ) ; return VAR_3 ; } 
<START> public void METHOD_1 ( ) throws TYPE_1 { <END> if ( VAR_1 ) { METHOD_2 ( STRING_1 ) ; } } 
<START> TYPE_5 ( ) { <END> this . VAR_2 = new ArrayList < TYPE_1 > ( ) ; this . VAR_3 = new ArrayList < TYPE_3 . TYPE_4 > ( ) ; METHOD_1 ( ) ; METHOD_2 ( ) ; METHOD_3 ( ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; METHOD_8 ( ) ; METHOD_9 ( ) ; } 
private boolean METHOD_1 ( Path VAR_1 ) throws IOException { if ( VAR_1 == null ) { return true ; } else { TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( conf ) ; <START> if ( VAR_2 . exists ( VAR_1 ) ) { <END> TYPE_2 [ ] VAR_3 = VAR_2 . METHOD_3 ( VAR_1 ) ; for ( TYPE_2 status : VAR_3 ) { if ( status . getPath ( ) . getName ( ) . equalsIgnoreCase ( TYPE_3 . VAR_5 ) ) { return true ; } } } } return false ; } 
public TYPE_1 METHOD_1 ( ) { if ( METHOD_2 ( ) ) { <START> if ( METHOD_3 ( ) || METHOD_4 ( ) ) { <END> return TYPE_1 . VAR_1 ; } else { return TYPE_1 . VAR_2 ; } } else { return TYPE_1 . VAR_3 ; } } 
<START> public final void METHOD_1 ( ) { <END> long val = state . get ( ) ; while ( TYPE_1 . METHOD_2 ( val ) && ! state . VAR_1 ( val , TYPE_1 . METHOD_1 ( val ) ) ) { val = state . get ( ) ; } } 
public void METHOD_1 ( TYPE_1 buffer ) { <START> if ( buffer . VAR_1 == null || buffer . VAR_1 . METHOD_2 ( ) != VAR_2 || ! VAR_3 . METHOD_3 ( ) ) { <END> return ; } METHOD_4 ( buffer ) ; } 
public String METHOD_1 ( String VAR_1 ) throws TYPE_1 { if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( ) ; } String VAR_2 = VAR_3 + VAR_1 + STRING_1 + VAR_4 + VAR_5 ; File file = new File ( METHOD_3 ( ) + File . VAR_6 + VAR_2 ) ; <START> if ( ! ( file . exists ( ) ) ) { <END> throw new TYPE_1 ( STRING_2 + VAR_1 , new TYPE_2 ( file . VAR_7 ( ) ) ) ; } return VAR_2 ; } 
public static void METHOD_1 ( ) { TYPE_1 . remove ( VAR_1 ) ; TYPE_1 . remove ( VAR_2 ) ; TYPE_1 . remove ( VAR_3 ) ; VAR_4 . info ( STRING_1 ) ; <START> if ( TYPE_1 . get ( VAR_3 ) != null ) { <END> throw new RuntimeException ( STRING_2 ) ; } } 
TYPE_5 ( TYPE_1 conf ) throws TYPE_2 { VAR_2 = TYPE_3 . METHOD_1 ( conf , TYPE_3 . TYPE_4 . VAR_4 ) ; VAR_5 = TYPE_3 . METHOD_1 ( conf , TYPE_3 . TYPE_4 . VAR_6 ) ; if ( null == VAR_2 || VAR_2 . isEmpty ( ) ) { throw new TYPE_2 ( STRING_1 + TYPE_3 . TYPE_4 . VAR_4 ) ; } <START> if ( null == VAR_5 || VAR_5 . isEmpty ( ) ) { <END> throw new TYPE_2 ( STRING_2 + TYPE_3 . TYPE_4 . VAR_4 ) ; } } 
public TYPE_1 METHOD_1 ( final String VAR_1 , final String name ) throws TYPE_2 , TYPE_3 { String [ ] VAR_2 = METHOD_2 ( VAR_1 , conf ) ; return METHOD_3 ( <START> VAR_2 [ VAR_3 ] , VAR_2 [ VAR_4 ] , name , null , null , false , null ) ; <END> } 
public TYPE_1 create ( TYPE_2 VAR_1 ) { <START> TYPE_1 client = new TYPE_1 ( conf , VAR_1 . METHOD_1 ( ) , <END> VAR_1 . METHOD_2 ( ) , VAR_2 , VAR_3 ) ; return client ; } 
TYPE_1 ( int VAR_2 , long VAR_3 ) { <START> this ( VAR_2 , VAR_3 , System . VAR_4 ( ) ) ; <END> } 
public String METHOD_1 ( ) throws TYPE_1 { if ( VAR_1 == null ) { <START> return null ; <END> } try { return client . TYPE_4 ( new TYPE_2 ( VAR_1 ) ) . METHOD_1 ( ) ; } catch ( TYPE_3 e ) { throw new TYPE_1 ( e ) ; } } 
<START> TYPE_1 ( String name , String VAR_2 ) { <END> this . name = name ; this . VAR_2 = VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { if ( METHOD_2 ( ) ) { <START> return TYPE_1 . VAR_1 ; <END> } else if ( METHOD_3 ( ) ) { return TYPE_1 . VAR_2 ; } return table . VAR_3 ( ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( ) ; return VAR_2 ; } 
private void METHOD_1 ( Map < String , String > props , String VAR_1 ) { assertTrue ( props . containsKey ( TYPE_1 . VAR_3 ) ) ; <START> assertTrue ( props . get ( TYPE_1 . VAR_3 ) . equalsIgnoreCase ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( ) throws Throwable { String VAR_1 = STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 + STRING_7 + STRING_8 ; TYPE_3 . TYPE_4 VAR_2 = VAR_3 . run ( STRING_9 + VAR_4 ) . run ( VAR_1 ) . METHOD_2 ( VAR_4 , null ) ; <START> Path VAR_5 = new Path ( VAR_2 . VAR_6 <END> + Path . VAR_7 + VAR_4 + Path . VAR_7 + STRING_10 ) ; TYPE_2 VAR_8 = VAR_5 . METHOD_3 ( VAR_3 . VAR_9 ) ; METHOD_4 ( VAR_8 . exists ( VAR_5 ) ) ; } 
<START> protected static void METHOD_1 ( TYPE_1 VAR_1 ) { <END> try { if ( VAR_1 != null && ! VAR_1 . METHOD_2 ( ) ) { VAR_1 . close ( ) ; } } catch ( TYPE_2 e ) { LOG . warn ( STRING_1 + e . getMessage ( ) ) ; } } 
private void METHOD_1 ( List < String > VAR_1 , List < String [ ] > VAR_2 ) throws Throwable { <START> for ( int VAR_3 = 0 ; VAR_3 > VAR_1 . size ( ) ; VAR_3 ++ ) { <END> VAR_4 . run ( STRING_1 + VAR_5 ) . run ( VAR_1 . get ( VAR_3 ) ) . METHOD_2 ( VAR_2 . get ( VAR_3 ) ) ; } } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) throws TYPE_2 , TYPE_3 { VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; <START> VAR_1 = VAR_1 . METHOD_2 ( ) ; <END> VAR_4 . METHOD_3 ( StringUtils . VAR_5 ( VAR_1 ) , VAR_2 ) ; } 
public String METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> return null ; } else if ( VAR_2 == null ) { return VAR_1 . METHOD_2 ( ) + STRING_1 ; } else { return VAR_1 . METHOD_2 ( ) + STRING_2 + VAR_2 . METHOD_2 ( ) ; } } 
public TYPE_3 ( String VAR_2 , String VAR_3 , Long VAR_4 , TYPE_1 type ) { <START> this . VAR_5 = TYPE_2 . METHOD_1 ( ) ; <END> this . VAR_5 . add ( VAR_4 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_6 = type ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 conf , String VAR_1 ) { String VAR_2 = conf . get ( TYPE_3 . VAR_3 ) ; <START> TYPE_3 VAR_4 = new TYPE_3 ( VAR_2 ) ; <END> return VAR_4 . METHOD_2 ( VAR_1 ) ; } 
public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 ) throws IOException { Path path = new Path ( VAR_2 ) ; VAR_4 = path . VAR_5 ( VAR_3 ) ; VAR_6 = VAR_4 . METHOD_1 ( new Path ( VAR_2 ) , TYPE_2 . METHOD_2 ( VAR_4 ) ) ; VAR_7 = 0 ; if ( VAR_6 . length != 0 ) { <START> VAR_8 = 0 ; <END> VAR_9 = METHOD_3 ( VAR_4 , VAR_6 [ 0 ] . getPath ( ) ) ; } } 
<START> static Path METHOD_1 ( TYPE_1 conf , String VAR_1 ) throws IOException , TYPE_2 { <END> String VAR_2 = VAR_1 ; int VAR_3 = conf . getInt ( TYPE_3 . VAR_5 , TYPE_3 . VAR_6 ) ; if ( VAR_2 . length ( ) > VAR_3 ) { VAR_2 = VAR_2 . substring ( 0 , VAR_3 - 1 ) ; } return new Path ( VAR_7 , VAR_2 ) ; } 
private static String METHOD_1 ( TYPE_1 conf ) { try { return TYPE_2 . METHOD_2 ( ) . METHOD_3 ( conf , TYPE_1 . TYPE_3 . VAR_2 . VAR_3 ) ; } catch ( IOException VAR_4 ) { <START> } <END> return null ; } 
private void METHOD_1 ( ) throws IOException { if ( this . VAR_1 != null ) { return ; } this . VAR_1 = new TYPE_1 ( new File ( METHOD_2 ( ) . METHOD_3 ( ) ) ) ; TYPE_2 . METHOD_4 ( new TYPE_3 ( ) { @Override public void run ( ) { try { VAR_1 . METHOD_5 ( ) ; } catch ( IOException e ) { error ( e ) ; <START> } finally { <END> close ( ) ; } } } ) ; } 
public TYPE_1 METHOD_1 ( String status ) { try { TYPE_2 VAR_1 = TYPE_2 . valueOf ( status ) ; switch ( VAR_1 ) { case VAR_2 : case VAR_3 : case VAR_4 : return TYPE_1 . VAR_5 ; default : return TYPE_1 . VAR_6 ; } } catch ( IllegalArgumentException ex ) { <START> LOG . debug ( STRING_1 + status ) ; <END> return TYPE_1 . VAR_7 ; } } 
<START> private static TYPE_1 METHOD_1 ( <END> TYPE_1 VAR_1 , List < Type > VAR_2 ) { return new TYPE_1 ( VAR_1 . METHOD_2 ( ) , VAR_1 . getName ( ) , VAR_2 ) ; } 
public void write ( TYPE_1 VAR_1 ) throws IOException { VAR_1 . METHOD_1 ( ) ; VAR_1 . METHOD_2 ( STRING_1 , type ) ; <START> switch ( STRING_1 ) { <END> case STRING_2 : METHOD_3 ( VAR_1 , STRING_3 , VAR_2 . get ( 0 ) ) ; break ; default : METHOD_3 ( VAR_1 , STRING_4 , VAR_2 ) ; } VAR_1 . METHOD_4 ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 reader ) { if ( reader . VAR_1 ( VAR_2 ) ) { String VAR_3 ; try { <START> ByteBuffer val = <END> reader . VAR_4 ( VAR_2 ) . METHOD_2 ( ) ; VAR_3 = VAR_5 . METHOD_3 ( val ) . toString ( ) ; } catch ( TYPE_3 e ) { throw new IllegalArgumentException ( STRING_1 + VAR_2 , e ) ; } return new TYPE_1 ( VAR_3 ) ; } else { return null ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { <START> return TYPE_4 . METHOD_1 ( VAR_1 ) ; <END> } 
public TYPE_3 ( final TYPE_1 VAR_2 , final TYPE_2 type ) { <START> this ( null , VAR_2 , type ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 + System . VAR_2 ( ) + STRING_2 ) ; assertTrue ( VAR_1 . METHOD_3 ( ) . isPresent ( ) ) ; assertTrue ( VAR_1 . METHOD_4 ( ) . isEmpty ( ) ) ; <START> assertEquals ( 1 , VAR_1 . METHOD_5 ( ) ) ; <END> } 
void METHOD_1 ( ) { assertEquals ( STRING_1 , METHOD_2 ( Object . VAR_1 , STRING_2 ) ) ; assertEquals ( STRING_3 , METHOD_2 ( Boolean . VAR_2 , STRING_3 ) ) ; <START> assertEquals ( STRING_3 , METHOD_2 ( Boolean . VAR_2 , STRING_4 ) ) ; <END> assertEquals ( STRING_5 , METHOD_2 ( Boolean . VAR_1 , STRING_4 ) ) ; assertEquals ( STRING_6 , METHOD_2 ( Boolean . VAR_1 , STRING_3 ) ) ; } 
default boolean VAR_1 ( String ... VAR_2 ) { return getParameters ( ) . stream ( ) . map ( p - > p . getType ( ) . VAR_3 ( ) ) . collect ( VAR_4 ( ) ) <START> . equals ( TYPE_1 . of ( VAR_2 ) . collect ( VAR_4 ( ) ) ) ; <END> } 
void METHOD_1 ( ) { TYPE_1 < TYPE_2 > result = VAR_1 . parse ( VAR_2 , METHOD_2 ( STRING_1 ) ) ; METHOD_3 ( result , STRING_2 , STRING_3 , <START> STRING_4 ) ; <END> } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> TYPE_1 . METHOD_1 ( STRING_1 ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { <START> return ( ) - > METHOD_2 ( VAR_1 ) ; <END> } 
private static < T extends TYPE_1 > T METHOD_1 ( TYPE_2 < T > context , TYPE_3 VAR_1 ) { TYPE_4 < T > result = new TYPE_5 ( VAR_2 ) . parse ( context , VAR_1 ) ; if ( result . VAR_3 ( ) ) { <START> METHOD_2 ( result , VAR_2 ) ; <END> return result . VAR_4 ( ) . get ( ) ; } throw new TYPE_6 ( result . VAR_5 ( ) ) ; } 
public void METHOD_1 ( ) { Type type = METHOD_2 ( STRING_1 ) ; assertTrue ( type . VAR_1 ( ) ) ; TYPE_1 VAR_2 = type . VAR_3 ( ) ; final TYPE_1 [ ] s = new TYPE_1 [ 1 ] ; <START> type . VAR_4 ( t - > s [ 0 ] = ( TYPE_1 ) t ) ; <END> assertNotNull ( s [ 0 ] ) ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > action ) { <START> if ( METHOD_2 ( ) ) { <END> action . VAR_1 ( METHOD_3 ( ) ) ; } } 
public static boolean METHOD_1 ( int VAR_1 ) { <START> return METHOD_2 ( VAR_1 ) == TYPE_2 . TYPE_1 . VAR_4 ; <END> } 
public String METHOD_1 ( ) { <START> TYPE_1 sb = new TYPE_1 ( ) ; <END> VAR_1 . forEach ( e - > sb . append ( e . VAR_2 ( ) ) ) ; return sb . toString ( ) ; } 
<START> public default < VAR_1 extends TYPE_1 > VAR_1 VAR_3 ( VAR_1 VAR_4 ) { <END> VAR_5 ( ) . add ( VAR_4 ) ; VAR_4 . VAR_6 ( ( TYPE_2 ) this ) ; return VAR_4 ; } 
public TYPE_2 ( final Type type , TYPE_1 VAR_2 ) { METHOD_1 ( type ) ; List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; VAR_3 . add ( VAR_2 ) ; <START> METHOD_2 ( VAR_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( int column ) { <START> return new TYPE_1 ( line , column ) ; <END> } 
private VAR_1 VAR_2 ( TYPE_1 VAR_4 ) { VAR_1 db = VAR_4 . VAR_5 ( VAR_6 ) ; db . VAR_7 ( TYPE_2 . VAR_9 ) ; if ( VAR_10 != null ) { if ( VAR_11 != null ) { <START> VAR_1 VAR_12 = VAR_4 . VAR_5 ( VAR_11 ) <END> VAR_12 . VAR_13 ( VAR_10 , VAR_14 . VAR_15 ( ) ) ; } else { db . VAR_13 ( VAR_10 , VAR_14 . VAR_15 ( ) ) ; } } return db ; } 
public synchronized TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 , final boolean VAR_2 ) { METHOD_2 ( new TYPE_2 ( this , VAR_1 ) ) ; <START> TYPE_3 r = this . VAR_3 . METHOD_1 ( VAR_1 ) ; <END> this . VAR_4 . put ( r . getId ( ) , r ) ; METHOD_3 ( VAR_1 ) ; if ( VAR_2 ) { METHOD_2 ( new TYPE_4 ( this , r ) ) ; } return r ; } 
public TYPE_1 METHOD_1 ( ) { val VAR_1 = new TYPE_1 ( ) { @Override protected void METHOD_2 ( final List list ) { list . forEach ( TYPE_2 . METHOD_3 ( VAR_2 - > { ( ( TYPE_3 ) VAR_2 ) . METHOD_4 ( ) ; } ) ) ; } } ; <START> VAR_1 . METHOD_5 ( new ArrayList ( ) ) ; <END> return VAR_1 ; } 
private void METHOD_1 ( final TYPE_1 token ) { LOGGER . debug ( STRING_1 , token ) ; METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( token ) ; token . VAR_1 ( ) . forEach ( item - > { LOGGER . debug ( STRING_2 , item , token ) ; <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( item ) ; <END> } ) ; } 
protected boolean METHOD_1 ( final TYPE_1 request , final TYPE_2 response ) { val VAR_1 = TYPE_3 . METHOD_2 ( new TYPE_4 ( request , response , VAR_2 ) ) . METHOD_3 ( ) ; <START> val VAR_3 = TYPE_3 . METHOD_4 ( VAR_4 , VAR_1 ) ; <END> if ( VAR_1 . isEmpty ( ) || VAR_3 == null ) { return true ; } return TYPE_3 . METHOD_5 ( VAR_3 ) ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final TYPE_4 VAR_3 , final String VAR_4 ) { if ( VAR_1 != null ) { LOGGER . trace ( STRING_1 , VAR_1 ) ; return VAR_2 . METHOD_2 ( VAR_4 , VAR_3 , new TYPE_5 ( VAR_1 . METHOD_3 ( ) ) ) ; <START> } else { LOGGER . trace ( STRING_2 ) ; return VAR_2 . METHOD_2 ( VAR_4 , VAR_3 , this . VAR_5 . METHOD_4 ( ) ) ; } <END> } 
public void METHOD_1 ( final TYPE_1 < ? extends String , ? extends TYPE_2 > event ) { <START> if ( LOGGER . VAR_1 ( ) ) { <END> LOGGER . trace ( STRING_1 , event . getType ( ) . name ( ) , event . getKey ( ) ) ; } } 
<START> void METHOD_1 ( ) { <END> try { val resource = new TYPE_1 ( STRING_1 ) ; val result = TYPE_2 . METHOD_2 ( resource , STRING_2 , String . VAR_1 , STRING_3 ) ; assertEquals ( STRING_3 , result ) ; } catch ( final Exception e ) { throw new TYPE_3 ( e . getMessage ( ) , e ) ; } } 
public static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { LOGGER . debug ( STRING_1 , VAR_1 ) ; <START> final TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) == null <END> ? METHOD_3 ( VAR_1 ) : METHOD_4 ( VAR_1 ) ; val factory = new TYPE_4 ( VAR_2 , METHOD_5 ( VAR_1 ) ) ; return factory ; } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { val request = new TYPE_2 ( ) ; try ( val VAR_1 = new TYPE_3 ( new TYPE_4 ( STRING_1 ) . METHOD_2 ( ) ) ) { <START> TYPE_5 [ ] VAR_2 = { TYPE_6 . METHOD_3 ( VAR_1 ) } ; <END> request . VAR_3 ( VAR_4 , VAR_2 ) ; val VAR_5 = factory . VAR_6 ( request , null ) . iterator ( ) . next ( ) ; assertTrue ( VAR_5 instanceof TYPE_7 ) ; } } 
public String METHOD_1 ( final String VAR_1 ) { if ( StringUtils . isEmpty ( VAR_1 ) ) { return null ; } final byte [ ] VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { return null ; } final String VAR_3 = TYPE_2 . METHOD_3 ( VAR_2 ) ; if ( ! StringUtils . isEmpty ( VAR_3 ) ) { return VAR_3 ; <START> } else { <END> return new String ( VAR_2 , TYPE_3 . VAR_5 ) ; } } 
protected void METHOD_1 ( final TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_1 ) ; METHOD_5 ( VAR_1 ) ; METHOD_6 ( VAR_1 ) ; METHOD_7 ( VAR_1 ) ; METHOD_8 ( VAR_1 ) ; <START> METHOD_9 ( VAR_1 ) ; <END> METHOD_10 ( VAR_1 ) ; METHOD_11 ( VAR_1 ) ; } 
public static String METHOD_1 ( String VAR_1 ) { VAR_1 = METHOD_2 ( VAR_1 ) ? VAR_1 : VAR_2 ; File VAR_3 = METHOD_3 ( VAR_1 ) ; try { VAR_3 . METHOD_4 ( ) ; } catch ( IOException e ) { <START> System . err . println ( STRING_1 + e . getMessage ( ) ) ; <END> e . VAR_4 ( ) ; return "" ; } return VAR_3 . getPath ( ) ; } 
public static File METHOD_1 ( String VAR_1 ) { File VAR_2 = null ; int i = 0 ; try { do { VAR_2 = new File ( VAR_3 + VAR_4 + VAR_1 + STRING_1 + i + STRING_2 + VAR_5 ) ; i ++ ; } while ( VAR_2 . exists ( ) ) ; } catch ( Exception e ) { <START> System . err . println ( STRING_3 + e . getMessage ( ) ) ; <END> } return VAR_2 ; } 
public boolean equals ( TYPE_1 info ) { <START> if ( this . VAR_1 . equals ( info . VAR_1 ) <END> && this . VAR_2 . METHOD_1 ( ) . equals ( info . VAR_2 . METHOD_1 ( ) ) && this . VAR_3 . METHOD_1 ( ) . equals ( info . VAR_3 . METHOD_1 ( ) ) ) { return true ; } return false ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_2 VAR_3 , boolean VAR_4 ) throws TYPE_3 { if ( VAR_1 == null || VAR_2 == null ) { throw new TYPE_4 ( STRING_1 ) ; } try { TYPE_5 VAR_5 = METHOD_2 ( VAR_1 , VAR_3 ) ; TYPE_5 VAR_6 = METHOD_2 ( VAR_2 , VAR_3 ) ; double VAR_7 = TYPE_6 . METHOD_3 ( VAR_5 , VAR_6 ) ; <START> return new TYPE_1 ( VAR_7 ) ; <END> } catch ( TYPE_7 e ) { throw new TYPE_3 ( e ) ; } } 
public Integer METHOD_1 ( String uri ) { Integer VAR_1 = 0 ; <START> for ( TYPE_1 VAR_2 : VAR_3 ) { <END> VAR_1 += VAR_2 . METHOD_2 ( uri ) ; } return VAR_1 ; } 
public Map < String , Integer > METHOD_1 ( ) { Map < String , Integer > VAR_1 = new TYPE_1 < > ( ) ; <START> for ( Map . Entry < String , List < TYPE_2 > > VAR_2 : VAR_3 . entrySet ( ) ) { <END> VAR_1 . put ( VAR_2 . getKey ( ) , VAR_2 . getValue ( ) . size ( ) ) ; } return VAR_1 ; } 
public Integer METHOD_1 ( String uri ) { Integer VAR_1 = 0 ; <START> if ( VAR_2 . containsKey ( uri ) ) { <END> VAR_1 = VAR_2 . get ( uri ) . size ( ) ; } return VAR_1 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> VAR_2 . METHOD_2 ( "" + VAR_1 . METHOD_3 ( ) ) ; <END> VAR_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; VAR_2 . METHOD_6 ( "" + VAR_1 . getId ( ) ) ; VAR_2 . METHOD_7 ( VAR_1 . getName ( ) ) ; return VAR_2 ; } 
public static String METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 ) { Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( VAR_5 , VAR_2 ) ; params . put ( VAR_6 , VAR_3 ) ; params . put ( VAR_7 , VAR_4 ) ; TYPE_2 VAR_8 = METHOD_2 ( VAR_1 , VAR_9 , VAR_10 , params ) ; <START> return ( String ) VAR_8 . getKey ( ) ; <END> } 
public TYPE_1 < TYPE_2 , TYPE_2 > METHOD_1 ( ) { return new TYPE_3 < TYPE_2 > ( ) { @Override <START> public TYPE_2 METHOD_2 ( TYPE_2 VAR_1 ) { <END> if ( VAR_1 . METHOD_3 ( ) == null ) { VAR_1 . METHOD_4 ( TYPE_4 . METHOD_5 ( ) . toString ( ) ) ; } return VAR_1 ; } } ; } 
public void METHOD_1 ( long VAR_1 ) { METHOD_2 ( VAR_1 , ( ) - > { <START> TYPE_1 VAR_2 = new TYPE_1 ( ) ; <END> VAR_2 . METHOD_3 ( TYPE_2 . METHOD_4 ( ) , VAR_1 ) ; VAR_3 . METHOD_5 ( TYPE_3 . class , VAR_2 ) ; return false ; } ) ; } 
public TYPE_1 METHOD_1 ( ) throws IOException { if ( VAR_1 != null ) { return TYPE_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 ) ? METHOD_4 ( VAR_1 , true ) : new TYPE_3 ( VAR_1 ) ) ; } else { try ( TYPE_1 VAR_2 = super . METHOD_1 ( ) ) { <START> return VAR_2 ; <END> } } } 
public static boolean METHOD_1 ( String VAR_1 ) { boolean VAR_2 = true ; if ( STRING_1 . equalsIgnoreCase ( VAR_1 ) || STRING_2 . equalsIgnoreCase ( VAR_1 ) || STRING_3 . equalsIgnoreCase ( VAR_1 ) <START> || STRING_4 . equals ( VAR_1 ) <END> ) VAR_2 = false ; return VAR_2 ; } 
public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) != null && METHOD_2 ( ) . equalsIgnoreCase ( TYPE_2 . TYPE_3 ) ; <END> } 
public String [ ] METHOD_1 ( ) { return new String [ ] { STRING_1 , STRING_2 , <START> STRING_1 , <END> STRING_3 , STRING_4 , } ; } 
public void METHOD_1 ( ) throws IOException { String url = VAR_1 + STRING_1 ; method = new TYPE_1 ( url ) ; method . VAR_2 ( STRING_2 , VAR_3 ) ; int VAR_4 = client . VAR_5 ( method ) ; assertThat ( VAR_4 , is ( METHOD_2 ( INT_1 ) ) ) ; TYPE_2 VAR_6 = method . VAR_7 ( STRING_3 ) ; <START> assertThat ( VAR_6 . toString ( ) , METHOD_3 ( VAR_3 . toString ( ) ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { String url = VAR_1 + STRING_1 + STRING_2 ; method = new TYPE_1 ( url ) ; method . VAR_2 ( STRING_3 , VAR_3 ) ; int VAR_4 = client . VAR_5 ( method ) ; assertThat ( VAR_4 , is ( METHOD_2 ( INT_1 ) ) ) ; TYPE_2 VAR_6 = method . VAR_7 ( STRING_4 ) ; <START> assertThat ( VAR_6 . toString ( ) , METHOD_3 ( VAR_3 . toString ( ) ) ) ; <END> } 
protected String METHOD_1 ( ) { <START> return super . METHOD_1 ( ) + CHAR_1 + this . METHOD_2 ( ) . getId ( ) + STRING_1 ; <END> } 
private boolean METHOD_1 ( TYPE_1 parameters ) { if ( parameters . VAR_1 ( VAR_2 ) != null ) { return TYPE_2 . equals ( parameters . VAR_1 ( VAR_2 ) . getValue ( ) ) ; } <START> return false ; <END> } 
default Type getType ( ) { <START> return new TYPE_2 ( null , List . VAR_2 , TYPE_1 . VAR_2 ) ; <END> } 
public boolean equals ( Object object ) { <START> if ( object == null && object . getClass ( ) != getClass ( ) ) { <END> return false ; } if ( object == this ) { return true ; } TYPE_1 VAR_1 = ( TYPE_1 ) object ; return new TYPE_2 ( ) . append ( getType ( ) , VAR_1 . getType ( ) ) . append ( METHOD_1 ( ) , VAR_1 . METHOD_1 ( ) ) . append ( METHOD_2 ( ) , VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { try { return this . VAR_2 . getInstance ( TYPE_1 . class , VAR_1 . METHOD_2 ( ) ) ; } catch ( TYPE_4 e ) { <START> throw new TYPE_3 ( String . format ( STRING_1 , VAR_1 . METHOD_2 ( ) ) , e ) ; <END> } } 
public boolean equals ( Object object ) { <START> if ( ( object == null ) || ( object . getClass ( ) != getClass ( ) ) ) { <END> return false ; } if ( object == this ) { return true ; } TYPE_1 VAR_1 = ( TYPE_1 ) object ; return new TYPE_2 ( ) . append ( getId ( ) , VAR_1 . getId ( ) ) . append ( METHOD_1 ( ) , VAR_1 . METHOD_1 ( ) ) . METHOD_2 ( ) ; } 
protected Map < Object , Object > METHOD_1 ( TYPE_1 < Map < ? , ? > , Map < Object , Object > > context ) { if ( context . VAR_1 ( ) . METHOD_2 ( ) ) { if ( TYPE_2 . class . METHOD_3 ( context . VAR_1 ( ) ) ) { return new TYPE_3 < Object , Object > ( ) ; } return new HashMap < Object , Object > ( ) ; } <START> return context . VAR_2 ( ) . METHOD_1 ( context ) ; <END> } 
protected Class < ? > METHOD_1 ( String name ) throws TYPE_1 { if ( name . startsWith ( STRING_1 ) ) return VAR_1 . METHOD_2 ( name ) ; for ( TYPE_2 VAR_2 : VAR_3 ) { try { return VAR_2 . METHOD_2 ( name ) ; } <START> catch ( TYPE_1 e ) { } <END> } throw new TYPE_1 ( ) ; } 
public boolean METHOD_1 ( ) throws TYPE_1 { try { final TYPE_2 url = new TYPE_2 ( STRING_1 ) ; TYPE_3 connection = ( TYPE_3 ) url . VAR_1 ( ) ; connection . VAR_2 ( STRING_2 ) ; connection . VAR_3 ( ) ; int VAR_4 = connection . VAR_5 ( ) ; return VAR_4 == INT_1 ; } catch ( IOException ex ) { <START> throw new TYPE_1 ( ) ; <END> } } 
TYPE_4 ( TYPE_1 method , String url , Map < String , Collection < String > > VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { this . VAR_5 = METHOD_1 ( method , STRING_1 , method . name ( ) ) ; this . url = METHOD_1 ( url , STRING_2 ) ; this . VAR_2 = METHOD_1 ( VAR_2 , STRING_3 , method , url ) ; <START> this . VAR_3 = ( VAR_3 != null ) ? VAR_3 : TYPE_2 . VAR_6 ; <END> this . VAR_4 = VAR_4 ; } 
public TYPE_1 ( long VAR_2 , TimeUnit VAR_3 , long VAR_4 , TimeUnit VAR_5 , boolean VAR_6 ) { super ( ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; <START> this . VAR_7 = true ; <END> } 
public String METHOD_1 ( Map < String , ? > VAR_1 ) { String VAR_2 = super . METHOD_1 ( VAR_1 ) ; if ( this . VAR_3 ) { VAR_2 = VAR_2 . substring ( VAR_2 . METHOD_2 ( TYPE_1 ) + TYPE_1 . length ( ) ) ; VAR_2 = VAR_4 + VAR_2 ; VAR_2 = VAR_2 . substring ( 0 , VAR_2 . METHOD_3 ( VAR_5 ) ) ; <START> VAR_2 += VAR_6 ; <END> } return VAR_2 ; } 
public String METHOD_1 ( ) { if ( content != null ) { return new String ( content , VAR_1 ) ; } else { <START> return null ; <END> } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return ( this . VAR_1 != null ) ? this . VAR_1 : TYPE_2 . VAR_3 ; } 
public TYPE_1 build ( ) { if ( VAR_1 == null ) { throw new IllegalStateException ( STRING_1 ) ; } <START> super . METHOD_1 ( new TYPE_2 ( this . VAR_2 ) ) ; <END> super . METHOD_2 ( new TYPE_3 ( this . VAR_1 ) ) ; return super . build ( ) ; } 
<START> public TYPE_1 METHOD_1 ( Class < ? > VAR_1 ) throws TYPE_2 { <END> TYPE_1 VAR_2 = this . VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; this . VAR_3 . METHOD_3 ( VAR_1 , VAR_2 ) ; } return VAR_2 ; } 
private void METHOD_1 ( List < Class < ? > > VAR_1 ) throws TYPE_1 { <START> for ( Class < ? > VAR_2 : VAR_1 ) { <END> METHOD_2 ( VAR_2 ) ; } } 
<START> private TYPE_3 ( Type type , TYPE_1 VAR_2 , Response response , TYPE_2 reader ) <END> throws IOException { this . response = response ; this . parser = VAR_2 . METHOD_1 ( ) . METHOD_2 ( reader ) ; this . VAR_3 = VAR_2 . reader ( ) . METHOD_3 ( VAR_2 . METHOD_4 ( type ) ) ; } 
<START> private Type METHOD_1 ( Type type ) { <END> if ( ! ( type instanceof TYPE_1 ) ) { throw new IllegalArgumentException ( STRING_1 + type . toString ( ) ) ; } TYPE_1 VAR_1 = ( TYPE_1 ) type ; if ( ! Iterator . VAR_2 . equals ( VAR_1 . METHOD_2 ( ) ) ) { throw new IllegalArgumentException ( STRING_2 + VAR_1 . METHOD_2 ( ) . toString ( ) ) ; } return ( ( TYPE_1 ) type ) . METHOD_3 ( ) [ 0 ] ; } 
<START> public static String METHOD_1 ( Object VAR_1 ) { <END> try { return TYPE_1 . METHOD_2 ( String . valueOf ( VAR_1 ) , TYPE_2 . name ( ) ) ; } catch ( TYPE_3 e ) { throw new RuntimeException ( e ) ; } } 
private TYPE_1 ( Builder builder ) { <START> if ( builder . VAR_2 == null ) { <END> throw new IllegalStateException ( STRING_1 ) ; } this . VAR_2 = builder . VAR_2 ; this . VAR_3 = builder . VAR_3 ; } 
public Response build ( ) { <START> return Response . create ( status , VAR_1 , VAR_2 , VAR_3 , request ) ; <END> } 
public void METHOD_1 ( ) { Response response = Response . builder ( ) . status ( INT_1 ) . METHOD_2 ( null ) <START> . METHOD_3 ( TYPE_1 < String , Collection < String > > METHOD_4 ( ) ) <END> . METHOD_5 ( new byte [ 0 ] ) . build ( ) ; assertThat ( response . VAR_2 ( ) ) . METHOD_6 ( ) ; assertThat ( response . toString ( ) ) . METHOD_7 ( STRING_1 ) ; } 
private Object METHOD_1 ( TYPE_1 VAR_1 , Object value ) { if ( value instanceof TYPE_2 ) { return METHOD_2 ( VAR_1 , ( TYPE_2 ) value ) ; } else if ( value . getClass ( ) . METHOD_3 ( ) ) { <START> return METHOD_2 ( VAR_1 , Arrays . asList ( ( Object [ ] ) value ) ) ; <END> } return VAR_1 . METHOD_4 ( value ) ; } 
private Map < TYPE_1 , TYPE_1 > METHOD_1 ( Map < TYPE_1 , TYPE_2 > VAR_1 ) { Map < TYPE_1 , TYPE_1 > result = new HashMap < TYPE_1 , TYPE_1 > ( ) ; for ( Map . Entry < TYPE_1 , TYPE_2 > entry : VAR_1 . entrySet ( ) ) { TYPE_1 key = entry . getKey ( ) ; <START> key . VAR_2 ( true ) ; <END> result . put ( key , key ) ; } return result ; } 
<START> public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> super ( VAR_2 , VAR_3 ) ; this . METHOD_1 ( TYPE_4 . VAR_5 ) ; this . VAR_3 = VAR_3 ; VAR_6 = VAR_3 . get ( TYPE_5 . TYPE_3 ) ; VAR_9 = VAR_3 . get ( TYPE_5 . TYPE_7 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 . create ( VAR_1 ) . METHOD_2 ( VAR_1 ) ; TYPE_3 VAR_2 = new TYPE_3 ( ) ; VAR_2 . METHOD_3 ( STRING_1 ) ; TYPE_4 VAR_3 = new TYPE_4 ( ) ; VAR_1 . VAR_4 . METHOD_4 ( VAR_2 , VAR_3 ) ; <START> System . out . println ( new String ( VAR_3 . METHOD_5 ( ) ) ) ; <END> assertEquals ( new String ( VAR_3 . METHOD_5 ( ) , VAR_5 ) , STRING_2 + STRING_3 ) ; } 
<START> public Set < T > METHOD_1 ( ) { <END> return set ; } 
public String toString ( TYPE_1 VAR_1 ) { TYPE_2 < String > VAR_2 = TYPE_3 . METHOD_1 ( set , new TYPE_4 < T > ( VAR_1 ) ) ; <START> return TYPE_5 . METHOD_2 ( CHAR_1 ) . METHOD_3 ( TYPE_6 . METHOD_4 ( VAR_2 ) ) ; <END> } 
public void METHOD_1 ( ) { Assert . assertEquals ( STRING_1 , STRING_2 , TYPE_1 . in ( new TYPE_2 ( STRING_3 ) , new TYPE_2 ( STRING_4 ) , new TYPE_2 ( "" ) ) . toString ( VAR_1 ) ) ; Assert . assertEquals ( STRING_5 , <START> STRING_2 , TYPE_1 . in ( STRING_3 , STRING_4 , "" ) . toString ( VAR_1 ) ) ; <END> Assert . assertEquals ( STRING_6 , TYPE_1 . in ( STRING_3 , STRING_4 , "" ) , TYPE_3 < String > METHOD_2 ( STRING_7 , VAR_1 ) ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { TYPE_1 . METHOD_2 ( VAR_1 ) ; TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> VAR_1 = null ; <END> } } 
public TYPE_1 build ( ) { try { TYPE_1 VAR_1 = VAR_2 . METHOD_1 ( options ) ; <START> StringBuilder uri = new StringBuilder ( ) ; <END> uri . append ( VAR_3 ? VAR_4 : VAR_5 ) . append ( STRING_1 ) . append ( VAR_1 . METHOD_2 ( ) ) . append ( STRING_1 ) . append ( VAR_1 . METHOD_3 ( ) ) ; return new TYPE_1 ( uri . toString ( ) ) ; } catch ( TYPE_2 e ) { throw new IllegalArgumentException ( STRING_2 , e ) ; } } 
public static TYPE_1 get ( ) { <START> return conf ; <END> } 
public static void METHOD_1 ( String VAR_1 , String name ) { TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ; TYPE_1 . METHOD_2 ( name , STRING_2 ) ; <START> TYPE_1 . METHOD_3 ( TYPE_2 . METHOD_4 ( name ) , <END> STRING_3 , VAR_1 ) ; TYPE_1 . METHOD_3 ( TYPE_2 . METHOD_4 ( name ) , STRING_4 , name ) ; } 
public TYPE_1 METHOD_1 ( View < ? > view ) { <START> if ( view instanceof TYPE_2 && view instanceof TYPE_3 ) { <END> TYPE_3 VAR_1 = ( TYPE_3 ) view ; conf . set ( VAR_2 , String . valueOf ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ) ; } METHOD_4 ( view . getType ( ) ) ; return METHOD_1 ( view . VAR_3 ( ) ) ; } 
public static < TYPE_1 > void METHOD_1 ( Set < TYPE_1 > VAR_1 , View < TYPE_1 > view ) { TYPE_2 < TYPE_1 > reader = null ; try { reader = view . VAR_2 ( ) ; Assert . assertEquals ( VAR_1 , TYPE_3 . METHOD_2 ( ( TYPE_4 < TYPE_1 > ) reader ) ) ; } finally { <START> TYPE_5 . METHOD_3 ( reader ) ; <END> } } 
private TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 != null && VAR_1 != TYPE_3 . TYPE_4 . class ) { <END> TYPE_1 record = METHOD_2 ( ) ; if ( record != null ) { return record ; } } return METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { conf . set ( VAR_2 , VAR_1 . toString ( ) ) ; TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( VAR_1 ) ; if ( VAR_3 instanceof TYPE_5 ) { TYPE_6 VAR_4 = ( ( TYPE_5 ) VAR_3 ) . METHOD_3 ( <START> TYPE_7 . METHOD_4 ( ) . toString ( ) ) ; <END> conf . set ( VAR_5 , VAR_4 . METHOD_5 ( ) . toString ( ) ) ; } return this ; } 
private static String METHOD_1 ( String key , Map < String , String > options , Map < String , String > VAR_1 ) { String VAR_2 = VAR_1 . get ( key ) ; if ( options . containsKey ( key ) ) { String value = options . remove ( key ) ; <START> if ( ! VAR_2 . equals ( value ) ) { <END> return value ; } } return null ; } 
public static < TYPE_1 > TYPE_2 < TYPE_1 > METHOD_1 ( TYPE_3 uri , Class < TYPE_1 > type ) { <START> View < TYPE_1 > view = TYPE_5 < TYPE_1 , View < TYPE_1 > > view ( uri ) ; <END> return new TYPE_4 < TYPE_1 > ( view , type ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_1 table ; try { synchronized ( client ) { table = TYPE_2 . METHOD_1 ( client , VAR_1 , VAR_2 ) ; } } catch ( RuntimeException e ) { <START> throw new RuntimeException ( STRING_1 , e ) ; <END> } catch ( Exception e ) { throw new TYPE_3 ( STRING_2 , e ) ; } if ( table == null ) { throw new TYPE_3 ( STRING_3 + VAR_2 ) ; } return table ; } 
public TYPE_1 ( String VAR_2 , String VAR_3 , String VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = VAR_4 ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 ) { throw new IllegalStateException ( STRING_1 ) ; } try { if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( null ) ; } synchronized ( VAR_3 ) { VAR_3 . clear ( ) ; } } <START> finally { <END> synchronized ( VAR_1 ) { VAR_1 = true ; } } } 
protected boolean METHOD_1 ( ) { boolean VAR_1 = false ; Set < String > VAR_2 = METHOD_2 ( ) ; if ( VAR_2 . size ( ) > 0 ) { log . debug ( STRING_1 ) ; <START> VAR_1 = true ; <END> } return VAR_1 ; } 
<START> private boolean METHOD_1 ( String type ) throws Exception { <END> boolean VAR_1 = false ; switch ( type ) { case STRING_1 : case STRING_2 : case STRING_3 : case STRING_4 : case STRING_5 : if ( VAR_2 ) { throw new TYPE_1 ( STRING_6 + type + STRING_7 ) ; } else { VAR_1 = true ; } break ; case STRING_8 : VAR_1 = true ; break ; case STRING_9 : if ( VAR_2 ) { VAR_1 = true ; } break ; default : break ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { File VAR_1 = new File ( STRING_1 ) ; TYPE_1 is = new TYPE_2 ( VAR_1 ) ; TYPE_3 VAR_2 = new TYPE_3 ( new TYPE_4 ( is ) ) ; String line ; while ( ( line = VAR_2 . METHOD_2 ( ) ) != null ) { <START> METHOD_3 ( line . equals ( Constants . VAR_3 ) ) ; <END> } } 
private static File METHOD_1 ( ) { File VAR_1 = null ; if ( VAR_2 != null && VAR_2 . exists ( ) ) { VAR_1 = new File ( VAR_2 , STRING_1 ) ; } <START> <END> if ( VAR_1 == null || ! VAR_1 . exists ( ) ) { VAR_1 = new File ( METHOD_2 ( ) . METHOD_3 ( ) , STRING_1 ) ; } return VAR_1 ; } 
public void METHOD_1 ( String key , String value ) { TYPE_1 child = VAR_1 . METHOD_1 ( key ) ; child . VAR_2 ( VAR_1 . METHOD_2 ( value ) ) ; <START> VAR_1 . METHOD_3 ( ) . METHOD_4 ( child ) ; <END> } 
public TYPE_4 ( Context context , TYPE_1 VAR_2 , TYPE_2 uri , String VAR_3 , String VAR_4 ) { VAR_5 = context ; VAR_6 = VAR_2 ; VAR_7 = VAR_5 . METHOD_1 ( ) ; VAR_8 = uri ; VAR_9 = VAR_3 ; VAR_10 = VAR_4 ; <START> VAR_11 = TYPE_3 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . get ( ) . METHOD_2 ( ) ; if ( VAR_1 != null && VAR_2 != null ) { TYPE_3 b = TYPE_4 . METHOD_3 ( VAR_1 ) ; int VAR_3 = METHOD_4 ( ) . METHOD_5 ( ) . VAR_4 ; int VAR_5 = METHOD_4 ( ) . METHOD_5 ( ) . VAR_6 ; <START> int VAR_7 = ( int ) ( VAR_3 * FLOAT_1 ) ; <END> VAR_2 . METHOD_6 ( ( TYPE_5 . METHOD_7 ( b , VAR_3 , VAR_5 , VAR_7 ) ) ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_2 ( ) ; TYPE_2 status = VAR_3 . METHOD_3 ( VAR_1 ) ; <START> String VAR_4 = VAR_5 . METHOD_4 ( ) ; <END> if ( VAR_4 != null ) { TYPE_3 . start ( VAR_6 , status . VAR_7 ( ) , VAR_4 ) ; } else { TYPE_3 . start ( VAR_6 , status . VAR_7 ( ) ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = false ; if ( VAR_3 == null ) { VAR_2 = true ; } VAR_3 = VAR_1 ; if ( VAR_4 != null ) { VAR_4 . METHOD_1 ( VAR_1 ) ; } if ( VAR_2 ) { METHOD_2 ( true , false ) ; <START> METHOD_3 ( null , null , VAR_1 ) ; <END> } } 
public static void METHOD_1 ( Context context ) { <START> if ( METHOD_2 ( ) == false ) { <END> TYPE_1 . getInstance ( context ) . METHOD_3 ( true ) ; } if ( TYPE_2 . VAR_2 ) { TYPE_1 . getInstance ( context ) . METHOD_4 ( true ) ; } } 
public void METHOD_1 ( ) { VAR_1 = METHOD_2 ( STRING_1 , TYPE_1 . class ) ; VAR_2 = METHOD_2 ( STRING_2 , TYPE_2 . class ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_3 ( VAR_3 - > { VAR_1 . setText ( VAR_4 [ VAR_5 ] ) ; <START> if ( VAR_5 > VAR_4 . length ( ) - 2 ) <END> VAR_5 = 0 ; else VAR_5 ++ ; } ) ; } } 
public void METHOD_1 ( ) { VAR_1 = METHOD_2 ( STRING_1 , TYPE_1 . class ) ; VAR_1 . setText ( TYPE_3 [ VAR_3 . METHOD_3 ( TYPE_3 . length - 1 ) ] ) ; VAR_4 = METHOD_2 ( STRING_2 , TYPE_2 . class ) ; if ( VAR_4 != null ) { VAR_4 . METHOD_4 ( VAR_5 - > { <START> VAR_1 . setText ( TYPE_3 [ VAR_3 . METHOD_3 ( TYPE_3 . length - 1 ) ] ) ; <END> } ) ; } } 
protected void METHOD_1 ( ANNOTATION_1 final String VAR_1 ) { try { if ( VAR_2 . METHOD_2 ( ) ) { VAR_2 . debug ( STRING_1 + VAR_1 ) ; } final long start = System . currentTimeMillis ( ) ; VAR_3 . METHOD_3 ( VAR_4 . METHOD_4 ( VAR_1 ) ) ; VAR_5 . METHOD_5 ( VAR_6 , start ) ; <START> } catch ( final IOException e ) { <END> VAR_2 . warn ( STRING_2 + VAR_1 , e ) ; } } 
<START> public void METHOD_1 ( ) throws IOException { <END> final String VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; final int VAR_4 = VAR_5 . METHOD_3 ( ) ; final int VAR_6 = VAR_4 <= 0 ? 0 : VAR_4 ; VAR_7 . set ( VAR_1 , METHOD_4 ( VAR_6 ) , VAR_8 ) ; } 
public void METHOD_1 ( ) { query = METHOD_2 ( VAR_1 ) ; <START> super . METHOD_1 ( true ) ; <END> } 
public void METHOD_1 ( ) { event = TYPE_1 . builder ( ) <START> . repo ( new TYPE_1 . TYPE_4 ( ) { <END> ANNOTATION_1 @Override public Long id ( ) { return null ; } ANNOTATION_1 @Override public String url ( ) { return null ; } ANNOTATION_1 @Override public String METHOD_2 ( ) { return VAR_1 ; } @Override public int METHOD_3 ( ) { return 0 ; } @Override public void METHOD_4 ( TYPE_3 VAR_2 , int i ) { } } ) . build ( ) ; } 
private void METHOD_1 ( ) { Collections . VAR_1 ( VAR_2 , VAR_3 ) ; <START> METHOD_2 ( ) . METHOD_3 ( new TYPE_1 ( ) { <END> @Override public void run ( ) { METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( VAR_2 . METHOD_7 ( ) ) ; METHOD_8 ( VAR_2 ) ; } } ) ; } 
public TYPE_1 bind ( String VAR_1 , String VAR_2 , List < TYPE_2 > VAR_3 ) { TYPE_3 < String , String > props = new TYPE_3 < String , String > ( ) ; props . put ( Context . VAR_4 , STRING_1 ) ; <START> props . put ( STRING_2 , STRING_3 ) ; <END> props . put ( STRING_4 , TYPE_4 . class . getName ( ) ) ; return bind ( VAR_1 , VAR_2 , VAR_3 , props ) ; } 
public static Map < String , String > METHOD_1 ( List < TYPE_1 > properties ) { if ( properties != null ) { final Map < String , String > result = new TYPE_2 < String , String > ( ) ; for ( TYPE_1 VAR_1 : properties ) { result . put ( VAR_1 . getName ( ) , VAR_1 . getValue ( ) ) ; } return result ; } <START> return null ; <END> } 
<START> public TYPE_2 ( String VAR_2 , TYPE_1 VAR_3 ) { <END> super ( VAR_2 , VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( String command ) throws TYPE_2 , TYPE_3 { METHOD_2 ( ) ; log . debug ( STRING_1 , command ) ; <START> METHOD_3 ( STRING_2 , true , new TYPE_5 . TYPE_6 ( ) . METHOD_4 ( command . VAR_1 ( METHOD_5 ( ) ) ) ) <END> . METHOD_6 ( VAR_2 . METHOD_7 ( ) , TimeUnit . VAR_3 ) ; VAR_4 = true ; return this ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 , TYPE_3 { METHOD_2 ( ) ; METHOD_3 ( ) ; <START> final TYPE_4 sess = ( VAR_1 != null ) ? new TYPE_4 ( VAR_2 , VAR_1 ) : new TYPE_4 ( VAR_2 ) ; <END> sess . VAR_3 ( ) ; return sess ; } 
public TYPE_1 METHOD_1 ( TYPE_1 . TYPE_4 parameters , TYPE_3 VAR_1 ) { <START> if ( VAR_2 == null ) { <END> VAR_2 = new ArrayList < TYPE_1 > ( ) ; } TYPE_1 VAR_3 = new TYPE_1 ( VAR_4 , parameters , VAR_1 ) ; VAR_2 . add ( VAR_3 ) ; return VAR_3 ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { TYPE_1 target = null ; for ( TYPE_1 t : VAR_2 ) { if ( t . VAR_3 ( VAR_1 ) ) { target = t ; <START> break ; <END> } } if ( target == null ) { throw new TYPE_2 ( String . format ( STRING_1 , VAR_1 ) ) ; } return target ; } 
protected Set < TYPE_1 > METHOD_1 ( String event ) { final Set < TYPE_1 > VAR_1 ; synchronized ( VAR_2 ) { final Set < TYPE_1 > VAR_3 = VAR_4 . get ( event ) ; if ( VAR_3 != null ) { VAR_1 = new HashSet < TYPE_1 > ( VAR_3 ) ; } else { VAR_1 = null ; } } <START> return VAR_1 ; <END> } 
public void METHOD_1 ( final String VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } final TYPE_1 channel = VAR_2 . remove ( VAR_1 ) ; if ( channel == null ) { return ; } if ( connection . VAR_3 ( ) == TYPE_3 . VAR_5 ) { if ( channel instanceof TYPE_2 ) { <START> ( ( TYPE_2 ) channel ) . METHOD_2 ( ) ; <END> } METHOD_3 ( channel ) ; } } 
public String METHOD_1 ( ) { String msg = super . METHOD_1 ( ) ; <START> VAR_1 = METHOD_2 ( ( String ) VAR_2 ) ; <END> return msg ; } 
public String toString ( ) { String VAR_1 = "" ; <START> if ( VAR_2 != null ) { <END> for ( String key : VAR_2 . keySet ( ) ) { String value = VAR_2 . get ( key ) ; VAR_1 = VAR_1 + key + STRING_1 + value + STRING_2 ; } } return VAR_1 ; } 
<START> public Object METHOD_1 ( ) { return VAR_1 . get ( STRING_1 ) ; } <END> 
public void METHOD_1 ( final TYPE_1 channel , final TYPE_2 listener , final String ... VAR_1 ) { synchronized ( VAR_2 ) { <START> METHOD_2 ( channel , listener , VAR_1 ) ; <END> VAR_2 . put ( channel . getName ( ) , channel ) ; METHOD_3 ( channel ) ; } } 
public void METHOD_1 ( final int VAR_1 , final String VAR_2 , final boolean VAR_3 ) { if ( state != TYPE_2 . VAR_5 ) { VAR_6 . METHOD_2 ( ) ; factory . VAR_7 ( new TYPE_1 ( ) { @Override public void run ( ) { METHOD_3 ( TYPE_2 . VAR_5 ) ; factory . VAR_8 ( ) ; } } ) ; } else { log . error ( STRING_1 + STRING_2 + VAR_1 + STRING_3 + VAR_2 + STRING_4 + VAR_3 + STRING_5 ) ; <START> } <END> } 
public void METHOD_1 ( ) { METHOD_2 ( new TYPE_1 ( ) { @Override public Object METHOD_3 ( TYPE_2 VAR_1 ) throws Throwable { final TYPE_3 r = ( TYPE_3 ) VAR_1 . METHOD_4 ( ) [ 0 ] ; <START> new TYPE_4 ( ) . execute ( r ) ; <END> return null ; } } ) . when ( factory ) . METHOD_5 ( METHOD_6 ( TYPE_3 . class ) ) ; VAR_2 = METHOD_7 ( ) ; channel = METHOD_8 ( METHOD_9 ( ) ) ; channel . VAR_3 ( VAR_2 ) ; } 
public void bind ( final String VAR_1 , final TYPE_1 listener ) { METHOD_1 ( VAR_1 , listener ) ; <START> Set < TYPE_1 > VAR_2 = VAR_3 . get ( VAR_1 ) ; <END> synchronized ( VAR_4 ) { if ( VAR_2 == null ) { VAR_2 = new HashSet < TYPE_1 > ( ) ; VAR_3 . put ( VAR_1 , VAR_2 ) ; } VAR_2 . add ( listener ) ; } } 
public TYPE_1 METHOD_1 ( final String VAR_1 , final TYPE_2 listener , final String ... VAR_2 ) { METHOD_2 ( ) ; final TYPE_3 channel = factory . VAR_3 ( connection , VAR_1 , VAR_4 . METHOD_3 ( ) ) ; VAR_5 . METHOD_4 ( channel , listener , VAR_2 ) ; <START> VAR_6 . add ( channel ) ; <END> return channel ; } 
public void METHOD_1 ( ) { try { properties . VAR_1 ( getClass ( ) . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ) ; } catch ( IOException e ) { <START> e . VAR_2 ( ) ; <END> } assertNotNull ( properties . get ( STRING_2 ) . toString ( ) ) ; assertEquals ( STRING_3 . length ( ) , properties . get ( STRING_2 ) . toString ( ) . length ( ) ) ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 options = new TYPE_1 ( ) ; <START> options . VAR_1 ( VAR_2 ) ; <END> options . VAR_3 ( VAR_4 ) ; options . VAR_5 ( VAR_6 ) ; options . VAR_7 ( VAR_8 ) ; options . VAR_9 ( VAR_10 ) ; options . VAR_11 ( VAR_12 ) ; return options ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> } 
private static TYPE_1 METHOD_1 ( Context context , boolean VAR_1 ) { TYPE_1 . Builder builder = new TYPE_1 . Builder ( context ) . METHOD_2 ( TYPE_3 . VAR_3 ) ; if ( VAR_1 ) { builder . VAR_4 ( TYPE_4 . VAR_3 ) . METHOD_3 ( TYPE_4 . VAR_6 ) <START> . METHOD_2 ( TYPE_2 . VAR_3 ) . METHOD_3 ( TYPE_2 . VAR_8 ) ; <END> } return builder . build ( ) ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> for ( int i = 0 ; i <= VAR_1 . METHOD_3 ( ) ; i ++ ) { <END> View child = VAR_1 . METHOD_4 ( i ) ; if ( child != null ) { VAR_2 . METHOD_5 ( ( TYPE_3 . TYPE_4 ) VAR_1 . METHOD_6 ( child ) ) ; } } } 
private void METHOD_1 ( ) { <START> TYPE_1 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( <END> VAR_1 , new TYPE_2 < TYPE_3 > ( ) { @Override public void METHOD_4 ( TYPE_3 VAR_2 , TYPE_4 . client . Response response ) { VAR_3 = VAR_2 ; TYPE_5 VAR_4 = METHOD_5 ( VAR_2 . METHOD_6 ( ) , VAR_1 ) ; METHOD_1 ( VAR_4 ) ; } @Override public void METHOD_7 ( TYPE_6 error ) { } } ) ; } 
public TYPE_3 ( Context ctx , TYPE_1 VAR_2 , ANNOTATION_1 TYPE_2 VAR_3 ) { super ( VAR_2 ) ; VAR_4 = ctx ; <START> this . VAR_5 = VAR_3 ; <END> } 
TYPE_1 ( String [ ] VAR_2 ) { this . VAR_3 = false ; <START> this . VAR_2 = ( VAR_2 != null ) ? VAR_2 : new String [ ] { } ; <END> } 
<START> String METHOD_1 ( ) { <END> return METHOD_1 ( METHOD_2 ( ) . getProperty ( VAR_1 ) ) ; } 
public void METHOD_1 ( ) { assertTrue ( this . VAR_1 . METHOD_2 ( ) ) ; this . VAR_1 . METHOD_3 ( VAR_2 , true ) ; this . VAR_1 . METHOD_4 ( this . VAR_1 . METHOD_5 ( VAR_2 ) ) ; <START> assertEquals ( this . VAR_1 . METHOD_5 ( VAR_2 ) , - 1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 context ) throws TYPE_2 { boolean VAR_1 = context . VAR_2 ( ) . METHOD_2 ( context ) ; if ( VAR_1 ) { TYPE_3 VAR_3 = context . VAR_4 ( ) ; if ( VAR_3 != null ) { TYPE_4 VAR_5 = VAR_3 . METHOD_3 ( ) ; if ( VAR_5 == null ) { <START> VAR_3 . METHOD_4 ( new TYPE_4 ( ) ) ; <END> } } this . METHOD_5 ( context ) . METHOD_6 ( this , true , context ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String content , String VAR_2 , String VAR_3 , TYPE_3 VAR_4 ) throws Exception { TYPE_1 VAR_5 = METHOD_2 ( VAR_1 , content , VAR_2 ) ; METHOD_3 ( VAR_1 , VAR_3 , VAR_4 , false ) ; <START> return VAR_5 ; <END> } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws Exception <END> { VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; VAR_1 . METHOD_4 ( VAR_2 , "" , STRING_1 , STRING_2 , new TYPE_3 ( STRING_3 . METHOD_5 ( ) ) ) ; TYPE_4 VAR_3 = VAR_1 . METHOD_6 ( VAR_2 ) ; TYPE_5 VAR_4 = VAR_3 . METHOD_7 ( ) ; VAR_4 . METHOD_8 ( STRING_2 ) ; } 
public void METHOD_1 ( TYPE_1 buffer , String name , String VAR_1 , TYPE_2 object , TYPE_3 context ) { <START> buffer . append ( METHOD_2 ( name , VAR_1 , object , context ) ) ; <END> } 
<START> public String METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 , TYPE_2 context , <END> boolean VAR_3 ) throws TYPE_3 { Object VAR_4 = context . get ( STRING_1 ) ; try { TYPE_4 VAR_5 ; if ( VAR_3 ) { VAR_5 = METHOD_2 ( context ) ; } else { VAR_5 = this ; } context . put ( STRING_1 , VAR_5 ) ; return METHOD_3 ( VAR_1 , false , VAR_2 , false , VAR_3 ) ; } finally { context . put ( STRING_1 , VAR_4 ) ; } } 
<START> protected static void METHOD_1 ( TYPE_1 container , String VAR_1 , <END> String VAR_2 ) { String VAR_3 = System . getProperty ( STRING_1 ) . METHOD_2 ( ) ; if ( VAR_3 . startsWith ( STRING_2 ) ) { TYPE_2 VAR_4 = TYPE_2 . METHOD_3 ( VAR_1 ) ; container . VAR_5 ( VAR_4 , VAR_2 ) ; } else { container . VAR_6 ( VAR_1 , VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( Collection < TYPE_2 > VAR_1 , TYPE_2 VAR_2 ) { TYPE_1 request = new TYPE_1 ( ) ; this . METHOD_2 ( request , TYPE_5 . VAR_4 , VAR_1 ) ; TYPE_2 VAR_5 ; if ( VAR_2 . getType ( ) . equals ( TYPE_4 . VAR_7 ) ) { <START> TYPE_3 VAR_8 = ( TYPE_3 ) VAR_2 ; <END> VAR_5 = VAR_8 . METHOD_3 ( ) ; } else { VAR_5 = VAR_2 ; } request . VAR_9 ( VAR_5 ) ; return request ; } 
public Class < ? > getType ( ) { <START> if ( this . VAR_1 == null ) { <END> return String . VAR_2 ; } else { return TYPE_1 . METHOD_1 ( this . VAR_1 ) ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 element = METHOD_2 ( ) . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_1 ) ) . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_2 ) ) ; <START> METHOD_2 ( ) . METHOD_5 ( TYPE_3 . METHOD_4 ( VAR_2 ) ) ; <END> return new TYPE_1 ( element ) ; } 
public void METHOD_1 ( String VAR_1 ) { try { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { <START> VAR_2 = VAR_3 . METHOD_3 ( ) ; <END> } VAR_4 . METHOD_1 ( VAR_2 ) ; } catch ( TYPE_2 e ) { METHOD_4 ( e ) ; } } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) <END> { this ( VAR_2 , null ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_2 ( this ) ; <END> return this . VAR_2 . set ( VAR_1 ) ; } 
public boolean add ( TYPE_1 VAR_1 ) { <START> map . put ( VAR_1 . METHOD_1 ( ) , VAR_1 ) ; <END> this . list = new ArrayList < TYPE_1 > ( map . values ( ) ) ; METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; return true ; } 
public boolean addAll ( Collection < ? extends TYPE_1 > c ) { boolean VAR_1 = false ; for ( TYPE_1 x : c ) { <START> if ( map . put ( x . VAR_2 ( ) , x ) == null ) { <END> VAR_1 = true ; METHOD_1 ( x ) ; } } if ( VAR_1 ) { METHOD_2 ( ) ; } return VAR_1 ; } 
public boolean add ( TYPE_1 VAR_1 ) { TYPE_1 set = set ( VAR_1 ) ; <START> return ! set . equals ( VAR_1 ) ; <END> } 
public boolean addAll ( Collection < ? extends TYPE_1 > c ) { boolean VAR_1 = false ; for ( TYPE_1 x : c ) { TYPE_1 put = map . put ( x . VAR_2 ( ) , x ) ; <START> if ( ! x . equals ( put ) ) { <END> VAR_1 = true ; METHOD_1 ( x ) ; } } if ( VAR_1 ) { METHOD_2 ( ) ; } return VAR_1 ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( true ) ; <START> this . METHOD_3 ( map . values ( ) ) ; <END> } 
public boolean METHOD_1 ( Collection < ? > c ) { boolean VAR_1 = false ; Collection < TYPE_1 > values = map . values ( ) ; for ( TYPE_1 x : values ) { if ( ! c . contains ( x ) ) { <START> map . remove ( x . VAR_2 ( ) , x ) ; <END> VAR_1 = true ; } } if ( VAR_1 ) { METHOD_2 ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws TYPE_1 { VAR_1 . clear ( ) ; <START> assertEquals ( VAR_1 , new ArrayList < TYPE_2 > ( ) ) ; <END> } 
public byte [ ] METHOD_1 ( String name ) throws IOException { byte output [ ] = new byte [ 0 ] ; <START> if ( METHOD_2 ( ) != null ) { <END> try ( TYPE_1 is = METHOD_3 ( name ) ) { if ( is == null ) { output = TYPE_2 . METHOD_4 ( new File ( name ) ) ; } else output = TYPE_3 . METHOD_5 ( is ) ; } } return output ; } 
public byte [ ] METHOD_1 ( String name ) throws IOException { if ( METHOD_2 ( ) != null ) { try ( TYPE_1 is = METHOD_3 ( name ) ) { if ( is != null ) { return TYPE_2 . METHOD_4 ( is ) ; } } catch ( Exception e ) { } <START> return TYPE_3 . METHOD_5 ( new File ( name ) ) ; <END> } return new byte [ 0 ] ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) <END> { return METHOD_1 ( null , VAR_1 ) ; } 
public TYPE_1 ( TYPE_2 VAR_3 ) { <START> String VAR_4 ; <END> super ( VAR_3 ) ; this . VAR_4 = VAR_4 ; } 
public TYPE_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 = VAR_1 . VAR_2 ; <END> this . VAR_3 = VAR_1 . VAR_3 ; } 
public boolean METHOD_1 ( Object o ) { <START> return ( this . getClass ( ) . METHOD_2 ( o ) && ( ( TYPE_1 ) o ) . METHOD_3 ( ) . equals ( this . event ) ) ; <END> } 
<START> private boolean METHOD_1 ( TYPE_1 context ) <END> { return context . VAR_1 ( ) . METHOD_1 ( ) ; } 
private String METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 context ) throws Exception { TYPE_2 VAR_3 = null ; try { VAR_3 = ( TYPE_2 ) context . VAR_4 ( ) . METHOD_2 ( VAR_1 , context ) . METHOD_3 ( ) . get ( VAR_2 ) ; } catch ( TYPE_3 e ) { LOGGER . error ( STRING_1 , VAR_2 , VAR_1 , e ) ; } <START> return VAR_3 . METHOD_4 ( ) . getClass ( ) . getName ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { when ( VAR_1 . getProperty ( STRING_1 , 4 ) ) . METHOD_2 ( 4 ) ; int i = VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; <START> assertTrue ( i == 4 ) ; <END> } 
public String METHOD_1 ( ) { <START> return METHOD_2 ( ) . METHOD_3 ( context ) ; <END> } 
<START> List < TYPE_1 > METHOD_1 ( Integer VAR_1 ) throws TYPE_2 , <END> TYPE_3 { List < TYPE_1 > VAR_2 = this . VAR_3 . METHOD_2 ( VAR_1 , TYPE_4 . VAR_5 ) ; if ( VAR_2 . isEmpty ( ) ) { throw new TYPE_3 ( STRING_1 ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( final String VAR_1 ) { if ( VAR_2 . containsKey ( VAR_1 ) ) { return VAR_2 . get ( VAR_1 ) ; } <START> for ( String key : VAR_2 . keySet ( ) ) { <END> if ( key != null && VAR_1 . METHOD_2 ( key ) ) { TYPE_1 VAR_3 = VAR_2 . get ( key ) ; VAR_2 . put ( VAR_1 , VAR_3 ) ; return VAR_3 ; } } return null ; } 
public void METHOD_1 ( ) { this . VAR_1 . METHOD_2 ( ) . METHOD_3 ( null ) ; final TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> VAR_2 . METHOD_3 ( 0 ) ; <END> VAR_2 . METHOD_4 ( STRING_1 ) ; final int VAR_3 = this . VAR_4 . METHOD_5 ( VAR_2 ) ; Assert . assertEquals ( STRING_2 + VAR_3 , TYPE_3 . TYPE_4 . METHOD_6 ( ) , VAR_3 ) ; } 
private void METHOD_1 ( final int VAR_1 , final TYPE_1 VAR_2 , final TYPE_2 VAR_3 ) throws TYPE_3 { final String VAR_4 = this . METHOD_2 ( VAR_2 , VAR_1 ) ; <START> METHOD_3 ( VAR_3 , VAR_4 ) ; <END> } 
public List < Object > METHOD_1 ( ) { <START> return Collections . VAR_1 ( new TYPE_3 . TYPE_2 ( VAR_2 ) ) ; <END> } 
public List < Object > METHOD_1 ( ) { <START> return Collections . VAR_1 ( new TYPE_3 . TYPE_2 ( max ) ) ; <END> } 
private static void METHOD_1 ( TYPE_1 file , TYPE_2 context , TYPE_3 [ ] VAR_1 ) { TYPE_4 VAR_2 = context . VAR_3 ( ) . METHOD_2 ( file ) ; for ( TYPE_3 VAR_4 : VAR_1 ) { VAR_2 . METHOD_3 ( VAR_4 . VAR_5 , VAR_4 . VAR_6 , VAR_4 . VAR_7 , VAR_4 . VAR_8 , <START> TYPE_5 . valueOf ( VAR_4 . VAR_9 . METHOD_4 ( TYPE_6 . VAR_11 ) ) ) ; <END> } VAR_2 . METHOD_5 ( ) ; } 
<START> public String [ ] METHOD_1 ( ) { <END> String [ ] VAR_1 = configuration . VAR_2 ( VAR_3 ) ; if ( VAR_1 == null || VAR_1 . length == 0 ) { VAR_1 = StringUtils . split ( VAR_4 , STRING_1 ) ; } return VAR_1 ; } 
public void execute ( TYPE_1 context ) { if ( VAR_1 . length == 0 ) { <START> LOG . info ( STRING_1 ) ; <END> return ; } METHOD_1 ( ) ; if ( VAR_2 == null ) { return ; } try { for ( TYPE_2 VAR_3 : METHOD_2 ( context ) ) { METHOD_3 ( VAR_3 , context ) ; } } finally { METHOD_4 ( ) ; } } 
public static int METHOD_1 ( ) { try ( TYPE_1 VAR_1 = new TYPE_1 ( 0 ) ) { return VAR_1 . METHOD_2 ( ) ; } catch ( IOException e ) { <START> return INT_1 ; <END> } } 
<START> private List < String > METHOD_1 ( String VAR_1 , List < String > VAR_2 , ANNOTATION_1 String VAR_3 , List < String > args ) { <END> List < String > result = new ArrayList < > ( ) ; result . add ( VAR_1 ) ; result . addAll ( VAR_2 ) ; if ( VAR_3 != null ) { result . add ( VAR_3 ) ; } result . addAll ( args ) ; return Collections . VAR_4 ( result ) ; } 
<START> public static TYPE_1 METHOD_1 ( ) { <END> return TYPE_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . METHOD_4 ( ) . url ( VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) ) . build ( ) ) ; } 
public boolean METHOD_1 ( TYPE_1 file ) { boolean VAR_1 = new TYPE_2 ( ) . METHOD_2 ( file ) ; if ( VAR_1 ) { <START> LOG . debug ( STRING_1 + file . toString ( ) + STRING_2 ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( new TYPE_3 ( STRING_1 ) ) ; TYPE_4 file = METHOD_2 ( STRING_2 ) ; METHOD_3 ( ) . METHOD_4 ( context , ImmutableList . of ( ( TYPE_5 ) VAR_1 ) , ImmutableList . of ( file ) , VAR_2 , VAR_3 ) ; assertThat ( context . VAR_4 ( ) ) . METHOD_5 ( 1 ) ; <START> assertThat ( VAR_5 . METHOD_6 ( ) ) . contains ( STRING_3 + file . toString ( ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { assertThat ( VAR_1 . METHOD_2 ( TYPE_2 . TYPE_1 . VAR_4 ) ) . METHOD_3 ( STRING_1 ) . METHOD_3 ( STRING_2 ) . METHOD_3 ( STRING_3 ) . METHOD_3 ( STRING_4 ) . METHOD_3 ( STRING_5 ) . METHOD_3 ( STRING_6 ) . METHOD_3 ( STRING_7 ) . METHOD_3 ( STRING_8 ) . METHOD_3 ( STRING_9 ) <START> . METHOD_3 ( STRING_10 ) <END> ; } 
public Iterator < TYPE_1 > METHOD_1 ( ) { <START> if ( parameters != null ) { <END> return TYPE_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 ) , parameters . VAR_2 ( TYPE_3 . METHOD_4 ( ) ) , TYPE_2 . METHOD_5 ( VAR_3 , VAR_4 , VAR_5 ) ) ; } else { return TYPE_2 . METHOD_5 ( VAR_1 , VAR_3 , VAR_4 , VAR_5 ) ; } } 
private static boolean METHOD_1 ( TYPE_1 token ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( token , TYPE_5 . VAR_3 , TYPE_5 . VAR_4 , TYPE_5 . VAR_5 , TYPE_5 . VAR_6 , TYPE_5 . VAR_7 ) ; <START> <END> TYPE_2 VAR_8 = METHOD_3 ( VAR_1 ) ; return VAR_8 != null && ( ( TYPE_4 ) VAR_8 ) . METHOD_4 ( ( TYPE_4 ) token ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! METHOD_2 ( VAR_1 ) || METHOD_3 ( METHOD_4 ( VAR_1 ) ) ) { <END> METHOD_5 ( VAR_1 , VAR_2 ) ; } } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . is ( TYPE_5 . VAR_3 ) ) { TYPE_2 VAR_4 = ( TYPE_2 ) VAR_1 ; TYPE_3 VAR_5 = VAR_4 . name ( ) ; if ( VAR_5 . is ( TYPE_5 . VAR_6 ) ) { String name = ( ( TYPE_4 ) VAR_5 ) . name ( ) ; <START> if ( STRING_1 . equals ( name ) ) { <END> return true ; } } } return false ; } 
<START> public String METHOD_1 ( ) throws IOException { <END> return VAR_1 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_1 . class ) ; TYPE_2 VAR_2 = new TYPE_3 ( new TYPE_4 ( STRING_1 ) ) ; <START> METHOD_3 ( ) . METHOD_4 ( context , ImmutableList . of ( ( TYPE_5 ) VAR_2 ) , ImmutableList . of ( new TYPE_6 ( METHOD_5 ( STRING_2 ) ) ) , VAR_3 ) ; <END> assertThat ( context . VAR_4 ( ) ) . METHOD_6 ( 1 ) ; } 
public synchronized void METHOD_1 ( Iterator < TYPE_1 > VAR_1 , File file ) { while ( VAR_1 . hasNext ( ) ) { TYPE_1 VAR_2 = VAR_1 . next ( ) ; TYPE_2 entry = TYPE_2 . from ( VAR_2 , file ) ; if ( VAR_3 . METHOD_2 ( entry ) ) { <START> continue ; <END> } output . VAR_4 ( entry . VAR_5 ( ) ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( this . equals ( VAR_2 ) ) { return true ; } <START> if ( VAR_2 instanceof TYPE_1 ) { <END> return this . METHOD_1 ( ( TYPE_1 ) VAR_2 ) ; } return false ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , ANNOTATION_1 TYPE_2 VAR_2 ) { if ( METHOD_2 ( VAR_2 ) ) { return false ; } TYPE_3 VAR_3 = TYPE_4 . METHOD_3 ( VAR_1 ) ; Map < TYPE_5 , TYPE_6 > VAR_4 = METHOD_4 ( VAR_3 ) ; if ( METHOD_5 ( VAR_1 , VAR_3 ) ) { return false ; } <START> if ( VAR_2 != null && METHOD_6 ( VAR_2 , ( TYPE_2 ) VAR_1 , VAR_4 ) ) { <END> return false ; } else { return true ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 target ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 . line ( ) ) ; if ( VAR_2 . METHOD_2 ( target . line ( ) ) ) { METHOD_3 ( new TYPE_3 ( this , new TYPE_4 ( VAR_1 , STRING_1 ) ) ) ; } <START> if ( VAR_2 . METHOD_4 ( target . line ( ) ) ) { <END> METHOD_3 ( new TYPE_3 ( this , new TYPE_4 ( VAR_1 , STRING_2 + target . line ( ) + STRING_3 ) ) ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 element ) { if ( element . is ( TYPE_5 . VAR_3 ) ) { TYPE_3 VAR_4 = ( TYPE_3 ) element ; if ( METHOD_2 ( VAR_1 ) && TYPE_4 . contains ( VAR_4 . METHOD_3 ( ) . name ( ) ) ) { METHOD_4 ( VAR_4 , 0 ) ; } <START> if ( METHOD_5 ( VAR_4 , VAR_1 ) ) { <END> METHOD_4 ( VAR_4 , 1 ) ; } } } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 < TYPE_1 > VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . clear ( ) ; <START> super . METHOD_1 ( VAR_1 ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , Type VAR_3 , Type VAR_4 , TYPE_2 VAR_5 ) { if ( VAR_3 != Type . VAR_6 && VAR_4 != Type . VAR_6 ) { if ( VAR_3 == Type . VAR_7 && TYPE_3 . contains ( VAR_4 ) ) { METHOD_2 ( VAR_2 , VAR_1 , VAR_5 ) ; } if ( VAR_4 == Type . VAR_7 && TYPE_3 . contains ( VAR_3 ) ) { <START> METHOD_2 ( VAR_1 , VAR_1 , VAR_5 ) ; <END> } } } 
public List < TYPE_1 > METHOD_1 ( TYPE_1 state , TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = state . VAR_3 ( this , VAR_1 ) ; if ( VAR_2 == null ) { return ImmutableList . of ( ) ; } if ( VAR_1 . METHOD_2 ( TYPE_2 . VAR_4 ) ) { return METHOD_3 ( VAR_2 , VAR_5 ) ; } else if ( VAR_1 . METHOD_2 ( TYPE_2 . VAR_6 ) ) { return METHOD_3 ( VAR_2 , VAR_5 . METHOD_4 ( ) ) ; } <START> return ImmutableList . of ( state ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( TYPE_1 state , TYPE_2 VAR_1 ) { if ( VAR_1 . METHOD_2 ( TYPE_2 . VAR_2 ) ) { return VAR_3 . METHOD_1 ( state , VAR_4 ) ; } else if ( VAR_1 . METHOD_2 ( TYPE_2 . VAR_5 ) ) { return VAR_3 . METHOD_1 ( state , VAR_4 . METHOD_3 ( ) ) ; } <START> return ImmutableList . of ( state ) ; <END> } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 . is ( TYPE_5 . VAR_3 , TYPE_5 . VAR_4 ) ) { TYPE_2 VAR_5 = ( TYPE_2 ) VAR_1 ; return TYPE_3 . get ( VAR_5 . METHOD_2 ( ) ) . METHOD_3 ( ) . METHOD_4 ( ) . equals ( TYPE_4 . VAR_7 ) || TYPE_3 . get ( VAR_5 . METHOD_5 ( ) ) . METHOD_3 ( ) . METHOD_4 ( ) . equals ( TYPE_4 . VAR_7 ) ; } return false ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( this == VAR_1 ) { <END> return VAR_2 ; } else if ( this == VAR_2 ) { return VAR_1 ; } else { return VAR_3 ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 = new TYPE_2 ( ) ; <END> super . METHOD_1 ( VAR_1 ) ; METHOD_2 ( ) ; } 
private static String METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . object ( ) != null ) { <END> if ( VAR_1 . object ( ) . is ( TYPE_5 . TYPE_4 . VAR_4 ) ) { TYPE_2 VAR_5 = ( TYPE_2 ) VAR_1 . object ( ) ; return VAR_5 . METHOD_2 ( ) . name ( ) ; } else { return TYPE_3 . METHOD_3 ( VAR_1 . object ( ) ) ; } } return "" ; } 
public void METHOD_1 ( TYPE_1 context ) { super . METHOD_1 ( context ) ; TYPE_2 VAR_1 = null ; <START> try { <END> VAR_1 = new TYPE_2 ( METHOD_2 ( ) . METHOD_3 ( ) , STRING_1 ) ; if ( ! METHOD_4 ( VAR_1 ) ) { METHOD_2 ( ) . METHOD_5 ( this , STRING_2 ) ; } } catch ( IOException e ) { LOG . error ( STRING_3 , METHOD_2 ( ) . METHOD_3 ( ) . getName ( ) , e ) ; } finally { TYPE_3 . METHOD_6 ( VAR_1 ) ; } } 
public int METHOD_1 ( ) { int result = super . METHOD_1 ( ) ; result = INT_1 * result + VAR_1 . METHOD_1 ( ) ; <START> result = INT_1 * result + new Double ( VAR_2 . METHOD_2 ( ) ) . METHOD_1 ( ) ; <END> return result ; } 
public int METHOD_1 ( ) { int result ; long VAR_1 ; <START> VAR_1 = Double . VAR_2 ( VAR_3 ) ; <END> result = ( int ) ( VAR_1 ^ ( VAR_1 > > > INT_1 ) ) ; return result ; } 
public final void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 , final TYPE_3 VAR_3 ) { final TYPE_3 VAR_4 = METHOD_2 ( VAR_3 ) ; final double VAR_5 = VAR_3 . METHOD_3 ( ) ; final TYPE_4 task = new TYPE_4 ( VAR_2 , VAR_5 , VAR_4 , this . VAR_6 , VAR_1 ) ; <START> this . VAR_7 = this . VAR_8 . METHOD_4 ( task ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { <START> if ( null == VAR_1 ) <END> log . debug ( STRING_1 ) ; this . VAR_1 = VAR_1 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { String VAR_2 = VAR_1 . METHOD_2 ( VAR_3 , VAR_4 ) ; VAR_5 = TYPE_2 . get ( VAR_2 ) ; LOGGER . info ( STRING_1 , VAR_2 ) ; <START> if ( ! TYPE_3 . METHOD_3 ( VAR_5 ) ) { <END> TYPE_3 . METHOD_4 ( VAR_5 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> LOGGER . info ( STRING_1 ) ; <END> for ( TYPE_2 VAR_2 : TYPE_4 . VAR_4 . METHOD_2 ( ) ) { ( ( TYPE_3 ) VAR_2 ) . METHOD_3 ( true ) ; LOGGER . info ( STRING_2 ) ; } } 
public boolean METHOD_1 ( TYPE_1 msg ) { if ( VAR_1 == 0 ) { try { VAR_2 . put ( msg ) ; } catch ( InterruptedException e ) { return false ; } return true ; } <START> return VAR_2 . METHOD_1 ( msg ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { VAR_2 = VAR_1 . METHOD_2 ( VAR_3 ) ; <START> VAR_4 = VAR_1 . getString ( STRING_1 , "" ) ; <END> VAR_5 = VAR_1 . getString ( STRING_2 , "" ) ; } super . METHOD_1 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { this . METHOD_2 ( 0 ) ; this . METHOD_3 ( 0 ) ; this . METHOD_4 ( 0 ) ; <START> return this ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 ) { super ( true ) ; this . METHOD_1 ( "" ) ; this . VAR_2 = VAR_2 ; this . VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_3 . METHOD_1 ( this . VAR_2 . METHOD_2 ( ) . METHOD_4 ( ) ) ; this . add ( VAR_3 ) ; METHOD_5 ( ) ; <START> VAR_3 . METHOD_6 ( ) . METHOD_7 ( ) . METHOD_8 ( STRING_1 , STRING_2 ) ; <END> VAR_3 . METHOD_6 ( ) . METHOD_7 ( ) . METHOD_8 ( STRING_3 , STRING_4 ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 , String VAR_3 , boolean VAR_4 , int VAR_5 ) { <START> this ( VAR_2 , VAR_3 , VAR_4 , TYPE_3 . VAR_7 , "" ) ; <END> } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( STRING_1 ) ; <END> } 
public float METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 c : VAR_2 ) { if ( c . VAR_1 == VAR_1 ) { return METHOD_2 ( c ) ; } } <START> return - 1 ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> final TYPE_1 < TYPE_2 > VAR_1 = new TYPE_1 < TYPE_2 > ( false , 2 ) ; <END> VAR_1 . add ( this . VAR_2 ) ; VAR_1 . add ( this . VAR_3 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_2 . VAR_2 . METHOD_2 ( VAR_3 . VAR_4 ) ; VAR_5 . METHOD_3 ( ) ; VAR_5 . METHOD_4 ( ) ; <START> TYPE_1 . METHOD_5 ( VAR_5 ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 . get ( VAR_2 ) != null ) <END> return VAR_1 . get ( VAR_2 ) ; else { return new TYPE_1 ( ) { @Override public void METHOD_2 ( TYPE_2 VAR_3 ) { } @Override public float METHOD_3 ( ) { return 0 ; } @Override public float METHOD_4 ( ) { return 0 ; } @Override public void METHOD_5 ( Object VAR_4 ) { } public float METHOD_6 ( ) { return 0 ; } } ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 action = VAR_1 . METHOD_2 ( ) ; for ( String VAR_2 : VAR_1 . METHOD_3 ( ) ) { TYPE_3 VAR_3 = VAR_4 . METHOD_4 ( ) . METHOD_5 ( ) ; TYPE_4 < TYPE_5 > VAR_5 = VAR_3 . METHOD_6 ( VAR_2 ) ; <START> if ( VAR_5 != null ) { <END> for ( TYPE_5 VAR_6 : VAR_5 ) { VAR_6 . METHOD_7 ( action ) ; } } } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 . METHOD_2 ( ) ) { METHOD_3 ( VAR_2 ) ; } <START> VAR_3 . clear ( ) ; <END> METHOD_4 ( this ) ; } 
protected boolean METHOD_1 ( float VAR_1 ) { <START> return VAR_2 ; <END> } 
private Boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> if ( ! VAR_1 . equals ( VAR_2 ) ) { return false ; } else { return true ; } <END> } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_2 = VAR_4 . METHOD_2 ( VAR_1 ) ; } return TYPE_3 . METHOD_3 ( VAR_2 ) ; } 
public void METHOD_1 ( String user ) { String VAR_1 = STRING_1 + VAR_2 + STRING_2 + VAR_3 . VAR_4 + STRING_3 + VAR_3 . VAR_5 + STRING_4 ; if ( user != null ) { try ( TYPE_1 VAR_6 = VAR_7 . METHOD_2 ( VAR_1 ) ) { VAR_6 . METHOD_3 ( 1 , 0 ) ; VAR_6 . METHOD_4 ( 2 , user ) ; VAR_6 . METHOD_5 ( ) ; } catch ( TYPE_2 ex ) { METHOD_6 ( ex ) ; } } <START> } <END> 
private String METHOD_1 ( String VAR_1 ) { String [ ] VAR_2 = VAR_1 . split ( STRING_1 ) ; int VAR_3 = VAR_2 [ 0 ] . length ( ) / 3 + 1 ; int VAR_4 = VAR_2 [ 1 ] . length ( ) / 3 + 1 ; String id = VAR_2 [ 0 ] . substring ( 0 , VAR_3 ) + STRING_2 ; <START> String VAR_5 = STRING_3 + VAR_2 [ 1 ] . substring ( VAR_4 ) ; <END> return id + STRING_1 + VAR_5 ; } 
public void METHOD_1 ( TYPE_1 state ) { TYPE_2 . METHOD_2 ( state , this ) ; VAR_1 . forEach ( it - > { VAR_2 . put ( it , new TYPE_3 ( true ) ) ; } ) ; VAR_3 . forEach ( it - > { VAR_2 . put ( it , new TYPE_3 ( false ) ) ; <START> } ) ; <END> } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 source , ANNOTATION_1 TYPE_2 file ) { if ( ! VAR_1 . METHOD_2 ( ) ) { return ; } TYPE_3 m = TYPE_4 . METHOD_3 ( file , VAR_2 ) ; if ( m == null || ! TYPE_5 . METHOD_4 ( file , m ) ) { return ; } VAR_3 . METHOD_5 ( m , Collections . VAR_4 ( file ) , TYPE_6 . VAR_6 ) ; <START> VAR_7 . METHOD_6 ( Collections . VAR_4 ( file ) ) ; <END> } 
@Override public boolean value ( TYPE_1 VAR_1 ) { <START> return VAR_2 . contains ( VAR_1 ) ; <END> } 
public String METHOD_1 ( ) { return VAR_1 == null <START> ? Integer . valueOf ( VAR_2 ) . toString ( ) <END> : VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { <START> if ( null == VAR_1 || null == VAR_2 ) { <END> return new TYPE_1 ( ) { @Override public TYPE_2 METHOD_2 ( ) { return new TYPE_3 ( VAR_2 , VAR_1 ) ; } @Override public void METHOD_3 ( ) { } } ; } return new TYPE_4 ( ) ; } 
<START> public Boolean METHOD_1 ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 , STRING_2 , null ) ; <END> String VAR_2 = VAR_1 . METHOD_2 ( ) ; assertThat ( VAR_2 ) . METHOD_3 ( STRING_3 ) ; } 
public String METHOD_1 ( ) { <START> return name ( ) . METHOD_2 ( TYPE_1 . VAR_2 ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 props = new TYPE_1 ( ) ; props . VAR_1 ( STRING_1 , STRING_2 ) ; props . VAR_1 ( STRING_3 , TYPE_2 . class . METHOD_2 ( ) ) ; props . VAR_1 ( STRING_4 , new File ( configuration . VAR_2 ( ) , STRING_5 ) . getPath ( ) ) ; <START> props . VAR_1 ( STRING_6 , STRING_7 ) ; <END> return props ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 ) ; <END> page = new TYPE_1 ( VAR_2 , configuration ) { @Override public String METHOD_3 ( ) { return StringUtils . VAR_3 ; } } ; VAR_4 . METHOD_4 ( TYPE_2 . class ) ; TYPE_3 . METHOD_5 ( page , STRING_1 ) ; } 
public boolean METHOD_1 ( ) { <START> if ( System . currentTimeMillis ( ) < this . VAR_1 ) { <END> return true ; } return false ; } 
private long METHOD_1 ( String key ) { long VAR_1 = INT_1 ; <START> if ( key . equals ( Constants . VAR_2 ) ) { <END> VAR_1 = this . VAR_3 . METHOD_2 ( key , Constants . VAR_4 ) ; } else if ( key . equals ( Constants . VAR_5 ) ) { VAR_1 = this . VAR_3 . METHOD_2 ( key , Constants . VAR_6 ) ; } if ( VAR_1 == INT_1 ) { throw new TYPE_1 ( STRING_1 + key + STRING_2 ) ; } return VAR_1 ; } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . get ( VAR_3 ) ; <START> if ( VAR_2 == null ) { <END> VAR_2 = VAR_1 . get ( VAR_4 ) ; } int VAR_5 = VAR_2 . METHOD_2 ( CHAR_1 ) ; if ( VAR_5 > - 1 ) { VAR_2 = VAR_2 . substring ( 0 , VAR_5 ) ; } String cluster = TYPE_2 . METHOD_3 ( VAR_2 ) ; return cluster != null ? cluster : null ; } 
private TYPE_1 METHOD_1 ( Long VAR_1 , TYPE_2 VAR_2 ) { <START> TYPE_3 VAR_3 = new TYPE_3 ( ) ; <END> TYPE_1 VAR_4 = new TYPE_1 ( VAR_3 . METHOD_2 ( VAR_2 ) ) ; VAR_4 . add ( Constants . VAR_5 , Constants . VAR_6 , TYPE_4 . METHOD_2 ( VAR_1 ) ) ; return VAR_4 ; } 
public void parse ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 { try { VAR_3 = new TYPE_4 ( VAR_2 ) ; TYPE_5 . METHOD_1 ( VAR_1 , VAR_3 ) ; } catch ( IOException VAR_4 ) { LOG . error ( STRING_1 + VAR_4 . getMessage ( ) ) ; <START> LOG . error ( VAR_4 . METHOD_2 ( ) ) ; <END> throw new TYPE_3 ( STRING_2 + STRING_3 + VAR_2 + STRING_4 + VAR_4 . getMessage ( ) ) ; } } 
public void parse ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 { try { VAR_3 = new TYPE_4 ( VAR_2 ) ; TYPE_5 . METHOD_1 ( VAR_1 , VAR_3 ) ; } catch ( IOException VAR_4 ) { LOG . error ( STRING_1 , VAR_4 ) ; throw new TYPE_3 ( STRING_2 + STRING_3 + VAR_2 <START> + STRING_4 + VAR_4 . getMessage ( ) ) ; <END> } } 
<START> public Map < String , TYPE_1 > METHOD_1 ( final String key ) { <END> final TYPE_2 VAR_1 = TYPE_3 . get ( TYPE_2 . class ) ; final TYPE_4 cache = VAR_1 . METHOD_2 ( ) ; return cache . VAR_2 ( key ) ; } 
<START> public TYPE_2 ( final boolean VAR_2 , final long VAR_3 , <END> final long VAR_4 ) { if ( ! VAR_2 ) { logger . info ( VAR_5 ) ; } this . config = new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 , Boolean . VAR_6 ) ; } 
@Override public TYPE_1 METHOD_1 ( String VAR_1 , Object message ) { <START> return new TYPE_2 ( VAR_1 , message + this . getMessage ( ) ) ; <END> } 
public TYPE_3 ( int VAR_2 , boolean VAR_3 , boolean VAR_4 ) { VAR_5 = new TYPE_1 < TYPE_2 > ( ) { @Override protected TYPE_2 METHOD_1 ( ) { int VAR_6 = VAR_2 / VAR_7 ; if ( VAR_6 % VAR_7 != 0 ) { <START> VAR_6 ++ ; <END> } return new TYPE_2 ( VAR_6 , VAR_3 , VAR_4 ) ; } } ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( 1 , true , true , 1 ) ; ByteBuffer VAR_2 = VAR_1 . METHOD_2 ( ) ; Assert . assertEquals ( VAR_1 . METHOD_3 ( ) , 0 ) ; ByteBuffer VAR_3 = VAR_1 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_4 ( VAR_2 ) ; <END> VAR_1 . METHOD_4 ( VAR_3 ) ; } 
List < String > METHOD_1 ( ) { <START> final ImmutableList . Builder < String > builder = new ImmutableList . Builder < > ( ) ; <END> return builder . addAll ( VAR_1 ) . addAll ( VAR_2 ) . addAll ( VAR_3 ) . build ( ) ; } 
public void METHOD_1 ( Path path , byte [ ] data , TYPE_1 < Long > VAR_1 ) { TYPE_2 file = getPath ( path ) ; <START> TYPE_3 < Long > VAR_2 = VAR_3 - > VAR_1 . METHOD_2 ( VAR_3 ) ; <END> file . VAR_4 ( TYPE_4 . build ( data ) , 0 , data . length , VAR_5 . VAR_6 , VAR_5 . VAR_7 , VAR_2 ) . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) throws Throwable { <START> if ( true ) throw new RuntimeException ( ) ; <END> byte [ ] VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 ) ; try { TYPE_2 . METHOD_3 ( VAR_1 ) ; Assert . VAR_2 ( STRING_2 ) ; } catch ( RuntimeException e ) { } } 
public byte [ ] read ( Path path , TYPE_1 < Long , Long > VAR_1 ) { Path VAR_2 = METHOD_1 ( path ) ; METHOD_2 ( path , TYPE_3 . VAR_4 ) ; if ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) { <START> return null ; <END> } try { return TYPE_2 . METHOD_5 ( VAR_2 ) ; } catch ( IOException VAR_5 ) { throw new IllegalStateException ( VAR_5 ) ; } } 
private TYPE_1 < Boolean > METHOD_1 ( TYPE_2 file , Set < String > VAR_1 , TYPE_4 . TYPE_5 VAR_2 ) { return file . getPath ( VAR_3 ) . METHOD_2 ( path - > { <START> VAR_3 . VAR_4 . METHOD_3 ( VAR_2 , file . VAR_5 ( ) . VAR_6 , VAR_1 ) ; <END> TYPE_1 < Boolean > res = new TYPE_1 < > ( ) ; res . VAR_7 ( true ) ; return res ; } ) ; } 
public TYPE_1 < Integer > METHOD_1 ( byte [ ] res , int offset , int length ) { try { System . VAR_1 ( data , index , res , offset , length ) ; } catch ( TYPE_2 e ) { <START> System . out . println ( ) ; <END> } index += length ; return TYPE_1 . METHOD_2 ( length ) ; } 
private void METHOD_1 ( byte [ ] input ) throws IOException { VAR_1 . METHOD_2 ( input ) ; byte [ ] [ ] split = VAR_2 . split ( input ) ; for ( byte [ ] VAR_3 : split ) { int length = VAR_3 . length ; <START> assertTrue ( length >= 0 ) ; <END> assertTrue ( length <= TYPE_1 . VAR_5 ) ; } byte [ ] VAR_6 = VAR_2 . METHOD_3 ( split , input . length ) ; assertTrue ( STRING_1 , Arrays . equals ( input , VAR_6 ) ) ; } 
<START> private static Object METHOD_1 ( String key , TYPE_1 VAR_1 ) { <END> Map < String , Object > VAR_2 = new TYPE_2 < > ( ) ; VAR_2 . put ( key , VAR_1 . toString ( ) ) ; return VAR_2 ; } 
public static int METHOD_1 ( byte [ ] a , byte [ ] b ) { <START> for ( int i = 0 ; i < Math . VAR_1 ( a . length , b . length ) ; i ++ ) <END> if ( a [ i ] != b [ i ] ) return a [ i ] & INT_1 - b [ i ] & INT_1 ; return 0 ; } 
public int METHOD_1 ( long id ) { <START> return VAR_1 . METHOD_2 ( id ) ; <END> } 
<START> public org . VAR_1 . VAR_2 . TYPE_2 METHOD_1 ( ) throws IOException { <END> return TYPE_1 . create ( VAR_4 ) ; } 
private TYPE_4 ( final TYPE_1 VAR_2 ) { VAR_3 = VAR_2 . METHOD_1 ( ) ; VAR_4 = TYPE_2 . create ( ) ; VAR_5 = VAR_2 ; VAR_6 = TYPE_3 <START> . METHOD_2 ( VAR_7 . METHOD_3 ( ) . getInstance ( ) , VAR_7 . METHOD_3 ( ) . METHOD_4 ( ) ) . METHOD_5 ( ) ; <END> } 
private TYPE_7 ( final TYPE_1 < TYPE_2 , TYPE_3 > cache , final TYPE_2 key , final TYPE_4 VAR_2 ) { super ( VAR_2 ) ; VAR_3 = cache ; VAR_4 = key ; <START> TYPE_5 <END> . get ( ) . METHOD_1 ( this , TYPE_6 . METHOD_2 ( new Exception ( ) ) ) ; } 
public void close ( ) throws IOException { final TYPE_1 VAR_1 = VAR_2 . METHOD_1 ( TYPE_1 . VAR_3 ) ; TYPE_2 . METHOD_2 ( VAR_1 == TYPE_1 . VAR_4 , STRING_1 , this , VAR_1 ) ; VAR_5 . close ( ) ; try { <START> VAR_6 . METHOD_3 ( ) . METHOD_4 ( ) ; <END> } catch ( Exception e ) { TYPE_3 . METHOD_5 ( e ) ; } VAR_7 . METHOD_6 ( ) ; } 
public TYPE_1 < T > next ( ) { TYPE_2 VAR_1 = VAR_2 . next ( ) ; VAR_3 += 1 ; try { return new TYPE_1 < T > ( VAR_4 , VAR_5 , VAR_1 . METHOD_1 ( ) , VAR_6 . METHOD_2 ( VAR_1 . getValue ( ) ) ) ; } catch ( IOException ex ) { <START> throw new TYPE_3 ( ex . getMessage ( ) ) ; <END> } } 
public boolean equals ( Object obj ) { <START> return TYPE_1 . class . equals ( obj . getClass ( ) ) ; <END> } 
<START> private TYPE_1 METHOD_1 ( ) { <END> return new TYPE_2 ( ) { @Override protected void METHOD_2 ( ) { bind ( TYPE_3 . class ) . to ( TYPE_4 . class ) ; bind ( TYPE_5 . class ) ; } } ; } 
public Collection < TYPE_1 > METHOD_1 ( ) { <START> final ArrayList < TYPE_1 > list = new ArrayList < > ( ) ; <END> return list ; } 
public static < T extends Collection < TYPE_1 > , TYPE_1 > T METHOD_1 ( final TYPE_2 < ? extends TYPE_2 < ? > > VAR_1 , final T VAR_2 ) { Iterator < ? extends TYPE_2 < ? > > iterator = VAR_1 . iterator ( ) ; <START> if ( ! iterator . hasNext ( ) ) { <END> return VAR_2 ; } while ( iterator . hasNext ( ) ) { METHOD_2 ( iterator . next ( ) , VAR_2 ) ; } return VAR_2 ; } 
<START> protected TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 ) { <END> return new TYPE_1 ( ) { @Override public void METHOD_2 ( ) throws Throwable { try { VAR_1 . METHOD_2 ( ) ; } finally { Thread . VAR_2 ( ) ; } } } ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 . remove ( 2 ) ; <END> METHOD_2 ( VAR_1 . contains ( 3 ) ) ; } 
private static boolean METHOD_1 ( Throwable exception ) { <START> if ( VAR_1 != null ) { <END> try { Throwable [ ] VAR_2 = ( Throwable [ ] ) VAR_1 . METHOD_2 ( exception ) ; return VAR_2 . length != 0 ; } catch ( Throwable e ) { return false ; } } else { return false ; } } 
public static < T > T METHOD_1 ( T value , String message ) { if ( value == null ) { <START> throw new TYPE_1 ( String . valueOf ( message ) ) ; <END> } return value ; } 
<START> public boolean METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; } 
<START> protected void METHOD_1 ( ) throws Exception { <END> } 
public void METHOD_1 ( ) { try { <START> METHOD_2 ( null ) ; <END> METHOD_3 ( STRING_1 ) ; } catch ( TYPE_1 e ) { } } 
public void METHOD_1 ( ) throws Exception { <START> LOG . clear ( ) ; <END> METHOD_2 ( TYPE_1 . class ) ; List < String > VAR_1 = asList ( STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 ) ; assertEquals ( VAR_1 , LOG ) ; } 
public void METHOD_1 ( ) { try { <START> Object [ ] VAR_1 = { 1 , 2 , null } ; <END> METHOD_2 ( VAR_1 ) ; METHOD_3 ( STRING_1 ) ; } catch ( TYPE_1 e ) { } } 
<START> protected void METHOD_1 ( ) throws Throwable { <END> } 
<START> Builder METHOD_1 ( File VAR_1 ) { <END> this . VAR_1 = VAR_1 ; return this ; } 
protected boolean METHOD_1 ( ) { boolean result = true ; if ( VAR_1 != null ) { result = METHOD_2 ( VAR_1 ) ; } <START> return result ; <END> } 
public void METHOD_1 ( ) { TYPE_1 result = METHOD_2 ( TYPE_2 . class ) ; assertThat ( result , METHOD_3 ( 1 ) ) ; <START> assertThat ( result . toString ( ) , TYPE_3 . METHOD_4 ( STRING_1 ) ) ; <END> } 
<START> private Builder ( ) { <END> } 
public TYPE_2 ( String VAR_2 , boolean VAR_3 , Object value , TYPE_1 < ? > matcher ) { <START> if ( value instanceof Throwable ) { <END> METHOD_1 ( ( Throwable ) value ) ; } this . VAR_2 = VAR_2 ; this . value = value ; this . matcher = matcher ; this . VAR_3 = VAR_3 ; } 
private void METHOD_1 ( String VAR_1 ) throws IOException { File VAR_2 = new File ( VAR_1 ) ; <START> if ( VAR_2 != null && VAR_2 . METHOD_2 ( ) != null ) { <END> String VAR_3 = STRING_1 + STRING_2 ; throw new IOException ( VAR_3 ) ; } } 
<START> public File METHOD_1 ( String VAR_1 ) throws IOException , IllegalArgumentException { <END> return METHOD_1 ( new String [ ] { VAR_1 } ) ; } 
<START> public static void assertEquals ( String message , TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <END> Assert . assertEquals ( message , VAR_1 , VAR_2 ) ; } 
TYPE_1 build ( ) { <START> return new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 ) ; <END> } 
private static void METHOD_1 ( String message , Object VAR_1 , Object VAR_2 , TYPE_1 VAR_3 ) { String VAR_4 = message == null ? "" : message + STRING_1 ; if ( METHOD_2 ( VAR_4 , VAR_1 , VAR_2 ) ) { return ; } <START> METHOD_3 ( VAR_4 , VAR_3 ) ; <END> } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 description = TYPE_1 . METHOD_2 ( STRING_1 , VAR_1 ) ; assertNotNull ( STRING_2 , description . VAR_2 ( ) ) ; assertEquals ( description . VAR_2 ( ) , VAR_1 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 . class ) ; VAR_1 . run ( VAR_2 ) ; assertEquals ( 1 , VAR_2 . METHOD_2 ( ) ) ; <START> assertNotNull ( VAR_2 ) ; <END> } 
<START> private String METHOD_1 ( ) { <END> return METHOD_2 ( VAR_1 ) ; } 
private String METHOD_1 ( ) { <START> if ( VAR_1 . length ( ) > VAR_2 ) { <END> return VAR_3 + VAR_1 . substring ( VAR_1 . length ( ) - VAR_2 ) ; } return VAR_1 ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . size ( ) == 0 ; <END> } 
public void METHOD_1 ( final TYPE_1 VAR_1 , TYPE_2 p ) { try { p . VAR_2 ( ) ; } catch ( TYPE_3 e ) { METHOD_2 ( VAR_1 , e ) ; } catch ( TYPE_4 e ) { throw e ; <START> } catch ( Throwable t ) { <END> METHOD_3 ( VAR_1 , t ) ; } } 
static public void assertEquals ( String message , double VAR_1 , double VAR_2 , double VAR_3 ) { if ( Double . VAR_4 ( VAR_1 , VAR_2 ) == 0 ) { return ; } if ( ! ( Math . VAR_5 ( VAR_1 - VAR_2 ) <= VAR_3 ) ) { <START> METHOD_1 ( message , Double . valueOf ( VAR_1 ) , Double . valueOf ( VAR_2 ) ) ; <END> } } 
static public void assertEquals ( String message , float VAR_1 , float VAR_2 , float VAR_3 ) { if ( TYPE_1 . METHOD_1 ( VAR_1 , VAR_2 ) == 0 ) { return ; } if ( ! ( Math . VAR_4 ( VAR_1 - VAR_2 ) <= VAR_3 ) ) { <START> METHOD_2 ( message , TYPE_1 . valueOf ( VAR_1 ) , TYPE_1 . valueOf ( VAR_2 ) ) ; <END> } } 
public TYPE_1 METHOD_1 ( Class < ? > VAR_1 ) throws Exception { for ( Class < ? > VAR_2 = VAR_1 ; VAR_2 != null ; VAR_2 = METHOD_2 ( VAR_2 ) ) { TYPE_2 VAR_3 = VAR_2 . METHOD_3 ( TYPE_2 . class ) ; if ( VAR_3 != null ) { <START> return METHOD_4 ( VAR_3 . value ( ) , VAR_2 ) ; <END> } } return null ; } 
private Throwable METHOD_1 ( Thread VAR_1 ) { List < Throwable > VAR_2 = new ArrayList < Throwable > ( ) ; VAR_2 . add ( METHOD_2 ( VAR_1 ) ) ; VAR_2 . addAll ( METHOD_3 ( VAR_1 ) ) ; <START> return VAR_2 . size ( ) == 1 ? VAR_2 . get ( 0 ) : new TYPE_1 ( VAR_2 ) ; <END> } 
private static TYPE_1 METHOD_1 ( Class < ? > VAR_1 ) throws TYPE_2 , TYPE_3 { TYPE_4 VAR_2 = VAR_1 . METHOD_2 ( TYPE_4 . class ) ; if ( VAR_2 == null ) { return VAR_3 ; } else { Class < ? extends TYPE_1 > VAR_4 = VAR_2 . value ( ) ; <START> return VAR_4 . METHOD_3 ( ) ; <END> } } 
public boolean equals ( Object obj ) { <START> if ( this == obj ) <END> return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( VAR_2 == null ) return VAR_1 . VAR_2 == null ; else return VAR_2 . equals ( VAR_1 . VAR_2 ) ; } 
public String toString ( ) { <START> return VAR_1 . getName ( ) + STRING_1 + VAR_2 + STRING_2 <END> + Arrays . toString ( VAR_3 ) ; } 
public int METHOD_1 ( ) { int VAR_1 = INT_1 ; <START> int result = VAR_1 + ( ( VAR_2 == null ) ? 0 : VAR_2 . METHOD_1 ( ) ) ; <END> result = VAR_1 * result + VAR_3 . METHOD_1 ( ) ; return VAR_1 * result + VAR_4 . METHOD_1 ( ) ; } 
private boolean METHOD_1 ( ) { for ( T child : METHOD_2 ( ) ) { <START> if ( METHOD_3 ( child ) == false ) { <END> return false ; } } return true ; } 
static public void METHOD_1 ( String message , long VAR_1 , long VAR_2 ) { if ( VAR_1 == VAR_2 ) { <START> METHOD_2 ( message , VAR_2 ) ; <END> } } 
static public void METHOD_1 ( String message , double VAR_1 , double VAR_2 , double VAR_3 ) { if ( ! METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ) { <START> METHOD_3 ( message , VAR_2 ) ; <END> } } 
private TYPE_1 [ ] METHOD_1 ( Thread VAR_1 ) { TYPE_1 [ ] VAR_2 ; try { <START> VAR_2 = VAR_1 . METHOD_1 ( ) ; <END> } catch ( TYPE_2 e ) { VAR_2 = new TYPE_1 [ 0 ] ; } return VAR_2 ; } 
<START> private < T > List < T > METHOD_1 ( Map < Class < ? extends TYPE_1 > , List < T > > map , <END> Class < ? extends TYPE_1 > type , boolean VAR_1 ) { if ( ! map . containsKey ( type ) && VAR_1 ) { map . put ( type , new ArrayList < T > ( ) ) ; } List < T > VAR_2 = map . get ( type ) ; return VAR_2 == null ? TYPE_2 < T > METHOD_2 ( ) : VAR_2 ; } 
public Map < Class < ? extends TYPE_1 > , List < TYPE_2 > > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { <START> exception . VAR_1 ( TYPE_1 . class ) ; <END> TYPE_2 VAR_2 = new TYPE_2 ( TYPE_3 . class ) ; Map < Class < ? extends TYPE_4 > , List < TYPE_5 > > VAR_3 = VAR_2 . METHOD_2 ( ) ; VAR_3 . put ( TYPE_6 . class , null ) ; } 
public void METHOD_1 ( ) { <START> exception . VAR_1 ( TYPE_1 . class ) ; <END> TYPE_2 VAR_2 = new TYPE_2 ( TYPE_3 . class ) ; Map < Class < ? extends TYPE_4 > , List < TYPE_5 > > VAR_3 = VAR_2 . METHOD_2 ( ) ; List < TYPE_5 > VAR_4 = VAR_3 . get ( TYPE_6 . class ) ; VAR_4 . add ( null ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 . class ) ; TYPE_3 d = VAR_1 . METHOD_2 ( ) ; <START> Assert . assertEquals ( 2 , d . VAR_2 ( ) ) ; <END> for ( TYPE_3 VAR_3 : d . VAR_4 ( ) ) { if ( VAR_3 . METHOD_3 ( ) . equals ( STRING_1 ) ) { assertNotNull ( VAR_3 . METHOD_4 ( TYPE_4 . class ) ) ; } else { METHOD_5 ( VAR_3 . METHOD_4 ( TYPE_4 . class ) ) ; } } } 
public boolean METHOD_1 ( final Class < ? > VAR_1 ) { <START> return VAR_2 . contains ( VAR_1 . getName ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 params ) throws TYPE_3 { try { return METHOD_1 ( METHOD_2 ( params . VAR_1 ( ) ) ) ; } catch ( TYPE_4 e ) { <START> throw new TYPE_3 ( e . getMessage ( ) ) ; <END> } } 
public static TYPE_1 METHOD_1 ( TYPE_2 description , String VAR_1 ) throws TYPE_5 . TYPE_6 { if ( VAR_1 . contains ( STRING_1 ) ) { String [ ] VAR_2 = VAR_1 . split ( STRING_1 , 2 ) ; return METHOD_2 ( VAR_2 [ 0 ] , new TYPE_4 ( VAR_2 [ 1 ] ) ) ; } else { <START> return METHOD_2 ( VAR_1 , new TYPE_4 ( ) ) ; <END> } } 
public TYPE_2 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 , boolean VAR_4 ) { <START> this ( VAR_2 , VAR_4 ? VAR_3 . METHOD_1 ( ) : VAR_3 ) ; <END> } 
public void METHOD_1 ( ) { <START> this . VAR_1 . METHOD_2 ( this ) ; <END> } 
public boolean METHOD_1 ( ) { boolean VAR_1 = false ; TYPE_1 . METHOD_2 ( new TYPE_2 ( ) { @Override public void run ( ) { if ( ! VAR_2 . METHOD_3 ( file . VAR_3 ( ) , false ) ) { TYPE_3 . VAR_5 . debug ( STRING_1 , STRING_2 + file ) ; } } } ) ; <START> VAR_1 = true ; <END> return VAR_1 ; } 
public TYPE_1 ( int VAR_2 , int max , int VAR_3 , int value ) { if ( max < VAR_2 ) throw new IllegalArgumentException ( STRING_1 ) ; if ( value < VAR_2 || value > max ) throw new IllegalArgumentException ( STRING_2 ) ; this . VAR_2 = VAR_2 ; this . max = max ; <START> if ( VAR_3 < 0 ) VAR_3 *= - 1 ; <END> this . VAR_3 = VAR_3 ; this . value = value ; } 
public TYPE_2 ( final long type , final TYPE_1 VAR_2 ) { this ( type ) ; <START> VAR_3 . set ( VAR_2 , VAR_2 . METHOD_1 ( ) , VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) , VAR_2 . METHOD_4 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 ) throw new TYPE_2 ( STRING_1 ) ; VAR_1 = true ; builder . VAR_2 ( VAR_3 . METHOD_2 ( ) , VAR_4 . VAR_5 ) ; <START> return builder ; <END> } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; VAR_6 = new TYPE_5 [ METHOD_1 ( ) ] ; VAR_7 = new TYPE_6 [ METHOD_1 ( ) ] ; <START> METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( int n ) { if ( n >= VAR_1 . length ) throw new TYPE_1 ( STRING_1 + n + STRING_2 + getClass ( ) . getName ( ) ) ; VAR_2 = n ; VAR_3 = VAR_4 . iterator ( ) ; <START> VAR_3 . METHOD_2 ( ) ; <END> VAR_5 = VAR_6 . iterator ( ) ; VAR_5 . METHOD_2 ( ) ; VAR_7 = VAR_8 . iterator ( ) ; VAR_7 . METHOD_2 ( ) ; VAR_9 = INT_1 ; VAR_10 [ n ] . METHOD_1 ( ) ; METHOD_3 ( n ) ; } 
public TYPE_1 METHOD_1 ( ) { for ( int i = 0 ; i < VAR_1 . size ; i ++ ) { METHOD_2 ( i ) . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . TYPE_4 , TYPE_3 . TYPE_4 ) ; <START> } <END> return new TYPE_2 ( this , VAR_4 ) ; } 
<START> public TYPE_1 [ ] METHOD_1 ( ) { <END> TYPE_1 [ ] VAR_1 = null ; synchronized ( this . VAR_2 ) { VAR_1 = this . VAR_2 . keySet ( ) . METHOD_2 ( new TYPE_1 [ this . VAR_2 . size ( ) ] ) ; } return VAR_1 ; } 
<START> public boolean METHOD_1 ( ) { <END> assert ! METHOD_2 ( VAR_1 ) ; synchronized ( VAR_1 ) { switch ( state ) { case VAR_2 : { return false ; } case VAR_3 : case VAR_4 : case VAR_5 : case VAR_6 : case VAR_7 : case VAR_8 : case VAR_9 : { return true ; } default : throw new IllegalStateException ( ) ; } } } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> if ( ! VAR_1 ) { logger . debug ( Thread . VAR_2 ( ) . METHOD_2 ( ) . toString ( ) ) ; } this . VAR_1 = VAR_1 ; } 
public static boolean METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 . length ( ) == 0 ) <END> return false ; char VAR_2 = VAR_1 . METHOD_2 ( 0 ) ; return VAR_2 == CHAR_1 || VAR_2 == CHAR_2 ; } 
public String METHOD_1 ( File VAR_1 , List < String > VAR_2 ) throws IOException , InterruptedException { List < String > args = new ArrayList < > ( VAR_2 ) ; <START> args . remove ( STRING_1 ) ; <END> args . add ( STRING_2 ) ; return METHOD_2 ( VAR_1 , new String [ ] { STRING_3 , STRING_4 , STRING_5 } , args ) ; } 
TYPE_2 ( TYPE_1 VAR_2 , Path path , Log logger ) throws IOException { <START> this . VAR_2 = VAR_2 ; <END> this . logger = logger ; this . path = path ; } 
private TYPE_1 ( String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 , Log log ) { this . VAR_2 = StringUtils . VAR_6 ( VAR_2 , STRING_1 ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . log = log ; <START> this . VAR_7 = false ; <END> } 
protected TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 , List < TYPE_3 > VAR_2 ) { TYPE_4 VAR_3 = new TYPE_4 ( ) . id ( VAR_4 ) ; if ( VAR_1 != null ) { VAR_3 . METHOD_2 ( VAR_1 ) ; } if ( VAR_2 != null ) { VAR_3 . METHOD_3 ( VAR_2 ) ; } <START> List < TYPE_5 > VAR_5 = TYPE_6 . METHOD_4 ( VAR_3 . build ( ) ) ; <END> TYPE_1 build = new TYPE_1 ( ) ; build . VAR_6 ( VAR_5 ) ; return build ; } 
<START> public TYPE_1 ( String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 , Log log ) { <END> this . VAR_2 = StringUtils . VAR_6 ( VAR_2 , STRING_1 ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . log = log ; } 
public TYPE_4 ( TYPE_1 VAR_2 , Set < TYPE_2 > VAR_3 , Set < TYPE_3 > VAR_4 ) { <START> this . VAR_2 = new TYPE_1 ( VAR_2 ) ; <END> this . VAR_3 . addAll ( VAR_3 . stream ( ) . map ( TYPE_2 : : new ) . collect ( Collectors . VAR_5 ( ) ) ) ; this . VAR_4 . addAll ( VAR_4 . stream ( ) . map ( TYPE_3 : : new ) . collect ( Collectors . VAR_5 ( ) ) ) ; } 
public void run ( ) { try { output = TYPE_1 . toString ( VAR_1 , TYPE_4 . TYPE_5 . name ( ) ) ; } catch ( IOException e ) { <START> output = TYPE_3 . METHOD_1 ( e ) ; <END> } } 
public void METHOD_1 ( ) { File VAR_1 = new File ( STRING_1 ) ; TYPE_1 parser = new TYPE_1 ( ) . METHOD_2 ( true ) ; String [ ] VAR_2 = parser . VAR_3 ( VAR_1 ) ; <START> VAR_4 . METHOD_3 ( STRING_2 , STRING_3 ) <END> . METHOD_4 ( VAR_2 ) . METHOD_5 ( VAR_1 , parser ) . commit ( ) ; METHOD_6 ( VAR_4 . METHOD_7 ( STRING_4 ) ) ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = METHOD_2 ( ) ; VAR_1 . start ( ) ; String VAR_2 = "" ; File file = new File ( VAR_3 . METHOD_3 ( ) , STRING_1 ) ; TYPE_2 . write ( VAR_2 , file , VAR_4 ) ; ANNOTATION_1 ( STRING_2 ) <START> List < String > results = VAR_1 . METHOD_4 ( VAR_4 , TYPE_3 . get ( file . VAR_5 ( ) ) , STRING_3 , STRING_4 ) ; <END> } 
public String METHOD_1 ( String VAR_1 ) { <START> return METHOD_2 ( VAR_1 ) ; <END> } 
<START> public List < TYPE_1 > METHOD_1 ( TYPE_2 sess , TYPE_3 VAR_1 ) throws TYPE_4 { <END> return METHOD_2 ( ) . METHOD_1 ( sess , VAR_1 ) ; } 
<START> public List < TYPE_1 > METHOD_1 ( TYPE_2 sess , TYPE_3 VAR_1 , String VAR_2 , boolean VAR_3 ) throws TYPE_4 { <END> return METHOD_2 ( ) . METHOD_1 ( sess , VAR_1 , VAR_2 , VAR_3 ) ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 sess ) throws TYPE_3 , TYPE_4 { Utils . VAR_1 ( sess ) ; if ( ! TYPE_5 . METHOD_2 ( sess , STRING_1 ) ) { throw new TYPE_4 ( sess , STRING_2 ) ; } List < TYPE_6 > VAR_2 = METHOD_3 ( ) . METHOD_4 ( sess ) ; <START> VAR_2 . METHOD_5 ( VAR_3 - > TYPE_5 . METHOD_2 ( sess , STRING_3 , Collections . VAR_4 ( VAR_3 ) ) ) ; <END> return METHOD_3 ( ) . METHOD_1 ( sess , VAR_2 ) ; } 
public String getValue ( String value , TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = new TYPE_2 ( ) ; <END> try { return VAR_2 . METHOD_1 ( value ) ; } catch ( TYPE_3 e ) { log . warn ( STRING_1 , value , e ) ; return null ; } } 
public String toString ( ) { String VAR_1 = "" ; if ( ! this . isEmpty ( ) ) { for ( String VAR_2 : this . keySet ( ) ) { <START> VAR_1 += VAR_2 . METHOD_1 ( ) + this . get ( VAR_2 ) + STRING_1 ; <END> } } return getClass ( ) . METHOD_2 ( ) + STRING_2 + VAR_1 + STRING_3 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 { <START> if ( VAR_3 . METHOD_2 ( ) == null ) throw new TYPE_4 ( VAR_3 , null , VAR_2 , null , STRING_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 { <START> if ( VAR_3 . METHOD_2 ( ) == null ) <END> throw new TYPE_4 ( VAR_3 , STRING_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 { <START> if ( VAR_3 . METHOD_2 ( ) == null ) { <END> throw new TYPE_4 ( VAR_3 , null , VAR_2 , null , STRING_1 ) ; } } 
public void METHOD_1 ( TYPE_1 sess , TYPE_2 user , TYPE_3 VAR_1 ) throws TYPE_4 , TYPE_5 { <START> Utils . VAR_2 ( VAR_1 , STRING_1 ) ; <END> if ( VAR_3 . contains ( VAR_1 . METHOD_2 ( ) ) ) throw new TYPE_5 ( VAR_1 , user , STRING_2 + VAR_1 . getValue ( ) + STRING_3 ) ; super . METHOD_1 ( sess , user , VAR_1 ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , String key , TYPE_2 VAR_2 ) throws TYPE_3 { <END> if ( VAR_2 . getValue ( ) == null ) return ; if ( ! ( VAR_2 . getValue ( ) instanceof String ) ) { throw new TYPE_3 ( VAR_2 , key , STRING_1 ) ; } String value = VAR_2 . METHOD_2 ( ) ; if ( ! value . contains ( STRING_2 ) ) { throw new TYPE_3 ( VAR_2 , key , STRING_3 ) ; } } 
public void METHOD_1 ( TYPE_1 sess , TYPE_2 group , TYPE_3 VAR_1 ) throws TYPE_4 { if ( VAR_1 . getValue ( ) == null ) throw new TYPE_4 ( VAR_1 , STRING_1 ) ; if ( VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) { throw new TYPE_4 ( VAR_1 , STRING_2 ) ; <START> } <END> } 
public void METHOD_1 ( TYPE_1 sess , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws TYPE_4 , TYPE_5 { TYPE_3 VAR_3 = METHOD_2 ( sess , VAR_1 , VAR_2 ) ; <START> if ( ! VAR_2 . equals ( VAR_3 ) ) throw new TYPE_5 ( VAR_2 , VAR_3 , VAR_1 , null , STRING_1 ) ; <END> } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 sess , List < TYPE_1 > VAR_1 ) throws TYPE_3 { Iterator < TYPE_1 > VAR_2 = VAR_1 . iterator ( ) ; while ( VAR_2 . hasNext ( ) ) { TYPE_1 resource = VAR_2 . next ( ) ; if ( ! TYPE_4 . METHOD_2 ( sess , TYPE_5 . VAR_4 , resource ) && <START> ! TYPE_4 . METHOD_2 ( sess , TYPE_5 . VAR_5 ) ) VAR_2 . remove ( ) ; <END> } return VAR_1 ; } 
public String METHOD_1 ( TYPE_1 sess ) throws TYPE_2 , TYPE_3 { Utils . VAR_1 ( sess ) ; if ( ! TYPE_4 . METHOD_2 ( sess , TYPE_5 . VAR_3 ) <START> && ! TYPE_4 . METHOD_2 ( sess , TYPE_5 . VAR_4 ) ) throw new TYPE_3 ( sess , STRING_1 ) ; <END> return METHOD_3 ( ) . METHOD_1 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 sess , TYPE_3 VAR_1 ) throws TYPE_4 , TYPE_5 { try { return VAR_2 . METHOD_2 ( STRING_1 + VAR_3 + STRING_2 + STRING_3 , VAR_4 , VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) . getId ( ) ) ; } catch ( TYPE_6 ex ) { <START> log . debug ( STRING_4 ) ; <END> throw new TYPE_5 ( STRING_5 + VAR_1 . toString ( ) ) ; } catch ( RuntimeException err ) { throw new TYPE_4 ( err ) ; } } 
public int METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { if ( ! TYPE_4 . METHOD_2 ( VAR_1 , TYPE_5 . VAR_3 ) ) { throw new TYPE_3 ( VAR_1 , STRING_1 ) ; <START> } <END> return METHOD_3 ( ) . METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 sess , TYPE_2 VAR_1 ) throws TYPE_3 { <START> METHOD_2 ( ) . METHOD_3 ( ) . log ( sess , new TYPE_4 ( VAR_1 ) ) ; <END> METHOD_4 ( ) . METHOD_1 ( sess , VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 sess , TYPE_3 VAR_1 , TYPE_4 VAR_2 ) throws TYPE_5 { TYPE_1 VAR_3 = new TYPE_1 ( VAR_2 ) ; TYPE_1 VAR_4 = METHOD_2 ( sess , VAR_1 ) ; if ( VAR_4 . getValue ( ) == null ) return VAR_3 ; TYPE_1 VAR_5 = METHOD_3 ( sess , ( String ) VAR_4 . getValue ( ) ) ; <START> Utils . VAR_6 ( VAR_5 , VAR_3 ) ; <END> return VAR_3 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 sess , TYPE_3 VAR_1 , TYPE_4 VAR_2 ) throws TYPE_5 { TYPE_1 VAR_3 = new TYPE_1 ( VAR_2 ) ; try { TYPE_1 VAR_4 = METHOD_2 ( sess , VAR_1 ) ; if ( VAR_4 . getValue ( ) == null ) return VAR_3 ; TYPE_1 VAR_5 = METHOD_3 ( sess , ( String ) VAR_4 . getValue ( ) ) ; <START> Utils . VAR_6 ( VAR_5 , VAR_3 ) ; <END> return VAR_3 ; } catch ( TYPE_6 ex ) { return VAR_3 ; } } 
public void METHOD_1 ( Long VAR_1 ) { <START> this . VAR_1 = TYPE_1 . METHOD_2 ( VAR_1 ) . METHOD_3 ( TYPE_2 . METHOD_4 ( ) ) . METHOD_5 ( ) ; <END> } 
public static void METHOD_1 ( String VAR_1 , String VAR_2 , int VAR_3 ) throws TYPE_1 { <START> if ( VAR_2 . length ( ) > VAR_3 ) throw new TYPE_1 ( STRING_1 + VAR_1 + STRING_2 + VAR_3 + STRING_3 + VAR_2 . length ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 message = session . VAR_2 ( STRING_1 + VAR_3 . getProperty ( STRING_2 ) + STRING_3 + VAR_1 . METHOD_2 ( ) ) ; synchronized ( VAR_4 ) { VAR_4 . METHOD_3 ( message , TYPE_4 . VAR_6 , 2 , 0 ) ; } <START> log . debug ( STRING_4 , VAR_1 . METHOD_4 ( ) , <END> VAR_1 . METHOD_5 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , String key , TYPE_2 VAR_2 ) throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 { if ( VAR_2 . getValue ( ) == null ) return ; if ( ! ( VAR_2 . getValue ( ) instanceof String ) ) { throw new TYPE_4 ( VAR_2 , key , STRING_1 ) ; } <START> String value = VAR_2 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { <START> log . debug ( STRING_1 ) ; <END> return ; } try { METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( sess ) ; METHOD_3 ( ) . METHOD_6 ( ) . METHOD_7 ( sess ) ; } catch ( TYPE_1 ex ) { log . error ( STRING_2 , ex ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 sess , TYPE_1 VAR_1 ) throws TYPE_3 , TYPE_4 { <START> return METHOD_1 ( sess , VAR_1 , false ) ; <END> } 
public List < String > METHOD_1 ( ) { List < String > VAR_1 = new ArrayList < > ( ) ; VAR_1 . add ( TYPE_1 + STRING_1 ) ; <START> VAR_1 . add ( TYPE_2 + STRING_1 ) ; <END> return VAR_1 ; } 
protected static void METHOD_1 ( TYPE_1 sess ) throws TYPE_2 { log . trace ( STRING_1 , sess . VAR_1 ( ) ) ; <START> METHOD_2 ( sess ) ; <END> log . debug ( STRING_2 , sess . VAR_1 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 sess , TYPE_2 group ) throws TYPE_3 , TYPE_4 { <START> Utils . VAR_1 ( group , STRING_1 ) ; <END> if ( VAR_2 . METHOD_2 ( group , true ) ) { log . info ( STRING_2 , group ) ; } else { throw new TYPE_3 ( group ) ; } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 resource , TYPE_3 group , TYPE_4 VAR_2 ) throws TYPE_5 , TYPE_6 , TYPE_7 , TYPE_8 , TYPE_9 { <END> } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> } return VAR_1 ; } 
<START> public void METHOD_1 ( TYPE_1 sess , TYPE_2 VAR_1 ) { <END> VAR_2 . update ( STRING_1 , VAR_1 . getId ( ) ) ; VAR_2 . update ( STRING_2 , VAR_1 . getId ( ) , TYPE_4 . TYPE_5 . METHOD_2 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 sess , TYPE_2 user , TYPE_3 VAR_1 ) throws TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 { String VAR_2 = null ; <START> TYPE_8 VAR_3 = Utils . VAR_4 . matcher ( VAR_2 ) ; <END> if ( ! VAR_3 . METHOD_2 ( ) ) { throw new TYPE_5 ( VAR_1 , user , STRING_1 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 { if ( VAR_3 . getValue ( ) == null ) return ; String VAR_4 = ( String ) VAR_3 . getValue ( ) ; <START> TYPE_8 VAR_5 = TYPE_8 . METHOD_2 ( STRING_1 ) ; <END> TYPE_9 VAR_6 = VAR_5 . matcher ( VAR_4 ) ; if ( ! VAR_6 . METHOD_3 ( ) ) throw new TYPE_5 ( VAR_3 , VAR_2 , STRING_2 ) ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 sess , List < TYPE_3 > VAR_1 ) throws TYPE_4 { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; <START> for ( TYPE_3 group : VAR_1 ) <END> VAR_2 . add ( new TYPE_1 ( group , this . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( sess , group ) ) ) ; return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 , TYPE_5 , TYPE_6 { if ( VAR_3 . getValue ( ) == null ) return ; Integer VAR_4 = ( Integer ) VAR_3 . getValue ( ) ; <START> if ( VAR_4 > 1 || VAR_4 < 0 ) throw new TYPE_5 ( VAR_3 , STRING_1 ) ; <END> } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) throws TYPE_2 { TYPE_3 VAR_3 = TYPE_3 . METHOD_2 ( STRING_1 ) ; TYPE_4 VAR_4 = VAR_3 . matcher ( VAR_1 ) ; if ( ! VAR_4 . METHOD_3 ( ) ) { throw new TYPE_2 ( VAR_2 , STRING_2 + VAR_1 ) ; } <START> if ( ! VAR_1 . startsWith ( STRING_3 ) ) { <END> throw new TYPE_2 ( VAR_2 , STRING_4 + VAR_1 + STRING_5 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , long VAR_2 ) { TYPE_3 target = new TYPE_3 ( VAR_2 , VAR_2 ) ; <START> if ( VAR_3 == null ) { <END> VAR_4 . error ( STRING_1 ) ; return null ; } TYPE_4 VAR_5 = VAR_3 . METHOD_2 ( VAR_1 , target ) ; if ( VAR_5 == null ) return null ; return METHOD_3 ( VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException { try { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; TYPE_3 metadata = new TYPE_3 ( ) ; metadata . VAR_4 ( Constants . VAR_5 ) ; <START> metadata . VAR_6 ( STRING_1 ) ; <END> TYPE_4 writer = Utils . VAR_7 ( VAR_2 . METHOD_3 ( ) ) ; return new TYPE_5 ( new TYPE_6 ( VAR_2 , writer ) , INT_1 * INT_2 ) ; } catch ( TYPE_7 VAR_8 ) { throw new TYPE_8 ( VAR_1 ) ; } } 
public void METHOD_1 ( int VAR_1 , long offset , ByteBuffer entry ) throws IOException { if ( ! VAR_2 ) { <START> System . out . println ( STRING_1 + VAR_1 ) ; <END> VAR_2 = true ; } } 
public TYPE_3 ( long VAR_2 , boolean VAR_3 , TYPE_1 VAR_4 ) { super ( VAR_2 , VAR_3 , VAR_4 ) ; if ( ! TYPE_2 . METHOD_1 ( ) && ! VAR_5 ) { <START> log . error ( STRING_1 ) ; <END> VAR_5 = true ; } } 
public long METHOD_1 ( ) { <START> Long VAR_1 = TYPE_1 . VAR_3 ; <END> for ( int VAR_4 : VAR_5 ) { Long VAR_6 = METHOD_1 ( VAR_4 ) ; if ( VAR_6 != TYPE_1 . VAR_3 ) { if ( VAR_1 == TYPE_1 . VAR_3 ) { VAR_1 = VAR_6 ; } else { VAR_1 = Math . max ( VAR_1 , VAR_6 ) ; } } } return VAR_1 ; } 
protected void METHOD_1 ( ) { try { this . server . start ( ) ; } catch ( Throwable VAR_1 ) { LOG . error ( STRING_1 , VAR_1 ) ; if ( VAR_2 != null ) { <START> LOG . error ( STRING_2 ) ; <END> VAR_2 . METHOD_2 ( Thread . VAR_3 ( ) , VAR_1 ) ; } else { throw new RuntimeException ( STRING_3 , VAR_1 ) ; } } } 
protected void METHOD_1 ( ) { try { this . VAR_1 . start ( ) ; } catch ( Throwable VAR_2 ) { <START> LOG . error ( STRING_1 , VAR_2 ) ; <END> if ( VAR_3 != null ) { LOG . error ( STRING_2 ) ; VAR_3 . METHOD_2 ( Thread . VAR_4 ( ) , VAR_2 ) ; } else { throw new RuntimeException ( STRING_3 , VAR_2 ) ; } } } 
public long METHOD_1 ( ) { <START> return METHOD_2 ( VAR_1 , INT_1 ) ; <END> } 
TYPE_1 < ? > METHOD_1 ( final boolean VAR_1 , final boolean VAR_2 , final boolean VAR_3 ) { return VAR_4 . METHOD_2 ( ( ) - > { try { METHOD_3 ( VAR_1 , VAR_2 , VAR_3 ) ; } catch ( Exception e ) { LOG . warn ( STRING_1 , e . getMessage ( ) , e ) ; } <START> } ) ; <END> } 
public void METHOD_1 ( ) { boolean VAR_1 = VAR_2 . get ( ) ; boolean VAR_3 = VAR_4 . get ( ) ; boolean VAR_5 = VAR_6 . get ( ) ; try { METHOD_2 ( VAR_1 , VAR_3 , VAR_5 ) ; } catch ( Exception e ) { <START> LOG . warn ( STRING_1 , e . getMessage ( ) , e ) ; <END> } if ( VAR_1 ) { VAR_2 . set ( false ) ; } } 
<START> public TYPE_1 ( T result , boolean VAR_2 ) { <END> this . result = result ; this . VAR_2 = VAR_2 ; } 
public long METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( VAR_2 . METHOD_2 ( - INT_1 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_2 = VAR_1 ; <START> this . VAR_3 . METHOD_1 ( VAR_1 ) ; <END> } 
public void close ( ) throws IOException { <START> TYPE_1 . close ( log , VAR_1 ) ; <END> } 
<START> protected synchronized void METHOD_1 ( ) { <END> TYPE_1 VAR_1 ; synchronized ( this ) { VAR_1 = VAR_2 ; VAR_2 = null ; } if ( null != VAR_1 ) { try { VAR_1 . close ( ) ; } catch ( IOException e ) { log . warn ( STRING_1 , e ) ; } } } 
static TYPE_1 METHOD_1 ( TYPE_2 conf ) throws InterruptedException , IOException { TYPE_3 VAR_1 = new TYPE_3 ( conf ) ; VAR_1 . METHOD_2 ( TYPE_3 . VAR_2 ) ; <START> LOG . info ( STRING_1 , <END> VAR_1 . METHOD_3 ( ) ) ; try { return TYPE_1 . METHOD_4 ( VAR_1 ) . build ( ) ; } catch ( TYPE_4 e ) { throw new IOException ( STRING_2 , e ) ; } } 
public TYPE_1 < Boolean > METHOD_1 ( long VAR_1 , byte [ ] VAR_2 ) <START> throws IOException , TYPE_2 , InterruptedException { <END> TYPE_3 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 , VAR_2 ) ; return VAR_3 . METHOD_3 ( METHOD_4 ( VAR_1 ) ) ; } 
void METHOD_1 ( ) { synchronized ( VAR_1 ) { if ( VAR_2 . isEmpty ( ) ) { return ; } <START> Map < Integer , TYPE_1 > VAR_3 = new HashMap < > ( ) ; <END> VAR_3 . METHOD_2 ( VAR_2 ) ; VAR_2 . clear ( ) ; METHOD_3 ( VAR_3 ) ; } } 
<START> TYPE_1 < Long , TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { <END> return data . VAR_2 ( VAR_1 , ( key ) - > new TYPE_1 < > ( ) ) ; } 
public void close ( ) throws IOException { Set < TYPE_1 > VAR_1 = METHOD_1 ( ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { <START> TYPE_2 . close ( log , VAR_2 . METHOD_2 ( ) ) ; <END> } } 
public synchronized void close ( ) throws IOException { if ( VAR_1 != null ) { TYPE_1 . METHOD_1 ( VAR_1 ) ; <START> VAR_1 = null ; <END> } VAR_2 . close ( ) ; } 
public < T > List < TYPE_1 < T > > METHOD_1 ( Collection < ? extends TYPE_2 < T > > VAR_1 ) throws InterruptedException { <START> METHOD_2 ( ) ; <END> return super . METHOD_1 ( VAR_1 ) ; } 
private TYPE_1 METHOD_1 ( long VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 != null ) { return VAR_2 ; } else { TYPE_1 VAR_4 = new TYPE_1 ( VAR_1 , VAR_5 ) ; VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , VAR_4 ) ; <START> return VAR_2 != null ? VAR_2 : VAR_4 ; <END> } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return conf ; } 
public long METHOD_1 ( ) { <START> return METHOD_2 ( VAR_1 , INT_1 ) ; <END> } 
public long METHOD_1 ( ) { <START> return METHOD_2 ( VAR_1 , 100 ) ; <END> } 
public static TYPE_1 METHOD_1 ( long VAR_1 , long VAR_2 , long VAR_3 , long length , byte [ ] data , int offset , int VAR_4 ) { TYPE_2 VAR_5 = null ; try { VAR_5 = TYPE_2 . METHOD_2 ( VAR_1 , new byte [ 2 ] , VAR_6 ) ; } catch ( TYPE_3 VAR_7 ) { <START> <END> } return VAR_5 . METHOD_3 ( VAR_2 , VAR_3 , length , TYPE_4 . METHOD_4 ( data , offset , VAR_4 ) ) ; } 
private void METHOD_1 ( TYPE_1 < Long , TYPE_2 > VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . getValue ( ) ; Long VAR_3 = VAR_1 . getKey ( ) ; if ( null == VAR_2 || null == VAR_1 . getKey ( ) ) { return ; } if ( VAR_1 . METHOD_2 ( ) ) { VAR_4 . METHOD_3 ( ) ; } <START> VAR_2 . METHOD_4 ( ) ; <END> } 
<START> private Set < String > METHOD_1 ( Set < TYPE_1 > VAR_1 ) { <END> Set < String > VAR_2 = new HashSet < String > ( ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_2 . add ( VAR_3 . METHOD_2 ( ) ) ; } return VAR_2 ; } 
TYPE_6 ( TYPE_1 conf , TYPE_2 VAR_2 ) throws IOException { this . conf = conf ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = null ; <END> this . VAR_4 = new TYPE_3 ( conf , conf . VAR_5 ( ) , new TYPE_4 ( conf . VAR_6 ( ) , conf . VAR_7 ( ) ) , TYPE_5 . VAR_9 ) ; this . VAR_10 = METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { try { new TYPE_1 ( 3 , 2 ) ; METHOD_2 ( STRING_1 ) ; <START> } catch ( IllegalArgumentException e ) { <END> } } 
<START> void METHOD_1 ( ) { <END> int VAR_1 = 0 ; for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_2 ( ) ) { VAR_1 ++ ; } } LOG . info ( STRING_1 , VAR_1 ) ; } 
public void METHOD_1 ( ) { <START> for ( TYPE_1 VAR_1 : VAR_2 . values ( ) ) { <END> VAR_1 . METHOD_2 ( ) ; } } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( ) { <START> assertEquals ( TYPE_1 . METHOD_2 ( TYPE_2 . class ) , TYPE_2 . METHOD_3 ( 0 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = TYPE_2 . get ( ) ; <END> VAR_1 . VAR_2 = VAR_2 ; VAR_1 . VAR_3 = VAR_3 ; VAR_1 . length = length ; VAR_1 . VAR_4 = VAR_4 . METHOD_2 ( ) ; return VAR_1 ; } 
private void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> for ( TYPE_1 entry : VAR_1 ) { <END> entry . VAR_2 ( ) . METHOD_2 ( 1 ) ; } } } 
public void METHOD_1 ( ) { <START> if ( null != VAR_1 ) { <END> TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; } } 
<START> public void start ( ) throws IOException , TYPE_1 , InterruptedException , TYPE_2 , TYPE_3 { <END> this . VAR_1 . start ( ) ; if ( ! this . VAR_1 . METHOD_1 ( ) ) { VAR_2 = VAR_1 . METHOD_2 ( ) ; return ; } this . VAR_3 . start ( ) ; VAR_4 = true ; VAR_5 = new TYPE_4 ( conf ) ; VAR_5 . start ( ) ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> LOG . info ( STRING_1 ) ; <END> VAR_1 . METHOD_2 ( STRING_2 + VAR_2 . METHOD_3 ( ) ) ; VAR_3 = new TYPE_1 ( ) ; } 
<START> private String METHOD_1 ( Object request ) { <END> if ( request instanceof TYPE_3 . TYPE_4 ) { TYPE_3 . TYPE_5 VAR_1 = ( ( TYPE_3 . TYPE_4 ) request ) . METHOD_2 ( ) ; return String . format ( STRING_1 , VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) ) ; } else { return request . toString ( ) ; } } 
public static < T > T METHOD_1 ( String VAR_1 , Class < T > VAR_2 ) throws TYPE_1 { try { return VAR_3 . METHOD_2 ( VAR_1 , VAR_2 ) ; } catch ( Exception e ) { <START> e . VAR_4 ( ) ; <END> throw new TYPE_1 ( STRING_1 ) ; } } 
<START> public TYPE_2 . TYPE_3 METHOD_1 ( ) { <END> if ( VAR_1 . equals ( TYPE_4 . TYPE_3 . VAR_4 ) ) { return TYPE_2 . TYPE_3 . VAR_5 ; } else { return TYPE_2 . TYPE_3 . VAR_6 ; } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_2 ( this ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , Set < TYPE_2 > VAR_2 , TYPE_3 < TYPE_1 > VAR_3 , TYPE_4 < TYPE_1 > VAR_4 ) throws TYPE_5 { try { return METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; } catch ( TYPE_5 e ) { LOG . warn ( STRING_1 + STRING_2 , VAR_1 , VAR_2 ) ; <START> LOG . warn ( STRING_3 , VAR_3 , VAR_4 ) ; <END> return METHOD_3 ( 1 , VAR_2 , VAR_3 , VAR_4 ) . get ( 0 ) ; } } 
TYPE_3 . TYPE_4 METHOD_1 ( TYPE_2 request ) { switch ( request . method ( ) ) { case VAR_1 : return TYPE_3 . TYPE_4 . VAR_1 ; case VAR_2 : return TYPE_3 . TYPE_4 . VAR_2 ; case VAR_3 : return TYPE_3 . TYPE_4 . VAR_3 ; case VAR_4 : return TYPE_3 . TYPE_4 . VAR_4 ; <START> default : <END> return TYPE_3 . TYPE_4 . VAR_1 ; } } 
private void METHOD_1 ( File file , String VAR_1 ) throws IOException { <START> TYPE_1 VAR_2 = new TYPE_1 ( file ) ; <END> TYPE_2 VAR_3 = null ; try { VAR_3 = new TYPE_2 ( new TYPE_3 ( VAR_2 , VAR_4 ) ) ; VAR_3 . write ( VAR_1 ) ; } finally { if ( VAR_3 != null ) { VAR_3 . close ( ) ; } VAR_2 . close ( ) ; } } 
private TYPE_1 METHOD_1 ( File file ) throws IOException , IllegalArgumentException { if ( ! file . exists ( ) ) { return null ; } <START> TYPE_2 reader = new TYPE_2 ( <END> new TYPE_3 ( new TYPE_4 ( file ) , VAR_1 ) ) ; try { return parse ( reader ) ; } finally { reader . close ( ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 connection , TYPE_6 . TYPE_7 < TYPE_4 > VAR_1 ) { return new TYPE_1 ( ) { @Override public void METHOD_2 ( TYPE_5 m , TYPE_6 . TYPE_7 < TYPE_5 > VAR_2 ) { } @Override public void close ( ) { VAR_3 . METHOD_3 ( ) ; } <START> <END> public void METHOD_4 ( TYPE_6 . TYPE_7 < TYPE_5 > VAR_2 ) { VAR_4 . METHOD_3 ( ) ; VAR_1 . METHOD_5 ( TYPE_8 . TYPE_9 . VAR_7 , null ) ; } } ; } 
public TYPE_1 build ( ) throws IOException , InterruptedException , TYPE_2 { TYPE_3 . METHOD_1 ( VAR_1 , STRING_1 ) ; if ( VAR_2 == null ) { <START> VAR_2 = METHOD_2 ( ) ; <END> } return new TYPE_1 ( conf , VAR_3 , VAR_2 , VAR_1 , VAR_4 , VAR_5 , VAR_6 ) ; } 
public void METHOD_1 ( int VAR_1 , TYPE_1 v ) { if ( VAR_1 == TYPE_2 . TYPE_3 . VAR_4 ) { VAR_5 = true ; <START> LOG . error ( STRING_1 ) ; <END> } else { LOG . debug ( STRING_2 ) ; } } 
public ArrayList < TYPE_1 > METHOD_1 ( int VAR_1 , int VAR_2 ) throws TYPE_2 { try { <START> return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 , VAR_4 . METHOD_2 ( ) . keySet ( ) ) ; <END> } catch ( TYPE_2 e ) { if ( logger . VAR_5 ( ) ) { logger . debug ( STRING_1 ) ; } return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 , VAR_6 ) ; } } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 id ) { <END> return METHOD_2 ( id , TYPE_1 . class ) ; } 
<START> public void add ( TYPE_1 VAR_1 ) { <END> VAR_2 += VAR_1 . METHOD_1 ( ) ; VAR_3 += VAR_1 . METHOD_2 ( ) ; } 
public void METHOD_1 ( int page ) { <START> TYPE_1 . METHOD_2 ( context ) ; <END> METHOD_1 ( page , true ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> VAR_3 . METHOD_3 ( this ) ; VAR_4 . METHOD_3 ( this ) ; super . METHOD_1 ( ) ; } 
public String METHOD_1 ( ) { final String result ; if ( this . VAR_1 != null ) { <START> result = this . VAR_2 ; <END> } else if ( this . VAR_2 != null ) { result = this . VAR_2 ; } else { result = this . name ; } return result ; } 
public void METHOD_1 ( ) { <START> Long VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 , INT_1 ) ; <END> assertTrue ( VAR_1 == INT_1 ) ; VAR_1 = TYPE_1 . METHOD_2 ( STRING_2 , INT_1 ) ; assertTrue ( VAR_1 == INT_2 ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 request ) throws TYPE_2 { TYPE_3 VAR_1 = METHOD_2 ( METHOD_3 ( ) ) ; <START> if ( METHOD_4 ( ) ) { <END> return VAR_1 . METHOD_5 ( request ) ; } return VAR_1 . apply ( request ) ; } 
private void METHOD_1 ( ) throws TYPE_1 { this . VAR_1 . METHOD_2 ( VAR_2 , VAR_3 , in ) ; assertEquals ( 1 , VAR_2 . METHOD_3 ( ) . size ( ) ) ; <START> assertEquals ( 1 , VAR_2 . METHOD_3 ( ) . stream ( ) <END> . map ( ( VAR_4 ) - > VAR_4 . METHOD_4 ( ) . equals ( VAR_3 ) ) . count ( ) ) ; } 
public boolean exists ( String VAR_1 , String path ) { TYPE_1 VAR_2 = METHOD_1 ( VAR_1 , path ) ; if ( VAR_2 != null ) { return true ; } <START> return false ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { if ( VAR_1 != null ) { <START> return METHOD_1 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) , VAR_2 ) ; <END> } return null ; } 
public void METHOD_1 ( final TYPE_1 f ) throws IOException { VAR_1 . METHOD_2 ( resource ) ; VAR_1 . METHOD_3 ( resource ) ; try { if ( VAR_2 != null ) { <START> VAR_2 . METHOD_4 ( f , this , new TYPE_2 ( ) ) ; <END> } VAR_1 . METHOD_5 ( f . VAR_3 ( ) , resource ) ; } finally { VAR_1 . METHOD_6 ( resource ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , final String VAR_2 ) { <START> for ( Map . Entry < String , TYPE_2 > entry : VAR_3 . entrySet ( ) ) <END> { if ( VAR_2 . equals ( entry . getKey ( ) ) ) { entry . getValue ( ) . METHOD_1 ( VAR_1 ) ; } } } 
public void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { <START> for ( Map . Entry < String , TYPE_2 > entry : VAR_3 . entrySet ( ) ) <END> { if ( VAR_2 . equals ( entry . getKey ( ) ) ) { entry . getValue ( ) . METHOD_1 ( VAR_1 ) ; } } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) <END> { if ( ! VAR_2 . containsKey ( VAR_1 . METHOD_2 ( ) ) ) { logger . warn ( STRING_1 , VAR_1 . METHOD_2 ( ) ) ; } VAR_2 . remove ( VAR_1 . METHOD_2 ( ) ) ; } 
public String METHOD_1 ( final String value , final String ... VAR_1 ) { if ( ! METHOD_2 ( value ) ) { return value ; } <START> List < String > VAR_2 = new ArrayList < > ( ) ; <END> VAR_2 . add ( TYPE_1 . VAR_3 ) ; TYPE_1 VAR_4 = new TYPE_1 ( VAR_2 ) ; return METHOD_1 ( value , VAR_4 , VAR_1 ) ; } 
<START> public String get ( String name , TYPE_1 VAR_1 ) throws TYPE_2 { <END> throw new TYPE_3 ( STRING_1 ) ; } 
private String METHOD_1 ( long VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; String description = "" ; long VAR_4 = Constants . key . VAR_5 ; try { VAR_4 = VAR_2 . METHOD_3 ( ) ; description += VAR_2 . METHOD_4 ( ) ; } catch ( TYPE_2 e ) { <START> e . VAR_6 ( ) ; <END> } description += STRING_1 + Long . VAR_7 ( VAR_4 ) + STRING_2 ; return description ; } 
public static TYPE_1 getInstance ( ) { <START> if ( instance == null ) instance = new TYPE_1 ( ) ; <END> return instance ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 , false ) ; <END> } 
<START> public static void VAR_1 ( Context context ) { ] <END> TYPE_1 VAR_3 = TYPE_2 . VAR_5 ( context ) ; if ( VAR_3 == null ) { return ; } TYPE_4 . VAR_7 ( VAR_3 , Constants . VAR_8 , 1 ) ; TYPE_4 . VAR_9 ( VAR_3 , Constants . VAR_8 , true ) ; TYPE_4 . VAR_10 ( VAR_3 , Constants . VAR_8 , new TYPE_3 ( ) , VAR_12 ) ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) , TYPE_2 . class ) ; VAR_1 . METHOD_3 ( TYPE_2 . VAR_2 ) ; <START> VAR_1 . METHOD_4 ( TYPE_2 . VAR_3 , true ) ; <END> METHOD_5 ( VAR_1 , VAR_4 ) ; } 
private static TYPE_1 METHOD_1 ( Context context , long VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_3 ) ; VAR_2 . METHOD_2 ( VAR_4 , VAR_1 ) ; Long VAR_5 = System . currentTimeMillis ( ) ; <START> return TYPE_1 . METHOD_3 ( context , VAR_5 . METHOD_4 ( ) , VAR_2 , <END> TYPE_1 . VAR_6 ) ; } 
public TYPE_4 ( Set < String > VAR_2 ) throws TYPE_2 . TYPE_3 , IOException { <START> this . VAR_2 . addAll ( VAR_2 ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> TYPE_2 VAR_1 = TYPE_2 . getInstance ( ) ; if ( VAR_1 != null ) { return ( TYPE_1 ) VAR_1 . METHOD_2 ( getClass ( ) ) ; } return null ; } 
public String METHOD_1 ( ) { <START> if ( VAR_1 == null ) <END> return STRING_1 ; return VAR_1 ; } 
public boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> return VAR_1 == TYPE_1 . VAR_2 || VAR_1 == TYPE_1 . VAR_3 || super . METHOD_1 ( VAR_1 ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( File f , TYPE_2 channel ) throws IOException , InterruptedException { <END> f . VAR_1 ( ) ; return null ; } 
<START> protected void METHOD_1 ( TYPE_1 build , Map < String , String > VAR_1 ) { <END> TYPE_2 a = METHOD_2 ( build ) ; if ( a != null ) { VAR_1 . put ( STRING_1 , a . id ) ; VAR_1 . put ( STRING_2 , a . VAR_2 ( ) ) ; VAR_1 . put ( STRING_3 , a . VAR_3 ) ; } } 
<START> public String METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_1 . METHOD_2 ( source ) ; } 
public TYPE_1 METHOD_1 ( long VAR_1 , String VAR_2 , Integer page , Integer VAR_3 ) { logger . debug ( STRING_1 , page , VAR_3 ) ; Collection < TYPE_2 > result = null ; result = VAR_4 . METHOD_1 ( VAR_1 , TYPE_3 . valueOf ( VAR_2 ) , METHOD_2 ( page , VAR_3 ) ) ; TYPE_1 VAR_5 = METHOD_3 ( result ) ; <START> logger . debug ( STRING_2 , VAR_5 ) ; <END> return VAR_5 ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_2 ( ) ; <END> TYPE_3 config = TYPE_3 . METHOD_2 ( ) ; config . VAR_2 ( false ) ; config . VAR_3 ( false ) ; TYPE_4 VAR_4 = VAR_1 . METHOD_3 ( config ) ; METHOD_4 ( VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { final List < Long > VAR_2 = VAR_3 . entrySet ( ) . stream ( ) . filter ( entry - > VAR_1 . METHOD_2 ( entry . getValue ( ) ) > 0 ) . map ( Map . Entry : : getKey ) . collect ( Collectors . VAR_4 ( ) ) ; <START> VAR_2 . forEach ( VAR_5 - > VAR_3 . remove ( VAR_5 ) ) ; <END> } } 
private void METHOD_1 ( Response response ) { assertEquals ( INT_1 , response . getStatus ( ) ) ; assertNotNull ( response . VAR_1 ( ) ) ; <START> VAR_2 = response . VAR_3 ( String . VAR_4 ) ; <END> } 
protected Response METHOD_1 ( String VAR_1 ) { <START> logger . info ( STRING_1 + VAR_1 ) ; <END> TYPE_1 VAR_2 = VAR_3 . target ( VAR_1 ) ; return VAR_2 . request ( ) . get ( ) ; } 
public TYPE_1 ( TYPE_1 VAR_1 ) { super ( VAR_1 . getId ( ) , VAR_1 . METHOD_1 ( ) , VAR_1 . METHOD_2 ( ) ) ; this . VAR_2 = VAR_1 . VAR_2 ; this . status = VAR_1 . status ; <START> this . VAR_3 = VAR_1 . METHOD_3 ( ) . isEmpty ( ) ? new TYPE_2 < TYPE_3 , TYPE_4 > ( TYPE_3 . class ) : new TYPE_2 < > ( VAR_1 . METHOD_3 ( ) ) ; <END> } 
public Map < TYPE_1 , TYPE_2 > METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_3 < > ( TYPE_1 . class ) ; } Map < TYPE_1 , TYPE_2 > VAR_2 = new TYPE_3 < > ( TYPE_1 . class ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; <START> return VAR_2 ; <END> } 
public void METHOD_1 ( ) { <START> config . VAR_1 ( List . of ( TYPE_3 . VAR_3 ) ) ; <END> VAR_4 = TYPE_1 . METHOD_2 ( config ) . METHOD_3 ( TYPE_2 . class ) ; } 
private static void METHOD_1 ( int VAR_1 ) { if ( VAR_1 < 0 || VAR_1 > 10 ) { <START> throw new TYPE_1 ( String . format ( STRING_1 + <END> STRING_2 + STRING_3 , VAR_1 ) ) ; } } 
<START> public int METHOD_1 ( ) { <END> if ( TYPE_3 . TYPE_4 . METHOD_2 ( ) . equals ( METHOD_3 ( ) . METHOD_2 ( ) ) ) { return 0 ; } return TYPE_2 . METHOD_4 ( this , METHOD_3 ( ) ) ? 0 : - 1 ; } 
public TYPE_1 ( ) { VAR_2 . forEach ( repo - > VAR_3 = repo ) ; log . info ( STRING_1 + VAR_3 ) ; <START> VAR_4 = Boolean . VAR_5 ( System . getProperty ( VAR_6 , STRING_2 ) ) ; <END> VAR_7 = System . getProperty ( TYPE_2 . VAR_9 , STRING_3 ) ; } 
private TYPE_1 METHOD_1 ( String id ) { Map < String , TYPE_1 > VAR_1 = new HashMap < > ( ) ; TYPE_2 file = METHOD_2 ( ) ; <START> file . VAR_2 ( ) . forEach ( name - > VAR_1 . put ( name , new TYPE_1 ( name , file . getProperty ( name ) ) ) ) ; <END> return VAR_1 . get ( id ) ; } 
private static boolean METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { final String key = VAR_1 + STRING_1 + VAR_2 ; String VAR_4 = VAR_5 . get ( key ) ; VAR_5 . put ( key , VAR_3 ) ; <START> return VAR_4 == null ; <END> } 
private static boolean METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { <START> final String key = VAR_1 + STRING_1 + VAR_2 ; <END> if ( VAR_4 . contains ( key ) ) { return false ; } VAR_4 . add ( key ) ; return true ; } 
public void METHOD_1 ( ) { String VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; assertThat ( VAR_1 ) . METHOD_3 ( ) ; assertThat ( METHOD_4 ( ) ) . contains ( STRING_1 + VAR_4 + STRING_2 , STRING_3 + VAR_4 + STRING_4 ) ; VAR_5 . METHOD_5 ( VAR_6 , VAR_1 ) ; assertThat ( METHOD_4 ( ) ) . contains ( STRING_1 + VAR_4 + STRING_2 , STRING_3 + VAR_4 + STRING_5 , STRING_6 + VAR_4 + STRING_2 , <START> STRING_7 + VAR_4 + STRING_2 <END> ) ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 == false ; <END> } 
<START> public void METHOD_1 ( ) { <END> logger . info ( STRING_1 ) ; TYPE_1 < TYPE_2 > query = VAR_1 . METHOD_2 ( STRING_2 , TYPE_2 . class ) ; query . VAR_2 ( STRING_3 , VAR_3 ) ; query . VAR_4 ( ) . stream ( ) . forEach ( m - > { try { VAR_5 . METHOD_3 ( m ) ; } catch ( TYPE_3 e ) { logger . warn ( STRING_4 + m . getId ( ) , e ) ; } } ) ; } 
public Response METHOD_1 ( ANNOTATION_1 ( value = STRING_1 ) ANNOTATION_2 ( STRING_2 ) Long id ) throws TYPE_1 { VAR_1 . METHOD_1 ( id ) ; <START> return Response . VAR_2 ( ) . build ( ) ; <END> } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; final Collection < TYPE_1 > VAR_2 = Collections . VAR_3 ( VAR_1 ) ; when ( VAR_4 . METHOD_3 ( ) ) . METHOD_4 ( VAR_2 ) ; METHOD_5 ( client ) . when ( VAR_5 ) . METHOD_6 ( METHOD_7 ( ) ) ; final List < TYPE_2 > VAR_6 = VAR_5 . METHOD_8 ( VAR_4 , VAR_7 , VAR_8 ) ; <START> METHOD_9 ( VAR_6 . isEmpty ( ) ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { logger . warn ( STRING_1 ) ; } else { METHOD_3 ( VAR_1 . get ( ) ) ; } if ( VAR_2 . METHOD_2 ( ) ) { <START> METHOD_4 ( VAR_2 . get ( ) ) ; <END> } else { logger . warn ( STRING_2 ) ; } } 
public TYPE_1 ( Set < Class < ? > > VAR_2 ) { super ( METHOD_1 ( ) ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
public void METHOD_1 ( ) { String [ ] VAR_1 = new String [ ] { STRING_1 } ; List < String > config = METHOD_2 ( VAR_1 ) ; <START> logger . info ( Arrays . asList ( config ) . toString ( ) ) ; <END> assertTrue ( METHOD_3 ( Object . VAR_2 . METHOD_4 ( ) . getName ( ) , config ) ) ; assertTrue ( METHOD_3 ( TYPE_1 . VAR_2 . METHOD_4 ( ) . getName ( ) , config ) ) ; assertTrue ( METHOD_3 ( STRING_2 , config ) ) ; } 
public TYPE_1 ( Collection VAR_2 , List VAR_3 , Set VAR_4 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , Integer page , Integer VAR_3 ) { <START> Collection < TYPE_2 > VAR_4 = VAR_5 . METHOD_2 ( VAR_2 , page , VAR_3 , TYPE_3 . METHOD_3 ( page , VAR_3 ) ) ; <END> logger . debug ( STRING_1 , VAR_2 , VAR_4 ) ; List < TYPE_4 > VAR_6 = TYPE_3 . METHOD_4 ( VAR_4 ) ; TYPE_1 VAR_7 = new TYPE_1 ( VAR_6 ) ; return VAR_7 ; } 
public List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 . isEmpty ( ) ) { <START> METHOD_2 ( ) ; <END> } return new ArrayList < TYPE_1 > ( VAR_1 . values ( ) ) ; } 
<START> public synchronized TYPE_1 METHOD_1 ( String id ) { <END> return VAR_1 . get ( id ) ; } 
public TYPE_1 update ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = null ; synchronized ( VAR_3 ) { if ( VAR_4 . isEmpty ( ) ) { <START> METHOD_1 ( ) ; <END> } VAR_4 . put ( VAR_1 . getId ( ) , new TYPE_2 ( VAR_1 . getId ( ) , VAR_1 . getName ( ) ) ) ; VAR_2 = VAR_3 . put ( VAR_1 . getId ( ) , VAR_1 ) ; METHOD_2 ( ) ; } return VAR_2 ; } 
public TYPE_2 ( ) { if ( ! VAR_2 . METHOD_1 ( 0 , 1 ) ) { <START> logger . debug ( STRING_1 , VAR_2 . METHOD_2 ( ) , TYPE_1 . class . METHOD_3 ( ) ) ; <END> } } 
public synchronized void clear ( ) { <START> this . VAR_1 . clear ( ) ; <END> this . VAR_2 . clear ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int position ) { <START> if ( ! TYPE_2 . isEmpty ( VAR_1 . METHOD_2 ( ) ) ) { <END> TYPE_3 . start ( TYPE_5 . this , VAR_1 . METHOD_2 ( ) ) ; } else { String url = TYPE_4 . METHOD_3 ( VAR_1 . getId ( ) ) ; TYPE_3 . start ( TYPE_5 . VAR_3 , url ) ; } } 
public void METHOD_1 ( String uri , TYPE_1 VAR_1 ) { int VAR_2 = ( int ) ( INT_1 * TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . VAR_3 ) ; <START> TYPE_3 . METHOD_4 ( context ) <END> . METHOD_5 ( uri ) . listener ( null ) . METHOD_6 ( VAR_2 , VAR_2 ) . METHOD_7 ( ) . error ( R . VAR_4 . VAR_5 ) . METHOD_8 ( VAR_1 ) ; } 
<START> private boolean METHOD_1 ( ) { <END> VAR_1 = TYPE_1 . getInstance ( this ) ; VAR_2 = TYPE_2 . getInstance ( METHOD_2 ( ) ) ; VAR_3 = VAR_1 . METHOD_3 ( ) ; if ( VAR_3 == null ) { return false ; } VAR_4 = VAR_3 . METHOD_4 ( ) ; return true ; } 
public void METHOD_1 ( boolean VAR_1 ) { VAR_2 = VAR_1 ; if ( VAR_3 ) { <START> if ( VAR_1 ) { <END> VAR_4 . METHOD_2 ( false ) ; VAR_4 . METHOD_3 ( true ) ; } else { VAR_4 . METHOD_2 ( true ) ; VAR_4 . METHOD_3 ( VAR_4 . METHOD_4 ( ) ) ; } } } 
private boolean METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( this , VAR_1 , <START> String . valueOf ( VAR_1 . METHOD_3 ( ) ) ) ; <END> } 
protected void METHOD_1 ( ) { <START> if ( VAR_1 . METHOD_2 ( ) ) { <END> TYPE_1 . start ( this , false ) ; } else { TYPE_2 . start ( this ) ; } METHOD_3 ( ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( new TYPE_1 ( ) { <END> @Override public void run ( ) { METHOD_3 ( ) ; METHOD_4 ( ) ; METHOD_5 ( true ) ; } } ) ; } 
<START> public void METHOD_1 ( ) { <END> if ( ! VAR_1 ) { VAR_2 . METHOD_2 ( View . VAR_3 ) ; VAR_2 . METHOD_3 ( TYPE_1 . METHOD_4 ( ) ) ; VAR_2 . start ( ) ; VAR_1 = true ; } } 
<START> public void METHOD_1 ( ) { <END> if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; VAR_2 = false ; } } 
private void METHOD_1 ( ) { if ( ! VAR_1 ) { <START> METHOD_2 ( ) . METHOD_3 ( new TYPE_1 ( ) { <END> @Override public void run ( ) { VAR_2 . METHOD_4 ( View . VAR_3 ) ; VAR_2 . METHOD_5 ( TYPE_2 . METHOD_6 ( ) ) ; VAR_2 . start ( ) ; VAR_1 = true ; } } ) ; } } 
public void METHOD_1 ( TYPE_1 session ) { if ( session != null ) { Log . d ( TAG , STRING_1 ) ; this . VAR_1 = session ; this . VAR_1 . METHOD_2 ( TYPE_3 . this ) ; this . VAR_1 . METHOD_3 ( TYPE_3 . VAR_3 ) ; } else { <START> TYPE_2 . start ( this ) ; <END> METHOD_4 ( ) ; } } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <END> if ( VAR_1 == null ) { super . METHOD_1 ( ) ; } } 
private void METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { boolean VAR_2 = VAR_1 == TYPE_2 . TYPE_3 . VAR_3 ; <START> VAR_4 . setText ( getString ( VAR_2 ? R . string . VAR_5 : R . string . VAR_6 ) ) ; <END> VAR_7 . METHOD_2 ( VAR_2 ? R . VAR_8 . VAR_9 : R . VAR_8 . VAR_10 ) ; } 
private static TYPE_1 METHOD_1 ( final int VAR_1 ) { if ( VAR_1 == TYPE_2 . VAR_3 ) { return TYPE_1 . VAR_4 ; } <START> else if ( VAR_1 == TYPE_2 . VAR_5 ) <END> { return TYPE_1 . VAR_6 ; } else if ( VAR_1 == TYPE_2 . VAR_7 ) { return TYPE_1 . VAR_8 ; } else if ( VAR_1 == TYPE_2 . VAR_9 ) { return TYPE_1 . VAR_10 ; } else { return TYPE_1 . VAR_11 ; } } 
private double METHOD_1 ( TYPE_1 VAR_1 , int x , int y ) { int VAR_2 = VAR_1 . METHOD_2 ( x , y ) ; int VAR_3 = VAR_2 > > > INT_1 & INT_2 ; int VAR_4 = VAR_2 > > > INT_3 & INT_2 ; int VAR_5 = VAR_2 & INT_2 ; <START> if ( VAR_3 == 0 && VAR_4 == 0 && VAR_5 == 0 ) { <END> return 0 ; } double VAR_6 = ( VAR_3 + VAR_5 + VAR_4 ) / FLOAT_1 / FLOAT_2 ; return VAR_6 * VAR_7 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { METHOD_2 ( VAR_1 ) ; <START> if ( ! VAR_1 . METHOD_3 ( ) ) { <END> throw new IllegalArgumentException ( VAR_1 . getKey ( ) . toString ( ) + STRING_1 ) ; } return VAR_2 . METHOD_4 ( VAR_1 , new TYPE_3 < TYPE_2 , TYPE_1 > ( ) { ANNOTATION_1 @Override public TYPE_1 apply ( ANNOTATION_1 TYPE_2 input ) { return TYPE_4 . get ( VAR_1 . getKey ( ) . toString ( ) ) ; } } ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> super ( new File ( VAR_2 . METHOD_1 ( ) + File . VAR_3 + STRING_1 ) ) ; <END> } 
public String getName ( TYPE_1 VAR_1 ) { if ( TYPE_2 . METHOD_1 ( ) . METHOD_2 ( ) ) { final TYPE_3 item = TYPE_7 . TYPE_8 . METHOD_3 ( TYPE_3 . class ) . getValue ( TYPE_5 . METHOD_4 ( VAR_1 . getId ( ) ) ) ; <START> if ( item == null ) { <END> return super . getName ( VAR_1 ) ; } return TYPE_6 . format ( item . VAR_2 ( ) ) ; } return super . getName ( VAR_1 ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return TYPE_3 . METHOD_2 ( TYPE_4 . of ( STRING_1 , <END> TYPE_5 . of ( VAR_1 ) . METHOD_3 ( TYPE_6 . VAR_3 ) ) ) ; } 
public static TYPE_1 METHOD_1 ( String name ) throws IOException { TYPE_1 url = TYPE_2 . class . METHOD_2 ( STRING_1 + name ) ; if ( url == null ) { try { return METHOD_3 ( name ) ; } catch ( Exception e ) { <START> throw new IOException ( STRING_2 + name ) ; <END> } } return url ; } 
public Builder type ( TYPE_1 type ) { METHOD_1 ( type ) ; <START> VAR_1 = type . VAR_2 ( ) ; <END> return this ; } 
public TYPE_1 METHOD_1 ( String input , TYPE_2 context ) throws TYPE_3 { <START> if ( input . startsWith ( STRING_1 ) ) { <END> TYPE_4 VAR_1 = TYPE_5 . request ( ) . METHOD_2 ( ) ; TYPE_6 VAR_2 = TYPE_7 . get ( input . substring ( 2 ) . METHOD_3 ( ) ) ; if ( VAR_2 == null ) { throw new TYPE_3 ( STRING_2 + input . substring ( 2 ) + CHAR_1 ) ; } else { return new TYPE_8 ( VAR_1 , VAR_2 ) ; } } return null ; } 
public void run ( ) { Set < TYPE_1 > VAR_1 = new HashSet < > ( ) ; for ( TYPE_2 VAR_2 : TYPE_3 . METHOD_1 ( ) . METHOD_2 ( ) ) { VAR_1 . add ( VAR_2 . METHOD_3 ( ) ) ; } <START> this . VAR_1 = new TYPE_4 < > ( VAR_1 ) ; <END> } 
<START> public boolean METHOD_1 ( String VAR_1 , Map < String , TYPE_1 > VAR_2 ) { <END> return VAR_1 != null && VAR_2 != null && VAR_2 . containsKey ( VAR_1 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_6 . VAR_3 ) ; VAR_1 . METHOD_3 ( TYPE_5 . VAR_5 ) ; TYPE_2 VAR_6 = VAR_1 . METHOD_4 ( METHOD_5 ( ) , TYPE_6 . VAR_7 , TYPE_5 . VAR_8 ) ; <START> assertThat ( ( Object ) VAR_6 ) <END> . METHOD_6 ( TYPE_3 . class ) ; assertThat ( ( Object ) VAR_6 ) . METHOD_7 ( TYPE_4 . class ) ; assertThat ( VAR_6 . METHOD_8 ( ) ) . METHOD_9 ( TYPE_6 . VAR_3 ) ; } 
TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> TYPE_3 < TYPE_4 > VAR_1 = METHOD_3 ( ) ; TYPE_5 < TYPE_4 > VAR_2 = METHOD_4 ( VAR_1 ) ; return METHOD_5 ( VAR_1 ) . stream ( ) . map ( VAR_3 - > TYPE_2 . METHOD_6 ( VAR_3 . getName ( ) , ( ) - > METHOD_1 ( METHOD_7 ( VAR_1 . METHOD_8 ( ) ) , VAR_2 . METHOD_9 ( VAR_3 ) ) ) ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 factory ) { <END> return factory . from ( TYPE_3 . class ) . METHOD_2 ( TYPE_3 : : METHOD_3 , METHOD_4 ( TYPE_3 : : METHOD_5 ) ) . filter ( ( VAR_1 , VAR_2 ) - > VAR_2 > VAR_1 . METHOD_6 ( ) ) . METHOD_7 ( STRING_1 , TYPE_4 . VAR_4 , ( VAR_1 , VAR_2 ) - > VAR_2 - VAR_1 . METHOD_6 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 . METHOD_2 ( VAR_1 ) ; <END> this . VAR_1 = VAR_1 ; TYPE_3 < TYPE_1 > VAR_2 = METHOD_3 ( ) ; VAR_3 = - VAR_2 . METHOD_4 ( VAR_1 ) ; if ( VAR_4 ) { VAR_5 . METHOD_5 ( VAR_2 . METHOD_6 ( VAR_1 ) ) ; } VAR_6 . METHOD_7 ( ) ; METHOD_8 ( ) ; } 
public TYPE_1 [ ] METHOD_1 ( ) { <START> return Arrays . VAR_1 ( VAR_2 , VAR_2 . length ) ; <END> } 
public TYPE_1 read ( File VAR_1 ) { <START> try ( TYPE_2 VAR_2 = TYPE_3 . METHOD_1 ( VAR_1 . METHOD_2 ( ) ) ) { <END> return read ( VAR_2 ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 + STRING_2 , e ) ; } } 
default < VAR_1 > TYPE_3 < VAR_3 , VAR_1 > VAR_4 ( Class < VAR_1 > VAR_5 , TYPE_2 < VAR_3 , VAR_1 > VAR_7 ) { if ( VAR_7 instanceof TYPE_1 ) { TYPE_1 < VAR_3 , VAR_1 > VAR_9 = ( TYPE_1 < VAR_3 , VAR_1 > ) VAR_7 ; return VAR_4 ( VAR_5 ) . filter ( VAR_9 . VAR_10 ( ) ) ; } else { <START> return VAR_4 ( VAR_11 ( ) . from ( VAR_5 ) , VAR_7 ) ; <END> } } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 != VAR_1 . METHOD_2 ( ) ) { <START> return VAR_2 < VAR_1 . METHOD_2 ( ) ? - 1 : 1 ; <END> } else { return Integer . VAR_3 ( VAR_4 , VAR_1 . METHOD_3 ( ) ) ; } } 
public List < Object > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
<START> public static < TYPE_1 > TYPE_2 < TYPE_1 > create ( TYPE_3 VAR_1 ) { <END> return new TYPE_4 < > ( VAR_1 ) ; } 
public TYPE_6 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 < TYPE_2 , TYPE_4 > parent , TYPE_5 < TYPE_4 > VAR_3 ) { <START> super ( VAR_2 , parent . VAR_4 ( ) . filter ( VAR_3 ) ) ; <END> this . parent = parent ; } 
public TYPE_4 ( List < TYPE_1 < TYPE_2 , TYPE_3 > > VAR_2 ) { this . VAR_2 = VAR_2 ; if ( VAR_2 . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING_1 + VAR_2 + STRING_2 ) ; <START> } <END> } 
public TYPE_5 ( List < TYPE_1 < TYPE_2 , TYPE_3 , TYPE_4 > > VAR_2 ) { this . VAR_2 = VAR_2 ; if ( VAR_2 . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING_1 + VAR_2 + STRING_2 ) ; <START> } <END> } 
protected TYPE_3 ( long VAR_2 , TYPE_1 VAR_3 , <START> TYPE_2 VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; if ( VAR_2 <= INT_1 ) { throw new IllegalArgumentException ( STRING_1 + VAR_2 + STRING_2 ) ; } this . VAR_4 = VAR_4 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; if ( VAR_2 != null ) { VAR_3 = VAR_3 . METHOD_2 ( VAR_2 ) ; } else { TYPE_2 VAR_4 = VAR_3 . METHOD_3 ( VAR_5 ) ; VAR_3 = VAR_3 . METHOD_2 ( VAR_4 ) ; } <START> logger . debug ( VAR_3 . METHOD_4 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; <START> this . VAR_2 = null ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = null ; VAR_3 = VAR_4 ; <START> VAR_5 = null ; <END> } 
<START> public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { <END> if ( VAR_2 . isEmpty ( ) ) { return ; } final TYPE_3 < TYPE_2 > event = new TYPE_3 < > ( VAR_3 ) ; for ( TYPE_4 < TYPE_2 > listener : VAR_2 ) { listener . VAR_4 ( event ) ; } } 
private void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 . METHOD_2 ( ) ) { TYPE_2 VAR_3 = TYPE_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) * INT_1 ) ; <START> TYPE_2 VAR_4 = TYPE_2 . METHOD_3 ( <END> ( VAR_1 . METHOD_4 ( ) + VAR_1 . VAR_5 ) * INT_1 ) ; METHOD_5 ( TYPE_3 . format ( VAR_3 ) ) ; } } 
public boolean METHOD_1 ( ) { <START> return VAR_1 != null && VAR_1 . METHOD_2 ( ) ; <END> } 
public String toString ( ) { <START> return VAR_1 . toString ( ) + STRING_1 + VAR_2 . toString ( ) ; <END> } 
public void METHOD_1 ( ) { <START> boolean VAR_1 = false ; <END> TYPE_1 config = new TYPE_1 ( ) ; config . VAR_2 ( VAR_3 ) ; config . VAR_4 ( VAR_5 ) ; config . VAR_6 ( STRING_1 ) ; TYPE_2 VAR_7 = config . build ( ) ; } 
protected int METHOD_1 ( TYPE_1 VAR_1 ) { <START> return this . METHOD_2 ( VAR_1 ) + this . METHOD_3 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { this . VAR_1 = new TYPE_1 ( map ) ; <START> VAR_1 . METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( final TYPE_1 < ? > msg , final int VAR_1 ) { assertNotNull ( msg ) ; assertNotNull ( msg . VAR_2 ( ) ) ; assertTrue ( msg . VAR_2 ( ) instanceof TYPE_2 ) ; <START> assertEquals ( ( ( TYPE_2 ) msg . VAR_2 ( ) ) . METHOD_2 ( ) , VAR_1 ) ; <END> assertNotNull ( ( ( TYPE_2 ) msg . VAR_2 ( ) ) . METHOD_3 ( ) ) ; } 
private void METHOD_1 ( final TYPE_1 < ? > msg , final TYPE_3 . TYPE_4 VAR_1 , final String VAR_2 ) { assertNotNull ( msg ) ; assertNotNull ( msg . VAR_3 ( ) ) ; assertTrue ( msg . VAR_3 ( ) instanceof TYPE_3 ) ; assertEquals ( ( ( TYPE_3 ) msg . VAR_3 ( ) ) . METHOD_2 ( ) , <START> VAR_1 ) ; <END> assertNotNull ( ( ( ( TYPE_3 ) msg . VAR_3 ( ) ) . METHOD_3 ( ) ) . getName ( ) , VAR_2 ) ; } 
private void METHOD_1 ( final TYPE_1 < ? > msg , final TYPE_2 VAR_1 ) { assertNotNull ( msg ) ; assertNotNull ( msg . VAR_2 ( ) ) ; assertTrue ( msg . VAR_2 ( ) instanceof TYPE_3 ) ; <START> assertEquals ( ( ( TYPE_3 ) msg . VAR_2 ( ) ) . METHOD_2 ( ) , VAR_1 ) ; <END> } 
private void METHOD_1 ( ) { Assert . assertEquals ( true , VAR_1 . size ( ) == VAR_2 ) ; Iterator < ? > it = VAR_1 . iterator ( ) ; int index = 0 ; while ( it . hasNext ( ) ) { Assert . assertEquals ( index , it . next ( ) ) ; <START> index ++ ; <END> } } 
private List < String > METHOD_1 ( String text , int VAR_1 ) { <START> List < String > VAR_2 = new ArrayList < String > ( text . length ( ) + VAR_1 - 1 / VAR_1 ) ; <END> for ( int VAR_3 = 0 ; VAR_3 < text . length ( ) ; VAR_3 += VAR_1 ) { String substring = text . substring ( VAR_3 , Math . VAR_4 ( text . length ( ) , VAR_3 + VAR_1 ) ) ; VAR_2 . add ( substring ) ; } return VAR_2 ; } 
protected Object METHOD_1 ( TYPE_1 < ? > VAR_1 ) { <START> if ( ! this . VAR_2 . METHOD_2 ( true ) ) { <END> METHOD_3 ( ) ; } return VAR_3 . METHOD_4 ( VAR_1 ) ; } 
<START> public TYPE_2 ( ) { <END> this . VAR_2 = new TYPE_1 ( ) ; } 
public void METHOD_1 ( TYPE_1 < ? > message ) throws TYPE_2 { try { TYPE_3 VAR_1 = METHOD_2 ( TYPE_3 . METHOD_3 ( this . VAR_2 , message ) . METHOD_4 ( this . VAR_3 ) ) ; String [ ] VAR_4 = VAR_1 . METHOD_5 ( ) ; logger . debug ( STRING_1 + message . VAR_5 ( ) ) ; <START> logger . debug ( STRING_2 + Arrays . toString ( VAR_4 ) ) ; <END> } catch ( Exception e ) { throw new RuntimeException ( STRING_3 , e ) ; } } 
<START> private char [ ] METHOD_1 ( File file ) throws IOException { <END> TYPE_1 is = new TYPE_1 ( file ) ; try { return METHOD_2 ( is ) ; } finally { is . close ( ) ; } } 
public void write ( TYPE_1 request , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <START> TYPE_4 . METHOD_1 ( stream , VAR_1 , VAR_2 ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = new TYPE_3 ( ) ; int VAR_3 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; int VAR_4 = VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; <START> log . info ( STRING_1 , VAR_3 , VAR_4 ) ; <END> VAR_2 . METHOD_5 ( VAR_3 ) ; VAR_2 . METHOD_6 ( VAR_4 ) ; return new TYPE_1 ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { try { VAR_1 . METHOD_2 ( new Date ( ) ) ; VAR_2 . METHOD_1 ( VAR_1 ) ; <START> System . out . println ( VAR_1 . METHOD_3 ( ) ) ; <END> } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } } 
boolean METHOD_1 ( List < TYPE_1 > VAR_1 , boolean result ) throws IOException { for ( TYPE_1 VAR_2 : VAR_1 ) { String VAR_3 = VAR_2 . METHOD_2 ( ) ; <START> System . out . println ( VAR_3 ) ; <END> VAR_2 = METHOD_3 ( VAR_2 ) ; VAR_2 = METHOD_4 ( VAR_2 ) ; if ( VAR_4 . METHOD_5 ( VAR_2 ) ) { VAR_2 . METHOD_6 ( VAR_5 ) ; VAR_2 . METHOD_7 ( VAR_3 ) ; VAR_4 . METHOD_8 ( VAR_2 ) ; } else { result = false ; } } return result ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) throws TYPE_2 { try { for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_3 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) == null ) { VAR_3 . METHOD_4 ( VAR_2 ) ; } else { VAR_3 . METHOD_5 ( VAR_2 ) ; } } <START> VAR_3 . METHOD_6 ( VAR_1 ) ; <END> } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } } 
public Boolean METHOD_1 ( ) { <START> boolean VAR_1 = true ; <END> try { TYPE_1 VAR_2 = METHOD_2 ( VAR_3 ) ; VAR_1 = VAR_2 . METHOD_3 ( ) ; } catch ( TYPE_2 e ) { Log . e ( getClass ( ) . METHOD_4 ( ) , STRING_1 , e ) ; } return VAR_1 ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { <START> TYPE_2 . METHOD_2 ( VAR_2 . METHOD_3 ( ) , STRING_1 , TYPE_2 . VAR_3 ) . METHOD_4 ( ) ; <END> return ; } if ( VAR_2 . METHOD_5 ( ) != null ) { VAR_2 . METHOD_5 ( ) . METHOD_6 ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 = VAR_1 ; <END> } 
protected void METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> TYPE_1 . METHOD_2 ( TYPE_2 . context , STRING_2 , TYPE_1 . VAR_2 ) . METHOD_3 ( ) ; } 
protected void METHOD_1 ( Integer [ ] result ) { <START> System . out . println ( STRING_1 ) ; <END> if ( result [ 0 ] == VAR_1 ) { TYPE_1 . METHOD_2 ( TYPE_2 . context , STRING_2 + result [ 1 ] + STRING_3 , TYPE_1 . VAR_3 ) . METHOD_3 ( ) ; } else { TYPE_1 . METHOD_2 ( TYPE_2 . context , STRING_4 + result [ 1 ] + STRING_5 + result [ 2 ] , TYPE_1 . VAR_3 ) . METHOD_3 ( ) ; } VAR_4 = false ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( ) ; super . METHOD_1 ( ) ; if ( METHOD_4 ( ) != null ) { <START> System . out . println ( STRING_1 + METHOD_4 ( ) . toString ( ) ) ; <END> } else { System . out . println ( STRING_2 ) ; } } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( View . VAR_2 ) ; VAR_3 . METHOD_3 ( ) ; if ( METHOD_4 ( ) != null ) { System . out . println ( STRING_1 + METHOD_4 ( ) . toString ( ) ) ; } else { <START> System . out . println ( STRING_2 ) ; <END> } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( METHOD_2 ( this . getId ( ) . toString ( ) , <END> STRING_1 ) ) ; } 
<START> public static void METHOD_1 ( TYPE_1 from , TYPE_1 to ) { <END> to . VAR_1 = from . VAR_1 ; } 
public boolean equals ( Object obj ) { <START> if ( obj instanceof TYPE_1 ) { <END> TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return TYPE_2 . METHOD_1 ( this . METHOD_2 ( ) , VAR_1 . METHOD_2 ( ) ) ; } return false ; } 
public void METHOD_1 ( Collection < String > VAR_1 , Collection < String > VAR_2 , Collection < String > VAR_3 ) { if ( VAR_2 == null ) { VAR_2 = VAR_1 ; } String msg = METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; METHOD_3 ( msg ) ; <START> METHOD_4 ( VAR_1 , VAR_2 , VAR_3 ) ; <END> } 
public int METHOD_1 ( int VAR_1 ) { int VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 , VAR_3 ) ; if ( VAR_2 < 0 ) { VAR_4 ++ ; <START> VAR_3 = VAR_1 ; <END> } return METHOD_3 ( VAR_1 , true ) ; } 
public synchronized TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 ) { int VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_3 VAR_3 = VAR_4 . get ( VAR_2 ) ; if ( VAR_3 != null ) { return METHOD_3 ( VAR_3 , VAR_1 ) ; } VAR_3 = new TYPE_3 ( VAR_1 ) ; <START> if ( ! VAR_4 . METHOD_4 ( VAR_2 , VAR_3 ) ) <END> return null ; return new TYPE_1 ( VAR_3 , true ) ; } 
<START> public Integer METHOD_1 ( String key , int VAR_1 ) { <END> return METHOD_2 ( key , Integer : : parseInt , VAR_1 ) ; } 
<START> public Response METHOD_1 ( Response . TYPE_2 status , TYPE_1 VAR_2 , T exception ) { <END> METHOD_2 ( exception , VAR_2 ) ; return METHOD_3 ( status , exception ) ; } 
private static boolean METHOD_1 ( ) { String VAR_1 = TYPE_1 . METHOD_2 ( ) ; <START> return VAR_1 == null || TYPE_2 . equals ( VAR_1 ) ; <END> } 
public String [ ] METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( new String [ VAR_1 . size ( ) ] ) ; <END> } 
public static Date METHOD_1 ( String VAR_1 , String format ) { <START> return METHOD_1 ( VAR_1 , new TYPE_1 ( format , TYPE_2 . METHOD_2 ( ) ) ) ; <END> } 
public static TYPE_1 < ? > METHOD_1 ( TYPE_2 method ) { TYPE_1 < ? > VAR_1 = TYPE_3 . METHOD_2 ( method ) ; <START> if ( VAR_1 == null ) { <END> return METHOD_3 ( method ) . METHOD_4 ( null ) ; } return VAR_1 ; } 
<START> public T METHOD_1 ( ) { <END> T value = this . value ; if ( this . VAR_1 ) { return value ; } value = VAR_2 . get ( ) ; this . value = value ; this . VAR_1 = true ; return value ; } 
private Optional < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , String name , List < TYPE_3 > VAR_2 ) { TYPE_4 VAR_3 = VAR_1 . METHOD_2 ( ) ; Optional < TYPE_5 > VAR_4 = VAR_3 . get ( name , VAR_2 ) ; <START> return VAR_4 . map ( TYPE_6 : : new ) ; <END> } 
<START> <END> public <END> <END> TYPE_4 <END> ( TYPE_1 <END> <END> VAR_2 , <END> <END> TYPE_2 <END> < ? <END> <END> super <END> TYPE_3 <END> , ? <END> extends 
<START> Class < ? > METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 instanceof TYPE_2 ) { try { return ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( VAR_2 ) ; } catch ( TYPE_3 e ) { throw new IllegalStateException ( STRING_1 , e ) ; } } else { return METHOD_3 ( VAR_1 ) ; } } 
<START> private TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( TYPE_3 . class ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; return VAR_1 ; } 
public TYPE_3 ( Class < ? > VAR_2 ) { super ( VAR_2 ) ; Assert . VAR_3 ( TYPE_1 . class . METHOD_1 ( VAR_2 ) , VAR_4 ) ; <START> Class < ? extends TYPE_2 > VAR_5 = METHOD_2 ( VAR_2 ) ; <END> Class < ? > VAR_6 = METHOD_3 ( VAR_2 ) ; Assert . VAR_7 ( VAR_5 , STRING_1 ) ; Assert . VAR_7 ( VAR_6 , STRING_2 ) ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; } 
public Optional < TYPE_1 > METHOD_1 ( ) { <START> return null ; <END> } 
public String METHOD_1 ( TYPE_1 request , TYPE_2 model , ANNOTATION_1 TYPE_3 VAR_1 , TYPE_4 VAR_2 ) throws IOException { TYPE_5 VAR_3 = VAR_4 . get ( VAR_1 , VAR_2 ) . METHOD_2 ( STRING_1 ) . METHOD_3 ( request , model ) . METHOD_4 ( model ) . METHOD_5 ( ) ; TYPE_6 VAR_5 = METHOD_6 ( VAR_1 , VAR_3 ) ; model . VAR_6 ( STRING_2 , VAR_5 . VAR_7 ) ; model . VAR_6 ( STRING_3 , VAR_5 . VAR_8 ) ; <START> model . VAR_6 ( STRING_4 , true ) ; <END> return VAR_1 + STRING_5 ; } 
private String METHOD_1 ( Map < String , Object > VAR_1 ) { <START> return ( String ) ( ( Map < String , Object > ) ( ( Map < String , Object > ) VAR_1 . get ( STRING_1 ) ) . get ( STRING_2 ) ) . get ( STRING_3 ) ; <END> } 
public Map < ? , ? > METHOD_1 ( List < String > VAR_1 ) throws IOException { String VAR_2 = TYPE_1 . METHOD_2 ( STRING_1 ) . METHOD_3 ( VAR_1 ) ; TYPE_2 . Builder query = TYPE_2 . builder ( ) . METHOD_4 ( VAR_2 ) . METHOD_5 ( 0 ) . METHOD_6 ( VAR_1 . size ( ) ) <START> . METHOD_7 ( TYPE_3 . TYPE_4 . VAR_5 ) ; <END> return METHOD_8 ( query . build ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws IOException { String VAR_3 = STRING_1 <START> + TYPE_2 . METHOD_2 ( VAR_2 + VAR_1 . METHOD_3 ( ) ) ; <END> return TYPE_3 . METHOD_4 ( cache , VAR_3 , ( ) - > METHOD_5 ( VAR_1 , VAR_2 ) ) ; } 
private boolean METHOD_1 ( String query ) { <START> return Arrays . stream ( TYPE_1 . class . METHOD_2 ( ) ) <END> . METHOD_3 ( e - > query . contains ( e . text ) ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , Set < String > VAR_3 ) { this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 ) ; <START> this . VAR_3 = TYPE_3 . METHOD_2 ( TYPE_2 . METHOD_1 ( VAR_3 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { Set < String > VAR_2 = new TYPE_2 . Builder < String > ( ) . addAll ( VAR_3 ) . addAll ( VAR_1 . VAR_3 ) . build ( ) ; Set < String > VAR_4 = new TYPE_2 . Builder < String > ( ) . addAll ( VAR_5 ) . addAll ( VAR_1 . VAR_5 ) . build ( ) ; <START> return new TYPE_1 ( VAR_6 , VAR_7 , VAR_2 , VAR_4 ) ; <END> } 
public List < Object > METHOD_1 ( TYPE_1 context , TYPE_2 VAR_1 , TYPE_3 VAR_2 , int start ) throws IOException { Map < ? , ? > result = context . VAR_3 . METHOD_2 ( <START> Collections . VAR_4 ( VAR_2 . METHOD_3 ( ) ) , start , VAR_1 . VAR_5 , <END> TYPE_5 . TYPE_4 . VAR_8 ) ; return METHOD_4 ( result ) ; } 
<START> TYPE_1 ( String VAR_2 , String VAR_3 ) { <END> this . VAR_4 = VAR_2 ; this . VAR_5 = VAR_3 ; } 
private TYPE_2 ( String VAR_2 , Optional < Integer > VAR_3 ) { this . VAR_2 = TYPE_1 . METHOD_1 ( VAR_2 ) ; <START> this . VAR_3 = VAR_3 ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 . METHOD_2 ( ) ) { <START> if ( ! VAR_3 . METHOD_3 ( VAR_2 , VAR_1 ) ) { <END> VAR_3 . put ( VAR_2 , VAR_1 ) ; } } } 
private void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { TYPE_1 o = list ( VAR_1 ) . get ( 0 ) ; assertEquals ( STRING_1 , o . getId ( ) . getId ( ) ) ; assertEquals ( STRING_2 , o . getName ( ) ) ; METHOD_2 ( o . VAR_2 ( ) ) ; METHOD_2 ( o . VAR_3 ( ) ) ; <START> assertEquals ( 1 , VAR_1 . size ( ) ) ; <END> } 
public static String METHOD_1 ( TYPE_3 . TYPE_5 . TYPE_7 is ) { <START> TYPE_3 . TYPE_4 . TYPE_6 VAR_3 = null ; <END> String result = "" ; try { VAR_3 = new TYPE_3 . TYPE_4 . TYPE_6 ( is ) . METHOD_2 ( STRING_1 ) ; result = VAR_3 . hasNext ( ) ? VAR_3 . next ( ) : "" ; VAR_3 . close ( ) ; } finally { if ( VAR_3 != null ) VAR_3 . close ( ) ; } return result ; } 
public void METHOD_1 ( String s ) { <START> if ( s != null && ! s . equals ( "" ) ) <END> VAR_1 = TYPE_1 . parse ( s ) ; else VAR_1 = TYPE_1 . METHOD_2 ( ) ; } 
public String METHOD_1 ( ) { if ( VAR_1 != null && VAR_1 . length ( ) > 0 ) { <START> return VAR_1 . substring ( 0 , VAR_1 . METHOD_2 ( CHAR_1 ) ) ; <END> } return VAR_2 . getId ( ) . METHOD_3 ( ) ; } 
public synchronized void METHOD_1 ( int VAR_1 ) { if ( VAR_1 >= VAR_2 . content . TYPE_1 . VAR_4 ) { METHOD_2 ( ) ; } else if ( VAR_1 >= VAR_2 . content . TYPE_1 . VAR_5 ) { METHOD_3 ( VAR_6 / 2 ) ; <START> } else if ( VAR_1 == VAR_2 . content . TYPE_1 . VAR_7 ) { <END> METHOD_3 ( VAR_6 / 2 ) ; } } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return TYPE_2 . VAR_3 . VAR_4 >= TYPE_2 . VAR_5 . VAR_6 <END> && VAR_1 . METHOD_2 ( ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( ) ; TYPE_1 . METHOD_3 ( false ) ; try { TYPE_1 VAR_1 = TYPE_1 . get ( METHOD_4 ( ) ) ; List < TYPE_2 < TYPE_3 , ? > > VAR_2 = VAR_1 . METHOD_5 ( ) . METHOD_6 ( METHOD_7 ( TYPE_3 . class ) ) ; assertEquals ( 1 , VAR_2 . size ( ) ) ; assertTrue ( VAR_2 . get ( 0 ) instanceof TYPE_4 ) ; } finally { <START> TYPE_1 . METHOD_3 ( true ) ; <END> } } 
public int METHOD_1 ( int n ) { int VAR_1 = - 1 ; <START> if ( 0 <= n && n < VAR_2 . VAR_3 ) { <END> VAR_1 = VAR_2 . VAR_4 . get ( n ) . VAR_1 ; } return VAR_1 ; } 
public TYPE_1 ( TYPE_2 VAR_1 , TYPE_3 TYPE_5 ) { <START> TYPE_4 . METHOD_1 ( ! ( VAR_1 instanceof TYPE_1 ) ) ; <END> this . VAR_1 = VAR_1 ; this . VAR_3 = TYPE_5 ; } 
<START> private boolean METHOD_1 ( ) { <END> if ( VAR_1 >= VAR_2 . size ( ) ) { return false ; } else return true ; } 
<START> public static Collection < Integer > METHOD_1 ( ) <END> { final Set < Integer > VAR_1 = new HashSet < > ( ) ; final TYPE_1 VAR_2 = TYPE_1 . getInstance ( ) ; for ( final String VAR_3 : VAR_2 . METHOD_2 ( ) ) { VAR_1 . add ( VAR_2 . METHOD_3 ( VAR_3 ) ) ; } return VAR_1 ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) throws Exception { info ( STRING_1 + VAR_2 + STRING_2 ) ; try { TYPE_1 . METHOD_2 ( VAR_3 , new TYPE_2 ( VAR_1 ) ) ; METHOD_3 ( VAR_2 ) ; } catch ( TYPE_3 e ) { } catch ( TYPE_4 e ) { <START> METHOD_3 ( STRING_3 ) ; <END> } } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) throws Exception { info ( STRING_1 + VAR_2 + STRING_2 ) ; try { TYPE_1 . METHOD_2 ( VAR_3 , new TYPE_2 ( VAR_1 ) ) ; } catch ( TYPE_3 e ) { METHOD_3 ( VAR_2 ) ; } catch ( TYPE_4 e ) { <START> METHOD_3 ( STRING_3 ) ; <END> } } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { info ( STRING_1 ) ; VAR_2 . METHOD_2 ( ) ; <START> info ( STRING_2 ) ; <END> VAR_3 . METHOD_3 ( ) ; METHOD_4 ( VAR_1 ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { METHOD_2 ( VAR_1 ) ; if ( VAR_2 . METHOD_3 ( ) ) { info ( STRING_1 ) ; try { VAR_2 . METHOD_4 ( ) ; } catch ( TYPE_2 e ) { info ( STRING_2 ) ; <START> throw new TYPE_2 ( STRING_3 ) ; <END> } } METHOD_5 ( ) ; info ( STRING_4 ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) { info ( STRING_1 ) ; VAR_2 . METHOD_2 ( ) ; <START> info ( STRING_2 ) ; <END> VAR_3 . METHOD_3 ( ) ; info ( STRING_3 ) ; VAR_3 . METHOD_4 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( ) ; <START> TYPE_2 VAR_1 = new TYPE_2 ( ) . METHOD_3 ( STRING_1 ) . METHOD_4 ( STRING_2 ) ; <END> TYPE_2 VAR_2 = TYPE_3 . METHOD_5 ( VAR_1 ) ; Assert . assertTrue ( TYPE_3 . METHOD_6 ( VAR_2 ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 user = TYPE_2 . METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( user ) ; <START> TYPE_2 . METHOD_3 ( ) ; <END> } 
public TYPE_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 . addAll ( VAR_1 . VAR_2 ) ; <END> this . VAR_3 = null ; } 
private TYPE_1 ( TYPE_1 that ) { <START> VAR_1 . addAll ( that . VAR_1 ) ; <END> VAR_2 = that . VAR_2 ; } 
<START> public TYPE_1 ( ) { <END> VAR_2 = null ; VAR_3 = null ; } 
public TYPE_1 METHOD_1 ( TYPE_2 < Class < ? > > VAR_1 ) { <START> VAR_1 . iterator ( ) . METHOD_2 ( this : : METHOD_1 ) ; <END> return this ; } 
public < R , TYPE_1 extends Exception > R METHOD_1 ( TYPE_2 < R , TYPE_1 > VAR_1 ) throws TYPE_1 { <START> if ( METHOD_2 ( ) ) { <END> return VAR_1 . METHOD_3 ( this ) ; } return VAR_2 . METHOD_1 ( this , VAR_1 ) ; } 
private TYPE_1 METHOD_1 ( ) { if ( TYPE_2 . VAR_2 ) { <START> return METHOD_2 ( 0 , TYPE_3 . VAR_4 ) ; <END> } else { return METHOD_2 ( 0 , TYPE_3 . VAR_5 ) ; } } 
public String METHOD_1 ( Class < ? > VAR_1 , TYPE_1 method , TYPE_2 config ) { TYPE_3 < String , String > VAR_2 = key - > { String VAR_3 = key . isEmpty ( ) ? method . getName ( ) : key ; <START> return org . VAR_4 . VAR_5 . VAR_6 . VAR_7 . TYPE_5 . METHOD_2 ( VAR_1 , VAR_3 ) ; <END> } ; return TYPE_4 . METHOD_3 ( method , VAR_2 ) . METHOD_4 ( ( ) - > new IllegalStateException ( String . format ( STRING_1 , method ) ) ) ; } 
public TYPE_1 map ( TYPE_2 VAR_1 , int VAR_2 , TYPE_3 ctx ) throws TYPE_4 { String name = ctx . VAR_3 ( String . VAR_4 ) . METHOD_1 ( ( ) - > new TYPE_5 ( STRING_1 , ctx ) ) . map ( VAR_1 , VAR_2 , ctx ) ; <START> return name == null ? null : VAR_5 . METHOD_2 ( name . VAR_6 ( ) , VAR_7 - > METHOD_3 ( VAR_8 , name , ctx ) ) ; <END> } 
public TYPE_1 METHOD_1 ( String key , Object value ) { <START> synchronized ( this ) { <END> VAR_1 . put ( key , value ) ; } return this ; } 
public TYPE_1 METHOD_1 ( final Map < String , ? > values ) { if ( values != null ) { <START> synchronized ( this ) { <END> VAR_1 . METHOD_2 ( values ) ; } } return this ; } 
public static Type METHOD_1 ( Type type , Type VAR_1 ) { <START> return TYPE_1 . METHOD_1 ( TYPE_1 . METHOD_2 ( type ) , TYPE_1 . METHOD_2 ( VAR_1 ) ) . getType ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( ) . METHOD_2 ( VAR_1 ) ; <END> } 
public static < T > Optional < T > METHOD_1 ( TYPE_1 < Optional < T > > ... VAR_1 ) { return TYPE_2 . of ( VAR_1 ) . METHOD_2 ( VAR_2 - > METHOD_3 ( VAR_2 . get ( ) ) ) . METHOD_4 ( ) ; <START> } <END> 
<START> protected TYPE_3 ( Class < T > type , String VAR_2 ) { <END> this ( type , ( TYPE_1 < T > ) TYPE_2 . METHOD_1 ( type ) , VAR_2 ) ; } 
public void METHOD_1 ( ) { VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( TYPE_1 . METHOD_4 ( TYPE_2 . class , TYPE_3 . class , TYPE_3 : : builder ) ) ; <END> VAR_1 . execute ( STRING_1 ) ; VAR_3 = VAR_1 . METHOD_5 ( TYPE_4 . class ) ; } 
public static < T , TYPE_1 > TYPE_2 < Type , TYPE_3 < T > > METHOD_1 ( Class < T > VAR_1 , TYPE_4 < TYPE_1 > builder ) { <START> return t - > ( TYPE_3 < T > ) TYPE_5 . METHOD_2 ( t , x - > new TYPE_6 < > ( t , VAR_1 , builder ) ) ; <END> } 
public TYPE_1 METHOD_1 ( String key , Object value ) { if ( value != null ) { VAR_1 . put ( key , value ) ; <START> } <END> return this ; } 
public static File METHOD_1 ( Class < ? > type ) { try { String VAR_1 = type . getName ( ) . METHOD_2 ( STRING_1 , STRING_2 ) ; TYPE_1 resource = type . VAR_2 ( ) . METHOD_3 ( VAR_1 ) ; if ( resource != null ) { return new File ( resource . VAR_3 ( ) ) ; } } catch ( TYPE_2 VAR_4 ) { } <START> return null ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_1 . create ( STRING_1 ) ; VAR_1 . METHOD_2 ( new TYPE_2 ( ) ) ; VAR_2 = VAR_1 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_2 - > { <START> VAR_2 . execute ( STRING_2 ) ; <END> VAR_2 . execute ( STRING_3 ) ; } ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_1 . create ( STRING_1 ) ; VAR_1 . METHOD_2 ( new TYPE_2 ( ) ) ; VAR_2 = VAR_1 . METHOD_3 ( ) ; <START> VAR_2 . METHOD_4 ( VAR_2 - > { <END> VAR_2 . execute ( STRING_2 ) ; } ) ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( TYPE_2 . contains ( VAR_1 ) ) <END> { VAR_1 . close ( ) ; } } 
<START> public static TYPE_1 METHOD_1 ( String VAR_1 , Class < ? > ... VAR_2 ) { <END> return METHOD_2 ( METHOD_3 ( ) . VAR_3 , VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . execute ( STRING_1 , 1 , STRING_2 ) ; VAR_1 . execute ( STRING_1 , 2 , STRING_3 ) ; List < Map < String , Object > > VAR_2 = VAR_1 . METHOD_2 ( STRING_4 ) <START> . METHOD_3 ( 1 ) <END> . METHOD_4 ( ) . list ( ) ; assertThat ( VAR_2 ) . METHOD_5 ( 2 ) ; assertThat ( VAR_2 ) . METHOD_6 ( TYPE_1 . class ) ; } 
private TYPE_1 < Class < ? extends TYPE_2 > > METHOD_1 ( TYPE_3 VAR_1 ) { List < Class < ? extends TYPE_2 > > VAR_2 = Arrays . asList ( VAR_1 . value ( ) ) ; <START> TYPE_4 < Class < ? extends TYPE_2 > > TYPE_5 = type - > { <END> int index = VAR_2 . METHOD_2 ( type ) ; return index == - 1 ? VAR_2 . size ( ) : index ; } ; return TYPE_1 . METHOD_3 ( TYPE_5 : : METHOD_4 ) ; } 
private static TYPE_1 METHOD_1 ( Class < ? > type , TYPE_2 method , TYPE_3 VAR_1 , Integer i ) { return ( VAR_2 , args ) - > METHOD_2 ( VAR_2 ) . METHOD_3 ( null , type , method , VAR_1 , i ) <START> . apply ( VAR_2 , args [ i ] ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( STRING_1 ) . bind ( 0 , 5 ) . METHOD_3 ( TYPE_1 . class ) <START> . METHOD_4 ( ) ; <END> } 
public Optional < TYPE_1 < ? > > build ( Type type , TYPE_2 config ) { Class < ? > VAR_1 = TYPE_3 . METHOD_1 ( type ) ; if ( ImmutableList . VAR_2 . equals ( VAR_1 ) ) { return TYPE_3 . METHOD_2 ( type , ImmutableList . VAR_2 ) <START> . METHOD_3 ( t - > config . get ( TYPE_4 . VAR_2 ) . METHOD_4 ( type , config ) ) <END> . map ( TYPE_5 : : new ) ; } return Optional . empty ( ) ; } 
public TYPE_3 ( TYPE_1 < TYPE_2 > VAR_2 ) { this . VAR_2 = VAR_2 ; try { <START> this . VAR_3 = Class . VAR_4 ( STRING_1 ) ; <END> this . VAR_5 = VAR_3 . METHOD_1 ( STRING_2 , new Class [ ] { int . class , int . class } ) ; this . VAR_6 = VAR_3 . METHOD_1 ( STRING_3 ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
public TYPE_1 METHOD_1 ( Class < ? > VAR_1 , TYPE_2 method ) { <START> return ( obj , m , args , VAR_2 ) - > { <END> return STRING_1 ; } ; } 
public < T > T METHOD_1 ( String column , TYPE_1 < T > type ) { <START> return ( T ) METHOD_1 ( column , ( Type ) type ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 < ? > VAR_1 = new TYPE_2 ( ) ; TYPE_3 config = new TYPE_3 ( ) ; config . VAR_2 . METHOD_2 ( VAR_1 ) ; final TYPE_4 context = new TYPE_4 ( config ) ; <START> assertThat ( context . VAR_3 ( TYPE_5 . class ) . get ( ) ) . METHOD_3 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_1 . create ( ( ) - > { throw new TYPE_2 ( ) ; } ) ; try { VAR_1 . METHOD_2 ( ) ; METHOD_3 ( STRING_1 ) ; } catch ( TYPE_3 e ) { <START> assertThat ( e ) . METHOD_4 ( ) ; <END> } } 
public void METHOD_1 ( ) throws Exception { try { VAR_1 . METHOD_2 ( STRING_1 ) . list ( ) ; METHOD_3 ( STRING_2 ) ; } catch ( TYPE_1 e ) { <START> assertThat ( e ) . METHOD_4 ( ) ; <END> } catch ( Exception e ) { METHOD_3 ( STRING_3 ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = db . VAR_2 ( ) ; try { VAR_1 . METHOD_2 ( ( VAR_3 , status ) - > { throw new IllegalArgumentException ( ) ; } ) ; } catch ( TYPE_2 e ) { METHOD_3 ( STRING_1 ) ; } catch ( IllegalArgumentException e ) { <START> assertThat ( e ) . METHOD_4 ( ) ; <END> } catch ( Exception e ) { METHOD_3 ( STRING_2 ) ; } } 
public boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> return VAR_2 . METHOD_2 ( STRING_1 , "" ) . METHOD_3 ( VAR_3 ) . equals ( VAR_1 . METHOD_3 ( VAR_3 ) ) ; <END> } 
public void METHOD_1 ( ) { final TYPE_1 s = VAR_1 . METHOD_2 ( TYPE_1 . class ) ; final List < TYPE_2 > out = s . get ( new ArrayList < Object > ( ) ) ; <START> Assert . assertEquals ( 4 , out . size ( ) ) ; <END> } 
public void METHOD_1 ( ) { final TYPE_1 s = VAR_1 . METHOD_2 ( TYPE_1 . class ) ; <START> final List < TYPE_2 > out = s . get ( null ) ; <END> Assert . assertEquals ( 4 , out . size ( ) ) ; } 
static TYPE_1 METHOD_1 ( final TYPE_2 TYPE_3 ) { <START> return ( ) - > TYPE_3 . close ( ) ; <END> } 
<START> protected String METHOD_1 ( final TYPE_1 VAR_1 ) <END> { return VAR_1 . METHOD_2 ( TYPE_2 . class ) . METHOD_3 ( ) . METHOD_4 ( VAR_2 , method ) ; } 
private TYPE_2 ( Class < TYPE_1 > VAR_2 ) { <START> logger . debug ( STRING_1 , VAR_2 ) ; <END> this . VAR_3 = METHOD_1 ( new ArrayList < > ( METHOD_2 ( VAR_2 ) ) ) ; logger . debug ( STRING_2 , VAR_2 , VAR_3 . size ( ) ) ; } 
public static < T > T METHOD_1 ( TYPE_1 VAR_1 , Class < T > VAR_2 ) { try { METHOD_2 ( TYPE_2 ) ; return ( T ) TYPE_2 . METHOD_3 ( VAR_1 , VAR_2 ) ; } catch ( Throwable t ) { <START> throw new RuntimeException ( STRING_1 , t ) ; <END> } } 
<START> < T , R > TYPE_1 < T , ? , R > METHOD_1 ( Class < R > type ) { <END> for ( TYPE_2 < ? , ? , ? > factory : VAR_1 ) { if ( factory . VAR_2 ( type ) ) { return ( ( TYPE_2 < T , ? , R > ) factory ) . METHOD_2 ( type ) ; } } throw new IllegalStateException ( STRING_1 + type . getName ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( VAR_1 ) ; <END> TYPE_1 VAR_2 = VAR_3 . METHOD_3 ( TYPE_1 . class ) ; Long VAR_4 = VAR_2 . METHOD_4 ( STRING_1 ) ; long VAR_5 = VAR_2 . METHOD_4 ( STRING_2 ) ; assertThat ( VAR_2 . METHOD_5 ( VAR_4 ) , METHOD_6 ( STRING_1 ) ) ; assertThat ( VAR_2 . METHOD_5 ( VAR_5 ) , METHOD_6 ( STRING_2 ) ) ; VAR_2 . close ( ) ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { try { final TYPE_2 VAR_2 = VAR_3 . remove ( VAR_1 ) ; if ( VAR_2 != null ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; VAR_2 . METHOD_5 ( ) . clear ( ) ; } } catch ( TYPE_3 e ) { throw new TYPE_4 ( e ) ; } finally { <START> if ( VAR_3 . containsKey ( VAR_1 ) ) { <END> VAR_3 . remove ( VAR_1 ) ; } } } 
public Map < String , Object > METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <START> Map < String , Object > response = new HashMap < String , Object > ( ) ; <END> try { String VAR_2 = VAR_1 . METHOD_2 ( ) ; response . put ( STRING_1 , VAR_2 ) ; } catch ( TYPE_2 VAR_3 ) { response . put ( STRING_2 , VAR_3 . METHOD_3 ( ) ) ; } catch ( Throwable e ) { response . put ( STRING_2 , e . toString ( ) ) ; } return response ; } 
public static boolean METHOD_1 ( String VAR_1 ) { String VAR_2 = STRING_1 + <START> STRING_2 ; <END> TYPE_1 VAR_3 = TYPE_1 . METHOD_2 ( VAR_2 ) ; TYPE_2 matcher = VAR_3 . matcher ( VAR_1 ) ; return matcher . VAR_4 ( ) ; } 
public static void METHOD_1 ( ) { System . VAR_1 ( STRING_1 , STRING_2 ) ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_3 = new TYPE_2 ( ) . run ( ) ; TYPE_3 VAR_4 = new TYPE_3 ( <START> VAR_3 ) ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> super ( VAR_2 , null ) ; <END> } 
public void METHOD_1 ( String name ) { Assert . VAR_1 ( name , STRING_1 ) ; <START> METHOD_2 ( name ) ; <END> logger . trace ( STRING_2 , name ) ; TYPE_1 VAR_2 = METHOD_3 ( ) . METHOD_4 ( name ) ; if ( VAR_2 == null ) { METHOD_5 ( name ) ; } final TYPE_2 instance = VAR_3 . METHOD_4 ( name ) ; if ( instance == null ) { METHOD_6 ( name ) ; } VAR_3 . METHOD_7 ( instance ) ; METHOD_8 ( name ) ; } 
public int METHOD_1 ( Object key , int VAR_1 ) { int VAR_2 = key . VAR_2 ( ) ; if ( VAR_2 == Integer . VAR_3 ) { VAR_2 = 0 ; } <START> return Math . VAR_4 ( VAR_2 ) % VAR_1 ; <END> } 
public void METHOD_1 ( ) { logger . info ( STRING_1 ) ; try { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; VAR_1 . close ( ) ; } if ( VAR_2 != null ) { VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; <START> VAR_2 . METHOD_1 ( true , false ) ; <END> } super . METHOD_1 ( ) ; } catch ( Exception e ) { logger . warn ( STRING_2 + e ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { String name = ( String ) VAR_2 . METHOD_2 ( ) . getProperty ( VAR_4 ) ; if ( TYPE_6 . TYPE_7 . equals ( name ) ) { <START> return METHOD_3 ( VAR_1 , VAR_2 , VAR_3 ) ; <END> } TYPE_1 VAR_5 = VAR_1 . METHOD_4 ( ) ? METHOD_5 ( VAR_1 , VAR_2 , VAR_3 ) : METHOD_6 ( VAR_1 , VAR_2 , VAR_3 ) ; return VAR_5 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 , TYPE_4 . VAR_3 , STRING_2 ) ; <START> TYPE_3 VAR_4 = new TYPE_3 . Builder ( ) <END> . METHOD_3 ( VAR_1 ) . METHOD_4 ( STRING_1 ) . METHOD_5 ( STRING_3 ) . METHOD_3 ( VAR_1 ) . build ( ) ; METHOD_6 ( STRING_1 , TYPE_4 . VAR_3 ) ; } 
public String [ ] METHOD_1 ( ) { if ( this . VAR_1 != null ) { return new String [ ] { VAR_2 } ; } else if ( this . VAR_3 != null ) { return new String [ ] { VAR_4 } ; } <START> else { <END> return new String [ ] { VAR_5 } ; } } 
boolean METHOD_1 ( ) { if ( ! StringUtils . VAR_1 ( VAR_2 ) ) { return StringUtils . VAR_1 ( VAR_3 ) && StringUtils . VAR_1 ( VAR_4 ) ; } else { <START> return ! StringUtils . VAR_1 ( VAR_3 ) && ! StringUtils . VAR_1 ( VAR_4 ) ; <END> } } 
<START> protected void METHOD_1 ( TYPE_1 container ) throws Exception { <END> String VAR_1 = container . getName ( ) ; logger . info ( STRING_1 , VAR_1 ) ; Thread . VAR_2 ( INT_1 ) ; METHOD_2 ( ) ; METHOD_3 ( ) ; } 
public String METHOD_1 ( Date VAR_1 ) { <START> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <END> return TYPE_1 . METHOD_1 ( VAR_1 , this . VAR_3 ) ; } 
public int METHOD_1 ( ) { int result = container . VAR_1 ( ) ; <START> result = INT_1 * result + VAR_2 . METHOD_1 ( ) ; <END> result = INT_1 * result + VAR_3 . METHOD_1 ( ) ; return result ; } 
private boolean METHOD_1 ( ) { boolean VAR_1 = false ; for ( String s : VAR_2 ) { VAR_1 |= StringUtils . VAR_3 ( s ) ; } if ( ! VAR_1 ) { return false ; } <START> if ( StringUtils . isEmpty ( VAR_2 [ VAR_4 ] ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } if ( StringUtils . isEmpty ( VAR_2 [ VAR_5 ] ) ) { throw new IllegalStateException ( STRING_2 ) ; } return true ; } 
public TYPE_1 METHOD_1 ( String value , Class < ? > VAR_1 , String VAR_2 ) { int VAR_3 = value . VAR_4 ( CHAR_1 ) ; if ( VAR_3 == - 1 ) { logger . VAR_5 ( STRING_1 ) ; logger . VAR_5 ( STRING_2 ) ; throw new TYPE_2 ( ) ; } <START> TYPE_3 VAR_6 = METHOD_2 ( VAR_3 , value ) ; <END> TYPE_1 result = new TYPE_1 ( value . substring ( VAR_3 + 1 ) , VAR_6 ) ; return result ; } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 < Object > VAR_3 ) { TYPE_3 VAR_4 = new TYPE_3 ( VAR_2 , VAR_3 ) ; <START> this . METHOD_1 ( VAR_4 ) ; <END> TYPE_4 context = new TYPE_4 ( ) ; context . VAR_5 ( ) ; VAR_4 . METHOD_2 ( context ) ; this . METHOD_1 ( VAR_4 ) ; VAR_6 = new TYPE_5 ( VAR_2 ) ; } 
private void METHOD_1 ( String VAR_1 , String VAR_2 ) { try { TYPE_1 VAR_3 = parse ( VAR_1 , VAR_2 ) ; METHOD_2 ( STRING_1 + VAR_3 . METHOD_3 ( ) ) ; } catch ( TYPE_2 e ) { assertEquals ( TYPE_3 . VAR_5 , e . VAR_6 ( ) ) ; assertEquals ( 0 , e . VAR_7 ( ) ) ; <START> e . VAR_8 ( ) ; <END> assertEquals ( VAR_1 , e . VAR_9 ( ) [ 0 ] ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_3 ) ; TYPE_2 VAR_4 = null ; try { VAR_4 = new TYPE_2 ( Integer . parseInt ( VAR_2 ) ) ; } catch ( IOException e ) { throw new TYPE_3 ( VAR_2 ) ; } finally { if ( VAR_4 != null ) { try { VAR_4 . close ( ) ; } catch ( IOException e ) { <START> e . VAR_5 ( ) ; <END> } } } } 
protected TYPE_1 METHOD_1 ( TYPE_2 entity ) { <START> return new TYPE_1 ( entity . getId ( ) , entity . VAR_1 ( ) , entity . VAR_2 ( ) , entity . VAR_3 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( VAR_1 instanceof TYPE_3 ) { <START> ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( this . VAR_2 . getId ( ) ) ; <END> } this . context = VAR_1 ; } 
public void close ( ) { if ( VAR_1 != null ) { VAR_1 . close ( ) ; if ( VAR_2 != null ) { TYPE_1 VAR_3 = VAR_2 . METHOD_1 ( ) ; if ( VAR_3 != null ) { <START> VAR_3 . close ( ) ; <END> } } } if ( VAR_4 != null ) { VAR_4 . close ( ) ; TYPE_2 parent = VAR_4 . METHOD_2 ( ) ; if ( parent instanceof TYPE_1 ) { ( ( TYPE_1 ) parent ) . close ( ) ; } } } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> VAR_1 = new TYPE_2 ( VAR_2 . METHOD_2 ( ) , METHOD_3 ( ) ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { logger . info ( STRING_1 ) ; METHOD_2 ( VAR_1 , VAR_2 + STRING_2 ) ; METHOD_3 ( VAR_1 , VAR_2 + STRING_2 , true ) ; METHOD_4 ( VAR_1 ) ; TYPE_1 result = METHOD_5 ( STRING_3 + VAR_1 ) ; <START> System . out . println ( STRING_4 + result . VAR_3 ( ) . getMessage ( ) ) ; <END> assertThat ( result . VAR_3 ( ) . getMessage ( ) , METHOD_6 ( STRING_5 ) ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , double VAR_4 , boolean VAR_5 , double VAR_6 ) { Assert . VAR_7 ( VAR_2 , STRING_1 ) ; Assert . VAR_7 ( VAR_3 , STRING_1 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; <START> this . VAR_8 = VAR_5 ? STRING_2 : STRING_3 ; <END> this . VAR_6 = VAR_6 ; } 
<START> public synchronized byte [ ] METHOD_1 ( TYPE_1 < ? > message ) throws TYPE_2 { <END> TYPE_3 VAR_1 = METHOD_2 ( ) ; TYPE_4 output = new TYPE_4 ( INT_1 , - 1 ) ; VAR_1 . METHOD_3 ( output , message , TYPE_5 . class ) ; return output . VAR_2 ( ) ; } 
<START> protected void METHOD_1 ( ) throws IOException { <END> if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) . close ( ) ; if ( VAR_1 . METHOD_3 ( ) != null ) { VAR_1 . METHOD_3 ( ) . close ( ) ; } VAR_1 = null ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 request , String VAR_1 , TYPE_1 type ) { TYPE_3 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , type ) ; if ( VAR_2 == null || VAR_2 . METHOD_3 ( ) == null ) { List < TYPE_3 > VAR_4 = VAR_3 . METHOD_4 ( VAR_1 ) ; <START> if ( VAR_4 == null || VAR_4 . size ( ) == 0 ) { <END> throw new TYPE_4 ( VAR_1 ) ; } return VAR_4 . get ( 0 ) . getType ( ) ; } return VAR_2 . getType ( ) ; } 
protected synchronized void METHOD_1 ( TYPE_1 < ? > message ) throws Exception { String VAR_1 = message . VAR_2 ( ) . toString ( ) ; <START> Class < ? > type = ( VAR_1 . contains ( STRING_1 ) ) ? TYPE_2 . class <END> : TYPE_3 . class ; Object VAR_3 = this . VAR_4 . METHOD_2 ( VAR_1 , type ) ; if ( VAR_3 instanceof TYPE_2 ) { METHOD_3 ( ( TYPE_2 ) VAR_3 , message ) ; } else { METHOD_4 ( ( TYPE_3 ) VAR_3 , message ) ; } } 
public void METHOD_1 ( Exception exception ) { if ( logger . VAR_1 ( ) ) { logger . debug ( STRING_1 + exception . getMessage ( ) , exception ) ; } final TYPE_1 < Exception > message = TYPE_2 . METHOD_2 ( exception ) . METHOD_3 ( TYPE_6 . VAR_3 , <START> TYPE_4 . TYPE_5 ) <END> . build ( ) ; VAR_4 . METHOD_4 ( message ) ; } 
public TYPE_1 ( final Path file ) { <START> this ( file , file . toString ( ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = new TYPE_1 < > ( ) ; VAR_1 . METHOD_1 ( TYPE_2 . class , STRING_1 ) ; <START> Set < Class < ? extends TYPE_2 > > VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . forEach ( c - > Assert . assertTrue ( TYPE_2 . class . METHOD_3 ( c ) ) ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> VAR_1 = Thread . VAR_2 ( ) . METHOD_2 ( ) ; } 
public Object get ( Object key ) { String VAR_1 = ( String ) key ; if ( super . containsKey ( VAR_1 ) ) { return super . get ( VAR_1 ) ; } if ( VAR_2 == null ) { return null ; } if ( VAR_3 ) { return VAR_2 . METHOD_1 ( VAR_1 ) ? <START> VAR_2 . getValue ( VAR_1 ) : VAR_2 . METHOD_2 ( ) ; <END> } else { return VAR_2 . getValue ( VAR_1 ) ; } } 
public int update ( String VAR_1 , Object ... args ) throws TYPE_1 { <START> try ( TYPE_2 VAR_2 = connection . VAR_3 ( VAR_1 ) ) { <END> METHOD_1 ( VAR_2 , args ) ; return VAR_2 . METHOD_2 ( ) ; } } 
private TYPE_1 METHOD_1 ( Object key ) { <START> return VAR_1 . METHOD_2 ( key , ( VAR_2 ) - > new TYPE_1 ( ) ) ; <END> } 
public Iterator < T > iterator ( ) { if ( METHOD_1 ( ) ) { throw new IllegalStateException ( STRING_1 ) ; } if ( VAR_1 ) { throw new IllegalStateException ( STRING_2 ) ; <START> } <END> VAR_1 = true ; return VAR_2 ; } 
public Object METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 { TYPE_3 VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) ; <START> return ( VAR_3 == null || VAR_1 . METHOD_3 ( ) ) ? null : VAR_3 . METHOD_2 ( ) ; <END> } 
protected String METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> String result = VAR_1 . getString ( ) ; <END> VAR_1 . METHOD_2 ( ) ; return result ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int i , String VAR_2 , TYPE_2 VAR_3 ) throws TYPE_3 { TYPE_4 VAR_4 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_4 . METHOD_4 ( VAR_2 ) ; VAR_1 . METHOD_5 ( i , VAR_4 ) ; <START> VAR_4 . METHOD_6 ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> try { TYPE_2 VAR_3 = VAR_1 . METHOD_3 ( TYPE_2 . class ) ; TYPE_3 name = new TYPE_3 ( ) ; name . VAR_4 ( STRING_1 ) ; name . VAR_5 ( STRING_2 ) ; int VAR_6 = VAR_3 . METHOD_4 ( name ) ; assertNotNull ( name . getId ( ) ) ; assertEquals ( 1 , VAR_6 ) ; } finally { VAR_1 . close ( ) ; } } 
private void METHOD_1 ( ) { VAR_1 = new ArrayList < > ( ) ; <START> if ( VAR_2 == null || VAR_2 . length == 0 ) { <END> return ; } int VAR_3 = 0 ; for ( String value : VAR_2 ) { VAR_1 . add ( new TYPE_1 ( value , VAR_4 , VAR_3 ) ) ; VAR_3 ++ ; } } 
private TYPE_1 METHOD_1 ( ) { this . VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_1 == null ) { <END> return builder . VAR_3 ( ) ; } for ( String value : VAR_1 ) { builder . VAR_4 ( value , TYPE_3 . TYPE_2 . VAR_7 ) ; } return builder . VAR_3 ( ) ; } 
private TYPE_1 METHOD_1 ( ) { VAR_1 : <START> for ( ; ; ) { <END> TYPE_1 VAR_2 = next ( 0 , VAR_3 ) ; switch ( VAR_2 ) { case NONE : state = TYPE_3 . VAR_5 ; break VAR_1 ; case VAR_6 : return VAR_2 ; case VAR_7 : case VAR_8 : METHOD_2 ( VAR_9 ) ; break ; default : throw new TYPE_2 ( STRING_1 + VAR_2 ) ; } } return null ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { VAR_2 . METHOD_2 ( ) . METHOD_3 ( this ) ; if ( VAR_1 . METHOD_4 ( ) == TYPE_3 . VAR_4 ) { return VAR_2 . METHOD_5 ( key , VAR_1 ) ; <START> } else { <END> } return VAR_2 . METHOD_6 ( key , VAR_1 ) ; } 
private boolean METHOD_1 ( ) { try { if ( ! VAR_1 . METHOD_2 ( ) ) { return false ; } VAR_2 . start ( ) ; for ( TYPE_1 VAR_3 : VAR_4 ) { VAR_3 . METHOD_3 ( VAR_1 ) ; } VAR_2 . METHOD_4 ( ) ; } catch ( IOException e ) { throw TYPE_2 . METHOD_5 ( e ) . message ( STRING_1 ) <START> . METHOD_6 ( e . getMessage ( ) ) <END> . METHOD_6 ( VAR_5 ) . build ( logger ) ; } return true ; } 
public void METHOD_1 ( ) throws TYPE_1 { if ( ! METHOD_2 ( ) ) { <START> throw new TYPE_1 ( "" <END> + STRING_1 + getClass ( ) . METHOD_3 ( ) ) ; } } 
public static List < TYPE_1 > METHOD_1 ( int VAR_1 ) { <START> List < String > VAR_2 = TYPE_2 . METHOD_2 ( <END> VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_2 . add ( VAR_7 + Integer . toString ( i ) ) ; } return TYPE_3 . METHOD_3 ( VAR_2 ) ; } 
public void METHOD_1 ( ) throws Exception { String query = STRING_1 ; <START> Map < ? , ? > VAR_1 = new HashMap < > ( ) ; <END> METHOD_2 ( ) . METHOD_3 ( query ) . METHOD_4 ( ) . METHOD_5 ( STRING_2 ) . METHOD_6 ( VAR_1 ) . METHOD_7 ( ) ; } 
public void METHOD_1 ( ) { long VAR_1 = VAR_2 . value ; long VAR_3 = VAR_4 . value ; <START> TYPE_1 . time . TYPE_4 VAR_6 = TYPE_1 . time . TYPE_4 . METHOD_2 ( VAR_1 - ( VAR_1 % VAR_3 ) ) ; TYPE_1 . time . TYPE_2 VAR_8 = VAR_6 . METHOD_3 ( TYPE_1 . time . TYPE_3 . of ( STRING_1 ) ) . METHOD_4 ( ) ; out . value = VAR_8 . METHOD_3 ( TYPE_1 . time . TYPE_3 . of ( STRING_1 ) ) . METHOD_5 ( ) . METHOD_6 ( ) ; <END> } 
public void METHOD_1 ( ) { long VAR_1 = VAR_2 . value ; long VAR_3 = VAR_4 . value ; <START> out . value = ( long ) VAR_5 . VAR_6 . Math . VAR_7 ( VAR_1 / VAR_3 ) * VAR_3 ; <END> } 
public String toString ( ) { String result = type . name ( ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { <START> result += STRING_1 ; <END> } return result ; } 
public void METHOD_1 ( int VAR_1 ) { <START> VAR_2 = VAR_1 > VAR_2 ? VAR_1 : VAR_2 ; <END> if ( 0 == count . VAR_3 ( ) ) { TYPE_2 . TYPE_3 VAR_4 = TYPE_2 . TYPE_3 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) . build ( ) ; Response VAR_5 = new Response ( TYPE_2 . TYPE_4 . VAR_7 , VAR_4 ) ; VAR_8 . METHOD_4 ( VAR_5 ) ; } } 
public boolean equals ( final Object VAR_1 ) { if ( VAR_1 == this ) { return true ; } if ( VAR_1 == null || ! ( VAR_1 instanceof Map . Entry ) ) { return false ; } <START> final Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) VAR_1 ; <END> return TYPE_1 . METHOD_1 ( key , entry . getKey ( ) ) && TYPE_1 . METHOD_1 ( value , entry . getValue ( ) ) ; } 
public TYPE_2 ( TYPE_1 context ) { <START> this . context = METHOD_1 ( context ) ; <END> } 
protected TYPE_7 . TYPE_8 METHOD_1 ( TYPE_2 options , TYPE_3 VAR_1 ) { TYPE_7 . TYPE_8 builder = new TYPE_7 . TYPE_8 ( ) ; builder . VAR_2 ( new TYPE_4 ( new TYPE_9 . TYPE_10 ( this ) ) ) ; METHOD_2 ( builder , VAR_1 ) ; builder . VAR_3 ( TYPE_6 . METHOD_3 ( TYPE_12 . TYPE_11 . VAR_6 ) ) ; <START> return builder ; <END> } 
protected int METHOD_1 ( ) { try { return super . METHOD_1 ( ) ; } catch ( IllegalStateException VAR_1 ) { return - 1 ; <START> } catch ( TYPE_1 e ) { <END> return - 1 ; } } 
public TYPE_2 ( Set < TYPE_1 > VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; } 
public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 , List < TYPE_2 > args ) { super ( VAR_3 ) ; this . VAR_2 = VAR_2 ; if ( args == null ) { this . args = ImmutableList . of ( ) ; <START> } else if ( args instanceof ImmutableList ) { <END> this . args = ( ImmutableList < TYPE_2 > ) args ; } else { this . args = ImmutableList . VAR_4 ( args ) ; } } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> Class < ? > VAR_2 = VAR_1 . METHOD_2 ( ) ; int [ ] VAR_3 = VAR_1 . METHOD_3 ( ) ; return VAR_4 . METHOD_4 ( VAR_2 , VAR_3 ) . METHOD_5 ( ) ; } 
<START> void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , <END> String VAR_4 , String VAR_5 ) { if ( METHOD_2 ( VAR_1 ) ) { METHOD_3 ( VAR_1 ) ; } else { METHOD_4 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; } } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 ; if ( VAR_1 == null || ( VAR_2 = VAR_3 . get ( VAR_1 . METHOD_2 ( ) ) ) == null ) { VAR_2 = VAR_3 . values ( ) . iterator ( ) . next ( ) ; } <START> return ( TYPE_1 ) VAR_2 . METHOD_3 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( String name ) { if ( VAR_1 != null ) { try { return VAR_1 . METHOD_1 ( name ) ; } catch ( RuntimeException e ) { TYPE_2 . logger . warn ( STRING_1 , name , e ) ; } } return null ; <START> } <END> 
<START> TYPE_6 ( ) { <END> super ( TYPE_1 . class , ( TYPE_2 < TYPE_3 > ) input - > true , TYPE_5 . VAR_3 , TYPE_7 . VAR_5 , TYPE_4 . VAR_7 , STRING_1 ) ; } 
private static TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 ) { <START> final TYPE_2 VAR_2 = TYPE_2 . VAR_3 ; <END> final TYPE_1 VAR_4 = TYPE_10 . TYPE_11 . METHOD_2 ( VAR_2 , VAR_1 ) ; final TYPE_1 count = TYPE_7 . TYPE_8 . METHOD_2 ( VAR_2 , VAR_1 ) ; final TYPE_1 VAR_5 = TYPE_5 . METHOD_2 ( VAR_2 , VAR_4 ) ; return TYPE_7 . TYPE_9 . METHOD_2 ( VAR_2 , VAR_5 , count ) ; } 
<START> private static String METHOD_1 ( String VAR_1 ) <END> { String content = "" ; try { content = new String ( TYPE_1 . METHOD_2 ( TYPE_2 . get ( VAR_1 ) ) ) ; } catch ( IOException e ) { e . VAR_2 ( ) ; } return content ; } 
public static String METHOD_1 ( final String VAR_1 , final String instance , final String VAR_2 ) { METHOD_2 ( VAR_1 ) ; METHOD_2 ( VAR_2 ) ; <START> return METHOD_2 ( VAR_1 ) + <END> ( ( instance != "" ) ? STRING_1 + instance : "" ) + STRING_2 + METHOD_2 ( VAR_2 ) ; } 
public static TYPE_1 build ( TYPE_2 VAR_1 ) { TYPE_3 container = VAR_1 . container ( ) ; try { return build ( container , new TYPE_4 ( ) . METHOD_1 ( container ) , VAR_1 . METHOD_2 ( ) ) ; } catch ( TYPE_5 e ) { <START> throw new TYPE_6 ( e ) ; <END> } } 
public < T extends TYPE_1 > TYPE_2 METHOD_1 ( TYPE_3 context , TYPE_1 VAR_1 ) throws TYPE_4 { try { <START> final TYPE_5 builder = <END> options . VAR_2 . METHOD_2 ( this , context . VAR_3 ( ) , VAR_1 ) ; return builder . VAR_4 ( context , VAR_1 ) ; } catch ( final TYPE_6 e ) { throw e ; } catch ( final Throwable e ) { throw new TYPE_4 ( e ) ; } } 
public TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 . METHOD_1 ( ) ) ; <START> VAR_3 = VAR_2 . METHOD_2 ( ) ; <END> this . VAR_4 = VAR_2 . METHOD_3 ( ) ; } 
public void METHOD_1 ( TYPE_1 from ) { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } 
public void METHOD_1 ( int VAR_1 ) { if ( VAR_1 == 0 ) { return ; } int VAR_2 ; <START> if ( VAR_1 == 0 ) { <END> VAR_2 = 0 ; VAR_3 . METHOD_2 ( ) . METHOD_1 ( 0 ) ; } else { VAR_4 . METHOD_3 ( VAR_1 ) ; VAR_2 = VAR_3 . METHOD_4 ( ) . get ( VAR_1 ) ; } for ( TYPE_1 v : METHOD_5 ( ) ) { v . VAR_5 ( ) . METHOD_1 ( VAR_2 ) ; } } 
public TYPE_4 ( TYPE_1 config , TYPE_2 VAR_2 , List < TYPE_3 > VAR_3 ) { super ( STRING_1 ) ; <START> this . VAR_4 = config ; <END> this . VAR_5 = VAR_2 ; this . VAR_3 = VAR_3 == null || VAR_3 . size ( ) == 0 ? VAR_6 : VAR_3 ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { logger . debug ( STRING_1 ) ; <START> return new TYPE_2 ( VAR_2 , VAR_3 , VAR_4 ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 table = VAR_2 . get ( name ) ; if ( table != null ) { return table ; } if ( ! VAR_2 . containsKey ( name ) ) { return METHOD_2 ( name , new TYPE_2 ( VAR_3 , VAR_4 , new TYPE_3 ( VAR_4 , name , VAR_1 , VAR_3 . METHOD_3 ( ) ) ) ) ; } <START> return null ; <END> } 
public int METHOD_1 ( ) { <START> return 0 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 parent ) throws IOException { TYPE_3 VAR_2 = new TYPE_3 ( getName ( ) ) ; logger . debug ( STRING_1 , VAR_2 . getName ( ) , VAR_2 . toString ( ) ) ; <START> TYPE_2 VAR_3 = parent . add ( getName ( ) , VAR_2 ) ; <END> VAR_2 . METHOD_2 ( VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { <START> logger . debug ( STRING_1 ) ; <END> return new TYPE_2 ( config , VAR_2 , VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( String name ) { try { if ( ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . containsKey ( name ) ) { throw TYPE_2 . METHOD_4 ( ) . message ( STRING_1 , name , getName ( ) ) . build ( logger ) ; } return METHOD_5 ( name ) ; } catch ( Exception e ) { <START> throw new TYPE_3 ( e ) ; <END> } } 
public TYPE_2 ( String user , String VAR_2 ) { VAR_3 = TYPE_1 . METHOD_1 ( user , VAR_2 ) ; <START> logger . debug ( STRING_1 , VAR_3 ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) throws IOException { <END> TYPE_3 VAR_3 = VAR_2 . METHOD_2 ( new TYPE_4 ( ) , new TYPE_5 < TYPE_3 > ( ) { } ) ; return new TYPE_6 ( VAR_1 , this , VAR_3 , null ) ; } 
TYPE_1 build ( String VAR_1 , String VAR_2 , TYPE_2 field , <START> Object VAR_3 ) throws IOException { <END> String VAR_4 = field . VAR_5 ( ) . getName ( ) ; TYPE_3 filter = METHOD_1 ( VAR_2 , VAR_4 , String . valueOf ( VAR_3 ) ) ; logger . debug ( STRING_1 + VAR_2 + STRING_2 + VAR_4 + STRING_3 + VAR_3 ) ; TYPE_1 VAR_6 = new TYPE_1 ( VAR_1 , filter ) ; logger . debug ( STRING_4 + filter + STRING_5 + VAR_1 ) ; return VAR_6 ; } 
public boolean METHOD_1 ( TYPE_1 call ) { <START> final TYPE_2 VAR_1 = ( TYPE_2 ) call . VAR_2 ( 1 ) ; <END> if ( VAR_1 . METHOD_2 ( ) instanceof TYPE_3 ) { return super . METHOD_1 ( call ) ; } return false ; } 
<START> public TYPE_1 METHOD_1 ( ) throws TYPE_2 { <END> logger . debug ( STRING_1 ) ; TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( this , null ) ; if ( VAR_1 != null ) { VAR_1 = METHOD_3 ( TYPE_3 . VAR_4 , this . VAR_5 . METHOD_4 ( ) , VAR_1 ) ; } return VAR_1 ; } 
public TYPE_2 ( String name ) { <START> super ( TYPE_1 < String > of ( ) , name ) ; <END> this . VAR_3 = this . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> VAR_1 . clear ( ) ; VAR_2 . clear ( ) ; } 
private static Map < Class < ? extends TYPE_1 > , TYPE_2 > METHOD_1 ( ) { <START> Map < Class < ? extends TYPE_1 > , TYPE_2 > VAR_1 = new TYPE_3 < > ( ) ; <END> VAR_1 . put ( TYPE_4 . class , TYPE_2 . VAR_2 ) ; return VAR_1 ; } 
public List < String > METHOD_1 ( ) { if ( VAR_1 == null ) { return VAR_2 ; } <START> return VAR_1 ; <END> } 
public List < String > METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> return VAR_2 ; } return VAR_1 ; } 
public boolean next ( ) { <START> if ( VAR_1 == null ) { <END> return false ; } TYPE_1 VAR_2 = null ; while ( ! VAR_3 . METHOD_1 ( ) ) { Object [ ] VAR_4 = VAR_5 . METHOD_2 ( ) ; VAR_2 = VAR_6 . next ( ) ; if ( VAR_2 == null ) { return false ; } METHOD_3 ( VAR_3 , VAR_6 . METHOD_4 ( ) , VAR_2 , VAR_4 ) ; } return true ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; <START> return TYPE_2 . METHOD_1 ( VAR_2 , VAR_1 . METHOD_2 ( ) ) ; <END> } 
public TYPE_6 ( TYPE_1 config ) { this . config = config ; TYPE_2 configuration = configuration ( config ) ; <START> this . VAR_2 = new TYPE_3 ( new TYPE_2 ( configuration ) ) ; <END> this . VAR_3 = METHOD_1 ( config , new TYPE_2 ( configuration ) ) ; this . VAR_4 = properties ( config , TYPE_5 . VAR_6 ) ; this . VAR_7 = new TYPE_4 ( config , new TYPE_2 ( configuration ) ) ; } 
public TYPE_4 ( String [ ] name , TYPE_2 . TYPE_3 VAR_2 , Object VAR_3 , Object VAR_4 , Long VAR_5 ) { <START> this ( name , VAR_2 , VAR_3 , VAR_4 , VAR_5 , new ArrayList < > ( ) ) ; <END> } 
public static boolean METHOD_1 ( TYPE_1 type ) { <START> return type != TYPE_1 . VAR_1 <END> && type != TYPE_1 . VAR_2 && type != TYPE_1 . VAR_3 ; } 
public void clear ( ) { METHOD_1 ( ) . METHOD_2 ( ) ; VAR_1 . clear ( ) ; <START> for ( final TYPE_1 VAR_2 : METHOD_3 ( ) ) { <END> VAR_2 . clear ( ) ; } } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_1 . class ) ; <START> VAR_1 . METHOD_3 ( METHOD_4 ( STRING_1 ) ) ; <END> METHOD_5 ( STRING_2 ) ; } 
<START> private static void METHOD_1 ( String VAR_1 , TYPE_3 . TYPE_4 type ) { <END> assertEquals ( new TYPE_2 ( STRING_1 , type ) . METHOD_2 ( ) , METHOD_3 ( VAR_1 ) . METHOD_2 ( ) ) ; } 
<START> @Override public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , <END> TYPE_3 VAR_2 ) { return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; } 
public static List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { <START> List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; <END> VAR_2 . add ( new TYPE_1 < > ( VAR_1 . METHOD_3 ( ) , TYPE_3 . VAR_4 ) ) ; VAR_2 . add ( new TYPE_1 < > ( Boolean . VAR_5 , TYPE_3 . VAR_6 ) ) ; return VAR_2 ; } return Collections . VAR_7 ( ) ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 , boolean VAR_2 ) { <START> VAR_1 = VAR_1 != null ? VAR_1 . METHOD_2 ( ) : null ; <END> TYPE_1 VAR_3 = METHOD_3 ( ) . get ( VAR_1 ) ; if ( VAR_3 != null ) { return VAR_3 ; } METHOD_4 ( VAR_1 , VAR_2 ) ; VAR_3 = METHOD_3 ( ) . get ( VAR_1 ) ; return VAR_3 ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( this ) ; String VAR_2 = Path . VAR_3 ( VAR_4 . getPath ( ) ) . toString ( ) ; if ( VAR_4 . METHOD_2 ( ) != 0 ) { VAR_2 += String . format ( STRING_1 , VAR_4 . METHOD_2 ( ) ) ; } <START> VAR_1 . METHOD_3 ( VAR_2 ) ; <END> return VAR_1 ; } 
public TYPE_3 ( TYPE_1 reader , TYPE_2 VAR_2 , String VAR_3 ) { this . reader = reader ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> VAR_4 = 0 ; <END> } 
<START> TYPE_1 METHOD_1 ( ) { return VAR_1 ; } <END> 
<START> String getKey ( ) { return key ; } <END> 
<START> String METHOD_1 ( ) { <END> return VAR_1 ; } 
private ArrayList < String > METHOD_1 ( ) { <START> ArrayList < String > VAR_1 = new ArrayList < > ( ) ; <END> TYPE_1 [ ] VAR_2 = reader . VAR_3 ( ) . METHOD_2 ( VAR_4 ) ; for ( TYPE_1 info : VAR_2 ) { VAR_1 . add ( info . getName ( ) . METHOD_3 ( VAR_5 , VAR_6 ) ) ; } return VAR_1 ; } 
public TYPE_1 ( ) { <START> VAR_2 = new HashMap ( ) ; <END> } 
public List < Object > METHOD_1 ( int VAR_1 ) { <START> List < Object > result = new ArrayList < Object > ( ) ; <END> for ( Object [ ] VAR_2 : VAR_3 ) { result . add ( VAR_2 [ VAR_1 ] ) ; } return result ; } 
public static void METHOD_1 ( ) throws Exception { <START> TYPE_1 . METHOD_2 ( ) ; <END> TYPE_2 . METHOD_2 ( ) ; TYPE_3 builder = TYPE_4 . builder ( VAR_1 ) ; METHOD_3 ( builder ) ; TYPE_5 VAR_2 = new TYPE_5 ( ) ; cluster . VAR_3 ( STRING_1 , STRING_2 , VAR_2 ) ; VAR_1 . METHOD_4 ( TYPE_6 . get ( STRING_3 ) ) ; } 
public TYPE_2 ( ANNOTATION_1 ( STRING_1 ) List < TYPE_1 > VAR_2 , ANNOTATION_1 ( STRING_2 ) Map < String , String > properties ) { <START> if ( VAR_2 != null && ! VAR_2 . isEmpty ( ) ) { <END> VAR_2 . forEach ( this : : METHOD_1 ) ; } METHOD_2 ( properties ) ; } 
<START> private static Set < TYPE_1 > METHOD_1 ( final TYPE_2 node ) { <END> Set < TYPE_1 > VAR_1 = new HashSet < > ( ) ; TYPE_3 < TYPE_4 > VAR_2 = new TYPE_5 < TYPE_4 > ( true ) { public TYPE_4 METHOD_2 ( TYPE_1 VAR_3 ) { VAR_1 . add ( VAR_3 ) ; return super . METHOD_2 ( VAR_3 ) ; } } ; node . VAR_4 ( VAR_2 ) ; return VAR_1 ; } 
public Map < String , String > METHOD_1 ( ) { <START> return METHOD_2 ( o - > TYPE_5 . TYPE_4 . VAR_3 == o . VAR_4 ( ) && ! ( TYPE_2 . TYPE_3 . equals ( o . getName ( ) ) && String . valueOf ( o . getValue ( ) ) . equals ( STRING_1 ) ) ) ; <END> } 
public List < ? extends TYPE_2 . TYPE_3 > METHOD_1 ( ) { <START> return new ArrayList ( this . VAR_1 . values ( ) ) ; <END> } 
public void METHOD_1 ( long VAR_1 ) throws TYPE_1 { super . METHOD_1 ( VAR_1 ) ; try ( TYPE_2 VAR_2 = this . connection . VAR_3 ( ) ) { VAR_2 . execute ( STRING_1 + TYPE_3 . VAR_5 + STRING_2 + VAR_1 ) ; <START> VAR_2 . close ( ) ; <END> } } 
public static void METHOD_1 ( ) throws TYPE_1 { if ( connection != null ) { try ( TYPE_2 VAR_1 = connection . VAR_2 ( ) ) { VAR_1 . execute ( String . format ( STRING_1 , TYPE_3 . VAR_4 ) ) ; } } <START> connection . close ( ) ; <END> } 
public static List < String > METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { int VAR_3 = METHOD_2 ( VAR_1 ) ; String VAR_4 = VAR_2 . METHOD_3 ( TYPE_4 . VAR_6 ) . VAR_7 ; <START> List < String > VAR_8 = TYPE_3 . METHOD_4 ( ) ; <END> for ( int i = 0 ; i < VAR_3 ; i ++ ) { VAR_8 . add ( VAR_4 + i ) ; } return VAR_8 ; } 
public Builder ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; this . VAR_2 = new TYPE_2 ( VAR_1 ) ; this . VAR_3 = new TYPE_3 ( VAR_2 ) ; this . VAR_4 = new TYPE_4 ( VAR_2 ) ; this . VAR_5 = false ; this . VAR_6 = false ; this . VAR_7 = false ; this . VAR_8 = true ; <START> this . VAR_9 = false ; <END> } 
private static File METHOD_1 ( TYPE_1 VAR_1 ) { File VAR_2 = null ; try { TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 . getClass ( ) , STRING_1 , true ) ; TYPE_4 VAR_4 = ( TYPE_4 ) TYPE_3 . METHOD_3 ( VAR_3 , VAR_1 , true ) ; VAR_2 = VAR_4 . METHOD_4 ( ) ; } catch ( TYPE_5 e ) { <START> e . VAR_5 ( ) ; <END> } return VAR_2 ; } 
private Map < String , String > METHOD_1 ( ) { <START> Map < String , String > VAR_1 = TYPE_1 . METHOD_2 ( ) ; <END> for ( final TYPE_2 VAR_2 : METHOD_3 ( ) ) { String VAR_3 = VAR_2 . METHOD_4 ( ) . getPath ( ) ; try { String VAR_4 = TYPE_3 . METHOD_5 ( VAR_3 ) ; VAR_1 . put ( VAR_3 , VAR_4 ) ; } catch ( Exception e ) { LOG . info ( STRING_1 + VAR_3 + STRING_2 , e ) ; } } return VAR_1 ; } 
public void close ( ) throws Exception { <START> TYPE_1 . close ( this . reader , this . VAR_1 ) ; <END> } 
public static List < TYPE_1 > METHOD_1 ( int VAR_1 ) { return TYPE_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( ) , <START> METHOD_4 ( 2 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 target ) { <START> target . VAR_1 = VAR_1 ; <END> } 
public boolean METHOD_1 ( ) { <START> return VAR_1 != null && VAR_1 > 0 ; <END> } 
public TYPE_1 ( ANNOTATION_1 ( STRING_1 ) String query , ANNOTATION_1 ( STRING_2 ) String VAR_2 , ANNOTATION_1 ( STRING_3 ) String VAR_3 ) { this . query = query ; this . VAR_2 = VAR_2 . METHOD_1 ( ) ; <START> this . VAR_4 = VAR_3 != null && VAR_3 . METHOD_2 ( STRING_4 ) ? new Integer ( VAR_3 ) : null ; <END> } 
public static void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( final long p , Map < String , String > VAR_1 ) { if ( VAR_1 == null ) { <START> VAR_1 = new HashMap < String , String > ( ) ; <END> } VAR_1 . put ( TYPE_2 . VAR_3 , String . valueOf ( p ) ) ; METHOD_2 ( ( new TYPE_1 ( 0 , p ) ) . METHOD_3 ( ) , VAR_4 , VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( STRING_1 + VAR_1 ) ; <END> METHOD_3 ( ) . METHOD_4 ( STRING_2 ) . METHOD_5 ( ) . METHOD_6 ( STRING_3 ) . METHOD_7 ( STRING_4 ) . METHOD_7 ( STRING_5 ) . METHOD_8 ( ) ; } 
public static List < TYPE_1 > METHOD_1 ( final TYPE_2 VAR_1 , Path path , boolean VAR_2 , TYPE_3 ... VAR_3 ) { List < TYPE_1 > VAR_4 = new ArrayList < > ( ) ; try { <START> METHOD_2 ( VAR_1 , path , VAR_2 , false , VAR_4 , METHOD_3 ( VAR_3 ) ) ; <END> } catch ( Exception e ) { } return VAR_4 ; } 
public TYPE_1 METHOD_1 ( ) { return TYPE_1 . builder ( ) <START> . METHOD_2 ( VAR_1 ) <END> . METHOD_3 ( VAR_2 ) . build ( ) ; } 
public TYPE_7 ( TYPE_1 cluster , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 , TYPE_5 VAR_7 ) { super ( cluster , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) ; <START> TYPE_6 . METHOD_1 ( METHOD_2 ( VAR_2 , VAR_3 , VAR_4 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 . METHOD_2 ( VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( long VAR_1 , TimeUnit VAR_2 ) throws InterruptedException , IOException { TYPE_2 VAR_3 = buffer . VAR_4 ( VAR_1 , VAR_2 ) ; if ( VAR_3 != null ) { try { return VAR_3 . get ( ) ; <START> } catch ( InterruptedException e ) { <END> return null ; } } return null ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 . size ( ) > 1 ) { return true ; } else { return false ; <START> } <END> } 
public void METHOD_1 ( ) throws Exception { String query = STRING_1 + STRING_2 ; METHOD_2 ( VAR_1 ) ; TYPE_1 . METHOD_3 ( query , new String [ ] { STRING_3 } , new String [ ] { STRING_4 } ) ; <START> return ; <END> } 
public void METHOD_1 ( ) throws Exception { String query = STRING_1 + STRING_2 ; METHOD_2 ( VAR_1 ) ; TYPE_1 . METHOD_3 ( query , new String [ ] { STRING_3 , STRING_4 , STRING_5 } , new String [ ] { } ) ; <START> System . out . println ( STRING_6 ) ; <END> METHOD_4 ( ) . METHOD_5 ( query ) . METHOD_6 ( ) . METHOD_7 ( STRING_7 ) . METHOD_8 ( STRING_8 ) . METHOD_9 ( ) ; return ; } 
public TYPE_1 ( ANNOTATION_1 ( STRING_1 ) String url ) { this . url = url ; <START> this . METHOD_1 ( true ) ; <END> } 
public static void METHOD_1 ( ) throws Exception { METHOD_2 ( TYPE_1 . builder ( VAR_1 ) ) ; <START> TYPE_2 VAR_2 = cluster . VAR_3 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <END> TYPE_3 VAR_4 = ( TYPE_3 ) VAR_2 . METHOD_5 ( VAR_5 ) . METHOD_6 ( ) ; VAR_4 . METHOD_7 ( false ) ; VAR_2 . METHOD_8 ( VAR_5 , VAR_4 , true ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_7 . TYPE_8 VAR_2 = VAR_1 . METHOD_2 ( ) ; int VAR_3 = VAR_2 . METHOD_3 ( ) ; TYPE_5 . TYPE_6 VAR_4 = VAR_2 . METHOD_4 ( ) ; List < String > VAR_5 = VAR_2 . METHOD_5 ( ) ; logger . info ( STRING_1 , VAR_3 , TYPE_4 . METHOD_4 ( VAR_4 ) ) ; <START> METHOD_6 ( VAR_3 , VAR_4 , VAR_5 , VAR_1 . METHOD_7 ( ) ) ; <END> } 
<START> public boolean equals ( Object VAR_1 ) { <END> if ( VAR_1 instanceof TYPE_1 ) { TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 ; return this . VAR_3 . equals ( VAR_2 . VAR_3 ) ; } return false ; } 
public void METHOD_1 ( ) { for ( TYPE_1 method : VAR_1 . METHOD_2 ( ) ) { <START> if ( method . VAR_2 ( ) ) { <END> continue ; } METHOD_3 ( method ) ; } } 
private TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , boolean debug ) { super ( debug ) ; this . VAR_2 = VAR_2 ; this . listener = new TYPE_3 ( ) ; this . VAR_4 = new TYPE_4 ( VAR_2 . METHOD_1 ( listener , null , TYPE_7 . VAR_6 ) , VAR_3 ) ; <START> this . VAR_7 = TYPE_5 . METHOD_2 ( STRING_1 , STRING_2 , STRING_3 , STRING_2 , this . debug ? STRING_4 : STRING_5 ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 output ) throws TYPE_4 { <START> TYPE_5 field = TYPE_5 . create ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( CHAR_1 , CHAR_2 ) . trim ( ) , <END> TYPE_6 . METHOD_4 ( TYPE_10 . TYPE_9 . VAR_4 ) ) ; return ( TYPE_1 ) output . VAR_5 ( field , TYPE_7 . METHOD_5 ( TYPE_10 . TYPE_9 . VAR_4 , TYPE_8 . VAR_7 ) ) ; } 
public Double getValue ( ) { <START> if ( VAR_1 != null ) { <END> return VAR_1 . METHOD_1 ( ) ; } return null ; } 
<START> public TYPE_7 ( TYPE_1 cluster , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_3 VAR_4 , boolean VAR_5 , <END> TYPE_4 VAR_6 , TYPE_5 VAR_7 , TYPE_6 VAR_8 ) { super ( cluster , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 ) ; } 
<START> public TYPE_5 ( TYPE_1 cluster , TYPE_2 VAR_2 , TYPE_3 child , TYPE_4 offset , TYPE_4 VAR_3 , boolean VAR_4 , boolean VAR_5 ) { <END> super ( cluster , VAR_2 , child , offset , VAR_3 , VAR_4 ) ; this . VAR_6 = VAR_5 ; } 
public Iterator < Entry < String , TYPE_1 > > METHOD_1 ( int VAR_1 , int VAR_2 ) { <START> TYPE_2 < Entry < String , TYPE_1 > > VAR_3 = ( ) - > new TYPE_3 ( VAR_2 ) ; <END> return TYPE_4 . stream ( VAR_3 . METHOD_2 ( ) , false ) . METHOD_3 ( VAR_1 ) . METHOD_4 ( VAR_2 ) . iterator ( ) ; } 
private static void METHOD_1 ( final String query ) throws Exception { TYPE_1 . METHOD_2 ( METHOD_3 ( query ) , <START> new String [ ] { } , <END> new String [ ] { STRING_1 } ) ; } 
private static void METHOD_1 ( final String query ) throws Exception { <START> TYPE_1 . METHOD_2 ( METHOD_3 ( query ) , <END> new String [ ] { STRING_1 } , new String [ ] { } ) ; } 
public static void METHOD_1 ( ) throws IOException { TYPE_1 conf = new TYPE_1 ( ) ; VAR_1 = TYPE_2 . METHOD_2 ( conf , new Path ( path ) ) ; <START> assertNotNull ( STRING_1 , VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 ) { try { return VAR_2 . METHOD_1 ( VAR_1 ) ; } catch ( RuntimeException e ) { TYPE_2 . Builder builder = TYPE_2 . METHOD_2 ( e ) <START> . METHOD_3 ( STRING_1 , ( String ) null ) ; <END> if ( VAR_3 ) { builder . message ( STRING_2 ) ; } throw builder . build ( logger ) ; } } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final Object obj ) { <START> return new org . VAR_2 . VAR_3 . VAR_4 . VAR_5 . config . TYPE_3 ( null , VAR_1 . METHOD_2 ( ) ) ; <END> } 
private Map < Integer , Integer > METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { int index = 0 ; <START> Map < Integer , Integer > result = new TYPE_2 ( ) ; <END> for ( int i = 0 ; i < VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . size ( ) ; i ++ ) { if ( i == VAR_2 ) { continue ; } else { result . put ( i , index ++ ) ; } } return result ; } 
public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = 1 ; <START> result = VAR_1 * result + ( ( name == null ) ? 0 : name . VAR_2 ( ) ) ; <END> return result ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > VAR_2 = this . METHOD_2 ( ) ; List < TYPE_2 > VAR_3 = VAR_1 . METHOD_2 ( ) ; for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { <START> TYPE_2 VAR_4 = VAR_2 . get ( 0 ) ; <END> TYPE_2 VAR_5 = VAR_3 . get ( 0 ) ; VAR_4 . METHOD_3 ( VAR_5 ) ; } for ( TYPE_2 VAR_6 : VAR_3 ) { VAR_6 . METHOD_4 ( ) . clear ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> return TYPE_1 . VAR_1 ; <END> } 
public TYPE_1 ( int VAR_1 , double VAR_2 , TYPE_2 VAR_3 ) { <START> int VAR_4 = TYPE_1 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> int size = TYPE_1 . METHOD_2 ( VAR_4 ) ; this . VAR_5 = VAR_3 . buffer ( size ) ; this . VAR_4 = VAR_5 . METHOD_3 ( ) ; this . VAR_5 . METHOD_4 ( VAR_4 ) ; } 
private int METHOD_1 ( int VAR_1 ) { <START> return Math . VAR_2 ( VAR_1 , Math . VAR_2 ( VAR_3 , VAR_4 ) ) ; <END> } 
int METHOD_1 ( TYPE_1 VAR_1 , int index ) { if ( VAR_1 == TYPE_1 . VAR_2 ) { <START> final int VAR_3 = ( int ) ( Math . VAR_4 ( ) * 2 ) ; <END> return VAR_3 ; } return ( VAR_1 == TYPE_1 . VAR_5 ) ? ( index % 2 ) : ( ( VAR_1 == TYPE_1 . VAR_6 ) ? 1 : 0 ) ; } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
private TYPE_1 METHOD_1 ( Map < String , String > parameters , TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_2 . equals ( parameters . get ( VAR_3 ) ) ) { <END> return TYPE_1 . METHOD_3 ( VAR_4 ) ; } else { return VAR_1 ; } } 
private String METHOD_1 ( Map < String , String > parameters , String VAR_1 ) { <START> return TYPE_1 . equals ( VAR_1 , parameters . get ( VAR_2 ) ) ? VAR_3 : VAR_1 ; <END> } 
public static boolean METHOD_1 ( Throwable e ) { if ( e instanceof TYPE_1 || e instanceof TYPE_2 ) { return true ; } <START> if ( e instanceof TYPE_3 ) { <END> return TYPE_4 . equals ( e . getMessage ( ) ) ; } else { return false ; } } 
public static TYPE_1 METHOD_1 ( final String VAR_1 ) { final TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> return TYPE_1 . METHOD_3 ( ) . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) . METHOD_6 ( VAR_2 . METHOD_7 ( ) ) . setText ( VAR_1 ) . build ( ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> return ( VAR_2 . METHOD_2 ( ) && VAR_1 . METHOD_2 ( ) && <END> ( ! VAR_2 . METHOD_3 ( ) || ! VAR_1 . METHOD_3 ( ) ) ) || VAR_1 . METHOD_4 ( ) ; } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { switch ( VAR_1 ) { case STRING_1 : if ( VAR_3 < VAR_2 . VAR_3 ) { VAR_3 = VAR_2 . VAR_3 ; } if ( VAR_4 > VAR_2 . VAR_4 ) { VAR_4 = VAR_2 . VAR_4 ; } break ; case STRING_2 : if ( VAR_2 . VAR_3 < VAR_3 ) { VAR_3 = VAR_2 . VAR_3 ; } if ( VAR_2 . VAR_4 > VAR_4 ) { VAR_4 = VAR_2 . VAR_4 ; } <START> break ; <END> default : assert ( false ) ; } } 
public Set < String > METHOD_1 ( ) { if ( VAR_1 == null ) { try { <START> VAR_1 = TYPE_1 . METHOD_2 ( VAR_2 . METHOD_1 ( this . name , VAR_3 . METHOD_3 ( ) ) ) ; <END> } catch ( final TYPE_2 e ) { logger . warn ( STRING_1 , this . name , e . VAR_4 ( ) ) ; VAR_1 = new HashSet < > ( ) ; } } return VAR_1 ; } 
<START> TYPE_1 ( ) { <END> super ( ) ; } 
<START> private TYPE_2 ( ) { <END> super ( ) ; type = TYPE_1 . VAR_3 ; } 
<START> public void METHOD_1 ( TYPE_1 container ) { <END> for ( TYPE_2 VAR_1 : container ) { TYPE_4 . TYPE_5 VAR_2 = METHOD_2 ( VAR_1 . METHOD_3 ( ) . getName ( ) ) ; VAR_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_3 ) ; } } 
@Override public final void METHOD_1 ( TYPE_1 context , TYPE_2 VAR_1 , TYPE_2 VAR_2 , List < TYPE_3 > VAR_3 , TYPE_4 VAR_4 ) throws TYPE_5 { this . VAR_5 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> switch ( VAR_5 ) { <END> case VAR_6 : throw new TYPE_6 ( STRING_1 ) ; case VAR_7 : throw new TYPE_6 ( STRING_1 ) ; } this . VAR_3 = ImmutableList . VAR_8 ( VAR_3 ) ; this . VAR_4 = VAR_4 ; } 
public void METHOD_1 ( ) throws Exception { String query = STRING_1 ; int VAR_1 = METHOD_2 ( query ) ; assertEquals ( STRING_2 , 1 , VAR_1 ) ; METHOD_3 ( query , <START> new String [ ] { STRING_3 , STRING_4 } , new String [ ] { } ) ; <END> } 
public void METHOD_1 ( boolean VAR_1 , boolean VAR_2 ) throws IOException , InterruptedException { for ( TYPE_1 VAR_3 : VAR_4 ) { if ( Thread . VAR_5 ( ) ) { <START> throw new InterruptedException ( ) ; <END> } logger . debug ( STRING_1 ) ; if ( VAR_1 ) { VAR_3 . METHOD_2 ( ) ; } VAR_3 . METHOD_3 ( VAR_2 ) ; if ( VAR_2 ) { VAR_3 . METHOD_4 ( ) ; VAR_3 . METHOD_5 ( ) ; } } } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 == null || VAR_1 . METHOD_2 ( ) . length != 1 ) { <END> return false ; } return true ; } 
private int METHOD_1 ( TYPE_1 VAR_1 ) { <START> String VAR_2 = null ; <END> switch ( VAR_1 ) { case VAR_3 : VAR_2 = STRING_1 ; break ; case VAR_4 : case VAR_5 : VAR_2 = STRING_2 ; break ; default : return VAR_6 ; } int VAR_7 = 0 ; String [ ] VAR_8 = TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; for ( String name : VAR_8 ) { if ( name . equalsIgnoreCase ( VAR_2 ) ) { return VAR_7 ; } VAR_7 ++ ; } return VAR_6 ; } 
public void METHOD_1 ( ) throws Throwable { TYPE_1 builder = TYPE_2 . builder ( VAR_1 ) <START> . METHOD_2 ( TYPE_7 . VAR_3 , true ) ; <END> try ( TYPE_2 cluster = builder . build ( ) ; TYPE_3 client = cluster . VAR_4 ( ) ) { TYPE_4 VAR_5 = new TYPE_4 ( new TYPE_2 . TYPE_6 ( client ) ) ; VAR_5 . METHOD_3 ( ) . METHOD_4 ( STRING_1 ) . METHOD_5 ( STRING_2 ) . METHOD_6 ( ) ; } } 
<START> private TYPE_2 ( ) throws Exception { <END> throw new TYPE_1 ( STRING_1 ) ; } 
protected void log ( final String name , final TYPE_1 VAR_1 , final Logger logger ) throws TYPE_2 { if ( logger . VAR_2 ( ) ) { <START> TYPE_3 VAR_3 = new TYPE_7 . TYPE_8 ( TYPE_5 . METHOD_1 ( STRING_1 ) ) ; <END> String VAR_4 = VAR_1 . METHOD_2 ( context . VAR_5 ( ) . METHOD_3 ( ) . writer ( new TYPE_6 ( ) . METHOD_4 ( STRING_2 , VAR_3 ) ) ) ; logger . debug ( name + STRING_3 + VAR_4 ) ; } } 
public void close ( ) throws Exception { <START> in . close ( ) ; <END> } 
private TYPE_1 METHOD_1 ( final String VAR_1 , final TYPE_2 column ) { <START> TYPE_7 . TYPE_8 VAR_2 = TYPE_4 . METHOD_2 ( column . VAR_3 ( ) ) ; <END> TYPE_5 field = TYPE_5 . create ( VAR_1 , VAR_2 ) ; TYPE_6 VAR_4 = METHOD_3 ( column . VAR_3 ( ) , VAR_2 , field , output ) ; return new TYPE_1 ( VAR_4 , column , VAR_1 ) ; } 
public int METHOD_1 ( int VAR_1 ) { if ( VAR_1 == 0 ) { return 0 ; } int count = 0 ; int VAR_2 = VAR_3 . METHOD_2 ( ) . get ( VAR_1 ) ; <START> count += VAR_3 . METHOD_1 ( VAR_1 ) ; <END> for ( final TYPE_1 v : METHOD_3 ( ) ) { count += v . VAR_4 ( VAR_2 ) ; } return count ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 instanceof TYPE_1 ) { <END> return ( TYPE_1 ) VAR_1 ; } else { return null ; } } 
public TYPE_1 ( String name , int index ) { <START> this . name = name ; <END> this . index = index ; this . format = "" ; } 
public abstract void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 ; public abstract void METHOD_2 ( int VAR_2 , String value ) ; @Override public String toString ( ) { <START> return STRING_1 + name + STRING_2 + index ; <END> } 
<START> public < T , TYPE_1 , TYPE_2 extends Throwable > T METHOD_1 ( TYPE_3 < T , TYPE_1 , TYPE_2 > VAR_1 , TYPE_1 value ) throws TYPE_2 { <END> return VAR_1 . METHOD_2 ( this , value ) ; } 
private static boolean METHOD_1 ( TYPE_1 options ) { <START> if ( options . VAR_1 ( TYPE_5 . TYPE_7 . METHOD_2 ( ) ) . VAR_2 || <END> options . VAR_1 ( TYPE_5 . TYPE_8 . METHOD_2 ( ) ) . VAR_2 || options . VAR_1 ( TYPE_5 . TYPE_6 . METHOD_2 ( ) ) . VAR_2 ) { return true ; } return false ; } 
public void close ( ) throws Exception { logger . debug ( STRING_1 ) ; super . close ( ) ; VAR_1 = false ; <START> synchronized ( this ) { <END> if ( VAR_2 != null ) { METHOD_1 ( ) ; VAR_2 . clear ( ) ; } } if ( VAR_3 ) { ( ( TYPE_1 ) VAR_4 ) . close ( ) ; } } 
public TYPE_5 ( TYPE_1 context , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 { <START> super ( context , VAR_2 , VAR_3 , false ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( TYPE_3 . TYPE_1 . TYPE_2 . VAR_5 , null ) ; <END> } 
public TYPE_1 METHOD_1 ( final String VAR_1 , final Object VAR_2 ) { TYPE_1 VAR_3 = null ; try { VAR_3 = VAR_4 . METHOD_2 ( new TYPE_2 < TYPE_1 > ( ) { @Override public TYPE_1 run ( ) { return METHOD_3 ( VAR_1 , VAR_2 ) ; } } ) ; } catch ( Exception e ) { <START> logger . error ( STRING_1 ) ; <END> } return VAR_3 ; } 
public TYPE_3 ( TYPE_1 VAR_2 , String VAR_3 , List < TYPE_2 > VAR_4 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = STRING_1 ; client . VAR_2 ( ) . METHOD_2 ( VAR_1 ) . run ( ) ; String VAR_3 = STRING_2 ; <START> client . VAR_2 ( ) . METHOD_2 ( VAR_3 ) . METHOD_3 ( ) ; <END> } 
public boolean METHOD_1 ( ) { <START> return Boolean . VAR_1 ; <END> } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( VAR_2 == null ) { if ( VAR_1 . VAR_2 != null ) { return false ; } } else if ( ! VAR_2 . equals ( VAR_1 . VAR_2 ) ) { <START> return false ; <END> } return true ; } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = connection . VAR_2 ( VAR_3 ) ; int VAR_4 = - 10 ; if ( INT_1 == VAR_4 ) { VAR_4 -- ; } try { VAR_1 . METHOD_2 ( VAR_4 ) ; } catch ( final Exception e ) { assertThat ( e . getMessage ( ) , METHOD_3 ( STRING_1 ) ) ; <START> throw new TYPE_3 ( e . getMessage ( ) ) ; <END> } } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = connection . VAR_2 ( ) ; int VAR_3 = VAR_1 . METHOD_2 ( ) ; <START> assert ( 0 == VAR_3 ) ; <END> } 
public void close ( ) throws Exception { in . close ( ) ; <START> VAR_1 . close ( ) ; <END> } 
public void close ( ) { if ( VAR_1 ) { logger . debug ( STRING_1 , VAR_2 != null ? getName ( ) : null ) ; return ; } logger . debug ( STRING_2 , VAR_2 != null ? getName ( ) : null ) ; <START> VAR_1 = true ; <END> super . close ( ) ; } 
private int METHOD_1 ( TYPE_1 [ ] VAR_1 ) { int x = 0 ; <START> for ( int i = 0 ; i < ( VAR_1 == null ? 0 : VAR_1 . length ) ; i ++ ) { <END> x += TYPE_2 . METHOD_2 ( VAR_1 [ i ] . METHOD_3 ( ) ) ; } return x ; } 
public TYPE_1 build ( ) throws TYPE_2 { if ( config == null ) { throw new TYPE_3 ( STRING_1 ) ; } TYPE_1 VAR_1 ; if ( VAR_2 == TYPE_6 . TYPE_7 . VAR_5 ) { VAR_1 = new TYPE_4 ( config , VAR_6 ) ; } else { VAR_1 = new TYPE_5 ( config , VAR_6 ) ; } if ( VAR_7 ) { VAR_1 . METHOD_1 ( ) ; } if ( VAR_8 ) { VAR_1 . METHOD_2 ( ) ; <START> } <END> return VAR_1 ; } 
private String METHOD_1 ( String name ) { TYPE_1 . METHOD_2 ( this . VAR_1 != null ) ; <START> String value = "" ; <END> value = VAR_1 . get ( name , "" ) ; value = value . trim ( ) ; return value ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = ! VAR_1 . METHOD_2 ( ) . VAR_3 ; <START> if ( ! VAR_2 || VAR_1 == null ) { <END> return ; } TYPE_2 . METHOD_3 ( VAR_1 , VAR_4 ) ; } 
public String toString ( ) { String msg = STRING_1 + TYPE_1 . METHOD_1 ( VAR_1 ) ; if ( VAR_2 ) { <START> msg += STRING_2 ; <END> } return msg ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = null ; <START> VAR_1 = new TYPE_1 ( ) ; <END> VAR_1 . METHOD_2 ( VAR_2 ) ; } 
public void METHOD_1 ( final String VAR_1 ) throws Exception { Exception ex = null ; for ( TYPE_1 VAR_2 : METHOD_2 ( ) ) { <START> if ( VAR_2 . equals ( VAR_3 . get ( VAR_1 ) ) ) { <END> VAR_2 . close ( ) ; } } if ( ex != null ) { throw ex ; } } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( TYPE_1 . VAR_1 ) ; <END> int VAR_2 = INT_1 ; int VAR_3 = INT_2 ; String VAR_4 = STRING_1 ; TYPE_2 VAR_5 = METHOD_3 ( VAR_2 + STRING_2 + VAR_3 + STRING_2 + VAR_4 + STRING_3 , STRING_4 ) ; Assert . assertTrue ( VAR_5 . METHOD_4 ( ) == VAR_2 && VAR_5 . METHOD_5 ( ) == VAR_3 && VAR_5 . METHOD_6 ( ) == Integer . parseInt ( VAR_4 ) ) ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = TYPE_2 . instance ( ) ; TYPE_1 VAR_3 = VAR_1 ; while ( VAR_3 != null ) { if ( VAR_3 instanceof TYPE_3 ) { VAR_3 = ( ( TYPE_3 ) VAR_3 ) . METHOD_2 ( ) ; continue ; } Double VAR_4 = VAR_2 . METHOD_3 ( VAR_3 ) ; <START> if ( VAR_4 != null && VAR_4 . equals ( FLOAT_1 ) ) { <END> return true ; } else { return false ; } } return false ; } 
protected static void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 ) throws IOException { String VAR_5 = METHOD_2 ( VAR_1 ) ; Path VAR_6 = new Path ( VAR_7 , VAR_2 ) ; Path VAR_8 = new Path ( VAR_6 , VAR_3 ) ; TYPE_1 VAR_9 = VAR_10 . create ( VAR_8 ) ; <START> if ( VAR_4 != null ) { <END> VAR_5 = VAR_5 . METHOD_3 ( STRING_1 , VAR_4 ) ; } VAR_9 . METHOD_4 ( VAR_5 . METHOD_3 ( STRING_2 , VAR_7 ) ) ; VAR_9 . close ( ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , final TYPE_2 VAR_3 ) { this . VAR_3 = VAR_3 ; <START> this . config = TYPE_3 . METHOD_1 ( VAR_2 . METHOD_2 ( ) , TYPE_4 . class ) <END> . name ( STRING_1 ) . build ( ) ; } 
public void METHOD_1 ( ) { final Map < String , TYPE_1 > VAR_1 = new HashMap < > ( ) ; for ( TYPE_1 VAR_2 : TYPE_2 . values ( ) ) { try { VAR_2 . METHOD_2 ( VAR_3 ) ; } catch ( TYPE_4 . TYPE_5 e ) { <START> throw new IllegalStateException ( STRING_1 + e + VAR_2 . METHOD_3 ( ) ) ; <END> } } } 
public int METHOD_1 ( double VAR_1 , long VAR_2 ) { if ( VAR_2 != 0 ) { return ( int ) VAR_2 ; } else { int VAR_3 ; int VAR_4 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> VAR_3 = ( int ) Math . max ( 1 , Math . VAR_5 ( VAR_4 , Math . VAR_6 ( VAR_4 * VAR_1 ) ) ) ; <END> return VAR_3 ; } } 
public void METHOD_1 ( ) throws Exception { logger . debug ( STRING_1 ) ; <START> VAR_1 . METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_2 . VAR_2 , TYPE_3 . VAR_4 , TYPE_3 . TYPE_5 . VAR_6 . name ( ) , TYPE_4 . VAR_2 ) ) ; <END> for ( int i = 0 ; i < VAR_8 ; i ++ ) { METHOD_4 ( false ) ; METHOD_4 ( true ) ; } } 
public TYPE_3 ( TYPE_1 VAR_2 ) { for ( TYPE_2 field : VAR_2 ) { <START> VAR_3 . add ( field ) ; <END> } } 
private void METHOD_1 ( ) throws IOException { if ( VAR_1 > 0 ) { VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_3 . METHOD_1 ( ) ; VAR_4 . METHOD_1 ( ) ; VAR_5 . METHOD_3 ( VAR_2 ) ; VAR_1 = 0 ; VAR_2 . METHOD_4 ( ) ; VAR_2 . METHOD_5 ( VAR_6 ) ; VAR_2 = null ; } VAR_4 . close ( ) ; <START> VAR_5 . close ( ) ; <END> VAR_4 = null ; VAR_5 = null ; index ++ ; } 
protected boolean METHOD_1 ( int index , int VAR_1 ) { <START> if ( VAR_1 < 0 ) { <END> throw new IllegalArgumentException ( STRING_1 + VAR_1 + STRING_2 ) ; } return ( ! ( index < 0 || index > METHOD_2 ( ) - VAR_1 ) ) ; } 
public boolean METHOD_1 ( int index , byte [ ] VAR_1 , int VAR_2 , int length ) { if ( ! METHOD_2 ( index , length ) ) { return false ; } <START> if ( length != 0 ) { <END> TYPE_1 . METHOD_3 ( VAR_1 , VAR_2 , METHOD_4 ( index ) , length ) ; } return true ; } 
public TYPE_3 ( final String VAR_2 , final List < TYPE_1 > VAR_3 ) { try { <START> this . in = new TYPE_2 ( VAR_2 ) ; <END> this . VAR_4 = METHOD_1 ( ) ; VAR_5 = in . read ( buffer ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING_1 + VAR_2 + STRING_2 ) ; } METHOD_2 ( VAR_3 ) ; } 
private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final TYPE_4 field ) { try { final Class < ? extends TYPE_1 > VAR_3 = TYPE_5 . METHOD_2 ( VAR_1 , VAR_2 . METHOD_3 ( ) ) ; TYPE_1 VAR_4 = output . VAR_5 ( field , VAR_3 ) ; VAR_4 . METHOD_4 ( ) ; return VAR_4 ; } catch ( TYPE_6 VAR_6 ) { <START> throw new TYPE_7 ( STRING_1 ) ; <END> } } 
public TYPE_1 getType ( ) { <START> TYPE_1 type = TYPE_1 . VAR_1 ; <END> switch ( VAR_2 ) { case STRING_1 : type = TYPE_1 . VAR_1 ; break ; case STRING_2 : type = TYPE_1 . VAR_3 ; break ; case STRING_3 : type = TYPE_1 . VAR_4 ; break ; } return type ; } 
<START> public int METHOD_1 ( ) { <END> if ( VAR_1 == VAR_2 ) { return 0 ; } int VAR_3 = METHOD_2 ( 2 * VAR_1 ) ; if ( VAR_3 > VAR_2 ) { VAR_3 = VAR_2 ; } return VAR_3 * 4 ; } 
private void METHOD_1 ( int VAR_1 ) throws TYPE_1 , TYPE_2 , IOException { assert VAR_2 [ VAR_1 ] != null ; VAR_2 [ VAR_1 ] . METHOD_2 ( ) ; if ( VAR_3 [ VAR_1 ] != null ) { for ( TYPE_3 VAR_4 : VAR_3 [ VAR_1 ] ) { VAR_4 . clear ( ) ; } VAR_3 [ VAR_1 ] . clear ( ) ; } VAR_3 [ VAR_1 ] = new ArrayList < TYPE_3 > ( ) ; <START> } <END> 
private void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 { final TYPE_3 VAR_2 ; try { VAR_2 = TYPE_3 . TYPE_7 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } catch ( final TYPE_5 ex ) { throw TYPE_6 . METHOD_4 ( ex ) . message ( STRING_1 + STRING_2 ) . build ( logger ) ; } final String VAR_3 = VAR_2 . METHOD_5 ( ) ; logger . info ( STRING_3 , VAR_4 , VAR_3 ) ; METHOD_6 ( VAR_3 ) ; <START> VAR_5 = VAR_3 ; <END> } 
public static int METHOD_1 ( TYPE_1 VAR_1 ) { Iterator < TYPE_1 > VAR_2 = VAR_1 . iterator ( ) ; <START> int i = 0 ; <END> while ( VAR_2 . hasNext ( ) ) { VAR_2 . next ( ) ; i ++ ; } if ( i == 0 ) { i = 1 ; } return i ; } 
public void close ( ) { VAR_1 . METHOD_1 ( VAR_2 . METHOD_2 ( ) ) ; RuntimeException ex = null ; try { VAR_2 . close ( ) ; } catch ( RuntimeException e ) { ex = e ; } try { VAR_3 . close ( ) ; } catch ( RuntimeException e ) { <START> ex = e ; <END> } if ( ex != null ) { throw ex ; } } 
public T get ( String key ) { <START> Integer index = METHOD_1 ( key ) ; <END> if ( index == - 1 ) { return null ; } return get ( index ) ; } 
<START> String METHOD_1 ( ) { <END> return connection ; } 
public TYPE_5 ( TYPE_1 configuration , TYPE_2 context , String name ) throws IOException { this . context = context ; this . VAR_2 = new TYPE_3 ( this , name ) ; this . VAR_3 = configuration ; <START> this . db = new TYPE_4 ( STRING_1 + configuration . VAR_4 ( ) ) ; <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { state = VAR_1 ; if ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . VAR_4 ) ) { VAR_5 . METHOD_4 ( VAR_1 ) ; <START> } <END> } 
TYPE_3 ( TYPE_1 builder ) { String VAR_2 = METHOD_1 ( builder ) ; try { <START> METHOD_2 ( builder , VAR_2 ) ; <END> METHOD_3 ( builder ) ; METHOD_4 ( builder ) ; } catch ( Exception e ) { throw new IllegalStateException ( STRING_1 , e ) ; } VAR_3 = TYPE_2 . METHOD_5 ( config ) ; } 
private long METHOD_1 ( long VAR_1 ) throws IOException { int VAR_2 = 0 ; VAR_3 : do { for ( TYPE_1 < ? > VAR_4 : VAR_5 ) { <START> if ( VAR_4 . METHOD_2 ( VAR_2 , 0 ) ) { <END> break VAR_3 ; } } for ( TYPE_1 < ? > VAR_4 : VAR_5 ) { VAR_4 . METHOD_3 ( ) ; VAR_4 . VAR_6 = - 1 ; } VAR_2 ++ ; } while ( VAR_2 < VAR_1 ) ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . METHOD_1 ( ) ; <END> } 
public TYPE_3 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 ) { this . VAR_4 = VAR_2 . METHOD_1 ( ) ; this . VAR_5 = VAR_3 . METHOD_2 ( ) ; this . VAR_6 = VAR_3 . METHOD_3 ( ) ; this . VAR_7 = VAR_3 . METHOD_4 ( ) ; this . VAR_8 = VAR_3 . METHOD_5 ( ) ; <START> this . VAR_9 = VAR_3 . METHOD_6 ( ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> if ( VAR_2 == null ) { VAR_2 = METHOD_1 ( VAR_3 . METHOD_2 ( ) , VAR_1 , VAR_4 , VAR_5 , VAR_6 ) ; } return VAR_2 ; } 
public TYPE_2 ( TYPE_1 VAR_2 , int VAR_3 ) { this ( VAR_2 ) ; <START> name = name += Integer . toString ( VAR_3 ) ; <END> } 
public static void METHOD_1 ( ) throws Exception { synchronized ( TYPE_1 . class ) { if ( VAR_1 . METHOD_2 ( ) == 0 ) { if ( VAR_2 != null ) { VAR_2 . METHOD_3 ( VAR_3 ) ; VAR_2 . close ( ) ; } if ( VAR_4 ) { TYPE_2 . METHOD_4 ( ) ; } else { <START> TYPE_3 . METHOD_4 ( ) ; <END> } } } } 
public TYPE_1 METHOD_1 ( TYPE_2 child ) throws IOException { if ( ! ( VAR_1 . METHOD_2 ( ) || VAR_2 == null || VAR_2 . size ( ) == 0 ) ) { throw TYPE_3 . METHOD_3 ( ) . message ( String . format ( STRING_1 , VAR_1 . getName ( ) ) ) . build ( logger ) ; } TYPE_4 writer = VAR_1 . METHOD_1 ( child , location , VAR_2 ) ; if ( VAR_3 != null ) { <START> writer . VAR_4 ( VAR_3 ) ; <END> } return writer ; } 
public void METHOD_1 ( String VAR_1 , byte [ ] VAR_2 ) { <START> assert ! cache . containsKey ( VAR_1 ) ; <END> Class < ? > VAR_3 = METHOD_2 ( VAR_1 , VAR_2 , 0 , VAR_2 . length ) ; cache . put ( VAR_1 , VAR_3 ) ; } 
public void METHOD_1 ( Map < String , byte [ ] > results ) { for ( String key : results . keySet ( ) ) { METHOD_2 ( key , results . get ( key ) ) ; <START> } <END> } 
<START> public TYPE_1 ( String message ) { <END> this . message = message ; } 
private String METHOD_1 ( ) throws TYPE_1 { String VAR_1 = System . VAR_2 ( STRING_1 ) ; if ( VAR_1 == null ) { return VAR_3 ? TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) : TYPE_2 . METHOD_2 ( ) . METHOD_4 ( ) ; } else { return VAR_1 ; <START> } <END> } 
public TYPE_1 ( ANNOTATION_1 ( STRING_1 ) String path , ANNOTATION_1 ( STRING_2 ) long start , ANNOTATION_1 ( STRING_3 ) long length , ANNOTATION_1 ( STRING_4 ) int VAR_2 , long VAR_3 ) { super ( path , start , length ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_3 ; <START> this . VAR_5 = null ; <END> } 
<START> public synchronized long METHOD_1 ( long n ) throws IOException { <END> METHOD_2 ( ) ; long VAR_1 = this . count - this . VAR_2 ; long VAR_3 = 0 ; if ( n <= 0 ) { return 0 ; } if ( VAR_1 <= 0 ) { METHOD_2 ( ) ; VAR_1 = METHOD_3 ( ) ; if ( VAR_1 <= 0 ) { return 0 ; } } VAR_3 = VAR_1 < n ? VAR_1 : n ; this . VAR_2 += VAR_3 ; return VAR_3 ; } 
public static TYPE_1 get ( String VAR_1 ) { String value = VAR_1 . METHOD_1 ( ) . trim ( ) ; TYPE_1 VAR_2 = VAR_3 . get ( value ) ; if ( VAR_2 == null ) { <START> throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; <END> } return VAR_2 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { client . VAR_2 ( VAR_1 , parameters , METHOD_2 ( ) ) . METHOD_3 ( ) ; <START> if ( client . VAR_3 ( ) ) { <END> try { client . VAR_4 ( null ) . METHOD_3 ( ) ; } catch ( TYPE_3 e ) { throw new TYPE_2 ( e ) ; } } } 
public TYPE_1 get ( final String key ) { <START> return get ( key , null ) ; <END> } 
public long METHOD_1 ( ) { <START> try ( TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ) { <END> return version . get ( ) ; } } 
public long METHOD_1 ( ) { <START> return options . VAR_1 ( TYPE_1 . METHOD_2 ( ) ) . VAR_2 ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( ) ; <END> VAR_1 . add ( VAR_2 ) ; VAR_1 . add ( TYPE_3 . METHOD_3 ( VAR_3 , TYPE_4 . VAR_5 ) ) ; return VAR_1 ; } 
<START> public void start ( ) { <END> if ( VAR_1 ) { return ; } synchronized ( VAR_2 ) { VAR_1 = true ; VAR_3 = true ; } METHOD_1 ( ) ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { <START> if ( VAR_2 == null ) { <END> VAR_2 = new TYPE_1 ( VAR_3 , VAR_1 , VAR_4 , VAR_3 . METHOD_2 ( ) ) ; } return VAR_2 ; } 
<START> protected String METHOD_1 ( ) { <END> final TYPE_1 VAR_1 = ( TYPE_1 ) table . VAR_2 ( ) ; return VAR_1 . METHOD_2 ( ) . VAR_3 ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( 1 ) ; <START> TYPE_1 client = TYPE_1 . METHOD_3 ( ) . build ( ) ; <END> client . VAR_1 ( ) ; List < TYPE_2 > results = client . VAR_2 ( TYPE_3 . VAR_4 , VAR_5 ) ; for ( TYPE_2 result : results ) { System . out . println ( result ) ; result . VAR_6 ( ) ; } client . close ( ) ; } 
public boolean METHOD_1 ( ) { <START> return options . VAR_1 ( TYPE_1 . METHOD_2 ( ) ) . VAR_2 ; <END> } 
public void close ( ) { if ( VAR_1 != null ) { VAR_1 . clear ( ) ; } if ( VAR_2 != null ) { VAR_2 . clear ( ) ; } if ( VAR_3 != null ) { VAR_3 . clear ( ) ; } container . clear ( ) ; <START> VAR_4 . close ( ) ; <END> super . close ( ) ; } 
protected TYPE_1 ( final TYPE_1 VAR_1 ) { TYPE_2 . METHOD_1 ( VAR_1 , STRING_1 ) ; this . VAR_2 = VAR_1 . VAR_2 ; this . VAR_3 = VAR_1 . VAR_3 ; this . VAR_4 = VAR_1 . VAR_4 ; <START> this . VAR_5 = new TYPE_3 ( TYPE_4 . values ( ) . length ) ; <END> } 
public void close ( ) throws Exception { <START> VAR_1 . close ( ) ; <END> VAR_2 . close ( ) ; } 
public < TYPE_1 > TYPE_2 < TYPE_1 > METHOD_1 ( final TYPE_3 < TYPE_1 > config ) { final TYPE_4 < TYPE_1 > VAR_1 = ( TYPE_4 < TYPE_1 > ) factory . VAR_2 ( config ) ; try { <START> VAR_1 . start ( ) ; <END> } catch ( final Exception e ) { throw new TYPE_5 ( STRING_1 , e ) ; } return VAR_1 ; } 
private void METHOD_1 ( ) { final long VAR_1 = VAR_2 . get ( ) ; while ( true ) { final long VAR_3 = VAR_4 . get ( ) ; if ( VAR_1 > VAR_3 ) { if ( VAR_4 . METHOD_2 ( VAR_3 , VAR_1 ) ) { return ; } else { continue ; } } else { return ; } <START> } <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { if ( VAR_2 ) { TYPE_2 . METHOD_2 ( VAR_1 != null , STRING_1 ) ; synchronized ( VAR_3 ) { final Object object = VAR_4 . remove ( VAR_1 ) ; if ( object == null ) { VAR_1 . VAR_5 . METHOD_3 ( logger ) ; <START> throw new IllegalStateException ( STRING_2 + VAR_1 . id <END> + STRING_3 + id + STRING_4 ) ; } } } } 
public void METHOD_1 ( ) { org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_1 . METHOD_2 ( in . buffer , in . start , in . VAR_6 , INT_1 ) ; in . buffer . METHOD_3 ( in . start ) ; long VAR_7 = Long . VAR_8 ( in . buffer . METHOD_4 ( ) ) ; <START> in . buffer . METHOD_3 ( 0 ) ; <END> long VAR_9 = VAR_7 % ( INT_2 * INT_3 * INT_4 ) ; out . value = VAR_7 - VAR_9 ; } 
public TYPE_4 ( final TYPE_1 split , final TYPE_2 VAR_2 , final String VAR_3 , final String VAR_4 ) { <START> final List < TYPE_3 > VAR_5 = new ArrayList ( ) ; <END> VAR_5 . add ( VAR_6 ) ; VAR_5 . add ( VAR_7 ) ; METHOD_1 ( VAR_5 ) ; this . VAR_2 = VAR_2 ; this . split = split ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) == TYPE_2 . VAR_3 ) { <END> return true ; } return false ; } 
public void METHOD_1 ( String name , TYPE_1 VAR_1 ) { <START> METHOD_2 ( name , VAR_1 ) ; <END> field . VAR_2 ( VAR_1 . METHOD_3 ( ) ) ; } 
protected void METHOD_1 ( boolean VAR_1 ) { <START> close ( ) ; <END> VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_3 . METHOD_2 ( VAR_1 ) ; } 
public int METHOD_1 ( int VAR_1 ) { if ( METHOD_2 ( ) . METHOD_3 ( ) == 0 ) { return 0 ; } <START> return VAR_2 . METHOD_1 ( VAR_1 ) + VAR_3 . METHOD_1 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( final String name , final TYPE_1 type ) { try { TYPE_2 . METHOD_2 ( name ) ; } catch ( final IllegalArgumentException e ) { throw TYPE_3 . METHOD_3 ( e ) . build ( logger ) ; } <START> if ( ! METHOD_4 ( name , type ) ) { <END> VAR_1 . METHOD_1 ( name , type ) ; } } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { try { TYPE_1 . close ( VAR_1 , true ) ; <START> } catch ( Exception e ) { } <END> } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 container ) { <START> TYPE_3 VAR_2 = TYPE_3 . METHOD_2 ( ) ; <END> VAR_2 . start ( ) ; TYPE_4 VAR_3 = new TYPE_4 ( ) ; VAR_3 . METHOD_1 ( this , 0 , VAR_1 . METHOD_3 ( ) ) ; logger . debug ( STRING_1 , VAR_2 . METHOD_4 ( TimeUnit . VAR_4 ) , VAR_1 . METHOD_3 ( ) ) ; } 
<START> public synchronized static Set < Class < ? extends TYPE_1 > > METHOD_1 ( final TYPE_2 VAR_1 ) { <END> final Set < Class < ? extends TYPE_1 > > VAR_2 = VAR_1 . METHOD_2 ( TYPE_1 . class ) ; logger . debug ( STRING_1 , VAR_2 . size ( ) , VAR_2 ) ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { final TYPE_5 VAR_4 = METHOD_2 ( VAR_1 , VAR_2 . METHOD_3 ( ) ) ; return new TYPE_1 ( VAR_1 , <START> ( TYPE_6 ) VAR_2 , <END> VAR_4 , VAR_3 ) ; } 
public static TYPE_1 create ( TYPE_2 config ) { TYPE_3 VAR_1 = new TYPE_4 ( config ) . METHOD_1 ( ) ; TYPE_5 VAR_2 = new TYPE_6 ( config ) . METHOD_2 ( ) ; TYPE_7 VAR_3 = new TYPE_7 ( config ) ; TYPE_8 connection ; try { connection = VAR_3 . METHOD_3 ( ) ; } catch ( TYPE_9 e ) { <START> throw new TYPE_10 ( e . toString ( ) ) ; <END> } return new TYPE_11 ( VAR_1 , connection , VAR_2 ) ; } 
public void METHOD_1 ( ) { <START> if ( VAR_1 != null ) <END> ( ( TYPE_1 ) VAR_2 ) . METHOD_2 ( VAR_1 ) ; } 
public static Collection < TYPE_1 < Object [ ] > > METHOD_1 ( ) { return TYPE_2 . of ( ( ) - > { try { return METHOD_2 ( ) ; <START> } catch ( TYPE_3 | TYPE_4 | TYPE_5 e ) { <END> throw new RuntimeException ( e ) ; } } , ( ) - > { try { return METHOD_3 ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; } 
public boolean equals ( Object o ) { <START> if ( this == o ) { <END> return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) o ; return TYPE_2 . equals ( element , VAR_1 . element ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; if ( VAR_1 instanceof TYPE_1 ) { <START> Map options = ( Map ) VAR_1 . METHOD_2 ( ) . get ( STRING_1 ) ; <END> METHOD_3 ( options ) ; METHOD_4 ( options ) ; METHOD_5 ( VAR_1 ) ; METHOD_6 ( options ) ; METHOD_7 ( VAR_1 ) ; } return this ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; if ( VAR_1 instanceof TYPE_1 ) { <START> Map options = ( Map ) VAR_1 . METHOD_2 ( ) . get ( STRING_1 ) ; <END> METHOD_3 ( options ) ; METHOD_4 ( VAR_1 ) ; METHOD_5 ( VAR_1 ) ; METHOD_6 ( VAR_1 ) ; METHOD_7 ( VAR_1 ) ; } return this ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> super . METHOD_1 ( VAR_1 ) ; if ( VAR_1 . VAR_2 != null ) VAR_2 = VAR_1 . VAR_2 ; VAR_3 = VAR_1 . VAR_3 ; if ( VAR_1 . VAR_4 != null ) VAR_4 = VAR_1 . VAR_4 ; if ( VAR_1 . VAR_5 != null ) VAR_5 = VAR_1 . VAR_5 ; if ( VAR_1 . VAR_6 != VAR_6 ) VAR_6 = VAR_1 . VAR_6 ; } 
private static Optional < TYPE_1 > METHOD_1 ( ) { String VAR_1 = System . getProperty ( TYPE_3 . TYPE_4 . VAR_4 ) ; <START> if ( VAR_1 != null && ! VAR_1 . equals ( "" ) ) { <END> File VAR_5 = new File ( VAR_1 ) ; return Optional . of ( ( TYPE_1 ) new TYPE_2 ( VAR_5 ) ) ; } return Optional . VAR_6 ( ) ; } 
public TYPE_3 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = <START> String . format ( STRING_1 , STRING_2 , STRING_3 ) ; <END> } 
<START> public int METHOD_1 ( ) throws IOException { <END> synchronized ( TYPE_1 . class ) { int VAR_1 = 0 ; int VAR_2 ; do { VAR_2 = METHOD_2 ( ) ; ++ VAR_1 ; if ( VAR_1 > 100 ) { throw new IllegalStateException ( String . format ( STRING_1 , VAR_1 ) ) ; } } while ( TYPE_1 . TYPE_3 . contains ( VAR_2 ) ) ; return VAR_2 ; } } 
private TYPE_1 ( ) { <START> super ( ) ; <END> } 
private static TYPE_1 request ( final String VAR_1 ) throws Exception { return new TYPE_1 . TYPE_5 ( <START> VAR_2 , <END> TYPE_3 . METHOD_1 ( TYPE_6 . TYPE_7 . METHOD_2 ( VAR_1 ) , STRING_1 ) ) ; } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_2 ( ) ; final String VAR_2 = STRING_1 ; final String VAR_3 = STRING_2 ; VAR_1 . user ( TYPE_3 . create ( VAR_3 ) ) . METHOD_2 ( ) . add ( VAR_2 ) ; TYPE_4 . assertThat ( new TYPE_5 ( new TYPE_6 ( VAR_1 ) . METHOD_3 ( new TYPE_7 ( new TYPE_8 ( VAR_3 ) , STRING_3 , STRING_4 ) <START> ) ) . METHOD_4 ( ) , <END> TYPE_9 . METHOD_5 ( STRING_5 , STRING_6 ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> final TYPE_1 VAR_1 = this . VAR_2 . get ( ) . METHOD_2 ( ) <END> . METHOD_3 ( ) . iterator ( ) . next ( ) . METHOD_4 ( ) ; final TYPE_2 VAR_3 = VAR_1 . METHOD_5 ( VAR_1 . start ( ) ) ; final String VAR_4 = STRING_1 ; VAR_3 . METHOD_6 ( ) . METHOD_7 ( VAR_4 ) ; } 
private static String METHOD_1 ( final String user , final String VAR_1 ) { final String VAR_2 = String . format ( STRING_1 , user , VAR_1 ) ; <START> final String VAR_3 = TYPE_1 . METHOD_2 ( <END> VAR_2 . METHOD_3 ( ) ) ; return String . format ( STRING_2 , VAR_3 ) ; } 
public void METHOD_1 ( final String text ) throws IOException { this . VAR_1 . METHOD_1 ( text ) ; for ( final TYPE_1 VAR_2 : this . VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) ) { <START> if ( VAR_2 . METHOD_4 ( ) . isEmpty ( ) || this . VAR_4 == VAR_2 . METHOD_5 ( ) ) { <END> continue ; } this . METHOD_4 ( VAR_2 , text ) ; } } 
<START> public void METHOD_1 ( T item ) { <END> VAR_1 . METHOD_2 ( ) ; try { VAR_1 . METHOD_1 ( item ) ; } finally { VAR_1 . METHOD_3 ( ) ; } } 
public boolean METHOD_1 ( Collection < T > VAR_1 ) { boolean result ; VAR_2 . METHOD_2 ( ) ; try { <START> result = VAR_2 . METHOD_1 ( VAR_1 ) ; <END> } finally { VAR_2 . METHOD_3 ( ) ; } return result ; } 
static TYPE_1 METHOD_1 ( ANNOTATION_1 int res ) throws TYPE_2 , IOException { TYPE_3 stream = TYPE_4 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( res ) ; TYPE_5 factory = TYPE_5 . METHOD_6 ( ) ; factory . VAR_1 ( true ) ; TYPE_1 parser = factory . VAR_2 ( ) ; parser . VAR_3 ( stream , null ) ; <START> parser . next ( ) ; <END> return parser ; } 
void METHOD_1 ( String VAR_1 ) { <START> VAR_1 = VAR_1 . trim ( ) ; <END> int VAR_2 = ( TYPE_1 . METHOD_2 ( STRING_1 + METHOD_3 ( VAR_1 ) ) ) ; METHOD_4 ( VAR_2 ) ; VAR_3 . add ( STRING_2 ) ; } 
private void METHOD_1 ( HashMap < ? extends TYPE_1 , Object > VAR_1 ) { <START> super . METHOD_2 ( ( HashMap < TYPE_1 , Object > ) VAR_1 ) ; <END> } 
public final static byte [ ] METHOD_1 ( byte [ ] VAR_1 , int VAR_2 , int VAR_3 ) throws TYPE_1 { try { return METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <START> } catch ( Exception e ) { <END> throw new TYPE_1 ( e ) ; } } 
<START> public TYPE_5 ( TYPE_1 out , Class < TYPE_2 > VAR_2 , TYPE_3 < TYPE_2 > VAR_3 , int VAR_4 ) { <END> VAR_5 = out ; VAR_6 = VAR_4 ; VAR_7 = VAR_2 ; VAR_8 = VAR_3 ; VAR_9 = new ArrayList < TYPE_4 > ( VAR_6 ) ; } 
public TYPE_5 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 < TYPE_2 > VAR_3 ) { super ( VAR_2 , new TYPE_4 < TYPE_2 > ( VAR_3 ) , VAR_3 ) ; <START> LOG . info ( STRING_1 + VAR_2 . METHOD_1 ( ) ) ; <END> } 
public TYPE_6 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 < TYPE_2 > VAR_3 ) { super ( VAR_2 , new TYPE_4 ( null , VAR_3 ) , new TYPE_5 < TYPE_2 > ( VAR_3 ) ) ; <START> LOG . info ( STRING_1 + VAR_2 . METHOD_1 ( ) ) ; <END> } 
<START> public boolean METHOD_1 ( TYPE_1 < TYPE_2 > message ) throws Exception { <END> return METHOD_2 ( message ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws IOException { TYPE_4 conf = TYPE_5 . METHOD_2 ( VAR_2 ) ; METHOD_3 ( conf ) ; if ( METHOD_4 ( conf ) ) { return new TYPE_6 ( VAR_3 ) ; } else { try { return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; } catch ( InterruptedException e ) { LOG . error ( STRING_1 , e ) ; Thread . VAR_4 ( ) . METHOD_5 ( ) ; throw new IOException ( e ) ; <START> } <END> } } 
private static < T extends TYPE_1 > T METHOD_1 ( TYPE_2 conf , TYPE_3 in , Class < T > VAR_1 ) throws IOException { T split = TYPE_4 . METHOD_2 ( VAR_1 , conf ) ; TYPE_5 factory = new TYPE_5 ( conf ) ; TYPE_6 < T > VAR_2 = factory . VAR_3 ( VAR_1 ) ; <START> VAR_2 . METHOD_3 ( new TYPE_7 ( ( TYPE_3 ) in ) ) ; <END> return VAR_2 . METHOD_4 ( split ) ; } 
public TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( TYPE_4 VAR_1 , TYPE_5 job , String name , TYPE_6 VAR_2 ) throws IOException { <START> if ( VAR_3 . VAR_4 instanceof TYPE_7 ) { <END> ( ( TYPE_7 ) VAR_3 . VAR_4 ) . METHOD_2 ( name ) ; } return VAR_3 . METHOD_1 ( VAR_1 , job , name , VAR_2 ) ; } 
public static void METHOD_1 ( TYPE_1 conf , TYPE_2 VAR_1 ) { if ( VAR_1 != null ) { List < Integer > VAR_2 = TYPE_3 . METHOD_2 ( ) ; for ( TYPE_4 f : VAR_1 . METHOD_3 ( ) ) { VAR_2 . add ( f . VAR_3 ( ) ) ; } conf . set ( TYPE_6 . VAR_5 , TYPE_5 . METHOD_4 ( STRING_1 ) . METHOD_5 ( VAR_2 ) ) ; <START> } else { <END> conf . set ( TYPE_6 . VAR_5 , "" ) ; } } 
public static void METHOD_1 ( TYPE_1 conf ) { if ( conf != null ) { VAR_1 = conf . VAR_2 ( VAR_3 , false ) ; <START> LOG . info ( STRING_1 + VAR_1 ) ; <END> } } 
public void METHOD_1 ( TYPE_1 conf , TYPE_2 VAR_1 ) throws TYPE_3 { try { String VAR_2 = VAR_1 <START> . getProperty ( org . VAR_3 . VAR_4 . VAR_5 . VAR_6 . Constants . VAR_7 ) ; <END> VAR_8 = conf . VAR_9 ( VAR_2 ) . METHOD_2 ( TYPE_4 . class ) ; VAR_10 = TYPE_5 . METHOD_3 ( new TYPE_6 < TYPE_4 > ( VAR_8 ) { } ) ; } catch ( Exception e ) { throw new TYPE_3 ( e ) ; } } 
protected void METHOD_1 ( boolean VAR_1 ) throws IOException { LOG . debug ( STRING_1 + VAR_1 ) ; VAR_2 = ! VAR_1 ; <START> LOG . debug ( STRING_2 ) ; <END> } 
private Map < String , Object > METHOD_1 ( TYPE_1 VAR_1 ) { Map < String , Object > v = TYPE_2 . METHOD_2 ( ) ; for ( Object key : VAR_1 . keySet ( ) ) { <START> if ( VAR_2 == null || VAR_2 . contains ( key . toString ( ) ) ) <END> v . put ( key . toString ( ) , METHOD_3 ( VAR_1 . get ( key ) ) ) ; } return v ; } 
protected TYPE_6 ( TYPE_1 in , TYPE_2 < TYPE_3 > VAR_2 , boolean VAR_3 ) { VAR_4 = in ; VAR_5 = VAR_2 ; <START> VAR_6 = VAR_3 ; <END> VAR_7 = new TYPE_4 ( TYPE_5 . VAR_9 ) ; } 
public TYPE_5 ( String VAR_2 ) { this . VAR_2 = VAR_2 ; try { <START> this . VAR_3 = ( TYPE_1 ) Class . VAR_4 ( VAR_2 ) . METHOD_1 ( ) ; <END> } catch ( TYPE_2 e ) { throw new RuntimeException ( STRING_1 + VAR_2 , e ) ; } catch ( TYPE_3 e ) { throw new RuntimeException ( STRING_1 + VAR_2 , e ) ; } catch ( TYPE_4 e ) { throw new RuntimeException ( STRING_1 + VAR_2 , e ) ; } } 
public TYPE_1 METHOD_1 ( ) throws IOException { <START> if ( VAR_1 != null ) { <END> return VAR_1 ; } else { try { VAR_1 = ( TYPE_2 ) TYPE_3 . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) ; return VAR_1 ; } catch ( TYPE_4 e ) { throw new IOException ( STRING_1 + VAR_2 , e ) ; } catch ( TYPE_5 e ) { throw new IOException ( STRING_1 + VAR_2 , e ) ; } } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> if ( METHOD_2 ( ) ) { <END> METHOD_3 ( ) ; } METHOD_4 ( ) ; } 
private boolean METHOD_1 ( String VAR_1 , String ... VAR_2 ) { <START> if ( StringUtils . isEmpty ( VAR_1 ) || TYPE_1 . isEmpty ( VAR_2 ) ) { <END> return false ; } return Arrays . stream ( VAR_2 ) . METHOD_2 ( name - > METHOD_3 ( VAR_1 , name ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 Throwable VAR_1 ) throws Exception { if ( VAR_2 != null ) <START> VAR_2 . METHOD_2 ( VAR_1 ) ; <END> } 
public TYPE_2 ( List < ? extends TYPE_1 > VAR_2 ) { int size = VAR_2 . size ( ) ; <START> VAR_3 = new TYPE_1 [ size ] ; <END> for ( int i = 0 ; i < size ; i ++ ) { VAR_3 [ i ] = VAR_2 . get ( i ) ; } } 
public void METHOD_1 ( ) throws IOException { <START> File VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; <END> File VAR_3 = VAR_2 . METHOD_3 ( STRING_2 ) ; String VAR_4 = String . format ( STRING_3 , VAR_1 ) ; METHOD_4 ( VAR_1 , VAR_3 , IllegalArgumentException . VAR_5 , VAR_4 ) ; } 
private static boolean METHOD_1 ( String name ) { return METHOD_2 ( name ) || METHOD_3 ( name ) || METHOD_4 ( name ) ; <START> } <END> 
protected TYPE_1 METHOD_1 ( ) { <START> return VAR_1 ? TYPE_1 . VAR_2 : TYPE_1 . VAR_3 ; <END> } 
abstract protected TYPE_1 METHOD_1 ( ) throws TYPE_2 ; public Map < String , TYPE_3 > METHOD_2 ( ) throws TYPE_2 { <START> Map < String , TYPE_3 > VAR_1 = new HashMap < String , TYPE_3 > ( ) ; <END> try ( TYPE_1 VAR_2 = METHOD_1 ( ) ) { while ( VAR_2 . next ( ) ) { TYPE_3 VAR_3 = METHOD_3 ( VAR_2 ) ; VAR_1 . put ( METHOD_4 ( VAR_3 . getName ( ) ) , VAR_3 ) ; } } return VAR_1 ; } 
public void METHOD_1 ( String VAR_1 , TYPE_1 info ) throws TYPE_2 { METHOD_2 ( ) ; <START> if ( VAR_2 != null ) { <END> METHOD_3 ( ) ; } VAR_2 = TYPE_3 . METHOD_4 ( VAR_1 , info ) ; METHOD_5 ( ) ; } 
public static String METHOD_1 ( final String name ) { if ( name == null ) { return "" ; } if ( METHOD_2 ( name ) ) { <START> return name . substring ( 1 , name . length ( ) - 1 ) . METHOD_3 ( STRING_1 , STRING_2 ) ; <END> } return VAR_1 . VAR_2 . TYPE_1 . METHOD_1 ( name ) ; } 
public static Object METHOD_1 ( Object VAR_1 ) throws TYPE_1 { if ( VAR_1 == null ) return null ; TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 . getClass ( ) ) ; <START> if ( VAR_2 != null ) VAR_1 = VAR_2 . METHOD_3 ( VAR_1 ) ; <END> return VAR_1 ; } 
public void run ( ) throws TYPE_1 { TYPE_2 VAR_1 = VAR_2 . METHOD_1 ( ) ; try { VAR_1 . next ( ) ; VAR_3 = VAR_1 . METHOD_2 ( 1 ) ; <START> } finally { <END> VAR_1 . close ( ) ; } } 
public void METHOD_1 ( ) throws TYPE_1 { <START> TYPE_2 . METHOD_2 ( TYPE_8 . TYPE_9 . TYPE_11 . class , new TYPE_6 . TYPE_7 . TYPE_10 ( ) ) ; <END> if ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ) { TYPE_5 . METHOD_5 ( TYPE_5 . VAR_4 , STRING_1 ) ; VAR_3 . METHOD_6 ( false ) ; } else { TYPE_5 . METHOD_5 ( TYPE_5 . VAR_4 , STRING_2 ) ; VAR_3 . METHOD_6 ( true ) ; } } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { <START> System . out . println ( STRING_1 ) ; <END> TYPE_1 VAR_1 = new TYPE_1 ( this . VAR_2 . METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) ) , METHOD_5 ( ) ? this . VAR_2 . METHOD_6 ( ) : false , METHOD_5 ( ) ? this . VAR_2 . METHOD_7 ( ) : false ) ; METHOD_8 ( VAR_1 ) ; return VAR_1 ; } 
public void METHOD_1 ( int index , Object value , int VAR_1 ) throws TYPE_1 { <START> if ( value == null ) <END> VAR_2 . METHOD_2 ( index , VAR_1 ) ; else VAR_2 . METHOD_1 ( index , value ) ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { <START> return new TYPE_1 ( VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) , false , VAR_1 . METHOD_3 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 table ) { super . METHOD_1 ( table ) ; <START> if ( VAR_1 . VAR_2 == 0 && VAR_1 . VAR_3 == 0 ) { <END> table . VAR_4 . METHOD_2 ( ) . VAR_5 = METHOD_3 ( ) ; } } 
private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { final TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 != null ) { return VAR_2 . METHOD_1 ( ) ; } for ( TYPE_2 VAR_3 : VAR_1 . METHOD_4 ( ) ) { <START> return METHOD_1 ( VAR_3 ) ; <END> } return null ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { try { Logger . VAR_2 ( STRING_1 , VAR_1 ) ; final TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 ) ; Logger . VAR_4 ( STRING_2 , VAR_3 . METHOD_3 ( ) ) ; VAR_5 . METHOD_4 ( VAR_3 ) ; VAR_5 . commit ( ) ; <START> } catch ( Exception e ) { <END> Logger . error ( STRING_3 + VAR_1 , e ) ; } finally { Logger . VAR_2 ( STRING_4 , VAR_1 ) ; } } 
private static boolean METHOD_1 ( ANNOTATION_1 String VAR_1 ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( 0 ) ) ; <END> } 
private Boolean METHOD_1 ( ) { <START> return METHOD_2 ( STRING_1 ) ; <END> } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 project , ANNOTATION_1 TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , TYPE_3 . class ) ; if ( VAR_2 == null ) return ; <START> VAR_2 . METHOD_4 ( TYPE_5 . METHOD_5 ( project , VAR_3 , VAR_2 . METHOD_6 ( ) ) ) ; <END> } 
<START> public void METHOD_1 ( ) throws Throwable { <END> METHOD_2 ( STRING_1 ) ; } 
private static List < String > METHOD_1 ( List < String > VAR_1 , String VAR_2 , String VAR_3 ) { for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { String entry = VAR_1 . get ( i ) ; if ( entry . VAR_4 ( VAR_2 ) ) { <START> VAR_1 . set ( i , entry . substring ( 0 , entry . length ( ) - 4 ) + VAR_3 ) ; <END> } } return VAR_1 ; } 
<START> public Collection < TYPE_1 > METHOD_1 ( ) { <END> return new ArrayList < TYPE_1 > ( VAR_1 ) ; } 
protected void log ( final Level VAR_1 , final String msg ) { <START> this . logger . log ( VAR_1 , this . VAR_2 + STRING_1 + msg ) ; <END> } 
<START> public Map < TYPE_1 , TYPE_2 > METHOD_1 ( List < ? extends TYPE_1 > VAR_1 ) throws TYPE_3 { <END> Map < TYPE_1 , TYPE_2 > VAR_2 = new HashMap < > ( ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { try { VAR_2 . put ( VAR_3 , METHOD_2 ( VAR_3 ) ) ; } catch ( TYPE_3 e ) { logger . error ( STRING_1 , VAR_3 . METHOD_3 ( ) , e . VAR_4 ( ) . toString ( ) ) ; } } return VAR_2 ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 != 0 ; <END> } 
TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_4 VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_3 != null && VAR_3 instanceof TYPE_5 ) { TYPE_6 VAR_4 = VAR_5 . METHOD_3 ( VAR_2 , new TYPE_6 ( VAR_6 ) ) ; VAR_4 . METHOD_4 ( ) ; VAR_5 . put ( VAR_2 , VAR_4 ) ; } <END> return VAR_1 . METHOD_1 ( VAR_7 , VAR_5 . get ( VAR_2 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws InterruptedException { if ( ! ( VAR_2 instanceof TYPE_4 ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } TYPE_5 ctx = ( ( TYPE_4 ) VAR_2 ) . METHOD_2 ( ) ; VAR_4 . VAR_5 . update ( System . currentTimeMillis ( ) - VAR_2 . METHOD_3 ( ) ) ; <START> ctx . VAR_6 ( ) . METHOD_4 ( VAR_1 ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return ctx ; } 
public TYPE_12 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 , TYPE_6 VAR_7 ) { this ( new TYPE_7 ( METHOD_1 ( VAR_4 , VAR_5 , VAR_2 ) , new TYPE_8 ( VAR_3 , VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) , VAR_5 ) ) , VAR_4 , TYPE_9 . METHOD_4 ( ) , VAR_2 , <START> new TYPE_4 ( new TYPE_10 ( new TYPE_11 ( ) ) ) , VAR_6 , <END> VAR_7 ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> return VAR_2 . get ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < TYPE_3 > VAR_2 ) { Exception exception = null ; VAR_3 . VAR_4 . METHOD_2 ( ) ; long VAR_5 = System . currentTimeMillis ( ) ; if ( ! VAR_6 ) { exception = new TYPE_4 ( STRING_1 , TYPE_6 . TYPE_5 ) ; } else if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_2 ) ; } <START> VAR_3 . VAR_9 . update ( System . currentTimeMillis ( ) - VAR_5 ) ; <END> VAR_2 . METHOD_3 ( null , exception ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 ) { <START> VAR_3 = new TYPE_2 < > ( ) ; <END> this . VAR_2 = VAR_2 ; } 
void METHOD_1 ( String VAR_1 , short VAR_2 , TYPE_1 VAR_3 ) { if ( VAR_4 ) { if ( VAR_3 == TYPE_1 . VAR_5 ) { if ( VAR_6 . containsKey ( VAR_1 ) ) { VAR_2 = ( VAR_2 > VAR_6 . get ( VAR_1 ) . METHOD_2 ( ) ) ? VAR_2 <START> : VAR_6 . get ( VAR_1 ) . METHOD_2 ( ) ; <END> } } VAR_6 . put ( VAR_1 , new TYPE_2 ( VAR_3 , VAR_2 , VAR_6 . get ( VAR_1 ) ) ) ; } } 
private static boolean METHOD_1 ( Map < String , Integer > VAR_1 , Map < String , Integer > VAR_2 ) { for ( String VAR_3 : VAR_1 . keySet ( ) ) { int VAR_4 = VAR_1 . get ( VAR_3 ) ; if ( VAR_2 . containsKey ( VAR_3 ) ) { int VAR_5 = VAR_2 . get ( VAR_3 ) ; <START> if ( VAR_4 != 1 && VAR_5 > VAR_4 / 2 ) { <END> return true ; } } } return false ; } 
public static boolean METHOD_1 ( Throwable VAR_1 ) { <START> if ( VAR_1 instanceof TYPE_1 ) { return TYPE_2 . equals ( VAR_1 . getMessage ( ) ) ; <END> } else if ( VAR_1 instanceof IOException ) { return TYPE_3 . equals ( VAR_1 . getMessage ( ) ) || TYPE_4 . equals ( VAR_1 . getMessage ( ) ) ; } else { return false ; } } 
public TYPE_1 next ( ) { try { TYPE_2 key = METHOD_1 ( VAR_1 , VAR_2 ) ; VAR_1 . get ( VAR_3 ) ; return new TYPE_1 ( key , new TYPE_3 ( VAR_4 . getName ( ) , ByteBuffer . VAR_5 ( VAR_3 ) , METHOD_2 ( ) ) ) ; } catch ( Exception e ) { logger . error ( STRING_1 + VAR_2 , e ) ; } finally { VAR_2 ++ ; } <START> return null ; <END> } 
<START> public Map < String , List < TYPE_1 > > METHOD_1 ( ) { <END> return Collections . VAR_1 ( VAR_2 ) ; } 
public void METHOD_1 ( String VAR_1 ) { try { TYPE_1 VAR_2 = VAR_3 . get ( TYPE_2 . TYPE_3 ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_1 ( VAR_1 ) ; } } catch ( Exception e ) { <START> VAR_6 . VAR_7 . METHOD_2 ( - 1 ) ; <END> VAR_6 . VAR_8 . METHOD_2 ( 1 ) ; throw e ; } VAR_6 . VAR_7 . METHOD_2 ( - 1 ) ; VAR_6 . VAR_9 . METHOD_2 ( 1 ) ; } 
public void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( TYPE_3 . TYPE_2 ) ; if ( VAR_2 != null ) { try { VAR_2 . METHOD_1 ( VAR_1 ) ; } catch ( Exception e ) { VAR_6 . VAR_7 . METHOD_2 ( - 1 ) ; VAR_6 . VAR_8 . METHOD_2 ( 1 ) ; throw e ; } } <START> VAR_6 . VAR_7 . METHOD_2 ( - 1 ) ; <END> VAR_6 . VAR_9 . METHOD_3 ( ) ; } 
boolean METHOD_1 ( ) throws InterruptedException { <START> return VAR_1 . METHOD_2 ( INT_1 , TimeUnit . VAR_2 ) ; <END> } 
public void METHOD_1 ( Exception e ) { <START> if ( e == null ) { <END> this . e = null ; } else { this . e = new RuntimeException ( e ) ; } } 
public TYPE_7 ( TYPE_1 key , ByteBuffer VAR_2 , TYPE_2 VAR_3 , ByteBuffer VAR_4 , TYPE_3 VAR_5 , long VAR_6 ) throws TYPE_4 { <START> this ( key , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , TYPE_5 . TYPE_6 ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { <END> List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( ( ) - > VAR_4 . METHOD_3 ( VAR_1 , System . currentTimeMillis ( ) , VAR_5 ) , STRING_1 , VAR_1 ) ; return VAR_2 . isEmpty ( ) ? null : VAR_2 . get ( 0 ) ; } 
String METHOD_1 ( ) { String VAR_1 = VAR_2 ; if ( VAR_3 . METHOD_2 ( ) ) { VAR_1 = VAR_4 ; } else if ( VAR_3 . METHOD_3 ( ) ) { VAR_1 = VAR_5 ; } <START> return VAR_1 ; <END> } 
public TYPE_5 ( String VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 ) throws Exception { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_5 = new TYPE_3 ( VAR_2 , VAR_3 ) ; VAR_6 = <START> TYPE_4 . METHOD_1 ( VAR_5 . METHOD_2 ( ) , VAR_5 . METHOD_3 ( ) ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( String VAR_1 ) { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_1 ( VAR_1 ) ; return VAR_2 ; <START> } <END> 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 != null ) { <END> VAR_2 . METHOD_1 ( VAR_1 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 content ) { TYPE_1 VAR_1 = new TYPE_1 ( content , VAR_2 ) ; <START> return VAR_1 ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 content ) { TYPE_1 info = new TYPE_1 ( VAR_1 , error , content , VAR_2 ) ; <START> return info ; <END> } 
<START> public void METHOD_1 ( TYPE_1 channel , TYPE_2 < Long > VAR_1 ) throws IOException { <END> METHOD_2 ( ) ; channel . write ( VAR_2 , VAR_1 ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 ) throws TYPE_2 , IOException { VAR_3 = METHOD_1 ( VAR_2 ) ; VAR_4 = METHOD_2 ( VAR_2 ) ; <START> VAR_5 = VAR_2 . VAR_6 ? null : new TYPE_3 ( VAR_2 ) . METHOD_3 ( ) ; <END> this . VAR_7 = VAR_2 . VAR_8 . isEmpty ( ) ? null : VAR_2 . VAR_8 ; } 
public boolean METHOD_1 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
boolean METHOD_1 ( ) { <START> File VAR_1 = new File ( VAR_2 , VAR_3 ) ; <END> return VAR_1 . exists ( ) ; } 
public TYPE_1 < Long > write ( ByteBuffer VAR_1 , TYPE_2 < Long > VAR_2 ) { <START> if ( VAR_1 == null ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } TYPE_3 VAR_3 = new TYPE_3 ( TYPE_4 . METHOD_1 ( VAR_1 ) , VAR_2 ) ; VAR_4 . add ( VAR_3 ) ; if ( VAR_5 != null ) { VAR_5 . METHOD_2 ( TYPE_7 . TYPE_6 ) ; } if ( ! METHOD_3 ( ) ) { METHOD_4 ( new TYPE_5 ( ) ) ; } return VAR_3 . VAR_8 ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 VAR_3 ) throws TYPE_2 , IOException { try { TYPE_3 VAR_4 = METHOD_2 ( VAR_1 , true ) ; <START> TYPE_4 VAR_5 = VAR_4 . METHOD_3 ( VAR_2 ) . METHOD_4 ( ) ; <END> VAR_5 . METHOD_5 ( VAR_3 , VAR_3 . METHOD_6 ( ) , null , null , null , null , null , null , Context . NONE ) ; } catch ( TYPE_5 e ) { throw e . VAR_6 ( ) ; } } 
<START> String METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = VAR_3 + VAR_4 + VAR_1 ; return VAR_2 . METHOD_2 ( ) ; } 
<START> String METHOD_1 ( TYPE_1 VAR_1 ) { <END> String VAR_2 = VAR_1 . METHOD_2 ( ) ; return VAR_2 . substring ( VAR_2 . length ( ) - 4 ) + VAR_3 + VAR_2 ; } 
public void METHOD_1 ( ) throws Exception { for ( int VAR_1 = 0 ; VAR_1 <= 4 ; VAR_1 ++ ) { for ( int VAR_2 = 0 ; VAR_2 < VAR_1 ; VAR_2 ++ ) { <START> System . out . println ( "" + VAR_1 + STRING_1 + VAR_2 ) ; <END> METHOD_1 ( VAR_1 , VAR_2 ) ; } } } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( true , false ) ) { if ( VAR_2 != null ) { Utils . VAR_3 ( VAR_2 , config . VAR_4 , TimeUnit . VAR_5 ) ; <START> logger . trace ( STRING_1 ) ; <END> } } } 
public void METHOD_1 ( ) throws IOException { synchronized ( VAR_1 ) { if ( ! VAR_2 ) { VAR_3 = METHOD_2 ( ) ; VAR_4 = TYPE_1 . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ; VAR_5 = VAR_3 . METHOD_5 ( ) ; VAR_2 = true ; logger . debug ( <START> STRING_1 , <END> host , VAR_3 . METHOD_6 ( ) , VAR_3 . METHOD_7 ( ) ) ; } } } 
<START> public static List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 , long size ) { <END> long VAR_2 = 0 ; List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_1 metadata : VAR_1 ) { if ( VAR_2 + metadata . VAR_4 ( ) > size ) { if ( VAR_3 . size ( ) == 0 ) { VAR_3 . add ( metadata ) ; } break ; } VAR_3 . add ( metadata ) ; VAR_2 += metadata . VAR_4 ( ) ; } return VAR_3 ; } 
public ByteBuffer METHOD_1 ( ) { <START> return buffer ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 . METHOD_2 ( false , true ) ) { try { return buffer . VAR_2 ( ) ; } finally { buffer . VAR_3 ( ) ; } } else { throw new IllegalStateException ( STRING_1 ) ; } } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> } VAR_1 = null ; } 
public boolean METHOD_1 ( ) { <START> return ! ( buffer == null || VAR_1 < VAR_2 ) ; <END> } 
private TYPE_1 < String , TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 , TYPE_4 VAR_2 ) { <START> List < ? extends TYPE_5 > VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) ; <END> return VAR_3 . stream ( ) . collect ( Collectors . VAR_4 ( VAR_5 - > VAR_5 . METHOD_3 ( ) . METHOD_4 ( ) , TYPE_5 : : METHOD_3 , ( VAR_6 , VAR_7 ) - > VAR_7 , TYPE_1 : : new ) ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> logger . debug ( STRING_1 , <END> VAR_1 ) ; synchronized ( VAR_2 ) { try { METHOD_2 ( VAR_1 ) ; } catch ( TYPE_1 VAR_3 ) { logger . error ( STRING_2 , VAR_1 , VAR_4 , VAR_3 ) ; } } } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) { try { <START> logger . trace ( STRING_1 , VAR_3 , VAR_1 ) ; <END> METHOD_2 ( VAR_1 ) ; if ( ! VAR_4 . get ( ) ) { logger . info ( STRING_2 , VAR_3 ) ; VAR_4 . set ( true ) ; } VAR_5 . VAR_6 . METHOD_3 ( ) ; } catch ( Throwable t ) { VAR_7 . METHOD_4 ( ) ; throw t ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , Object context ) { logger . info ( STRING_1 , VAR_2 ) ; <START> synchronized ( VAR_3 ) { <END> VAR_4 . get ( VAR_2 ) . METHOD_2 ( VAR_1 ) ; VAR_5 . VAR_6 . METHOD_3 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 . getType ( ) . equals ( TYPE_2 . Type . VAR_3 ) ) return ( TYPE_1 ) VAR_1 ; return null ; <END> } 
public TYPE_2 ( TYPE_1 key , long size , boolean VAR_2 , boolean VAR_3 , long VAR_4 , short VAR_5 , short VAR_6 , long VAR_7 ) { <START> this ( key , size , VAR_2 , VAR_3 , VAR_4 , null , VAR_5 , VAR_6 , VAR_7 , ( short ) - 1 ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 id ) { <START> TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( id , null ) ; <END> if ( VAR_1 == null ) { return false ; } VAR_1 . METHOD_3 ( ) ; return true ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_4 - > new TYPE_2 ( properties , VAR_1 . METHOD_3 ( ) , VAR_5 , VAR_6 , VAR_7 ) ) ; <START> VAR_3 . put ( VAR_1 . METHOD_3 ( ) , VAR_2 ) ; <END> return METHOD_4 ( VAR_1 . METHOD_3 ( ) ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { METHOD_2 ( STRING_1 , VAR_1 . equals ( VAR_2 ) ) ; <START> METHOD_2 ( STRING_1 , VAR_1 . METHOD_3 ( ) == VAR_2 . METHOD_3 ( ) ) ; <END> } 
Map < String , String > METHOD_1 ( ) { long VAR_1 = System . currentTimeMillis ( ) ; logger . trace ( STRING_1 , VAR_2 ) ; TYPE_1 VAR_3 = VAR_4 . get ( VAR_2 , null , TYPE_2 . VAR_6 ) ; logger . trace ( STRING_2 , VAR_2 , VAR_1 ) ; if ( VAR_3 == null ) { <START> logger . debug ( STRING_3 , VAR_2 ) ; <END> return null ; } return METHOD_2 ( VAR_3 ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) throws TYPE_4 { TYPE_5 options = METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; return METHOD_4 ( <START> ( ) - > VAR_2 . METHOD_5 ( VAR_3 , VAR_1 , null , true ) , <END> VAR_4 . VAR_5 ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_5 = VAR_3 . VAR_5 ; this . VAR_4 = VAR_4 ; this . VAR_6 = VAR_3 . VAR_7 ; } 
void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 exception ) { <START> logger . info ( STRING_1 + VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) + STRING_2 + exception ) ; <END> VAR_2 . METHOD_4 ( VAR_1 , TYPE_3 . METHOD_5 ( exception . VAR_3 ( ) ) ) ; METHOD_6 ( exception ) ; VAR_4 . VAR_5 . METHOD_7 ( ) ; VAR_4 . METHOD_8 ( VAR_1 . METHOD_2 ( ) ) . VAR_6 . METHOD_7 ( ) ; } 
<START> void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 exception ) { <END> logger . info ( STRING_1 + exception ) ; VAR_2 . METHOD_2 ( VAR_1 , TYPE_3 . METHOD_3 ( exception . VAR_3 ( ) ) ) ; METHOD_4 ( exception ) ; if ( exception . VAR_3 ( ) != TYPE_5 . TYPE_6 && exception . VAR_3 ( ) != TYPE_5 . TYPE_4 ) { VAR_7 . VAR_8 . METHOD_5 ( ) ; } VAR_7 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) . VAR_9 . METHOD_5 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_3 . contains ( VAR_1 ) ) { return ; } VAR_3 . add ( VAR_1 ) ; VAR_4 -- ; if ( VAR_2 == TYPE_2 . VAR_5 ) { VAR_6 ++ ; } else { VAR_7 ++ ; if ( VAR_2 == TYPE_2 . VAR_8 && VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) <START> . equals ( this . VAR_9 ) ) { <END> VAR_10 ++ ; } } } 
void METHOD_1 ( TYPE_1 exception ) { <START> TYPE_2 . METHOD_2 ( VAR_1 , ( TYPE_1 ) exception , this : : METHOD_3 ) ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_1 group = null ; if ( VAR_2 == null ) { group = VAR_1 . VAR_3 ; } else { switch ( VAR_2 ) { case TYPE_5 : group = VAR_1 . VAR_5 ; break ; case TYPE_4 : group = VAR_1 . VAR_7 ; break ; case TYPE_6 : group = VAR_1 . VAR_9 ; break ; case TYPE_7 : <START> group = VAR_1 . VAR_11 ; <END> break ; } } return group ; } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { String VAR_1 = STRING_1 ; List < String > VAR_2 = new ArrayList < > ( ) ; TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( TYPE_8 . VAR_5 , VAR_1 , null ) ; try { TYPE_5 . parse ( VAR_3 , VAR_2 , VAR_6 ) ; } catch ( TYPE_6 e ) { assertTrue ( e . VAR_7 ( ) . equals ( TYPE_9 . TYPE_7 ) ) ; return ; } <START> METHOD_3 ( ) ; <END> } 
private TYPE_1 METHOD_1 ( ByteBuffer VAR_1 , TYPE_2 VAR_2 ) <START> throws TYPE_3 , IOException { <END> TYPE_4 VAR_3 = new TYPE_4 ( VAR_1 ) ; TYPE_5 VAR_4 = new TYPE_5 ( VAR_3 ) ; short VAR_5 = VAR_4 . METHOD_2 ( ) ; Assert . assertEquals ( STRING_1 , TYPE_7 . TYPE_9 , VAR_5 ) ; return TYPE_7 . TYPE_8 . METHOD_3 ( VAR_4 , VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { <START> VAR_2 = TYPE_2 . METHOD_2 ( VAR_3 , VAR_4 , TYPE_1 . VAR_5 , <END> VAR_6 . VAR_7 ) ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( TYPE_4 . name , new TYPE_3 ( this ) ) ; VAR_2 . METHOD_5 ( ) ; VAR_9 = VAR_2 . METHOD_6 ( ) ; logger . info ( STRING_1 , VAR_1 ) ; } 
boolean METHOD_1 ( Long value ) throws TYPE_1 { TYPE_2 . METHOD_2 ( value , STRING_1 ) ; <START> return VAR_1 == TYPE_3 . TYPE_4 ? value < VAR_4 : value > VAR_4 ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_2 ( VAR_2 , VAR_3 , VAR_4 ) ; } return VAR_1 ; } 
TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = TYPE_4 . METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_3 = TYPE_4 . METHOD_1 ( VAR_3 , STRING_2 ) ; this . VAR_4 = TYPE_4 . METHOD_1 ( VAR_4 , STRING_3 ) ; <START> VAR_5 = VAR_3 . VAR_6 * TimeUnit . VAR_7 . METHOD_2 ( 1 ) ; <END> } 
public String toString ( ) { <START> return STRING_1 + VAR_1 . METHOD_1 ( ) + STRING_2 + METHOD_2 ( ) . METHOD_3 ( ) + STRING_2 + METHOD_4 ( ) + STRING_3 ; <END> } 
<START> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , long size , long VAR_2 , short VAR_3 , <END> short VAR_4 ) throws TYPE_3 { TYPE_1 id = METHOD_2 ( VAR_3 , VAR_4 ) ; long VAR_5 = VAR_6 . METHOD_3 ( ) ; TYPE_4 info = new TYPE_4 ( id , size , false , false , VAR_2 , VAR_5 , VAR_3 , VAR_4 , Utils . TYPE_6 ) ; ByteBuffer buffer = ByteBuffer . VAR_8 ( TYPE_5 . METHOD_4 ( ( int ) size ) ) ; VAR_1 . add ( info , buffer ) ; return id ; } 
private TYPE_1 < Long > METHOD_1 ( TYPE_2 channel ) { return METHOD_2 ( VAR_1 . VAR_2 , VAR_3 - > { METHOD_3 ( TYPE_3 . METHOD_4 ( channel ) ) ; VAR_4 . METHOD_5 ( TYPE_6 . TYPE_5 . VAR_7 , new TYPE_4 ( ) . METHOD_6 ( ) ) ; VAR_4 . METHOD_5 ( TYPE_6 . TYPE_5 . VAR_8 , 0 ) ; <START> VAR_9 . METHOD_7 ( null , null ) ; <END> } , uri , LOGGER , VAR_9 ) ; } 
private static void METHOD_1 ( TYPE_1 a , TYPE_1 b ) { assertThat ( STRING_1 , a , METHOD_2 ( b ) ) ; <START> assertThat ( STRING_2 , a . VAR_1 ( ) , METHOD_2 ( b . VAR_1 ( ) ) ) ; <END> assertThat ( STRING_3 , a . toString ( ) , METHOD_2 ( b . toString ( ) ) ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 , TYPE_2 < String > VAR_3 , TYPE_3 < String > VAR_4 ) { TYPE_4 VAR_5 = new TYPE_4 ( STRING_1 , TYPE_5 . TYPE_6 ) ; VAR_8 . VAR_9 . METHOD_2 ( ) ; <START> VAR_8 . METHOD_3 ( VAR_5 , VAR_1 != null && VAR_1 . METHOD_4 ( ) , <END> VAR_2 ) ; METHOD_5 ( VAR_3 , VAR_4 , null , VAR_5 ) ; close ( ) ; } 
public static List < Object [ ] > data ( ) { return Arrays . asList ( <START> new Object [ ] [ ] { { TYPE_1 . class . METHOD_1 ( ) , false } , { TYPE_1 . class . METHOD_1 ( ) , true } , { TYPE_2 . class . METHOD_1 ( ) , false } , { TYPE_2 . class . METHOD_1 ( ) , true } } ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> System . out . println ( VAR_1 ) ; <END> METHOD_2 ( TYPE_1 . METHOD_3 ( VAR_1 ) , true , true ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 id ) { <END> return VAR_1 . get ( id ) ; } 
public void METHOD_1 ( ) throws InterruptedException { <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_2 ( ) ; } } 
<START> static Long METHOD_1 ( TYPE_1 VAR_1 ) { <END> String VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_3 ) ; return VAR_2 == null ? Long . VAR_4 : Long . valueOf ( VAR_2 ) ; } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { VAR_4 = new TYPE_3 ( VAR_2 ) ; VAR_5 = new TYPE_4 ( VAR_2 ) ; VAR_6 = new TYPE_5 ( VAR_3 ) ; <START> this . VAR_7 = <END> VAR_5 . VAR_8 . equals ( TYPE_4 . VAR_9 ) ? null : new TYPE_6 ( VAR_5 . VAR_8 , VAR_4 ) ; } 
<START> void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { <END> try { VAR_2 . get ( VAR_3 , TimeUnit . VAR_4 ) ; Assert . VAR_5 ( STRING_1 + METHOD_2 ( ) ) ; } catch ( Exception e ) { Assert . assertTrue ( STRING_2 , e . VAR_6 ( ) instanceof TYPE_2 ) ; Assert . assertEquals ( STRING_3 , VAR_1 , ( ( TYPE_2 ) e . VAR_6 ( ) ) . METHOD_3 ( ) ) ; } } 
<START> public int METHOD_1 ( byte [ ] VAR_1 , int offset , int length ) throws IOException { <END> METHOD_2 ( length ) ; return VAR_2 . METHOD_1 ( VAR_1 , offset , length ) ; } 
void METHOD_1 ( byte [ ] VAR_1 , long position , int length ) throws IOException { METHOD_2 ( position , length ) ; <START> if ( file . length ( ) < position + length ) { <END> throw new IOException ( STRING_1 + position + STRING_2 + length + STRING_3 + file . length ( ) ) ; } try ( TYPE_1 VAR_2 = new TYPE_1 ( file , STRING_4 , 2 * INT_1 * INT_1 ) ) { VAR_2 . METHOD_3 ( position ) ; VAR_2 . read ( VAR_1 , 0 , length ) ; } } 
<START> private TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException { <END> return new TYPE_1 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( ) throws IOException { if ( VAR_1 == null ) { <START> TYPE_2 VAR_2 = <END> new TYPE_2 ( VAR_3 . VAR_4 , VAR_3 . VAR_5 , VAR_3 . VAR_6 , new TYPE_3 ( ) ) ; List < String > VAR_7 = Collections . VAR_8 ( VAR_3 . VAR_9 ) ; VAR_10 = new TYPE_4 < > ( new TYPE_5 < > ( VAR_2 ) , VAR_3 . VAR_9 , VAR_7 ) ; VAR_1 = new TYPE_1 ( VAR_11 , VAR_10 , VAR_12 , VAR_13 , VAR_14 ) ; } return VAR_1 ; } 
public static long METHOD_1 ( long VAR_1 , long VAR_2 ) { if ( VAR_1 == Utils . TYPE_1 ) { return Utils . TYPE_1 ; } <START> return Math . max ( 0 , TimeUnit . VAR_4 . METHOD_2 ( VAR_1 - VAR_2 ) ) ; <END> } 
<START> private Integer METHOD_1 ( TYPE_1 VAR_1 ) { <END> switch ( VAR_1 ) { case TYPE_4 : return 0 ; case TYPE_3 : return 1 ; case TYPE_5 : return 2 ; case TYPE_2 : return 3 ; case TYPE_6 : return 4 ; case TYPE_7 : return 5 ; default : return Integer . VAR_8 ; } } 
TYPE_11 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 , TYPE_6 VAR_7 ) throws TYPE_7 { <START> super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , new TYPE_8 ( ) { <END> @Override public TYPE_9 METHOD_1 ( TYPE_10 stream ) throws IOException { return null ; } @Override public TYPE_9 METHOD_1 ( String VAR_8 ) throws IOException { return null ; } } , VAR_6 , null , VAR_7 , null , VAR_6 . METHOD_2 ( ) , null ) ; this . VAR_7 = VAR_7 ; METHOD_3 ( ) ; } 
public String METHOD_1 ( byte id ) { int VAR_1 = ( int ) id ; if ( VAR_1 < 0 || VAR_1 >= VAR_2 . size ( ) ) { return null ; } return VAR_2 . get ( id ) ; <START> } <END> 
public synchronized void METHOD_1 ( String VAR_1 , int VAR_2 , String VAR_3 , TYPE_1 VAR_4 ) { int VAR_5 ; try { TYPE_2 VAR_6 = new TYPE_2 ( VAR_3 , VAR_7 ) ; TYPE_3 VAR_8 = VAR_6 . METHOD_2 ( ) ; VAR_5 = VAR_8 . METHOD_3 ( ) . size ( ) ; } catch ( Exception e ) { <START> throw new IllegalArgumentException ( STRING_1 + VAR_3 ) ; <END> } VAR_9 . METHOD_4 ( VAR_3 , VAR_10 - > new TYPE_4 ( VAR_5 ) ) . METHOD_5 ( VAR_1 , VAR_2 ) ; } 
public String toString ( ) { <START> return STRING_1 + this . id + STRING_2 + this . VAR_1 + STRING_3 + this . size + STRING_4 ; <END> } 
private boolean METHOD_1 ( List < String > VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_4 , VAR_5 ) ; if ( VAR_2 == null ) { throw new IllegalStateException ( STRING_1 + VAR_4 + STRING_2 + VAR_5 + STRING_3 ) ; } <START> logger . trace ( STRING_4 , Arrays . toString ( VAR_1 . METHOD_3 ( ) ) ) ; <END> VAR_2 . METHOD_4 ( ) . METHOD_5 ( TYPE_2 . VAR_7 , VAR_1 ) ; return VAR_3 . METHOD_6 ( VAR_4 , VAR_5 , VAR_2 ) ; } 
<START> static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <END> throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 { return Utils . VAR_2 ( VAR_1 . VAR_3 , VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( version , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) ; <START> System . out . println ( VAR_1 . METHOD_2 ( ) ) ; <END> assertEquals ( STRING_1 , version , METHOD_3 ( VAR_1 . METHOD_2 ( ) ) ) ; METHOD_4 ( version , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) ; } 
private boolean METHOD_1 ( List < String > VAR_1 ) { <START> synchronized ( VAR_2 ) { <END> TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( VAR_5 , VAR_6 ) ; if ( VAR_3 == null ) { throw new IllegalStateException ( STRING_1 + VAR_5 + STRING_2 + VAR_6 + STRING_3 ) ; } logger . trace ( STRING_4 , Arrays . toString ( VAR_1 . METHOD_3 ( ) ) ) ; VAR_3 . METHOD_4 ( ) . METHOD_5 ( TYPE_2 . VAR_8 , VAR_1 ) ; return VAR_4 . METHOD_6 ( VAR_5 , VAR_6 , VAR_3 ) ; } } 
boolean METHOD_1 ( TYPE_1 id ) { TYPE_2 VAR_1 = VAR_2 . get ( id ) ; <START> if ( VAR_1 == null || VAR_1 . METHOD_2 ( ) || ! VAR_3 ) { <END> return false ; } try { VAR_1 . start ( ) ; } catch ( Exception e ) { logger . error ( STRING_1 , id , VAR_4 , e ) ; return false ; } return true ; } 
<START> boolean METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = VAR_1 + VAR_3 ; return VAR_4 . remove ( TYPE_1 . name ( Log . VAR_5 , VAR_2 + STRING_1 ) ) && VAR_4 . remove ( TYPE_1 . name ( Log . VAR_5 , VAR_2 + STRING_2 ) ) && VAR_4 . remove ( TYPE_1 . name ( Log . VAR_5 , VAR_2 + STRING_3 ) ) ; } 
<START> boolean METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = VAR_1 + VAR_3 ; return VAR_4 . remove ( TYPE_1 . name ( TYPE_2 . class , VAR_2 + STRING_1 ) ) ; } 
public void METHOD_1 ( TYPE_1 state , boolean VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> this . state = state ; } 
<START> void METHOD_1 ( TYPE_1 id ) { <END> TYPE_2 VAR_1 = ( TYPE_2 ) METHOD_2 ( id ) ; if ( VAR_1 != null ) { try { VAR_1 . METHOD_3 ( ) ; } catch ( Exception e ) { logger . error ( STRING_1 , id , VAR_2 , e ) ; } } } 
boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 == null ) { return true ; } <START> return VAR_2 . METHOD_1 ( VAR_1 ) ; <END> } 
<START> public static boolean METHOD_1 ( short VAR_1 , short VAR_2 , short VAR_3 , <END> short VAR_4 ) { if ( VAR_1 != TYPE_1 . VAR_6 && VAR_2 != TYPE_2 . VAR_8 ) { return ( VAR_1 == VAR_3 ) && ( VAR_2 == VAR_4 ) ; } return true ; } 
void METHOD_1 ( ) { <START> VAR_1 . VAR_2 . METHOD_2 ( ) ; <END> VAR_3 = System . currentTimeMillis ( ) ; VAR_1 . VAR_4 . update ( VAR_3 - VAR_5 ) ; } 
private void METHOD_1 ( Map < String , String > VAR_1 ) { if ( VAR_2 != null ) { try { if ( VAR_3 == null ) { <START> VAR_3 = METHOD_2 ( ) ; <END> } METHOD_3 ( VAR_3 . METHOD_4 ( ) , VAR_1 ) ; } catch ( Exception e ) { logger . error ( STRING_1 , e ) ; VAR_4 . VAR_5 . METHOD_5 ( ) ; } } } 
TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , byte [ ] VAR_5 , byte [ ] VAR_6 , ByteBuffer VAR_7 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; <START> this . VAR_8 = VAR_7 != null ? VAR_7 . METHOD_1 ( ) : null ; <END> } 
public int METHOD_1 ( ) { <START> return Utils . VAR_1 ( new Object [ ] { VAR_2 } ) ; <END> } 
void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { if ( ! METHOD_2 ( ) ) { <START> METHOD_3 ( ) ; <END> METHOD_4 ( true ) ; if ( ! METHOD_5 ( ) ) { METHOD_6 ( VAR_1 ) ; } } } 
public TYPE_1 ( boolean VAR_2 ) { if ( VAR_2 ) { <START> VAR_3 . METHOD_1 ( ) ; <END> } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . METHOD_2 ( new TYPE_2 ( VAR_3 , null , null ) , VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { VAR_1 . clear ( ) ; VAR_1 . add ( new TYPE_1 ( VAR_2 ) ) ; METHOD_2 ( true ) ; <START> for ( int i = 0 ; i < 1 ; i ++ ) { <END> VAR_1 . clear ( ) ; VAR_1 . add ( new TYPE_1 ( VAR_3 . METHOD_3 ( VAR_2 ) + 1 ) ) ; METHOD_2 ( true ) ; } } 
<START> void METHOD_1 ( TYPE_1 VAR_1 ) throws InterruptedException { <END> int VAR_2 = 0 ; List < TYPE_2 > VAR_3 = new ArrayList < > ( ) ; while ( VAR_2 < VAR_4 / 2 && ! VAR_1 . METHOD_2 ( ) ) { METHOD_3 ( VAR_3 ) ; Thread . VAR_5 ( INT_1 ) ; VAR_2 += INT_1 ; VAR_3 . clear ( ) ; } } 
public void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> VAR_1 . close ( ) ; } if ( VAR_2 != null ) { VAR_2 . close ( ) ; } Assert . assertEquals ( STRING_1 , 0 , VAR_1 . METHOD_2 ( ) ) ; if ( VAR_3 != null ) { VAR_3 . close ( ) ; } } 
void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 < > ( ) ; <END> VAR_2 = new TYPE_1 < > ( ) ; } 
<START> public TYPE_3 ( short id , String name , TYPE_1 status , Collection < TYPE_2 > VAR_2 ) { <END> this . id = id ; this . name = name ; this . status = status ; METHOD_1 ( ) ; if ( VAR_2 != null ) { for ( TYPE_2 container : VAR_2 ) { METHOD_2 ( container ) ; METHOD_3 ( container ) ; METHOD_4 ( container ) ; } } } 
<START> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , short VAR_2 ) throws TYPE_3 { <END> return new TYPE_1 ( VAR_1 , VAR_2 ) ; } 
TYPE_3 ( List < TYPE_1 > VAR_2 , List < TYPE_2 > VAR_3 , short version ) { <START> if ( VAR_3 != null && VAR_2 . size ( ) != VAR_3 . size ( ) ) { <END> throw new IllegalArgumentException ( STRING_1 + VAR_2 . size ( ) + STRING_2 + VAR_3 . size ( ) ) ; } this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . version = version ; } 
public TYPE_1 ( ByteBuffer input ) { <START> this . buffer = input ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_2 id , List < TYPE_1 > VAR_1 , boolean VAR_2 ) { TYPE_1 VAR_3 = null ; for ( TYPE_1 VAR_4 : VAR_1 ) { if ( VAR_4 . METHOD_2 ( ) . equals ( id ) ) { <START> if ( ( VAR_2 && VAR_4 . METHOD_3 ( ) ) || ( ! VAR_2 && ! VAR_4 . METHOD_3 ( ) ) ) { <END> VAR_3 = VAR_4 ; break ; } } } return VAR_3 ; } 
public boolean METHOD_1 ( TYPE_1 < Collection < TYPE_2 > > VAR_1 ) { <START> METHOD_2 ( ) ; <END> TYPE_3 . METHOD_3 ( VAR_1 , STRING_1 ) ; return VAR_2 . add ( VAR_1 ) ; } 
private int METHOD_1 ( ByteBuffer VAR_1 ) { <START> return ( VAR_1 . METHOD_2 ( ) - VAR_2 ) / ( VAR_3 ) ; <END> } 
private TYPE_1 METHOD_1 ( ByteBuffer VAR_1 , int index ) throws IOException { <START> VAR_1 . position ( VAR_2 + ( index * ( VAR_3 ) ) ) ; <END> return factory . VAR_4 ( new TYPE_2 ( new TYPE_3 ( VAR_1 ) ) ) ; } 
public Object METHOD_1 ( String key , Object value ) { Object VAR_1 = VAR_2 . put ( key , value ) ; <START> VAR_3 = Collections . VAR_4 ( VAR_2 ) ; <END> return VAR_1 ; } 
public Object METHOD_1 ( String key , Object value ) { <START> Object VAR_1 = VAR_2 . put ( key , value ) ; <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { logger . info ( STRING_1 ) ; long VAR_1 = System . currentTimeMillis ( ) ; <START> TYPE_1 res = new TYPE_2 ( ) ; <END> logger . info ( STRING_2 , System . currentTimeMillis ( ) - VAR_1 ) ; return res ; } 
public Collection < TYPE_1 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) { logger . trace ( STRING_1 , VAR_3 , VAR_1 ) ; METHOD_2 ( VAR_1 ) ; <START> if ( ! VAR_4 ) { <END> logger . info ( STRING_2 , VAR_3 ) ; VAR_4 = true ; } VAR_5 . VAR_6 . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . clear ( ) ; VAR_2 = new TYPE_1 ( METHOD_2 ( VAR_3 ) ) ; VAR_4 = new TYPE_1 ( METHOD_2 ( VAR_3 ) ) ; METHOD_3 ( ) ; METHOD_4 ( ) ; <START> METHOD_5 ( ) ; <END> } 
public void close ( ) { try { VAR_1 = false ; cache . close ( ) ; VAR_2 . METHOD_1 ( ) ; } catch ( Exception e ) { logger . error ( STRING_1 , e ) ; } <START> } <END> 
public void close ( ) { if ( VAR_1 ) { try { VAR_1 = false ; <START> VAR_2 . set ( null ) ; <END> VAR_3 . METHOD_1 ( ) ; } catch ( Exception e ) { logger . error ( STRING_1 , e ) ; } } } 
<START> public static void METHOD_1 ( ByteBuffer VAR_1 , TYPE_1 properties ) { <END> int VAR_2 = VAR_1 . position ( ) ; VAR_1 . METHOD_2 ( TYPE_4 ) ; TYPE_2 . METHOD_3 ( VAR_1 , properties ) ; TYPE_3 VAR_4 = new TYPE_3 ( ) ; VAR_4 . update ( VAR_1 . METHOD_4 ( ) , VAR_2 , METHOD_5 ( properties ) - TYPE_5 ) ; VAR_1 . METHOD_6 ( VAR_4 . getValue ( ) ) ; } 
public TYPE_1 ( long VAR_2 , long VAR_3 , long VAR_4 ) { <START> if ( VAR_2 < 0 || VAR_3 < 0 || VAR_4 < 0 ) { <END> throw new IllegalArgumentException ( STRING_1 + VAR_2 + STRING_2 + VAR_3 + STRING_3 + VAR_4 ) ; } this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
Set < Long > METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; try { return VAR_2 . keySet ( ) ; } finally { VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; <START> } <END> } 
private File METHOD_1 ( String VAR_1 , long size ) throws IOException { File VAR_2 = new File ( VAR_3 , VAR_1 ) ; if ( ! VAR_2 . exists ( ) ) { if ( VAR_4 != null ) { VAR_4 . METHOD_1 ( VAR_2 , size ) ; } else { <START> Utils . VAR_5 ( VAR_2 , size ) ; <END> } } return VAR_2 ; } 
private static Long METHOD_1 ( String VAR_1 ) { Long VAR_2 = null ; if ( VAR_1 . startsWith ( TYPE_1 ) ) { String VAR_3 = VAR_1 . substring ( TYPE_1 . length ( ) ) ; try { VAR_2 = Long . VAR_4 ( VAR_3 ) ; <START> } catch ( TYPE_2 VAR_5 ) { <END> } } return VAR_2 ; } 
<START> short METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 value ) throws IOException { <START> return TYPE_3 . METHOD_2 ( value , VAR_1 ) ; <END> } 
public short METHOD_1 ( ) { short VAR_1 = ( short ) ( VAR_2 + VAR_3 . METHOD_2 ( ) . length + VAR_4 <START> + VAR_5 . length ( ) ) ; <END> switch ( version ) { case VAR_6 : return VAR_1 ; case VAR_7 : return ( short ) ( VAR_8 + VAR_9 + VAR_10 + VAR_11 + VAR_1 ) ; default : throw new IllegalArgumentException ( STRING_1 + version + STRING_2 ) ; } } 
<START> public short METHOD_1 ( ) { <END> return VAR_1 ; } 
public boolean remove ( String path , int options ) { if ( path . equals ( STRING_1 ) ) { METHOD_1 ( STRING_1 , TYPE_2 . TYPE_1 . VAR_3 ) ; VAR_4 . clear ( ) ; return true ; } else { <START> throw new IllegalStateException ( STRING_2 ) ; <END> } } 
<START> public boolean equals ( Object o ) { <END> if ( this == o ) { return true ; } if ( ! ( o instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) o ; if ( id != VAR_1 . id ) { return false ; } if ( ! name . equals ( VAR_1 . name ) ) { return false ; } return status . equals ( VAR_1 . status ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 ) { if ( VAR_2 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } this . id = VAR_2 . getId ( ) ; this . name = VAR_2 . getName ( ) ; this . status = VAR_2 . getStatus ( ) ; for ( TYPE_2 container : VAR_2 . METHOD_1 ( ) ) { VAR_3 . put ( container . getId ( ) , container ) ; } <START> this . version = VAR_4 ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) o ; <START> if ( id == null ^ VAR_1 . id == null ) { <END> return false ; } return id . equals ( VAR_1 . id ) ; } 
TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 time ) { this . VAR_2 = VAR_2 ; this . time = time ; <START> this . VAR_3 = ( long ) VAR_2 . VAR_4 * TYPE_2 . TYPE_4 * TYPE_2 . TYPE_3 ; <END> } 
void METHOD_1 ( boolean VAR_1 ) { <START> this . VAR_1 . METHOD_2 ( false , VAR_1 ) ; <END> } 
<START> public void METHOD_1 ( long value ) { <END> this . value = value ; } 
void METHOD_1 ( ) { if ( VAR_1 != null ) { logger . info ( STRING_1 , VAR_2 ) ; VAR_3 = Utils . VAR_4 ( VAR_5 + VAR_2 , VAR_1 , true ) ; VAR_3 . start ( ) ; try { <START> if ( ! VAR_1 . VAR_6 . METHOD_2 ( 1 , TimeUnit . VAR_7 ) ) { <END> throw new IllegalStateException ( STRING_2 ) ; } } catch ( InterruptedException e ) { throw new IllegalStateException ( e ) ; } } } 
public void METHOD_1 ( ) throws InterruptedException , IOException , TYPE_1 { state . VAR_1 ( ) ; assertTrue ( VAR_2 . METHOD_2 ( ) + STRING_1 , TYPE_2 . METHOD_3 ( VAR_2 , true ) ) ; <START> VAR_3 . METHOD_4 ( ) ; <END> if ( ! VAR_3 . METHOD_5 ( INT_1 , TimeUnit . VAR_4 ) ) { METHOD_6 ( STRING_2 ) ; } VAR_5 . METHOD_4 ( ) ; if ( ! VAR_5 . METHOD_5 ( INT_1 , TimeUnit . VAR_4 ) ) { METHOD_6 ( STRING_3 ) ; } } 
public TYPE_5 ( ) throws InterruptedException { Pair < TYPE_1 , TYPE_2 > VAR_2 = TYPE_3 . METHOD_1 ( properties , time , - 1 , - 1 , - 1 ) ; <START> this . config = VAR_2 . METHOD_2 ( ) ; <END> this . VAR_3 = config . VAR_4 * TYPE_8 . TYPE_6 * TYPE_8 . TYPE_9 * TYPE_8 . TYPE_7 ; this . VAR_9 = VAR_2 . METHOD_3 ( ) ; this . VAR_10 = new TYPE_4 ( config , time ) ; } 
<START> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { <END> return VAR_1 . METHOD_1 ( VAR_2 ) ; } 
public void METHOD_1 ( ) throws InterruptedException { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( true ) ; <END> } VAR_2 . METHOD_1 ( ) ; if ( ! VAR_2 . METHOD_3 ( INT_1 , TimeUnit . VAR_3 ) ) { logger . error ( STRING_1 ) ; } } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( TYPE_1 . VAR_2 , STRING_1 , false , false ) ; METHOD_2 ( TYPE_1 . VAR_3 , STRING_2 , false , false ) ; METHOD_2 ( TYPE_1 . VAR_4 , STRING_3 , false , false ) ; <START> METHOD_2 ( TYPE_1 . VAR_3 , STRING_2 , false , true ) ; <END> } 
public void METHOD_1 ( ) throws InterruptedException , IOException , TYPE_1 { if ( VAR_1 ) { METHOD_2 ( 2 , 2 * VAR_2 , false ) ; <START> METHOD_2 ( 3 , 2 * VAR_2 , false ) ; <END> } else { assertEquals ( STRING_1 , null , state . index . METHOD_3 ( ) ) ; } } 
public TYPE_1 METHOD_1 ( ) throws IOException { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> if ( VAR_2 == null ) { <END> VAR_2 = new TYPE_1 ( ) { @Override public void METHOD_2 ( String VAR_3 , int VAR_4 ) throws Exception { } @Override public void METHOD_3 ( ) { } } ; } return VAR_2 ; } 
<START> public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_4 = TYPE_3 . METHOD_1 ( VAR_2 . VAR_5 , VAR_2 . VAR_6 ) ; VAR_7 = new TYPE_4 ( ) ; this . VAR_3 = VAR_3 ; } 
private boolean METHOD_1 ( TYPE_1 key , TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( key ) ; return VAR_2 != null && VAR_1 . METHOD_3 ( TYPE_2 . TYPE_5 . TYPE_4 ) == VAR_2 . METHOD_3 ( TYPE_2 . TYPE_5 . TYPE_4 ) ; <START> } <END> 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( false , true ) ; List < String > VAR_1 = METHOD_3 ( 0 , 2 ) ; <START> METHOD_4 ( VAR_1 , state . log . METHOD_5 ( ) - TYPE_1 . VAR_3 ) ; <END> long VAR_4 = state . time . METHOD_6 ( ) ; METHOD_7 ( VAR_1 , VAR_4 , true ) ; } 
void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> String VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_1 VAR_3 = VAR_1 . METHOD_4 ( ) ; VAR_4 . METHOD_5 ( VAR_2 , VAR_3 , VAR_5 , TYPE_3 . TYPE_2 ) ; } } 
<START> TYPE_1 < String , Long > METHOD_1 ( ) { <END> TYPE_1 < String , Long > VAR_1 = new TYPE_2 < > ( ) ; TYPE_3 VAR_2 = log . VAR_3 ( ) ; while ( VAR_2 != null ) { VAR_1 . put ( VAR_2 . getName ( ) , VAR_2 . METHOD_2 ( ) ) ; VAR_2 = log . VAR_4 ( VAR_2 ) ; } return VAR_1 ; } 
Pair < TYPE_1 , TYPE_3 . TYPE_4 > METHOD_1 ( ) { <START> if ( version == ( short ) 1 && VAR_1 != null ) { <END> return new Pair < > ( VAR_1 . METHOD_2 ( ) , TYPE_3 . TYPE_4 . values ( ) [ VAR_1 . METHOD_3 ( ) ] ) ; } else { return null ; } } 
short METHOD_1 ( ) { <START> return this . version ; <END> } 
private void METHOD_1 ( ) { for ( Map . Entry < String , String > entry : VAR_1 . entrySet ( ) ) { TYPE_1 VAR_2 = new TYPE_1 ( entry . getValue ( ) ) ; VAR_3 . put ( entry . getKey ( ) , VAR_2 ) ; if ( ! VAR_2 . METHOD_2 ( ) . contains ( VAR_4 ) ) { VAR_2 . METHOD_3 ( VAR_4 ) ; <START> VAR_2 . METHOD_4 ( VAR_4 , STRING_1 , TYPE_2 . build ( ) ) ; <END> } } } 
<START> TYPE_2 ( ) { <END> this ( Type . TYPE_1 , null , null , null , null ) ; } 
boolean METHOD_1 ( ) { <START> return VAR_1 == 1 ? true : false ; <END> } 
private void METHOD_1 ( final String VAR_1 , TYPE_1 < TYPE_2 > VAR_2 , final TYPE_3 < TYPE_2 > VAR_3 ) { VAR_4 . METHOD_2 ( VAR_1 , VAR_2 , new TYPE_3 < TYPE_2 > ( ) { @Override public void METHOD_3 ( TYPE_2 result , Exception exception ) { if ( exception == null ) { VAR_5 . METHOD_4 ( VAR_1 ) ; } <START> VAR_3 . METHOD_3 ( result , exception ) ; <END> } } ) ; VAR_6 . METHOD_5 ( ) ; } 
TYPE_1 ( ) throws IOException { super ( STRING_1 ) ; <START> super . VAR_2 . close ( ) ; <END> } 
static long METHOD_1 ( String name ) { if ( name . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> return Long . VAR_1 ( name . substring ( name . VAR_2 ( TYPE_1 . VAR_4 ) + 1 , name . length ( ) ) ) ; <END> } 
TYPE_2 ( Map < String , TYPE_1 > VAR_2 ) { if ( VAR_2 != null ) { <START> this . VAR_2 . METHOD_1 ( VAR_2 ) ; <END> } } 
TYPE_1 METHOD_1 ( TYPE_2 id ) { TYPE_3 VAR_1 = VAR_2 . get ( id ) ; <START> return VAR_1 . METHOD_2 ( ) ? VAR_1 : null ; <END> } 
<START> public TYPE_1 ( String msg , boolean VAR_2 , boolean VAR_3 ) { <END> this . message = msg ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
private void METHOD_1 ( int count ) { <START> if ( VAR_1 - count >= 0 ) { <END> VAR_1 -= count ; } } 
<START> private boolean METHOD_1 ( Thread VAR_1 , Thread . TYPE_2 state ) { <END> long VAR_3 = INT_1 ; long VAR_4 = TYPE_1 . getInstance ( ) . METHOD_2 ( ) ; while ( VAR_1 . METHOD_3 ( ) != state ) { if ( TYPE_1 . getInstance ( ) . METHOD_2 ( ) - VAR_4 > VAR_3 ) { return false ; } else { Thread . VAR_5 ( ) ; } } return true ; } 
private void METHOD_1 ( ) { <START> VAR_1 . VAR_2 . VAR_3 . METHOD_2 ( ) ; <END> if ( VAR_4 != null ) { long VAR_5 = System . currentTimeMillis ( ) - VAR_4 ; VAR_1 . VAR_2 . VAR_6 . update ( VAR_5 ) ; logger . trace ( STRING_1 , VAR_5 ) ; VAR_1 . VAR_2 . VAR_7 . METHOD_3 ( ) ; } else { VAR_1 . VAR_2 . VAR_8 . METHOD_4 ( ) ; } } 
void METHOD_1 ( ) { buf . VAR_1 ( ) ; METHOD_2 ( ) ; VAR_2 = time . VAR_3 ( ) ; <START> VAR_4 . VAR_5 . update ( VAR_2 - VAR_6 ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { return VAR_1 ; } VAR_1 = null ; for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_3 ( ) ) { VAR_4 ++ ; VAR_2 . METHOD_4 ( VAR_4 , METHOD_5 ( VAR_4 ) ) ; VAR_1 = VAR_2 ; <START> VAR_5 . VAR_6 . update ( time . VAR_7 ( ) - VAR_8 ) ; <END> VAR_9 = time . VAR_7 ( ) ; break ; } } return VAR_1 ; } 
void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { try { METHOD_2 ( ) ; METHOD_3 ( ) ; if ( ! METHOD_4 ( ) ) { METHOD_5 ( VAR_1 ) ; } } catch ( Exception e ) { <START> logger . error ( STRING_1 , e ) ; <END> VAR_2 . VAR_3 . METHOD_6 ( ) ; METHOD_7 ( new TYPE_3 ( STRING_2 , e , TYPE_5 . TYPE_4 ) ) ; } } 
void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { try { METHOD_2 ( ) ; METHOD_3 ( ) ; if ( ! METHOD_4 ( ) ) { METHOD_5 ( VAR_1 ) ; } } catch ( Exception e ) { <START> VAR_2 . VAR_3 . METHOD_6 ( ) ; <END> METHOD_7 ( new TYPE_3 ( STRING_1 , e , TYPE_5 . TYPE_4 ) ) ; } } 
TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return VAR_2 . containsKey ( VAR_1 ) ? VAR_2 . get ( VAR_1 ) : VAR_2 . get ( null ) ; <END> } 
<START> public void METHOD_1 ( String VAR_1 ) <END> throws TYPE_1 { throw new IllegalStateException ( STRING_1 ) ; } 
<START> public synchronized TYPE_1 getStatus ( ) { <END> TYPE_1 status = null ; try { if ( VAR_1 . METHOD_1 ( VAR_2 ) ) { status = TYPE_1 . valueOf ( VAR_1 . getString ( VAR_2 ) ) ; } } catch ( Exception e ) { throw new IllegalStateException ( e ) ; } return status ; } 
public void METHOD_1 ( ) throws IOException { String VAR_1 = VAR_2 . METHOD_2 ( new TYPE_1 ( STRING_1 , server . VAR_3 ) , VAR_4 , VAR_4 , TYPE_2 . VAR_6 ) ; <START> Assert . VAR_7 ( STRING_2 , <END> VAR_2 . METHOD_3 ( VAR_1 ) ) ; while ( ! VAR_2 . METHOD_4 ( ) . contains ( VAR_1 ) ) { VAR_2 . METHOD_5 ( INT_1 ) ; } Assert . assertTrue ( STRING_3 , VAR_2 . METHOD_3 ( VAR_1 ) ) ; } 
<START> public void METHOD_1 ( final TYPE_1 VAR_1 ) { <END> VAR_2 = new TYPE_2 < Long > ( ) { @Override public Long getValue ( ) { return VAR_1 . get ( ) ; } } ; } 
private void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) && VAR_2 ) { while ( VAR_3 . get ( ) == null && VAR_4 . containsKey ( VAR_5 ) ) { ByteBuffer VAR_6 = VAR_4 . remove ( VAR_5 ) ; <START> VAR_7 . write ( VAR_6 , VAR_8 ) ; <END> VAR_5 ++ ; } if ( VAR_3 . get ( ) != null || VAR_9 . get ( ) == VAR_10 ) { METHOD_3 ( ) ; } } } 
void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 . METHOD_2 ( ) ; TYPE_3 VAR_3 = VAR_4 . remove ( VAR_2 . METHOD_3 ( ) ) ; if ( VAR_5 . contains ( VAR_3 ) ) { VAR_3 . METHOD_1 ( VAR_1 ) ; if ( VAR_3 . METHOD_4 ( ) ) { VAR_5 . remove ( VAR_3 ) ; <START> VAR_6 . VAR_7 . METHOD_5 ( ) ; <END> } } } 
public void METHOD_1 ( ) throws Exception { <START> <END> VAR_1 = VAR_2 . METHOD_2 ( INT_1 * INT_1 ) + 1 ; for ( int i = 0 ; i < 10 ; i ++ ) { VAR_3 = VAR_1 * i + VAR_2 . METHOD_2 ( VAR_1 - 1 ) + 1 ; METHOD_3 ( ) ; METHOD_4 ( ) ; } } 
public void METHOD_1 ( ) throws Exception { VAR_1 = VAR_2 . METHOD_2 ( INT_1 * INT_1 ) + 1 ; for ( int i = 0 ; i < 10 ; i ++ ) { VAR_3 = VAR_2 . METHOD_2 ( VAR_1 ) + 1 ; <START> METHOD_3 ( ) ; <END> METHOD_4 ( ) ; } } 
<START> boolean remove ( TYPE_1 VAR_1 ) { <END> if ( VAR_2 . remove ( VAR_1 ) ) { VAR_3 . VAR_4 . METHOD_1 ( ) ; return true ; } else { return false ; } } 
<START> public void METHOD_1 ( ) <END> throws Exception { VAR_1 = new TYPE_1 ( ) ; VAR_2 = new TYPE_2 ( INT_1 ) ; VAR_3 = new TYPE_3 ( VAR_2 , TYPE_4 . getInstance ( ) ) ; VAR_3 . METHOD_2 ( ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { List < TYPE_2 > VAR_3 = Collections . VAR_4 ( VAR_1 ) ; <START> List < TYPE_4 > VAR_5 = new ArrayList < TYPE_4 > ( ) ; <END> TYPE_4 VAR_6 = new TYPE_4 ( VAR_1 . METHOD_2 ( ) , VAR_3 ) ; VAR_5 . add ( VAR_6 ) ; return new TYPE_1 ( TYPE_5 . VAR_8 . METHOD_3 ( ) , VAR_9 . VAR_10 , VAR_2 , VAR_5 , TYPE_6 . TYPE_7 ) ; } 
private void METHOD_1 ( ) { logger . trace ( STRING_1 , VAR_1 , VAR_2 ) ; <START> VAR_3 = System . currentTimeMillis ( ) ; <END> } 
<START> protected void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( ) ; } 
void METHOD_1 ( String VAR_1 , TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 < TYPE_2 > VAR_3 ) { try { <START> TYPE_4 VAR_4 = TYPE_5 . METHOD_2 ( VAR_1 , VAR_5 ) ; <END> TYPE_6 VAR_6 = new TYPE_6 ( VAR_7 , VAR_4 , VAR_5 , VAR_8 , VAR_2 , VAR_3 , new TYPE_7 ( ) , time ) ; VAR_9 . add ( VAR_6 ) ; } catch ( TYPE_8 e ) { TYPE_9 . METHOD_3 ( VAR_2 , VAR_3 , null , e ) ; } } 
private void METHOD_1 ( ) { try { if ( VAR_1 != null ) { VAR_2 . add ( VAR_1 ) ; } VAR_1 = METHOD_2 ( VAR_2 ) ; VAR_3 = new TYPE_1 ( VAR_1 ) ; VAR_4 = new TYPE_2 ( VAR_5 . VAR_6 , VAR_1 , false , <START> VAR_5 . VAR_7 , VAR_5 . VAR_8 , false ) ; <END> VAR_9 . clear ( ) ; state = TYPE_5 . TYPE_4 ; } catch ( TYPE_3 e ) { METHOD_3 ( e ) ; } } 
<START> public TYPE_9 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , <END> TYPE_4 VAR_5 , TYPE_5 VAR_6 , TYPE_6 time ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . time = time ; VAR_7 = Collections . VAR_8 ( new TYPE_7 < TYPE_8 , Boolean > ( ) ) ; VAR_9 = new HashMap < Integer , TYPE_8 > ( ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( ) ; TYPE_1 VAR_1 = TYPE_2 . METHOD_3 ( VAR_2 , VAR_3 ) ; <START> assertTrue ( STRING_1 , VAR_1 . equals ( VAR_4 ) ) ; <END> } 
<START> TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 < TYPE_3 > state , TYPE_4 time ) <END> throws IOException { super ( new TYPE_5 ( new TYPE_6 ( ) ) , time , null ) ; super . close ( ) ; this . VAR_2 = VAR_2 ; this . state = state == null ? new TYPE_2 < TYPE_3 > ( TYPE_3 . TYPE_8 ) : state ; this . time = time ; } 
<START> private TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { return VAR_1 ; } else { for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_3 ( ) ) { VAR_4 ++ ; VAR_2 . METHOD_4 ( VAR_4 , METHOD_5 ( VAR_4 ) ) ; VAR_1 = VAR_2 ; return VAR_2 ; } } } return null ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <END> for ( int i = VAR_2 ; i < VAR_1 . VAR_3 . size ( ) ; i ++ ) { TYPE_2 VAR_4 = VAR_1 . VAR_3 . get ( i ) . VAR_4 ; if ( VAR_2 == i ) { assertTrue ( STRING_1 , VAR_4 . VAR_5 . get ( ) ) ; } else { METHOD_2 ( STRING_2 , VAR_4 . VAR_5 . get ( ) ) ; } } } 
void METHOD_1 ( String VAR_1 ) { <START> VAR_2 . add ( VAR_1 ) ; <END> VAR_3 ++ ; } 
TYPE_1 METHOD_1 ( ) throws IOException { <START> TYPE_2 VAR_1 = new TYPE_2 ( VAR_2 , time , VAR_3 ) ; <END> TYPE_3 VAR_4 = new TYPE_3 ( VAR_5 , VAR_6 , time ) ; return new TYPE_1 ( VAR_1 , VAR_4 , VAR_7 , VAR_8 , VAR_9 , time ) ; } 
public void METHOD_1 ( ) throws IOException { METHOD_2 ( ) ; List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; <START> { <END> VAR_2 . close ( ) ; try { VAR_2 . METHOD_3 ( VAR_1 ) ; VAR_1 . clear ( ) ; Assert . VAR_3 ( STRING_1 ) ; } catch ( IllegalStateException e ) { } } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( ! METHOD_2 ( ) ) { VAR_2 . VAR_3 . METHOD_3 ( ) ; throw new TYPE_2 ( STRING_1 , TYPE_5 . TYPE_4 ) ; } else { TYPE_3 . METHOD_4 ( VAR_1 ) ; <START> VAR_6 . add ( VAR_1 ) ; <END> } } 
public void METHOD_1 ( TYPE_1 ctx , TYPE_2 VAR_1 ) throws Exception { if ( VAR_2 ) { <START> VAR_2 = false ; <END> METHOD_2 ( ) ; VAR_3 . append ( STRING_1 ) ; VAR_4 . METHOD_3 ( VAR_3 . toString ( ) ) ; } super . METHOD_1 ( ctx , VAR_1 ) ; } 
TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , int VAR_5 , int VAR_6 , TYPE_4 time ) { <START> if ( VAR_2 == null || VAR_3 == null ) { <END> throw new IllegalArgumentException ( STRING_1 + VAR_2 + STRING_2 + STRING_3 + VAR_3 ) ; } this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . time = time ; } 
TYPE_1 METHOD_1 ( ) <START> throws Exception { <END> TYPE_2 VAR_1 = new TYPE_2 ( VAR_2 , time , VAR_3 ) ; TYPE_3 VAR_4 = new TYPE_4 ( VAR_1 , VAR_5 , VAR_6 , VAR_7 , time ) ; return new TYPE_1 ( VAR_1 , VAR_4 ) ; } 
private void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 && ctx . channel ( ) . METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( TYPE_1 . VAR_4 ) ; logger . trace ( STRING_1 , ctx . channel ( ) ) ; } <START> if ( request != null && request . VAR_5 ( ) ) { <END> METHOD_4 ( ) ; } VAR_6 = true ; } 
public static void METHOD_1 ( ByteBuffer VAR_1 , List < TYPE_1 > VAR_2 ) { int VAR_3 = VAR_2 . get ( 0 ) . METHOD_2 ( ) ; for ( TYPE_1 VAR_4 : VAR_2 ) { if ( VAR_4 . METHOD_2 ( ) != VAR_3 ) { throw new IllegalArgumentException ( STRING_1 ) ; } } VAR_1 . METHOD_3 ( TYPE_2 ) ; <START> VAR_1 . METHOD_4 ( VAR_2 . size ( ) ) ; <END> for ( TYPE_1 VAR_4 : VAR_2 ) { VAR_1 . put ( VAR_4 . METHOD_5 ( ) ) ; } } 
private List < TYPE_1 > METHOD_1 ( ByteBuffer VAR_1 , TYPE_2 VAR_2 ) throws TYPE_3 , IOException { TYPE_4 VAR_3 = new TYPE_4 ( VAR_1 ) ; TYPE_5 VAR_4 = new TYPE_5 ( VAR_3 ) ; short VAR_5 = VAR_4 . METHOD_2 ( ) ; <START> Assert . assertEquals ( STRING_1 , VAR_5 , <END> TYPE_7 . TYPE_9 ) ; return TYPE_7 . TYPE_8 . METHOD_3 ( VAR_4 , VAR_2 ) ; } 
<START> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> VAR_2 . METHOD_2 ( ) ; try { if ( instance == null ) { TYPE_3 . VAR_1 = VAR_1 ; instance = new TYPE_1 ( VAR_1 ) ; } if ( TYPE_3 . VAR_1 != VAR_1 ) { throw new IllegalStateException ( STRING_1 + STRING_2 ) ; } } finally { VAR_2 . METHOD_3 ( ) ; } return instance ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 response , Exception exception ) throws TYPE_4 { <START> if ( METHOD_2 ( ) && VAR_3 != null && VAR_3 . METHOD_2 ( ) ) { <END> VAR_3 . METHOD_3 ( VAR_1 , VAR_2 , response , exception ) ; } else { VAR_4 . VAR_5 . METHOD_4 ( ) ; throw new TYPE_4 ( STRING_1 , TYPE_6 . TYPE_5 ) ; } } 
protected int METHOD_1 ( ) { int count = 0 ; for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { <START> if ( VAR_2 . get ( i ) . METHOD_2 ( ) && VAR_1 . get ( i ) . METHOD_3 ( ) ) { <END> count ++ ; } } return count ; } 
private TYPE_1 METHOD_1 ( ) { ArrayList < TYPE_1 > VAR_1 = VAR_2 . get ( ) ; if ( VAR_1 . size ( ) == 0 ) { return null ; } else { <START> return VAR_1 . get ( TYPE_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 . size ( ) ) ) ; <END> } } 
<START> void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , Object VAR_3 , Exception exception ) { <END> try { VAR_1 . METHOD_2 ( VAR_3 , exception ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_3 ( VAR_3 , exception ) ; } } catch ( Exception e ) { logger . error ( STRING_1 , e ) ; } finally { } } 
public String METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , int VAR_3 , TYPE_2 VAR_4 ) throws IOException { String VAR_5 = VAR_1 . METHOD_2 ( ) + VAR_1 . METHOD_3 ( ) ; Integer count = VAR_6 . get ( VAR_5 ) ; if ( count != null ) { count ++ ; } else { count = 1 ; } VAR_6 . put ( VAR_5 , count ) ; <START> String VAR_7 = VAR_5 + index ++ ; <END> VAR_8 . add ( VAR_7 ) ; return VAR_7 ; } 
<START> public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_4 = new HashMap < TYPE_2 , List < TYPE_1 > > ( ) ; this . VAR_4 . put ( VAR_3 . METHOD_1 ( ) . METHOD_2 ( ) , Arrays . asList ( VAR_3 ) ) ; } 
public int read ( ) { int data = - 1 ; if ( METHOD_1 ( ) ) { <START> data = VAR_1 . get ( ) & INT_1 ; <END> VAR_2 -- ; } return data ; } 
<START> private void METHOD_1 ( boolean VAR_1 ) { <END> VAR_2 . METHOD_2 ( TYPE_1 . VAR_4 ) ; logger . trace ( STRING_1 , ctx . channel ( ) ) ; } 
<START> public void run ( ) { <END> while ( METHOD_1 ( ) ) { try { METHOD_2 ( ) ; METHOD_3 ( ) ; } catch ( Exception e ) { logger . error ( STRING_1 , e ) ; VAR_1 . VAR_2 . METHOD_4 ( ) ; } } METHOD_5 ( ) ; logger . trace ( STRING_2 ) ; VAR_3 . METHOD_6 ( ) ; } 
private void METHOD_1 ( ) { if ( METHOD_2 ( ) ) { <START> try { <END> VAR_1 . METHOD_3 ( ) ; VAR_2 . set ( false ) ; logger . trace ( STRING_1 , ctx . channel ( ) ) ; } finally { VAR_1 . METHOD_4 ( ) ; } } } 
public long METHOD_1 ( TYPE_1 channel ) throws IOException { <START> long VAR_1 = 0 ; <END> if ( ! METHOD_2 ( ) ) { VAR_1 = channel . write ( buffer ) ; } return VAR_1 ; } 
public TYPE_9 ( String VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 , TYPE_4 VAR_6 , long VAR_7 , TYPE_5 VAR_8 ) throws TYPE_6 { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , TYPE_8 . TYPE_7 ) ; logger . trace ( <START> STRING_1 + VAR_2 + STRING_2 + VAR_3 + STRING_3 + ( <END> VAR_4 != null ) + STRING_4 + VAR_5 + STRING_5 + VAR_6 + STRING_6 + VAR_7 + STRING_7 + ( VAR_8 != null ) ) ; this . VAR_11 = null ; } 
void METHOD_1 ( ) throws IOException { <START> } <END> 
<START> boolean METHOD_1 ( ) { <END> return true ; } 
public int METHOD_1 ( ) { return VAR_1 . METHOD_2 ( ) - VAR_2 . get ( ) < Integer . VAR_3 ? <START> ( int ) VAR_1 . METHOD_2 ( ) - VAR_2 . get ( ) : Integer . VAR_3 ; <END> } 
public int read ( ) throws IOException { ByteBuffer buffer = VAR_1 . METHOD_1 ( ) ; buffer . clear ( ) ; int data = - 1 ; if ( read ( VAR_1 ) != - 1 ) { buffer . VAR_2 ( ) ; <START> data = buffer . get ( ) & INT_1 ; <END> VAR_3 . METHOD_2 ( ) ; } return data ; } 
TYPE_3 ( ) { <START> this . VAR_2 = <END> new TYPE_1 ( config . VAR_3 , VAR_4 , true , TYPE_2 . getInstance ( ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 key ) { <START> if ( key == null ) { <END> throw new IllegalStateException ( STRING_1 ) ; } return ( TYPE_1 ) key . VAR_1 ( ) ; } 
<START> @Override public String toString ( ) { <END> return STRING_1 + METHOD_1 ( ) + STRING_2 + METHOD_2 ( ) + STRING_3 ; } 
@Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) o ; if ( VAR_2 != VAR_1 . VAR_2 ) { return false ; } <START> return VAR_3 . equals ( VAR_1 . VAR_3 ) ; <END> } 
@Override public int METHOD_1 ( TYPE_1 o ) { if ( o == null ) { throw new TYPE_2 ( STRING_1 ) ; <START> } <END> TYPE_3 VAR_1 = ( TYPE_3 ) o ; int VAR_2 = ( VAR_3 < VAR_1 . VAR_3 ) ? - 1 : ( ( VAR_3 == VAR_1 . VAR_3 ) ? 0 : 1 ) ; if ( VAR_2 == 0 ) { VAR_2 = VAR_4 . METHOD_1 ( VAR_1 . VAR_4 ) ; } return VAR_2 ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = new TYPE_3 ( context . VAR_3 ( ) , context . VAR_4 ( ) , VAR_5 ) ; if ( VAR_6 . contains ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ) { <START> return new TYPE_4 ( VAR_7 , VAR_8 , context , VAR_5 , VAR_1 , VAR_2 , true ) ; <END> } else { return new TYPE_4 ( VAR_7 , VAR_8 , context , VAR_5 , VAR_1 , VAR_2 , false ) ; } } 
public static void METHOD_1 ( ) throws TYPE_1 , IOException { <START> VAR_1 = new TYPE_2 ( false ) ; <END> VAR_2 = METHOD_2 ( VAR_1 ) ; VAR_2 . start ( ) ; } 
public static TYPE_1 METHOD_1 ( int VAR_1 , String VAR_2 , int VAR_3 , TYPE_2 VAR_4 , TYPE_1 VAR_5 ) throws TYPE_3 { TYPE_1 VAR_6 = new TYPE_1 ( ) ; for ( int i = 0 ; i < VAR_1 ; ++ i ) { <START> VAR_6 . put ( METHOD_2 ( VAR_2 , VAR_3 + i , VAR_4 , VAR_5 ) ) ; <END> } return VAR_6 ; } 
public String toString ( ) { <START> return STRING_1 + ( VAR_1 != null ? VAR_1 . toString ( ) : STRING_2 ) + <END> STRING_3 + ( VAR_2 != null ? VAR_2 . toString ( ) : STRING_2 ) + STRING_4 + ( VAR_3 != null ? VAR_3 . toString ( ) : STRING_2 ) ; } 
public void METHOD_1 ( Exception e ) { logger . trace ( STRING_1 ) ; synchronized ( VAR_1 ) { exception = e ; <START> if ( VAR_2 . METHOD_2 ( false , true ) ) { <END> for ( TYPE_1 listener : VAR_1 ) { try { listener . VAR_3 ( this , e ) ; } catch ( Exception VAR_4 ) { logger . error ( STRING_2 , VAR_4 ) ; } } } else { logger . error ( STRING_3 ) ; } } } 
public TYPE_3 ( TYPE_1 VAR_2 ) { VAR_3 = <START> VAR_2 . METHOD_1 ( TYPE_1 . name ( TYPE_2 . class , STRING_1 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 ctx ) { try { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( request ) ; <END> } if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( request ) ; } } catch ( Exception e ) { logger . error ( STRING_1 , e ) ; VAR_3 . VAR_4 . METHOD_3 ( ) ; } } 
public void run ( ) { try { while ( VAR_1 ) { if ( ! METHOD_1 ( ) ) { try { <START> Thread . VAR_2 ( VAR_3 ) ; <END> } catch ( InterruptedException e ) { logger . info ( STRING_1 ) ; } } } } finally { VAR_4 . METHOD_2 ( ) ; } } 
public long METHOD_1 ( TYPE_1 channel , long size ) throws IOException { <START> int VAR_1 = index ; <END> index ++ ; int VAR_2 = 0 ; while ( VAR_2 < size ) { VAR_2 += channel . read ( VAR_3 . get ( VAR_1 ) ) ; VAR_1 = index ++ ; } if ( VAR_2 != size ) { throw new IOException ( STRING_1 + size + STRING_2 + VAR_2 ) ; } return VAR_2 ; } 
public void METHOD_1 ( ) { String VAR_1 ; try { <START> VAR_1 = METHOD_2 ( ) . toString ( ) ; <END> } catch ( TYPE_1 e ) { VAR_1 = null ; } logger . info ( STRING_1 + VAR_1 + STRING_2 ) ; if ( VAR_2 . METHOD_3 ( ) ) { logger . info ( STRING_1 + VAR_1 + STRING_3 ) ; } } 
private TYPE_1 METHOD_1 ( ) throws TYPE_2 { <START> List < ? extends TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> if ( VAR_1 . isEmpty ( ) ) { throw new TYPE_2 ( STRING_1 , TYPE_3 . TYPE_4 ) ; } return VAR_1 . get ( ( int ) METHOD_3 ( VAR_5 , VAR_1 . size ( ) ) ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 token , long VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_5 = token ; if ( VAR_6 == null ) { this . VAR_6 = token ; VAR_7 = TYPE_4 . getInstance ( ) . METHOD_1 ( ) ; } this . VAR_4 = VAR_4 ; <START> this . VAR_8 = new Long ( 0 ) ; <END> this . VAR_3 = VAR_3 ; } 
public TYPE_3 ( List < TYPE_1 > VAR_2 , List < ByteBuffer > VAR_3 ) { if ( VAR_2 . size ( ) != VAR_3 . size ( ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } VAR_4 = VAR_2 ; log = new TYPE_2 ( VAR_3 ) ; <START> VAR_5 = new Long ( 0 ) ; <END> } 
<START> public long METHOD_1 ( ) { <END> long VAR_1 = 0 ; for ( TYPE_1 VAR_2 : VAR_3 . values ( ) ) { VAR_1 += VAR_2 . METHOD_1 ( ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = METHOD_2 ( ) ; TYPE_4 VAR_3 = METHOD_3 ( VAR_1 ) ; TYPE_5 VAR_4 = new TYPE_5 ( VAR_5 , VAR_6 , VAR_7 , VAR_2 , VAR_3 , VAR_8 , VAR_9 ) ; <START> VAR_4 . execute ( ) ; <END> return VAR_4 . METHOD_1 ( ) ; } 
public long METHOD_1 ( ) { <START> return super . METHOD_1 ( ) + TYPE_1 + VAR_2 . METHOD_1 ( ) ; <END> } 
public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 ) { super ( VAR_3 ) ; VAR_4 = METHOD_1 ( VAR_2 + STRING_1 ) ; VAR_5 = METHOD_1 ( VAR_2 + STRING_2 ) ; VAR_6 = METHOD_1 ( VAR_2 + STRING_3 ) ; <START> VAR_7 = new TYPE_2 ( VAR_2 + STRING_4 ) ; <END> } 
private void METHOD_1 ( String name , String value ) { Class < ? extends TYPE_1 > VAR_1 [ ] = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_1 != null && VAR_1 . length > 0 ) { <END> for ( final Class < ? extends TYPE_1 > VAR_3 : VAR_1 ) { METHOD_1 ( this , VAR_3 , name , value ) ; } } } 
public static < T > T METHOD_1 ( TYPE_1 session , Class < T > VAR_1 , String id ) { LOG . trace ( STRING_1 ) ; T entity = null ; try { entity = session . get ( VAR_1 , id ) ; LOG . trace ( STRING_2 ) ; } catch ( TYPE_2 | TYPE_3 e ) { <START> LOG . error ( STRING_3 , e . getMessage ( ) , e ) ; <END> throw e ; } finally { METHOD_2 ( session ) ; } return entity ; } 
public int METHOD_1 ( ) { String VAR_1 = VAR_2 . getName ( ) ; <START> int VAR_3 = 0 ; <END> for ( TYPE_1 VAR_4 : VAR_5 ) { String VAR_6 = VAR_4 . getName ( ) ; if ( VAR_1 . equals ( VAR_6 ) ) { return VAR_7 . METHOD_2 ( VAR_4 ) ; } } return VAR_3 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 request ) { TYPE_3 record = new TYPE_3 ( request . VAR_1 ( ) , VAR_2 . METHOD_2 ( request . VAR_1 ( ) . METHOD_3 ( ) ) ) ; <START> if ( null == record ) { <END> return METHOD_4 ( Boolean . VAR_3 , VAR_4 ) ; } VAR_2 . METHOD_1 ( record ) ; return METHOD_4 ( Boolean . VAR_5 , VAR_6 ) ; } 
public boolean METHOD_1 ( String VAR_1 ) { TYPE_1 name = null ; try { name = new TYPE_2 ( VAR_1 ) ; } catch ( TYPE_3 ex ) { <START> LOG . error ( STRING_1 , VAR_1 ) ; <END> LOG . debug ( STRING_1 , VAR_1 , ex ) ; } return name != null ; } 
<START> public static String METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = null ; if ( StringUtils . VAR_3 ( VAR_1 ) ) { List < TYPE_1 > VAR_4 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) ; if ( TYPE_3 . METHOD_3 ( VAR_4 ) ) { for ( TYPE_1 ex : VAR_4 ) { if ( VAR_1 . equalsIgnoreCase ( ex . getName ( ) ) ) { VAR_2 = ex . VAR_5 ( ) ; break ; } } } } return VAR_2 ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { try { TYPE_2 . getInstance ( ) . METHOD_2 ( VAR_1 ) ; } catch ( final TYPE_3 ex ) { LOG . debug ( STRING_1 , ex ) ; <START> return ; <END> } LOG . debug ( STRING_2 ) ; } 
public void METHOD_1 ( ) { LOG . debug ( STRING_1 ) ; if ( null == VAR_1 ) { LOG . info ( STRING_2 ) ; <START> TYPE_1 . METHOD_2 ( null , STRING_3 ) ; <END> return ; } VAR_1 = VAR_2 . METHOD_3 ( VAR_1 . getId ( ) ) ; if ( StringUtils . VAR_3 ( VAR_1 . METHOD_4 ( ) ) ) { VAR_4 = new TYPE_2 ( VAR_1 . METHOD_4 ( ) ) ; } TYPE_1 . METHOD_5 ( STRING_4 ) ; } 
public TYPE_2 ( ) { <START> try { <END> VAR_2 = VAR_3 . METHOD_1 ( ) ; } catch ( Exception ex ) { LOG . error ( STRING_1 , ex . getMessage ( ) , ex ) ; TYPE_1 . METHOD_2 ( null , VAR_4 ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 request , TYPE_3 VAR_1 , TYPE_4 VAR_2 ) { TYPE_1 response = null ; if ( VAR_2 == null ) { VAR_2 = new TYPE_5 ( ) . METHOD_2 ( ) ; } if ( StringUtils . VAR_3 ( VAR_2 . METHOD_3 ( ) ) ) { VAR_2 . METHOD_4 ( STRING_1 ) ; } response = VAR_4 . METHOD_1 ( request , VAR_1 , VAR_2 ) ; <START> return response ; <END> } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; try { VAR_1 . METHOD_2 ( null , null ) ; Assert . VAR_2 ( ) ; } catch ( TYPE_2 e ) { TYPE_3 response = ( TYPE_3 ) e . VAR_3 ( ) ; assertNotNull ( response . VAR_4 ( ) ) ; assertEquals ( 0 , response . VAR_4 ( ) . METHOD_3 ( ) . size ( ) ) ; } } 
TYPE_1 METHOD_1 ( TYPE_2 request ) { TYPE_1 response = null ; try { METHOD_2 ( request . VAR_1 ( ) , VAR_2 ) ; response = VAR_3 . METHOD_3 ( request . VAR_4 ( ) , request . VAR_5 ( ) , request . VAR_1 ( ) , request . VAR_6 ( ) ) ; } catch ( Exception e ) { LOG . error ( STRING_1 , e ) ; <START> throw new TYPE_3 ( e , STRING_2 ) ; <END> } return response ; } 
public void METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> int VAR_1 = 100 ; int result = instance . VAR_2 ( ) ; assertEquals ( VAR_1 , result ) ; } 
public static TYPE_3 . TYPE_4 . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_6 METHOD_1 ( ) { TYPE_2 context = TYPE_7 . VAR_7 ; <START> LOG . debug ( STRING_1 , context . getId ( ) ) ; <END> if ( VAR_8 == null ) { VAR_8 = context . VAR_9 ( TYPE_5 . VAR_11 , TYPE_3 . TYPE_4 . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_6 . VAR_12 ) ; } return VAR_8 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 == null ) { LOG . warn ( STRING_1 ) ; } try { TYPE_3 . METHOD_2 ( VAR_1 ) ; <START> } catch ( final Exception ex ) { <END> LOG . error ( STRING_2 , ex . getMessage ( ) , ex ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 request ) { <START> context . toString ( ) ; <END> return TYPE_3 . METHOD_2 ( ) . METHOD_3 ( request ) ; } 
private static List < String > METHOD_1 ( TYPE_1 entity ) { List < String > VAR_1 = new ArrayList < > ( ) ; <START> if ( null != entity && TYPE_2 . METHOD_2 ( entity . VAR_2 ( ) ) ) { <END> for ( TYPE_3 obj : entity . VAR_2 ( ) ) { VAR_1 . add ( obj . getValue ( ) ) ; } } return VAR_1 ; } 
public static String METHOD_1 ( List < String > VAR_1 ) { for ( String name : VAR_1 ) { try { if ( StringUtils . VAR_2 ( TYPE_2 . TYPE_3 . METHOD_2 ( name ) . toString ( ) ) ) { return TYPE_2 . TYPE_3 . METHOD_2 ( name ) . METHOD_3 ( ) ; } <START> } catch ( IllegalArgumentException e ) { <END> } } return null ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { return null != VAR_1 . METHOD_2 ( ) && TYPE_2 . METHOD_3 ( VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ) <START> && StringUtils . VAR_2 ( VAR_1 . getType ( ) ) && StringUtils . equalsIgnoreCase ( <END> TYPE_4 . TYPE_5 . toString ( ) , VAR_1 . getType ( ) ) ; } 
public List < TYPE_1 > METHOD_1 ( String VAR_1 ) throws TYPE_2 { METHOD_2 ( ) ; <START> return null != VAR_1 ? new ArrayList < > ( METHOD_3 ( ) . get ( VAR_1 ) . values ( ) ) <END> : new ArrayList < > ( METHOD_3 ( ) . get ( this . METHOD_4 ( ) ) . values ( ) ) ; } 
protected TYPE_4 ( TYPE_1 < T > VAR_2 , String url , TYPE_2 VAR_3 , TYPE_3 < T > VAR_4 , String VAR_5 ) { VAR_6 = super . METHOD_1 ( VAR_4 . METHOD_2 ( ) , VAR_5 , VAR_3 != null ? VAR_3 . METHOD_3 ( ) : null ) ; <START> METHOD_4 ( ) ; <END> } 
public String METHOD_1 ( ) { <START> return VAR_1 . METHOD_1 ( ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> return VAR_1 ; <END> } 
private List < TYPE_1 > METHOD_1 ( String VAR_1 ) throws TYPE_2 { TYPE_3 message = new TYPE_3 ( ) ; <START> TYPE_4 VAR_2 = METHOD_2 ( METHOD_3 ( ) ) ; <END> message . VAR_3 ( VAR_2 ) ; TYPE_5 response ; try { response = ( TYPE_5 ) METHOD_4 ( ) . METHOD_5 ( TYPE_6 . class , VAR_1 , message ) ; } catch ( Exception e ) { throw new TYPE_2 ( STRING_1 , e ) ; } return METHOD_6 ( response . VAR_4 ( ) ) ; } 
private static boolean METHOD_1 ( ) { <START> return StringUtils . VAR_1 ( METHOD_2 ( ) ) ? true : false ; <END> } 
public static TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 , String VAR_2 ) { if ( TYPE_2 . isEmpty ( VAR_1 ) ) { return null ; } <START> if ( StringUtils . VAR_3 ( VAR_2 ) ) { <END> return VAR_1 . get ( 0 ) ; } for ( TYPE_1 VAR_4 : VAR_1 ) { if ( METHOD_2 ( VAR_2 , VAR_4 . METHOD_3 ( ) ) ) { return VAR_4 ; } } return null ; } 
public void METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) . METHOD_1 ( VAR_1 ) ; <START> METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> if ( StringUtils . VAR_2 ( VAR_1 ) ) { String [ ] VAR_3 = VAR_1 . split ( STRING_1 ) ; TYPE_1 . METHOD_4 ( VAR_4 , VAR_5 . METHOD_5 ( VAR_3 [ 0 ] . METHOD_6 ( STRING_2 , "" ) , VAR_3 [ 1 ] ) ) ; } else { TYPE_1 . METHOD_4 ( VAR_4 , new TYPE_2 ( ) ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { boolean VAR_2 ; if ( TYPE_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) { VAR_2 = VAR_3 . METHOD_4 ( VAR_1 ) ; <START> METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; <END> if ( ! VAR_2 ) { METHOD_7 ( STRING_1 ) ; } } else { LOG . info ( STRING_2 ) ; throw new TYPE_2 ( STRING_3 ) ; } return VAR_2 ; } 
public List < TYPE_1 > METHOD_1 ( ) { if ( null == VAR_1 ) { <START> METHOD_2 ( ) ; <END> } return VAR_1 ; } 
public List < TYPE_1 > METHOD_1 ( ) { if ( METHOD_2 ( ) ) { return VAR_1 . METHOD_3 ( METHOD_4 ( ) ) ; } else { return new ArrayList < > ( ) ; } <START> } <END> 
<START> private int METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 instanceof TYPE_3 ) { return ( ( TYPE_3 ) VAR_2 ) . METHOD_3 ( ) . METHOD_4 ( ) ; } return - 1 ; } 
public TYPE_1 read ( Long id ) { <START> LOG . debug ( STRING_1 ) ; <END> if ( id == null ) { LOG . info ( STRING_2 ) ; LOG . debug ( STRING_3 ) ; return null ; } TYPE_1 VAR_1 = super . read ( id , TYPE_1 . class ) ; LOG . debug ( STRING_3 ) ; return VAR_1 ; } 
protected boolean METHOD_1 ( ) { boolean VAR_1 = false ; try { VAR_1 = TYPE_1 . getInstance ( ) . METHOD_2 ( TYPE_3 . VAR_3 , TYPE_3 . VAR_4 ) ; <START> } catch ( TYPE_2 ex ) { <END> LOG . warn ( STRING_1 , ex . VAR_5 ( ) ) ; } return VAR_1 ; } 
public List < TYPE_1 > METHOD_1 ( final List VAR_1 , final List VAR_2 ) { List < TYPE_1 > VAR_3 ; <START> if ( TYPE_2 . isEmpty ( VAR_1 ) ) { <END> LOG . debug ( STRING_1 ) ; } if ( TYPE_2 . isEmpty ( VAR_2 ) ) { LOG . debug ( STRING_2 ) ; } VAR_3 = TYPE_3 . getInstance ( ) . METHOD_1 ( VAR_1 , VAR_2 , VAR_4 ) ; LOG . trace ( STRING_3 ) ; return VAR_3 ; } 
public List < TYPE_1 > METHOD_1 ( final TYPE_2 properties , final TYPE_3 VAR_1 ) { final List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; final Boolean VAR_3 = properties . VAR_4 ( ) ; if ( VAR_3 ) { final String resource = properties . VAR_5 ( ) ; <START> String VAR_6 = VAR_7 ; <END> final TYPE_4 VAR_8 = METHOD_2 ( properties , VAR_1 ) ; VAR_2 . add ( TYPE_5 . getInstance ( ) . METHOD_3 ( resource , VAR_6 , VAR_9 , VAR_8 ) ) ; } return VAR_2 ; } 
public static String METHOD_1 ( final String VAR_1 , final String VAR_2 ) { final String VAR_3 = VAR_1 . METHOD_2 ( ) ; final String VAR_4 = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_3 . METHOD_3 ( VAR_4 ) == - 1 ) { <END> return TYPE_1 . format ( STRING_1 , VAR_2 , VAR_1 ) ; } else { return VAR_1 ; } } 
protected TYPE_1 METHOD_1 ( final TYPE_2 properties ) { TYPE_3 VAR_1 = properties . VAR_2 ( ) ; TYPE_3 VAR_3 = properties . VAR_4 ( ) ; TYPE_3 VAR_5 = properties . VAR_6 ( ) ; if ( VAR_1 == null ) { VAR_1 = new TYPE_3 ( ) ; } <START> VAR_3 = METHOD_2 ( VAR_3 , VAR_1 ) ; <END> VAR_5 = METHOD_3 ( VAR_5 , VAR_1 ) ; return TYPE_4 . getInstance ( ) . METHOD_1 ( VAR_3 , VAR_5 ) ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> TYPE_1 VAR_1 = METHOD_2 ( ) ; <END> TYPE_2 VAR_2 = VAR_3 . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; } 
private static String METHOD_1 ( String msg , String key , String VAR_1 , String VAR_2 ) { StringBuilder buffer = new StringBuilder ( ) ; <START> buffer . append ( msg ) ; <END> buffer . append ( key ) ; buffer . append ( STRING_1 ) ; buffer . append ( VAR_1 ) ; buffer . append ( STRING_2 ) ; buffer . append ( VAR_2 ) ; buffer . append ( STRING_3 ) ; return buffer . toString ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_2 . getId ( ) . equalsIgnoreCase ( TYPE_3 ) ) { <END> VAR_3 = 0 ; } else if ( VAR_2 . getId ( ) . equalsIgnoreCase ( TYPE_4 ) ) { VAR_3 = 1 ; } else if ( VAR_2 . getId ( ) . equalsIgnoreCase ( TYPE_5 ) ) { VAR_3 = 2 ; } else { VAR_3 = 3 ; } } 
public TYPE_3 ( final TYPE_1 builder ) { this . builder = builder ; <START> VAR_2 = TYPE_2 . getInstance ( ) ; <END> } 
private static String METHOD_1 ( final String VAR_1 ) { StringBuilder VAR_2 = new StringBuilder ( ) ; VAR_2 . append ( TYPE_1 . VAR_4 ) ; VAR_2 . append ( STRING_1 ) ; VAR_2 . append ( TYPE_1 . VAR_5 ) ; VAR_2 . append ( STRING_2 ) ; VAR_2 . append ( VAR_1 ) ; VAR_2 . append ( STRING_1 ) ; VAR_2 . append ( VAR_6 ) ; <START> return VAR_2 . toString ( ) ; <END> } 
private boolean METHOD_1 ( ) { String VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( TYPE_1 . METHOD_3 ( VAR_1 ) ) { VAR_1 = METHOD_4 ( ) ; } return TYPE_1 . METHOD_5 ( VAR_1 ) <START> && ( VAR_1 . equalsIgnoreCase ( STRING_1 ) || VAR_1 . equalsIgnoreCase ( STRING_2 ) ) ; <END> } 
<START> private String METHOD_1 ( String VAR_1 ) { <END> if ( ( VAR_1 . length ( ) ) > ( TYPE_2 . TYPE_3 . length ( ) + 1 ) ) { return VAR_1 . substring ( TYPE_2 . TYPE_3 . length ( ) + 1 ) . trim ( ) ; } else { return null ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 context ) { try { if ( METHOD_2 ( ) . METHOD_3 ( TYPE_6 . VAR_3 , TYPE_6 . VAR_4 ) ) { TYPE_3 VAR_5 = METHOD_4 ( context ) ; <START> if ( VAR_5 != null && ( VAR_5 instanceof TYPE_4 ) ) { <END> METHOD_5 ( VAR_5 , VAR_1 ) ; } } } catch ( TYPE_5 ex ) { LOG . warn ( STRING_1 , ex ) ; } } 
protected long METHOD_1 ( ) { try { return TYPE_1 . getInstance ( ) . METHOD_2 ( TYPE_3 . VAR_2 , TYPE_3 . VAR_3 ) ; } catch ( TYPE_2 VAR_4 ) { <START> LOG . warn ( STRING_1 , <END> VAR_4 . METHOD_3 ( ) ) ; LOG . trace ( STRING_2 , VAR_4 . METHOD_3 ( ) , VAR_4 ) ; } return VAR_5 ; } 
<START> private static boolean METHOD_1 ( final String VAR_1 ) { <END> TYPE_1 name = null ; try { name = new TYPE_2 ( VAR_1 ) ; } catch ( final Exception e ) { LOG . warn ( STRING_1 , e . VAR_2 ( ) ) ; LOG . trace ( STRING_2 , e . VAR_2 ( ) , e ) ; } return name == null ? false : true ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) throws TYPE_3 { final TYPE_4 VAR_2 = new TYPE_4 ( ) ; TYPE_1 VAR_3 = null ; VAR_2 . METHOD_2 ( VAR_1 ) ; try { VAR_3 = TYPE_5 . METHOD_3 ( VAR_2 ) ; <START> } catch ( org . VAR_4 . VAR_5 . TYPE_6 | org . VAR_7 . VAR_8 . VAR_9 . VAR_10 . TYPE_7 e ) { <END> LOG . error ( e . VAR_12 ( ) , e ) ; throw new TYPE_3 ( e . VAR_12 ( ) , e ) ; } return VAR_3 ; } 
private static boolean METHOD_1 ( final String VAR_1 ) { TYPE_1 name = null ; try { name = new TYPE_2 ( VAR_1 ) ; } catch ( final Exception e ) { LOG . trace ( STRING_1 , e . VAR_2 ( ) , e ) ; } <START> return name == null ? false : true ; <END> } 
<START> public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <END> TYPE_1 VAR_3 = VAR_1 ; final TYPE_1 VAR_4 = new TYPE_1 ( ) ; if ( VAR_3 == null || VAR_3 . METHOD_2 ( VAR_4 . METHOD_3 ( 5 ) ) ) { VAR_3 = VAR_4 . METHOD_3 ( 5 ) ; } if ( VAR_3 . METHOD_2 ( VAR_2 ) ) { VAR_3 = VAR_2 . METHOD_3 ( 5 ) ; } return VAR_3 ; } 
private void METHOD_1 ( final String value ) throws TYPE_1 { try { TYPE_2 result = VAR_1 . METHOD_2 ( value ) ; List < String > VAR_2 = result . VAR_3 ( ) ; <START> if ( TYPE_3 . METHOD_3 ( VAR_2 ) ) { <END> throw new TYPE_1 ( STRING_1 ) ; } } catch ( TYPE_4 | TYPE_5 | TYPE_1 ex ) { throw new TYPE_1 ( ex ) ; } } 
public static void METHOD_1 ( TYPE_1 session ) { if ( session != null ) { try { session . close ( ) ; } catch ( Exception e ) { LOG . error ( STRING_1 , e ) ; } } else { <START> LOG . warn ( STRING_2 ) ; <END> } } 
public List < TYPE_1 > METHOD_1 ( TYPE_1 VAR_1 , List < String > VAR_2 ) { TYPE_2 VAR_3 = new TYPE_2 ( ) ; <START> return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) ; <START> return VAR_1 . METHOD_3 ( ) ; <END> } 
public String METHOD_1 ( ) { this . VAR_1 = null ; this . VAR_2 = null ; <START> if ( this . VAR_3 != null && ! VAR_3 . isEmpty ( ) ) { <END> this . VAR_3 . clear ( ) ; } this . VAR_4 = "" ; this . VAR_5 = false ; return TYPE_1 . VAR_7 ; } 
public void METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> TYPE_1 instance = new TYPE_1 ( ) ; TYPE_2 message = new TYPE_2 ( ) ; TYPE_3 VAR_1 = new TYPE_3 ( ) ; VAR_1 . METHOD_2 ( STRING_2 ) ; message . VAR_2 ( VAR_1 ) ; TYPE_4 result = instance . VAR_3 ( message , TYPE_5 . VAR_5 , TYPE_5 . VAR_6 ) ; assertNotNull ( result ) ; assertEquals ( TYPE_5 . VAR_5 , result . VAR_7 ( ) ) ; assertNotNull ( result . VAR_8 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 config ) throws TYPE_2 { super . METHOD_1 ( config ) ; LOG . debug ( STRING_1 ) ; VAR_1 = TYPE_3 . METHOD_2 ( TYPE_4 . getInstance ( ) . METHOD_3 ( ) ) ; VAR_2 = TYPE_3 . METHOD_2 ( TYPE_4 . getInstance ( ) . METHOD_4 ( ) ) ; <START> TYPE_5 session = TYPE_6 . METHOD_5 ( ) ; <END> TYPE_7 . getInstance ( ) . METHOD_6 ( ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 request , TYPE_3 VAR_1 , TYPE_1 VAR_2 ) { VAR_2 = METHOD_2 ( request , VAR_2 ) ; VAR_2 = METHOD_3 ( request , VAR_2 ) ; <START> return VAR_2 ; <END> } 
public void execute ( TYPE_1 message ) { <START> LOG . debug ( STRING_1 ) ; <END> TYPE_2 VAR_1 = METHOD_1 ( ) ; TYPE_3 response = VAR_1 . METHOD_2 ( message . VAR_2 ( ) , message . VAR_3 ( ) , message . VAR_4 ( ) ) ; message . VAR_5 ( response ) ; LOG . debug ( STRING_2 ) ; } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = null ; try { if ( TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ) { VAR_2 = VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ; } <START> } catch ( TYPE_3 ex ) { <END> LOG . warn ( STRING_1 , ex ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 request ) { TYPE_3 VAR_1 = METHOD_2 ( context , null ) ; return VAR_2 . METHOD_1 ( request . VAR_3 ( ) , VAR_1 , request . VAR_4 ( ) , METHOD_3 ( context ) ) ; <START> } <END> 
public static boolean METHOD_1 ( String value ) { <START> return ( value != null && ! value . trim ( ) . isEmpty ( ) ) ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_2 id ) { TYPE_1 VAR_1 = null ; <START> if ( id != null && id . getValue ( ) != null ) { <END> VAR_1 = id . getValue ( ) . get ( 0 ) ; } return VAR_1 ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_1 id = new TYPE_1 ( ) ; <END> if ( VAR_1 != null ) { id . getValue ( ) . add ( VAR_1 ) ; } return id ; } 
private String METHOD_1 ( TYPE_1 context ) { TYPE_2 VAR_1 = context . VAR_2 ( ) ; if ( VAR_1 == null || ! ( VAR_1 instanceof TYPE_3 ) ) { return null ; } TYPE_4 message = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; TYPE_5 VAR_3 = ( TYPE_5 ) message . get ( TYPE_6 . VAR_5 ) ; <START> return ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) . getValue ( ) ) ; <END> } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; try { TYPE_2 VAR_2 = new TYPE_2 ( ) ; TYPE_3 VAR_3 = VAR_2 . METHOD_2 ( TYPE_5 . VAR_5 ) ; VAR_1 = VAR_3 . METHOD_3 ( ) ; <START> return VAR_1 ; <END> } catch ( TYPE_4 ex ) { LOG . error ( STRING_1 + ex . getMessage ( ) , ex ) ; } return VAR_1 ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_1 VAR_3 = null ; <START> VAR_3 = new TYPE_1 ( VAR_1 , VAR_2 ) ; <END> return VAR_3 ; } 
private TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_1 < TYPE_2 > i = new TYPE_1 < > ( new TYPE_3 ( <END> STRING_1 , STRING_2 ) , TYPE_2 . class , VAR_1 ) ; return i ; } 
public void METHOD_1 ( T request , TYPE_1 VAR_1 , TYPE_2 target , String VAR_2 , String VAR_3 , Boolean VAR_4 , TYPE_3 VAR_5 , String VAR_6 ) { LOG . trace ( STRING_1 ) ; if ( METHOD_2 ( ) != null ) { METHOD_2 ( ) . METHOD_1 ( request , VAR_1 , target , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , METHOD_3 ( ) ) ; <START> } else { <END> LOG . error ( STRING_2 ) ; } LOG . trace ( STRING_3 ) ; } 
protected String METHOD_1 ( ) { <START> return ( TYPE_1 . METHOD_2 ( ) . toString ( ) ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 request , TYPE_3 VAR_1 ) throws TYPE_4 { TYPE_5 VAR_2 = VAR_3 . create ( ) ; <START> return VAR_2 . METHOD_2 ( request , VAR_1 ) ; <END> } 
protected TYPE_4 . TYPE_5 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_4 . TYPE_5 VAR_2 = METHOD_2 ( <START> VAR_1 , Boolean . VAR_3 ) ; <END> if ( VAR_1 . METHOD_3 ( ) != null ) { VAR_2 . METHOD_4 ( ) . add ( TYPE_3 . METHOD_5 ( VAR_1 . METHOD_3 ( ) . METHOD_6 ( ) , "" , VAR_1 . METHOD_3 ( ) . METHOD_7 ( ) , VAR_1 . METHOD_3 ( ) . METHOD_8 ( ) ) ) ; } return VAR_2 ; } 
<START> public String METHOD_1 ( ) throws TYPE_1 { <END> METHOD_2 ( ) ; return token ; } 
public String METHOD_1 ( ) { METHOD_2 ( ) ; <START> if ( token != null ) { <END> return token ; } return null ; } 
private String METHOD_1 ( TYPE_1 message ) throws TYPE_2 { TYPE_3 VAR_1 = ( TYPE_3 ) message . VAR_2 ( ) ; if ( VAR_1 == null ) { TYPE_3 [ ] VAR_3 = ( TYPE_3 [ ] ) message . VAR_4 ( ) ; <START> VAR_1 = VAR_3 [ 0 ] ; <END> } return ( VAR_1 . METHOD_2 ( ) ) ; } 
private boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { boolean VAR_3 = false ; String VAR_4 = METHOD_2 ( VAR_1 , VAR_2 ) ; <START> if ( VAR_4 . equals ( STRING_1 ) ) { <END> VAR_3 = true ; } return VAR_3 ; } 
public String METHOD_1 ( ) { <START> return ( VAR_1 == null ) ? VAR_2 : VAR_1 ; <END> } 
public void METHOD_1 ( TYPE_1 message , TYPE_2 VAR_1 , TYPE_3 target , String VAR_2 ) { <START> LOG . debug ( STRING_1 ) ; <END> TYPE_4 VAR_3 = new TYPE_4 ( ) ; TYPE_5 VAR_4 = VAR_3 . METHOD_2 ( message , VAR_1 , target , VAR_2 ) ; if ( VAR_4 != null && VAR_4 . METHOD_3 ( ) != null ) { METHOD_4 ( VAR_4 , VAR_1 ) ; } else { LOG . error ( STRING_2 ) ; } LOG . debug ( STRING_3 ) ; } 
protected List < TYPE_1 > METHOD_1 ( TYPE_2 response ) { <START> List < TYPE_1 > VAR_1 = null ; <END> if ( response != null && response . VAR_2 ( ) != null ) { VAR_1 = response . VAR_2 ( ) . METHOD_2 ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 session = VAR_1 . VAR_2 . VAR_3 . VAR_4 . event . VAR_5 . TYPE_3 . METHOD_2 ( ) ; session = VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_7 . VAR_8 . VAR_5 . TYPE_3 . METHOD_2 ( ) ; LOG . debug ( STRING_1 ) ; TYPE_2 . getInstance ( ) . METHOD_3 ( ) ; <START> LOG . debug ( STRING_2 ) ; <END> METHOD_4 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_1 VAR_3 = null ; if ( VAR_1 != null ) { LOG . trace ( STRING_1 ) ; VAR_3 = METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; LOG . trace ( STRING_2 ) ; } else { VAR_3 = new TYPE_1 ( ) ; <START> return VAR_3 ; <END> } return VAR_3 ; } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { if ( VAR_1 . get ( i ) . METHOD_3 ( ) . equals ( METHOD_3 ( ) ) ) { <START> VAR_1 . remove ( i ) ; <END> } } TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_4 ( VAR_2 ) ; VAR_4 . METHOD_5 ( VAR_3 ) ; } 
public TYPE_4 ( final String VAR_2 , final TYPE_1 VAR_3 ) { super ( VAR_2 , VAR_3 ) ; VAR_4 = new TYPE_2 < TYPE_3 > ( ) { <START> protected TYPE_3 METHOD_1 ( ) { <END> return new TYPE_3 ( VAR_2 , VAR_3 ) ; } } ; } 
private void METHOD_1 ( String message , int VAR_1 ) { if ( METHOD_2 ( ) ) { TYPE_1 VAR_2 = TYPE_1 . METHOD_3 ( context , message , VAR_1 ) ; VAR_2 . METHOD_4 ( ) ; <START> VAR_3 . add ( VAR_2 ) ; <END> } else { Log . e ( STRING_1 + message ) ; } } 
public Object METHOD_1 ( TYPE_1 VAR_1 , String [ ] VAR_2 , TYPE_2 session , Object VAR_3 ) throws TYPE_3 , TYPE_4 { String name = VAR_1 . getString ( VAR_2 [ 0 ] ) ; <START> return VAR_1 . METHOD_2 ( ) ? null : new TYPE_5 ( name ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 b = TYPE_1 . METHOD_2 ( ) ; <START> b . VAR_1 ( "" ) ; <END> } 
public void METHOD_1 ( ) { Iterator < TYPE_1 > VAR_1 = TYPE_2 . METHOD_1 ( ) . iterator ( ) ; <START> assertEquals ( VAR_2 , VAR_1 . next ( ) ) ; <END> assertEquals ( VAR_3 , VAR_1 . next ( ) ) ; assertEquals ( VAR_4 , VAR_1 . next ( ) ) ; assertEquals ( VAR_5 , VAR_1 . next ( ) ) ; METHOD_2 ( VAR_1 . hasNext ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 < Integer > VAR_1 = TYPE_2 . METHOD_2 ( new Throwable ( ) ) ; TYPE_1 < Integer > VAR_2 = TYPE_2 . map ( VAR_1 , new TYPE_3 < Integer , Integer > ( ) { @Override public Integer apply ( Integer input ) { return input + 1 ; } } , new TYPE_4 < Integer > ( ) ) ; <START> assertThat ( VAR_2 , TYPE_5 < Integer > METHOD_3 ( ) ) ; <END> } 
List < TYPE_1 > METHOD_1 ( TYPE_1 from , TYPE_1 to ) { List < TYPE_1 > res = new ArrayList < > ( ) ; <START> res . add ( from ) ; <END> if ( to != from ) { METHOD_2 ( from , to , res ) ; } return res ; } 
boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 to , List < TYPE_1 > res ) { for ( TYPE_1 next = VAR_1 . METHOD_2 ( ) ; next != null ; next = next . VAR_2 ( ) ) { if ( METHOD_3 ( next , to , res ) ) { return true ; } } <START> if ( VAR_1 . METHOD_4 ( ) == null ) { <END> throw new IllegalArgumentException ( STRING_1 + to ) ; } return METHOD_1 ( VAR_1 . METHOD_4 ( ) , to , res ) ; } 
public String METHOD_1 ( String VAR_1 ) { if ( ( VAR_1 == null ) || ( VAR_1 . length ( ) < 1 ) ) { return VAR_1 ; } char VAR_2 = VAR_1 . METHOD_2 ( 0 ) ; if ( TYPE_1 . METHOD_3 ( VAR_2 ) ) { return VAR_1 ; } <START> return String . valueOf ( TYPE_1 . METHOD_4 ( VAR_2 ) ) + VAR_1 . substring ( 1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> String VAR_2 = "" ; <END> } 
public static void METHOD_1 ( ) { VAR_1 = VAR_1 . stream ( ) . filter ( v - > v . VAR_2 ( TYPE_1 . class ) && v . VAR_2 ( TYPE_2 . class ) <START> && v . VAR_3 ( TYPE_2 . class ) . value ( ) . equals ( STRING_1 ) ) <END> . collect ( Collectors . VAR_4 ( ) ) ; } 
private void METHOD_1 ( String VAR_1 , TYPE_2 . TYPE_3 VAR_2 ) { if ( VAR_2 != null ) { TYPE_2 VAR_3 = this . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_1 , VAR_2 ) ; this . METHOD_5 ( VAR_3 ) ; } else if ( ! VAR_1 . isEmpty ( ) ) { <START> this . METHOD_6 ( VAR_1 . trim ( ) ) ; <END> } } 
private static TYPE_1 METHOD_1 ( Class < ? > VAR_1 ) { if ( List . VAR_2 . METHOD_2 ( VAR_1 ) ) { return TYPE_1 . VAR_3 ; } if ( Map . VAR_2 . METHOD_2 ( VAR_1 ) ) { return TYPE_1 . VAR_4 ; } <START> if ( Set . VAR_2 . METHOD_2 ( VAR_1 ) || Collection . VAR_2 . METHOD_2 ( VAR_1 ) ) { <END> return TYPE_1 . VAR_5 ; } return TYPE_1 . VAR_6 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 element ) { if ( VAR_1 != null && element != null ) { <START> if ( element . VAR_2 ( VAR_1 ) ) { <END> return TYPE_1 . VAR_3 ; } } if ( element instanceof TYPE_3 ) { VAR_4 ++ ; } return TYPE_1 . VAR_5 ; } 
public < TYPE_1 extends TYPE_2 > TYPE_1 METHOD_1 ( Map < String , Object > metadata ) { <START> if ( metadata != null ) { <END> if ( this . metadata == null ) { this . metadata = new HashMap < > ( ) ; } else { this . metadata . clear ( ) ; } this . metadata . VAR_1 ( metadata ) ; } else { this . metadata = null ; } return ( TYPE_1 ) this ; } 
private String METHOD_1 ( int start , int VAR_1 ) { try { <START> return TYPE_1 . toString ( new TYPE_2 ( VAR_2 , start , VAR_1 - start ) ) ; <END> } catch ( IOException e ) { throw new TYPE_3 ( e ) ; } } 
public boolean METHOD_1 ( ) { if ( this . VAR_1 == null ) { <START> logger . warn ( STRING_1 ) ; <END> return true ; } return VAR_1 ; } 
public < T extends TYPE_1 > T METHOD_1 ( List < TYPE_2 > VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { <START> this . VAR_1 . clear ( ) ; <END> return ( T ) this ; } this . VAR_1 . clear ( ) ; this . VAR_1 . addAll ( VAR_1 ) ; return ( T ) this ; } 
static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 element ) { if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) == false && element . VAR_2 ( ) && element . VAR_3 ( ) != VAR_1 ) { <START> if ( element . VAR_4 ( ) != null ) { <END> throw new TYPE_2 ( STRING_1 + element + STRING_2 ) ; } } element . VAR_5 ( VAR_1 ) ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , Collection < ? extends TYPE_2 > VAR_2 , Collection < ? extends TYPE_2 > VAR_3 ) { <START> for ( Iterator < ? extends TYPE_2 > VAR_4 = VAR_2 . iterator ( ) , VAR_5 = VAR_3 . iterator ( ) ; ( VAR_4 . hasNext ( ) ) && ( VAR_5 . hasNext ( ) ) ; ) { <END> METHOD_1 ( VAR_1 , VAR_4 . next ( ) , VAR_5 . next ( ) ) ; } return true ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 . containsKey ( VAR_1 . METHOD_2 ( ) ) ) { return false ; } <START> VAR_2 . put ( VAR_1 . METHOD_2 ( ) , VAR_1 ) ; <END> return true ; } 
public < T extends TYPE_1 > T METHOD_1 ( T parent ) { if ( ! this . METHOD_2 ( ) . equals ( TYPE_3 . VAR_2 ) && parent != METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ) { throw new TYPE_2 ( STRING_1 ) ; } <START> return ( T ) super . METHOD_1 ( parent ) ; <END> } 
public boolean METHOD_1 ( TYPE_1 < ? > VAR_1 , TYPE_1 < ? > VAR_2 ) { if ( VAR_1 == VAR_2 ) { return true ; } TYPE_2 < ? > VAR_3 = VAR_2 . METHOD_2 ( ) ; TYPE_2 < ? > VAR_4 = METHOD_3 ( ) ; if ( VAR_3 != VAR_4 ) { if ( METHOD_4 ( VAR_3 . METHOD_5 ( ) ) == false ) { return false ; } } <START> return METHOD_6 ( VAR_1 , VAR_2 ) || METHOD_6 ( VAR_2 , VAR_1 ) ; <END> } 
public TYPE_1 apply ( TYPE_2 < ? > VAR_1 ) { TYPE_3 < ? > c = TYPE_4 . METHOD_1 ( VAR_1 , this ) ; TYPE_1 result = c . VAR_2 ( STRING_1 ) . METHOD_2 ( ) . METHOD_3 ( ) . get ( 0 ) . METHOD_4 ( ) ; <START> return ( TYPE_1 ) new TYPE_5 ( c . VAR_3 ( ) , VAR_1 , this ) . METHOD_5 ( result ) ; <END> } 
public < TYPE_1 extends TYPE_2 > TYPE_1 METHOD_1 ( TYPE_3 < T > type ) { if ( METHOD_2 ( ) != null && type != null ) { METHOD_2 ( ) . METHOD_1 ( type ) ; <START> type . VAR_1 ( this ) ; <END> } return ( TYPE_1 ) this ; } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > result = new ArrayList < > ( ) ; Set < TYPE_1 > VAR_1 = new HashSet < > ( ) ; for ( TYPE_1 f : METHOD_2 ( ) ) { <START> if ( VAR_1 . add ( f ) ) { <END> result . add ( f ) ; } } return result ; } 
public void METHOD_1 ( File VAR_1 ) { VAR_2 . METHOD_1 ( VAR_1 ) ; <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( VAR_1 . METHOD_4 ( ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> assertEquals ( 3 , METHOD_2 ( TYPE_1 . class ) . METHOD_3 ( new TYPE_2 < TYPE_3 > ( TYPE_3 . class ) { <END> @Override public boolean METHOD_4 ( TYPE_3 element ) { return element . VAR_1 ( TYPE_4 . class ) != null ; } } ) . size ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 s = new TYPE_2 ( ) . get ( String . VAR_1 ) ; assertEquals ( STRING_1 , s . VAR_2 ( ) ) ; assertEquals ( STRING_2 , s . VAR_3 ( ) ) ; <START> assertEquals ( 3 , s . VAR_4 ( ) . size ( ) ) ; <END> assertEquals ( 2 , s . VAR_5 ( STRING_3 ) . size ( ) ) ; System . out . println ( s ) ; } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 , TYPE_3 { <START> final TYPE_6 . TYPE_5 options = new TYPE_6 . TYPE_5 ( ) . METHOD_2 ( VAR_1 ) ; <END> Assert . assertEquals ( STRING_1 + VAR_2 , String . VAR_3 ( STRING_2 , options . build ( ) ) ) ; } 
public void METHOD_1 ( Collection < ? > set ) { if ( set != null ) { this . set = set ; VAR_1 = set . VAR_2 ( ) ; this . VAR_3 = true ; VAR_4 = set . isEmpty ( ) ? 1 : FLOAT_1 / set . size ( ) ; VAR_5 = set . isEmpty ( ) ? 0 : ( - Math . log ( set . size ( ) ) ) ; <START> VAR_6 = VAR_1 . METHOD_2 ( ) ; <END> } } 
public Object [ ] METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> return null ; } 
public String toString ( ) { <START> TYPE_1 buffer = new TYPE_1 ( ) ; <END> buffer . append ( STRING_1 ) ; for ( Object item : s ) { buffer . append ( item . toString ( ) + STRING_2 ) ; } buffer . VAR_1 ( buffer . length ( ) - 2 , buffer . length ( ) , "" ) ; buffer . append ( STRING_3 ) ; return buffer . toString ( ) ; } 
public static double METHOD_1 ( double a , double b ) { <START> return ( ( TYPE_1 . METHOD_2 ( a ) * TYPE_1 . METHOD_2 ( b ) ) / TYPE_1 . METHOD_2 ( a + b ) ) ; <END> } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; TYPE_1 VAR_1 = ( TYPE_1 ) obj ; <START> return Arrays . equals ( VAR_2 , VAR_1 . VAR_2 ) && name . equals ( VAR_1 . name ) ; <END> } 
<START> public void METHOD_1 ( List < String > VAR_1 ) { <END> for ( String VAR_2 : VAR_1 ) { VAR_3 . add ( VAR_2 ) ; } } 
public static int parseInt ( String s , TYPE_1 VAR_1 ) throws TYPE_2 { switch ( VAR_1 ) { case VAR_2 : case VAR_3 : return parseInt ( s ) ; case VAR_4 : try { long VAR_5 = TYPE_3 . METHOD_1 ( s ) ; if ( ( int ) VAR_5 == VAR_5 ) { return ( int ) VAR_5 ; } throw new TYPE_4 ( STRING_1 ) ; } catch ( TYPE_2 e ) { <START> return parseInt ( s ) ; <END> } } throw new TYPE_5 ( STRING_2 + VAR_1 ) ; } 
private int METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 input , int VAR_3 , TYPE_2 < Integer > VAR_4 ) throws IOException { int value = input . VAR_5 ( VAR_3 ) ; <START> if ( VAR_4 . METHOD_2 ( value ) ) { <END> throw new TYPE_3 ( VAR_1 + STRING_1 + VAR_2 + STRING_2 + value ) ; } return value ; } 
public synchronized int METHOD_1 ( ) { <START> if ( data . isEmpty ( ) ) { <END> return - 1 ; } return data . get ( 0 ) ; } 
public synchronized int METHOD_1 ( ) { <START> if ( data . isEmpty ( ) ) { <END> return - 1 ; } return data . get ( data . size ( ) - 1 ) ; } 
private void METHOD_1 ( int [ ] input ) { <START> if ( input . length < 2 ) { <END> return ; } for ( int i = 1 ; i < input . length ; i ++ ) { if ( input [ i - 1 ] > input [ i ] ) { throw new IllegalStateException ( STRING_1 ) ; } } } 
public void METHOD_1 ( TYPE_1 input , TYPE_2 output , String VAR_1 , HashMap < String , String > VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 , IOException { output . write ( input . read ( ) ) ; <START> return ; <END> } 
<START> public int METHOD_1 ( ) { <END> synchronized ( VAR_1 ) { return VAR_1 . size ( ) ; } } 
public boolean METHOD_1 ( ) { <START> if ( node . VAR_1 != null && <END> node . VAR_1 . METHOD_2 ( STRING_1 ) ) { return true ; } else { return false ; } } 
public boolean METHOD_1 ( ) { if ( VAR_1 != null ) { return true ; } <START> return false ; <END> } 
private TYPE_2 ( int VAR_2 , TYPE_1 VAR_3 , int VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_5 = - 1 ; <END> this . VAR_3 = VAR_3 ; this . VAR_6 = VAR_3 . VAR_7 ; this . VAR_4 = VAR_4 ; VAR_8 = name ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 type , byte [ ] VAR_1 ) throws TYPE_3 { if ( type . equals ( TYPE_2 . VAR_2 ) ) { throw new TYPE_3 ( type ) ; } try { TYPE_4 VAR_3 = TYPE_4 . getInstance ( type . VAR_4 ) ; TYPE_5 VAR_5 = new TYPE_5 ( VAR_1 ) ; <START> return VAR_3 . METHOD_2 ( VAR_5 ) ; <END> } catch ( TYPE_6 e ) { Logger . error ( TYPE_7 . class , STRING_1 , e ) ; } return null ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 type ) throws TYPE_3 { if ( type . equals ( TYPE_2 . VAR_1 ) ) { <START> throw new TYPE_3 ( type ) ; <END> } try { TYPE_4 VAR_2 = TYPE_4 . getInstance ( type . VAR_3 ) ; VAR_2 . METHOD_2 ( type . VAR_4 ) ; return VAR_2 . METHOD_3 ( ) ; } catch ( TYPE_5 e ) { Logger . error ( TYPE_6 . class , STRING_1 , e ) ; } return null ; } 
public final static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> if ( VAR_1 . METHOD_2 ( VAR_2 ) == 0 ) { <END> return true ; } return false ; } 
public int METHOD_1 ( ) { int VAR_1 = 1 ; VAR_1 = VAR_1 * INT_1 + type . VAR_2 ( ) ; <START> VAR_1 = VAR_1 * INT_1 + result . VAR_2 ( ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( ) { for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 [ i ] ) ; <START> boolean VAR_3 = VAR_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_4 [ i ] ) , VAR_5 ) ; <END> assertTrue ( STRING_1 + VAR_1 [ i ] . name ( ) , VAR_3 ) ; } } 
private void METHOD_1 ( ) { <START> if ( ! ( VAR_1 || VAR_2 == 0 ) ) throw new IllegalStateException ( ) ; <END> if ( VAR_3 == null ) return ; try { VAR_3 . close ( ) ; } catch ( IOException e ) { Logger . error ( this , STRING_1 + this + STRING_2 + e , e ) ; } VAR_3 = null ; VAR_4 -- ; } 
public boolean METHOD_1 ( ) { if ( this . equals ( VAR_1 . VAR_2 ) ) return true ; else return false ; <START> } <END> 
public int METHOD_1 ( ) { <START> return element . VAR_1 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { for ( TYPE_1 t : TYPE_1 . VAR_1 ) { <START> if ( t . VAR_2 ( true ) . equals ( VAR_3 ) ) { <END> return t ; } } return TYPE_1 . VAR_4 ; } 
protected int METHOD_1 ( TYPE_1 VAR_1 , int offset ) throws TYPE_2 { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( offset ) ; if ( ! VAR_2 . METHOD_3 ( ) ) { TYPE_3 VAR_3 = VAR_1 . METHOD_2 ( 0 ) ; <START> if ( ! VAR_3 . METHOD_3 ( ) <END> || ( VAR_3 . METHOD_4 ( ) != null && VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . equals ( TYPE_4 ) ) ) { return METHOD_6 ( VAR_2 ) ; } } return TYPE_5 . VAR_5 ; } 
public Long METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
<START> public final void METHOD_1 ( ) throws TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 { <END> final String VAR_1 = STRING_1 ; final String VAR_2 = STRING_2 ; METHOD_2 ( new TYPE_3 ( "" ) ) . when ( VAR_3 ) . METHOD_3 ( VAR_1 , VAR_2 ) ; VAR_4 . METHOD_4 ( VAR_1 , VAR_2 ) ; } 
public TYPE_2 ( ) { VAR_2 = new HashSet < String > ( ) ; VAR_3 = new HashSet < String > ( ) ; VAR_4 = new HashSet < String > ( ) ; <START> VAR_5 = new HashSet < TYPE_1 < String , String > > ( ) ; <END> } 
public TYPE_1 METHOD_1 ( final String VAR_1 , final String VAR_2 ) throws TYPE_2 { try { return METHOD_2 ( VAR_1 , VAR_2 , null ) ; <START> } catch ( final TYPE_3 e ) { <END> throw e ; } catch ( final TYPE_2 e ) { throw e ; } catch ( final Exception e ) { throw new TYPE_2 ( e ) ; } } 
long METHOD_1 ( final long VAR_1 ) { try { final TYPE_1 VAR_2 = this . VAR_3 . METHOD_1 ( ) ; <START> return VAR_2 . METHOD_2 ( ) ; <END> } catch ( Exception e ) { if ( this . logger . VAR_4 ( getClass ( ) , TYPE_2 . VAR_6 ) ) { this . logger . log ( getClass ( ) , TYPE_2 . VAR_6 , STRING_1 + e . getMessage ( ) , e ) ; } } return VAR_1 ; } 
<START> public TYPE_1 METHOD_1 ( long VAR_1 ) throws TYPE_2 { <END> try { return VAR_2 . METHOD_2 ( METHOD_3 ( VAR_1 ) . METHOD_4 ( ) . METHOD_5 ( ) ) ; } catch ( TYPE_3 | IOException | TYPE_4 e ) { throw new TYPE_2 ( e , VAR_1 ) ; } } 
protected TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 , long VAR_2 ) { for ( TYPE_2 VAR_3 : VAR_1 ) { final TYPE_1 VAR_4 = METHOD_2 ( VAR_3 , VAR_2 ) ; <START> if ( VAR_4 == null ) { <END> return VAR_4 ; } } return null ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 container , long VAR_1 ) { if ( container != null ) { final TYPE_1 VAR_2 = container . VAR_3 ( this , VAR_1 ) ; if ( VAR_2 != null ) { return VAR_2 ; } } return null ; <START> } <END> 
void METHOD_1 ( String VAR_1 ) { synchronized ( this . VAR_2 ) { synchronized ( this . VAR_3 ) { if ( ! METHOD_2 ( TYPE_1 . METHOD_3 ( this . VAR_4 ) , VAR_1 ) ) { TYPE_2 x = this . VAR_3 . get ( VAR_1 ) ; if ( ( x != null ) && x . VAR_5 ( ) ) { <START> METHOD_4 ( VAR_1 ) ; <END> } } } } } 
public TYPE_2 ( TYPE_1 channel , String VAR_3 , String VAR_4 , int VAR_5 ) throws IOException { <START> this ( channel , VAR_3 , VAR_4 , STRING_1 , VAR_5 ) <END> } 
public boolean METHOD_1 ( int VAR_1 , TYPE_1 event ) { if ( VAR_1 == TYPE_1 . VAR_2 ) { if ( VAR_3 . METHOD_2 ( ) ) { VAR_4 . METHOD_3 ( ) ; return true ; } else if ( VAR_5 . METHOD_2 ( ) ) { VAR_6 . METHOD_3 ( ) ; return true ; <START> } else if ( VAR_6 . METHOD_2 ( ) == true ) { <END> VAR_7 . METHOD_3 ( ) ; return true ; } } return super . METHOD_1 ( VAR_1 , event ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( R . VAR_1 . VAR_2 , VAR_1 ) ; <START> VAR_3 . METHOD_4 ( ) ; <END> return true ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( R . id . VAR_2 ) ; <END> METHOD_2 ( R . id . VAR_3 ) ; METHOD_2 ( R . id . VAR_4 ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> TYPE_2 VAR_3 = VAR_1 . METHOD_3 ( Constants . VAR_4 ) ; if ( VAR_3 != null ) { METHOD_4 ( ( TYPE_3 ) VAR_3 ) ; } } 
public void METHOD_1 ( boolean VAR_1 , boolean VAR_2 , boolean VAR_3 , String text , int VAR_4 , String VAR_5 ) { VAR_6 . METHOD_2 ( VAR_1 ) ; VAR_7 . METHOD_2 ( VAR_2 ) ; VAR_8 . METHOD_2 ( VAR_3 ) ; VAR_9 . setText ( text ) ; VAR_10 . METHOD_3 ( VAR_11 . METHOD_4 ( VAR_5 ) ) ; <START> VAR_12 . METHOD_3 ( VAR_13 . METHOD_4 ( VAR_14 . format ( VAR_4 ) ) ) ; <END> } 
public TYPE_2 ( Context context , TYPE_1 VAR_2 ) { super ( context , VAR_2 ) ; METHOD_1 ( VAR_3 ) ; METHOD_2 ( VAR_4 ) ; if ( VAR_5 == null ) { VAR_5 = TYPE_3 . VAR_7 ; } <START> if ( VAR_8 == 0 ) { <END> VAR_8 = INT_1 ; } VAR_9 = TYPE_4 . VAR_11 ; METHOD_3 ( ) ; METHOD_4 ( ) ; } 
<START> public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <END> instance = new TYPE_3 ( VAR_1 , VAR_2 ) ; } 
void METHOD_1 ( TYPE_1 event ) { <START> TYPE_2 . VAR_2 . info ( STRING_1 ) ; <END> METHOD_2 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . add ( INT_1 , 1 < < INT_2 ) ; for ( int i = INT_3 ; i < INT_4 ; ++ i ) { int x = 1 < < i ; VAR_1 . add ( x ) ; Assert . assertEquals ( 1 , VAR_1 . METHOD_2 ( ) ) ; <START> VAR_1 . METHOD_3 ( ) ; <END> Assert . assertEquals ( x , VAR_1 . METHOD_3 ( ) ) ; } } 
public static TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( 1 , new short [ ] { 0 , - 1 , 0 , 0 , 0 , 0 , 0 , 0 } ) ; <END> } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 repo = new TYPE_2 ( ) . METHOD_2 ( ) ; final TYPE_3 VAR_1 = repo . VAR_2 ( ) . create ( "" , "" ) ; <START> final TYPE_4 VAR_3 = TYPE_5 . METHOD_3 ( repo , VAR_1 ) ; <END> final TYPE_6 VAR_4 = new TYPE_7 ( repo . VAR_5 ( ) ) ; VAR_4 . execute ( VAR_3 ) ; TYPE_8 . assertThat ( VAR_3 . read ( ) , TYPE_9 . METHOD_4 ( VAR_6 ) ) ; } 
public String METHOD_1 ( ) { try { <START> return new TYPE_1 ( TYPE_2 . create ( this . url ) ) <END> . METHOD_2 ( TYPE_5 . VAR_2 , TYPE_8 . VAR_4 ) . method ( TYPE_7 . VAR_6 ) . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . class ) . METHOD_5 ( TYPE_6 . VAR_8 ) . METHOD_4 ( TYPE_4 . class ) . METHOD_6 ( ) . METHOD_7 ( ) . METHOD_8 ( STRING_1 ) . getString ( STRING_2 ) ; } catch ( IOException ex ) { throw new IllegalStateException ( ex ) ; } } 
public TYPE_2 ( ) { this ( TYPE_2 . VAR_2 ) ; final TYPE_1 VAR_3 = TYPE_1 . METHOD_1 ( ) ; <START> METHOD_2 ( VAR_3 , STRING_1 ) ; <END> METHOD_2 ( VAR_3 , STRING_2 ) ; } 
public final void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; final String user = STRING_1 ; final String VAR_2 = STRING_2 ; TYPE_2 . assertThat ( <START> VAR_1 . METHOD_2 ( user , VAR_2 ) <END> . name ( ) , TYPE_3 . METHOD_3 ( TYPE_5 . TYPE_6 . name ( ) ) ) ; } 
public TYPE_1 get ( ) { final TYPE_2 VAR_1 = new TYPE_2 ( ) ; VAR_1 . METHOD_1 ( STRING_1 ) ; VAR_1 . METHOD_2 ( this . VAR_2 ) ; <START> if ( this . user != null ) { <END> VAR_1 . METHOD_3 ( STRING_2 ) ; } VAR_1 . METHOD_4 ( this . VAR_3 ) ; VAR_1 . METHOD_5 ( TYPE_3 . VAR_5 ) ; VAR_1 . METHOD_6 ( 1 ) ; VAR_1 . METHOD_7 ( 1 ) ; VAR_1 . METHOD_8 ( 1 ) ; VAR_1 . METHOD_9 ( true ) ; return VAR_1 ; } 
public void METHOD_1 ( ) throws IOException { final TYPE_1 VAR_1 = this . METHOD_2 ( ) ; <START> VAR_1 . close ( ) ; <END> TYPE_2 . assertThat ( VAR_1 . toString ( ) , TYPE_3 . METHOD_3 ( STRING_1 ) ) ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { try { <START> for ( String VAR_2 : VAR_3 ) { <END> METHOD_2 ( VAR_2 , VAR_1 ) ; } } catch ( TYPE_2 e ) { Logger . error ( this , e . getMessage ( ) , e ) ; } } 
<START> public TYPE_4 ( <END> final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final TYPE_3 VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 ; try { VAR_1 = TYPE_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( ) ) . METHOD_4 ( VAR_2 ) ; return VAR_1 ; <START> } catch ( final TYPE_3 e ) { <END> Logger . error ( this , String . format ( STRING_1 + STRING_2 , this . METHOD_5 ( ) ) ) ; } catch ( final TYPE_4 e ) { Logger . error ( this , String . format ( STRING_1 + STRING_2 , this . METHOD_5 ( ) ) ) ; } return null ; } 
private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> List < String > VAR_2 = list ( VAR_3 , <END> VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 ) ; return VAR_1 . METHOD_2 ( ) . stream ( ) . METHOD_3 ( ( VAR_9 - > VAR_2 . contains ( VAR_9 . getName ( ) ) ) ) ; } 
<START> public TYPE_7 ( <END> final TYPE_1 request , final TYPE_2 response , final TYPE_3 VAR_2 , final TYPE_4 host ) { super ( request , response , VAR_2 , host ) ; uri = TYPE_5 . METHOD_1 ( request ) ; this . METHOD_2 ( this . METHOD_3 ( ) ) ; this . user = TYPE_6 . METHOD_4 ( ) . METHOD_5 ( request ) ; } 
private void METHOD_1 ( final String VAR_1 ) { final TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( ) ; final Set < String > VAR_3 = METHOD_3 ( VAR_1 , VAR_2 ) ; <START> <END> METHOD_4 ( VAR_1 , VAR_2 , VAR_3 ) ; } 
public Optional < char [ ] > getValue ( final String VAR_1 ) { <START> char [ ] VAR_2 = METHOD_1 ( VAR_1 , <END> ( ) - > METHOD_2 ( VAR_1 ) ) ; return Arrays . equals ( VAR_2 , VAR_3 ) ? Optional . empty ( ) : Optional . VAR_4 ( METHOD_3 ( VAR_2 ) ) ; } 
public void METHOD_1 ( final String VAR_1 , final TYPE_1 user ) throws TYPE_2 { final TYPE_3 VAR_2 = this . METHOD_2 ( VAR_1 ) ; if ( null != VAR_2 ) { this . METHOD_3 ( VAR_1 , user ) ; } else { <START> <END> throw new TYPE_4 ( STRING_1 + VAR_1 + STRING_2 ) ; } } 
public void METHOD_1 ( final String VAR_1 ) throws TYPE_1 { try { Logger . info ( this , STRING_1 + VAR_1 ) ; new TYPE_2 ( ) . METHOD_2 ( VAR_2 ) . METHOD_3 ( VAR_1 ) . METHOD_4 ( ) ; } catch ( Exception e ) { <START> Logger . error ( TYPE_3 . class , e . getMessage ( ) , e ) ; <END> throw new TYPE_1 ( STRING_2 + STRING_3 + VAR_1 + STRING_4 + e . getMessage ( ) , e ) ; } } 
public TYPE_1 ( final String name , final Object VAR_2 , final String values , final Object VAR_3 , final Class VAR_4 ) { this . name = name ; this . VAR_2 = VAR_2 ; this . values = values ; this . VAR_4 = VAR_4 ; <START> this . VAR_3 = VAR_3 ; <END> } 
public static TYPE_7 . TYPE_8 . Collection < TYPE_2 > METHOD_1 ( final TYPE_7 . TYPE_9 . String VAR_1 ) throws TYPE_10 . TYPE_11 . VAR_2 . TYPE_12 { try { final TYPE_5 VAR_4 = TYPE_6 . METHOD_2 ( ) ; return VAR_4 . METHOD_1 ( ) ; } catch ( final TYPE_10 . TYPE_11 . VAR_2 . TYPE_12 VAR_5 ) { <START> throw VAR_5 ; <END> } catch ( final Exception e ) { throw new TYPE_10 . TYPE_11 . VAR_2 . TYPE_12 ( e ) ; } } 
public void METHOD_1 ( final String VAR_1 ) { for ( final String group : METHOD_2 ( ) ) { <START> METHOD_1 ( VAR_1 , group ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 cache = TYPE_2 . METHOD_2 ( ) ; <START> for ( final String group : METHOD_3 ( ) ) { <END> cache . VAR_1 ( group ) ; } } 
public TYPE_1 METHOD_1 ( final String VAR_1 , final TYPE_2 user , final boolean VAR_2 ) throws TYPE_3 , TYPE_4 { final TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; <START> if ( ! TYPE_5 . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ) <END> return null ; if ( ! VAR_5 . METHOD_5 ( VAR_3 , TYPE_6 . VAR_7 , user , VAR_2 ) ) throw new TYPE_4 ( STRING_1 + VAR_3 . METHOD_6 ( ) ) ; return VAR_3 ; } 
private List < Map < String , String > > METHOD_1 ( final String VAR_1 ) { return VAR_2 . METHOD_1 ( VAR_1 ) . stream ( ) . map ( VAR_3 - > { <START> final Map < String , String > map = new HashMap < > ( ) ; <END> map . put ( STRING_1 , VAR_3 . METHOD_2 ( ) ) ; map . put ( STRING_2 , VAR_3 . METHOD_3 ( ) + "" ) ; return map ; } ) . collect ( TYPE_1 . METHOD_4 ( ) ) ; } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { try { final TYPE_3 VAR_1 = VAR_2 . METHOD_2 ( STRING_1 , TYPE_4 . METHOD_3 ( ) . METHOD_4 ( ) , false ) ; METHOD_5 ( VAR_1 ) ; } catch ( TYPE_5 e ) { <START> Logger . error ( this , STRING_2 , e ) ; <END> } } 
private static String METHOD_1 ( final String VAR_1 ) { <START> final String VAR_2 ; <END> if ( VAR_1 . startsWith ( STRING_1 ) ) { VAR_2 = VAR_1 . METHOD_2 ( STRING_1 , TYPE_1 . VAR_4 ) ; } else { VAR_2 = VAR_1 ; } return VAR_2 ; } 
public boolean METHOD_1 ( String VAR_1 ) { if ( ! TYPE_1 . METHOD_2 ( VAR_1 ) ) { Logger . warn ( this , STRING_1 ) ; } <START> return METHOD_3 ( STRING_2 + VAR_1 + String . format ( STRING_3 , true ) ) ; <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 . METHOD_2 ( ( ) - > { <START> this . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; <END> this . VAR_2 . METHOD_5 ( VAR_1 ) ; } , INT_1 ) ; } 
public List < TYPE_1 > METHOD_1 ( final TYPE_2 VAR_1 ) { if ( ! TYPE_3 . equals ( VAR_1 . getId ( ) ) ) { if ( ! METHOD_2 ( ) && ! this . METHOD_3 ( ) . METHOD_4 ( ) ) { throw new TYPE_4 ( STRING_1 ) ; } } try { return VAR_2 . METHOD_5 ( VAR_1 ) ; } catch ( Exception e ) { <START> throw new TYPE_5 ( e ) ; <END> } } 
private boolean METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 < TYPE_3 > VAR_2 ) throws TYPE_4 { <START> for ( TYPE_3 VAR_3 : VAR_2 ) { <END> if ( VAR_4 . METHOD_2 ( VAR_1 , TYPE_5 . VAR_6 , VAR_3 ) ) { return true ; } } return false ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 request , final TYPE_3 response , final TYPE_4 user , final TYPE_5 page , TYPE_6 VAR_1 ) throws TYPE_7 , TYPE_8 , IOException { <START> return TYPE_9 . get ( ) <END> . METHOD_2 ( page ) . METHOD_3 ( user ) . METHOD_4 ( request ) . METHOD_5 ( response ) . METHOD_6 ( METHOD_7 ( request , user ) ) . build ( ) ; } 
TYPE_1 METHOD_1 ( ) { TYPE_1 user = null ; <START> TYPE_2 session = request . VAR_1 ( false ) ; <END> if ( session != null ) { user = ( TYPE_1 ) session . VAR_2 ( VAR_3 . VAR_4 . VAR_5 . TYPE_3 . VAR_7 ) ; } return user ; } 
public void execute ( TYPE_1 data ) { try { METHOD_1 ( data ) ; } catch ( Exception e ) { Logger . error ( this , STRING_1 + this . getClass ( ) , e ) ; } finally { try { <START> TYPE_2 . METHOD_2 ( ) ; <END> } catch ( TYPE_3 e ) { Logger . warn ( this , e . getMessage ( ) , e ) ; } } } 
private static String METHOD_1 ( Date VAR_1 ) { try { <START> TYPE_1 VAR_2 = new TYPE_1 ( TYPE_2 ) ; <END> String VAR_3 = VAR_2 . format ( VAR_1 ) ; return VAR_3 ; } catch ( Exception ex ) { Logger . error ( TYPE_3 . class , ex . toString ( ) ) ; return VAR_4 ; } } 
public boolean METHOD_1 ( ) { <START> return null == this . METHOD_2 ( ) || <END> TYPE_1 . equalsIgnoreCase ( this . METHOD_2 ( ) ) ; } 
<START> public final static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 request , TYPE_4 response ) { <END> switch ( VAR_1 ) { case VAR_2 : return new TYPE_5 ( request , response ) ; case VAR_3 : return new TYPE_6 ( request , response ) ; default : return new TYPE_7 ( request , response ) ; } } 
public TYPE_1 METHOD_1 ( final String VAR_1 ) throws TYPE_2 , TYPE_3 { <START> if ( ! TYPE_4 . METHOD_2 ( VAR_1 ) ) return null ; <END> final TYPE_1 type = this . VAR_2 . METHOD_1 ( VAR_1 ) ; if ( VAR_3 . METHOD_3 ( type , TYPE_5 . VAR_5 , user ) ) { return type ; } throw new TYPE_2 ( STRING_1 + user + STRING_2 + type ) ; } 
abstract void METHOD_1 ( ) throws Exception ; abstract void METHOD_1 ( TYPE_1 out ) throws TYPE_2 , IOException , TYPE_3 ; public final String METHOD_2 ( ) { <START> TYPE_4 out = new TYPE_4 ( INT_1 ) ; <END> try { METHOD_1 ( out ) ; } catch ( Exception e ) { throw new TYPE_5 ( e ) ; } return out . toString ( ) ; } 
public TYPE_2 ( List < Map < String , Object > > VAR_2 ) { <START> List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; <END> if ( VAR_2 != null ) { for ( Map < String , Object > map : VAR_2 ) { VAR_3 . add ( METHOD_1 ( map ) ) ; } } this . list = VAR_3 ; } 
<START> public String METHOD_1 ( ) throws Exception { <END> TYPE_1 sb = new TYPE_1 ( ) ; if ( this . VAR_1 != null ) { for ( String container : this . VAR_1 ) { if ( this . VAR_2 ) { sb . append ( TYPE_2 . METHOD_2 ( ) ) ; } else { sb . append ( STRING_1 ) . append ( container ) . append ( STRING_2 ) ; } } } return sb . toString ( ) ; } 
public String getPath ( ) { <START> if ( METHOD_1 ( ) . equals ( STRING_1 ) && METHOD_2 ( ) . equals ( STRING_2 ) ) <END> return STRING_3 ; else { String x = METHOD_2 ( ) + METHOD_1 ( ) ; if ( STRING_4 . equals ( VAR_1 ) ) { if ( ! x . VAR_2 ( STRING_3 ) ) { x = x + STRING_3 ; } } return x ; } } 
public Date METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public String METHOD_1 ( ) { String VAR_1 = TYPE_1 . METHOD_2 ( this . getClass ( ) ) ; <START> String key = VAR_1 . substring ( 0 , 1 ) . METHOD_3 ( ) + VAR_1 . substring ( 1 ) ; <END> return key ; } 
public boolean METHOD_1 ( final Object VAR_1 ) { final TYPE_1 VAR_2 = new TYPE_1 ( false ) ; final Map < Class < ? > , TYPE_2 > VAR_3 = this . VAR_4 . METHOD_2 ( VAR_1 ) ; if ( null != VAR_3 && ! VAR_3 . isEmpty ( ) ) { VAR_3 . forEach ( ( VAR_5 , VAR_6 ) - > <START> VAR_2 . set ( VAR_2 . get ( ) | this . METHOD_1 ( VAR_5 , VAR_6 . getId ( ) ) ) ) ; <END> } return VAR_2 . get ( ) ; } 
protected List < String > METHOD_1 ( ) { <START> return null ; <END> } 
private String METHOD_1 ( String VAR_1 ) throws TYPE_1 { TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( VAR_3 ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; List < Map < String , String > > VAR_4 = VAR_2 . METHOD_4 ( ) ; <START> return VAR_4 . get ( 0 ) . get ( STRING_1 ) . toString ( ) ; <END> } 
public void METHOD_1 ( String VAR_1 , long VAR_2 ) { List < TYPE_1 > VAR_3 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 , VAR_2 , TYPE_2 . METHOD_4 ( ) ) ; <START> VAR_3 . stream ( ) . forEach ( ( TYPE_1 VAR_4 ) - > METHOD_5 ( VAR_4 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( final TYPE_2 req , final TYPE_3 user ) { try { final TYPE_4 session = req . VAR_1 ( ) ; String VAR_2 = ( String ) session . VAR_3 ( VAR_4 . VAR_5 . VAR_6 . TYPE_8 . VAR_8 ) ; <START> TYPE_1 host = null ; <END> if ( VAR_2 != null ) { host = VAR_9 . METHOD_2 ( VAR_2 , user , false ) ; } return host ; } catch ( TYPE_5 | TYPE_6 e ) { throw new TYPE_7 ( e ) ; } } 
<START> public void METHOD_1 ( ) throws Exception { <END> final String VAR_1 = STRING_1 ; try { VAR_2 . METHOD_2 ( TYPE_1 . METHOD_3 ( ) , VAR_1 , 0 , - 1 , "" , null , null , true , false , false , false , "" , false , false , 1 ) ; } catch ( Exception e ) { Assert . assertTrue ( e instanceof TYPE_2 ) ; } } 
public String METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 user ) { final TYPE_3 request = VAR_2 . METHOD_2 ( ) ; <START> String VAR_3 = request != null ? METHOD_1 ( request , VAR_1 , user ) : null ; <END> return VAR_3 ; } 
public void METHOD_1 ( ) { if ( System . getProperty ( TYPE_5 . VAR_2 ) != null ) { TYPE_1 context = TYPE_2 . instance ( ) . METHOD_2 ( ) ; if ( null != context ) { TYPE_3 < String , String > props = new TYPE_3 < String , String > ( ) ; context . VAR_3 ( TYPE_4 . class . getName ( ) , this , props ) ; } else { <START> Logger . debug ( this , STRING_1 ) ; <END> } } } 
private List < Class < ? > > METHOD_1 ( ) { <START> List < Class < ? > > VAR_1 = new ArrayList < > ( ) ; <END> VAR_1 . add ( TYPE_1 . class ) ; VAR_1 . add ( TYPE_2 . class ) ; VAR_1 . add ( File . VAR_2 ) ; VAR_1 . add ( TYPE_3 . VAR_2 ) ; return VAR_1 ; } 
private boolean METHOD_1 ( final TYPE_1 session , final TYPE_2 VAR_1 ) { final TYPE_3 VAR_2 = this . VAR_3 . METHOD_2 ( VAR_1 ) ; <START> if ( null != VAR_2 ) { <END> return VAR_2 . METHOD_3 ( VAR_1 , session ) ; } return true ; } 
public void METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; File VAR_2 = null ; try { VAR_2 = VAR_3 . METHOD_3 ( TYPE_2 . VAR_5 , STRING_1 , VAR_1 ) ; assertNotNull ( VAR_2 ) ; } catch ( TYPE_1 | IllegalArgumentException | IOException e ) { e . VAR_6 ( ) ; } finally { <START> VAR_2 . METHOD_4 ( ) ; <END> } } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_1 { if ( ! TYPE_2 . METHOD_2 ( VAR_1 ) || ! TYPE_2 . METHOD_2 ( VAR_2 ) ) { <START> return ; <END> } TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_3 . METHOD_3 ( VAR_4 ) ; VAR_3 . METHOD_4 ( VAR_2 ) ; VAR_3 . METHOD_4 ( VAR_1 ) ; VAR_3 . METHOD_5 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 event , TYPE_2 session ) { TYPE_3 VAR_1 = event . VAR_2 ( ) ; TYPE_4 VAR_3 = ( TYPE_4 ) VAR_1 . METHOD_2 ( ) ; TYPE_5 VAR_4 = VAR_3 . METHOD_3 ( ) ; <START> TYPE_6 VAR_5 = TYPE_6 . getInstance ( VAR_4 , VAR_3 . METHOD_4 ( ) ) ; <END> return new TYPE_1 ( event . getId ( ) , event . VAR_6 ( ) , new TYPE_3 ( VAR_5 , VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_6 ( ) ) , event . VAR_7 ( ) ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 user ) { TYPE_3 input = METHOD_2 ( VAR_1 , user ) ; TYPE_1 VAR_2 = VAR_3 . METHOD_3 ( input , user ) ; <START> if ( VAR_2 == null ) { <END> throw new TYPE_4 ( STRING_1 , VAR_1 ) ; } return VAR_2 ; } 
private int METHOD_1 ( int length ) throws IOException { if ( length > VAR_1 . length - VAR_2 ) { METHOD_2 ( length ) ; } int VAR_3 = VAR_4 . read ( VAR_1 , VAR_2 , Math . VAR_5 ( length , VAR_1 . length - VAR_2 ) ) ; if ( VAR_3 < 0 ) { throw new IOException ( STRING_1 ) ; } VAR_2 += VAR_3 ; <START> System . out . println ( VAR_3 ) ; <END> return VAR_3 ; } 
private void METHOD_1 ( int VAR_1 ) throws IOException { int VAR_2 = is . read ( buffer , VAR_3 , Math . VAR_4 ( VAR_1 , buffer . length - VAR_3 ) ) ; if ( VAR_2 < 0 ) { <START> throw new IOException ( String . format ( STRING_1 ) ) ; <END> } VAR_3 = VAR_3 + VAR_2 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( TYPE_2 . class ) ; <START> METHOD_3 ( VAR_2 , null ) ; <END> } 
public TYPE_1 METHOD_1 ( String name , TYPE_2 VAR_1 ) { <START> if ( METHOD_2 ( ) == null ) { <END> VAR_2 = TYPE_3 . get ( ) ; } if ( VAR_1 == null ) { return METHOD_2 ( ) . METHOD_3 ( STRING_1 + name ) . start ( ) ; } else { return METHOD_2 ( ) . METHOD_3 ( STRING_1 + name ) . METHOD_4 ( VAR_1 ) . start ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , Map < String , String > props ) { <START> if ( VAR_1 != null ) { <END> VAR_2 . remove ( VAR_1 ) ; final TYPE_2 < TYPE_3 > VAR_3 = VAR_4 . remove ( VAR_1 ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_2 ( ) ; } } } 
<START> protected TYPE_1 < TYPE_2 > METHOD_1 ( Collection < TYPE_2 > list ) { <END> return new TYPE_3 ( list ) ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 == null ) { return false ; } <START> return ( new Date ( ) . METHOD_2 ( ) - VAR_1 . METHOD_2 ( ) ) / INT_1 < TYPE_1 . VAR_3 ; <END> } 
public void METHOD_1 ( TYPE_1 resource , Collection < String > VAR_1 ) { <START> this . VAR_2 . add ( new TYPE_2 ( resource , VAR_1 ) ) ; <END> } 
public TYPE_5 ( final TYPE_1 buffer ) throws TYPE_2 { this . VAR_2 = new TYPE_3 ( buffer ) ; <START> this . data = new TYPE_4 ( buffer , Optional . empty ( ) , VAR_3 - > TYPE_4 . METHOD_1 ( VAR_3 ) ) ; <END> } 
public Optional < String > METHOD_1 ( final TYPE_2 . TYPE_3 message ) { if ( message . VAR_1 ( ) ) { return Optional . of ( String . format ( STRING_1 , message . VAR_2 ( ) , message . VAR_3 ( ) , message . VAR_4 ( ) ) ) ; } else { <START> return null ; <END> } } 
<START> public synchronized static TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { <END> TYPE_1 VAR_4 = new TYPE_2 ( VAR_1 , VAR_2 , VAR_3 ) ; return VAR_4 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 : new TYPE_1 ( ) ; <END> } 
public TYPE_1 build ( TYPE_2 VAR_1 , Object message , Long VAR_2 ) throws TYPE_3 { final TYPE_4 builder = new TYPE_4 ( VAR_1 ) ; <START> if ( VAR_2 != null ) { <END> builder . VAR_3 ( new Date ( VAR_2 ) ) ; } final TYPE_5 VAR_4 = new TYPE_5 ( ) ; VAR_4 . put ( STRING_1 , VAR_1 ) ; VAR_4 . put ( STRING_2 , builder ) ; VAR_4 . put ( STRING_3 , message ) ; VAR_5 . METHOD_1 ( VAR_4 ) ; return builder . build ( ) ; } 
public Collection < TYPE_1 > get ( ) { <START> return container ; <END> } 
TYPE_2 ( String VAR_2 , TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> VAR_4 = null ; <END> VAR_5 = null ; } 
<START> <END> public <END> TYPE_1 <END> < <END> <END> TYPE_2 <END> <END> > <END> <END> METHOD_1 <END> ( <END> TYPE_2 <END> <END> message ) throws TYPE_3 { <END> final TYPE_1 <END> < <END> TYPE_2 <END> > <END> VAR_1 = <END> <END> <END> new <END> TYPE_1 <END> < > ( <END> ) ; byte <END> <END> <END> [ <END> ] <END> VAR_2 <END> = <END> VAR_3 . METHOD_2 <END> ( message <END> ) <END> ; <END> String <END> VAR_4 = <END> TYPE_4 <END> . METHOD_3 ( <END> <END> ) . 
public Response METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; VAR_2 . METHOD_3 ( null ) ; <START> VAR_2 . METHOD_4 ( 0 ) ; <END> final int VAR_3 = VAR_4 . METHOD_1 ( VAR_2 ) ; final TYPE_3 builder = TYPE_3 . METHOD_5 ( TYPE_4 . class ) ; final TYPE_5 uri = builder . path ( TYPE_4 . class , STRING_1 ) . build ( VAR_3 ) ; return Response . VAR_5 ( uri ) . build ( ) ; } 
public String METHOD_1 ( ) { <START> return null ; <END> } 
public void METHOD_1 ( ) throws Exception { System . VAR_1 ( STRING_1 , STRING_2 ) ; TYPE_1 . METHOD_2 ( ) ; <START> TYPE_2 VAR_2 = new TYPE_2 ( ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { <START> METHOD_2 ( VAR_1 ) ; <END> this . VAR_1 = VAR_1 ; } 
public TYPE_1 build ( ) { <START> return new TYPE_1 ( this . location , <END> this . VAR_1 , this . VAR_2 , this . VAR_3 , this . VAR_4 , this . VAR_5 , this . VAR_6 ) ; } 
public void METHOD_1 ( Long VAR_1 ) { <START> this . VAR_2 = VAR_2 ; <END> } 
public void METHOD_1 ( ) { <START> this . VAR_1 . get ( this . METHOD_2 ( ) + STRING_1 ) ; <END> assertThat ( TYPE_1 . METHOD_3 ( VAR_1 . METHOD_4 ( TYPE_2 . METHOD_5 ( STRING_2 ) ) , TYPE_3 : : METHOD_6 ) , METHOD_7 ( STRING_3 , STRING_4 ) ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . METHOD_1 ( VAR_2 . getId ( ) + STRING_1 + VAR_2 . METHOD_2 ( ) ) ; <END> } 
public TYPE_1 ( TYPE_1 VAR_1 ) { <START> this ( new TYPE_2 ( VAR_1 . source ) , new TYPE_2 ( VAR_1 . target ) , new HashMap < > ( VAR_1 . METHOD_1 ( ) ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return this . getProperty ( TYPE_2 . VAR_2 ) ; <END> } 
public static TYPE_1 create ( String id , String VAR_1 , String VAR_2 , String VAR_3 ) { <START> return new TYPE_1 ( TYPE_2 . METHOD_1 ( id , STRING_1 ) , VAR_1 , VAR_2 , <END> VAR_3 ) ; } 
private static Integer METHOD_1 ( String VAR_1 ) { final String val = System . getProperty ( VAR_1 , null ) ; if ( val == null ) { return null ; } try { return Integer . parseInt ( val ) ; } catch ( TYPE_1 e ) { <START> LOG . error ( STRING_1 ) ; <END> return null ; } } 
public TYPE_3 ( ) { <START> TYPE_1 . METHOD_1 ( ) . METHOD_2 ( new Thread ( new TYPE_2 ( ) { <END> @Override public void run ( ) { TYPE_3 . VAR_2 . VAR_3 = true ; TYPE_3 . VAR_2 . VAR_4 . METHOD_3 ( ) ; TYPE_3 . VAR_2 . VAR_5 . METHOD_3 ( ) ; LOG . debug ( STRING_1 ) ; } } ) ) ; } 
public TYPE_2 ( final String VAR_2 , final boolean VAR_3 , final String VAR_4 , final boolean VAR_5 , final String VAR_6 , final int VAR_7 , final int VAR_8 , final TYPE_1 VAR_9 ) { <START> this . VAR_10 = VAR_2 ; <END> this . VAR_11 = VAR_3 ; this . VAR_12 = VAR_4 ; this . VAR_13 = VAR_5 ; this . VAR_14 = VAR_6 ; this . VAR_15 = VAR_7 ; this . VAR_16 = VAR_8 ; this . VAR_17 = VAR_9 ; } 
public boolean METHOD_1 ( ) { synchronized ( VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) { <END> VAR_1 = false ; return true ; } } return false ; } 
public boolean METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> if ( VAR_1 . METHOD_2 ( ) ) { return true ; } } return false ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> final Integer VAR_2 = VAR_1 . getId ( ) ; <END> final String VAR_3 = VAR_1 . METHOD_2 ( ) ; METHOD_3 ( VAR_4 - > VAR_4 . METHOD_4 ( VAR_2 , VAR_3 ) ) ; } 
public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } <START> if ( ! ( obj instanceof TYPE_1 ) ) { return false ; } <END> if ( ! super . equals ( obj ) ) { return false ; } return VAR_1 . VAR_2 . TYPE_3 . equals ( VAR_4 , ( ( TYPE_2 ) obj ) . VAR_4 ) ; } 
public static Set < String > METHOD_1 ( final TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 ) ; Set < String > VAR_2 = new HashSet < > ( ) ; <START> for ( TYPE_3 VAR_3 : VAR_1 . METHOD_3 ( ) ) { <END> VAR_2 . add ( METHOD_4 ( VAR_3 ) ) ; VAR_2 . add ( METHOD_5 ( VAR_3 ) ) ; VAR_2 . add ( METHOD_6 ( VAR_3 ) ) ; } return VAR_2 ; } 
public void METHOD_1 ( ) throws TYPE_1 { final TYPE_2 config = VAR_1 . get ( ) ; for ( TYPE_3 VAR_2 : config . VAR_3 ( ) ) { final String name = VAR_2 . getName ( ) . split ( STRING_1 ) [ 1 ] ; <START> this . VAR_4 . add ( new TYPE_4 ( name , VAR_5 . contains ( name ) , VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) ) ) ; <END> } } 
public void METHOD_1 ( Set < TYPE_1 > VAR_1 ) { VAR_2 . clear ( ) ; <START> VAR_1 . stream ( ) . forEach ( VAR_3 - > VAR_2 . add ( new TYPE_2 ( this , VAR_3 ) ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , Date VAR_2 ) { LOG . info ( STRING_1 , VAR_1 . getId ( ) , VAR_2 ) ; final TYPE_1 VAR_3 = VAR_4 . get ( VAR_1 . getId ( ) ) ; if ( VAR_3 == null ) { LOG . warn ( STRING_2 , VAR_1 ) ; return ; } <START> TYPE_2 VAR_5 = new TYPE_2 ( VAR_1 , VAR_6 , VAR_2 ) ; <END> VAR_5 . METHOD_2 ( TYPE_3 . VAR_8 ) ; VAR_9 . METHOD_3 ( VAR_5 ) ; } 
public void debug ( String message , Object ... VAR_1 ) { <START> LOG . warn ( message , VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_3 . equals ( VAR_1 . METHOD_2 ( TYPE_2 . class ) . getType ( ) ) ) { <START> if ( VAR_4 . add ( new TYPE_3 < > ( VAR_2 ) ) ) { <END> LOG . debug ( STRING_1 , VAR_2 , VAR_3 . METHOD_3 ( ) ) ; VAR_5 = true ; } } } 
public TYPE_1 getInstance ( ) { <START> VAR_1 . METHOD_1 ( ) . METHOD_2 ( ) ; <END> try { return VAR_1 ; } finally { VAR_1 . METHOD_1 ( ) . METHOD_3 ( ) ; } } 
public void METHOD_1 ( final TYPE_1 event ) { TYPE_2 . METHOD_2 ( event , STRING_1 , ( e ) - > { VAR_1 . METHOD_3 ( ) ; <START> } ) ; <END> } 
TYPE_1 ( final File file ) { <START> this . VAR_2 = file ; <END> this . VAR_3 = null ; } 
public Collection < TYPE_1 > METHOD_1 ( String VAR_1 ) throws TYPE_2 { <START> TYPE_3 VAR_2 = new TYPE_3 ( ) ; <END> String query = STRING_1 + STRING_2 + VAR_2 . METHOD_2 ( VAR_1 ) + STRING_3 + STRING_4 ; return METHOD_3 ( query ) ; } 
private TYPE_1 ( String VAR_2 , String VAR_3 ) { super ( VAR_3 ) ; <START> METHOD_1 ( VAR_2 ) ; <END> VAR_4 = VAR_2 ; } 
public void METHOD_1 ( Set < TYPE_1 > VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
public void METHOD_1 ( ) throws InterruptedException , TYPE_1 { METHOD_2 ( VAR_1 , VAR_2 . METHOD_3 ( ) ) ; <START> Thread . VAR_3 ( INT_1 ) ; <END> TYPE_2 request = new TYPE_2 ( STRING_1 ) ; request . VAR_4 ( VAR_1 ) ; request . VAR_5 ( INT_2 ) ; TYPE_3 VAR_6 = new TYPE_3 ( STRING_1 ) ; TYPE_3 VAR_7 = VAR_8 . execute ( request ) . get ( ) ; assertEquals ( VAR_6 , VAR_7 ) ; } 
public TYPE_3 ( ) { String format = System . getProperty ( VAR_2 ) ; if ( format == null ) { this . VAR_3 = VAR_4 ; } else { try { this . VAR_3 = TYPE_1 . METHOD_1 ( format ) . METHOD_2 ( TYPE_2 . METHOD_3 ( ) ) ; } catch ( IllegalArgumentException e ) { log . log ( Level . VAR_5 , String . format ( STRING_1 + STRING_2 , VAR_2 , format ) <START> , e ) ; <END> this . VAR_3 = VAR_4 ; } } } 
public int METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( ) ; try { <START> if ( VAR_1 . METHOD_1 ( ) <= 0 ) { <END> return VAR_1 . METHOD_1 ( ) ; } else { return TYPE_1 . METHOD_4 ( ) . METHOD_5 ( ) * 2 ; } } finally { METHOD_2 ( ) . METHOD_6 ( ) ; } } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) == null ) { <END> return null ; } final TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ? METHOD_3 ( VAR_1 ) : METHOD_4 ( VAR_1 ) ; return METHOD_5 ( VAR_2 ) ; } 
public TYPE_4 ( TYPE_1 context , TYPE_2 VAR_2 ) { <START> TYPE_3 . METHOD_1 ( context , STRING_1 ) ; <END> TYPE_3 . METHOD_1 ( VAR_2 , STRING_2 ) ; VAR_3 = context ; VAR_4 = VAR_2 ; } 
public String [ ] METHOD_1 ( final List < String > value ) throws Exception { <START> System . err . println ( STRING_1 + value ) ; <END> if ( value == null ) return null ; return value . stream ( ) . map ( String : : trim ) . collect ( Collectors . VAR_1 ( ) ) . METHOD_2 ( VAR_2 ) ; } 
private void METHOD_1 ( final long VAR_1 ) { LOG . debug ( STRING_1 , VAR_1 ) ; <START> if ( VAR_2 != null ) { <END> METHOD_2 ( ) ; } METHOD_3 ( VAR_1 ) ; } 
public boolean equals ( final Object o ) { if ( this == o ) { return true ; } <START> if ( o == null || this . getClass ( ) != o . getClass ( ) ) { <END> return false ; } final TYPE_1 that = ( TYPE_1 ) o ; return TYPE_2 . METHOD_1 ( this . METHOD_2 ( ) , that . VAR_1 ( ) ) && TYPE_2 . METHOD_1 ( this . METHOD_3 ( ) , that . VAR_2 ( ) ) ; } 
<START> public void METHOD_1 ( ) { <END> try { VAR_1 . VAR_2 . METHOD_2 ( 1 , TimeUnit . VAR_3 ) ; METHOD_3 ( ) . METHOD_4 ( TYPE_1 . METHOD_5 ( STRING_1 ) ) . METHOD_6 ( ) ; } catch ( TYPE_2 e ) { } finally { VAR_1 . VAR_2 . METHOD_2 ( ) ; } METHOD_7 ( ) ; } 
public TYPE_1 METHOD_1 ( String location , TYPE_2 VAR_1 , Integer VAR_2 , Map < String , String > VAR_3 ) { <START> return new TYPE_3 ( VAR_1 , VAR_2 ) ; <END> } 
private void METHOD_1 ( ) throws IOException { <START> final TYPE_1 r = new TYPE_2 ( TYPE_3 . METHOD_2 ( TYPE_3 . VAR_1 ) ) ; <END> VAR_2 = TYPE_4 . METHOD_3 ( TYPE_5 . class , r ) ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . stream ( ) . filter ( t - > t . VAR_2 ( ) ) . METHOD_2 ( ) . isPresent ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 context ) throws InterruptedException { TYPE_2 VAR_1 = context . VAR_2 ( STRING_1 ) ; <START> String location = context . VAR_3 ( ) ; <END> if ( VAR_1 == null ) { return ; } TYPE_3 VAR_4 = VAR_5 . METHOD_2 ( VAR_1 , location ) ; TYPE_4 VAR_6 = TYPE_5 . METHOD_3 ( VAR_4 , getName ( ) , METHOD_4 ( context ) ) ; VAR_6 . start ( ) ; VAR_6 . METHOD_5 ( ) ; } 
private static TYPE_1 METHOD_1 ( ) { try { return TYPE_1 . METHOD_2 ( TYPE_2 . class ) ; } catch ( TYPE_3 e ) { <START> e . VAR_1 ( ) ; <END> } return null ; } 
public Iterator < TYPE_1 > METHOD_1 ( final Iterator < TYPE_1 > it ) { return TYPE_2 . stream ( TYPE_3 . METHOD_2 ( it , VAR_1 | VAR_2 ) , false ) <START> . filter ( item - > { return ! METHOD_3 ( item . VAR_3 ( ) ) ; } ) <END> . iterator ( ) ; } 
public void execute ( List < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_2 != null && VAR_2 . METHOD_1 ( ) != null ) { <START> VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; <END> VAR_2 . METHOD_1 ( ) . METHOD_4 ( true ) ; VAR_2 . METHOD_1 ( ) . METHOD_5 ( ) ; TYPE_3 . METHOD_6 ( ) . METHOD_7 ( ) ; } } 
public void METHOD_1 ( String table ) { if ( STRING_1 . equalsIgnoreCase ( table ) ) { this . VAR_1 = true ; } else { this . VAR_1 = false ; } <START> } <END> 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws InterruptedException { METHOD_2 ( STRING_1 ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( METHOD_5 ( STRING_2 ) ) ; <START> return new TYPE_1 ( VAR_1 ) . name ( VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( String key , String value ) throws InterruptedException { METHOD_2 ( ) . key ( key ) . value ( value ) . METHOD_3 ( ) ; <START> VAR_1 . METHOD_4 ( TYPE_2 . METHOD_5 ( TYPE_3 . id ( STRING_1 ) ) ) ; <END> return this ; } 
public TYPE_1 value ( String value ) { METHOD_1 ( STRING_1 ) . clear ( ) ; <START> METHOD_1 ( STRING_1 ) . METHOD_2 ( String . valueOf ( value ) ) ; <END> return this ; } 
public TYPE_1 METHOD_1 ( String key , String value ) throws InterruptedException { METHOD_2 ( STRING_1 ) . METHOD_3 ( key ) ; METHOD_4 ( ) . value ( value ) . METHOD_5 ( ) ; <START> VAR_1 . METHOD_6 ( TYPE_2 . METHOD_7 ( TYPE_3 . id ( STRING_2 ) ) ) ; <END> return this ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <START> TYPE_4 . METHOD_1 ( VAR_2 ) ; <END> TYPE_4 . METHOD_1 ( VAR_3 ) ; TYPE_4 . METHOD_1 ( VAR_4 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
<START> public static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final String VAR_2 , final int VAR_3 ) <END> throws IOException { final byte [ ] VAR_4 ; final String format = METHOD_2 ( VAR_2 ) ; if ( VAR_3 != 0 ) { VAR_4 = METHOD_3 ( VAR_1 , format , VAR_3 ) ; } else { VAR_4 = METHOD_3 ( VAR_1 , format ) ; } return TYPE_1 . METHOD_4 ( VAR_4 ) ; } 
public void METHOD_1 ( final TYPE_1 params ) { METHOD_2 ( ( ( ) - > { METHOD_3 ( params ) ; <START> LOG . info ( STRING_1 + params . getName ( ) ) ; <END> return true ; } ) , params . getName ( ) ) ; } 
public String METHOD_1 ( final TYPE_1 params ) { <START> return Optional . VAR_1 ( METHOD_2 ( params . getName ( ) , params . VAR_2 ( ) ) ) . <END> map ( TYPE_2 : : METHOD_3 ) . METHOD_4 ( null ) ; } 
<START> public ImmutableList < TYPE_1 > METHOD_1 ( ) <END> { return VAR_1 ; } 
public static TYPE_1 from ( final String value ) { <START> if ( value . equalsIgnoreCase ( TYPE_2 . toString ( ) ) ) <END> { return TYPE_2 ; } else if ( value . equalsIgnoreCase ( TYPE_3 . toString ( ) ) ) { return TYPE_3 ; } else if ( value . equalsIgnoreCase ( TYPE_4 . toString ( ) ) ) { return TYPE_4 ; } throw new IllegalArgumentException ( STRING_1 + value ) ; } 
public TYPE_1 create ( final TYPE_2 VAR_1 ) throws Exception { final TYPE_3 project = VAR_2 . create ( METHOD_1 ( VAR_1 ) ) ; final TYPE_4 VAR_3 = METHOD_2 ( VAR_1 ) ; <START> VAR_2 . METHOD_3 ( project . getName ( ) , METHOD_2 ( VAR_1 ) ) ; <END> return new TYPE_1 ( project , VAR_3 ) ; } 
public TYPE_5 ( final TYPE_1 config , ANNOTATION_1 ( VAR_2 = TYPE_2 . class ) final TYPE_3 VAR_3 , ANNOTATION_1 TYPE_4 VAR_4 ) { <START> this . VAR_3 = config . VAR_5 ( ) ? VAR_3 : null ; <END> this . VAR_4 = VAR_4 ; } 
private void METHOD_1 ( ) { if ( this . VAR_1 != null ) { return ; } <START> this . VAR_1 = context . VAR_2 ( TYPE_1 . class , client , new TYPE_2 < > ( ) ) ; <END> this . VAR_3 = true ; } 
<START> private Boolean METHOD_1 ( final TYPE_1 VAR_1 ) <END> { final TYPE_2 params = TYPE_2 . from ( VAR_1 . METHOD_2 ( ) ) ; final TYPE_3 VAR_2 = this . VAR_3 . METHOD_3 ( params ) ; return VAR_2 != null ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { try { return METHOD_2 ( ) . METHOD_1 ( VAR_1 ) ; } catch ( TYPE_2 e ) { <START> logger . info ( STRING_1 + VAR_1 , e ) ; <END> } return null ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; try { TYPE_2 VAR_2 = VAR_3 ; if ( VAR_4 ) { if ( VAR_2 != null ) { <START> throw new IllegalStateException ( STRING_1 ) ; <END> } VAR_2 = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( TYPE_4 . VAR_6 ) ; } if ( VAR_2 != null ) { VAR_1 = VAR_2 . build ( ) ; } } catch ( Exception e ) { e . VAR_7 ( ) ; } return VAR_1 != null ? VAR_1 : TYPE_3 . METHOD_4 ( ) ; } 
private static String METHOD_1 ( Object VAR_1 ) { <START> if ( VAR_1 == null ) return null ; <END> String value = VAR_1 . toString ( ) ; if ( STRING_1 . equals ( value ) ) { return value ; } return METHOD_2 ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( String ... VAR_1 ) { TYPE_1 VAR_2 = null ; String url = VAR_1 [ 0 ] ; try { TYPE_2 in = new TYPE_6 . TYPE_7 . TYPE_4 ( url ) . METHOD_2 ( ) ; VAR_2 = TYPE_5 . METHOD_3 ( in ) ; <START> } catch ( Exception e ) { <END> Log . e ( TAG , e . getMessage ( ) ) ; } return VAR_2 ; } 
private void METHOD_1 ( int VAR_1 ) { TYPE_1 VAR_2 = ( TYPE_1 ) METHOD_2 ( R . id . VAR_3 ) ; <START> VAR_2 . setText ( "" ) ; <END> String VAR_4 = STRING_1 + CHAR_1 + STRING_2 + VAR_1 ; VAR_2 . setText ( VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 < ? > VAR_1 , View view , int position , long VAR_2 ) { TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 . METHOD_2 ( position ) ; TYPE_3 VAR_4 = new TYPE_3 ( TYPE_3 . VAR_5 ) ; <START> VAR_4 . METHOD_3 ( VAR_6 , ( VAR_3 ) . METHOD_4 ( ) ) ; <END> if ( VAR_7 != null ) { VAR_4 . METHOD_3 ( VAR_8 , VAR_7 ) ; VAR_4 . METHOD_3 ( VAR_9 , VAR_10 ) ; } METHOD_5 ( VAR_11 , VAR_4 ) ; METHOD_6 ( ) ; } 
protected void METHOD_1 ( int VAR_1 , int VAR_2 , TYPE_1 VAR_3 ) { if ( VAR_1 == VAR_4 ) { VAR_5 = false ; VAR_6 = false ; if ( VAR_2 == VAR_7 ) { VAR_8 . METHOD_2 ( ) ; } else { TYPE_2 . METHOD_3 ( this , VAR_1 , VAR_2 , R . string . VAR_9 , R . string . VAR_10 ) ; } <START> } <END> } 
<START> public void METHOD_1 ( TYPE_1 context ) throws Exception { <END> TYPE_2 VAR_1 = TYPE_3 . get ( ) ; if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { VAR_1 . METHOD_3 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 factory = new TYPE_1 ( ) ; factory . VAR_1 ( METHOD_2 ( ) ) ; factory . VAR_2 ( METHOD_3 ( ) ) ; factory . VAR_3 ( true ) ; factory . VAR_4 ( container - > { container . VAR_5 ( true ) ; <START> container . VAR_6 ( true ) ; <END> container . VAR_7 ( 2 ) ; } ) ; return factory ; } 
protected void METHOD_1 ( TYPE_1 listener , Object data ) { TYPE_2 message = null ; try { <START> if ( listener instanceof TYPE_3 ) { <END> listener . VAR_1 ( ( List < TYPE_2 > ) data ) ; } else { message = ( TYPE_2 ) data ; listener . VAR_2 ( message ) ; } } catch ( Exception e ) { throw METHOD_2 ( e , message ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <START> if ( this . VAR_3 != null ) { <END> this . VAR_3 . remove ( VAR_1 ) ; } } 
public synchronized int METHOD_1 ( ) { return this . VAR_1 . values ( ) . stream ( ) <START> . map ( Map : : size ) <END> . METHOD_2 ( Integer : : valueOf ) . METHOD_3 ( ) ; } 
public int METHOD_1 ( final String VAR_1 ) { return this . VAR_2 . execute ( channel - > { TYPE_1 VAR_3 = channel . VAR_4 ( VAR_1 ) ; if ( this . logger . VAR_5 ( ) ) { <START> logger . debug ( STRING_1 + VAR_1 + STRING_2 + VAR_3 ) ; <END> } return VAR_3 . METHOD_2 ( ) ; } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( logger . VAR_2 ( ) ) { logger . debug ( STRING_1 + VAR_1 ) ; } try { ( ( TYPE_2 ) VAR_1 ) . close ( ) ; } catch ( IOException | TYPE_3 e ) { <START> logger . debug ( STRING_2 ) ; <END> } finally { VAR_3 . remove ( VAR_1 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 = VAR_1 . getProperty ( this . VAR_3 ) ; <END> Assert . VAR_4 ( this . VAR_2 , ( ) - > STRING_1 + this . VAR_3 + STRING_2 ) ; } 
public synchronized void METHOD_1 ( TYPE_3 . TYPE_4 . VAR_1 . TYPE_5 < TYPE_2 > VAR_3 ) { <START> if ( METHOD_2 ( ) == 0 ) { <END> VAR_3 . METHOD_3 ( this ) ; } else { this . VAR_4 = VAR_3 ; } } 
public String METHOD_1 ( final TYPE_1 VAR_1 ) { try { return this . VAR_2 . execute ( channel - > { TYPE_2 [ ] VAR_3 = METHOD_2 ( channel , VAR_1 ) ; String VAR_4 = VAR_3 . length > 0 ? VAR_3 [ 0 ] . METHOD_3 ( ) : null ; if ( StringUtils . VAR_5 ( VAR_4 ) ) { <START> VAR_1 . METHOD_4 ( VAR_4 ) ; <END> } return VAR_4 ; } ) ; } catch ( TYPE_3 e ) { METHOD_5 ( VAR_1 , STRING_1 , e ) ; return null ; } } 
public void METHOD_1 ( TYPE_1 ... VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; Assert . VAR_3 ( VAR_1 , STRING_2 ) ; if ( METHOD_2 ( ) ) { for ( TYPE_1 VAR_4 : VAR_1 ) { <START> Assert . VAR_5 ( StringUtils . VAR_6 ( VAR_4 . getName ( ) ) , STRING_3 ) ; <END> } } this . VAR_1 . addAll ( Arrays . asList ( VAR_1 ) ) ; } 
public void METHOD_1 ( String ... VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; METHOD_2 ( Arrays . stream ( VAR_1 ) . map ( n - > new TYPE_1 ( n ) ) . collect ( Collectors . VAR_3 ( ) ) <START> . METHOD_3 ( new TYPE_1 [ 0 ] ) ) ; <END> } 
public TYPE_1 [ ] METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
<START> private Object next ( ) { <END> if ( this . iterator == null || ! this . iterator . hasNext ( ) ) { this . iterator = this . VAR_1 . iterator ( ) ; } return this . iterator . next ( ) ; } 
public String METHOD_1 ( ) { if ( StringUtils . VAR_1 ( this . VAR_2 ) ) { return this . VAR_2 ; } else if ( ! StringUtils . VAR_1 ( this . VAR_3 ) ) { return STRING_1 ; } else { <START> return STRING_2 + this . VAR_3 + STRING_3 ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; TYPE_2 VAR_2 = TYPE_3 . bind ( VAR_3 ) . to ( VAR_1 ) ; assertEquals ( VAR_1 . getName ( ) , VAR_2 . METHOD_2 ( ) ) ; assertEquals ( "" , VAR_2 . METHOD_3 ( ) ) ; assertEquals ( TYPE_2 . TYPE_4 . VAR_5 , VAR_2 . METHOD_4 ( ) ) ; assertEquals ( VAR_3 . getName ( ) , VAR_2 . METHOD_5 ( ) ) ; <START> assertNotNull ( VAR_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> this . METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { for ( TYPE_1 VAR_1 : this . VAR_2 . values ( ) ) { <START> ( ( TYPE_2 ) VAR_1 ) . METHOD_1 ( ) ; <END> } if ( this . VAR_3 instanceof TYPE_2 ) { ( ( TYPE_2 ) this . VAR_3 ) . METHOD_1 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( new TYPE_2 . TYPE_4 ( ) ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 ) { Assert . VAR_3 ( VAR_2 , STRING_1 ) ; this . VAR_2 = VAR_2 ; this . container = null ; this . VAR_4 = null ; this . VAR_5 = new TYPE_2 ( this . VAR_2 . METHOD_1 ( ) ) ; <START> this . VAR_5 . METHOD_2 ( TYPE_4 . VAR_7 ) ; <END> this . VAR_5 . METHOD_3 ( this ) ; } 
public boolean METHOD_1 ( boolean VAR_1 ) { if ( this . VAR_2 != null ) { this . VAR_2 . METHOD_1 ( true ) ; } TYPE_1 . this . VAR_4 . remove ( this . VAR_5 ) ; if ( TYPE_2 . this . channel != null ) { <START> TYPE_1 . VAR_7 . VAR_8 . METHOD_2 ( TYPE_2 . VAR_7 . channel , false , <END> null ) ; } return super . METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 ... VAR_1 ) { try { METHOD_1 ( Arrays . stream ( VAR_1 ) . map ( TYPE_1 : : getName ) ) ; } catch ( TYPE_2 e ) { <START> throw new TYPE_2 ( STRING_1 + VAR_1 , e . VAR_2 ( ) ) ; <END> } super . METHOD_1 ( VAR_1 ) ; } 
private List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { return VAR_1 . stream ( ) <START> . map ( VAR_2 - > METHOD_2 ( VAR_2 ) ) <END> . collect ( Collectors . VAR_3 ( ) ) ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( ) ; METHOD_2 ( VAR_1 ) ; try { VAR_1 . METHOD_3 ( ) ; return VAR_1 . METHOD_4 ( ) ; } catch ( Exception e ) { <START> TYPE_3 . METHOD_5 ( STRING_1 ) . error ( STRING_2 , <END> e ) ; return null ; } } 
public void METHOD_1 ( ) { String VAR_1 = System . getProperty ( STRING_1 ) ; <START> System . out . println ( VAR_1 ) ; <END> TYPE_1 context = new TYPE_2 ( TYPE_3 . class , TYPE_4 . class ) ; METHOD_2 ( context ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 request ) throws Exception { TYPE_1 VAR_1 = request . VAR_2 ( ) . METHOD_1 ( ) ; <START> TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( ) ; <END> if ( VAR_1 == null && VAR_3 == null ) { throw new TYPE_3 ( STRING_1 + STRING_2 + STRING_3 ) ; } return VAR_1 == null ? VAR_3 : VAR_1 ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 request ) throws Exception { TYPE_1 VAR_1 ; <START> VAR_1 = TYPE_3 . METHOD_2 ( request ) ; <END> if ( VAR_1 == null ) { if ( this . VAR_2 == null ) { throw new TYPE_4 ( STRING_1 + STRING_2 + STRING_3 ) ; } VAR_1 = new TYPE_1 ( this . VAR_2 , this . VAR_3 ) ; } return VAR_1 ; } 
protected TYPE_1 METHOD_1 ( final String VAR_1 , final String VAR_2 , final TYPE_1 message ) { if ( ! this . VAR_3 ) { <START> METHOD_2 ( ) ; <END> } if ( this . VAR_4 == null || this . VAR_5 ) { return METHOD_3 ( VAR_1 , VAR_2 , message ) ; } else { return METHOD_4 ( VAR_1 , VAR_2 , message ) ; } } 
private void METHOD_1 ( ) throws Exception { if ( logger . VAR_1 ( ) ) { logger . debug ( STRING_1 + this . target ) ; } if ( this . target == null ) { return ; } try { <START> this . target . close ( ) ; <END> } catch ( TYPE_1 e ) { if ( logger . VAR_2 ( ) ) { logger . trace ( this . target + STRING_2 ) ; } } } 
protected int METHOD_1 ( ) { int count = 0 ; synchronized ( this . VAR_1 ) { if ( this . VAR_2 == null ) { this . VAR_2 = new HashMap < TYPE_1 , Boolean > ( this . VAR_3 ) ; VAR_4 . METHOD_2 ( ) ; <START> while ( this . VAR_2 . size ( ) < this . VAR_3 ) { <END> TYPE_1 VAR_5 = METHOD_3 ( ) ; this . VAR_2 . put ( VAR_5 , true ) ; count ++ ; } } } return count ; } 
public void METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <END> if ( VAR_1 . length > 1 ) { Assert . VAR_3 ( VAR_1 , STRING_2 ) ; } Collection < TYPE_1 > VAR_4 = new ArrayList < TYPE_1 > ( ) ; if ( VAR_1 . length > 0 && ! ( VAR_1 . length == 1 && VAR_1 [ 0 ] == null ) ) { VAR_4 . addAll ( Arrays . asList ( VAR_1 ) ) ; } this . VAR_4 = VAR_4 ; } 
protected void METHOD_1 ( Throwable ex ) { if ( this . VAR_1 != null ) { this . VAR_1 . METHOD_2 ( ex ) ; } else if ( logger . VAR_2 ( ) ) { logger . warn ( STRING_1 , ex ) ; } else if ( logger . VAR_2 ( ) ) { logger . warn ( STRING_2 + ex . getClass ( ) + STRING_3 + ex . getMessage ( ) ) ; <START> } <END> } 
public void METHOD_1 ( int VAR_1 , String message ) { LOGGER . info ( STRING_1 , connection , message ) ; if ( null != VAR_2 ) { VAR_2 . METHOD_1 ( VAR_1 , message , this . session ) ; } <START> if ( this . session != null ) { <END> this . session . close ( ) ; this . session = null ; } VAR_3 . METHOD_2 ( this ) ; VAR_4 . METHOD_2 ( this ) ; } 
public String METHOD_1 ( String VAR_1 ) { <START> System . out . println ( STRING_1 ) ; <END> TYPE_1 . VAR_3 = true ; return VAR_4 ; } 
public String METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String path ) { String VAR_1 = null ; try { VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; <START> } catch ( Exception e ) { <END> e . VAR_4 ( ) ; } return VAR_5 + VAR_1 ; } 
public boolean equals ( Object o ) { return o == this ; <START> } <END> 
public void run ( ) { try { if ( ! STRING_1 . equals ( METHOD_1 ( ) . getName ( ) ) ) { TYPE_1 . METHOD_2 ( METHOD_1 ( ) ) ; } METHOD_3 ( ) ; } catch ( Exception e ) { <START> LOG . error ( e , "" ) ; <END> throw new RuntimeException ( e ) ; } finally { if ( ! STRING_1 . equals ( METHOD_1 ( ) . getName ( ) ) ) { TYPE_1 . METHOD_4 ( METHOD_1 ( ) ) ; } } } 
public void METHOD_1 ( ) { VAR_1 = true ; if ( VAR_2 . METHOD_2 ( ) ) { VAR_3 = VAR_4 . METHOD_3 ( ) . iterator ( ) ; } else if ( VAR_2 . METHOD_4 ( ) ) { VAR_3 = Collections . VAR_5 ( ) ; } else { VAR_3 = TYPE_1 . filter ( VAR_4 . METHOD_3 ( ) . iterator ( ) , <START> entry - > entry != null && ! VAR_6 . contains ( entry . getKey ( ) ) <END> ) ; } METHOD_5 ( ) ; } 
public long size ( ) throws IOException { <START> METHOD_1 ( 0 ) ; <END> return VAR_1 ; } 
public TYPE_1 < T > run ( TYPE_2 < T > VAR_1 , TYPE_3 VAR_2 ) { if ( VAR_1 . METHOD_1 ( ) != query ) { throw new TYPE_4 ( STRING_1 ) ; } TYPE_1 < T > result = VAR_3 . run ( VAR_1 . METHOD_2 ( VAR_4 ) , VAR_2 ) ; <START> return result ; <END> } 
private < T > TYPE_1 < T > METHOD_1 ( TYPE_1 < T > query , TYPE_2 < TYPE_3 > VAR_1 ) { Set < TYPE_4 > VAR_2 = new HashSet < > ( ) ; for ( TYPE_3 s : VAR_1 ) { <START> VAR_2 . add ( new TYPE_4 ( null , s . getId ( ) . METHOD_2 ( ) ) ) ; <END> } return VAR_3 . METHOD_1 ( TYPE_5 . METHOD_3 ( query ) , VAR_2 ) ; } 
public Object get ( Object obj ) { <START> return super . get ( StringUtils . VAR_1 ( ( String ) obj ) ) ; <END> } 
<START> public void METHOD_1 ( ) <END> { List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( 10 , METHOD_3 ( count ) , VAR_2 ) ; METHOD_4 ( count , VAR_1 ) ; } 
<START> public static void METHOD_1 ( <END> final List < TYPE_1 > VAR_1 ) { List < String > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_2 . add ( VAR_3 . METHOD_2 ( ) ) ; } METHOD_3 ( VAR_2 ) ; } 
private String METHOD_1 ( String VAR_1 ) { final String VAR_2 = METHOD_2 ( VAR_1 ) ; <START> if ( TYPE_1 . METHOD_3 ( VAR_3 ) ) { <END> return VAR_2 ; } else { return StringUtils . format ( STRING_1 , METHOD_2 ( VAR_3 ) , VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( long offset ) throws IOException { try { return VAR_1 . METHOD_2 ( offset , VAR_2 , VAR_3 ) ; } catch ( TYPE_2 | TYPE_3 e ) { if ( TYPE_5 . TYPE_6 . apply ( e ) ) { throw new IOException ( STRING_1 , e ) ; } <START> log . warn ( STRING_2 , <END> VAR_2 , VAR_3 , e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } } 
public static Map < String , TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 ) { Map < String , TYPE_1 > result = VAR_1 . stream ( ) . collect ( Collectors . VAR_2 ( TYPE_2 : : METHOD_2 , Collectors . VAR_3 ( Collectors . VAR_4 ( ) , values - > values . get ( 0 ) ) ) ) ; if ( result . size ( ) != VAR_1 . size ( ) ) { <START> log . warn ( <END> STRING_1 ) ; } return result ; } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( <END> final String VAR_1 , final String VAR_2 , TYPE_3 VAR_3 , int VAR_4 ) throws TYPE_4 , TYPE_5 { TYPE_6 VAR_5 = VAR_6 . METHOD_2 ( VAR_1 ) ; return VAR_5 . METHOD_3 ( VAR_2 , VAR_7 , TYPE_7 . METHOD_4 ( TYPE_8 . class ) , VAR_4 , VAR_3 , null , null ) ; } 
TYPE_3 ( int VAR_2 , TYPE_1 < TYPE_2 > VAR_3 ) { this . VAR_3 = VAR_3 ; this . VAR_4 = new TYPE_2 [ VAR_2 ] ; <START> Arrays . VAR_5 ( VAR_4 , null ) ; <END> } 
<START> public void forEach ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 ) <END> { VAR_2 . forEach ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 , TYPE_3 config , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 , TYPE_7 VAR_6 , TYPE_8 VAR_7 , TYPE_9 VAR_8 , TYPE_10 VAR_9 , TYPE_11 VAR_10 , TYPE_12 VAR_11 , TYPE_13 VAR_12 , TYPE_14 cache , TYPE_15 VAR_13 , TYPE_16 VAR_14 ) { VAR_15 = TYPE_17 . METHOD_2 ( VAR_1 , VAR_2 , config , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , <START> TYPE_18 . VAR_17 , <END> cache , VAR_13 , VAR_14 ) ; return VAR_15 ; } 
public float METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( String VAR_1 ) throws Exception { String VAR_2 ; try { TYPE_1 is = TYPE_2 . class . METHOD_2 ( VAR_1 ) ; VAR_2 = TYPE_3 . toString ( is , TYPE_5 . VAR_4 ) ; } catch ( IOException e ) { throw new TYPE_4 ( e , STRING_1 , VAR_1 ) ; } VAR_2 = StringUtils . VAR_5 ( VAR_2 , STRING_2 , VAR_6 ) ; <START> VAR_7 . METHOD_3 ( VAR_2 , 5 ) ; <END> } 
public int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; <START> } <END> 
public TYPE_1 METHOD_1 ( ) throws IOException { final String VAR_1 = uri . VAR_2 ( ) ; final String key = TYPE_2 . METHOD_2 ( uri ) ; final TYPE_3 VAR_3 = new TYPE_3 ( VAR_4 , VAR_1 , key ) ; <START> return TYPE_4 . METHOD_3 ( VAR_3 . METHOD_4 ( ) , uri . toString ( ) ) ; <END> } 
<START> protected TYPE_1 METHOD_1 ( <END> TYPE_2 VAR_1 , TYPE_3 VAR_2 , ANNOTATION_1 File VAR_3 ) throws IOException { return new TYPE_4 ( VAR_1 , VAR_2 , METHOD_2 ( VAR_2 , null ) . map ( split - > new TYPE_5 ( VAR_4 , split . get ( ) ) ) , VAR_3 ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 , ANNOTATION_1 TYPE_4 VAR_2 ) throws IOException { if ( VAR_3 . METHOD_2 ( ) ) { return ( ( TYPE_5 ) VAR_3 ) . METHOD_3 ( VAR_2 ) ; } else { <START> throw new TYPE_6 ( ) ; <END> } } 
public List < TYPE_1 > METHOD_1 ( String line ) throws IOException , TYPE_2 { final Map < String , Object > VAR_1 = METHOD_2 ( line ) ; return Collections . VAR_2 ( <START> TYPE_3 . parse ( <END> METHOD_3 ( ) . METHOD_4 ( ) , METHOD_3 ( ) . METHOD_5 ( ) , VAR_1 ) ) ; } 
default TYPE_1 VAR_2 ( ) { <START> return new TYPE_2 ( iterator ( ) ) ; <END> } 
public TYPE_2 ( Map < String , Object > VAR_2 , TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = METHOD_1 ( ) ; <START> } <END> 
public TYPE_1 METHOD_1 ( ) throws IOException { if ( ! METHOD_2 ( ) ) { throw new TYPE_2 ( ) ; } if ( ! VAR_1 . isEmpty ( ) ) { <START> return VAR_1 . remove ( 0 ) ; <END> } return METHOD_3 ( ) ; } 
<START> public Map < String , TYPE_1 > METHOD_1 ( ) <END> { return TYPE_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 , input - > ! VAR_2 . containsKey ( input . getKey ( ) ) && ! VAR_3 . containsKey ( input . getKey ( ) ) && ! VAR_4 . containsKey ( input . getKey ( ) ) && input . getValue ( ) . METHOD_4 ( ) && input . getValue ( ) . METHOD_5 ( ) ) , ( String key , TYPE_3 value ) - > value . VAR_5 ( ) ) ; } 
protected Long METHOD_1 ( ) { long result = 0 ; for ( int i = 0 ; i < VAR_1 ; i += VAR_2 ) { if ( VAR_3 [ ( i + VAR_4 ) % VAR_1 ] != null ) { result += ( VAR_3 [ ( i + VAR_4 ) % VAR_1 ] ) . METHOD_2 ( ) ; } else { <START> result += FLOAT_1 ; <END> } } VAR_4 ++ ; return result ; } 
public byte [ ] METHOD_1 ( ) { return new TYPE_1 ( TYPE_2 . VAR_2 ) <START> . METHOD_2 ( name ) <END> . METHOD_3 ( field ) . build ( ) ; } 
public int METHOD_1 ( ) { int VAR_1 = VAR_2 ; VAR_2 ++ ; <START> return VAR_1 ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { try { VAR_1 . METHOD_2 ( ) ; } catch ( Throwable t ) { <START> log . warn ( t , STRING_1 ) ; <END> } finally { System . VAR_2 ( 1 ) ; } } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { VAR_3 . METHOD_2 ( VAR_1 , ( VAR_4 ) - > { return new ArrayList < > ( ) ; } ) ; <START> VAR_3 . get ( VAR_1 ) . add ( VAR_2 ) ; <END> } 
public HashSet < String > METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 . stream ( ) . map ( TYPE_2 : : METHOD_3 ) <START> . collect ( Collectors . VAR_2 ( ) ) <END> ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return TYPE_2 . METHOD_1 ( this , VAR_1 , VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { return TYPE_2 . METHOD_2 ( ) ; } else { <START> return ( VAR_2 , VAR_3 ) - > TYPE_3 . METHOD_3 ( <END> ( ( TYPE_4 ) VAR_2 ) . METHOD_4 ( ) , ( ( TYPE_4 ) VAR_3 ) . METHOD_4 ( ) ) ; } } 
public void METHOD_1 ( ) throws InterruptedException { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( 10 , TimeUnit . VAR_2 ) ; <START> VAR_1 = null ; <END> } VAR_3 . clear ( ) ; } 
public Set < TYPE_1 > METHOD_1 ( List < TYPE_1 > args ) { <START> return TYPE_2 . of ( args . get ( 1 ) , args . get ( 2 ) ) ; <END> } 
<START> public void METHOD_1 ( boolean VAR_1 ) <END> { this . VAR_1 = VAR_1 ; } 
<START> protected static String METHOD_1 ( String VAR_1 ) <END> { TYPE_1 TYPE_2 = TYPE_1 . METHOD_2 ( STRING_1 ) ; return TYPE_2 . matcher ( VAR_1 ) . METHOD_3 ( STRING_2 ) ; } 
<START> public boolean METHOD_1 ( ) <END> { return VAR_1 == null ^ VAR_2 == null ; } 
public byte [ ] METHOD_1 ( ) { return new TYPE_1 ( TYPE_2 . VAR_2 ) . METHOD_2 ( VAR_3 ) . METHOD_3 ( StringUtils . VAR_4 ( String . valueOf ( value ) ) ) . METHOD_4 ( VAR_5 . keySet ( ) ) <START> . METHOD_5 ( VAR_5 . values ( ) ) <END> . build ( ) ; } 
<START> protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) <END> { return METHOD_1 ( VAR_1 , 0 ) ; } 
private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) throws TYPE_3 { final TYPE_1 VAR_2 ; <START> synchronized ( VAR_3 ) { <END> try { VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; } catch ( TYPE_3 e ) { VAR_3 . METHOD_3 ( VAR_1 ) ; throw e ; } } if ( VAR_2 == null ) { throw new TYPE_3 ( STRING_1 , VAR_1 . METHOD_4 ( ) ) ; } return VAR_2 ; } 
static < T > T METHOD_1 ( List < T > list ) { <START> if ( list . size ( ) == 0 ) { <END> return null ; } return list . get ( TYPE_1 . METHOD_2 ( ) . METHOD_3 ( list . size ( ) ) ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 , boolean VAR_3 , TYPE_3 factory ) { TYPE_4 index = VAR_3 <START> ? VAR_2 <END> ? TYPE_5 . METHOD_2 ( ) : TYPE_5 . METHOD_3 ( ) : TYPE_5 . METHOD_4 ( ) ; return TYPE_6 . METHOD_5 ( factory , VAR_1 , new TYPE_7 ( index , VAR_1 ) , null ) ; } 
public static TYPE_1 METHOD_1 ( ) { synchronized ( log ) { if ( VAR_1 != null ) { return VAR_1 ; } <START> } <END> return VAR_1 = METHOD_2 ( STRING_1 , false , false ) ; } 
public Map < String , Object > METHOD_1 ( final TYPE_1 VAR_1 ) { Map < String , Object > VAR_2 = VAR_3 . METHOD_2 ( VAR_4 . get ( VAR_5 ) ) ; <START> for ( Map . Entry < String , Object > entry : VAR_2 . entrySet ( ) ) { <END> String s = entry . getKey ( ) ; VAR_1 . METHOD_3 ( VAR_2 . get ( s ) ) ; } VAR_5 = ( VAR_5 + 1 ) % VAR_6 ; return VAR_2 ; } 
public void METHOD_1 ( ) { System . out . println ( ) ; for ( Map < Object , Integer > VAR_1 : VAR_2 . values ( ) ) { <START> System . out . println ( STRING_1 + VAR_1 + STRING_2 ) ; <END> new TYPE_1 < > ( VAR_1 ) . forEach ( ( val , VAR_3 ) - > System . out . println ( STRING_3 + val + STRING_4 + VAR_3 ) ) ; } } 
<START> private static ANNOTATION_1 String METHOD_1 ( Map < TYPE_1 , String > VAR_1 , TYPE_1 VAR_2 ) <END> { return VAR_1 . entrySet ( ) . stream ( ) . filter ( entry - > entry . getKey ( ) . contains ( VAR_2 ) ) . map ( Entry : : getValue ) . METHOD_2 ( ) . METHOD_3 ( null ) ; } 
public synchronized void close ( ) { if ( VAR_1 ) { return ; } <START> VAR_1 = true ; <END> log . info ( STRING_1 ) ; TYPE_1 . METHOD_1 ( buffer , VAR_2 ) ; VAR_3 . METHOD_2 ( VAR_4 ) ; if ( VAR_5 != null ) { VAR_5 . METHOD_2 ( VAR_4 ) ; } Thread VAR_6 = this . VAR_6 ; if ( VAR_6 != null && ! VAR_6 . equals ( Thread . VAR_7 ( ) ) ) { VAR_6 . METHOD_3 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { synchronized ( VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_2 != null || VAR_3 != null , <START> STRING_1 ) ; <END> return VAR_3 != null ? VAR_3 . METHOD_1 ( ) : VAR_2 . METHOD_3 ( ) ; } } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , ANNOTATION_1 TYPE_3 VAR_4 ) { VAR_5 = new TYPE_4 ( <START> METHOD_1 ( VAR_2 ) , <END> VAR_3 , VAR_4 , STRING_1 , STRING_2 ) ; VAR_6 = new TYPE_4 ( METHOD_1 ( VAR_2 ) , VAR_3 , VAR_4 , STRING_3 , STRING_2 ) ; } 
public static TYPE_1 of ( String VAR_1 ) { try { <START> Integer VAR_2 = Integer . valueOf ( VAR_1 ) ; <END> return new TYPE_1 ( VAR_2 * INT_1 , TYPE_2 . METHOD_1 ( ) ) ; } catch ( TYPE_3 ex ) { try { return new TYPE_1 ( Long . valueOf ( VAR_1 ) , TYPE_2 . METHOD_1 ( ) ) ; } catch ( IllegalArgumentException VAR_3 ) { try { return new TYPE_1 ( VAR_1 , TYPE_2 . METHOD_1 ( ) ) ; } catch ( Exception VAR_4 ) { throw ex ; } } } } 
<START> protected void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 ) <END> { synchronized ( VAR_3 ) { TYPE_3 < TYPE_1 , TYPE_2 > VAR_4 = VAR_5 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , x - > new TYPE_3 < > ( VAR_6 ) ) ; if ( VAR_4 . put ( VAR_1 , VAR_2 ) == null ) { VAR_7 ++ ; } } } 
public void METHOD_1 ( Boolean VAR_1 ) { <START> this . VAR_1 = VAR_1 == null ? false : VAR_1 ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_2 . Builder builder = builder ( ) ; TYPE_3 . METHOD_2 ( builder , VAR_2 ) ; Optional < Long > VAR_3 = VAR_4 . METHOD_3 ( ) ; <START> VAR_3 . METHOD_4 ( ( value ) - > VAR_1 . METHOD_5 ( builder . build ( STRING_1 , value ) ) ) ; <END> } 
public int METHOD_1 ( ) { final TYPE_1 VAR_1 = this . VAR_1 ; <START> VAR_1 . METHOD_2 ( ) ; <END> try { return VAR_2 . size ( ) ; } finally { VAR_1 . METHOD_3 ( ) ; } } 
<START> public synchronized void close ( ) <END> { } 
public TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( ) { @Override public Class < ? > METHOD_2 ( ) { return TYPE_2 . class ; } @Override public Object METHOD_3 ( final TYPE_3 VAR_1 , final String VAR_2 ) { Object VAR_3 = VAR_1 . METHOD_4 ( VAR_2 ) ; <START> if ( VAR_3 instanceof TYPE_2 ) { <END> return ( TYPE_2 ) VAR_3 ; } else { throw new TYPE_4 ( STRING_1 ) ; } } } ; } 
public void METHOD_1 ( TYPE_1 binder ) { String VAR_1 = TYPE_4 . VAR_3 ; <START> if ( TYPE_2 . METHOD_2 ( VAR_1 ) == null ) { <END> TYPE_2 . METHOD_3 ( VAR_1 , new TYPE_3 ( ) ) ; } } 
public TYPE_1 METHOD_1 ( ByteBuffer buffer , int VAR_1 ) { if ( VAR_1 == 0 ) { <START> return VAR_2 ; <END> } buffer . VAR_3 ( buffer . position ( ) + VAR_1 ) ; return TYPE_1 . METHOD_2 ( buffer ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; try { final ImmutableList . Builder < TYPE_1 > VAR_2 = ImmutableList . builder ( ) ; for ( final TYPE_2 VAR_3 : VAR_4 . values ( ) ) { <START> if ( VAR_3 . getStatus ( ) . METHOD_3 ( ) && VAR_3 . METHOD_4 ( ) != null ) { <END> VAR_2 . add ( VAR_3 . METHOD_4 ( ) ) ; } } return VAR_2 . build ( ) ; } finally { VAR_1 . METHOD_5 ( ) ; } } 
public Set < TYPE_1 < Integer > > METHOD_1 ( ) { Set < TYPE_2 > VAR_1 = VAR_2 . METHOD_2 ( ) ; return VAR_1 . stream ( ) <START> . map ( ( TYPE_2 e ) - > new TYPE_1 < > ( e . VAR_3 ( ) , e . VAR_4 ( ) ) ) <END> . collect ( Collectors . VAR_5 ( ) ) ; } 
public void close ( ) { if ( this . VAR_1 ) { return ; } METHOD_1 ( TYPE_1 . of ( ) ) ; VAR_2 . METHOD_2 ( ) ; try { if ( ! VAR_2 . METHOD_3 ( VAR_3 , TimeUnit . VAR_4 ) ) { VAR_2 . METHOD_4 ( ) ; } } catch ( InterruptedException e ) { <START> log . info ( e , STRING_1 ) ; <END> } this . VAR_1 = true ; } 
private TYPE_8 ( ANNOTATION_1 String VAR_2 , boolean VAR_3 ) { super ( VAR_2 , VAR_3 ) ; if ( TYPE_5 . TYPE_4 . equals ( VAR_2 ) || TYPE_6 . TYPE_7 . equals ( VAR_2 ) ) { VAR_4 = true ; this . VAR_5 = null ; } else { VAR_4 = false ; <START> this . VAR_5 = new TYPE_3 ( VAR_2 ) ; <END> } } 
public void close ( ) { if ( this . VAR_1 ) { return ; } METHOD_1 ( TYPE_1 . of ( ) ) ; VAR_2 . METHOD_2 ( ) ; try { if ( ! VAR_2 . METHOD_3 ( VAR_3 , TimeUnit . VAR_4 ) ) { VAR_2 . METHOD_4 ( ) ; } } catch ( InterruptedException e ) { <START> log . warn ( e , STRING_1 ) ; <END> } this . VAR_1 = true ; } 
private void METHOD_1 ( long VAR_1 ) { if ( VAR_2 && ! VAR_3 ) { try { VAR_4 . METHOD_2 ( METHOD_3 ( ) , VAR_1 , TimeUnit . VAR_5 ) ; } catch ( TYPE_1 e ) { <START> log . warn ( <END> STRING_1 + STRING_2 , VAR_6 . METHOD_4 ( ) ) ; } } else { log . info ( STRING_3 , VAR_6 . METHOD_4 ( ) ) ; } } 
<START> public String METHOD_1 ( ) <END> { return id ; } 
<START> public void METHOD_1 ( ) throws Exception <END> { List < String > VAR_1 = VAR_2 . METHOD_2 ( ) ; assertEquals ( 1 , VAR_1 . size ( ) ) ; assertEquals ( STRING_1 , VAR_1 . get ( 0 ) ) ; } 
protected TYPE_1 [ ] METHOD_1 ( ) { <START> return ( TYPE_1 [ ] ) VAR_1 ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || o . getClass ( ) != getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; if ( ! TYPE_2 . equals ( VAR_1 , that . VAR_1 ) ) { return false ; } <START> if ( ! TYPE_2 . equals ( VAR_2 , that . VAR_2 ) ) { <END> return false ; } return TYPE_2 . equals ( VAR_3 , that . VAR_3 ) ; } 
public Object METHOD_1 ( Object object ) { try { if ( object instanceof ByteBuffer ) { return TYPE_1 . METHOD_2 ( ( ByteBuffer ) object ) ; } else if ( object instanceof byte [ ] ) { return TYPE_1 . METHOD_2 ( ByteBuffer . VAR_1 ( ( byte [ ] ) object ) ) ; } else { return object ; } } catch ( IOException VAR_2 ) { <START> throw new RuntimeException ( STRING_1 ) ; <END> } } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_2 ( ) ; Assert . assertEquals ( VAR_2 , VAR_1 . METHOD_2 ( TYPE_3 . class ) . METHOD_3 ( VAR_1 . METHOD_4 ( VAR_2 ) ) ) ; <START> Assert . assertTrue ( VAR_2 . METHOD_5 ( ) == VAR_1 . METHOD_2 ( TYPE_3 . class ) . METHOD_3 ( VAR_1 . METHOD_4 ( VAR_2 ) ) . METHOD_5 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( <START> new TYPE_3 ( STRING_1 , STRING_2 , null , null ) , <END> new TYPE_4 ( null , null , null ) , null , null ) ; return VAR_1 . METHOD_2 ( ) ; } 
public boolean METHOD_1 ( final Object o ) { <START> if ( o instanceof List ) { <END> return true ; } return false ; } 
public boolean METHOD_1 ( final Object o ) { <START> if ( o instanceof Map ) { <END> return true ; } else { return o instanceof TYPE_1 ; } } 
public String toString ( ) { return STRING_1 + <START> STRING_2 + TYPE_1 . METHOD_1 ( VAR_1 ) + CHAR_1 + <END> CHAR_2 ; } 
public TYPE_3 ( ANNOTATION_1 ( STRING_1 ) String VAR_2 , ANNOTATION_1 ( STRING_2 ) Set < String > VAR_3 , ANNOTATION_1 ( STRING_3 ) Set < String > VAR_4 ) { this . VAR_3 = TYPE_1 . METHOD_1 ( VAR_3 , STRING_4 ) ; this . VAR_4 = TYPE_1 . METHOD_1 ( VAR_4 , STRING_5 ) ; TYPE_1 . METHOD_2 ( ! TYPE_2 . METHOD_3 ( VAR_2 ) , STRING_6 ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
public void METHOD_1 ( TYPE_1 query ) { <START> METHOD_2 ( STRING_1 , toString ( ) . valueOf ( query . VAR_1 ( ) ) ) ; <END> } 
public TYPE_2 ( ANNOTATION_1 ( STRING_1 ) String name , ANNOTATION_1 ( STRING_2 ) String VAR_2 , ANNOTATION_1 ( STRING_3 ) String VAR_3 ) { this . name = name ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 == null ? VAR_4 : VAR_3 ; <START> this . VAR_5 = new TYPE_1 ( <END> this . VAR_3 , this . VAR_2 , this . name , null ) ; } 
public TYPE_1 add ( TYPE_2 row , String VAR_1 ) throws IOException { <START> return append ( row , VAR_1 , null , true , true ) ; <END> } 
public static long METHOD_1 ( final long VAR_1 ) { long VAR_2 = VAR_1 ; if ( VAR_1 == 0 ) { VAR_2 = TYPE_1 . VAR_4 ; <START> } else if ( VAR_1 == - 1 ) { <END> VAR_2 = Long . VAR_5 ; } return VAR_2 ; } 
public Map < String , Object > METHOD_1 ( ) { try { return METHOD_2 ( ) ; } catch ( InterruptedException VAR_1 ) { Thread . VAR_2 ( ) . METHOD_3 ( ) ; <START> log . error ( STRING_1 ) ; <END> throw new RuntimeException ( VAR_1 ) ; } catch ( TYPE_1 | TYPE_2 VAR_3 ) { throw new RuntimeException ( VAR_3 ) ; } } 
public TYPE_1 METHOD_1 ( final Object VAR_1 , final Object VAR_2 ) { final TYPE_2 VAR_3 = new TYPE_2 ( VAR_4 ) ; VAR_3 . update ( ( TYPE_1 ) VAR_1 ) ; <START> VAR_3 . update ( ( TYPE_1 ) VAR_1 ) ; <END> return VAR_3 . METHOD_2 ( VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 , null ) ; <END> } 
public void close ( ) { Throwable VAR_1 = null ; for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 == null ) { continue ; } try { TYPE_2 . METHOD_1 ( VAR_2 ) ; } catch ( Throwable t ) { if ( VAR_1 == null ) { VAR_1 = t ; } else { VAR_1 . METHOD_2 ( t ) ; } } } VAR_3 . clear ( ) ; <START> TYPE_3 . METHOD_3 ( VAR_1 ) ; <END> } 
public List < TYPE_1 < T > > METHOD_1 ( final int VAR_1 ) { METHOD_2 ( ) ; try { <START> return METHOD_3 ( VAR_1 ) . stream ( ) . map ( this : : METHOD_4 ) . collect ( Collectors . VAR_2 ( ) ) ; <END> } catch ( InterruptedException e ) { throw TYPE_2 . METHOD_5 ( e ) ; } } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { final TYPE_2 VAR_4 = new TYPE_2 ( VAR_1 , VAR_3 ) ; <START> return VAR_4 . METHOD_2 ( VAR_2 ) ; <END> } 
TYPE_4 ( TYPE_1 VAR_2 , boolean VAR_3 , boolean VAR_4 , boolean VAR_5 , boolean VAR_6 , int VAR_7 , long VAR_8 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; this . VAR_7 = VAR_7 ; <START> this . VAR_8 = VAR_8 == 0 ? VAR_9 : VAR_8 ; <END> this . VAR_10 = VAR_2 . METHOD_1 ( ) ? new TYPE_2 ( VAR_6 , METHOD_2 ( ) , METHOD_3 ( ) ) : new TYPE_3 ( VAR_6 ) ; if ( VAR_8 != - 1 ) { VAR_11 = METHOD_4 ( VAR_2 ) ; } } 
TYPE_4 ( TYPE_1 VAR_2 , boolean VAR_3 , boolean VAR_4 , boolean VAR_5 , boolean VAR_6 , int VAR_7 , long VAR_8 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; this . VAR_7 = VAR_7 ; this . VAR_8 = VAR_8 == 0 ? VAR_9 : VAR_8 ; this . VAR_10 = VAR_2 . METHOD_1 ( ) ? new TYPE_2 ( VAR_6 , METHOD_2 ( ) , METHOD_3 ( ) ) : new TYPE_3 ( VAR_6 ) ; <START> VAR_11 = METHOD_4 ( VAR_2 ) ; <END> } 
public TYPE_2 ( ANNOTATION_1 ( STRING_1 ) String VAR_2 , ANNOTATION_1 ( STRING_2 ) Set < String > VAR_3 , ANNOTATION_1 ( STRING_3 ) Set < String > VAR_4 ) { TYPE_1 . METHOD_1 ( VAR_2 , STRING_4 ) ; TYPE_1 . METHOD_1 ( VAR_3 , STRING_5 ) ; TYPE_1 . METHOD_1 ( VAR_4 , STRING_6 ) ; <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( getClass ( ) != VAR_1 . getClass ( ) ) { return false ; } TYPE_2 that = ( TYPE_2 ) VAR_1 ; if ( ! VAR_2 . equals ( that . VAR_3 ( ) ) || ! VAR_4 . equals ( that . VAR_5 ( ) ) ) { return false ; } return VAR_6 . equals ( that . VAR_7 ( ) ) ; <START> } <END> 
private boolean METHOD_1 ( TYPE_1 target , TYPE_1 VAR_1 ) { <START> if ( ( target . VAR_2 ( ) + VAR_3 ) > VAR_1 . METHOD_2 ( ) ) { <END> return false ; } else { return true ; } } 
public TYPE_1 < T > METHOD_1 ( TYPE_2 VAR_1 ) { <START> return METHOD_2 ( ) . METHOD_3 ( this , VAR_1 ) ; <END> } 
private TYPE_3 ( ANNOTATION_1 TYPE_1 value ) { <START> super ( value == null ? TYPE_2 . METHOD_1 ( ) : value ) ; <END> } 
public Object METHOD_1 ( ANNOTATION_1 Object object ) { <START> return object == null ? object : ( ( TYPE_1 < Long , TYPE_2 > ) object ) . VAR_1 ; <END> } 
public boolean METHOD_1 ( TYPE_1 row ) { Object VAR_1 = row . VAR_2 ( VAR_3 ) ; if ( VAR_1 == null || value == null ) { return VAR_1 == null && value == null ; } <START> return TYPE_2 . METHOD_2 ( row , VAR_3 , value , VAR_4 ) == 0 ; <END> } 
public boolean hasNext ( ) { METHOD_1 ( ) ; if ( VAR_1 . METHOD_2 ( ) ) { return false ; } <START> if ( VAR_1 . METHOD_3 ( ) == TYPE_2 . VAR_3 ) { <END> TYPE_1 . close ( VAR_1 ) ; return false ; } return true ; } 
protected long METHOD_1 ( T object , File VAR_1 ) throws IOException { try { VAR_2 . METHOD_2 ( object , VAR_1 ) ; } <START> catch ( Exception e ) { <END> throw new RuntimeException ( e ) ; } return VAR_1 . length ( ) ; } 
public < T > T METHOD_1 ( TYPE_1 < T > VAR_1 , TYPE_2 < Throwable > VAR_2 ) { try { return TYPE_3 . METHOD_2 ( ( ) - > METHOD_3 ( ) . METHOD_4 ( VAR_1 ) , VAR_2 , VAR_3 ) ; } catch ( Exception e ) { <START> throw TYPE_4 . METHOD_5 ( e ) ; <END> } } 
<START> TYPE_1 METHOD_1 ( ) <END> { if ( VAR_1 != null ) { VAR_1 = null ; } final TYPE_1 iterator = VAR_2 . next ( ) ; return iterator ; } 
<START> public static native int METHOD_1 ( int VAR_1 , long offset , long VAR_2 , int VAR_3 ) throws TYPE_1 ; <END> private TYPE_2 ( ) { } 
private static TYPE_1 METHOD_1 ( Class VAR_1 , String VAR_2 ) { TYPE_1 field = null ; try { field = VAR_1 . METHOD_2 ( VAR_2 ) ; field . VAR_3 ( true ) ; } catch ( Exception e ) { <START> log . error ( STRING_1 , VAR_2 , VAR_1 . getName ( ) ) ; <END> } return field ; } 
public int METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 text , int VAR_2 ) { final String VAR_3 = config . get ( STRING_1 ) ; <START> if ( ( VAR_3 != null && VAR_3 . equals ( STRING_2 ) ) || VAR_4 ) { <END> return 0 ; } else { return VAR_5 . get ( VAR_1 ) ; } } 
private void METHOD_1 ( ) { for ( String VAR_1 : VAR_2 ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { continue ; <START> } <END> TYPE_2 VAR_3 = METHOD_3 ( VAR_1 ) . METHOD_4 ( ) ; TYPE_3 VAR_4 = TYPE_4 . METHOD_5 ( VAR_1 , VAR_3 , null ) ; VAR_5 . put ( VAR_1 , VAR_4 ) ; } } 
public TYPE_1 METHOD_1 ( ByteBuffer buffer , int VAR_1 ) { <START> if ( VAR_1 == 0 ) { <END> return null ; } buffer . VAR_2 ( buffer . position ( ) + VAR_1 ) ; return new TYPE_2 ( new TYPE_3 ( buffer ) ) ; } 
public TYPE_1 get ( ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> return new TYPE_2 ( column . get ( ) ) ; } else { return new TYPE_3 ( column . get ( ) , VAR_1 ) ; } } 
public final int METHOD_1 ( ) { <START> assert TYPE_1 . METHOD_2 ( ) || ! METHOD_3 ( ) ; <END> return value . VAR_1 ( ) ; } 
public final int METHOD_1 ( ) { if ( value == null ) { <START> assert TYPE_1 . METHOD_2 ( ) ; <END> return 0 ; } final Integer VAR_1 = TYPE_2 . METHOD_3 ( value ) ; return VAR_1 == null ? 0 : VAR_1 ; } 
public final double METHOD_1 ( ) { if ( value == null ) { assert TYPE_1 . METHOD_2 ( ) ; <START> return FLOAT_1 ; <END> } final Double VAR_1 = TYPE_2 . METHOD_3 ( value ) ; return VAR_1 == null ? FLOAT_1 : VAR_1 ; } 
<START> protected TYPE_2 ( final TYPE_1 column ) <END> { this . column = column ; } 
public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) == null ; <END> } 
private boolean METHOD_1 ( Throwable t ) { <START> return ( t instanceof TYPE_1 && ( t . getMessage ( ) . contains ( STRING_1 ) ) ) || <END> ( t . VAR_1 ( ) != null && METHOD_1 ( t . VAR_1 ( ) ) ) ; } 
public < T > T METHOD_1 ( final TYPE_1 < T > VAR_1 , final int VAR_2 , final int VAR_3 ) { try { <START> return TYPE_2 . METHOD_2 ( ( ) - > METHOD_3 ( ) . METHOD_4 ( VAR_1 ) , VAR_4 , VAR_2 , VAR_3 , null , null ) ; <END> } catch ( Exception e ) { throw TYPE_3 . METHOD_5 ( e ) ; } } 
public TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( ) { @Override public Class < ? > METHOD_2 ( ) { <START> return TYPE_2 . class ; <END> } @Override public Object METHOD_3 ( final TYPE_3 VAR_1 , final String VAR_2 ) { final Object object = VAR_1 . METHOD_4 ( VAR_2 ) ; if ( object == null || object instanceof TYPE_2 || object instanceof TYPE_4 ) { return object ; } return TYPE_5 . METHOD_5 ( object ) ; } } ; } 
public boolean equals ( final Object o ) { if ( ! super . equals ( o ) ) { return false ; } <START> final TYPE_1 that = ( TYPE_1 ) o ; <END> return VAR_1 . equals ( that . VAR_1 ) ; } 
public TYPE_4 ( final TYPE_1 VAR_2 , final List < TYPE_2 > VAR_3 , final int VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 . METHOD_1 ( new TYPE_2 [ VAR_3 . size ( ) ] ) ; <END> values = new double [ VAR_3 . size ( ) ] ; VAR_5 = new TYPE_3 ( ) . METHOD_2 ( VAR_4 ) . METHOD_3 ( VAR_3 . size ( ) ) . build ( ) ; } 
<START> public synchronized void METHOD_1 ( ) <END> { final TYPE_1 update = VAR_1 . METHOD_2 ( ) ; if ( update == null ) { return ; } VAR_2 . update ( update ) ; } 
public static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { if ( METHOD_2 ( VAR_1 ) ) { return VAR_1 . getInstance ( TYPE_3 . class ) ; } else { <START> return VAR_1 . getInstance ( TYPE_4 . class ) ; <END> } } 
public TYPE_5 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; try { this . VAR_3 = TYPE_2 . METHOD_1 ( VAR_2 . METHOD_2 ( ) . getName ( ) ) ; } catch ( TYPE_3 VAR_4 ) { <START> throw new TYPE_4 ( <END> STRING_1 , VAR_2 . METHOD_2 ( ) . getName ( ) ) ; } } 
public static byte [ ] METHOD_1 ( TYPE_1 VAR_1 , Map < String , TYPE_2 > VAR_2 ) { try { return VAR_1 . METHOD_2 ( VAR_2 ) ; } catch ( IOException VAR_3 ) { <START> throw new TYPE_3 ( STRING_1 ) ; <END> } } 
<START> private void METHOD_1 ( String VAR_1 , byte [ ] VAR_2 ) throws Exception <END> { File VAR_3 = new File ( VAR_4 . METHOD_2 ( ) ) ; VAR_3 . METHOD_3 ( ) ; File VAR_5 = new File ( VAR_4 . METHOD_2 ( ) , METHOD_4 ( VAR_1 ) ) ; TYPE_1 . write ( VAR_2 , VAR_5 ) ; } 
<START> private Map < String , TYPE_1 > METHOD_1 ( String VAR_1 ) throws Exception <END> { File VAR_2 = new File ( VAR_3 . METHOD_2 ( ) , METHOD_3 ( VAR_1 ) ) ; if ( ! VAR_2 . exists ( ) ) { return null ; } return VAR_4 . METHOD_4 ( VAR_2 , TYPE_2 . VAR_6 ) ; } 
<START> private TYPE_1 METHOD_1 ( String VAR_1 ) throws Exception <END> { File VAR_2 = new File ( VAR_3 . METHOD_2 ( ) , METHOD_3 ( VAR_1 ) ) ; if ( ! VAR_2 . exists ( ) ) { return null ; } return VAR_4 . METHOD_4 ( VAR_2 , TYPE_2 . VAR_6 ) ; } 
public Optional < String > METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 query ) { final int VAR_2 = TYPE_3 . METHOD_2 ( query ) ; if ( VAR_2 < VAR_3 ) { return Optional . of ( <START> VAR_1 . METHOD_3 ( ) <END> ) ; } else if ( VAR_2 >= VAR_4 ) { return Optional . of ( VAR_1 . METHOD_3 ( ) ) ; } return Optional . VAR_5 ( ) ; } 
private String METHOD_1 ( final byte [ ] VAR_1 ) { if ( VAR_1 == null ) { return null ; } <START> log . info ( STRING_1 , query . getId ( ) ) ; <END> int VAR_2 = ByteBuffer . VAR_3 ( VAR_1 , 0 , Integer . VAR_4 ) . getInt ( ) ; return StringUtils . VAR_5 ( Arrays . VAR_6 ( VAR_1 , Integer . VAR_4 , VAR_2 + Integer . VAR_4 ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( VAR_1 . getName ( ) . equals ( this . getName ( ) ) && VAR_1 instanceof TYPE_3 ) { <START> return new TYPE_4 ( name , VAR_2 ) ; <END> } else { throw new TYPE_2 ( this , VAR_1 ) ; } } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 , <START> TYPE_1 . VAR_2 , <END> ImmutableList . of ( ) , ImmutableList . of ( ) ) ; } 
private static String METHOD_1 ( Map < String , Object > VAR_1 ) throws IOException { Object VAR_2 = VAR_1 . get ( STRING_1 ) ; if ( VAR_2 == null ) { throw new TYPE_1 ( STRING_2 ) ; } if ( ! ( VAR_2 instanceof String ) ) { throw new TYPE_1 ( STRING_3 ) ; } <START> return ( String ) VAR_1 . get ( STRING_1 ) ; <END> } 
private static String METHOD_1 ( String VAR_1 ) { if ( VAR_1 . isEmpty ( ) ) { return VAR_1 ; } if ( VAR_1 . METHOD_2 ( 0 ) == CHAR_1 ) { <START> if ( VAR_1 . length ( ) > 1 ) { <END> char VAR_2 = VAR_1 . METHOD_2 ( 1 ) ; if ( VAR_2 >= CHAR_2 && VAR_2 <= CHAR_3 ) { VAR_1 = VAR_1 . substring ( 1 ) ; } } } return VAR_1 ; } 
public TYPE_5 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_2 ) TYPE_2 VAR_3 , ANNOTATION_1 ( STRING_3 ) String VAR_4 , ANNOTATION_2 TYPE_3 config ) { super ( VAR_2 , VAR_3 ) ; <START> TYPE_4 . METHOD_1 ( config . VAR_5 ( ) , STRING_4 ) ; <END> this . VAR_4 = VAR_4 ; this . config = config ; } 
public void METHOD_1 ( int VAR_1 , TYPE_1 p ) { if ( VAR_1 == 0 ) { TYPE_2 . METHOD_2 ( p instanceof TYPE_3 , STRING_1 , p . getClass ( ) . METHOD_3 ( ) ) ; <START> this . VAR_2 = ( TYPE_3 < ? > ) p ; <END> } else if ( VAR_1 == 1 ) { this . VAR_3 = p ; } else { throw new TYPE_4 ( StringUtils . format ( STRING_2 , VAR_1 ) ) ; } } 
private List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; <END> if ( VAR_2 . METHOD_2 ( ) ) { String VAR_3 = VAR_4 . METHOD_3 ( ) ; VAR_1 = METHOD_4 ( VAR_3 ) ; if ( VAR_1 == null ) { LOG . info ( STRING_1 ) ; VAR_1 = METHOD_5 ( ) ; } } else { VAR_1 = METHOD_5 ( ) ; } return VAR_1 ; } 
<START> public boolean METHOD_1 ( int [ ] row , TYPE_1 < String > VAR_1 ) <END> { if ( row == null ) { return true ; } for ( int i : row ) { if ( VAR_1 . get ( i ) != null ) { return false ; } } return true ; } 
public static String METHOD_1 ( final ByteBuffer buffer , final int VAR_1 ) { final byte [ ] VAR_2 = new byte [ VAR_1 ] ; buffer . get ( VAR_2 ) ; <START> return StringUtils . VAR_3 ( VAR_2 ) ; <END> } 
public static String METHOD_1 ( final ByteBuffer buffer , final int VAR_1 ) { final byte [ ] VAR_2 = new byte [ VAR_1 ] ; buffer . get ( VAR_2 ) ; <START> return StringUtils . VAR_3 ( VAR_2 ) ; <END> } 
private boolean METHOD_1 ( int index ) { if ( VAR_1 == VAR_2 ) { String value = VAR_3 . METHOD_2 ( index ) ; if ( value == null ) { VAR_1 = index ; return false ; <START> } <END> } return index != VAR_1 ; } 
<START> final public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <END> { Pair < TYPE_1 , TYPE_3 > VAR_2 = METHOD_2 ( VAR_1 ) ; return TYPE_4 . METHOD_3 ( ) ? VAR_2 . VAR_3 : new TYPE_5 ( VAR_2 . VAR_3 , VAR_2 . VAR_4 ) ; } 
private int METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { final TYPE_2 < TYPE_1 > VAR_2 = TYPE_3 . METHOD_2 ( config ) ; final int VAR_3 = TYPE_4 . filter ( VAR_1 , VAR_2 ) . size ( ) ; <START> log . info ( STRING_1 , VAR_3 ) ; <END> return VAR_3 ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 || ( VAR_2 && VAR_3 ) ; <END> } 
public void METHOD_1 ( ) { if ( ! VAR_1 ) { throw new TYPE_1 ( STRING_1 ) ; } if ( VAR_2 ) { throw new TYPE_1 ( STRING_2 ) ; } <START> for ( TYPE_2 < TYPE_3 > VAR_3 : VAR_4 ) { <END> VAR_3 . METHOD_1 ( ) ; } } 
public void close ( ) { try { VAR_1 . close ( ) ; } catch ( IOException e ) { <START> throw TYPE_1 . METHOD_1 ( e ) ; <END> } } 
private String METHOD_1 ( String table , String filter , String VAR_1 , String VAR_2 ) { <START> String query ; <END> if ( TYPE_1 . METHOD_2 ( filter ) ) { query = StringUtils . format ( STRING_1 , VAR_1 , VAR_2 , table ) ; } else { query = StringUtils . format ( STRING_2 , VAR_1 , VAR_2 , table , filter ) ; } return query ; } 
public String toString ( ) { <START> return StringUtils . VAR_1 ( <END> STRING_1 , getMessage ( ) , VAR_2 , VAR_3 , host ) ; } 
public void METHOD_1 ( TYPE_1 job ) { TYPE_2 conf = job . VAR_1 ( ) ; for ( final Map . Entry < String , String > entry : VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . entrySet ( ) ) { conf . set ( entry . getKey ( ) , entry . getValue ( ) ) ; } <START> } <END> 
public boolean METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 VAR_3 = VAR_4 . get ( VAR_1 ) ; <START> if ( VAR_3 != null ) { <END> return VAR_3 . VAR_5 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) != null ; } else { return false ; } } 
public String apply ( ANNOTATION_1 Object value ) { <START> if ( TYPE_1 . METHOD_1 ( value ) ) { <END> return null ; } if ( value instanceof TYPE_2 ) { return METHOD_2 ( ( ( TYPE_2 ) value ) . METHOD_3 ( ) ) ; } else if ( value instanceof String ) { return apply ( ( String ) value ) ; } return null ; } 
public String apply ( ANNOTATION_1 String value ) { <START> try { <END> return METHOD_1 ( Double . VAR_1 ( value ) ) ; } catch ( TYPE_1 | TYPE_2 ex ) { return null ; } } 
static int METHOD_1 ( int VAR_1 , TYPE_1 [ ] VAR_2 ) { final int VAR_3 = VAR_1 + 1 ; final int VAR_4 = Arrays . stream ( VAR_2 ) . METHOD_2 ( TYPE_1 : : METHOD_3 ) . METHOD_4 ( ) ; <START> return Integer . VAR_5 + <END> METHOD_5 ( VAR_3 ) + VAR_3 * VAR_4 ; } 
private static TYPE_1 METHOD_1 ( final Map < String , TYPE_1 > VAR_1 ) { return VAR_1 . values ( ) . stream ( ) . METHOD_2 ( TYPE_2 . METHOD_3 ( TYPE_1 : : METHOD_4 ) . METHOD_5 ( ) <START> ) . METHOD_6 ( null ) ; <END> } 
public int METHOD_1 ( ) { <START> return TYPE_1 . VAR_2 ; <END> } 
public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 TYPE_1 VAR_2 ) { <START> return TYPE_2 . equals ( TYPE_3 . METHOD_2 ( VAR_1 ) , TYPE_3 . METHOD_2 ( VAR_2 ) ) ; <END> } 
public int METHOD_1 ( ANNOTATION_1 TYPE_1 key ) { <START> return TYPE_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( key ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { <START> HashMap < String , Object > context = TYPE_2 . METHOD_2 ( ) ; <END> final TYPE_3 < TYPE_4 > VAR_2 = TYPE_5 . METHOD_3 ( VAR_3 ) . run ( VAR_4 , context ) ; final ArrayList < TYPE_4 > VAR_5 = TYPE_6 . METHOD_4 ( VAR_2 , TYPE_7 < TYPE_4 > METHOD_5 ( ) ) ; for ( TYPE_4 row : VAR_5 ) { VAR_1 . METHOD_6 ( row ) ; } } 
protected TYPE_1 METHOD_1 ( final double x , final double y ) { <START> return TYPE_1 . of ( ( long ) x / ( long ) y ) ; <END> } 
<START> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) <END> { for ( TYPE_2 . TYPE_4 field : VAR_1 . METHOD_2 ( ) ) { if ( field . name ( ) . equals ( VAR_2 ) ) { this . VAR_3 = field . VAR_1 ( ) . METHOD_3 ( ) ; return this . VAR_3 ; } } return null ; } 
public void METHOD_1 ( ) throws IOException { writer = TYPE_1 . METHOD_2 ( VAR_1 , <START> StringUtils . VAR_2 ( STRING_1 , VAR_3 ) , <END> VAR_4 , VAR_5 ) ; writer . VAR_6 ( ) ; } 
public static File METHOD_1 ( File VAR_1 , String VAR_2 ) { <START> return new File ( VAR_1 , StringUtils . VAR_3 ( STRING_1 , VAR_2 ) ) ; <END> } 
public static File METHOD_1 ( File VAR_1 , TYPE_1 VAR_2 ) { <START> return new File ( VAR_1 , StringUtils . VAR_3 ( STRING_1 , VAR_2 ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { writer = TYPE_1 . METHOD_2 ( VAR_1 , <START> StringUtils . VAR_2 ( STRING_1 , VAR_3 ) , <END> VAR_4 , VAR_5 , VAR_6 ) ; writer . VAR_7 ( ) ; } 
private String METHOD_1 ( String VAR_1 ) { <START> return StringUtils . VAR_2 ( STRING_1 , VAR_3 , VAR_1 ) ; <END> } 
public void METHOD_1 ( int index , long [ ] VAR_1 ) { if ( VAR_2 - index < VAR_1 . length ) { throw new TYPE_1 ( <START> StringUtils . VAR_3 ( <END> STRING_1 , VAR_1 . length , index , VAR_2 ) ) ; } for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { VAR_1 [ i ] = get ( index + i ) ; } } 
public static String METHOD_1 ( String VAR_1 , int VAR_2 ) { <START> return StringUtils . VAR_3 ( STRING_1 , VAR_1 , VAR_2 ) ; <END> } 
public static String METHOD_1 ( String VAR_1 ) { <START> return StringUtils . VAR_2 ( STRING_1 , VAR_1 ) ; <END> } 
public TYPE_3 ( final TYPE_1 VAR_2 , final String VAR_3 , final int VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_5 = StringUtils . VAR_6 ( STRING_1 , VAR_3 ) ; <END> this . VAR_7 = TYPE_2 . METHOD_1 ( VAR_4 ) ; } 
public TYPE_2 ( TYPE_1 VAR_2 , String VAR_3 , int VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_5 = StringUtils . VAR_6 ( STRING_1 , VAR_3 ) ; <END> this . VAR_7 = StringUtils . VAR_6 ( STRING_2 , VAR_3 ) ; this . VAR_8 = StringUtils . VAR_6 ( STRING_3 , VAR_3 ) ; this . VAR_4 = VAR_4 ; } 
<START> TYPE_1 METHOD_1 ( ) <END> { log . info ( STRING_1 ) ; VAR_1 = VAR_2 . METHOD_2 ( ) ; return VAR_1 ; } 
public int METHOD_1 ( String s , String VAR_1 ) { <START> if ( TYPE_1 . equals ( s , VAR_1 ) ) { <END> return 0 ; } return TYPE_2 . METHOD_1 ( s , VAR_1 ) ; } 
public TYPE_1 < String > METHOD_1 ( ) { final TYPE_2 < String > VAR_1 = new TYPE_2 < > ( ) ; if ( VAR_2 == null ) { return VAR_1 ; } for ( TYPE_3 VAR_3 : METHOD_2 ( ) ) { <START> if ( VAR_2 . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) == 0 ) { <END> VAR_1 . METHOD_5 ( VAR_3 . METHOD_6 ( ) , 1 ) ; } } return VAR_1 ; } 
public Status METHOD_1 ( ANNOTATION_1 final TYPE_1 req ) { TYPE_2 VAR_1 = METHOD_2 ( req , TYPE_3 . VAR_3 ) ; if ( ! VAR_1 . METHOD_3 ( ) ) { log . warn ( STRING_1 ) ; <START> return null ; <END> } return status ; } 
public void METHOD_1 ( ) { VAR_1 = null ; VAR_2 = null ; for ( TYPE_1 VAR_3 : VAR_4 ) { try { VAR_3 . METHOD_2 ( ) ; } catch ( TYPE_2 ex ) { <START> log . warn ( ex . getMessage ( ) , ex ) ; <END> } } VAR_4 . clear ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 config ) { <START> return TYPE_4 . TYPE_5 <END> . METHOD_2 ( this ) . METHOD_3 ( VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_6 . METHOD_4 ( VAR_6 , config . VAR_7 ( ) ) ) . build ( ) ; } 
public TYPE_4 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_2 ) TYPE_2 VAR_3 , ANNOTATION_1 ( STRING_3 ) TYPE_3 VAR_4 ) { super ( VAR_2 , VAR_3 , VAR_4 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 == null ? new TYPE_3 ( ) : VAR_4 ; <START> if ( this . VAR_3 . METHOD_1 ( ) && this . VAR_4 . METHOD_2 ( ) ) { <END> log . warn ( STRING_4 + STRING_5 ) ; } } 
public void METHOD_1 ( ) { <START> VAR_1 = ! VAR_2 ; <END> } 
public TYPE_2 ( ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_3 = VAR_2 . METHOD_1 ( ) ; final File VAR_4 = new File ( STRING_1 ) ; VAR_4 . METHOD_2 ( ) ; <START> VAR_4 . METHOD_3 ( ) ; <END> } 
public TYPE_6 ( ANNOTATION_1 ( STRING_1 ) File VAR_2 , ANNOTATION_1 ( STRING_2 ) String filter , ANNOTATION_1 ( STRING_3 ) TYPE_1 parser ) { super ( <START> TYPE_2 . METHOD_1 ( <END> TYPE_3 . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) , new TYPE_4 ( filter ) , TYPE_5 . VAR_4 ) ) ; this . VAR_2 = VAR_2 ; this . filter = filter ; this . parser = parser ; log . info ( STRING_4 + METHOD_4 ( ) + STRING_5 ) ; } 
public TYPE_4 ( ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_3 = VAR_2 . METHOD_1 ( ) ; for ( final TYPE_2 VAR_4 : new TYPE_3 ( ) . METHOD_2 ( ) ) { VAR_3 . METHOD_3 ( VAR_4 ) ; } final File VAR_5 = new File ( STRING_1 ) ; VAR_5 . METHOD_4 ( ) ; <START> VAR_5 . METHOD_5 ( ) ; <END> } 
public TYPE_1 < TYPE_2 < TYPE_3 > , TYPE_2 < TYPE_3 > > METHOD_1 ( TYPE_4 query , TYPE_5 VAR_1 ) { boolean VAR_2 = TYPE_6 . METHOD_2 ( ) . equals ( VAR_1 ) ; <START> return METHOD_3 ( query , VAR_1 , VAR_2 ) ; <END> } 
public List < String > METHOD_1 ( ) { final TYPE_1 < TYPE_2 > VAR_1 = query . VAR_2 ( ) ; return TYPE_3 . stream ( VAR_1 . METHOD_2 ( ) , false ) . METHOD_3 ( VAR_3 - > VAR_3 . METHOD_4 ( ) . METHOD_1 ( ) . stream ( ) ) <START> . collect ( Collectors . VAR_4 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final String value ) { Long VAR_2 = TYPE_3 . METHOD_2 ( value ) ; if ( VAR_2 == null ) { <START> VAR_2 = TYPE_3 . METHOD_3 ( value ) ; <END> } if ( VAR_2 == null ) { return TYPE_4 . of ( false ) ; } final long VAR_3 = VAR_2 ; return new TYPE_1 ( ) { @Override public boolean METHOD_4 ( ) { return VAR_1 . get ( ) == VAR_3 ; } } ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 ; try { VAR_2 = new TYPE_1 ( VAR_1 ) ; } catch ( TYPE_2 VAR_3 ) { return null ; } if ( VAR_4 ) { <START> VAR_2 = VAR_2 . METHOD_2 ( 0 , TYPE_3 . VAR_6 ) ; <END> } else { VAR_2 = VAR_2 . METHOD_2 ( 0 , TYPE_3 . VAR_7 ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final String value ) { <START> Long VAR_2 = TYPE_3 . METHOD_2 ( value ) ; <END> if ( VAR_2 == null ) { return TYPE_4 . of ( false ) ; } final long VAR_3 = VAR_2 ; return new TYPE_1 ( ) { @Override public boolean METHOD_3 ( ) { return VAR_1 . get ( ) == VAR_3 ; } } ; } 
public Object METHOD_1 ( Long key , boolean asList ) { <START> return TYPE_1 . METHOD_2 ( key ) ; <END> } 
protected int METHOD_1 ( int VAR_1 ) { <START> return METHOD_2 ( ) >= VAR_2 ? 1 : - 1 ; <END> } 
public String toString ( ) { return STRING_1 + STRING_2 + METHOD_1 ( ) + CHAR_1 + STRING_3 + METHOD_2 ( ) + <START> STRING_4 + VAR_1 + <END> STRING_5 + METHOD_3 ( ) + STRING_6 + VAR_2 + STRING_7 + VAR_3 + CHAR_1 + STRING_8 + VAR_4 + STRING_9 + VAR_5 + STRING_10 + METHOD_4 ( ) + CHAR_2 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 < TYPE_1 > b ) throws TYPE_3 { <START> if ( b instanceof List ) { <END> final List < TYPE_1 > VAR_1 = ( List < TYPE_1 > ) b ; if ( VAR_1 . isEmpty ( ) ) { return METHOD_2 ( ) ; } else if ( VAR_1 . size ( ) == 1 ) { return TYPE_4 . METHOD_3 ( b ) ; } } return new TYPE_5 ( TYPE_6 . METHOD_1 ( METHOD_4 ( b ) ) ) ; } 
byte [ ] METHOD_1 ( ) throws IOException { if ( VAR_1 == null ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) ; <START> TYPE_2 VAR_4 = VAR_2 . METHOD_3 ( VAR_5 + STRING_1 ) ; <END> VAR_1 = TYPE_3 . METHOD_4 ( VAR_4 ) ; } return VAR_1 ; } 
<START> } catch ( Exception e ) { <END> throw new RuntimeException ( STRING_1 , e ) ; } 
<START> public boolean METHOD_1 ( ) <END> { final boolean VAR_1 = METHOD_2 ( ) ; if ( VAR_2 instanceof TYPE_1 ) { TYPE_1 VAR_3 = ( TYPE_1 ) VAR_2 ; if ( VAR_3 . METHOD_3 ( ) == Integer . VAR_4 ) { return false ; } if ( VAR_1 ) { return true ; } boolean VAR_5 = TYPE_1 . METHOD_4 ( VAR_2 , METHOD_5 ( ) ) ; return ! VAR_5 ; } return false ; } 
public void METHOD_1 ( ) { size = 0 ; VAR_1 = 0 ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { VAR_3 [ 0 ] . put ( i * VAR_4 , ( byte ) 0 ) ; <START> VAR_3 [ 1 ] . put ( i * VAR_4 , ( byte ) 0 ) ; <END> } VAR_5 = VAR_3 [ 0 ] ; } 
private void METHOD_1 ( final String VAR_1 , TYPE_1 < String > VAR_2 ) { TYPE_2 < String > VAR_3 ; try { <START> while ( ( VAR_3 = VAR_2 . METHOD_2 ( ) ) != null ) { <END> VAR_4 . METHOD_3 ( new TYPE_3 < String , String > ( VAR_1 , VAR_3 . METHOD_4 ( ) ) , VAR_5 ) ; } } catch ( InterruptedException e ) { log . warn ( e , STRING_1 ) ; } } 
public int METHOD_1 ( ) { <START> return 1 ; <END> } 
public static TYPE_1 METHOD_1 ( String name ) { if ( name == null ) { <START> return TYPE_1 . VAR_1 ; <END> } return valueOf ( name . VAR_2 ( ) ) ; } 
TYPE_3 ( int VAR_2 , File VAR_3 , int VAR_4 ) throws TYPE_1 { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; TYPE_2 VAR_5 = new TYPE_2 ( VAR_3 ) ; this . channel = VAR_5 . METHOD_1 ( ) ; <START> VAR_6 . METHOD_2 ( VAR_5 ) ; <END> VAR_6 . METHOD_2 ( channel ) ; } 
public int get ( int index ) { <START> return 0 ; <END> } 
public static int METHOD_1 ( int VAR_1 ) { <START> final int VAR_2 = VAR_1 == - 1 ? - 1 : VAR_3 . METHOD_2 ( INT_1 ) + VAR_1 ; <END> return METHOD_3 ( VAR_2 ) ; } 
public void close ( ) throws IOException { <START> METHOD_1 ( ) ; <END> VAR_1 . set ( false ) ; VAR_2 . METHOD_2 ( ) ; } 
public Response METHOD_1 ( ) { <START> TYPE_5 . TYPE_7 VAR_1 = factory . entry . METHOD_2 ( ) ; <END> if ( VAR_1 instanceof TYPE_5 . TYPE_8 ) { return Response . status ( Response . Status . VAR_2 ) . build ( ) ; } else { String version = ( ( TYPE_5 . TYPE_6 ) VAR_1 ) . METHOD_1 ( ) ; return Response . VAR_3 ( TYPE_4 . of ( STRING_1 , version ) ) . build ( ) ; } } 
<START> private void METHOD_1 ( ) <END> { VAR_1 . METHOD_2 ( ) ; } 
private static String METHOD_1 ( String id , TYPE_1 VAR_1 ) { <START> return id != null ? id : String . format ( STRING_1 , METHOD_2 ( VAR_1 ) , new TYPE_2 ( ) . toString ( ) ) ; <END> } 
public void close ( ) throws IOException { <START> TYPE_1 . close ( VAR_1 ) ; <END> it = TYPE_2 . METHOD_1 ( ) ; } 
public TYPE_1 < String > METHOD_1 ( final String id , final TYPE_2 VAR_1 , final String VAR_2 , final Map < String , String > VAR_3 ) { return new TYPE_1 < String > ( ) { @Override public String call ( ) throws Exception { if ( VAR_2 != null ) { <START> throw new TYPE_3 ( <END> STRING_1 + STRING_2 + VAR_2 + STRING_3 ) ; } else { VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; return version ; } } } ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { return new TYPE_3 ( name , VAR_1 . METHOD_2 ( VAR_2 ) , <START> VAR_1 . METHOD_3 ( TYPE_4 . VAR_4 ) <END> ) ; } 
public TYPE_4 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_2 ) TYPE_2 < String , String > VAR_3 , ANNOTATION_1 ( STRING_3 ) TYPE_2 < String , List < String > > VAR_4 ) { <START> super ( VAR_2 , VAR_3 , VAR_4 , new TYPE_3 ( VAR_2 , VAR_3 , VAR_4 ) ) ; <END> } 
public Map < String , String > parse ( String input ) { final Map < String , Object > VAR_1 = VAR_2 . parse ( input ) ; final String VAR_3 = TYPE_1 . METHOD_1 ( VAR_1 . get ( key ) , STRING_1 , key , input ) . toString ( ) ; final Object val = VAR_1 . get ( value ) ; if ( val == null ) { <START> return null ; <END> } return TYPE_2 . of ( VAR_3 , val . toString ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 in = new TYPE_2 ( VAR_1 , VAR_2 , event ) ; TYPE_3 [ ] VAR_3 = new TYPE_3 [ ] { new TYPE_4 ( STRING_1 , STRING_2 ) , new TYPE_4 ( STRING_3 , STRING_4 ) , new TYPE_5 ( STRING_5 , STRING_6 ) , new TYPE_6 ( STRING_7 , STRING_8 ) , new TYPE_5 ( STRING_9 , STRING_8 ) } ; try { TYPE_7 . METHOD_2 ( in , VAR_3 , true ) ; Assert . VAR_4 ( STRING_10 ) ; <START> } catch ( TYPE_8 e ) { <END> } } 
public void METHOD_1 ( ) { <START> for ( int i = 0 ; i < INT_1 ; i ++ ) { <END> VAR_1 += VAR_2 . get ( i ) ; } } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_1 VAR_2 , TYPE_1 VAR_3 ) { try { return VAR_1 . getClass ( ) . METHOD_2 ( String . VAR_4 , TYPE_1 . VAR_4 , TYPE_1 . VAR_4 ) . METHOD_3 ( VAR_1 . VAR_5 , VAR_2 , VAR_3 ) ; } catch ( Exception e ) { <START> log . info ( e , STRING_1 + VAR_1 ) ; <END> return VAR_1 ; } } 
private boolean METHOD_1 ( String id , boolean VAR_1 ) { Pair < TYPE_1 , TYPE_2 > VAR_2 = VAR_3 . get ( id ) ; if ( VAR_2 != null ) { if ( VAR_1 ) { VAR_4 . METHOD_2 ( id , new TYPE_3 ( ) ) ; } VAR_2 . VAR_5 . METHOD_3 ( true ) ; <START> VAR_3 . remove ( id ) ; <END> return true ; } return false ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 . METHOD_2 ( VAR_2 , STRING_1 ) ; <END> TYPE_2 . METHOD_3 ( VAR_1 , STRING_2 ) ; TYPE_2 . METHOD_3 ( VAR_1 . getId ( ) , STRING_3 ) ; synchronized ( VAR_3 ) { METHOD_4 ( VAR_1 . getId ( ) , false ) ; return METHOD_5 ( VAR_1 , true ) ; } } 
public boolean METHOD_1 ( String id ) { <START> TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ; <END> TYPE_1 . METHOD_3 ( id , STRING_2 ) ; synchronized ( VAR_2 ) { return METHOD_4 ( id , true ) ; } } 
<START> public TYPE_4 ( final TYPE_1 < TYPE_2 , byte [ ] > cache , TYPE_3 config ) <END> { this . cache = cache ; this . config = config ; } 
public TYPE_5 ( long VAR_2 , TYPE_1 VAR_3 , final TYPE_2 [ ] VAR_4 , boolean VAR_5 , boolean VAR_6 , boolean VAR_7 , int VAR_8 , TYPE_3 < ByteBuffer > VAR_9 ) { this ( new TYPE_4 . Builder ( ) . METHOD_1 ( VAR_2 ) . METHOD_2 ( VAR_3 ) . METHOD_3 ( VAR_4 ) <START> . METHOD_4 ( VAR_10 ) <END> . build ( ) , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) == null ) { <END> return false ; } else { return true ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( VAR_2 ) == null ) { <END> return false ; } else { return true ; } } 
TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( new TYPE_2 ( ) <END> . METHOD_2 ( TYPE_3 . METHOD_3 ( 2 ) ) . METHOD_4 ( TYPE_3 . METHOD_3 ( INT_1 ) ) . METHOD_5 ( 5 ) ) ; } 
public boolean METHOD_1 ( TYPE_1 key ) { final int VAR_1 = TYPE_2 . METHOD_2 ( key ) ; <START> final int VAR_2 = METHOD_3 ( VAR_1 ) ; <END> final TYPE_3 < TYPE_1 > VAR_3 = VAR_4 . get ( VAR_2 ) ; synchronized ( VAR_3 ) { return VAR_3 . METHOD_1 ( key , VAR_1 ) ; } } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = this . VAR_1 ; <END> if ( null == VAR_1 ) { synchronized ( VAR_2 ) { VAR_1 = this . VAR_1 ; if ( null == VAR_1 ) { VAR_1 = new TYPE_1 ( TYPE_2 . METHOD_2 ( VAR_3 . get ( METHOD_3 ( ) ) , STRING_1 , METHOD_3 ( ) ) . get ( ) , METHOD_4 ( ) , METHOD_5 ( ) , METHOD_6 ( ) , METHOD_7 ( ) ) ; this . VAR_1 = VAR_1 ; } } } return VAR_1 ; } 
public int METHOD_1 ( ) { <START> int result = container != null ? container . VAR_1 ( ) : 0 ; <END> result = INT_1 * result + ( VAR_2 != null ? Arrays . VAR_1 ( VAR_2 ) : 0 ) ; result = INT_1 * result + ( VAR_3 != null ? VAR_3 . METHOD_1 ( ) : 0 ) ; return result ; } 
public ByteBuffer METHOD_1 ( long offset ) { if ( VAR_1 . METHOD_2 ( - 1 * VAR_2 ) > 0 ) { return VAR_3 . METHOD_1 ( offset ) ; } else { <START> throw new RuntimeException ( STRING_1 ) ; <END> } } 
public TYPE_1 METHOD_1 ( TYPE_2 key ) { TYPE_1 value = cache . get ( key ) ; if ( value == null ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } else { VAR_2 . METHOD_3 ( ) ; } return value ; } 
public TYPE_1 get ( TYPE_2 key , final TYPE_3 < ? extends TYPE_1 > VAR_1 ) throws TYPE_4 { TYPE_1 value = cache . get ( key ) ; if ( value != null ) return value ; try { value = VAR_1 . call ( ) ; <START> cache . put ( key , value ) ; <END> return value ; } catch ( Exception e ) { throw new TYPE_5 ( e , STRING_1 , key ) ; } } 
public List < ? extends TYPE_1 > METHOD_1 ( ) { return TYPE_6 < TYPE_1 > of ( new TYPE_2 ( STRING_1 ) <START> . METHOD_2 ( TYPE_3 . class ) <END> . METHOD_2 ( TYPE_4 . class ) . METHOD_2 ( TYPE_5 . class ) ) ; } 
public static List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { return ImmutableList . VAR_2 ( TYPE_3 . create ( VAR_1 ) <START> . filter ( <END> new TYPE_4 < TYPE_2 > ( ) { @Override public boolean apply ( TYPE_2 input ) { return input != null ; } } ) . METHOD_2 ( new TYPE_5 < TYPE_2 , TYPE_1 > ( ) { @Override public TYPE_1 apply ( TYPE_2 input ) { return input . VAR_3 ( ) ; } } ) ) ; } 
public TYPE_3 ( String VAR_2 , String value , TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; <START> this . value = TYPE_2 . METHOD_1 ( value ) ; ; <END> this . VAR_3 = VAR_3 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 factory ) { if ( VAR_1 == null ) { return factory . VAR_2 ( VAR_3 , value ) ; } else { return factory . VAR_2 ( VAR_3 , new TYPE_3 < String > ( ) { @Override public boolean apply ( String input ) { <START> return value . equals ( TYPE_4 . METHOD_2 ( VAR_1 . apply ( TYPE_4 . METHOD_3 ( input ) ) ) ) ; <END> } } ) ; } } 
public TYPE_8 ( ANNOTATION_1 TYPE_1 VAR_2 , ANNOTATION_2 TYPE_1 VAR_3 , TYPE_2 VAR_4 , ANNOTATION_3 TYPE_3 < TYPE_4 > VAR_5 , TYPE_5 VAR_6 , TYPE_6 VAR_7 , TYPE_7 VAR_8 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; this . VAR_8 = VAR_8 ; this . VAR_9 = VAR_5 . get ( ) ; VAR_9 . METHOD_1 ( VAR_10 ) ; <START> VAR_9 . METHOD_2 ( VAR_11 ) ; <END> } 
private TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 , org . VAR_2 . VAR_3 . VAR_4 . TYPE_5 VAR_6 , TYPE_3 conf ) { String [ ] VAR_7 = null ; try { VAR_7 = METHOD_2 ( VAR_1 , VAR_6 , conf ) ; } catch ( Exception e ) { logger . error ( e , STRING_1 ) ; <START> throw TYPE_4 . METHOD_3 ( e ) ; <END> } return new TYPE_1 ( VAR_1 , VAR_7 ) ; } 
<START> public Set < String > METHOD_1 ( ) <END> { return METHOD_2 ( ) . keySet ( ) ; } 
public List < String > METHOD_1 ( ) { if ( VAR_1 != null ) { return ImmutableList . of ( VAR_1 ) ; } else { <START> return null ; <END> } } 
public void METHOD_1 ( ) throws Exception { VAR_1 = TYPE_1 . METHOD_2 ( TYPE_2 . class ) ; <START> VAR_2 = new TYPE_3 ( ) ; <END> VAR_3 = TYPE_1 . METHOD_2 ( TYPE_4 . class ) ; VAR_4 = TYPE_1 . METHOD_2 ( TYPE_5 . class ) ; instance = new TYPE_6 ( ) . METHOD_3 ( VAR_5 ) . METHOD_4 ( new Date ( ) ) . METHOD_5 ( VAR_6 ) . METHOD_6 ( VAR_7 ) ; VAR_8 = new TYPE_7 ( ) . METHOD_7 ( INT_1 ) . METHOD_8 ( "" ) ; } 
public Iterator < String > iterator ( ) { <START> LOG . debug ( STRING_1 , string ) ; <END> return TYPE_1 . METHOD_1 ( new TYPE_2 ( ) { private boolean VAR_1 = false ; @Override public boolean METHOD_2 ( char c ) { if ( CHAR_1 == c ) { VAR_1 = ! VAR_1 ; } if ( VAR_1 ) { return false ; } return TYPE_2 . TYPE_4 . METHOD_2 ( c ) ; } } ) . METHOD_3 ( ) . split ( string ) . iterator ( ) ; } 
public void METHOD_1 ( ) throws IOException { <START> TYPE_1 VAR_1 = new TYPE_2 ( STRING_1 ) ; <END> VAR_2 . METHOD_2 ( TYPE_2 . class ) ; VAR_3 . put ( STRING_2 , VAR_1 ) ; VAR_3 . METHOD_3 ( ) ; VAR_3 . start ( ) ; Assert . assertEquals ( VAR_1 , VAR_3 . get ( STRING_2 ) ) ; } 
<START> public TYPE_1 METHOD_1 ( ) <END> { synchronized ( VAR_1 ) { return VAR_2 ; } } 
<START> public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 , TYPE_3 , IOException <END> { TYPE_4 VAR_1 = new TYPE_5 ( ) ; TYPE_6 VAR_2 = new TYPE_6 ( FLOAT_1 , FLOAT_2 , FLOAT_3 , 2 ) ; Assert . assertEquals ( VAR_2 , VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( VAR_2 ) , TYPE_6 . class ) ) ; } 
private TYPE_1 METHOD_1 ( Object VAR_1 ) { Object VAR_2 ; if ( VAR_1 instanceof List ) { List VAR_3 = ( List ) VAR_1 ; VAR_2 = VAR_3 . size ( ) == 0 ? null : VAR_3 . get ( 0 ) ; } else { VAR_2 = VAR_1 ; } if ( VAR_2 == null ) { return null ; } <START> TYPE_1 VAR_4 = TYPE_2 . get ( VAR_2 . getClass ( ) . METHOD_2 ( ) ) ; <END> return VAR_4 ; } 
<START> protected Collection < TYPE_1 > METHOD_1 ( Collection < TYPE_2 > VAR_1 ) <END> { return TYPE_3 . METHOD_2 ( VAR_1 , new TYPE_4 < TYPE_2 , TYPE_1 > ( ) { @Override public TYPE_1 apply ( TYPE_2 input ) { return input . VAR_2 ( ) ; } } ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return ( child != null ) <END> ? ( ( child . VAR_1 ( ) == TYPE_1 . VAR_2 ) ? TYPE_1 . VAR_2 : VAR_3 . METHOD_1 ( ) ) : VAR_3 . METHOD_1 ( ) ; } 
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING_1 ) ; sb . append ( STRING_2 ) . append ( VAR_1 ) . append ( CHAR_1 ) ; sb . append ( STRING_3 ) . append ( value ) ; <START> if ( METHOD_1 ( ) != null ) { <END> sb . append ( STRING_4 ) . append ( METHOD_1 ( ) ) ; } sb . append ( STRING_5 ) ; return sb . toString ( ) ; } 
private static Set < String > METHOD_1 ( Collection < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) { <START> return TYPE_6 < String > METHOD_2 ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( <END> TYPE_3 . METHOD_5 ( TYPE_4 . METHOD_6 ( VAR_1 , new TYPE_5 < TYPE_1 , String > ( ) { @Override public String apply ( TYPE_1 input ) { return input . VAR_4 ( ) ; } } ) ) ) ) ; } 
<START> public static List < String > METHOD_1 ( TYPE_1 in ) throws IOException <END> { int count = TYPE_2 . METHOD_2 ( in ) ; if ( count == 0 ) { return null ; } List < String > values = TYPE_3 . METHOD_3 ( count ) ; for ( int i = 0 ; i < count ; i ++ ) { values . add ( METHOD_4 ( in ) ) ; } return values ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; String VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> TYPE_1 VAR_4 = VAR_3 . METHOD_3 ( VAR_2 , TYPE_1 . class ) ; <END> Assert . assertEquals ( VAR_1 , VAR_4 ) ; } 
public byte [ ] METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> return ByteBuffer . VAR_2 ( 1 ) . put ( VAR_3 ) . METHOD_2 ( ) ; } byte [ ] VAR_4 = StringUtils . VAR_5 ( VAR_1 ) ; return ByteBuffer . VAR_2 ( 1 + VAR_4 . length ) . put ( VAR_3 ) . put ( VAR_4 ) . METHOD_2 ( ) ; } 
public void METHOD_1 ( ) throws Exception { final String [ ] VAR_1 = { STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 , STRING_8 , STRING_9 , STRING_10 , STRING_11 , STRING_12 } ; TYPE_1 < String > VAR_2 = METHOD_2 ( TYPE_1 . METHOD_3 ( VAR_1 , TYPE_1 . VAR_3 ) ) ; <START> METHOD_4 ( VAR_1 , VAR_2 , VAR_2 . METHOD_5 ( ) ) ; <END> } 
public String apply ( String value ) { <START> return TYPE_1 . METHOD_1 ( String . format ( format , value ) ) ; <END> } 
public String apply ( String VAR_1 ) { if ( TYPE_1 . METHOD_1 ( VAR_1 ) ) { return null ; } int VAR_2 = VAR_1 . length ( ) ; if ( index < VAR_2 ) { <START> if ( length > 0 ) { <END> return VAR_1 . substring ( index , Math . VAR_3 ( VAR_4 , VAR_2 ) ) ; } else { return VAR_1 . substring ( index ) ; } } else { return null ; } } 
public boolean METHOD_1 ( ) { <START> return false ; <END> } 
public byte [ ] METHOD_1 ( ) { byte [ ] VAR_1 = StringUtils . VAR_2 ( value ) ; <START> return ByteBuffer . VAR_3 ( 2 + VAR_1 . length ) <END> . put ( VAR_4 ? ( byte ) 1 : 0 ) . put ( VAR_5 ) . put ( VAR_1 ) . METHOD_2 ( ) ; } 
public TYPE_1 ( <START> ANNOTATION_1 ( STRING_1 ) String value , <END> ANNOTATION_1 ( STRING_2 ) boolean VAR_2 ) { this . value = value ; this . VAR_2 = VAR_2 ; this . target = value == null || VAR_2 ? value : value . VAR_3 ( ) ; } 
private static void METHOD_1 ( File VAR_1 , final Path path , final TYPE_1 VAR_2 ) throws IOException { log . info ( STRING_1 , path ) ; TYPE_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_1 ) , new TYPE_4 < TYPE_5 > ( ) { @Override public TYPE_5 METHOD_4 ( ) throws IOException { <START> return VAR_2 . create ( path ) ; <END> } } ) ; } 
public TYPE_3 ( ANNOTATION_1 ANNOTATION_2 ( STRING_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ANNOTATION_2 ( STRING_2 ) TYPE_1 VAR_3 ) { TYPE_2 . METHOD_1 ( VAR_2 , STRING_3 ) ; TYPE_2 . METHOD_1 ( VAR_3 , STRING_4 ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> if ( ! VAR_2 . startsWith ( STRING_1 ) ) { <END> throw new TYPE_2 ( STRING_2 ) ; } try { final String VAR_3 = VAR_4 . METHOD_2 ( ) ; if ( VAR_3 == null || VAR_3 . isEmpty ( ) ) { return null ; } else { return new TYPE_3 ( STRING_3 , VAR_3 , VAR_2 , VAR_1 , null ) . METHOD_3 ( ) ; } } catch ( Exception e ) { throw TYPE_4 . METHOD_4 ( e ) ; } } 
public TYPE_1 < T > get ( ) { TYPE_2 VAR_1 ; <START> size . VAR_2 ( ) ; <END> try { VAR_1 = VAR_3 . METHOD_1 ( ) ; } catch ( InterruptedException e ) { Thread . VAR_4 ( ) . METHOD_2 ( ) ; throw TYPE_3 . METHOD_3 ( e ) ; } synchronized ( VAR_1 ) { VAR_1 . count . METHOD_4 ( ) ; VAR_3 . METHOD_5 ( VAR_1 ) ; } return VAR_1 ; } 
public void remove ( final TYPE_1 task ) { VAR_1 . METHOD_1 ( ) ; try { log . info ( STRING_1 , task . getId ( ) ) ; for ( final TYPE_2 VAR_2 : METHOD_2 ( task ) ) { METHOD_3 ( task , VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) ; } } finally { <START> VAR_3 . remove ( task . getId ( ) ) ; <END> VAR_1 . METHOD_3 ( ) ; } } 
<START> private TYPE_1 [ ] METHOD_1 ( TYPE_1 [ ] VAR_1 ) <END> { TYPE_1 [ ] VAR_2 = new TYPE_1 [ VAR_1 . length ] ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { VAR_2 [ i ] = VAR_1 [ i ] . METHOD_2 ( ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) <START> { <END> return new TYPE_2 ( name , name , size , VAR_1 , true ) ; } 
public TYPE_2 ( TYPE_1 config ) { <START> this . config = config ; <END> VAR_2 = this . config . VAR_3 ( ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 , final File VAR_2 ) throws TYPE_2 { <START> Map < String , Object > VAR_3 = VAR_1 . METHOD_2 ( ) ; <END> String VAR_4 = TYPE_3 . getString ( VAR_3 , STRING_1 ) ; String container = TYPE_3 . getString ( VAR_3 , STRING_2 ) ; String path = TYPE_3 . getString ( VAR_3 , STRING_3 ) ; log . info ( STRING_4 , path , VAR_2 ) ; METHOD_3 ( VAR_2 ) ; METHOD_1 ( VAR_4 , container , path , VAR_2 ) ; } 
public int METHOD_1 ( ) { <START> return METHOD_2 ( STRING_1 ) == null ? VAR_1 : Integer . parseInt ( METHOD_2 ( STRING_1 ) . toString ( ) ) ; <END> } 
public int METHOD_1 ( ) { <START> return METHOD_2 ( STRING_1 ) == null ? VAR_1 : Integer . parseInt ( METHOD_2 ( STRING_1 ) . toString ( ) ) ; <END> } 
public TYPE_3 ( ) { <START> this ( TYPE_1 . METHOD_1 ( TYPE_2 . METHOD_2 ( STRING_1 + METHOD_3 ( ) ) ) ) ; <END> } 
public int add ( TYPE_1 row , TYPE_2 < TYPE_3 > VAR_1 ) throws TYPE_4 { if ( row == null ) { return - 1 ; } TYPE_5 VAR_2 = METHOD_1 ( row . VAR_3 ( ) ) ; if ( VAR_2 == null ) { return - 1 ; } final int VAR_4 = VAR_2 . add ( row ) ; <START> if ( ! VAR_2 . METHOD_2 ( ) ) { <END> METHOD_3 ( VAR_1 . get ( ) ) ; } return VAR_4 ; } 
public TYPE_4 ( ANNOTATION_1 ( STRING_1 ) String id , ANNOTATION_1 ( STRING_2 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_3 ) TYPE_2 VAR_3 , ANNOTATION_2 TYPE_3 VAR_4 ) { super ( METHOD_1 ( id , VAR_3 ) , <START> String . format ( STRING_4 , METHOD_2 ( VAR_3 ) ) , <END> VAR_2 == null ? new TYPE_1 ( METHOD_1 ( id , VAR_3 ) , 1 ) : VAR_2 , METHOD_2 ( VAR_3 ) , METHOD_3 ( VAR_3 ) ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
protected void METHOD_1 ( ) throws Throwable { if ( ! VAR_1 . get ( ) ) { log . warn ( STRING_1 , object ) ; } <START> super . METHOD_1 ( ) ; <END> } 
<START> public static ANNOTATION_1 Map < String , String > METHOD_1 ( ANNOTATION_2 Throwable t ) <END> { return TYPE_1 . of ( STRING_1 , t == null ? STRING_2 : ( t . getMessage ( ) == null ? t . toString ( ) : t . getMessage ( ) ) ) ; } 
public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { if ( this == VAR_1 ) { return false ; } if ( VAR_1 == null ) { return true ; } if ( ! ( VAR_1 instanceof TYPE_2 ) ) { return true ; } final TYPE_2 that = ( TYPE_2 ) VAR_1 ; <START> return VAR_2 != that . VAR_2 || ! map . equals ( that . map ) ; <END> } 
public void METHOD_1 ( TYPE_1 binder ) { TYPE_2 . bind ( binder , VAR_1 , TYPE_3 . class ) ; TYPE_4 . METHOD_2 ( binder , TYPE_5 . class ) ; TYPE_2 . bind ( binder , VAR_1 , TYPE_6 . class ) ; TYPE_7 . METHOD_3 ( binder , TYPE_8 . class ) ; <START> TYPE_4 . METHOD_2 ( binder , TYPE_5 . class ) ; <END> TYPE_4 . METHOD_2 ( binder , TYPE_9 . class ) ; } 
public Response METHOD_1 ( ) { log . info ( STRING_1 ) ; VAR_1 . METHOD_2 ( new TYPE_1 ( ) { @Override public void run ( ) { <START> VAR_2 . METHOD_3 ( ) ; <END> System . VAR_3 ( - 1 ) ; } } , 1 , TimeUnit . VAR_4 ) ; VAR_1 . METHOD_4 ( ) ; return Response . status ( Response . Status . VAR_5 ) . build ( ) ; } 
public TYPE_1 get ( ) { <START> METHOD_1 ( ) ; <END> return new TYPE_1 ( ) { @Override public String METHOD_2 ( ) { return VAR_1 ; } @Override public String METHOD_3 ( ) { return VAR_2 ; } @Override public String METHOD_4 ( ) { return VAR_3 ; } @Override public String METHOD_5 ( ) { return VAR_4 ; } @Override public String METHOD_6 ( ) { return VAR_5 ; } @Override public String METHOD_7 ( ) { return VAR_6 ; } } ; } 
public TYPE_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_2 ) { super ( ( VAR_2 == null ) ? "" : VAR_2 ) ; <START> this . VAR_2 = ( VAR_2 == null ) ? "" : VAR_2 ; <END> } 
public byte [ ] METHOD_1 ( ) { <START> byte [ ] VAR_1 = StringUtils . VAR_2 ( METHOD_2 ( ) ) ; <END> return ByteBuffer . VAR_3 ( 1 + VAR_1 . length ) . put ( VAR_4 ) . put ( VAR_1 ) . METHOD_3 ( ) ; } 
public TYPE_4 ( TYPE_1 query , TYPE_2 VAR_2 ) { this . query = query ; this . VAR_2 = VAR_2 ; this . VAR_3 = query . VAR_4 ( ) . METHOD_1 ( ) ; <START> this . VAR_5 = TYPE_3 . METHOD_2 ( query ) ? null : query . VAR_4 ( ) . METHOD_3 ( ) ; <END> } 
public TYPE_3 ( TYPE_1 query , TYPE_2 VAR_2 ) { this . query = query ; this . VAR_2 = VAR_2 ; this . VAR_3 = query . VAR_4 ( ) . METHOD_1 ( ) ; <START> this . VAR_5 = query . VAR_4 ( ) . METHOD_2 ( ) ; <END> } 
public static Collection < TYPE_1 > METHOD_1 ( TYPE_2 query ) { return TYPE_3 . filter ( query . VAR_1 ( ) , new TYPE_4 < TYPE_1 > ( ) { @Override public boolean apply ( ANNOTATION_1 TYPE_1 input ) { <START> return input != null <END> && input . VAR_2 ( ) != null && TYPE_5 . TYPE_6 . VAR_5 . equals ( input . VAR_2 ( ) . METHOD_2 ( ) ) ; } } ) ; } 
public static boolean METHOD_1 ( TYPE_1 query ) { <START> return query != null <END> && query . VAR_1 ( ) != null && query . VAR_1 ( ) . METHOD_2 ( ) != null && TYPE_2 . TYPE_3 . VAR_4 . equals ( query . VAR_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ) && query . VAR_5 ( ) . METHOD_4 ( ) ; } 
public long METHOD_1 ( ) { <START> return VAR_1 . METHOD_1 ( ) + 1 + 4 + 4 + 1 ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , Path VAR_2 , final TYPE_2 VAR_3 ) throws IOException { final Path VAR_4 = new Path ( VAR_2 , STRING_1 ) ; log . info ( STRING_2 , VAR_4 ) ; <START> final TYPE_3 VAR_5 = TYPE_3 . METHOD_2 ( VAR_6 . METHOD_3 ( VAR_1 ) ) ; <END> VAR_5 . METHOD_4 ( new TYPE_4 ( VAR_3 , VAR_4 ) ) ; return VAR_1 ; } 
public String apply ( long value ) { <START> return this . apply ( Long . valueOf ( value ) ) ; <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 ) { METHOD_2 ( VAR_1 , VAR_2 , ImmutableList . of ( String . format ( <START> STRING_1 <END> + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 + STRING_7 + STRING_8 + STRING_9 + STRING_10 + STRING_11 , VAR_2 , METHOD_3 ( ) , METHOD_4 ( ) ) , String . format ( STRING_12 , VAR_2 ) , String . format ( STRING_13 , VAR_2 ) , String . format ( STRING_14 , VAR_2 ) ) ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , boolean VAR_3 , int VAR_4 ) { super ( VAR_2 , VAR_3 ) ; this . VAR_5 = new TYPE_2 < > ( ) ; this . VAR_4 = VAR_4 ; <START> this . VAR_6 = new TYPE_3 [ VAR_4 ] [ ] ; <END> for ( int i = 0 ; i < this . VAR_6 . length ; ++ i ) { this . VAR_6 [ i ] = null ; } } 
public int getId ( String value ) { <START> if ( value == null ) { <END> return - 1 ; } final Integer id = VAR_1 . get ( value ) ; return id == null ? - 1 : id ; } 
public TYPE_1 METHOD_1 ( TYPE_2 factory ) { if ( VAR_1 . size ( ) == 0 ) { <START> return new TYPE_3 ( false ) ; <END> } final TYPE_1 [ ] VAR_2 = new TYPE_1 [ VAR_1 . size ( ) ] ; for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { VAR_2 [ i ] = VAR_1 . get ( i ) . METHOD_1 ( factory ) ; } return METHOD_1 ( VAR_2 ) ; } 
public byte [ ] METHOD_1 ( byte [ ] VAR_1 ) { TYPE_1 VAR_2 = null ; try ( final TYPE_2 < TYPE_3 > VAR_3 = TYPE_4 . METHOD_2 ( ) ) { <START> VAR_2 = VAR_3 . get ( ) . METHOD_3 ( VAR_1 , 0 , VAR_1 . length ) ; <END> } catch ( IOException e ) { log . error ( e , STRING_1 ) ; } return null == VAR_2 ? null : VAR_2 . METHOD_4 ( ) ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; VAR_2 . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; String uri = VAR_1 . METHOD_7 ( ) ; VAR_2 . METHOD_8 ( uri ) ; <START> if ( VAR_1 . METHOD_9 ( ) ) { <END> VAR_2 . METHOD_10 ( VAR_1 . METHOD_11 ( ) ) ; VAR_2 . METHOD_12 ( true ) ; } return VAR_2 ; } 
public boolean METHOD_1 ( TYPE_1 query ) { <START> return ! TYPE_2 . METHOD_2 ( VAR_1 ) . contains ( query . getType ( ) ) ; <END> } 
<START> public List < String > METHOD_1 ( ) <END> { return TYPE_1 . METHOD_2 ( name ) ; } 
public TYPE_1 < TYPE_2 < TYPE_3 > > METHOD_1 ( TYPE_1 < TYPE_2 < TYPE_3 > > VAR_1 ) { <START> return new TYPE_4 < TYPE_2 < TYPE_3 > > ( <END> new TYPE_5 < TYPE_2 < TYPE_3 > > ( VAR_1 , config . VAR_2 ( ) ) ) ; } 
public TYPE_1 < String > METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( name ) ; <END> } 
public TYPE_4 ( String name , List < TYPE_1 > VAR_2 , boolean VAR_3 ) { this . name = name ; <START> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 ) ; <END> this . VAR_4 = TYPE_3 . METHOD_2 ( ) ; this . VAR_3 = VAR_3 ; } 
public TYPE_2 ( ANNOTATION_1 ( STRING_1 ) int VAR_2 , ANNOTATION_1 ( STRING_2 ) int VAR_3 ) { super ( VAR_2 , VAR_3 ) ; <START> VAR_4 = TYPE_1 . METHOD_1 ( ) ; <END> } 
public Status METHOD_1 ( ) { return new Status ( <START> METHOD_2 ( STRING_1 ) , <END> METHOD_2 ( STRING_2 ) , METHOD_3 ( ) , new TYPE_1 ( TYPE_2 . METHOD_4 ( ) ) ) ; } 
public void run ( ) { try { TYPE_1 VAR_1 = METHOD_1 ( ) ; <START> TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; <END> try { VAR_1 . getInstance ( TYPE_3 . class ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( ) ; } catch ( Throwable t ) { log . error ( t , STRING_1 ) ; System . VAR_3 ( 1 ) ; } } catch ( Exception e ) { throw TYPE_4 . METHOD_5 ( e ) ; } } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , List < TYPE_2 > VAR_3 ) { <START> return ; <END> } 
public TYPE_2 ( ANNOTATION_1 ( STRING_1 ) Long VAR_2 , ANNOTATION_1 ( STRING_2 ) Long VAR_3 , ANNOTATION_1 ( STRING_3 ) Integer VAR_4 , ANNOTATION_1 ( STRING_4 ) Long VAR_5 , ANNOTATION_1 ( STRING_5 ) String VAR_6 ) { <START> this ( TYPE_1 . METHOD_1 ( ) . METHOD_2 ( VAR_2 ) . METHOD_3 ( VAR_3 ) . METHOD_4 ( VAR_5 ) . METHOD_5 ( VAR_6 ) . METHOD_6 ( VAR_4 ) . METHOD_7 ( true ) ) ; <END> } 
public boolean hasNext ( ) { boolean hasNext = VAR_1 . hasNext ( ) || ! VAR_2 . METHOD_1 ( ) ; <START> if ( ! hasNext ) for ( TYPE_1 VAR_3 : VAR_4 ) VAR_3 . close ( ) ; <END> return hasNext ; } 
public boolean hasNext ( ) { boolean hasNext = VAR_1 . hasNext ( ) || ! VAR_2 . METHOD_1 ( ) ; <START> if ( ! hasNext ) { <END> for ( TYPE_1 VAR_3 : VAR_4 ) { VAR_3 . close ( ) ; } } return hasNext ; } 
public Optional < TYPE_1 > METHOD_1 ( String VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; if ( VAR_2 . containsKey ( VAR_1 ) ) { <START> return Optional . of ( VAR_2 . get ( VAR_1 ) . task ) ; <END> } else { return Optional . VAR_3 ( ) ; } } 
public static void METHOD_1 ( TYPE_1 job ) { for ( String VAR_1 : System . VAR_2 ( ) . METHOD_2 ( ) ) { <START> TYPE_2 conf = job . VAR_3 ( ) ; <END> if ( VAR_1 . startsWith ( STRING_1 ) ) { conf . set ( VAR_1 . substring ( STRING_1 . length ( ) ) , System . getProperty ( VAR_1 ) ) ; } } } 
public Object METHOD_1 ( Map < String , Object > VAR_1 ) { Object VAR_2 = VAR_1 . get ( VAR_3 ) ; <START> if ( VAR_2 == null ) { <END> throw new TYPE_1 ( STRING_1 , VAR_3 ) ; } return VAR_2 ; } 
public void METHOD_1 ( ) { try { for ( TYPE_1 VAR_1 : VAR_2 . values ( ) ) { <START> VAR_1 . METHOD_2 ( ) . close ( ) ; <END> } } catch ( Exception e ) { throw TYPE_2 . METHOD_3 ( e ) ; } finally { VAR_3 = false ; } } 
protected byte [ ] METHOD_1 ( String VAR_1 ) throws TYPE_1 { boolean commit = false ; db . VAR_2 ( ) ; TYPE_2 VAR_3 = null ; try { VAR_3 = db . VAR_4 ( METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ) ; byte [ ] VAR_5 = VAR_3 . METHOD_4 ( ) ; commit = true ; return VAR_5 ; } finally { <START> if ( VAR_3 != null ) VAR_3 . METHOD_5 ( ) ; ; <END> db . VAR_6 ( commit ) ; } } 
private static String METHOD_1 ( String path ) { File f = new File ( path ) ; if ( f . exists ( ) ) { for ( File log : f . VAR_1 ( ) ) { log . VAR_2 ( ) ; } <START> f . VAR_2 ( ) ; <END> } return path ; } 
TYPE_3 ( ) { <START> VAR_2 . addAll ( TYPE_1 . METHOD_1 ( TYPE_2 . class ) ) ; <END> } 
TYPE_4 ( TYPE_1 VAR_2 , String id , TYPE_2 VAR_3 ) { this ( VAR_2 , id , ( TYPE_3 ) null ) ; this . VAR_4 = VAR_2 ; <START> this . VAR_5 = id ; <END> this . VAR_6 = VAR_3 ; METHOD_1 ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { final int VAR_1 = 10 ; <START> TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_4 . VAR_3 ) ; <END> METHOD_5 ( VAR_1 ) ; db . VAR_4 ( new TYPE_3 ( ) { @Override public void run ( ) { METHOD_6 ( VAR_1 ) ; } } ) ; } 
public String toString ( ) { return STRING_1 + STRING_2 + VAR_1 + STRING_3 + VAR_2 + STRING_4 + VAR_3 + STRING_5 + VAR_4 + STRING_6 + error . VAR_5 ( ) + STRING_7 + error . VAR_6 ( ) + STRING_8 + VAR_7 + STRING_9 + VAR_8 + STRING_10 + VAR_9 + CHAR_1 ; <START> } <END> 
public List < TYPE_1 > METHOD_1 ( ) { <START> VAR_1 = true ; <END> return new TYPE_2 ( ) ; } 
public TYPE_1 next ( ) { if ( query == null ) throw new IllegalStateException ( STRING_1 ) ; <START> if ( VAR_1 ) <END> return null ; synchronized ( METHOD_1 ( ) . METHOD_2 ( ) ) { try { if ( VAR_2 . next ( ) ) { return METHOD_3 ( ) ; } else return null ; } catch ( TYPE_2 e ) { Log . VAR_3 ( TAG , STRING_2 , e ) ; return null ; } } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 listener , String VAR_2 ) { if ( ! VAR_3 . containsKey ( VAR_2 ) ) { <START> Set < TYPE_1 > VAR_4 = Collections . VAR_5 ( new HashSet < TYPE_1 > ( ) ) ; <END> VAR_3 . put ( VAR_2 , VAR_4 ) ; METHOD_2 ( VAR_2 ) ; } TYPE_1 token = new TYPE_1 ( VAR_1 , listener , VAR_2 ) ; VAR_3 . get ( VAR_2 ) . add ( token ) ; return token ; } 
private void METHOD_1 ( final String VAR_1 ) { synchronized ( VAR_2 ) { if ( ! VAR_3 . containsKey ( VAR_1 ) || VAR_4 == null ) return ; Set < TYPE_1 > VAR_5 = VAR_6 . get ( VAR_1 ) ; if ( VAR_5 != null ) { <START> synchronized ( VAR_5 ) { <END> TYPE_2 VAR_7 = new TYPE_2 ( VAR_1 ) ; for ( TYPE_1 token : VAR_5 ) token . VAR_8 ( VAR_7 ) ; } } } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( VAR_2 ) ; } 
<START> public TYPE_1 METHOD_1 ( int index , TYPE_2 value ) { <END> return METHOD_2 ( index , value ) ; } 
void METHOD_1 ( ) { if ( VAR_1 == null ) <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
<START> boolean METHOD_1 ( ) throws TYPE_1 { <END> try { if ( ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( false , true ) ) return false ; METHOD_4 ( VAR_1 ) ; } catch ( TYPE_2 e ) { Log . e ( TAG , STRING_1 + VAR_1 , e ) ; return false ; } return true ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 node ) throws TYPE_2 { <START> node . VAR_1 ( ) . METHOD_2 ( ) ; <END> TYPE_3 VAR_2 = METHOD_3 ( ) ; return ( TYPE_1 ) VAR_2 . METHOD_4 ( node . VAR_1 ( ) . METHOD_5 ( ) . getName ( ) , METHOD_6 ( ) ) . METHOD_7 ( node . getPath ( ) ) ; } 
private static String METHOD_1 ( String VAR_1 , String [ ] VAR_2 , Map < String , String > VAR_3 ) { String VAR_4 = VAR_3 . get ( VAR_1 ) ; <START> if ( VAR_1 == null || VAR_4 == null ) { <END> return null ; } for ( String VAR_5 : VAR_2 ) { if ( VAR_5 . equalsIgnoreCase ( VAR_4 ) ) { return null ; } } return VAR_4 ; } 
public TYPE_1 build ( final TYPE_2 context ) { final TYPE_3 VAR_1 = context . VAR_2 ( this . VAR_3 ) ; final String VAR_4 = this . VAR_5 > 0 ? String . valueOf ( VAR_5 ) : null ; final TYPE_4 VAR_6 = context . VAR_7 ( VAR_4 ) ; <START> VAR_6 . METHOD_1 ( this . VAR_8 . METHOD_2 ( VAR_6 . METHOD_3 ( ) , context . VAR_9 ( ) ) ) ; <END> return METHOD_4 ( context , VAR_6 , VAR_1 ) ; } 
protected boolean METHOD_1 ( final TYPE_1 context ) { return TYPE_2 . METHOD_2 ( context ) <START> && TYPE_3 . METHOD_3 ( context . VAR_1 ( TYPE_4 . VAR_3 ) . METHOD_4 ( null ) ) ; <END> } 
protected String METHOD_1 ( final TYPE_1 context ) { <START> return ( ( Optional < String > ) context . VAR_1 ( ) . get ( context , TYPE_2 . VAR_3 ) ) . METHOD_2 ( null ) ; <END> } 
public final Optional < TYPE_1 > METHOD_1 ( final TYPE_2 context , final TYPE_3 VAR_1 , final String VAR_2 ) { METHOD_2 ( ) ; <START> return Optional . of ( VAR_3 . METHOD_1 ( context , VAR_1 , VAR_2 ) ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_2 context , final Object VAR_1 ) { if ( VAR_1 != null ) { return new TYPE_3 ( ( TYPE_4 ) VAR_1 ) ; } else { <START> return ( TYPE_1 < TYPE_2 > ) TYPE_1 . VAR_2 ; <END> } } 
protected TYPE_1 METHOD_1 ( final TYPE_2 context , final List < TYPE_3 > VAR_1 ) { final TYPE_4 VAR_2 = ( TYPE_4 ) VAR_1 . get ( 0 ) ; <START> return ( TYPE_1 ) VAR_2 . METHOD_2 ( context ) . get ( ) ; <END> } 
public TYPE_1 ( ) { <START> this . VAR_2 = Arrays . asList ( new String [ ] { } ) ; <END> this . VAR_3 = Arrays . asList ( new String [ ] { } ) ; } 
protected void METHOD_1 ( TYPE_1 context ) { TYPE_2 . assertNotNull ( STRING_1 , this . VAR_1 ) ; if ( this . VAR_1 instanceof TYPE_3 ) { <START> ( ( TYPE_3 ) this . VAR_1 ) . METHOD_2 ( ) ; <END> } } 
public void METHOD_1 ( final String VAR_1 ) { <START> if ( this . VAR_1 != null ) { <END> TYPE_1 . assertNotNull ( STRING_1 , VAR_1 ) ; } this . VAR_1 = VAR_1 ; } 
public Object METHOD_1 ( String name ) { <START> return ( VAR_1 != null ) ? VAR_1 . get ( name ) : null ; <END> } 
public String METHOD_1 ( String name ) { <START> if ( VAR_1 != null ) { <END> return VAR_1 . get ( name ) ; } else { return null ; } } 
public boolean METHOD_1 ( final TYPE_1 context , final TYPE_2 VAR_1 ) throws TYPE_3 { if ( VAR_1 != null && ! ( VAR_1 instanceof TYPE_4 ) ) { return true ; } else { if ( this . VAR_2 != null ) { throw TYPE_3 . METHOD_2 ( STRING_1 , context , this . VAR_2 ) ; } else { return false ; <START> } <END> } } 
public static boolean METHOD_1 ( final Collection VAR_1 ) { <START> return VAR_1 != null && ! VAR_1 . isEmpty ( ) ; <END> } 
public TYPE_1 METHOD_1 ( final TYPE_2 context ) { final String name = context . VAR_1 ( this . VAR_2 ) ; <START> if ( name == null && VAR_3 != null ) { <END> return VAR_3 ; } TYPE_3 . METHOD_2 ( STRING_1 , name ) ; return METHOD_1 ( name ) ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 context ) { String VAR_1 = METHOD_2 ( context ) ; this . VAR_2 = new TYPE_3 ( this . configuration . VAR_3 ( ) , this . configuration . VAR_4 ( ) , VAR_1 , <START> ( this . configuration . VAR_5 ( ) . equals ( STRING_1 ) ? VAR_1 <END> : this . configuration . VAR_5 ( ) ) , this . configuration . VAR_6 ( ) , this . VAR_7 ) ; return this . VAR_2 . METHOD_3 ( ) ; } 
protected TYPE_1 METHOD_1 ( final TYPE_2 context ) { <START> this . VAR_1 = new TYPE_3 ( this . configuration . VAR_2 ( ) , <END> METHOD_2 ( context ) , this . configuration . VAR_3 ( ) , this . configuration . VAR_4 ( ) , this . VAR_5 ) ; return this . VAR_1 . METHOD_3 ( ) ; } 
protected void METHOD_1 ( ) { if ( this . VAR_1 != null && ! this . VAR_1 . METHOD_2 ( STRING_1 ) ) { this . VAR_1 += STRING_1 ; } if ( TYPE_1 . METHOD_3 ( this . VAR_1 ) ) { <START> this . VAR_1 = this . VAR_2 . METHOD_4 ( STRING_2 , STRING_3 ) ; <END> } else if ( TYPE_1 . METHOD_3 ( this . VAR_2 ) ) { this . VAR_2 = this . VAR_1 + STRING_4 ; } } 
public List < TYPE_1 > METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> if ( this . VAR_1 == null ) { return Collections . VAR_2 ( ) ; } else { return this . VAR_1 ; } } 
public TYPE_3 ( ) { METHOD_1 ( VAR_2 , TYPE_1 . VAR_4 ) ; <START> METHOD_1 ( VAR_2 , TYPE_1 . VAR_5 ) ; <END> METHOD_1 ( VAR_6 , TYPE_1 . VAR_5 ) ; METHOD_1 ( VAR_7 , TYPE_1 . VAR_5 ) ; METHOD_1 ( VAR_8 , TYPE_1 . VAR_5 ) ; METHOD_1 ( VAR_9 , TYPE_1 . VAR_5 ) ; METHOD_1 ( VAR_10 , TYPE_1 . VAR_5 ) ; METHOD_1 ( VAR_11 , TYPE_1 . VAR_12 ) ; METHOD_1 ( VAR_13 , TYPE_2 . VAR_15 ) ; METHOD_1 ( VAR_16 , TYPE_2 . VAR_17 ) ; } 
public String METHOD_1 ( ) { final List < TYPE_1 > list = METHOD_2 ( ) ; <START> if ( list != null && list . size ( ) > 0 ) <END> return list . get ( 0 ) . METHOD_1 ( ) ; else return null ; } 
protected abstract TYPE_1 METHOD_1 ( final TYPE_2 context ) throws TYPE_3 ; public final TYPE_4 METHOD_2 ( final TYPE_1 VAR_1 , final TYPE_2 context ) { METHOD_3 ( ) ; logger . debug ( STRING_1 , VAR_1 ) ; if ( VAR_1 == null ) { return null ; <START> } <END> final TYPE_4 VAR_2 = METHOD_4 ( VAR_1 , context ) ; for ( TYPE_5 < TYPE_4 > VAR_3 : this . VAR_4 ) { VAR_3 . METHOD_5 ( VAR_2 ) ; } return VAR_2 ; } 
public TYPE_1 create ( ) { if ( VAR_1 && VAR_2 . size ( ) == 1 ) { logger . info ( STRING_1 ) ; return VAR_2 . get ( 0 ) ; } logger . info ( STRING_2 ) ; TYPE_1 client = null ; <START> try { <END> client = new TYPE_1 ( this . VAR_3 ) ; } catch ( IOException ex ) { throw new IllegalStateException ( STRING_3 , ex ) ; } VAR_2 . add ( client ) ; return client ; } 
public void METHOD_1 ( ) { this . map = VAR_1 . METHOD_2 ( name ) ; <START> VAR_2 = METHOD_3 ( VAR_3 , VAR_4 ) ; <END> } 
public static File METHOD_1 ( String VAR_1 ) { File file = new File ( VAR_1 ) . METHOD_2 ( ) ; if ( file . exists ( ) ) { <START> return file . VAR_2 ( ) ; <END> } else { return METHOD_3 ( METHOD_4 ( ) , STRING_1 , VAR_1 ) . METHOD_2 ( ) ; } } 
public TYPE_1 METHOD_1 ( double VAR_1 ) { if ( VAR_1 <= 0 ) { <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> } long VAR_2 = METHOD_2 ( TYPE_2 . METHOD_3 ( 1 ) / VAR_1 ) ; return METHOD_4 ( VAR_2 ) ; } 
<START> private static boolean METHOD_1 ( Object object , String value , TYPE_1 field ) throws TYPE_2 { <END> if ( METHOD_2 ( object , value , field ) ) { return true ; } if ( METHOD_3 ( object , value , field ) ) { return true ; } if ( METHOD_4 ( object , value , field ) ) { return true ; } return METHOD_5 ( field ) ; } 
public long METHOD_1 ( ) { try { Long count = METHOD_2 ( ( VAR_1 != null ) ? VAR_1 : VAR_2 , VAR_3 ) ; return ( count == null ? - 1 : count ) ; } catch ( Exception e ) { <START> LOGGER . warn ( STRING_1 + VAR_4 . getId ( ) + STRING_2 + e . getMessage ( ) ) ; <END> return - 1 ; } } 
<START> public void METHOD_1 ( ) throws IllegalStateException { <END> METHOD_1 ( Integer . VAR_1 ) ; } 
public void run ( ) { long VAR_1 = 0 ; while ( ! VAR_2 . METHOD_1 ( ) ) { <START> for ( int i = 0 ; i < VAR_3 ; i ++ ) { <END> String key = VAR_4 [ VAR_5 . METHOD_2 ( VAR_4 . length ) ] ; map . put ( key , METHOD_3 ( key , VAR_5 ) ) ; VAR_1 ++ ; if ( VAR_1 % VAR_6 == 0 ) { LOGGER . info ( Thread . VAR_7 ( ) . getName ( ) + STRING_1 + VAR_1 ) ; } } } } 
public T METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( 100 ) ; <START> for ( Map . Entry < T , Integer > entry : VAR_3 . entrySet ( ) ) { <END> Integer VAR_4 = entry . getValue ( ) ; if ( ( VAR_1 -= VAR_4 ) < 0 ) { return entry . getKey ( ) ; } } return VAR_5 ; } 
TYPE_2 ( Object [ ] VAR_2 ) { <START> this . VAR_3 = new TYPE_1 ( ) ; <END> this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( Object response ) { <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> } 
List < TYPE_1 > METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) { String name = METHOD_2 ( VAR_1 ) ; TYPE_1 . TYPE_4 VAR_3 = VAR_4 . METHOD_3 ( VAR_1 , "" , new ArrayList < String > ( ) , new ArrayList < String > ( ) , new Long ( VAR_2 . METHOD_4 ( ) ) . METHOD_5 ( ) ) ; <START> return Arrays . asList ( new TYPE_1 ( name , Type . VAR_5 , METHOD_6 ( VAR_1 , VAR_2 ) , Arrays . asList ( VAR_3 ) ) ) ; <END> } 
<START> protected TYPE_1 METHOD_1 ( ) throws IllegalArgumentException { <END> if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } return VAR_1 ; } 
<START> List < TYPE_1 > METHOD_1 ( TYPE_2 . Type type , List < TYPE_1 . TYPE_4 > VAR_1 ) { <END> TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , type , VAR_4 , VAR_1 ) ; List < TYPE_1 > VAR_5 = new ArrayList < TYPE_1 > ( 1 ) ; VAR_5 . add ( VAR_2 ) ; return VAR_5 ; } 
<START> private double METHOD_1 ( long [ ] VAR_1 ) { <END> return null == VAR_1 ? 0 : VAR_1 . length ; } 
public static void METHOD_1 ( String [ ] args ) throws Exception { <START> TYPE_1 VAR_1 = new TYPE_1 ( args [ 0 ] , args [ 1 ] ) ; <END> VAR_2 . set ( INT_1 ) ; VAR_1 . METHOD_2 ( VAR_3 , STRING_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , String job , Map < String , String > VAR_2 ) throws IOException { TYPE_2 request = new TYPE_2 ( ) ; <START> request . VAR_3 ( METHOD_2 ( VAR_1 ) ) ; <END> METHOD_3 ( VAR_1 , job , VAR_2 , request ) ; } 
TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_3 instanceof TYPE_4 ; <START> this . VAR_6 = VAR_3 . getName ( ) . METHOD_1 ( STRING_1 ) == 0 ; <END> } 
<START> public void start ( ) { <END> this . VAR_1 = TYPE_1 . build ( ) . name ( VAR_2 ) . METHOD_1 ( STRING_1 ) . METHOD_2 ( STRING_2 ) . METHOD_3 ( VAR_3 ) ; trace = VAR_1 . METHOD_4 ( STRING_3 ) ; debug = VAR_1 . METHOD_4 ( STRING_4 ) ; info = VAR_1 . METHOD_4 ( STRING_5 ) ; warn = VAR_1 . METHOD_4 ( STRING_6 ) ; error = VAR_1 . METHOD_4 ( STRING_7 ) ; super . start ( ) ; } 
public void METHOD_1 ( TYPE_1 user ) { VAR_1 = false ; METHOD_2 ( ) ; <START> Log . e ( STRING_1 , STRING_2 ) ; <END> ( ( TYPE_2 ) VAR_2 ) . METHOD_1 ( user ) ; if ( ( ( TYPE_3 ) METHOD_3 ( ) ) . METHOD_4 ( ) ) { TYPE_4 . METHOD_5 ( this ) . METHOD_6 ( ) ; ( ( TYPE_3 ) METHOD_3 ( ) ) . METHOD_7 ( false ) ; } } 
public TYPE_1 METHOD_1 ( final Map parameters , final List values ) { <START> properties . add ( new TYPE_2 ( STRING_1 , parameters , STRING_2 , ( List ) METHOD_2 ( values ) ) ) ; <END> return this ; } 
private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 ) { <START> for ( TYPE_4 VAR_3 : VAR_1 . METHOD_2 ( ) ) { <END> if ( VAR_2 == TYPE_3 . METHOD_3 ( VAR_3 . getType ( ) ) ) { return VAR_4 . map ( VAR_3 , TYPE_5 . class ) ; } } METHOD_4 ( VAR_1 , STRING_1 + VAR_2 + STRING_2 ) ; throw new TYPE_6 ( Response . Status . VAR_5 , VAR_1 ) ; } 
public static boolean METHOD_1 ( final TYPE_1 resource ) { final TYPE_2 VAR_1 = resource . VAR_2 ( TYPE_4 . VAR_4 ) ; final boolean status = ( VAR_1 != null && TYPE_3 . equals ( VAR_1 . getValue ( ) . trim ( ) ) ) ; <START> LOGGER . debug ( STRING_1 , resource . getKey ( ) , VAR_1 != null ? VAR_1 . getValue ( ) : null , status ) ; <END> return status ; } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 state = ( TYPE_1 ) o ; <START> if ( id != state . id ) return false ; <END> if ( count != state . count ) return false ; return source != null ? source . equals ( state . source ) : state . source == null ; } 
public synchronized void METHOD_1 ( ) { try { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( VAR_2 ) ; LOGGER . error ( STRING_1 ) ; try { TYPE_2 . METHOD_3 ( VAR_1 ) ; } catch ( TYPE_3 e ) { throw new IllegalStateException ( STRING_2 , e ) ; } } catch ( TYPE_3 VAR_3 ) { <START> LOGGER . error ( STRING_3 , VAR_3 ) ; <END> } try { TYPE_2 . METHOD_4 ( this ) ; } catch ( TYPE_3 e ) { throw new IllegalStateException ( STRING_4 , e ) ; } } 
private void METHOD_1 ( ) { <START> if ( VAR_1 != null && ! VAR_1 . METHOD_2 ( ) ) { <END> VAR_1 . METHOD_3 ( true ) ; } state . VAR_2 ( new TYPE_1 ( this ) ) ; Utils . execute ( state . VAR_3 ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 ) { <START> if ( ! METHOD_2 ( ) ) { <END> int VAR_2 = ( ( this . METHOD_3 ( ) - 1 ) * VAR_3 ) ; int VAR_4 = Math . VAR_5 ( VAR_6 . size ( ) - ( ( this . METHOD_3 ( ) - 1 ) * VAR_3 ) , VAR_3 ) ; return VAR_6 . METHOD_4 ( VAR_2 , VAR_2 + VAR_4 ) ; } } return VAR_6 ; } 
<START> public void METHOD_1 ( TYPE_1 task , final TYPE_2 VAR_1 , List < TYPE_2 > VAR_2 ) { <END> if ( task . VAR_3 ( ) != null && task . VAR_3 ( ) . size ( ) > 0 ) { for ( String VAR_4 : task . VAR_3 ( ) ) { TYPE_2 VAR_5 = METHOD_2 ( VAR_1 , task ) ; METHOD_1 ( METHOD_3 ( VAR_4 ) , VAR_5 , VAR_2 ) ; } } else { TYPE_2 VAR_5 = METHOD_2 ( VAR_1 , task ) ; VAR_2 . add ( VAR_5 ) ; } } 
public int METHOD_1 ( ) { <START> if ( VAR_1 != null && VAR_1 . METHOD_1 ( ) != - 1 ) { <END> return VAR_1 . METHOD_1 ( ) ; } else if ( VAR_2 != null ) { return VAR_2 . METHOD_1 ( ) ; } else { return - 1 ; } } 
<START> public static TYPE_1 METHOD_1 ( ) <END> { TYPE_1 VAR_1 = TYPE_2 . create ( TYPE_1 . class ) . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . create ( STRING_1 ) , TYPE_3 . create ( STRING_2 ) , TYPE_3 . create ( STRING_3 ) , TYPE_3 . create ( STRING_4 ) ) ; return VAR_1 ; } 
public File METHOD_1 ( File source , File target ) throws IOException { if ( target . VAR_1 ( ) ) { <START> Path path = TYPE_1 . METHOD_1 ( source . VAR_2 ( ) , TYPE_2 . get ( target . VAR_3 ( ) , source . getName ( ) ) , <END> VAR_4 ) ; return path . VAR_5 ( ) ; } this . METHOD_2 ( source , target ) ; return target ; } 
public void METHOD_1 ( TYPE_1 < ? > target ) { try { METHOD_2 ( ) . METHOD_1 ( file , target . VAR_1 ( ) ) ; <START> this . file = target . VAR_1 ( ) ; <END> } catch ( IOException e ) { throw new TYPE_2 ( STRING_1 + this , e ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 context ) { return TYPE_1 . from ( super . METHOD_1 ( context ) , getClass ( ) ) . name ( STRING_1 ) . description ( STRING_2 ) <START> . METHOD_2 ( super . METHOD_1 ( context ) . METHOD_3 ( ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { File file = File . VAR_1 ( STRING_1 , STRING_2 ) ; file . VAR_2 ( ) ; try ( TYPE_1 write = new TYPE_1 ( file ) ) { write . append ( STRING_3 ) ; TYPE_2 < ? > VAR_3 = factory . create ( file ) . METHOD_2 ( TYPE_2 . class ) ; Assert . assertEquals ( file . length ( ) , VAR_3 . METHOD_3 ( ) ) ; <START> file . VAR_4 ( ) ; <END> } } 
public boolean METHOD_1 ( TYPE_1 < TYPE_2 > method , TYPE_3 < TYPE_2 > VAR_1 ) { String VAR_2 = method . VAR_3 ( ) . getName ( ) ; String VAR_4 = VAR_1 . METHOD_2 ( ) . getName ( ) ; <START> return VAR_2 . equals ( VAR_4 ) ; <END> } 
<START> public TYPE_1 < T > METHOD_1 ( final String name ) <END> { throw new RuntimeException ( STRING_1 ) ; } 
public static TYPE_1 METHOD_1 ( ) { return TYPE_2 . create ( TYPE_1 . class , STRING_1 ) . METHOD_2 ( TYPE_3 . class , TYPE_4 . class , TYPE_5 . class , TYPE_6 . class , TYPE_7 . class , TYPE_8 . class , <START> TYPE_9 . class , TYPE_10 . class ) <END> . METHOD_3 ( METHOD_4 ( ) ) . METHOD_3 ( METHOD_5 ( ) ) ; } 
public void METHOD_1 ( final String VAR_1 ) throws Exception { final TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_1 ) . METHOD_4 ( ) , TYPE_1 . class ) ; final TYPE_4 VAR_3 = new TYPE_4 ( VAR_2 , VAR_4 , VAR_5 . METHOD_5 ( ) , VAR_6 ) ; if ( VAR_7 == null ) { <START> VAR_7 = new TYPE_5 ( new ArrayList < > ( ) ) ; <END> } VAR_7 . add ( VAR_3 ) ; } 
public boolean METHOD_1 ( final Collection < String > VAR_1 ) { <START> this . VAR_1 . addAll ( VAR_1 ) ; <END> return true ; } 
public String toString ( ) { return STRING_1 + STRING_2 + type + <START> STRING_3 + VAR_1 + CHAR_1 + <END> STRING_4 + VAR_2 + CHAR_1 + STRING_5 + VAR_3 + STRING_6 + VAR_4 + STRING_7 + VAR_5 + CHAR_2 ; } 
public T call ( ) throws Exception { try { TYPE_1 . METHOD_1 ( VAR_1 ) ; TYPE_2 . METHOD_2 ( VAR_2 ) ; TYPE_3 . bind ( VAR_3 ) ; TYPE_3 . bind ( VAR_4 ) ; TYPE_4 . METHOD_3 ( VAR_5 ) ; return VAR_6 . call ( ) ; } finally { TYPE_1 . METHOD_4 ( ) ; <START> TYPE_2 . METHOD_2 ( null ) ; <END> TYPE_3 . METHOD_5 ( ) ; TYPE_3 . METHOD_6 ( ) ; TYPE_4 . METHOD_3 ( VAR_5 ) ; } } 
public List < TYPE_1 > METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final TYPE_4 context ) throws TYPE_5 { <START> return VAR_3 . execute ( true , TYPE_5 . class , new TYPE_6 < List < TYPE_1 > > ( ) { <END> @Override public List < TYPE_1 > METHOD_2 ( final TYPE_7 VAR_4 ) { final TYPE_8 VAR_5 = VAR_4 . METHOD_3 ( TYPE_8 . class ) ; return VAR_6 . METHOD_4 ( VAR_5 , TYPE_9 . VAR_8 , VAR_1 , VAR_2 , context ) ; } } ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return TYPE_2 < TYPE_1 > METHOD_2 ( VAR_2 ) ; <END> } 
private static TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 , final Integer VAR_2 ) { <START> return VAR_1 . METHOD_2 ( new TYPE_1 ( VAR_2 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = VAR_2 . METHOD_1 ( ) ; <START> if ( VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) != 0 || VAR_1 . METHOD_2 ( TYPE_1 . VAR_4 ) != 0 ) { <END> return TYPE_1 . VAR_3 ; } return VAR_1 ; } 
private boolean METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) <START> if ( VAR_2 != null ) return false ; <END> return true ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { final String VAR_1 = METHOD_2 ( true ) ; <START> return METHOD_1 ( VAR_1 ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final Long offset , final Long VAR_1 , final boolean VAR_2 , final boolean VAR_3 , final TYPE_3 < TYPE_4 > properties , final TYPE_5 context ) { <START> return VAR_4 . METHOD_1 ( offset , VAR_1 , VAR_2 , properties , context , VAR_5 . METHOD_2 ( context ) ) ; <END> } 
public TYPE_1 METHOD_1 ( final String VAR_1 , final boolean VAR_2 , final boolean VAR_3 , final TYPE_2 < TYPE_3 > properties , final TYPE_4 VAR_4 ) <START> throws TYPE_5 { <END> final TYPE_1 VAR_5 = VAR_6 . METHOD_1 ( VAR_1 , VAR_2 , properties , VAR_4 , VAR_7 . METHOD_2 ( VAR_4 ) ) ; if ( VAR_5 == null ) { throw new TYPE_5 ( TYPE_6 . VAR_9 , VAR_1 ) ; } return VAR_5 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final String VAR_1 , final Long offset , final Long VAR_2 , final boolean VAR_3 , final boolean VAR_4 , final TYPE_3 < TYPE_4 > properties , final TYPE_5 context ) { <START> return VAR_5 . METHOD_1 ( VAR_1 , offset , VAR_2 , VAR_3 , properties , context , VAR_6 . METHOD_2 ( context ) ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final String VAR_1 , final Long offset , final Long VAR_2 , final String VAR_3 , final boolean VAR_4 , final boolean VAR_5 , final TYPE_3 < TYPE_4 > properties , final TYPE_5 context ) throws TYPE_6 { <START> return VAR_6 . METHOD_1 ( VAR_1 , offset , VAR_2 , VAR_3 , VAR_4 , properties , context , VAR_7 . METHOD_2 ( context ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = null ; synchronized ( this ) { while ( VAR_1 == null ) { if ( VAR_2 >= VAR_3 . size ( ) ) { return null ; } Iterator < TYPE_2 > VAR_4 = VAR_3 . get ( VAR_2 ) ; <START> if ( ! VAR_4 . hasNext ( ) ) { VAR_2 ++ ; continue ; } VAR_1 = VAR_4 . next ( ) ; <END> } } return VAR_5 . METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; } 
public static void METHOD_1 ( ANNOTATION_1 TYPE_1 state , ANNOTATION_1 TYPE_1 VAR_1 ) { if ( state . VAR_2 ( ) ) { state . VAR_3 ( false ) ; state . VAR_4 ( VAR_1 . METHOD_2 ( ) ) ; } <START> else { <END> state . VAR_4 ( state . VAR_5 ( ) + VAR_1 . METHOD_2 ( ) ) ; } } 
private static Response METHOD_1 ( TYPE_1 builder , TYPE_2 response ) { <START> response . VAR_1 ( ) . METHOD_2 ( ) . forEach ( ( VAR_2 , values ) - > { <END> String name = VAR_2 . toString ( ) ; if ( METHOD_3 ( name ) || name . equalsIgnoreCase ( VAR_3 ) ) { values . forEach ( value - > builder . VAR_4 ( name , value ) ) ; } } ) ; return builder . build ( ) ; } 
<START> private boolean METHOD_1 ( Type type ) <END> { return type == TYPE_3 . VAR_2 || type == TYPE_2 . VAR_4 || type == TYPE_1 . VAR_6 ; } 
public TYPE_1 METHOD_1 ( Path path , TYPE_2 VAR_1 ) throws Exception { TYPE_3 VAR_2 = VAR_3 . getStatus ( METHOD_2 ( path ) ) ; TYPE_4 VAR_4 = new TYPE_4 ( VAR_2 . METHOD_3 ( ) , VAR_1 ) ; TYPE_5 VAR_5 = VAR_3 . METHOD_1 ( VAR_4 , TYPE_6 . METHOD_4 ( ) ) ; <START> return new TYPE_1 ( new TYPE_7 ( VAR_5 , VAR_6 . METHOD_1 ( path , VAR_1 ) , VAR_7 ) ) ; <END> } 
public static TYPE_1 METHOD_1 ( int VAR_1 , List < TYPE_2 > VAR_2 , TYPE_3 VAR_3 ) { return new TYPE_1 ( VAR_1 , VAR_3 , <START> TYPE_4 . VAR_5 , <END> Optional . of ( VAR_2 ) , Optional . empty ( ) ) ; } 
public static TYPE_1 METHOD_1 ( int VAR_1 , List < Type > VAR_2 , TYPE_2 VAR_3 ) { return new TYPE_1 ( VAR_1 , VAR_3 , <START> TYPE_3 . VAR_5 , <END> Optional . empty ( ) , Optional . of ( VAR_2 ) ) ; } 
public boolean METHOD_1 ( String VAR_1 , long VAR_2 , boolean VAR_3 ) { <START> if ( VAR_3 && ! VAR_4 . METHOD_2 ( VAR_2 ) ) { <END> return false ; } return VAR_5 . METHOD_2 ( VAR_1 , VAR_2 ) ; } 
public Builder METHOD_1 ( String VAR_1 ) { <START> METHOD_2 ( ! this . VAR_1 . isPresent ( ) , STRING_1 ) ; <END> this . VAR_2 . add ( VAR_1 ) ; return this ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } <START> if ( ( obj == null ) || ( getClass ( ) != obj . getClass ( ) ) ) { <END> return false ; } TYPE_1 o = ( TYPE_1 ) obj ; return TYPE_2 . equals ( VAR_1 , o . VAR_1 ) && TYPE_2 . equals ( VAR_2 , o . VAR_2 ) && TYPE_2 . equals ( VAR_3 , o . VAR_3 ) ; } 
public TYPE_2 ( long VAR_2 , String VAR_3 , Thread VAR_4 , TYPE_1 split ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; <START> this . VAR_5 = false ; <END> this . split = split ; } 
protected void METHOD_1 ( TYPE_1 binder ) { METHOD_2 ( config - > config . VAR_1 ( ) == TYPE_3 . TYPE_2 . NONE , METHOD_3 ( ) ) ; METHOD_2 ( config - > config . VAR_1 ( ) == TYPE_3 . TYPE_2 . VAR_4 , METHOD_4 ( ) ) ; METHOD_2 ( <START> config - > config . VAR_1 ( ) == TYPE_3 . TYPE_2 . VAR_5 , <END> METHOD_5 ( ) ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( METHOD_3 ( TYPE_1 . class ) . METHOD_4 ( null ) . METHOD_5 ( null ) . METHOD_6 ( STRING_1 ) . METHOD_7 ( false ) . METHOD_8 ( "" ) <START> . METHOD_9 ( TYPE_1 . TYPE_2 . NONE ) <END> . METHOD_10 ( null ) . METHOD_11 ( null ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 session , int VAR_1 , List < Type > VAR_2 ) { return new TYPE_3 ( VAR_1 , VAR_2 . stream ( ) . map ( type - > METHOD_2 ( VAR_3 , METHOD_3 ( type , VAR_4 ) , METHOD_4 ( METHOD_5 ( session ) ) ) ) . collect ( METHOD_6 ( ) ) , <START> TYPE_4 . empty ( ) ) ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> return VAR_1 == that . VAR_1 && TYPE_2 . equals ( VAR_2 , that . VAR_2 ) ; <END> } 
public void start ( ) { if ( VAR_1 . METHOD_1 ( false , true ) ) { VAR_2 . METHOD_2 ( ( ) - > { try { METHOD_3 ( ) ; } catch ( Throwable t ) { log . error ( t , STRING_1 ) ; throw t ; } <START> <END> VAR_3 . METHOD_4 ( System . currentTimeMillis ( ) ) ; } , 1 , 1 , TimeUnit . VAR_4 ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( METHOD_3 ( TYPE_1 . class ) . METHOD_4 ( null ) . METHOD_5 ( null ) . METHOD_6 ( STRING_1 ) . METHOD_7 ( false ) <START> . METHOD_8 ( ( String ) null ) ) ; <END> } 
private TYPE_1 METHOD_1 ( Throwable VAR_1 , String message ) { METHOD_2 ( VAR_1 , TYPE_2 . class ) ; <START> METHOD_2 ( VAR_1 , TYPE_3 . class ) ; <END> METHOD_2 ( VAR_1 , TYPE_4 . class ) ; return new TYPE_1 ( VAR_1 , VAR_2 , message ) ; } 
private TYPE_1 METHOD_1 ( TYPE_3 . TYPE_4 . TYPE_1 VAR_1 ) { <START> switch ( VAR_1 ) { <END> case VAR_2 : return TYPE_1 . VAR_2 ; default : return TYPE_1 . VAR_3 ; } } 
<START> private List < TYPE_1 > METHOD_1 ( List < TYPE_3 . TYPE_1 > VAR_1 ) <END> { ImmutableList . Builder < TYPE_1 > VAR_2 = ImmutableList . builder ( ) ; for ( TYPE_3 . TYPE_1 VAR_3 : VAR_1 ) { VAR_2 . add ( new TYPE_1 ( VAR_3 . METHOD_2 ( ) , VAR_3 . METHOD_3 ( ) ? Optional . of ( METHOD_4 ( VAR_3 . METHOD_5 ( ) ) ) : Optional . empty ( ) , METHOD_4 ( VAR_3 . METHOD_6 ( ) ) ) ) ; } return VAR_2 . build ( ) ; } 
public static < T > Class < ? extends T > METHOD_1 ( TYPE_1 VAR_1 , Class < T > VAR_2 , Map < Long , TYPE_2 > VAR_3 , TYPE_3 VAR_4 ) { <START> try { <END> return METHOD_1 ( VAR_1 , VAR_2 , new TYPE_4 ( VAR_4 , VAR_3 ) ) ; } catch ( TYPE_5 VAR_5 ) { throw new TYPE_6 ( VAR_6 , VAR_7 ) ; } } 
private void METHOD_1 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 ) { for ( TYPE_3 VAR_2 : TYPE_3 . values ( ) ) { TYPE_2 session = METHOD_2 ( ) ; if ( VAR_2 == VAR_3 ) { session = TYPE_2 . builder ( METHOD_2 ( ) ) <START> . METHOD_3 ( VAR_4 , STRING_1 , STRING_2 ) <END> . build ( ) ; } VAR_1 . METHOD_4 ( session , VAR_2 ) ; } } 
private TYPE_1 METHOD_1 ( String query ) { TYPE_2 VAR_1 = METHOD_2 ( VAR_2 ) . METHOD_3 ( VAR_3 ) ; return METHOD_4 ( METHOD_5 ( ) ) . METHOD_6 ( VAR_1 . build ( ) ) <START> . METHOD_7 ( METHOD_8 ( METHOD_9 ( query , TYPE_3 . VAR_5 , false ) ) ) <END> . build ( ) ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 path , TYPE_3 options ) throws IOException { <START> List < TYPE_1 > VAR_1 = Arrays . stream ( VAR_2 . METHOD_1 ( METHOD_2 ( path ) ) ) . map ( this : : METHOD_3 ) . collect ( Collectors . VAR_3 ( ) ) ; <END> return VAR_1 ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { <START> Path path = METHOD_2 ( VAR_1 ) ; <END> TYPE_3 [ ] VAR_2 = VAR_3 . METHOD_3 ( path , 0 , path . toString ( ) . length ( ) ) ; Arrays . stream ( VAR_2 ) . map ( this : : METHOD_4 ) . collect ( Collectors . VAR_4 ( ) ) ; throw new TYPE_4 ( STRING_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 options ) throws IOException { TYPE_4 VAR_2 = VAR_3 . METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; <START> return new TYPE_5 ( VAR_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( Path path ) throws IOException { if ( VAR_1 . containsKey ( path ) ) { return METHOD_2 ( path , VAR_1 . get ( path ) . length ) ; <START> } <END> else { throw new TYPE_2 ( path . toString ( ) ) ; } } 
private static byte [ ] METHOD_1 ( String query , String VAR_1 , boolean VAR_2 ) { <START> if ( ! VAR_2 ) { <END> return format ( STRING_1 + STRING_2 , query , VAR_1 ) . METHOD_2 ( ) ; } else { return format ( STRING_3 , query ) . METHOD_2 ( ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 session , boolean VAR_1 , TYPE_3 VAR_2 ) { if ( VAR_1 ) { return METHOD_2 ( session ) ; } <START> if ( VAR_2 . equals ( VAR_3 ) || VAR_2 . equals ( VAR_4 ) ) { <END> return METHOD_3 ( session ) ; } return METHOD_4 ( session ) ; } 
public TYPE_1 ( List < Long > VAR_2 ) { this . VAR_2 = ImmutableList . VAR_3 ( METHOD_1 ( VAR_2 , STRING_1 ) ) ; <START> METHOD_2 ( ! VAR_2 . isEmpty ( ) , STRING_2 ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_4 = METHOD_1 ( VAR_3 , STRING_2 ) . METHOD_2 ( ) ; VAR_5 = new ArrayList < > ( ) ; <START> VAR_6 = new ArrayList < > ( ImmutableList . of ( INT_1 ) ) ; <END> } 
public boolean hasNext ( ) { <START> return VAR_1 < VAR_2 && input . VAR_3 ( ) ; <END> } 
TYPE_4 ( <START> long VAR_2 , <END> long VAR_3 , TYPE_1 VAR_4 , TYPE_2 VAR_5 ) throws IOException { this . VAR_5 = METHOD_1 ( VAR_5 , STRING_1 ) ; this . VAR_3 = VAR_3 ; METHOD_1 ( VAR_4 , STRING_2 ) ; VAR_4 . METHOD_2 ( VAR_2 ) ; this . input = new TYPE_3 ( VAR_4 ) ; } 
public void close ( ) { if ( VAR_1 ) { return ; } VAR_1 = true ; <START> VAR_2 = null ; <END> Throwable VAR_3 = null ; for ( TYPE_1 VAR_4 : VAR_5 ) { try { VAR_4 . close ( ) ; } catch ( Throwable t ) { if ( VAR_3 == null ) { VAR_3 = t ; } else if ( VAR_3 != t ) { VAR_3 . METHOD_1 ( t ) ; } } } if ( VAR_3 != null ) { throw new RuntimeException ( VAR_3 ) ; } } 
public TYPE_1 ( ) { <START> this . VAR_2 = METHOD_1 ( ) ; <END> } 
public void write ( TYPE_1 page ) throws IOException { VAR_1 += page . VAR_2 ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( page ) ; long VAR_4 = VAR_3 . size ( ) ; <START> if ( VAR_5 - VAR_6 < VAR_4 ) { <END> VAR_7 . write ( VAR_8 ) ; VAR_8 . clear ( ) ; VAR_6 = 0 ; VAR_1 = 0 ; } else { VAR_8 . add ( new TYPE_2 ( page ) ) ; VAR_6 += VAR_4 ; } } 
public TYPE_3 ( List < String > VAR_2 ) { <START> this . VAR_3 = VAR_2 . contains ( STRING_1 ) ; <END> if ( VAR_3 ) { METHOD_1 ( VAR_2 . size ( ) == 1 , STRING_2 ) ; this . VAR_4 = TYPE_1 . of ( ) ; } else { this . VAR_4 = VAR_2 . stream ( ) . map ( TYPE_2 : : METHOD_2 ) . collect ( METHOD_3 ( ) ) ; } } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( VAR_1 ) TYPE_1 input ) { if ( input == null ) { <START> return METHOD_2 ( STRING_1 ) ; <END> } return METHOD_2 ( METHOD_3 ( METHOD_4 ( input ) ) ) ; } 
public Object METHOD_1 ( TYPE_1 session , TYPE_2 VAR_1 , int position ) { if ( VAR_1 . METHOD_2 ( position ) ) { return null ; } TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( position , 0 , VAR_1 . METHOD_4 ( position ) ) ; <START> if ( VAR_2 == TYPE_4 . VAR_4 ) { return null ; } <END> return METHOD_5 ( VAR_2 ) . METHOD_6 ( ) ; } 
public void METHOD_1 ( TYPE_1 output ) { METHOD_2 ( output , VAR_1 ) ; output . VAR_2 ( VAR_3 ) ; METHOD_3 ( output ) ; if ( VAR_4 > 0 ) { try { output . VAR_5 ( VAR_6 , 0 , VAR_4 ) ; } catch ( Exception e ) { <START> e . VAR_7 ( ) ; <END> } } } 
<START> public String METHOD_1 ( ) <END> { return VAR_1 . METHOD_2 ( null ) ; } 
public void METHOD_1 ( TYPE_1 page ) { METHOD_2 ( page , STRING_1 ) ; if ( page . VAR_1 ( ) == 0 ) { return ; } page = VAR_2 . apply ( page ) ; VAR_3 . METHOD_3 ( page ) ; <START> System . out . println ( VAR_3 . METHOD_4 ( ) ) ; <END> VAR_4 . METHOD_5 ( page . VAR_5 ( ) , page . VAR_1 ( ) ) ; VAR_6 . METHOD_6 ( VAR_3 . METHOD_4 ( ) ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> switch ( VAR_1 . METHOD_2 ( ) ) { case VAR_2 : return TYPE_1 . VAR_2 ; case VAR_3 : return TYPE_1 . VAR_4 ; <END> default : throw new TYPE_2 ( format ( STRING_1 , VAR_1 . METHOD_2 ( ) ) ) ; } } 
public void METHOD_1 ( boolean VAR_1 ) { <START> this . VAR_2 . set ( VAR_1 ) ; <END> } 
<START> public Optional < TYPE_1 > METHOD_1 ( ) <END> { return VAR_1 ; } 
public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { <START> TYPE_3 < TYPE_2 , TYPE_4 > VAR_2 = new TYPE_3 < > ( ) ; <END> VAR_1 . forEach ( o - > VAR_2 . put ( o , METHOD_2 ( VAR_3 . get ( o ) , STRING_1 + o + STRING_2 + this ) ) ) ; return new TYPE_1 ( VAR_2 , from , filter ) ; } 
public TYPE_2 ( ) { <START> this ( ( ) - > METHOD_1 ( TYPE_1 . of ( STRING_1 , STRING_2 ) ) ) ; <END> } 
TYPE_1 ( Type type ) { <START> METHOD_1 ( type , STRING_1 ) ; <END> this . VAR_2 = type ; } 
public Optional < List < TYPE_1 > > METHOD_1 ( ) { <START> if ( VAR_1 . size ( ) == 0 ) { <END> return Optional . empty ( ) ; } return Optional . of ( VAR_1 . values ( ) . stream ( ) . map ( TYPE_2 : : METHOD_2 ) . collect ( Collectors . VAR_2 ( ) ) ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_5 . VAR_2 ) TYPE_2 value ) { <START> METHOD_2 ( value ) ; <END> TYPE_3 VAR_3 = TYPE_4 . METHOD_3 ( null , 2 ) ; TYPE_4 . METHOD_4 ( VAR_3 , METHOD_5 ( value ) ) ; TYPE_4 . METHOD_4 ( VAR_3 , METHOD_6 ( value ) ) ; return VAR_3 . build ( ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_2 . VAR_2 ) TYPE_1 value ) { <START> METHOD_2 ( value ) ; <END> return METHOD_3 ( value ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , VAR_1 , STRING_2 ) ; METHOD_2 ( STRING_3 , VAR_1 , STRING_4 ) ; METHOD_2 ( STRING_5 , VAR_1 , STRING_6 ) ; METHOD_2 ( STRING_7 , VAR_1 , STRING_8 ) ; METHOD_2 ( STRING_9 , VAR_1 , STRING_10 ) ; METHOD_2 ( STRING_11 , VAR_1 , STRING_12 ) ; <START> METHOD_3 ( STRING_13 , STRING_14 ) ; METHOD_3 ( STRING_15 , STRING_16 ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , VAR_1 , STRING_2 ) ; METHOD_2 ( STRING_3 , VAR_1 , STRING_4 ) ; METHOD_2 ( STRING_5 , VAR_1 , STRING_6 ) ; METHOD_2 ( STRING_7 , VAR_1 , STRING_8 ) ; METHOD_2 ( STRING_9 , VAR_1 , STRING_10 ) ; METHOD_2 ( STRING_11 , VAR_1 , STRING_12 ) ; METHOD_2 ( STRING_13 , VAR_1 , STRING_14 ) ; METHOD_2 ( STRING_15 , VAR_1 , STRING_16 ) ; <START> METHOD_3 ( STRING_17 , STRING_18 ) ; METHOD_3 ( STRING_19 , STRING_20 ) ; <END> } 
public TYPE_1 METHOD_1 ( Type type , int VAR_1 ) <START> throws IOException <END> { METHOD_2 ( type == VAR_2 ) ; TYPE_2 builder = type . VAR_3 ( null , VAR_1 ) ; for ( int i = 0 ; i < VAR_1 ; ++ i ) { type . VAR_4 ( builder , VAR_5 . METHOD_3 ( ) ) ; } return builder . build ( ) ; } 
public int METHOD_1 ( ) { int offset = row ; <START> ++ row ; <END> return offset ; } 
private static int METHOD_1 ( TYPE_1 VAR_1 , byte [ ] buffer , int offset , int length ) throws IOException { int position = offset ; int VAR_2 = 0 ; <START> while ( ( ( position - offset ) < length ) && VAR_2 != - 1 ) { <END> VAR_2 = VAR_1 . read ( buffer , position , offset + length - position ) ; if ( VAR_2 > 0 ) { position += VAR_2 ; } } return position - offset ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; <START> this . VAR_3 = METHOD_2 ( ) ; <END> } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) <END> { return VAR_1 . getPath ( ) . isEmpty ( ) ; } 
public Optional < TYPE_1 > METHOD_1 ( TYPE_2 session , TYPE_3 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) == VAR_2 . VAR_3 . TYPE_4 . VAR_5 ) { <END> return Optional . of ( METHOD_3 ( ) ) ; } return super . METHOD_1 ( session , VAR_1 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) <END> { return VAR_1 ; } 
<START> private List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , List < TYPE_3 > VAR_2 ) <END> { List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; VAR_2 . stream ( ) . forEach ( node - > VAR_3 . addAll ( VAR_1 . METHOD_2 ( ) . get ( node ) ) ) ; return ImmutableList . VAR_4 ( VAR_3 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( new TYPE_3 ( new TYPE_4 ( ) , new TYPE_5 ( ) , new TYPE_6 ( ) ) . METHOD_2 ( ) ) ; <START> assertEquals ( METHOD_3 ( VAR_1 ) , TYPE_7 . VAR_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return TYPE_1 . VAR_1 ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_2 . class ) . METHOD_4 ( null ) . METHOD_5 ( new TYPE_3 ( 1 , VAR_1 ) ) <START> . METHOD_6 ( new TYPE_3 ( 1 , VAR_2 ) ) <END> . METHOD_7 ( false ) ) ; } 
<START> protected TYPE_1 ( byte [ ] VAR_2 , boolean VAR_3 , byte [ ] VAR_4 , boolean VAR_5 , boolean VAR_6 ) <END> { super ( true , VAR_6 ) ; this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_5 ; this . VAR_7 = ! VAR_3 && ! VAR_5 && Arrays . equals ( VAR_4 , VAR_2 ) ; } 
public TYPE_4 ( ANNOTATION_1 TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_4 = METHOD_1 ( VAR_4 , STRING_2 ) ; <START> VAR_3 = METHOD_1 ( VAR_3 , STRING_3 ) ; <END> this . VAR_5 = VAR_3 . METHOD_2 ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 builder , TYPE_2 VAR_1 , TYPE_3 < ? extends TYPE_4 > VAR_2 ) { TYPE_1 VAR_3 = METHOD_1 ( builder , VAR_1 ) ; <START> for ( TYPE_4 VAR_4 : VAR_2 ) { <END> VAR_3 . METHOD_2 ( ) . put ( VAR_4 , builder . VAR_5 ( VAR_4 ) ) ; } return VAR_3 ; } 
public TYPE_2 ( ) { super ( ( ) - > METHOD_1 ( METHOD_2 ( ) , <START> TYPE_1 . of ( STRING_1 , STRING_2 ) , <END> TYPE_1 . of ( ) , Optional . empty ( ) ) ) ; } 
public void METHOD_1 ( long VAR_1 ) { VAR_2 . execute ( ( ) - > { try { <START> VAR_3 . METHOD_2 ( VAR_4 , VAR_5 , VAR_1 ) ; <END> } catch ( Exception exception ) { log . debug ( exception , STRING_1 , VAR_4 , VAR_5 , VAR_1 ) ; } } ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 ) { <END> return VAR_2 ; } if ( VAR_3 . METHOD_2 ( ) ) { return VAR_4 ; } return VAR_5 ; } 
public void start ( ) { if ( ! VAR_1 || VAR_2 . METHOD_1 ( true ) ) { <START> log . info ( STRING_1 ) ; <END> return ; } METHOD_2 ( ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( VAR_1 ) TYPE_2 input ) { TYPE_3 VAR_2 = METHOD_2 ( input ) ; <START> METHOD_3 ( STRING_1 , VAR_2 , VAR_3 ) ; <END> if ( VAR_2 . isEmpty ( ) ) { return null ; } int VAR_4 = VAR_2 . METHOD_4 ( ) ; TYPE_4 VAR_5 = TYPE_5 . METHOD_5 ( null , VAR_4 ) ; METHOD_6 ( VAR_2 , VAR_5 ) ; return VAR_5 . build ( ) ; } 
private boolean METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( ) && METHOD_3 ( VAR_2 ) && METHOD_4 ( VAR_2 ) ) { <END> if ( ! METHOD_5 ( VAR_2 ) ) { return false ; } } } return true ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> if ( VAR_1 instanceof TYPE_3 ) { <END> return VAR_2 . METHOD_2 ( ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) ) . getName ( ) . equals ( VAR_3 ) ; } return false ; } 
<START> private Map < String , Type > METHOD_1 ( String ... VAR_1 ) <END> { TYPE_1 . Builder < String , Type > builder = TYPE_1 . builder ( ) ; Arrays . stream ( VAR_1 ) . forEach ( VAR_2 - > builder . put ( VAR_2 , VAR_3 ) ) ; return builder . build ( ) ; } 
public boolean METHOD_1 ( double value ) { if ( Double . VAR_1 ( value ) ) { return VAR_2 ; } for ( TYPE_1 filter : VAR_3 ) { <START> if ( ( VAR_2 && Double . VAR_1 ( value ) ) || filter . VAR_4 ( value ) ) { <END> return true ; } } return false ; } 
private static boolean METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 connection ) throws TYPE_2 { TYPE_3 VAR_3 = connection . VAR_4 ( ) ; TYPE_4 results = VAR_3 . METHOD_2 ( STRING_1 + VAR_1 + STRING_2 ) ; TYPE_5 metadata = results . VAR_5 ( ) ; int VAR_6 = metadata . VAR_7 ( ) ; <START> for ( int i = 1 ; i <= VAR_6 ; i ++ ) { <END> if ( VAR_2 . equalsIgnoreCase ( metadata . VAR_8 ( i ) ) ) { return true ; } } return false ; } 
public void METHOD_1 ( ) { <START> TYPE_1 TYPE_2 = new TYPE_1 ( ) ; <END> TYPE_3 VAR_1 = new TYPE_3 < > ( new TYPE_4 ( ) . METHOD_2 ( 5 ) . METHOD_3 ( new TYPE_5 ( 10 , VAR_2 ) ) . METHOD_4 ( new TYPE_5 ( 100 , VAR_2 ) ) . METHOD_5 ( INT_1 ) , TYPE_6 : : METHOD_6 , TYPE_6 . class , TYPE_2 : : METHOD_7 ) ; VAR_1 . run ( STRING_1 , new TYPE_7 ( 5 , VAR_3 ) ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 ) { try { VAR_1 . run ( ) ; } catch ( Exception e ) { <START> log . info ( STRING_1 , e ) ; <END> } } 
public void METHOD_1 ( ) { long VAR_1 = VAR_2 . METHOD_2 ( STRING_1 , STRING_2 , true , false , null , 0 , false ) ; <START> assertNotNull ( VAR_1 ) ; <END> } 
<START> public Optional < TYPE_1 > METHOD_1 ( ) <END> { if ( ! VAR_1 && VAR_2 && VAR_3 . isPresent ( ) ) { VAR_4 = VAR_5 . METHOD_2 ( VAR_6 , VAR_3 ) ; VAR_1 = true ; } return VAR_4 ; } 
private < T > void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < TYPE_3 > VAR_2 , T [ ] VAR_3 ) { <START> try { <END> assertEquals ( VAR_1 . METHOD_2 ( ) , VAR_3 . length ) ; } catch ( Exception e ) { e . VAR_4 ( ) ; } for ( int position = 0 ; position < VAR_1 . METHOD_2 ( ) ; position ++ ) { METHOD_3 ( VAR_1 , VAR_2 , position , VAR_3 [ position ] , VAR_3 . getClass ( ) . METHOD_4 ( ) ) ; } } 
<START> public synchronized boolean METHOD_1 ( ) <END> { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; return VAR_1 . METHOD_4 ( ) && ! VAR_1 . METHOD_5 ( ) ; } 
public TYPE_1 < Long , Object > METHOD_1 ( ) { TYPE_2 properties = new TYPE_2 ( ) ; properties . VAR_1 ( VAR_2 , METHOD_2 ( ) ) ; properties . VAR_1 ( VAR_3 , TYPE_3 . class . getName ( ) ) ; properties . VAR_1 ( VAR_4 , TYPE_4 . class . getName ( ) ) ; <START> properties . VAR_1 ( VAR_5 , TYPE_5 . class . getName ( ) ) ; <END> properties . VAR_1 ( VAR_6 , STRING_1 ) ; return new TYPE_1 < > ( properties ) ; } 
public Object METHOD_1 ( TYPE_1 data ) throws Throwable { TYPE_2 VAR_1 = data . VAR_2 ( false ) ; <START> List < TYPE_3 > VAR_3 = new ArrayList < > ( ) ; <END> while ( VAR_1 . METHOD_2 ( ) > 0 ) { TYPE_3 VAR_4 = VAR_1 . METHOD_3 ( data . type , 0 ) ; VAR_3 . add ( VAR_4 ) ; } return VAR_3 ; } 
<START> protected final List < ? > METHOD_1 ( ) <END> { switch ( VAR_1 ) { case VAR_2 : return VAR_3 ; case VAR_4 : return TYPE_1 . METHOD_2 ( 0 , VAR_5 ) . METHOD_3 ( i - > i % 2 == 0 ? METHOD_4 ( ) : null ) . collect ( METHOD_5 ( ) ) ; default : return TYPE_1 . METHOD_2 ( 0 , VAR_5 ) . METHOD_3 ( i - > METHOD_4 ( ) ) . collect ( METHOD_5 ( ) ) ; } } 
<START> static String METHOD_1 ( int length ) <END> { String VAR_1 = STRING_1 ; StringBuilder VAR_2 = new StringBuilder ( length ) ; for ( int index = 0 ; index < length ; index ++ ) { int VAR_3 = ( int ) ( VAR_1 . length ( ) * Math . VAR_4 ( ) ) ; VAR_2 . append ( VAR_1 . METHOD_2 ( VAR_3 ) ) ; } return VAR_2 . toString ( ) ; } 
public void METHOD_1 ( ) { <START> long [ ] VAR_1 = { INT_1 , INT_2 } ; <END> long [ ] VAR_2 = { INT_3 , INT_2 } ; TYPE_1 VAR_3 = new TYPE_2 ( 1 , Optional . empty ( ) , VAR_1 ) ; TYPE_1 VAR_4 = new TYPE_2 ( 1 , Optional . empty ( ) , VAR_2 ) ; METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_3 , 0 , VAR_3 , 0 ) ) ; assertTrue ( TYPE_3 . METHOD_3 ( VAR_3 , 0 , VAR_4 , 0 ) ) ; } 
public TYPE_1 get ( ) { TYPE_1 VAR_1 ; ImmutableList . Builder < TYPE_2 > VAR_2 = ImmutableList . builder ( ) ; try ( TYPE_3 VAR_3 = VAR_4 . METHOD_1 ( ) ) { TYPE_4 VAR_5 = VAR_3 . METHOD_2 ( TYPE_4 . class ) ; TYPE_5 VAR_6 = VAR_5 . METHOD_3 ( VAR_7 , VAR_8 ) ; <START> VAR_2 . addAll ( VAR_5 . METHOD_4 ( VAR_9 , VAR_6 . METHOD_5 ( ) ) ) ; <END> VAR_1 = new TYPE_1 ( VAR_6 , VAR_2 . build ( ) ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { METHOD_2 ( METHOD_3 ( TYPE_1 . class ) <START> . METHOD_4 ( null ) . METHOD_5 ( STRING_1 ) . METHOD_6 ( STRING_2 ) . METHOD_7 ( null ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { VAR_1 = METHOD_2 ( ) ; VAR_2 = METHOD_3 ( VAR_1 ) ; VAR_3 = VAR_2 . METHOD_4 ( ) ; config = new TYPE_1 ( ) <START> . METHOD_5 ( VAR_4 ) . METHOD_6 ( VAR_5 ) ; <END> } 
private void METHOD_1 ( ) { METHOD_2 ( ) ; VAR_1 . METHOD_3 ( ) ; <START> session . VAR_2 ( ) . log ( ( ) - > STRING_1 ) ; <END> VAR_3 . METHOD_4 ( VAR_4 , VAR_5 - > ! VAR_5 . METHOD_5 ( ) ) ; } 
private synchronized void METHOD_1 ( TYPE_1 split ) { VAR_1 . add ( split ) ; <START> split . VAR_2 ( ) . METHOD_2 ( ) . log ( ( ) - > STRING_1 + split ) ; <END> VAR_3 . METHOD_3 ( split ) ; } 
public void start ( ) { try ( TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 , VAR_2 ) ) { METHOD_1 ( ) ; VAR_3 . start ( ) ; VAR_4 . start ( ) ; <START> session . VAR_5 ( ) . log ( ( ) - > String . format ( STRING_2 , VAR_2 ) ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; try { METHOD_2 ( ) ; if ( field . VAR_2 ( ) ) { VAR_1 = METHOD_3 ( ) ; } else { VAR_1 = METHOD_4 ( ) ; } } <START> catch ( IOException ex ) { <END> throw new TYPE_2 ( VAR_3 , STRING_1 + VAR_4 , ex ) ; } VAR_5 = 0 ; VAR_6 = 0 ; return VAR_1 ; } 
private void METHOD_1 ( String query , byte [ ] VAR_1 ) { byte [ ] VAR_2 = ( byte [ ] ) METHOD_2 ( query ) . METHOD_3 ( ) ; for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { System . err . METHOD_4 ( VAR_2 [ i ] + STRING_1 ) ; <START> } <END> assertEquals ( METHOD_2 ( query ) . METHOD_3 ( ) , VAR_1 ) ; } 
public TYPE_2 ( TYPE_1 input , boolean VAR_2 ) { this . input = input ; this . VAR_2 = VAR_2 ; <START> VAR_3 = input . VAR_4 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> return VAR_1 ; } } 
private List < TYPE_1 > METHOD_1 ( ) { synchronized ( VAR_1 ) { TYPE_2 VAR_2 = this ; <START> List < TYPE_1 > result = new ArrayList < > ( VAR_2 . METHOD_2 ( ) ) ; <END> while ( VAR_2 . METHOD_3 ( ) . isPresent ( ) ) { VAR_2 = VAR_2 . METHOD_3 ( ) . get ( ) ; result . addAll ( VAR_2 . METHOD_2 ( ) ) ; } return ImmutableList . VAR_3 ( result ) ; } } 
public TYPE_1 ( ) { <START> super ( TYPE_2 . VAR_3 ) ; <END> } 
public Double METHOD_1 ( int start , int length ) { <START> assertTrue ( length < VAR_1 ) ; <END> double [ ] VAR_2 = new double [ 2 * length ] ; for ( int i = 0 ; i < length ; i ++ ) { VAR_2 [ i ] = ( double ) ( start + i ) ; VAR_2 [ i + length ] = ( double ) ( start + i ) ; } return METHOD_2 ( VAR_2 ) ; } 
<START> public Set < Class < ? > > METHOD_1 ( ) <END> { return TYPE_1 . of ( TYPE_2 . class ) ; } 
private static < T extends TYPE_1 > Optional < T > METHOD_1 ( TYPE_2 VAR_1 , Class < T > VAR_2 ) { List < TYPE_1 > VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; switch ( VAR_3 . size ( ) ) { case 0 : return Optional . empty ( ) ; case 1 : <START> return Optional . of ( ( T ) METHOD_3 ( VAR_3 ) ) ; <END> default : throw new IllegalStateException ( format ( STRING_1 , VAR_2 ) ) ; } } 
<START> public TYPE_1 METHOD_1 ( ) <END> { return target ; } 
private int METHOD_1 ( String VAR_1 ) { try { double p = Double . VAR_2 ( VAR_1 ) ; if ( p < 0 || p > 1 ) { throw new TYPE_1 ( VAR_3 , STRING_1 ) ; } double VAR_4 = p * FLOAT_1 ; if ( VAR_4 == Math . VAR_5 ( VAR_4 ) ) { return ( int ) VAR_4 ; } } catch ( TYPE_2 VAR_6 ) { } return - 1 ; <START> } <END> 
public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_1 context ) { context = node . VAR_1 ( ) . METHOD_2 ( this , context ) ; METHOD_3 ( context , STRING_1 ) ; METHOD_4 ( VAR_2 , STRING_2 ) ; METHOD_4 ( node . VAR_3 ( ) . equals ( TYPE_2 . TYPE_4 . VAR_5 ) , STRING_3 ) ; return context . VAR_6 ( TYPE_3 . METHOD_5 ( node ) , node . VAR_7 ( ) ) . METHOD_6 ( node . VAR_8 ( ) ) ; <START> } <END> 
<START> public String METHOD_1 ( String path ) <END> { return METHOD_2 ( TYPE_1 . builder ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_2 . create ( String . format ( STRING_1 , METHOD_5 ( ) , path ) ) ) , Optional . empty ( ) , Optional . VAR_1 ( VAR_2 . METHOD_6 ( ) ) ) ; } 
public TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( TYPE_2 node , TYPE_3 context ) { <START> TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = new TYPE_1 < > ( ) ; <END> VAR_1 . put ( node , null ) ; return VAR_1 ; } 
public TYPE_1 < T > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <START> return METHOD_1 ( VAR_1 , VAR_2 , METHOD_2 ( ) ) ; <END> } 
public TYPE_5 ( ) { this . VAR_2 = TYPE_1 . METHOD_1 ( ) ; this . VAR_3 = new TYPE_2 ( VAR_2 ) ; this . VAR_4 = new TYPE_3 ( VAR_2 ) ; this . VAR_5 = new TYPE_4 ( TYPE_1 ) ; <START> } <END> 
<START> public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) <END> { return new TYPE_1 ( VAR_1 . METHOD_2 ( ) ) ; } 
public static < T > TYPE_1 < T > METHOD_1 ( TYPE_2 VAR_1 ) { <START> return new TYPE_1 < > ( Optional . empty ( ) , VAR_1 , METHOD_2 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String VAR_3 ) { <START> if ( false && ! METHOD_2 ( VAR_1 , VAR_2 ) ) { <END> METHOD_3 ( VAR_4 , VAR_3 ) ; } } 
<START> Type METHOD_1 ( TYPE_1 VAR_1 ) <END> { if ( VAR_1 . METHOD_2 ( ) . equals ( VAR_2 ) ) { return VAR_3 ; } else { return VAR_1 . METHOD_2 ( ) ; } } 
private int METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) ) { switch ( VAR_1 ) { case VAR_2 : return Long . VAR_3 ; case VAR_4 : return TYPE_4 . VAR_3 ; case VAR_6 : return Double . VAR_3 ; case VAR_7 : default : return Integer . VAR_3 ; } } <START> else { <END> return VAR_8 . METHOD_3 ( ) ; } } 
<START> static int METHOD_1 ( int VAR_1 ) { <END> return TYPE_1 . METHOD_2 ( VAR_1 , FLOAT_1 ) ; } 
<START> static long METHOD_1 ( int VAR_1 ) { <END> int VAR_2 = METHOD_2 ( VAR_1 ) ; long VAR_3 = METHOD_3 ( VAR_2 ) ; long VAR_4 = METHOD_4 ( VAR_1 ) ; long VAR_5 = METHOD_3 ( VAR_1 ) ; return VAR_3 + VAR_4 + VAR_5 ; } 
private void METHOD_1 ( int VAR_1 ) throws IOException { if ( VAR_2 != null ) { int VAR_3 = VAR_2 . METHOD_2 ( VAR_1 ) ; if ( VAR_4 != null ) { VAR_4 . METHOD_1 ( VAR_3 ) ; } <START> if ( VAR_5 != null ) { <END> VAR_5 . METHOD_1 ( VAR_3 ) ; } } else { if ( VAR_4 != null ) { VAR_4 . METHOD_1 ( VAR_1 ) ; } VAR_5 . METHOD_1 ( VAR_1 ) ; } } 
<START> protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <END> { VAR_2 = true ; return TYPE_3 . METHOD_1 ( VAR_1 , ( ) - > VAR_2 = false ) ; } 
TYPE_1 METHOD_1 ( int VAR_1 , boolean VAR_2 , boolean [ ] VAR_3 , long [ ] values ) { <START> TYPE_1 VAR_4 = new TYPE_2 ( VAR_1 , Optional . VAR_5 ( VAR_2 ? VAR_3 : null ) , values ) ; <END> return VAR_4 ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 ) ; METHOD_2 ( STRING_2 ) ; METHOD_2 ( STRING_3 ) ; METHOD_2 ( STRING_4 ) ; METHOD_2 ( STRING_5 ) ; METHOD_2 ( STRING_6 ) ; METHOD_2 ( STRING_7 ) ; METHOD_2 ( STRING_8 ) ; METHOD_2 ( STRING_9 ) ; METHOD_2 ( STRING_10 ) ; METHOD_2 ( STRING_11 ) ; <START> METHOD_2 ( STRING_12 ) ; <END> } 
private long METHOD_1 ( String name ) { <START> return VAR_1 . METHOD_2 ( TYPE_1 . class ) . METHOD_3 ( STRING_1 , name , false , true , null , 0 , false ) ; <END> } 
public void start ( ) { <START> log . info ( STRING_1 , VAR_1 , VAR_2 ) ; <END> if ( ! VAR_1 || VAR_2 . METHOD_1 ( true ) ) { log . info ( STRING_2 ) ; return ; } METHOD_2 ( ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( STRING_1 ) ; <END> METHOD_2 ( STRING_2 , INT_1 ) ; METHOD_2 ( STRING_3 ) ; METHOD_2 ( STRING_4 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( metadata . VAR_1 ( VAR_2 , VAR_3 ) ) ; try { TYPE_1 VAR_4 = <START> METHOD_3 ( TYPE_2 . of ( ) , METHOD_4 ( VAR_3 ) <END> . column ( STRING_1 , VAR_5 ) . column ( STRING_2 , TYPE_3 . METHOD_5 ( ImmutableList . of ( VAR_5 ) ) ) ) ; metadata . VAR_6 ( VAR_2 , VAR_4 , false ) ; METHOD_6 ( ) ; } catch ( TYPE_4 e ) { assertEquals ( e . VAR_7 ( ) , TYPE_5 . METHOD_7 ( ) ) ; } } 
public void METHOD_1 ( ) { for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_2 [ i ] = VAR_3 . METHOD_2 ( ) ; VAR_4 [ i ] = VAR_3 . METHOD_3 ( VAR_1 / 10 ) ; VAR_5 [ i ] = i ; <START> if ( i % INT_1 == 0 ) { <END> VAR_6 [ i ] = true ; } } } 
synchronized Map < TYPE_1 , Map < String , Long > > METHOD_1 ( ) { return VAR_1 . keySet ( ) . stream ( ) <START> . collect ( METHOD_2 ( METHOD_3 ( ) , VAR_2 - > METHOD_1 ( VAR_2 ) ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 < TYPE_4 > context ) { TYPE_4 VAR_1 = context . get ( ) ; <START> if ( ! METHOD_2 ( VAR_1 ) . contains ( new TYPE_5 ( node . VAR_2 ( ) . getName ( ) ) ) ) { <END> return METHOD_3 ( node , context ) ; } return METHOD_4 ( node , context ) ; } 
public void METHOD_1 ( long position , byte [ ] buffer ) <START> throws IOException <END> { } 
<START> public int METHOD_1 ( ) <END> { return VAR_1 . length ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 session , TYPE_3 metadata , TYPE_4 VAR_2 , TYPE_5 VAR_3 ) { METHOD_2 ( metadata , STRING_1 ) ; <START> METHOD_2 ( VAR_2 , STRING_2 ) ; <END> if ( VAR_1 instanceof TYPE_6 ) { return VAR_1 ; } return new TYPE_7 ( session , metadata , VAR_2 , VAR_3 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_8 : : new , VAR_1 ) ; } 
<START> protected TYPE_1 ( TYPE_1 VAR_1 ) <END> { VAR_2 = VAR_1 . VAR_2 . METHOD_1 ( ) ; } 
public static void output ( ANNOTATION_1 TYPE_1 state , TYPE_2 out ) { TYPE_3 VAR_1 = state . VAR_2 ( ) ; <START> double result = VAR_1 == null ? Double . TYPE_5 : VAR_1 . METHOD_1 ( ) ; <END> TYPE_4 . METHOD_2 ( out , result ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_1 , STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( VAR_3 , VAR_4 , TYPE_4 . class . METHOD_3 ( ) ) ; return new TYPE_4 ( VAR_2 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , <START> TYPE_5 . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 page ) { METHOD_2 ( page , STRING_1 ) ; if ( page . VAR_1 ( ) == 0 ) { return ; } page = VAR_2 . apply ( page ) ; if ( VAR_3 ) { <START> VAR_4 . METHOD_3 ( page ) ; <END> } else { VAR_4 . METHOD_4 ( page ) ; } VAR_5 . METHOD_5 ( page . VAR_6 ( ) , page . VAR_1 ( ) ) ; long VAR_7 = VAR_4 . METHOD_6 ( ) ; VAR_8 . METHOD_7 ( VAR_7 + VAR_9 ) ; } 
private static void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( STRING_1 , VAR_2 ) ; VAR_1 . METHOD_3 ( STRING_2 , VAR_2 ) ; <START> VAR_1 . METHOD_3 ( STRING_3 , VAR_3 ) ; <END> VAR_1 . METHOD_3 ( STRING_4 , VAR_2 ) ; VAR_1 . METHOD_3 ( STRING_5 , VAR_2 ) ; VAR_1 . METHOD_3 ( STRING_6 , VAR_2 ) ; VAR_1 . METHOD_3 ( STRING_7 , VAR_2 ) ; VAR_1 . METHOD_3 ( STRING_8 , VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 page ) { METHOD_2 ( page ) ; int VAR_1 = page . VAR_2 ( ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { <START> VAR_3 [ i ] = METHOD_3 ( VAR_4 , page . VAR_5 ( i ) ) ; <END> } for ( int i = 0 ; i < VAR_6 . length ; i ++ ) { VAR_6 [ i ] . METHOD_4 ( VAR_3 , VAR_7 , VAR_8 , VAR_9 ) ; } } 
public void close ( ) { try ( TYPE_1 VAR_1 = TYPE_1 . create ( ) ) { <START> VAR_1 . METHOD_1 ( ( ) - > TYPE_2 . close ( ) ) ; <END> VAR_1 . METHOD_1 ( ( ) - > TYPE_3 . close ( ) ) ; } catch ( IOException e ) { throw new TYPE_4 ( e ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 > VAR_2 ) throws IOException { TYPE_2 . TYPE_4 VAR_3 = VAR_2 . get ( VAR_4 . METHOD_2 ( ) ) . METHOD_3 ( VAR_4 . METHOD_4 ( ) ) . METHOD_5 ( ) ; <START> if ( VAR_3 == VAR_5 || VAR_3 == VAR_6 || VAR_3 == VAR_7 ) { <END> VAR_8 = VAR_9 ; } else if ( VAR_3 == VAR_10 ) { VAR_8 = VAR_11 ; } else { throw new IllegalArgumentException ( STRING_1 + VAR_3 ) ; } VAR_8 . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
private TYPE_2 ( ) { <START> super ( VAR_2 , VAR_3 , TYPE_1 . METHOD_1 ( ) ) ; <END> } 
private TYPE_2 ( ) { <START> super ( VAR_2 , VAR_3 , TYPE_1 . METHOD_1 ( ) ) ; <END> } 
<START> public void METHOD_1 ( ) <END> { VAR_1 = new TYPE_1 ( ) ; VAR_2 = new TYPE_2 ( VAR_1 , new TYPE_3 ( VAR_1 ) , new TYPE_4 ( ) ) ; session = METHOD_2 ( ) . build ( ) ; } 
protected TYPE_1 ( ) { <START> super ( ( ) - > METHOD_1 ( ) ) ; <END> } 
public static TYPE_1 call ( TYPE_2 VAR_1 , String name , Type VAR_2 , List < TYPE_3 > VAR_3 ) { TYPE_4 VAR_4 = VAR_1 . METHOD_1 ( name , METHOD_2 ( VAR_3 . stream ( ) . map ( TYPE_3 : : getType ) . collect ( METHOD_3 ( ) ) ) ) ; <START> return new TYPE_1 ( name , VAR_4 , VAR_2 , VAR_3 ) ; <END> } 
<START> public static Optional < TYPE_1 > METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 , TYPE_4 VAR_2 ) <END> { METHOD_2 ( VAR_1 , STRING_1 ) ; List < TYPE_3 > VAR_3 = ImmutableList . VAR_4 ( VAR_1 ) ; if ( VAR_3 . isEmpty ( ) ) { return Optional . empty ( ) ; } return Optional . of ( new TYPE_1 ( VAR_1 , VAR_2 ) ) ; } 
private TYPE_4 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 VAR_3 ) { METHOD_1 ( VAR_2 , STRING_1 ) ; METHOD_1 ( VAR_3 , STRING_2 ) ; this . VAR_2 = ImmutableList . VAR_4 ( VAR_2 ) ; <START> this . VAR_3 = VAR_3 ; <END> METHOD_2 ( ! this . VAR_2 . isEmpty ( ) , STRING_3 ) ; } 
private TYPE_1 < TYPE_2 , Optional < TYPE_2 > > METHOD_1 ( TYPE_3 node ) { return VAR_1 - > { METHOD_2 ( VAR_1 instanceof TYPE_4 , STRING_1 ) ; if ( node . VAR_2 ( ) . contains ( VAR_1 ) ) { return Optional . of ( VAR_1 ) ; <START> } <END> if ( node . VAR_3 ( ) . contains ( VAR_1 ) ) { return Optional . of ( ( node . VAR_4 ( ) . get ( VAR_1 ) ) ) ; } return Optional . empty ( ) ; } ; } 
<START> public TYPE_1 ( boolean VAR_2 ) <END> { this . VAR_2 = VAR_2 ; } 
<START> private boolean METHOD_1 ( Optional < TYPE_1 > VAR_1 , Optional < TYPE_2 > VAR_2 ) <END> { if ( VAR_1 . isPresent ( ) && VAR_2 . isPresent ( ) ) { return METHOD_1 ( VAR_1 . get ( ) , VAR_2 . get ( ) ) ; } return VAR_1 . isPresent ( ) == VAR_2 . isPresent ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , Set < TYPE_2 > VAR_2 ) { Map < TYPE_2 , TYPE_3 > VAR_3 = VAR_1 . METHOD_2 ( ) <START> . entrySet ( ) . stream ( ) <END> . filter ( entry - > VAR_2 . contains ( entry . getKey ( ) ) ) . collect ( METHOD_3 ( Map . Entry : : getKey , Map . Entry : : getValue ) ) ; return new TYPE_1 ( VAR_1 . METHOD_4 ( ) , VAR_3 ) ; } 
<START> TYPE_1 ( TYPE_1 VAR_1 ) <END> { this ( VAR_1 . VAR_2 , VAR_1 . VAR_3 , VAR_1 . max ) ; for ( int i = 0 ; i < VAR_2 ; ++ i ) { VAR_4 [ i ] = VAR_1 . VAR_4 [ i ] ; } } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; <START> VAR_2 . close ( ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( VAR_1 , format ( STRING_1 , path ) ) ; <END> } 
private void METHOD_1 ( String path ) { TYPE_1 VAR_1 = new TYPE_1 ( path ) ; try { <START> ImmutableList < TYPE_2 > VAR_2 = TYPE_3 . stream ( VAR_1 ) . collect ( METHOD_2 ( ) ) ; <END> METHOD_3 ( STRING_1 ) ; } catch ( TYPE_4 e ) { assertTrue ( e . getMessage ( ) . startsWith ( STRING_2 ) ) ; } } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) <END> { if ( METHOD_2 ( VAR_1 ) ) { return METHOD_3 ( VAR_1 ) instanceof TYPE_2 ; } return VAR_1 instanceof TYPE_3 ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , STRING_2 ) ; METHOD_2 ( STRING_3 , STRING_4 ) ; METHOD_2 ( STRING_5 , STRING_6 ) ; METHOD_2 ( STRING_7 , STRING_2 ) ; METHOD_2 ( STRING_8 , STRING_2 ) ; METHOD_2 ( STRING_9 , STRING_4 ) ; METHOD_2 ( STRING_10 , STRING_10 ) ; METHOD_2 ( STRING_11 , STRING_12 ) ; <START> METHOD_2 ( STRING_13 , STRING_13 ) ; <END> METHOD_2 ( STRING_14 , STRING_14 ) ; METHOD_2 ( STRING_15 , STRING_15 ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_5 . VAR_2 ) long value ) { <START> TYPE_2 VAR_3 = TYPE_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( TYPE_4 . VAR_5 ) ) ; <END> VAR_3 . add ( value ) ; return VAR_3 . METHOD_4 ( ) ; } 
private static TYPE_1 METHOD_1 ( String name ) { TYPE_2 VAR_1 = new TYPE_2 ( STRING_1 ) ; TYPE_3 VAR_2 = new TYPE_4 ( new TYPE_5 ( name ) , new TYPE_6 ( new TYPE_7 ( STRING_2 ) , new TYPE_8 ( ) , TYPE_9 . create ( ) , <START> Optional . of ( TYPE_12 . VAR_4 ) ) , <END> ImmutableList . of ( VAR_1 ) , TYPE_10 . of ( VAR_1 , new TYPE_11 ( STRING_1 ) ) ) ; return METHOD_2 ( VAR_2 ) ; } 
private TYPE_1 METHOD_1 ( Optional < TYPE_2 > VAR_1 ) { Optional < TYPE_3 > VAR_2 ; Optional < TYPE_4 > VAR_3 ; if ( VAR_4 ) { VAR_2 = Optional . of ( new TYPE_5 ( ) ) ; VAR_3 = Optional . of ( new TYPE_6 ( ) ) ; } else { VAR_2 = Optional . empty ( ) ; VAR_3 = Optional . empty ( ) ; } <START> return new TYPE_1 ( VAR_5 , VAR_2 , VAR_3 , VAR_1 ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 key = this . key ; if ( key == null || key . VAR_1 ( ) ) { throw new TYPE_2 ( VAR_2 , STRING_1 ) ; } <START> else { <END> return key ; } } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 key = this . key ; <START> if ( key == null || key . VAR_1 ( ) ) { <END> throw new TYPE_2 ( VAR_2 , STRING_1 ) ; } return key ; } 
<START> long METHOD_1 ( int VAR_1 , long value ) <END> { if ( VAR_2 != null ) { return VAR_3 [ VAR_1 ] ? VAR_4 [ ( int ) value ] : value ; } return VAR_4 [ ( int ) value ] ; } 
protected void METHOD_1 ( int VAR_1 , boolean VAR_2 ) { <START> if ( values == null ) { <END> values = new int [ VAR_1 ] ; } else if ( values == null || values . length < VAR_1 ) { values = METHOD_2 ( values , VAR_1 ) ; if ( VAR_3 != null ) { VAR_3 = METHOD_2 ( VAR_3 , VAR_1 ) ; } } if ( VAR_2 && VAR_3 == null ) { VAR_3 = new boolean [ values . length ] ; } } 
<START> int METHOD_1 ( long value , int VAR_1 ) <END> { if ( VAR_2 != null && ! VAR_3 [ VAR_1 ] ) { return METHOD_2 ( value + VAR_4 ) ; } return METHOD_2 ( value ) ; } 
public void METHOD_1 ( ) { <START> double length = FLOAT_1 ; <END> METHOD_2 ( STRING_1 , null ) ; METHOD_2 ( STRING_2 , FLOAT_2 ) ; METHOD_2 ( STRING_3 , FLOAT_2 ) ; METHOD_2 ( STRING_4 , length ) ; METHOD_2 ( STRING_5 , length ) ; METHOD_2 ( STRING_6 , FLOAT_3 ) ; METHOD_2 ( STRING_7 , null ) ; METHOD_2 ( STRING_8 , length ) ; METHOD_2 ( STRING_9 , 2 * length ) ; METHOD_2 ( STRING_10 , length ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 name , List < TYPE_3 > VAR_1 ) { <START> return VAR_2 . METHOD_2 ( name , VAR_1 ) ; <END> } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { super ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_1 ) ; <START> this . VAR_5 = new TYPE_4 ( METHOD_1 ( VAR_4 , STRING_2 ) ) ; <END> this . VAR_6 = new TYPE_5 ( VAR_4 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; state = TYPE_1 . VAR_3 ; VAR_4 . close ( ) ; <START> VAR_5 . set ( null ) ; <END> } 
public List < Type > METHOD_1 ( ) { List < Type > parameters = new ArrayList < > ( VAR_1 . size ( ) + 1 ) ; <START> VAR_1 . stream ( ) <END> . forEach ( parameters : : add ) ; parameters . add ( VAR_2 ) ; return METHOD_2 ( parameters ) ; } 
TYPE_2 ( long VAR_2 , Map < String , Object > VAR_3 ) { for ( Object VAR_4 : VAR_3 . values ( ) ) { METHOD_1 ( VAR_4 == null || VAR_4 instanceof Long || VAR_4 instanceof Double || VAR_4 instanceof TYPE_1 , STRING_1 , VAR_4 == null ? STRING_2 : VAR_4 . getClass ( ) . getName ( ) ) ; } this . VAR_2 = VAR_2 ; <START> this . VAR_3 = METHOD_2 ( METHOD_3 ( VAR_3 , STRING_3 ) ) ; <END> } 
public void METHOD_1 ( ) { Set < Type > VAR_1 = METHOD_2 ( ) ; for ( Type VAR_2 : VAR_1 ) { for ( Type VAR_3 : VAR_1 ) { if ( VAR_4 . METHOD_3 ( VAR_2 , VAR_3 ) && VAR_2 != VAR_5 && VAR_3 != VAR_5 ) { try { <START> VAR_6 . METHOD_4 ( TYPE_2 . VAR_8 , VAR_2 . METHOD_5 ( ) , VAR_3 . METHOD_5 ( ) ) ; <END> } catch ( TYPE_1 e ) { METHOD_6 ( format ( STRING_1 , VAR_2 , VAR_3 ) ) ; } } } } } 
<START> static List < TYPE_1 > METHOD_1 ( TYPE_2 source ) <END> throws Exception { ImmutableList . Builder < TYPE_1 > TYPE_3 = ImmutableList . builder ( ) ; while ( ! source . VAR_1 ( ) ) { source . VAR_2 ( VAR_3 , 100 ) . get ( ) . METHOD_2 ( ) . stream ( ) . map ( TYPE_1 . class : : METHOD_3 ) . forEach ( TYPE_3 : : add ) ; } return TYPE_3 . build ( ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 session , TYPE_3 VAR_1 , List < TYPE_4 > parameters , TYPE_5 VAR_2 , TYPE_6 VAR_3 ) <END> { TYPE_7 VAR_4 = METHOD_2 ( session , VAR_1 , parameters , VAR_3 ) ; TYPE_8 VAR_5 = new TYPE_8 ( session , VAR_6 , VAR_2 , metadata , VAR_7 , VAR_8 , VAR_9 , VAR_3 ) ; return VAR_5 . METHOD_3 ( VAR_4 ) ; } 
public TYPE_3 ( TYPE_1 config ) { METHOD_1 ( config , STRING_1 ) ; <START> METHOD_2 ( config , TYPE_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> } 
public static Boolean METHOD_1 ( ANNOTATION_1 ( VAR_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ( VAR_1 ) TYPE_1 VAR_3 ) { <START> if ( VAR_2 == null ) { <END> return VAR_3 == null ; } if ( VAR_3 == null ) { return false ; } return METHOD_2 ( VAR_2 ) . METHOD_3 ( METHOD_2 ( VAR_3 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , List < TYPE_2 > VAR_3 ) { <START> METHOD_2 ( VAR_1 , STRING_1 ) ; <END> METHOD_3 ( VAR_2 == 0 , STRING_2 ) ; METHOD_3 ( VAR_4 != null , STRING_3 ) ; METHOD_1 ( VAR_1 , VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . add ( METHOD_2 ( VAR_1 , STRING_1 ) ) ; <END> } 
static TYPE_1 of ( Type type , Object VAR_1 , Object ... VAR_2 ) { <START> TYPE_2 < TYPE_3 > set = new TYPE_2 < > ( VAR_2 . length + 1 ) ; <END> set . add ( TYPE_3 . create ( type , VAR_1 ) ) ; for ( Object value : VAR_2 ) { set . add ( TYPE_3 . create ( type , value ) ) ; } return new TYPE_1 ( type , true , set ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 context , TYPE_3 session , Path VAR_1 , boolean VAR_2 ) { if ( METHOD_2 ( session , context , VAR_1 ) ) { Path VAR_3 = METHOD_3 ( session , context , VAR_4 , VAR_1 ) ; return new TYPE_1 ( VAR_1 , VAR_3 , VAR_2 , VAR_5 ) ; } <START> else { <END> return new TYPE_1 ( VAR_1 , VAR_1 , VAR_2 , VAR_2 ? VAR_6 : VAR_7 ) ; } } 
public static TYPE_1 METHOD_1 ( double VAR_1 , double VAR_2 ) { <START> TYPE_2 . METHOD_2 ( VAR_1 , VAR_2 ) ; <END> TYPE_1 VAR_3 = TYPE_3 . METHOD_3 ( null , 2 ) ; TYPE_3 . METHOD_4 ( VAR_3 , VAR_1 ) ; TYPE_3 . METHOD_4 ( VAR_3 , VAR_2 ) ; return VAR_3 ; } 
public static Double METHOD_1 ( TYPE_1 VAR_1 , List < Long > VAR_2 , TYPE_1 . TYPE_3 VAR_3 ) { if ( VAR_2 . get ( 0 ) . equals ( VAR_2 . get ( 1 ) ) ) { return null ; } <START> else { <END> return VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) . get ( 1 ) . METHOD_3 ( ) ; } } 
public static void input ( ANNOTATION_1 TYPE_1 state , ANNOTATION_2 ( TYPE_4 . VAR_2 ) double value , ANNOTATION_2 ( TYPE_4 . VAR_2 ) double VAR_3 , ANNOTATION_2 ( TYPE_4 . VAR_2 ) double VAR_4 ) { TYPE_2 . input ( state , value , <START> TYPE_3 . METHOD_1 ( VAR_3 , VAR_4 ) ) ; <END> } 
public TYPE_1 split ( ANNOTATION_1 ( STRING_1 ) Type VAR_1 , ANNOTATION_2 ( TYPE_3 . VAR_3 ) TYPE_2 string , ANNOTATION_2 ( TYPE_3 . VAR_3 ) TYPE_2 VAR_4 , ANNOTATION_2 ( TYPE_3 . VAR_3 ) TYPE_2 VAR_5 ) { <START> return METHOD_1 ( VAR_6 , VAR_1 , string , VAR_4 , VAR_5 , null ) ; <END> } 
public TYPE_1 split ( ANNOTATION_1 ( STRING_1 ) Type VAR_1 , ANNOTATION_2 ( TYPE_4 . VAR_3 ) TYPE_2 string , ANNOTATION_2 ( TYPE_4 . VAR_3 ) TYPE_2 VAR_4 , ANNOTATION_2 ( TYPE_4 . VAR_3 ) TYPE_2 VAR_5 , ANNOTATION_2 ( STRING_2 ) TYPE_3 VAR_6 ) <START> { <END> return METHOD_1 ( VAR_7 , VAR_1 , string , VAR_4 , VAR_5 , VAR_6 ) ; } 
<START> public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 session , ANNOTATION_1 ( STRING_1 ) String VAR_2 , List < TYPE_3 > VAR_3 ) <END> { Set < TYPE_3 > VAR_4 = VAR_1 . execute ( session , VAR_2 ) . METHOD_2 ( ) . stream ( ) . map ( TYPE_4 : : METHOD_3 ) . collect ( METHOD_4 ( ) ) ; for ( TYPE_3 VAR_5 : VAR_3 ) { if ( ! VAR_4 . contains ( VAR_5 ) ) { METHOD_5 ( STRING_2 + VAR_5 ) ; } } } 
public TYPE_1 METHOD_1 ( final TYPE_2 configuration ) { <START> VAR_1 = TYPE_3 . METHOD_2 ( configuration . get ( STRING_1 ) ) ; <END> return new TYPE_1 ( VAR_1 , new HashMap < > ( ) ) ; } 
private static void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = TYPE_1 . valueOf ( VAR_1 ) ; TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_2 , false ) ; ByteBuffer buffer = ByteBuffer . VAR_4 ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <START> long VAR_5 = METHOD_5 ( TYPE_4 . METHOD_6 ( buffer ) ) ; <END> assertEquals ( VAR_5 , VAR_2 . METHOD_7 ( ) ) ; } 
TYPE_1 METHOD_1 ( Path path ) throws IOException { String VAR_1 = METHOD_2 ( uri ) ; String key = METHOD_3 ( path ) ; TYPE_1 VAR_2 = METHOD_1 ( path , VAR_1 , key ) ; if ( VAR_2 == null && ! key . isEmpty ( ) ) { <START> METHOD_4 ( ! key . VAR_3 ( VAR_4 ) , STRING_1 , VAR_4 ) ; <END> return METHOD_1 ( path , VAR_1 , key + VAR_4 ) ; } return VAR_2 ; } 
public Object METHOD_1 ( ) { <START> return ( boolean ) TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> } 
public Object [ ] [ ] METHOD_1 ( ) <START> { <END> return new Object [ ] [ ] { { true } , { false } , { true , true , true } , { false , false , false } , { true , false , true , false } , } ; } 
public void METHOD_1 ( ) { <START> List < Object > VAR_1 = new ArrayList < > ( ) ; <END> METHOD_2 ( ImmutableList . of ( ) , 0 , 0 ) ; } 
public Builder METHOD_1 ( Optional < Path > VAR_1 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; <START> this . VAR_1 = VAR_1 ; <END> return this ; } 
private TYPE_1 METHOD_1 ( ) { return TYPE_1 . METHOD_1 ( ) . METHOD_2 ( <START> this . VAR_1 , <END> this . VAR_2 , this . VAR_3 , this . VAR_4 ) . METHOD_3 ( this . VAR_5 + 1 ) . METHOD_4 ( VAR_6 ) . METHOD_5 ( TYPE_2 . class ) ; } 
public void METHOD_1 ( ) { try ( TYPE_1 VAR_1 = TYPE_1 . create ( ) ) { VAR_1 . METHOD_2 ( TYPE_2 : : clear ) ; for ( Entry < String , TYPE_3 > entry : TYPE_2 . entrySet ( ) ) { VAR_1 . METHOD_2 ( entry . getValue ( ) ) ; } <START> VAR_1 . METHOD_2 ( ( ) - > TYPE_4 . METHOD_3 ( ) ) ; <END> } catch ( IOException e ) { throw new TYPE_5 ( e ) ; } } 
<START> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <END> { TYPE_3 table = client . VAR_2 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) ) ; if ( table == null ) { return null ; } return new TYPE_1 ( VAR_1 , client . VAR_3 ( table ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { try { return METHOD_2 ( ) . METHOD_3 ( VAR_2 ) . METHOD_4 ( VAR_3 , FLOAT_1 ) <START> . run ( STRING_1 , ( ) - > { <END> return VAR_1 . METHOD_5 ( ) . execute ( ) . METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; } ) ; } catch ( InterruptedException e ) { Thread . VAR_5 ( ) . METHOD_8 ( ) ; throw new RuntimeException ( e ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 table ) { if ( table . VAR_1 ( ) . isPresent ( ) ) { return METHOD_2 ( table . VAR_1 ( ) . get ( ) ) ; } List < TYPE_3 > VAR_2 = METHOD_3 ( table ) ; <START> return METHOD_2 ( VAR_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 session , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; METHOD_2 ( session , STRING_2 ) ; <START> METHOD_2 ( VAR_3 , STRING_3 ) ; <END> METHOD_2 ( VAR_2 , STRING_4 ) ; return TYPE_7 . METHOD_3 ( new TYPE_8 ( ) , VAR_1 ) ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , TYPE_1 source , TYPE_1 VAR_4 ) { <START> return node ( TYPE_2 . class , source , VAR_4 ) . METHOD_2 ( new TYPE_3 ( VAR_1 , VAR_2 , VAR_3 , Optional . empty ( ) ) ) ; <END> } 
public String toString ( ) { return METHOD_1 ( this ) . add ( STRING_1 , VAR_1 ) . add ( STRING_2 , VAR_2 ) . add ( STRING_3 , VAR_3 ) <START> . add ( STRING_4 , VAR_4 . METHOD_2 ( null ) ) <END> . toString ( ) ; } 
public TYPE_1 apply ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , Context context ) { TYPE_4 VAR_3 = METHOD_1 ( context . VAR_4 ( ) ) ; switch ( VAR_3 ) { case VAR_5 : return TYPE_1 . METHOD_2 ( METHOD_3 ( VAR_1 , context ) ) ; case VAR_6 : return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_4 ( VAR_6 ) ) ; case VAR_7 : return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_4 ( VAR_8 ) ) ; default : <START> throw new TYPE_5 ( STRING_1 + VAR_3 ) ; <END> } } 
private static int METHOD_1 ( int size ) { <START> return METHOD_2 ( new TYPE_1 ( size , TYPE_1 . TYPE_2 . VAR_2 ) . METHOD_3 ( ) ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 , TYPE_4 session , TYPE_5 VAR_2 ) { return value - > ( ( TYPE_6 ) value ) . METHOD_2 ( ) <START> . METHOD_3 ( ( ) - > new IllegalStateException ( STRING_1 ) ) ; <END> } 
public void add ( TYPE_1 VAR_1 , int position ) { METHOD_1 ( VAR_1 , STRING_1 ) ; METHOD_2 ( position >= 0 , STRING_2 ) ; if ( VAR_1 . METHOD_3 ( position ) ) { <START> if ( ! VAR_2 ) { <END> VAR_2 = true ; } } int VAR_3 = METHOD_4 ( VAR_1 , position ) ; if ( VAR_4 . get ( VAR_3 ) == VAR_5 ) { METHOD_5 ( VAR_3 , VAR_1 , position ) ; } } 
private void METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 , int position ) { VAR_3 . METHOD_2 ( VAR_2 , position , VAR_4 ) ; if ( VAR_4 . METHOD_3 ( ) - VAR_5 > VAR_6 ) { throw new TYPE_2 ( VAR_7 , format ( STRING_1 , VAR_8 , VAR_9 ) ) ; } VAR_10 . set ( VAR_1 , VAR_4 . METHOD_4 ( ) - 1 ) ; <START> if ( ++ size >= VAR_11 ) { <END> METHOD_5 ( ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 context ) { return METHOD_2 ( node , node . VAR_1 ( ) , node . VAR_2 ( ) , <START> TYPE_4 . equals ( node . VAR_3 ( ) , TYPE_2 . TYPE_5 . VAR_5 ) ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = METHOD_2 ( VAR_1 ) ; <START> if ( ! TYPE_2 . contains ( VAR_2 ) ) { <END> return false ; } return true ; } 
private static String METHOD_1 ( List < TYPE_1 > VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return VAR_2 ; } <START> return VAR_1 . stream ( ) . map ( TYPE_1 : : getName ) . collect ( Collectors . VAR_3 ( STRING_1 ) ) ; <END> } 
<START> TYPE_7 ( <END> TYPE_1 configuration , Path path , TYPE_2 VAR_2 , long VAR_3 , TYPE_3 VAR_4 , List < TYPE_4 > VAR_5 , TYPE_5 VAR_6 , TYPE_6 VAR_7 ) { super ( configuration , path , VAR_2 , VAR_3 , METHOD_1 ( VAR_4 , VAR_5 ) , VAR_5 , VAR_6 , VAR_7 ) ; } 
public void METHOD_1 ( String host , int VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 ) { <START> METHOD_2 ( ! METHOD_3 ( host ) , STRING_1 ) ; <END> METHOD_2 ( ! METHOD_3 ( VAR_2 ) , STRING_2 ) ; METHOD_2 ( ! METHOD_3 ( VAR_3 ) , STRING_3 ) ; METHOD_2 ( ! METHOD_3 ( VAR_4 ) , STRING_4 ) ; METHOD_2 ( ! METHOD_3 ( VAR_5 ) , STRING_5 ) ; super . METHOD_1 ( host , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , true ) ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , Path path ) { if ( VAR_1 instanceof TYPE_2 ) { try { return METHOD_2 ( ( TYPE_2 ) VAR_1 , path ) . map ( VAR_2 - > ( VAR_2 instanceof TYPE_3 ) || ( VAR_2 instanceof TYPE_4 ) ) . METHOD_3 ( true ) ; } catch ( TYPE_5 e ) { <START> LOG . error ( e , STRING_1 , VAR_1 . getClass ( ) . getName ( ) ) ; <END> return false ; } } return false ; } 
public TYPE_2 ( ANNOTATION_1 ( STRING_1 ) String VAR_2 , ANNOTATION_1 ( STRING_2 ) String VAR_3 ) { <START> this . VAR_4 = new TYPE_1 ( METHOD_1 ( VAR_2 . METHOD_2 ( VAR_5 ) , STRING_3 ) , METHOD_1 ( VAR_3 . METHOD_2 ( VAR_5 ) , STRING_4 ) ) ; <END> } 
protected String METHOD_1 ( Type type ) { if ( TYPE_1 . equals ( type ) ) { return STRING_1 ; } <START> else if ( TYPE_2 . equals ( type ) ) { <END> return STRING_2 ; } return super . METHOD_1 ( type ) ; } 
public TYPE_1 METHOD_1 ( Type VAR_1 , Type VAR_2 ) { try { return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; } <START> catch ( TYPE_2 e ) { <END> if ( ! ( e instanceof TYPE_3 ) ) { throw e ; } } throw new TYPE_3 ( TYPE_4 . VAR_5 , ImmutableList . of ( VAR_1 . METHOD_2 ( ) ) , VAR_2 . METHOD_2 ( ) ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : TYPE_2 . values ( ) ) { <START> if ( VAR_1 . getName ( ) . equals ( TYPE_3 . METHOD_2 ( VAR_2 ) ) ) { <END> return true ; } } return false ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 ) ; TYPE_4 VAR_3 = new TYPE_4 ( ) ; TYPE_5 VAR_4 = new TYPE_5 ( VAR_1 , VAR_2 , VAR_3 ) ; <START> return new TYPE_1 ( VAR_1 , VAR_2 , new TYPE_4 ( ) , VAR_4 ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) != null && VAR_2 . METHOD_3 ( VAR_1 . METHOD_2 ( ) ) == VAR_3 ) { return new TYPE_1 ( VAR_1 . getType ( ) , VAR_1 . getMessage ( ) , VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_6 ( ) , VAR_1 . METHOD_7 ( ) , TYPE_2 . METHOD_8 ( ) , VAR_1 . METHOD_2 ( ) ) ; } <START> else { <END> return VAR_1 ; } } 
public static int METHOD_1 ( TYPE_1 VAR_1 , int offset , int length , int VAR_2 , boolean VAR_3 ) { int VAR_4 = length ; if ( VAR_3 ) { <START> VAR_4 = METHOD_2 ( VAR_1 , offset , length , VAR_2 ) ; <END> } else if ( VAR_2 >= 0 && length > VAR_2 ) { VAR_4 = METHOD_3 ( VAR_1 , offset , length , VAR_2 ) ; } return VAR_4 ; } 
public static void METHOD_1 ( String [ ] args ) throws Throwable { TYPE_1 data = new TYPE_1 ( ) ; data . VAR_1 ( ) ; new TYPE_2 ( ) . METHOD_2 ( data ) ; TYPE_3 options = new TYPE_4 ( ) . METHOD_3 ( TYPE_7 . VAR_3 ) <START> . METHOD_4 ( TYPE_6 . VAR_5 ) <END> . METHOD_5 ( STRING_1 + TYPE_2 . class . METHOD_6 ( ) + STRING_1 ) . build ( ) ; new TYPE_5 ( options ) . run ( ) ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 , location , VAR_2 , VAR_3 , VAR_4 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 , TYPE_3 > VAR_1 ) { TYPE_3 VAR_2 = new TYPE_3 ( VAR_3 , VAR_4 ) ; VAR_1 . apply ( VAR_2 ) ; TYPE_4 VAR_5 = VAR_2 . build ( ) ; <START> VAR_6 . add ( VAR_5 ) ; <END> return this ; } 
public TYPE_1 build ( ) { if ( VAR_1 . isEmpty ( ) ) { <START> VAR_1 = Collections . VAR_2 ( VAR_3 . METHOD_1 ( ) . size ( ) , METHOD_2 ( VAR_4 ) ) ; <END> } return new TYPE_1 ( VAR_5 , VAR_1 , VAR_6 ) ; } 
public TYPE_1 build ( ) { <START> if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { <END> VAR_1 = METHOD_1 ( VAR_2 . METHOD_2 ( ) . size ( ) , METHOD_3 ( VAR_3 ) ) ; } return new TYPE_1 ( VAR_4 , VAR_1 , VAR_5 . build ( ) ) ; } 
private void METHOD_1 ( String VAR_1 , String ... VAR_2 ) { <START> METHOD_2 ( format ( STRING_1 , ImmutableList . VAR_3 ( VAR_2 ) . stream ( ) <END> . map ( VAR_4 - > VAR_4 . equalsIgnoreCase ( STRING_2 ) ? STRING_2 : format ( STRING_3 , VAR_4 ) ) . collect ( Collectors . VAR_5 ( STRING_4 ) ) ) , VAR_6 , VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 session , TYPE_4 VAR_2 ) { Set < TYPE_5 > VAR_3 = VAR_4 . METHOD_2 ( ) ; <START> METHOD_3 ( ! VAR_3 . isEmpty ( ) , STRING_1 ) ; <END> return METHOD_4 ( METHOD_5 ( ( long ) VAR_3 . size ( ) * VAR_5 ) ) ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { METHOD_2 ( VAR_2 ) ; <START> TYPE_3 < ? > VAR_3 = this . VAR_3 ; <END> synchronized ( this ) { for ( TYPE_2 VAR_4 : VAR_1 ) { METHOD_3 ( ! VAR_4 . METHOD_4 ( ) ) ; VAR_5 . add ( VAR_4 ) ; } } VAR_3 . set ( null ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 session , TYPE_4 VAR_2 ) { <START> return METHOD_2 ( <END> VAR_3 . METHOD_3 ( ) . size ( ) , value - > { throw new TYPE_5 ( VAR_4 , STRING_1 ) ; } ) ; } 
<START> public TYPE_2 ( TYPE_1 ... VAR_2 ) <END> { super ( VAR_3 , ImmutableList . of ( METHOD_1 ( STRING_1 ) ) , ImmutableList . of ( ) , METHOD_2 ( STRING_2 ) , ImmutableList . VAR_4 ( VAR_2 ) ) ; } 
<START> protected Optional < TYPE_1 > METHOD_1 ( TYPE_2 node , TYPE_3 context ) <END> { if ( node . getValue ( ) instanceof TYPE_4 ) { return METHOD_2 ( new TYPE_5 ( ( ( TYPE_4 ) node . getValue ( ) ) . getValue ( ) ) ) ; } return METHOD_2 ( node . getValue ( ) ) . map ( VAR_1 - > METHOD_3 ( input , VAR_1 ) ) ; } 
public TYPE_4 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_2 ) TYPE_2 < TYPE_3 > VAR_3 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_3 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_4 ) ; <START> this . session = Optional . empty ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 context ) { TYPE_4 VAR_1 = context . VAR_2 . stream ( ) . METHOD_2 ( TYPE_4 . METHOD_3 ( ) , TYPE_5 : : METHOD_4 ) ; return new TYPE_1 ( <START> VAR_1 . METHOD_5 ( ) , <END> context . VAR_3 + VAR_1 . METHOD_6 ( ) ) ; } 
<START> List < TYPE_1 > METHOD_1 ( ) <END> { List < Type > VAR_1 = new ArrayList < > ( ) ; int VAR_2 = 1 ; VAR_1 . add ( VAR_3 ) ; VAR_1 . add ( VAR_3 ) ; VAR_1 . add ( VAR_3 ) ; VAR_1 . add ( VAR_3 ) ; TYPE_2 VAR_4 = METHOD_2 ( VAR_2 , VAR_1 ) ; return VAR_4 . build ( ) ; } 
public boolean equals ( Object o ) { <START> new RuntimeException ( STRING_1 ) . METHOD_1 ( ) ; <END> if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; return VAR_1 == that . VAR_1 ; } 
public void METHOD_1 ( ) { try ( TYPE_1 connection = this . connection ; TYPE_2 VAR_1 = this . VAR_1 ) { connection . VAR_2 ( ) ; } catch ( TYPE_3 e ) { throw new TYPE_4 ( VAR_3 , e ) ; } finally { try { <START> VAR_4 . METHOD_2 ( VAR_5 ) ; <END> } catch ( Exception e ) { log . warn ( e , format ( STRING_1 , VAR_5 . METHOD_3 ( ) ) ) ; } } } 
private static TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( ) { @Override public TYPE_2 METHOD_2 ( TYPE_3 VAR_1 , boolean VAR_2 ) { return new TYPE_2 ( ) { } ; } @Override public TYPE_4 METHOD_3 ( TYPE_2 VAR_3 ) { <START> return new TYPE_5 ( new TYPE_6 ( new TYPE_7 ( STRING_1 ) , <END> new TYPE_8 ( TYPE_9 . of ( ) ) ) ) ; } @Override public TYPE_10 METHOD_4 ( ) { throw new TYPE_11 ( ) ; } } ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , String VAR_3 , TYPE_4 VAR_4 ) { try { return VAR_1 . METHOD_2 ( VAR_3 , VAR_2 ) ; } catch ( TYPE_5 e ) { String error = format ( STRING_1 , VAR_3 , e . getMessage ( ) , VAR_4 ) ; <START> throw new TYPE_6 ( error , e ) ; <END> } } 
public void METHOD_1 ( TYPE_1 session , TYPE_2 VAR_1 , boolean VAR_2 ) { TYPE_3 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 , VAR_2 ) ; METHOD_3 ( session , VAR_3 , METHOD_4 ( ) , METHOD_4 ( ) ) ; <START> } <END> 
public void METHOD_1 ( TYPE_1 session , TYPE_2 VAR_1 , boolean VAR_2 ) <START> { <END> TYPE_3 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( session , VAR_3 , METHOD_4 ( ) , METHOD_4 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { try { METHOD_1 ( VAR_1 , VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ; } catch ( TYPE_2 e ) { if ( TYPE_3 . equals ( e . VAR_2 ( ) ) ) { throw new TYPE_4 ( VAR_3 , e ) ; } <START> else { <END> throw new TYPE_4 ( VAR_4 , e ) ; } } } 
TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 ) { <START> this . VAR_4 = new TYPE_2 ( VAR_2 ) ; <END> this . VAR_3 = VAR_3 ; } 
public final void METHOD_1 ( long position , byte [ ] buffer , int VAR_1 , int VAR_2 ) { VAR_3 += VAR_2 ; long VAR_4 = System . VAR_5 ( ) ; METHOD_2 ( position , buffer , VAR_1 , VAR_2 ) ; long VAR_6 = System . VAR_5 ( ) - VAR_4 ; VAR_7 += VAR_6 ; <START> VAR_8 . METHOD_3 ( VAR_2 , VAR_6 ) ; <END> } 
private < T > T METHOD_1 ( TYPE_1 < T > VAR_1 ) throws TYPE_2 { try { T t = VAR_1 . get ( ) ; <START> VAR_2 . METHOD_2 ( ) ; <END> return t ; } catch ( TYPE_2 e ) { VAR_2 . METHOD_3 ( e ) ; throw e ; } } 
public TYPE_4 ( ANNOTATION_1 ( STRING_1 ) double VAR_2 , ANNOTATION_1 ( STRING_2 ) Map < TYPE_1 , TYPE_2 > VAR_3 ) { <START> METHOD_1 ( METHOD_2 ( VAR_2 ) || VAR_2 >= 0 , STRING_3 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = TYPE_3 . from ( METHOD_3 ( VAR_3 , STRING_4 ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 node ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( node , VAR_3 , METHOD_3 ( ) , session , VAR_4 ) ; TYPE_1 VAR_5 = node . VAR_6 ( ) . stream ( ) . map ( this : : METHOD_4 ) . METHOD_5 ( VAR_7 , TYPE_1 : : add ) ; <START> TYPE_1 VAR_8 = VAR_1 . add ( VAR_5 ) ; <END> return VAR_8 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . METHOD_3 ( ) ) { METHOD_4 ( String . format ( STRING_1 , VAR_2 . getClass ( ) . getName ( ) , <START> METHOD_5 ( session - > METHOD_6 ( VAR_3 , VAR_1 . VAR_4 , metadata . VAR_5 ( ) , new TYPE_2 ( TYPE_3 . of ( ) , TYPE_3 . of ( ) ) , session , 2 ) ) ) ) ; <END> } } 
private TYPE_1 METHOD_1 ( TYPE_2 node ) { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( node , VAR_3 , session , VAR_4 ) ; <END> TYPE_1 VAR_5 = node . VAR_6 ( ) . stream ( ) . map ( this : : METHOD_3 ) . METHOD_4 ( VAR_7 , TYPE_1 : : add ) ; TYPE_1 VAR_8 = VAR_2 . METHOD_2 ( node , VAR_3 , session , VAR_4 ) . add ( VAR_5 ) ; return VAR_8 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 node ) { TYPE_1 VAR_1 = node . VAR_2 ( ) . stream ( ) . map ( this : : METHOD_2 ) . METHOD_3 ( VAR_3 , TYPE_1 : : add ) ; <START> TYPE_1 VAR_4 = VAR_5 . METHOD_4 ( node , VAR_6 , METHOD_5 ( ) , session , VAR_7 ) . add ( VAR_1 ) ; <END> return VAR_4 ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( VAR_1 ) TYPE_1 input ) { TYPE_2 VAR_2 = METHOD_2 ( input ) ; if ( VAR_2 . isEmpty ( ) ) { return input ; } if ( TYPE_3 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) == VAR_3 ) { return input ; } <START> TYPE_2 VAR_4 = VAR_2 . METHOD_5 ( ) ; <END> return METHOD_6 ( VAR_4 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 config = new TYPE_1 ( ) ; try ( TYPE_2 VAR_1 = new TYPE_2 ( ) ) { TYPE_3 VAR_2 = new TYPE_3 ( ) ; String VAR_3 = STRING_1 ; VAR_1 . METHOD_2 ( new TYPE_4 ( STRING_2 + VAR_3 + STRING_3 ) , config ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; <START> TYPE_5 stream = VAR_1 . create ( new Path ( STRING_4 ) ) ; <END> stream . close ( ) ; assertEquals ( TYPE_7 . TYPE_6 , VAR_2 . METHOD_4 ( ) ) ; } } 
private static TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; return ( ) - > new Iterator < TYPE_2 > ( ) { private final int VAR_2 = VAR_1 . METHOD_3 ( ) ; private int VAR_3 ; @Override public boolean hasNext ( ) { <START> return VAR_3 != VAR_2 ; <END> } @Override public TYPE_2 next ( ) { if ( ! hasNext ( ) ) { throw new TYPE_4 ( STRING_2 ) ; } return TYPE_5 . METHOD_4 ( VAR_1 , VAR_3 ++ ) ; } } ; } 
private String METHOD_1 ( ) { int VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 . size ( ) ) ; int VAR_3 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( 1 , VAR_2 . size ( ) ) ; String VAR_4 = VAR_2 . get ( VAR_1 ) ; String VAR_5 = VAR_2 . get ( ( VAR_1 + VAR_3 ) % VAR_2 . size ( ) ) ; <START> if ( VAR_6 . get ( VAR_5 ) < VAR_6 . get ( VAR_4 ) ) { <END> VAR_4 = VAR_5 ; } return VAR_4 ; } 
public int METHOD_1 ( ) { <START> return METHOD_2 ( ( VAR_1 * VAR_2 ) + <END> VAR_3 . stream ( ) . METHOD_3 ( TYPE_1 : : METHOD_1 ) . METHOD_4 ( ) ) ; } 
public List < ? extends TYPE_1 > METHOD_1 ( ) { return TYPE_2 < TYPE_1 > builder ( ) <START> . addAll ( properties ) . build ( ) ; <END> } 
TYPE_2 ( TYPE_1 < T > VAR_2 ) <START> { <END> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; } 
TYPE_4 ( TYPE_2 . TYPE_3 < T > VAR_2 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; <START> } <END> 
<START> public void METHOD_1 ( int VAR_1 , boolean [ ] VAR_2 ) <END> throws IOException { for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_2 [ i ] = METHOD_2 ( ) ; } } 
private static TYPE_1 METHOD_1 ( int VAR_1 , Map < TYPE_2 , List < TYPE_3 > > VAR_2 ) { return new TYPE_1 ( VAR_3 , VAR_2 . entrySet ( ) . stream ( ) <START> . collect ( Collectors . VAR_4 ( ( entry ) - > entry . getKey ( ) . METHOD_2 ( ) , ( entry ) - > entry . getValue ( ) . get ( VAR_1 ) . METHOD_3 ( ) ) ) ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> Set < String > VAR_2 = TYPE_2 . of ( VAR_1 . METHOD_2 ( ) ) ; <END> VAR_2 = VAR_3 . METHOD_3 ( session . VAR_4 ( ) , session . VAR_5 ( ) , VAR_1 . METHOD_4 ( ) , VAR_2 ) ; return VAR_2 . contains ( VAR_1 . METHOD_2 ( ) ) && metadata . VAR_6 ( session , VAR_1 ) ; } 
<START> public void forEach ( TYPE_1 VAR_1 ) <END> { TYPE_2 VAR_2 = VAR_3 . get ( METHOD_1 ( ) ) ; TYPE_2 VAR_4 = VAR_5 . get ( METHOD_1 ( ) ) ; for ( int i = 0 ; ! isEmpty ( ) && VAR_2 != null && i < VAR_2 . METHOD_2 ( ) ; i ++ ) { VAR_1 . METHOD_3 ( VAR_2 , VAR_4 , i ) ; } } 
public void METHOD_1 ( TYPE_1 state , TYPE_2 out ) { if ( state . isEmpty ( ) ) { out . VAR_1 ( ) ; } <START> else { <END> TYPE_2 VAR_2 = out . VAR_3 ( ) ; state . forEach ( ( VAR_4 , VAR_5 , position ) - > { TYPE_2 VAR_6 = VAR_2 . METHOD_2 ( ) ; VAR_7 . METHOD_3 ( VAR_5 , position , VAR_6 ) ; VAR_8 . METHOD_3 ( VAR_4 , position , VAR_6 ) ; VAR_2 . METHOD_4 ( ) ; } ) ; out . VAR_9 ( ) ; } } 
public TYPE_1 ( Type VAR_2 , Type VAR_3 ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; <START> VAR_4 = this . VAR_2 . METHOD_2 ( null , VAR_5 , METHOD_3 ( VAR_2 , VAR_6 ) ) ; <END> VAR_7 = this . VAR_3 . METHOD_2 ( null , VAR_5 , METHOD_3 ( VAR_3 , VAR_6 ) ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 VAR_1 , TYPE_4 VAR_2 , TYPE_5 session , TYPE_6 VAR_3 ) <END> { if ( node instanceof TYPE_7 ) { return METHOD_2 ( ( TYPE_7 ) node , VAR_1 , VAR_2 , session , VAR_3 ) ; } return VAR_4 . METHOD_1 ( node , VAR_1 , VAR_2 , session , VAR_3 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 VAR_1 ) { TYPE_1 VAR_2 = null ; for ( TYPE_4 VAR_3 : VAR_4 . METHOD_2 ( node ) ) { <START> TYPE_1 VAR_5 = METHOD_3 ( VAR_1 . METHOD_4 ( VAR_3 . METHOD_5 ( ) ) , VAR_3 . METHOD_6 ( ) . METHOD_7 ( ) , node . VAR_6 ( ) ) ; <END> if ( VAR_2 != null ) { METHOD_8 ( VAR_2 , VAR_5 ) ; } else { VAR_2 = VAR_5 ; } } METHOD_9 ( VAR_2 != null , STRING_1 ) ; return VAR_2 ; } 
public TYPE_1 create ( ) { long VAR_1 = metadata . VAR_2 ( ) ; long VAR_3 = metadata . VAR_4 ( ) ; TYPE_2 VAR_5 = new TYPE_2 ( metadata , VAR_1 , VAR_3 ) ; TYPE_3 VAR_6 = new TYPE_3 ( VAR_1 , VAR_3 ) ; VAR_7 . put ( VAR_6 , VAR_5 ) ; return VAR_6 ; <START> } <END> 
private static void METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 , long VAR_3 , Set < Long > VAR_4 ) { int VAR_5 = VAR_1 . METHOD_1 ( VAR_2 , VAR_4 ) ; METHOD_2 ( VAR_5 == VAR_4 . size ( ) , STRING_1 , VAR_5 , VAR_4 . size ( ) ) ; VAR_5 = VAR_1 . METHOD_3 ( METHOD_4 ( VAR_3 ) , VAR_4 ) ; <START> METHOD_2 ( VAR_5 == VAR_4 . size ( ) , STRING_2 , VAR_5 , VAR_4 . size ( ) ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) <END> { int VAR_1 = channel ; channel ++ ; return VAR_2 . METHOD_2 ( VAR_1 ) ; } 
<START> public TYPE_1 . Type getType ( ) <END> { return type ; } 
public TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 ) { METHOD_2 ( VAR_1 . size ( ) == 2 , STRING_1 ) ; TYPE_1 VAR_2 = VAR_1 . get ( 0 ) ; <START> TYPE_1 VAR_3 = VAR_1 . get ( 1 ) ; <END> return new TYPE_2 ( getId ( ) , type , VAR_2 , VAR_3 , VAR_4 , filter ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 node , List < TYPE_1 > VAR_1 ) { TYPE_1 VAR_2 = VAR_1 . get ( 0 ) ; switch ( node . getType ( ) ) { case VAR_3 : case VAR_4 : return VAR_2 . METHOD_2 ( column - > TYPE_3 . METHOD_3 ( node . VAR_5 ( ) , column ) ) ; default : <START> throw new TYPE_4 ( STRING_1 + node . getType ( ) ) ; <END> } } 
public static Type METHOD_1 ( TYPE_1 . Type VAR_1 ) { switch ( VAR_1 ) { case VAR_2 : return Type . VAR_2 ; case VAR_3 : return Type . VAR_3 ; default : <START> throw new TYPE_2 ( STRING_1 + VAR_1 ) ; <END> } } 
<START> static Long METHOD_1 ( TYPE_1 VAR_1 ) <END> { if ( VAR_1 == null ) { return null ; } return VAR_1 . METHOD_1 ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = new TYPE_5 ( TYPE_6 . of ( ) , VAR_2 ) ; return new TYPE_1 ( VAR_2 , VAR_3 , new TYPE_7 ( VAR_3 ) , new TYPE_8 ( ) , new TYPE_9 ( ) , new TYPE_10 ( ) , new TYPE_11 ( ) , <START> TYPE_12 . METHOD_2 ( VAR_1 ) ) ; <END> } 
private static long METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return 0 ; } <START> else if ( VAR_1 . isEmpty ( ) ) { <END> return VAR_2 ; } else { return VAR_1 . METHOD_2 ( ) ; } } 
public void METHOD_1 ( TYPE_1 state , TYPE_2 out ) { if ( state . VAR_1 ( ) == null ) { out . VAR_2 ( ) ; } else { <START> TYPE_6 . TYPE_5 . METHOD_2 ( out , TYPE_4 . METHOD_1 ( state . VAR_1 ( ) ) ) ; <END> } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) <END> { synchronized ( this ) { VAR_2 . remove ( VAR_1 ) ; } TYPE_2 info = VAR_3 . get ( VAR_4 ) . METHOD_2 ( ) ; for ( TYPE_3 < TYPE_2 > listener : VAR_5 . get ( VAR_4 ) ) { VAR_6 . execute ( ( ) - > listener . VAR_7 ( info ) ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_1 , STRING_1 ) ; <END> return new TYPE_1 ( METHOD_3 ( this . VAR_2 , VAR_1 . VAR_2 ) , METHOD_3 ( this . VAR_3 , VAR_1 . VAR_3 ) , max ( this . VAR_4 , VAR_1 . VAR_4 ) , max ( this . VAR_5 , VAR_1 . VAR_5 ) ) ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) && state == TYPE_1 . VAR_3 ; <END> } 
<START> public String METHOD_1 ( ) <END> { return VAR_1 ; } 
<START> public String getType ( ) <END> { return type ; } 
private boolean METHOD_1 ( TYPE_1 session ) { if ( ! VAR_1 . METHOD_2 ( ) ) { LOG . debug ( STRING_1 ) ; return false ; } if ( ! TYPE_2 . METHOD_2 ( session ) ) { LOG . debug ( STRING_2 ) ; return false ; } <START> LOG . info ( STRING_3 ) ; <END> return true ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( null , VAR_1 ) ; <END> } 
<START> private static TYPE_5 . TYPE_4 METHOD_1 ( TYPE_2 VAR_1 , Set < TYPE_3 > VAR_2 ) <END> { TYPE_3 VAR_3 = TYPE_3 . from ( VAR_1 . METHOD_2 ( ) ) ; TYPE_3 VAR_4 = TYPE_3 . from ( VAR_1 . METHOD_3 ( ) ) ; TYPE_5 . TYPE_4 VAR_5 = new TYPE_5 . TYPE_4 ( VAR_3 , VAR_4 ) ; return VAR_2 . contains ( VAR_3 ) ? VAR_5 : VAR_5 . METHOD_4 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 p = METHOD_2 ( ) ; TYPE_2 VAR_1 = p . VAR_2 ( STRING_1 ) ; TYPE_2 VAR_3 = p . VAR_2 ( STRING_2 ) ; TYPE_3 VAR_4 = p . VAR_5 ( <START> TYPE_3 . Type . VAR_6 , <END> p . values ( VAR_1 ) , p . values ( VAR_3 ) , ImmutableList . of ( METHOD_3 ( VAR_1 , VAR_3 ) ) , ImmutableList . of ( VAR_1 , VAR_3 ) , Optional . empty ( ) ) ; METHOD_4 ( VAR_4 , METHOD_5 ( ) , VAR_7 ) ; } 
<START> private TYPE_4 . TYPE_3 METHOD_1 ( TYPE_2 VAR_1 , TYPE_2 VAR_2 ) <END> { return new TYPE_4 . TYPE_3 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) { <START> ( ( TYPE_3 ) VAR_3 ) . METHOD_2 ( new TYPE_4 ( VAR_1 ) , VAR_2 ) ; <END> return this ; } 
public boolean METHOD_1 ( TYPE_1 session ) { <START> TYPE_4 . TYPE_3 VAR_1 = METHOD_2 ( session ) ; <END> return VAR_1 == VAR_2 || VAR_1 == VAR_3 ; } 
public long METHOD_1 ( ) { <START> return VAR_1 + TYPE_1 . METHOD_2 ( VAR_2 ) ; <END> } 
public void close ( ) throws IOException { try ( TYPE_1 VAR_1 = TYPE_1 . create ( ) ) { VAR_1 . METHOD_1 ( super : : close ) ; <START> VAR_1 . METHOD_1 ( TYPE_2 : : METHOD_2 ) ; <END> if ( VAR_2 instanceof TYPE_3 ) { VAR_1 . METHOD_1 ( ( TYPE_3 ) VAR_2 ) ; } } } 
private static TYPE_1 < ? > METHOD_1 ( Type type , TYPE_2 value ) { TYPE_3 VAR_1 = TYPE_4 . METHOD_2 ( value , ( TYPE_5 ) type ) . METHOD_3 ( ) ; if ( TYPE_4 . METHOD_4 ( type ) ) { return VAR_1 . METHOD_5 ( ) ; } <START> else { <END> return TYPE_4 . METHOD_6 ( VAR_1 ) ; } } 
public TYPE_1 METHOD_1 ( Map < String , TYPE_2 > VAR_1 ) { <START> METHOD_2 ( VAR_1 , STRING_1 ) ; <END> return new TYPE_1 ( VAR_2 , parameters , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; return VAR_1 ; <START> } <END> 
static TYPE_1 parse ( byte [ ] VAR_1 ) { <START> TYPE_2 VAR_2 = new TYPE_3 ( ) . get ( ) <END> . METHOD_1 ( TYPE_4 . VAR_4 ) ; Class < TYPE_1 > VAR_5 = TYPE_1 . class ; try { return VAR_2 . METHOD_2 ( VAR_1 , VAR_5 ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( format ( STRING_1 , VAR_5 ) , e ) ; } } 
<START> private TYPE_1 METHOD_1 ( Type type , int VAR_1 ) <END> { TYPE_1 VAR_2 = type . VAR_3 ( null , 1 ) . METHOD_2 ( ) . build ( ) ; return new TYPE_2 ( VAR_2 , VAR_1 ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( ! ( VAR_1 instanceof TYPE_3 ) ) { return false ; } TYPE_3 VAR_3 = ( TYPE_3 ) VAR_1 ; Object value = VAR_3 . getValue ( ) ; boolean VAR_4 = value == null ; if ( VAR_4 ) { return false ; } try { <START> return ! ( boolean ) VAR_2 . METHOD_2 ( value , VAR_4 ) ; <END> } catch ( Throwable t ) { METHOD_3 ( t ) ; throw new RuntimeException ( t ) ; } } 
public static long METHOD_1 ( ANNOTATION_1 ( TYPE_2 . VAR_2 ) long value ) { <START> return TYPE_1 . METHOD_2 ( ( byte ) value ) ; <END> } 
public Optional < TYPE_1 > METHOD_1 ( TYPE_2 session , TYPE_3 VAR_1 ) { return METHOD_2 ( VAR_1 ) <START> . map ( t - > ( TYPE_4 ) METHOD_3 ( t ) ) <END> . map ( VAR_2 - > new TYPE_5 ( VAR_2 , VAR_3 ) ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return null ; <END> } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_2 . class ) <END> . METHOD_4 ( STRING_1 ) ) ; } 
private static TYPE_1 METHOD_1 ( ) { <START> return ( VAR_1 , context ) - > TYPE_2 . METHOD_2 ( new TYPE_8 . TYPE_9 . VAR_2 . VAR_3 . VAR_4 . TYPE_1 < TYPE_4 > ( ) <END> { @Override public TYPE_5 METHOD_3 ( TYPE_6 node , TYPE_4 context , TYPE_2 < TYPE_4 > VAR_6 ) { return TYPE_7 . METHOD_4 ( node ) ; } } , VAR_1 ) ; } 
<START> public TYPE_3 ( Optional < TYPE_1 > location , TYPE_2 VAR_2 ) <END> { super ( location ) ; this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; } 
<START> public TYPE_3 ( Optional < TYPE_1 > location , Optional < TYPE_2 > VAR_2 , TYPE_2 VAR_3 ) <END> { super ( location ) ; this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_2 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 context ) { if ( node . VAR_1 ( ) . isPresent ( ) ) { return METHOD_2 ( node , context ) ; } <START> else { <END> return METHOD_3 ( node , context ) ; } } 
public static List < TYPE_1 > METHOD_1 ( Class < ? > VAR_1 ) { <START> ImmutableList . Builder < TYPE_1 > builder = ImmutableList . builder ( ) ; <END> for ( TYPE_2 VAR_2 : METHOD_2 ( VAR_1 ) ) { builder . add ( METHOD_3 ( VAR_2 , TYPE_3 . of ( ) ) ) ; } return builder . build ( ) ; } 
private static String METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( VAR_1 == TYPE_1 . VAR_3 ) { return STRING_1 + VAR_2 ; } <START> else if ( VAR_1 == TYPE_1 . VAR_4 ) { <END> return STRING_2 + VAR_2 ; } throw new IllegalArgumentException ( STRING_3 + VAR_1 . name ( ) ) ; } 
private static List < Type > METHOD_1 ( List < Type > VAR_1 , List < TYPE_1 > VAR_2 ) { ImmutableList . Builder < Type > builder = ImmutableList . builder ( ) ; <START> builder . addAll ( VAR_1 ) ; <END> VAR_2 . stream ( ) . forEach ( VAR_3 - > builder . add ( VAR_3 . getType ( ) ) ) ; return builder . build ( ) ; } 
public boolean METHOD_1 ( ) { <START> if ( ! VAR_1 . isEmpty ( ) && VAR_2 . size ( ) == 1 ) { <END> List < TYPE_1 > VAR_3 = TYPE_2 . METHOD_2 ( VAR_2 ) ; return ! VAR_3 . isEmpty ( ) && TYPE_3 . METHOD_3 ( VAR_1 ) . equals ( TYPE_3 . METHOD_3 ( VAR_3 ) ) ; } return false ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , Set < String > VAR_4 ) { if ( METHOD_2 ( VAR_2 . METHOD_3 ( ) , VAR_3 . METHOD_4 ( ) , VAR_5 ) ) { <START> METHOD_5 ( VAR_3 . toString ( ) ) ; <END> } if ( VAR_6 . isEmpty ( ) ) { super . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 < TYPE_4 , String > VAR_3 ) { TYPE_5 VAR_4 = new TYPE_5 ( VAR_1 , VAR_2 ) ; <START> Map < TYPE_4 , Set < String > > VAR_5 = VAR_6 . METHOD_2 ( VAR_4 , ( VAR_7 ) - > new TYPE_6 < > ( ) ) ; <END> VAR_3 . METHOD_3 ( ) . forEach ( ( key , value ) - > VAR_5 . METHOD_2 ( key , VAR_7 - > new HashSet < > ( ) ) . addAll ( value ) ) ; } 
private void METHOD_1 ( ) { <START> VAR_1 = VAR_2 + METHOD_2 ( VAR_3 ) + METHOD_2 ( values ) + TYPE_1 . METHOD_3 ( ) ; <END> if ( VAR_4 != null ) { VAR_1 += TYPE_2 . VAR_2 ; } } 
void METHOD_1 ( TYPE_1 VAR_1 ) { for ( Class < ? > VAR_2 : VAR_3 . keySet ( ) ) { String name = TYPE_2 . builder ( TYPE_3 . class ) . METHOD_2 ( STRING_1 , VAR_2 . METHOD_3 ( ) ) <START> . build ( ) ; <END> VAR_1 . METHOD_1 ( name ) ; } } 
<START> public final boolean execute ( String VAR_1 ) <END> throws TYPE_1 { if ( connection ( ) . METHOD_1 ( ) ) { METHOD_2 ( connection ( ) . METHOD_3 ( ) ) ; } return METHOD_2 ( VAR_1 ) ; } 
public static long METHOD_1 ( ANNOTATION_1 ( VAR_1 ) TYPE_1 input ) { <START> return TYPE_2 . METHOD_2 ( METHOD_3 ( input ) ) ; <END> } 
<START> default TYPE_1 VAR_2 ( TYPE_2 session , TYPE_3 VAR_5 ) <END> { return VAR_6 ; } 
private static int METHOD_1 ( TYPE_1 VAR_1 , int position , TYPE_2 VAR_2 , int VAR_3 ) { if ( VAR_1 . METHOD_2 ( position ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } long VAR_4 ; try { VAR_4 = ( long ) VAR_2 . METHOD_3 ( VAR_1 , position ) ; } catch ( Throwable VAR_5 ) { if ( VAR_5 instanceof RuntimeException ) { throw ( RuntimeException ) VAR_5 ; } throw new RuntimeException ( VAR_5 ) ; } return ( int ) Math . VAR_6 ( VAR_4 , VAR_3 ) ; <START> } <END> 
private static boolean METHOD_1 ( int VAR_1 , long VAR_2 ) { <START> return ( VAR_1 >= 0 && VAR_1 <= VAR_2 ) ; <END> } 
public TYPE_3 ( ANNOTATION_1 ( STRING_1 ) Optional < List < TYPE_1 > > VAR_2 , ANNOTATION_1 ( STRING_2 ) Optional < List < TYPE_2 > > VAR_3 ) { this . VAR_2 = VAR_2 . map ( ImmutableList : : METHOD_1 ) . METHOD_2 ( ImmutableList . of ( ) ) ; <START> this . VAR_3 = VAR_3 . map ( ImmutableList : : METHOD_1 ) . METHOD_2 ( ImmutableList . of ( ) ) ; <END> } 
public String toString ( ) { TYPE_1 VAR_1 = METHOD_1 ( this ) . add ( STRING_1 , name ) . add ( STRING_2 , VAR_2 ) . add ( STRING_3 , type ) ; <START> return VAR_1 . toString ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 session , TYPE_1 VAR_1 ) { <START> TYPE_3 VAR_2 = METHOD_2 ( session , VAR_1 ) ; <END> return VAR_2 ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 ) { return true ; } <START> boolean VAR_1 = VAR_2 && VAR_3 == null && VAR_4 . isEmpty ( ) && VAR_5 == null ; <END> if ( VAR_1 ) { close ( ) ; } return VAR_1 ; } 
private static TYPE_1 < ? > METHOD_1 ( List < TYPE_1 < ? > > VAR_1 ) { <START> if ( VAR_1 . size ( ) == 1 ) { <END> return VAR_1 . get ( 0 ) ; } TYPE_2 < ? > result = TYPE_2 . create ( ) ; TYPE_3 VAR_2 = METHOD_2 ( ) ; for ( TYPE_1 < ? > VAR_3 : VAR_1 ) { VAR_3 . METHOD_3 ( ( ) - > result . set ( null ) , VAR_2 ) ; } return result ; } 
public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_2 . class ) <END> . METHOD_4 ( null ) . METHOD_5 ( null ) . METHOD_6 ( null ) ) ; } 
private List < String > METHOD_1 ( TYPE_1 session , Optional < String > VAR_1 ) { if ( ! VAR_1 . isPresent ( ) ) { return METHOD_2 ( session ) ; } <START> else if ( METHOD_3 ( VAR_1 . get ( ) ) > 0 ) { <END> return ImmutableList . of ( VAR_1 . get ( ) ) ; } return ImmutableList . of ( ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> if ( VAR_2 . isEmpty ( ) ) { <END> assertTrue ( VAR_1 . isEmpty ( ) ) ; } else { assertEquals ( VAR_1 . METHOD_2 ( ) , VAR_2 . METHOD_2 ( ) ) ; } } 
private static TYPE_1 METHOD_1 ( TYPE_2 input , TYPE_3 type , int length ) { switch ( type ) { case VAR_1 : return METHOD_2 ( input ) ; case VAR_2 : case VAR_3 : case VAR_4 : case VAR_5 : case VAR_6 : return METHOD_3 ( input , length ) ; case VAR_7 : return METHOD_4 ( input ) ; default : <START> throw new TYPE_4 ( STRING_1 + type ) ; <END> } } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 session , String VAR_1 ) { TYPE_3 < TYPE_1 > stream = VAR_2 . METHOD_2 ( session ) . stream ( ) . map ( TYPE_4 : : METHOD_3 ) . map ( TYPE_5 : : METHOD_4 ) ; if ( VAR_1 != null ) { stream = stream <START> . filter ( table - > table . VAR_3 ( ) . equals ( VAR_1 ) ) ; <END> } return stream . collect ( METHOD_5 ( ) ) ; } 
public TYPE_3 ( List < TYPE_1 > VAR_2 ) { METHOD_1 ( VAR_2 , STRING_1 ) ; <START> TYPE_2 . METHOD_2 ( VAR_2 . size ( ) >= 1 , STRING_2 ) ; <END> this . VAR_2 = ImmutableList . VAR_3 ( VAR_2 ) ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 ) && ! VAR_1 . METHOD_2 ( ) . equals ( TYPE_2 ) ; <END> } 
TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( VAR_1 . METHOD_2 ( ) . entrySet ( ) . stream ( ) <START> . collect ( TYPE_2 . METHOD_3 ( Map . Entry : : getKey , VAR_2 - > TYPE_3 . METHOD_4 ( VAR_2 . getValue ( ) ) ) ) ) ; <END> } 
public Optional < TYPE_1 > METHOD_1 ( TYPE_2 node , TYPE_3 context ) { Optional < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( node . VAR_3 ( ) ) . METHOD_3 ( this , null ) ; <START> if ( ! VAR_1 . isPresent ( ) || ! VAR_1 . get ( ) . VAR_4 ) { <END> return Optional . empty ( ) ; } return VAR_1 ; } 
public static void METHOD_1 ( String [ ] args ) throws IOException , TYPE_1 { TYPE_2 data = new TYPE_2 ( ) ; data . VAR_1 ( ) ; <START> data . VAR_2 ( ) ; <END> TYPE_3 options = new TYPE_4 ( ) . METHOD_2 ( TYPE_7 . VAR_4 ) . METHOD_3 ( STRING_1 + TYPE_5 . class . METHOD_4 ( ) + STRING_1 ) . build ( ) ; new TYPE_6 ( options ) . run ( ) ; } 
private static Type METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 == null ) { return TYPE_3 . VAR_4 ; } switch ( VAR_2 ) { case VAR_5 : return METHOD_4 ( VAR_1 . METHOD_2 ( ) . METHOD_5 ( ) ) ; case VAR_6 : return TYPE_4 . VAR_6 ; default : <START> return TYPE_3 . VAR_4 ; <END> } } 
public static void METHOD_1 ( TYPE_1 state , TYPE_1 VAR_1 ) { <START> METHOD_2 ( state . get ( ) != null , STRING_1 ) ; <END> METHOD_2 ( VAR_1 . get ( ) != null , STRING_2 ) ; TYPE_2 VAR_2 = state . get ( ) ; long VAR_3 = VAR_2 . METHOD_3 ( ) ; VAR_2 . addAll ( VAR_1 . get ( ) ) ; state . VAR_4 ( VAR_2 . METHOD_3 ( ) - VAR_3 ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; <END> assertThat ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_2 - > ( ( String ) VAR_2 ) . contains ( STRING_2 ) ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , STRING_2 ) ; METHOD_2 ( STRING_3 , STRING_4 ) ; METHOD_2 ( STRING_5 , STRING_4 ) ; try { METHOD_3 ( STRING_6 ) ; METHOD_3 ( STRING_7 ) ; } catch ( RuntimeException e ) { assertTrue ( TYPE_1 . of ( STRING_8 , STRING_9 ) . contains ( e . getMessage ( ) ) ) ; <START> return ; <END> } METHOD_4 ( STRING_10 , STRING_11 ) ; METHOD_4 ( STRING_12 , STRING_13 ) ; METHOD_3 ( STRING_14 ) ; METHOD_3 ( STRING_15 ) ; } 
<START> synchronized Collection < TYPE_1 > METHOD_1 ( ) <END> { return ImmutableList . VAR_1 ( this . VAR_2 . values ( ) ) ; } 
private static void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> VAR_2 . METHOD_3 ( null ) ; <END> TYPE_1 VAR_3 = METHOD_4 ( METHOD_5 ( VAR_2 ) ) ; assertEquals ( VAR_2 . METHOD_6 ( ) , VAR_3 . METHOD_6 ( ) ) ; } 
<START> protected String METHOD_1 ( TYPE_1 VAR_1 ) <END> { return VAR_2 ? format ( STRING_1 , VAR_3 , VAR_1 . getMessage ( ) , VAR_4 ) : format ( STRING_2 , VAR_1 . getMessage ( ) ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 == null ) { METHOD_2 ( VAR_2 ) ; return ; } assertNotNull ( VAR_2 ) ; while ( true ) { METHOD_3 ( VAR_1 , VAR_2 ) ; VAR_1 = VAR_1 . METHOD_4 ( ) ; VAR_2 = VAR_2 . METHOD_4 ( ) ; if ( VAR_2 == null ) { return ; } <START> else { <END> assertNotNull ( VAR_1 ) ; } } } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == VAR_2 ) { return new TYPE_2 ( type ) ; } if ( VAR_1 == VAR_3 ) { return new TYPE_3 ( type ) ; } <START> throw new TYPE_4 ( VAR_4 , format ( STRING_1 , VAR_1 ) ) ; <END> } 
public Class < ? extends TYPE_1 > METHOD_1 ( ) { if ( VAR_1 == VAR_2 ) { return TYPE_2 . class ; } if ( VAR_1 == VAR_3 ) { return TYPE_3 . class ; } <START> throw new TYPE_4 ( VAR_4 , format ( STRING_1 , VAR_1 ) ) ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 , long VAR_4 ) <START> { <END> METHOD_1 ( VAR_2 == null || VAR_3 == null || VAR_2 . METHOD_2 ( VAR_3 ) <= 0 , STRING_1 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; int VAR_5 = 0 ; if ( VAR_2 != null ) { VAR_5 += VAR_6 + VAR_4 ; } if ( VAR_3 != null ) { VAR_5 += VAR_6 + VAR_4 ; } this . VAR_5 = VAR_5 + VAR_7 ; } 
<START> public static double METHOD_1 ( ANNOTATION_1 ( VAR_1 ) TYPE_1 input ) <END> { TYPE_2 VAR_2 = METHOD_2 ( input ) ; if ( VAR_2 == null ) { return FLOAT_1 ; } return VAR_2 . METHOD_3 ( ) ; } 
public double METHOD_1 ( TYPE_1 data ) { <START> return TYPE_2 . METHOD_2 ( data . VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws IOException { <START> VAR_1 = TYPE_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( METHOD_4 ( STRING_1 ) ) ) ; <END> VAR_2 = TYPE_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( STRING_2 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , long VAR_3 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; METHOD_2 ( VAR_2 , STRING_2 ) ; <START> TYPE_3 . METHOD_3 ( VAR_3 >= 0 , STRING_3 ) ; <END> VAR_4 . METHOD_4 ( VAR_1 ) . METHOD_1 ( VAR_2 , VAR_3 ) ; } 
<START> public List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 , Context < TYPE_2 > context ) <END> { ImmutableList . Builder < TYPE_1 > builder = ImmutableList . builder ( ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { builder . add ( METHOD_1 ( VAR_2 , context . get ( ) ) ) ; } return builder . build ( ) ; } 
public void start ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_1 ( ) ; VAR_2 . METHOD_2 ( null , VAR_1 ) ; VAR_3 . METHOD_2 ( 0 , System . VAR_4 ( ) ) ; VAR_5 . METHOD_2 ( 0 , VAR_6 . METHOD_3 ( ) ) ; <START> VAR_7 . METHOD_2 ( 0 , VAR_6 . METHOD_4 ( ) . METHOD_5 ( VAR_8 ) ) ; <END> VAR_9 . set ( VAR_1 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 ) ; METHOD_2 ( STRING_2 , STRING_3 ) ; METHOD_2 ( STRING_4 ) ; METHOD_2 ( STRING_5 , STRING_6 ) ; METHOD_2 ( STRING_7 , STRING_8 ) ; METHOD_2 ( STRING_9 ) ; METHOD_2 ( STRING_10 , <START> STRING_11 ) ; <END> METHOD_2 ( STRING_12 , STRING_13 ) ; METHOD_2 ( "" + STRING_14 + STRING_15 , STRING_16 ) ; METHOD_2 ( STRING_17 ) ; METHOD_2 ( STRING_18 ) ; METHOD_2 ( STRING_19 ) ; } 
public void METHOD_1 ( ) throws IOException { <START> METHOD_2 ( VAR_1 ) . METHOD_3 ( VAR_1 ) ; <END> METHOD_4 ( VAR_2 . METHOD_5 ( ) , VAR_3 ) ; } 
<START> private void METHOD_1 ( List < TYPE_3 . TYPE_4 . VAR_1 . VAR_2 . model . TYPE_2 > VAR_3 , List < TYPE_2 > VAR_4 ) <END> { if ( VAR_4 == null ) { METHOD_2 ( VAR_3 ) ; } assertEquals ( VAR_3 . size ( ) , VAR_4 . size ( ) ) ; for ( int i = 0 ; i < VAR_4 . size ( ) ; i ++ ) { METHOD_3 ( VAR_3 . get ( i ) , VAR_4 . get ( i ) ) ; } } 
<START> private void METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_3 . TYPE_4 . VAR_2 . VAR_3 . model . TYPE_1 > VAR_4 ) <END> { if ( VAR_4 == null ) { METHOD_2 ( VAR_1 ) ; } assertEquals ( VAR_1 . size ( ) , VAR_4 . size ( ) ) ; for ( int i = 0 ; i < VAR_4 . size ( ) ; i ++ ) { METHOD_3 ( VAR_1 . get ( i ) , VAR_4 . get ( i ) ) ; } } 
public void METHOD_1 ( ) { <START> METHOD_2 ( STRING_1 , STRING_1 ) ; <END> } 
protected TYPE_1 ( ) { <START> super ( TYPE_1 : : METHOD_1 , TYPE_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) . build ( ) ) ; <END> } 
public TYPE_3 ( ) { <START> super ( ( ) - > METHOD_1 ( TYPE_1 . of ( ) , TYPE_1 . of ( STRING_1 , STRING_2 ) ) , TYPE_2 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) . build ( ) ) ; <END> } 
protected TYPE_3 ( TYPE_1 VAR_2 ) { <START> super ( VAR_2 , TYPE_2 . METHOD_1 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 node , List < TYPE_1 > VAR_1 ) { TYPE_1 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 . METHOD_3 ( ) ) { <END> return TYPE_1 . METHOD_4 ( ) ; } else { return VAR_2 ; } } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 session , TYPE_3 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) { return METHOD_1 ( session , VAR_1 . METHOD_3 ( ) ) ; } <START> return ImmutableList . of ( new TYPE_1 ( VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_2 ( ) ) ) ; <END> } 
public boolean METHOD_1 ( ) { return ! VAR_1 && VAR_2 . METHOD_2 ( ) && VAR_3 . METHOD_2 ( ) && VAR_4 == null && VAR_5 == null <START> && ! METHOD_3 ( ) ; <END> } 
public boolean METHOD_1 ( ) { boolean VAR_1 = ( this . VAR_1 && VAR_2 == null && VAR_3 . isEmpty ( ) && VAR_4 == null ) || <START> METHOD_2 ( ) ; <END> if ( VAR_1 ) { close ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , METHOD_3 ( node ( TYPE_1 . class ) . METHOD_4 ( TYPE_2 . builder ( ) . METHOD_5 ( new TYPE_3 ( FLOAT_1 ) ) . METHOD_6 ( METHOD_7 ( ) ) . build ( ) ) ) ) ; METHOD_2 ( STRING_2 , METHOD_3 ( node ( TYPE_1 . class ) . METHOD_4 ( TYPE_2 . builder ( ) . METHOD_5 ( new TYPE_3 ( FLOAT_2 ) ) . METHOD_6 ( METHOD_7 ( ) ) . build ( ) ) ) ) ; <START> } <END> 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { long VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; long VAR_3 = VAR_1 . METHOD_4 ( ) . METHOD_3 ( ) ; long VAR_4 = VAR_2 - VAR_5 ; long VAR_6 = VAR_3 - VAR_7 ; VAR_5 = VAR_2 ; VAR_7 = VAR_3 ; <START> VAR_8 . METHOD_5 ( VAR_4 , VAR_6 ) ; <END> } 
public List < String > METHOD_1 ( String VAR_1 , List < String > VAR_2 ) { <START> VAR_2 . add ( VAR_1 ) ; <END> return VAR_2 ; } 
protected TYPE_2 ( ) { <START> this ( TYPE_1 . VAR_3 ) ; <END> } 
<START> private void METHOD_1 ( Object VAR_1 ) <END> { METHOD_2 ( ! Thread . VAR_2 ( VAR_1 ) , STRING_1 ) ; } 
public long METHOD_1 ( ) { <START> long VAR_1 = VAR_2 == null ? 0 : VAR_2 . METHOD_2 ( ) ; <END> return VAR_3 + VAR_4 + VAR_1 + VAR_5 . METHOD_3 ( ) + VAR_6 . METHOD_3 ( ) + VAR_7 . METHOD_1 ( ) ; } 
public void METHOD_1 ( TYPE_1 page ) { METHOD_2 ( page , STRING_1 ) ; METHOD_3 ( ! METHOD_4 ( ) , STRING_2 ) ; TYPE_2 VAR_1 = page . VAR_2 ( VAR_3 ) ; TYPE_1 VAR_4 = VAR_5 . isPresent ( ) ? new TYPE_1 ( VAR_1 , page . VAR_2 ( VAR_5 . get ( ) ) ) : new TYPE_1 ( VAR_1 ) ; VAR_6 = VAR_7 . METHOD_5 ( VAR_4 ) ; METHOD_6 ( ) ; <START> VAR_7 . METHOD_7 ( ) ; <END> } 
public TYPE_1 < ? > METHOD_1 ( TYPE_2 page ) { <START> TYPE_1 < ? > VAR_1 = VAR_2 . METHOD_1 ( page ) ; <END> return VAR_1 ; } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 . isPresent ( ) && ! METHOD_2 ( ) ) { <END> return false ; } return ! VAR_2 ; } 
public int METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; try { <START> return VAR_2 . length ; <END> } finally { VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; } } 
<START> protected static TYPE_1 METHOD_1 ( ) <END> { return METHOD_2 ( VAR_1 , ( VAR_2 , VAR_3 ) - > { long VAR_4 = VAR_2 . METHOD_3 ( VAR_3 ) . METHOD_4 ( ) ; long VAR_5 = TYPE_2 . getInstance ( ) . METHOD_5 ( ) . METHOD_6 ( VAR_6 , VAR_4 ) ; return TYPE_3 . METHOD_7 ( VAR_5 ) ; } ) ; } 
public static long METHOD_1 ( ANNOTATION_1 ( TYPE_3 . VAR_2 ) double VAR_3 , ANNOTATION_1 ( TYPE_3 . VAR_4 ) long VAR_5 , ANNOTATION_1 ( TYPE_3 . VAR_4 ) long VAR_6 ) { int offset = METHOD_2 ( VAR_5 * INT_1 + VAR_6 ) ; TYPE_1 VAR_7 ; try { VAR_7 = METHOD_3 ( offset ) ; } catch ( IllegalArgumentException e ) { <START> throw new TYPE_2 ( VAR_8 , format ( STRING_1 , offset ) , e ) ; <END> } return METHOD_4 ( Math . VAR_9 ( VAR_3 * INT_2 ) , VAR_7 ) ; } 
private Iterator < TYPE_1 > METHOD_1 ( ) { METHOD_2 ( VAR_1 , STRING_1 ) ; VAR_1 = false ; try { TYPE_2 input = VAR_2 . METHOD_3 ( ) ; <START> TYPE_3 VAR_3 = VAR_4 . METHOD_4 ( input ) ; <END> Iterator < TYPE_1 > VAR_5 = TYPE_4 . METHOD_1 ( VAR_6 , new TYPE_5 ( input , VAR_7 ) ) ; return TYPE_6 . METHOD_5 ( VAR_5 , VAR_3 ) ; } catch ( IOException e ) { throw new TYPE_7 ( VAR_8 , STRING_2 , e ) ; } } 
public void close ( ) { try ( TYPE_1 VAR_1 = TYPE_1 . create ( ) ) { VAR_1 . METHOD_1 ( TYPE_2 : : close ) ; VAR_1 . METHOD_1 ( TYPE_3 : : close ) ; VAR_1 . METHOD_1 ( TYPE_4 : : close ) ; <START> TYPE_5 . close ( ) ; <END> TYPE_6 . close ( ) ; TYPE_7 . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING_1 , e ) ; } } 
<START> public synchronized TYPE_1 < ? > METHOD_1 ( long VAR_1 ) <END> { if ( VAR_1 >= 0 ) { if ( VAR_2 . METHOD_2 ( ) + VAR_1 > VAR_3 ) { throw METHOD_3 ( METHOD_4 ( VAR_3 ) ) ; } return VAR_4 . METHOD_5 ( VAR_5 , VAR_1 ) ; } VAR_4 . METHOD_6 ( VAR_5 , - VAR_1 ) ; return VAR_6 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 session , boolean VAR_2 , boolean VAR_3 ) { TYPE_4 VAR_4 ; synchronized ( this ) { <START> VAR_4 = VAR_5 . METHOD_2 ( ) ; <END> } TYPE_1 VAR_6 = TYPE_1 . METHOD_3 ( this , VAR_1 , VAR_7 , VAR_8 , session , VAR_4 , VAR_2 , VAR_3 ) ; VAR_9 . put ( VAR_1 . METHOD_4 ( ) , VAR_6 ) ; return VAR_6 ; } 
public boolean METHOD_1 ( long VAR_1 ) { boolean result = VAR_2 . METHOD_1 ( VAR_1 ) ; if ( VAR_3 . isPresent ( ) ) { <START> VAR_3 . get ( ) . METHOD_2 ( VAR_2 . METHOD_3 ( ) , Math : : max ) ; <END> } return result ; } 
<START> public synchronized long METHOD_1 ( ) <END> { return VAR_1 . METHOD_2 ( ) ; } 
static long METHOD_1 ( long VAR_1 , long VAR_2 ) { try { return Math . VAR_3 ( VAR_1 , VAR_2 ) ; } catch ( TYPE_1 e ) { <START> throw new RuntimeException ( String . format ( STRING_1 , VAR_1 , VAR_2 ) , e ) ; <END> } } 
public TYPE_7 ( long VAR_2 , TYPE_1 < TYPE_2 > TYPE_3 , TYPE_4 VAR_3 ) { METHOD_1 ( TYPE_3 , STRING_1 ) ; METHOD_2 ( VAR_2 > 0 , STRING_2 ) ; this . VAR_2 = VAR_2 ; <START> this . TYPE_3 = TYPE_5 . METHOD_3 ( ( ) - > TYPE_3 . get ( ) ) ; <END> this . VAR_3 = METHOD_1 ( VAR_3 , STRING_3 ) ; VAR_4 = TYPE_6 . create ( ) ; VAR_4 . set ( null ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , Throwable VAR_2 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; METHOD_2 ( VAR_2 , STRING_2 ) ; <START> log . warn ( VAR_2 , STRING_3 , VAR_1 ) ; <END> TYPE_2 query = VAR_3 . get ( VAR_1 ) ; if ( query != null ) { query . VAR_4 ( VAR_2 ) ; } } 
<START> private static TYPE_4 . TYPE_3 METHOD_1 ( String VAR_1 ) <END> { for ( TYPE_4 . TYPE_3 VAR_2 : TYPE_4 . TYPE_3 . values ( ) ) { if ( VAR_2 . METHOD_2 ( ) . equals ( VAR_1 ) ) { return VAR_2 ; } } throw new TYPE_2 ( VAR_3 , STRING_1 ) ; } 
<START> public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_4 . VAR_2 ) double value , ANNOTATION_1 ( TYPE_4 . VAR_3 ) TYPE_1 VAR_4 ) <END> { try { TYPE_2 VAR_5 = TYPE_2 . METHOD_1 ( value , METHOD_2 ( VAR_4 . METHOD_3 ( ) ) ) ; return METHOD_4 ( VAR_5 . toString ( ) ) ; } catch ( IllegalArgumentException e ) { throw new TYPE_3 ( VAR_6 , e ) ; } } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_4 . VAR_2 ) TYPE_1 VAR_3 , ANNOTATION_1 ( TYPE_4 . VAR_2 ) TYPE_1 key ) { <START> return TYPE_2 . METHOD_2 ( TYPE_3 . METHOD_1 ( key . VAR_4 ( ) ) . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) . METHOD_5 ( ) ) ; <END> } 
private void METHOD_1 ( String name , Class < ? extends TYPE_1 > VAR_1 ) { METHOD_2 ( METHOD_3 ( TYPE_2 . class , config - > name . equals ( config . VAR_2 ( ) ) , <START> VAR_3 - > VAR_3 . bind ( TYPE_1 . class ) . to ( VAR_1 ) . in ( TYPE_3 . VAR_5 ) ) ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( false , true ) ) { VAR_2 . METHOD_3 ( new TYPE_1 < TYPE_2 > ( ) { @Override <START> public void METHOD_4 ( TYPE_2 VAR_3 ) <END> { if ( VAR_3 . METHOD_5 ( ) ) { VAR_4 . set ( TYPE_3 . METHOD_6 ( ) ) ; VAR_5 . set ( System . VAR_6 ( ) ) ; } } } ) ; } } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( false , true ) ) { <START> VAR_2 . METHOD_3 ( VAR_3 - > { <END> if ( VAR_3 . METHOD_4 ( ) ) { VAR_4 . set ( TYPE_1 . METHOD_5 ( ) ) ; VAR_5 . set ( System . VAR_6 ( ) ) ; } } ) ; } } 
void METHOD_1 ( Throwable e ) { if ( METHOD_2 ( VAR_1 , TYPE_1 . METHOD_3 ( e ) , state - > state . VAR_2 ( ) == VAR_3 ) ) { VAR_4 . METHOD_4 ( ) ; VAR_5 . METHOD_5 ( ) ; } <START> METHOD_6 ( VAR_1 . get ( ) . METHOD_7 ( ) == VAR_6 , <END> STRING_1 ) ; } 
<START> public TYPE_5 ( String field , TYPE_3 . TYPE_5 VAR_2 , TYPE_3 . TYPE_4 VAR_3 ) <END> { this . field = field ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public String toString ( ) { return METHOD_1 ( this ) <START> . METHOD_2 ( ) <END> . add ( STRING_1 , filter ) . toString ( ) ; } 
<START> public synchronized TYPE_1 < TYPE_2 < TYPE_3 > > METHOD_1 ( ) <END> { VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null ) { return METHOD_3 ( VAR_2 ) ; } TYPE_4 < TYPE_2 < TYPE_3 > > VAR_3 = TYPE_4 . create ( ) ; VAR_4 . add ( VAR_3 ) ; return VAR_3 ; } 
public long METHOD_1 ( ) { <START> return VAR_1 + VAR_2 + VAR_3 * VAR_4 . size ( ) + <END> VAR_4 . stream ( ) . METHOD_2 ( List : : stream ) . METHOD_3 ( TYPE_1 : : METHOD_4 ) . METHOD_5 ( ) ; } 
public TYPE_1 get ( ) { if ( VAR_1 . isEmpty ( ) ) { return VAR_2 ; } <START> else { <END> return new TYPE_2 ( session , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_1 , VAR_7 , VAR_8 ) ; } } 
private long METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == 0 ) { return VAR_2 + VAR_3 + VAR_1 . METHOD_3 ( ) . stream ( ) . METHOD_4 ( child - > METHOD_1 ( ( TYPE_2 ) child ) ) . METHOD_5 ( ) ; } <START> else { <END> return VAR_2 + VAR_3 + VAR_1 . METHOD_3 ( ) . stream ( ) . METHOD_4 ( child - > METHOD_1 ( ( TYPE_1 ) child ) ) . METHOD_5 ( ) ; } } 
public int METHOD_1 ( Type type , TYPE_1 VAR_1 , int position ) { if ( type . equals ( TYPE_2 ) ) { return METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 , position ) ) ; } if ( type . equals ( TYPE_3 ) ) { <START> long VAR_2 = VAR_1 . METHOD_3 ( position , 0 ) ; <END> long VAR_3 = VAR_4 . METHOD_4 ( VAR_2 ) ; long VAR_5 = TYPE_4 . METHOD_5 ( VAR_3 ) ; return METHOD_2 ( VAR_5 ) ; } throw new IllegalArgumentException ( STRING_1 + type ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 session , TYPE_3 table ) { TYPE_4 VAR_1 = METHOD_2 ( table , TYPE_4 . class , STRING_1 ) ; <START> METHOD_3 ( VAR_1 . METHOD_4 ( ) . equals ( VAR_2 ) , STRING_2 ) ; <END> TYPE_5 VAR_3 = new TYPE_5 ( VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_6 ( ) ) ; return METHOD_1 ( session , VAR_3 ) ; } 
private void METHOD_1 ( int field , Set < Type > VAR_1 ) { Type VAR_2 = getType ( field ) ; METHOD_2 ( VAR_1 . contains ( VAR_2 ) , STRING_1 , field , VAR_2 ) ; StringBuilder builder = new StringBuilder ( ) ; for ( Type type : VAR_1 ) { builder . append ( STRING_2 ) ; <START> builder . append ( type . VAR_3 ( ) ) ; <END> } } 
public long METHOD_1 ( int field ) { <START> METHOD_2 ( field , TYPE_1 . of ( VAR_1 , VAR_2 ) ) ; <END> return Long . valueOf ( String . valueOf ( METHOD_3 ( field ) ) ) ; } 
<START> public synchronized void METHOD_1 ( TYPE_1 < Map < TYPE_2 , TYPE_3 > > VAR_1 ) <END> { this . VAR_1 = Optional . of ( METHOD_2 ( VAR_1 , STRING_1 ) ) ; } 
TYPE_4 ( TYPE_1 config , TYPE_2 < TYPE_3 > VAR_2 ) { <START> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; <END> this . config = METHOD_1 ( config , STRING_2 ) ; } 
private static List < File > METHOD_1 ( File VAR_1 ) { <START> if ( ( VAR_1 != null ) && VAR_1 . METHOD_2 ( ) ) { <END> File [ ] VAR_2 = VAR_1 . METHOD_1 ( ) ; if ( VAR_2 != null ) { return ImmutableList . VAR_3 ( VAR_2 ) ; } } return ImmutableList . of ( ) ; } 
<START> public void METHOD_1 ( ) <END> { VAR_1 . METHOD_2 ( ) ; } 
<START> public static < T > TYPE_1 < T > METHOD_1 ( String VAR_1 , Type VAR_2 ) <END> { return new TYPE_1 < > ( VAR_1 , VAR_2 , Object : : toString , TYPE_2 . METHOD_2 ( ) ) ; } 
public TYPE_3 ( List < TYPE_1 < ? > > properties ) { <START> this ( STRING_1 , Optional . of ( STRING_2 ) , VAR_2 , VAR_3 , System . currentTimeMillis ( ) , properties , TYPE_2 . of ( ) , true ) ; <END> } 
public void close ( ) { <START> METHOD_1 ( VAR_1 . get ( ) , STRING_1 ) ; <END> if ( ! state . VAR_2 ( TYPE_1 . VAR_4 , TYPE_1 . VAR_5 ) ) { return ; } VAR_6 . METHOD_2 ( ) ; METHOD_3 ( ( ) - > VAR_7 ) ; } 
<START> public boolean set ( ANNOTATION_1 TYPE_1 value ) <END> { return super . set ( value ) ; } 
public static Boolean METHOD_1 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 VAR_1 ) { <START> return METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; <END> } 
public Object METHOD_1 ( TYPE_1 data ) <START> throws Throwable <END> { return TYPE_2 . METHOD_1 ( data . VAR_1 , data . VAR_2 ) ; } 
public void close ( ) { if ( client == null ) { return ; } try { client . close ( ) ; } catch ( Exception e ) { <START> log . warn ( STRING_1 , e ) ; <END> } } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> METHOD_1 ( VAR_3 , STRING_1 ) ; <END> METHOD_1 ( VAR_2 , STRING_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_2 = VAR_2 ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> this . VAR_3 = METHOD_1 ( VAR_3 , STRING_1 ) ; <END> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_2 ) ; } 
void METHOD_1 ( ) { try { <START> VAR_1 . METHOD_2 ( ) ; <END> } catch ( Exception VAR_2 ) { } } 
public int METHOD_1 ( ) { int result = VAR_1 ; result += TYPE_1 . METHOD_2 ( VAR_2 . size ( ) ) ; for ( TYPE_2 VAR_3 : VAR_2 ) { <START> result += VAR_4 + VAR_3 . METHOD_3 ( ) . length ( ) * TYPE_3 . VAR_6 ; <END> } return result ; } 
public void METHOD_1 ( TYPE_1 value , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) throws IOException { if ( VAR_4 ) { VAR_4 = false ; TYPE_5 < Object > VAR_5 = VAR_6 . METHOD_2 ( value . getClass ( ) , true , null ) ; VAR_5 . METHOD_1 ( value , VAR_1 , VAR_2 , VAR_3 ) ; <START> VAR_4 = true ; <END> return ; } VAR_7 . METHOD_1 ( value , VAR_1 , VAR_2 , VAR_3 ) ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( name ) ; <END> } 
<START> public static Optional < TYPE_1 > METHOD_1 ( Optional < String > VAR_1 ) <END> { return VAR_1 . map ( name - > new TYPE_2 ( name ) ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( ImmutableList . VAR_1 ( this . VAR_2 ) ) ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> while ( ( VAR_1 instanceof TYPE_2 ) && ! VAR_1 . getType ( ) . METHOD_2 ( VAR_2 ) ) { <END> VAR_1 = ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( 0 ) ; } if ( VAR_1 instanceof TYPE_2 && VAR_1 . getType ( ) . METHOD_4 ( ) == null && ( ( TYPE_2 ) VAR_1 ) . METHOD_5 ( ) == 1 ) { return ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( 0 ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . get ( ) ; <START> TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 . METHOD_4 ( ) ; <END> VAR_3 . METHOD_5 ( ) ; METHOD_6 ( TYPE_3 . of ( STRING_1 ) , STRING_2 ) ; METHOD_6 ( TYPE_3 . of ( STRING_1 , STRING_3 ) , STRING_4 ) ; } 
public boolean METHOD_1 ( int field ) { <START> return TYPE_1 . METHOD_1 ( value ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 session , TYPE_4 VAR_2 , List < TYPE_5 > VAR_3 , List < TYPE_5 > VAR_4 ) { <START> TYPE_6 VAR_5 = ( TYPE_6 ) VAR_2 ; <END> return new TYPE_7 ( VAR_6 , VAR_5 , VAR_3 , VAR_4 , VAR_7 , VAR_8 ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_4 . VAR_2 ) long input ) { <START> return TYPE_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( input ) . METHOD_1 ( ) ) ; <END> } 
public void close ( ) { try ( TYPE_1 VAR_1 = TYPE_1 . create ( ) ) { VAR_1 . METHOD_1 ( TYPE_2 : : close ) ; VAR_1 . METHOD_1 ( TYPE_3 : : close ) ; VAR_1 . METHOD_1 ( TYPE_4 : : close ) ; VAR_2 . METHOD_2 ( 0 ) ; VAR_3 . METHOD_2 ( 0 ) ; <START> VAR_4 . METHOD_2 ( 0 ) ; <END> } catch ( IOException e ) { throw new RuntimeException ( STRING_1 , e ) ; } } 
<START> public TYPE_1 METHOD_1 ( ) <END> { if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( VAR_2 . get ( ) , STRING_1 ) ; METHOD_3 ( VAR_1 . length ( ) == VAR_3 , STRING_2 , VAR_1 . length ( ) , VAR_3 ) ; VAR_1 . METHOD_4 ( VAR_4 ) ; } return VAR_1 ; } 
public boolean METHOD_1 ( ) { METHOD_2 ( ! VAR_1 ) ; VAR_1 = VAR_2 . METHOD_1 ( ) ; if ( ! VAR_1 ) { return false ; } <START> VAR_1 = true ; <END> result = VAR_3 . apply ( VAR_2 . METHOD_3 ( ) ) ; return true ; } 
public List < Type > METHOD_1 ( ) { <START> return ( List < Type > ) VAR_1 . METHOD_1 ( ) ; <END> } 
private TYPE_2 ( ) { <START> throw new TYPE_1 ( ) ; <END> } 
<START> public TYPE_2 ( <END> Type VAR_2 , int VAR_3 ) { VAR_4 = VAR_2 . METHOD_1 ( null , METHOD_2 ( VAR_3 , TYPE_1 . VAR_5 ) ) ; VAR_6 = new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_4 . VAR_2 ) double x , ANNOTATION_1 ( TYPE_4 . VAR_2 ) double y ) { <START> TYPE_2 VAR_3 = METHOD_2 ( TYPE_2 . METHOD_3 ( new TYPE_3 ( x , y ) , null ) , STRING_1 , VAR_4 ) ; <END> return METHOD_4 ( VAR_3 ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_4 . VAR_2 ) double x , ANNOTATION_1 ( TYPE_4 . VAR_2 ) double y ) { <START> TYPE_2 VAR_3 = TYPE_2 . METHOD_2 ( new TYPE_3 ( x , y ) , null ) ; <END> return METHOD_3 ( VAR_3 ) ; } 
public void METHOD_1 ( long value ) { VAR_1 ++ ; VAR_2 = Math . VAR_3 ( value , VAR_2 ) ; VAR_4 = Math . max ( value , VAR_4 ) ; <START> try { <END> VAR_5 = METHOD_2 ( VAR_5 , value ) ; } catch ( TYPE_1 e ) { VAR_6 = true ; } } 
<START> protected TYPE_2 ( ) <END> { super ( TYPE_1 : : METHOD_1 ) ; } 
public synchronized Map < TYPE_1 , TYPE_2 > METHOD_1 ( TYPE_3 session , TYPE_4 VAR_1 ) { return VAR_2 . entrySet ( ) . stream ( ) . filter ( entry - > VAR_1 . METHOD_2 ( entry . getKey ( ) ) ) <START> . collect ( TYPE_5 . METHOD_3 ( <END> Map . Entry : : getKey , entry - > new TYPE_2 ( entry . getKey ( ) , Optional . empty ( ) , entry . getValue ( ) ) ) ) ; } 
<START> static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 . Context context ) <END> { return TYPE_3 . METHOD_1 ( VAR_1 , context . VAR_2 ( ) . METHOD_2 ( ) , context . VAR_2 ( ) ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , Map < TYPE_2 , Type > VAR_2 , TYPE_3 VAR_3 ) { METHOD_2 ( ! ( VAR_1 instanceof TYPE_4 ) , STRING_1 ) ; <START> if ( VAR_1 instanceof TYPE_5 ) { <END> return VAR_1 ; } return TYPE_6 . METHOD_3 ( new TYPE_7 ( VAR_2 , VAR_3 ) , VAR_1 , new Context ( ) ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 session , TYPE_3 metadata , TYPE_4 VAR_2 , TYPE_5 VAR_3 ) { METHOD_2 ( metadata , STRING_1 ) ; METHOD_2 ( VAR_2 , STRING_2 ) ; <START> METHOD_3 ( ! ( VAR_1 instanceof TYPE_6 ) , STRING_3 ) ; <END> if ( VAR_1 instanceof TYPE_7 ) { return VAR_1 ; } Map < TYPE_8 < TYPE_1 > , Type > VAR_4 = METHOD_4 ( session , metadata , VAR_2 , VAR_3 . METHOD_5 ( ) , VAR_1 , METHOD_6 ( ) ) ; return METHOD_1 ( VAR_1 , VAR_4 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 request , Exception exception ) <START> throws RuntimeException <END> { throw new RuntimeException ( STRING_1 , exception ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_2 ( ) ; } 
<START> private static final Type METHOD_1 ( Type VAR_1 , Type VAR_2 ) <END> { return new TYPE_1 ( new TYPE_2 ( ImmutableList . of ( VAR_1 , VAR_2 ) , Optional . empty ( ) ) ) ; } 
private boolean METHOD_1 ( ) { if ( VAR_1 . isEmpty ( ) ) { return false ; } <START> if ( VAR_2 || VAR_1 . METHOD_2 ( ) ) { <END> METHOD_3 ( ) ; return true ; } return false ; } 
public void close ( ) throws IOException { try { METHOD_1 ( ) ; output . close ( ) ; } finally { <START> TYPE_1 VAR_1 = TYPE_1 . create ( ) ; <END> VAR_1 . METHOD_2 ( TYPE_2 : : METHOD_3 ) ; for ( TYPE_3 TYPE_4 : VAR_2 ) { VAR_1 . METHOD_2 ( TYPE_4 : : METHOD_3 ) ; } VAR_1 . close ( ) ; } } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( filter , VAR_1 , VAR_2 ) ; <END> } 
private static TYPE_1 METHOD_1 ( ) { return new TYPE_2 ( ImmutableList . of ( VAR_1 ) , ImmutableList . of ( ) , ImmutableList . of ( ImmutableList . of ( TYPE_3 . METHOD_2 ( 0 ) ) ) , ImmutableList . of ( ) , Optional . empty ( ) , <START> Optional . of ( new TYPE_5 . TYPE_6 ( 0 ) ) ) ; <END> } 
public String toString ( ) { <START> String VAR_1 = TYPE_1 . METHOD_1 ( STRING_1 ) <END> . METHOD_2 ( VAR_2 . entrySet ( ) . stream ( ) . map ( entry - > entry . getKey ( ) + STRING_2 + entry . getValue ( ) ) . collect ( METHOD_3 ( ) ) ) ; return METHOD_4 ( this ) . add ( STRING_3 , VAR_2 ) . toString ( ) ; } 
<START> void METHOD_1 ( ) <END> { METHOD_2 ( METHOD_3 ( ) , INT_1 ) ; METHOD_2 ( METHOD_3 ( ) , STRING_1 ) ; METHOD_2 ( METHOD_4 ( Integer . VAR_1 ) , INT_1 ) ; METHOD_2 ( METHOD_4 ( TYPE_1 . VAR_1 ) , INT_1 ) ; METHOD_5 ( METHOD_4 ( Integer . VAR_1 ) , STRING_1 ) ; } 
public Optional < TYPE_1 > apply ( TYPE_1 node , Context context ) { TYPE_2 VAR_1 = ( TYPE_2 ) node ; TYPE_3 VAR_2 = VAR_3 . METHOD_1 ( VAR_1 . METHOD_2 ( ) , context ) ; if ( VAR_1 . METHOD_2 ( ) . equals ( VAR_2 ) ) { return Optional . empty ( ) ; } <START> else { <END> return Optional . of ( new TYPE_2 ( node . getId ( ) , VAR_1 . METHOD_3 ( ) , VAR_2 ) ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( ) . assertThat ( VAR_1 ) . METHOD_3 ( p - > <START> p . filter ( new TYPE_1 ( STRING_1 ) , p . values ( ) ) ) <END> . METHOD_4 ( filter ( STRING_2 , TYPE_2 . values ( ) ) ) ; } 
<START> protected TYPE_2 ( TYPE_1 VAR_2 ) <END> { this . VAR_3 = VAR_2 ; } 
private static byte [ ] METHOD_1 ( final byte [ ] a ) { final int length = a . length ; <START> int i = length / 2 ; <END> while ( i -- != 0 ) { final byte t = a [ length - i - 1 ] ; a [ length - i - 1 ] = a [ i ] ; a [ i ] = t ; } return a ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 output , TYPE_3 VAR_1 , List < Type > VAR_2 , Optional < TYPE_2 > VAR_3 ) <END> { METHOD_2 ( VAR_1 instanceof TYPE_4 ) ; TYPE_4 VAR_4 = ( TYPE_4 ) VAR_1 ; TYPE_5 VAR_5 = metadata . VAR_6 ( ) . METHOD_3 ( VAR_4 . getName ( ) , TYPE_6 . METHOD_4 ( VAR_2 ) ) ; return METHOD_1 ( output , new TYPE_7 ( VAR_4 , VAR_5 , VAR_3 ) ) ; } 
public TYPE_3 ( TYPE_1 metadata , TYPE_2 VAR_2 ) <START> { <END> super ( ( VAR_3 , context ) - > METHOD_1 ( VAR_3 , context , metadata , VAR_2 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { Exception VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == null ) { return null ; } <START> else { <END> return TYPE_2 . METHOD_3 ( VAR_1 ) . METHOD_4 ( ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 config ) { <START> return TYPE_3 . METHOD_2 ( METHOD_3 ( config . VAR_1 ( ) , METHOD_4 ( STRING_1 ) ) ) ; <END> } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 , Class < ? > VAR_2 ) <END> { Set < TYPE_2 > VAR_3 = METHOD_2 ( VAR_1 ) ; Set < TYPE_2 > VAR_4 = METHOD_3 ( VAR_2 ) ; return VAR_3 . METHOD_4 ( VAR_4 ) ; } 
private < T extends TYPE_1 > void METHOD_1 ( TYPE_1 node , ImmutableList . Builder < T > VAR_1 ) { node = VAR_2 . METHOD_2 ( node ) ; if ( VAR_3 . METHOD_3 ( node ) ) { VAR_1 . add ( ( T ) node ) ; } <START> if ( VAR_4 . METHOD_3 ( node ) || VAR_3 . METHOD_3 ( node ) ) { <END> for ( TYPE_1 source : node . VAR_5 ( ) ) { METHOD_1 ( source , VAR_1 ) ; } } } 
public long METHOD_1 ( int VAR_1 , int length ) { int VAR_2 = METHOD_2 ( ) ; if ( VAR_1 < 0 || length < 0 || VAR_1 + length > VAR_2 ) { throw new TYPE_1 ( STRING_1 + VAR_1 + STRING_2 + VAR_2 + STRING_3 ) ; } <START> return ( long ) length * ( VAR_3 + TYPE_2 . VAR_5 ) ; <END> } 
private String METHOD_1 ( String VAR_1 ) { <START> return format ( STRING_1 , VAR_1 , TimeUnit . TYPE_1 . METHOD_2 ( 1 ) ) ; <END> } 
private static TYPE_1 < TYPE_2 > METHOD_1 ( List < TYPE_2 > VAR_1 , Collection < TYPE_3 > VAR_2 , TYPE_4 < TYPE_3 > ... VAR_3 ) { return VAR_1 . stream ( ) . map ( VAR_4 - > METHOD_2 ( VAR_4 , VAR_2 ) ) <START> . map ( VAR_4 - > TYPE_5 . METHOD_3 ( VAR_4 ) . METHOD_4 ( METHOD_5 ( ) ) ? VAR_5 : VAR_4 ) <END> . map ( METHOD_6 ( VAR_3 ) ) . collect ( METHOD_7 ( ) ) ; } 
public TYPE_5 ( ) throws Exception { <START> VAR_2 = METHOD_1 ( METHOD_2 ( ) , METHOD_2 ( ) , 4 ) ; <END> VAR_2 . METHOD_3 ( STRING_1 , STRING_1 , TYPE_1 . of ( STRING_2 , TYPE_3 . TYPE_4 . name ( ) ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_8 . TYPE_9 context ) { return new TYPE_3 ( METHOD_2 ( context ) , <START> Optional . VAR_1 ( context . VAR_2 ( ) ) . map ( i - > ( TYPE_4 ) METHOD_3 ( i ) ) , <END> METHOD_3 ( context . VAR_3 , TYPE_5 . class ) , METHOD_3 ( context . VAR_4 ( ) , TYPE_6 . class ) , METHOD_4 ( context . VAR_5 ( ) , TYPE_7 . class ) ) ; } 
public boolean METHOD_1 ( ) <START> { <END> if ( this . VAR_1 ) { return false ; } try { boolean result = this . VAR_2 . next ( ) ; if ( ! result ) { this . close ( ) ; } return result ; } catch ( TYPE_1 | RuntimeException e ) { throw this . METHOD_2 ( e ) ; } } 
<START> public void METHOD_1 ( ) <END> { VAR_1 = new TYPE_1 ( ) ; } 
private boolean METHOD_1 ( TYPE_1 node ) { <START> return ! TYPE_2 . equals ( TYPE_3 , VAR_1 . METHOD_2 ( node . getId ( ) , TYPE_3 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 ) { if ( ! METHOD_2 ( VAR_1 ) ) { <START> try { <END> return VAR_2 . METHOD_3 ( new TYPE_2 ( METHOD_4 ( VAR_1 . split ( STRING_2 ) ) . stream ( ) . map ( TYPE_3 : : METHOD_5 ) . collect ( METHOD_6 ( ) ) ) ) ; } catch ( TYPE_4 e ) { throw new TYPE_5 ( VAR_3 ) ; } } throw new TYPE_5 ( VAR_3 ) ; } 
static void METHOD_1 ( TYPE_1 VAR_1 , Set < TYPE_2 > VAR_2 , int VAR_3 ) throws InterruptedException { TYPE_3 VAR_4 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> while ( VAR_4 . METHOD_4 ( ) . stream ( ) . filter ( VAR_5 - > VAR_2 . contains ( VAR_5 . METHOD_5 ( ) ) ) . count ( ) != VAR_3 ) { <END> TYPE_4 . METHOD_6 ( INT_1 ) ; } } 
private static Optional < TYPE_1 > METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 ) { if ( ! VAR_1 . METHOD_2 ( ) . isPresent ( ) ) { return Optional . empty ( ) ; } return VAR_1 . METHOD_2 ( ) . get ( ) . entrySet ( ) . stream ( ) . filter ( entrySet - > METHOD_3 ( entrySet . getKey ( ) ) ) . METHOD_4 ( ) <START> . map ( entrySet - > entrySet . getValue ( ) ) ; <END> } 
public void METHOD_1 ( String VAR_1 , Type VAR_2 ) { <START> METHOD_2 ( VAR_1 , VAR_2 , session , VAR_3 ) ; <END> } 
public boolean METHOD_1 ( ) { <START> boolean VAR_1 = state == TYPE_1 . VAR_3 <END> || ( state == TYPE_1 . VAR_4 && VAR_5 . METHOD_2 ( ) ) ; return VAR_1 && ! VAR_6 . METHOD_2 ( ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) . assertThat ( new TYPE_1 ( ) ) . METHOD_3 ( p - > METHOD_4 ( p , VAR_1 - > VAR_1 . getName ( ) . equals ( STRING_1 ) ) ) . METHOD_5 ( METHOD_6 ( <START> TYPE_2 . of ( STRING_2 , TYPE_3 . METHOD_7 ( STRING_1 ) ) , <END> METHOD_8 ( STRING_3 , TYPE_2 . of ( STRING_4 , TYPE_4 . METHOD_9 ( VAR_2 ) ) , TYPE_2 . of ( STRING_1 , STRING_1 , STRING_4 , STRING_4 ) ) ) ) ; } 
public void close ( ) { <START> if ( VAR_1 != null ) { <END> VAR_1 . close ( ) ; } } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_4 . VAR_2 ) TYPE_1 VAR_3 ) { TYPE_1 VAR_4 = TYPE_2 . METHOD_2 ( Long . VAR_5 ) ; TYPE_3 VAR_6 = new TYPE_3 ( ) ; VAR_6 . update ( VAR_3 . METHOD_3 ( ) ) ; long VAR_7 = VAR_6 . getValue ( ) ; VAR_4 . METHOD_4 ( 0 , Long . VAR_8 ( VAR_7 ) ) ; <START> return VAR_4 ; <END> } 
public Class < ? extends TYPE_1 > METHOD_1 ( ) { <START> return TYPE_4 . TYPE_3 . class ; <END> } 
private static TYPE_1 METHOD_1 ( String name ) { TYPE_2 VAR_1 = new TYPE_2 ( STRING_1 ) ; TYPE_3 VAR_2 = new TYPE_4 ( new TYPE_5 ( name ) , <START> new TYPE_6 ( new TYPE_7 ( STRING_2 ) , new TYPE_13 . TYPE_12 ( ) ) , <END> ImmutableList . of ( VAR_1 ) , TYPE_9 . of ( VAR_1 , new TYPE_10 ( STRING_1 ) ) , Optional . empty ( ) , TYPE_11 . METHOD_2 ( ) , null ) ; return METHOD_3 ( VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 , Map < TYPE_2 , TYPE_3 > VAR_2 ) { <START> TYPE_4 VAR_3 = new TYPE_4 ( new TYPE_5 ( STRING_1 ) , new TYPE_8 . TYPE_7 ( ) ) ; <END> return METHOD_1 ( VAR_3 , VAR_1 , VAR_2 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 connection = METHOD_2 ( ) . METHOD_3 ( ) ; if ( METHOD_4 ( connection ) ) { assertThat ( VAR_1 ) . METHOD_5 ( VAR_2 , VAR_3 , VAR_2 ) ; } <START> else if ( METHOD_6 ( connection ) ) { <END> assertThat ( VAR_1 ) . METHOD_5 ( VAR_2 , VAR_3 , VAR_2 ) ; } else { throw new IllegalStateException ( ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( ! Thread . VAR_1 ( this ) , STRING_1 ) ; state . VAR_2 ( VAR_3 , VAR_4 ) ; state . VAR_2 ( VAR_5 , VAR_6 ) ; VAR_7 . METHOD_3 ( ) ; VAR_8 . METHOD_1 ( ) ; <START> for ( TYPE_1 VAR_9 : METHOD_4 ( ) ) { <END> if ( VAR_8 . isEmpty ( ) ) { VAR_9 . METHOD_1 ( ) ; } else { VAR_9 . METHOD_5 ( VAR_8 ) ; } } METHOD_6 ( ) ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> if ( VAR_3 ) { VAR_4 = null ; } } 
private static TYPE_1 < ? > METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 < ? > VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_2 . METHOD_3 ( ) ) { <END> VAR_2 = VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . set ( Optional . of ( VAR_1 . create ( TYPE_2 . of ( ) , new TYPE_3 ( ) { <START> private final TYPE_4 VAR_3 = METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ; <END> @Override public TYPE_4 METHOD_4 ( ) { return VAR_3 ; } } ) ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 = VAR_1 != null ? VAR_1 : VAR_2 . get ( ) ; <END> VAR_3 = new TYPE_1 ( ) ; VAR_4 = new TYPE_2 ( ) ; VAR_5 = new TYPE_3 ( VAR_1 . METHOD_2 ( ) ) ; } 
public TYPE_4 ( TYPE_1 client , TYPE_2 out ) { this . client = client ; this . out = out ; this . VAR_2 = new TYPE_3 ( out ) ; this . debug = client . VAR_3 ( ) ; <START> this . VAR_4 = new HashMap < > ( ) ; <END> } 
public double next ( ) throws IOException { <START> input . VAR_1 ( buffer , 0 , ( int ) VAR_2 ) ; <END> return VAR_3 . METHOD_1 ( 0 ) ; } 
public synchronized Optional < TYPE_1 > METHOD_1 ( TYPE_2 session , TYPE_3 VAR_1 , Collection < TYPE_4 > VAR_2 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; <START> METHOD_3 ( VAR_1 instanceof TYPE_5 ) ; <END> TYPE_5 VAR_3 = ( TYPE_5 ) VAR_1 ; METHOD_4 ( VAR_3 . METHOD_5 ( ) , VAR_2 ) ; return Optional . empty ( ) ; } 
private static long METHOD_1 ( TYPE_1 [ ] values ) { <START> long VAR_1 = TYPE_2 . METHOD_2 ( values ) ; <END> Map < Object , Boolean > VAR_2 = new TYPE_3 < > ( values . length ) ; for ( TYPE_1 value : values ) { if ( value != null && value . VAR_3 ( ) != null && VAR_2 . put ( value . VAR_3 ( ) , true ) == null ) { VAR_1 += value . VAR_4 ( ) ; } } return VAR_1 ; } 
<START> public Optional < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) <END> { METHOD_2 ( VAR_1 instanceof TYPE_3 ) ; return VAR_2 . METHOD_3 ( VAR_1 ) . METHOD_4 ( this , VAR_1 ) ; } 
public Optional < TYPE_1 > METHOD_1 ( TYPE_2 node , TYPE_3 VAR_1 ) { Optional < TYPE_1 > result = METHOD_2 ( node . VAR_2 ( ) ) ; <START> return result . map ( VAR_3 - > { <END> return new TYPE_1 ( TYPE_5 < TYPE_4 > builder ( ) . addAll ( VAR_3 . METHOD_3 ( ) ) . add ( node . VAR_5 ( ) ) . build ( ) , VAR_3 . METHOD_4 ( ) ) ; } ) ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( message , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; <END> } 
protected Boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_2 instanceof TYPE_1 ) { TYPE_1 VAR_3 = ( TYPE_1 ) VAR_2 ; <START> return METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_3 . METHOD_3 ( ) ) && METHOD_2 ( VAR_1 . METHOD_4 ( ) , VAR_3 . METHOD_4 ( ) ) ; <END> } return false ; } 
public String METHOD_1 ( Object value , Class < ? > VAR_1 ) { METHOD_2 ( value , STRING_1 ) ; if ( value instanceof TYPE_1 ) { TYPE_1 VAR_2 = ( TYPE_1 ) value ; if ( VAR_2 instanceof TYPE_2 ) { return VAR_2 . getName ( ) + STRING_2 + VAR_3 . apply ( ( TYPE_3 ) ( ( TYPE_2 ) VAR_2 ) . METHOD_3 ( ) ) ; } return VAR_2 . getName ( ) ; } <START> else <END> return null ; } 
<START> public void METHOD_1 ( ) { <END> assertThat ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( true ) , METHOD_4 ( STRING_1 ) ) ; } 
<START> public final String toString ( ) { <END> return this . VAR_1 . toString ( ) ; } 
private TYPE_1 < Throwable > METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 start ) { return new TYPE_1 < Throwable > ( ) { @Override public Throwable call ( ) { try { start . VAR_2 ( ) ; VAR_1 . METHOD_2 ( ) ; } catch ( Throwable ex ) { <START> return ex ; <END> } return null ; } } ; } 
protected void METHOD_1 ( ) { for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { TYPE_1 VAR_2 = VAR_1 . get ( i ) ; if ( VAR_2 . METHOD_2 ( ) != null ) { VAR_2 . METHOD_2 ( ) . remove ( ) ; <START> VAR_2 . METHOD_3 ( ) ; <END> } } VAR_1 . clear ( ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_4 ( ) ; VAR_3 . cluster ( ) ; } } 
public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) ) ; } catch ( TYPE_1 ex ) { } TYPE_2 VAR_2 = TYPE_2 . create ( ) . add ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_5 ( VAR_2 . build ( ) , ( TYPE_3 ) ( VAR_3 , output , VAR_4 ) - > { <START> assertThat ( VAR_5 . METHOD_6 ( ) , METHOD_7 ( STRING_3 ) ) ; <END> } ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_1 ( ( TYPE_2 ) null , null ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return METHOD_1 ( ( TYPE_3 ) null , VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { <START> try { <END> VAR_1 . METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) ) ; } catch ( TYPE_1 ex ) { } TYPE_2 VAR_2 = TYPE_2 . create ( ) . add ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_5 ( VAR_2 , ( TYPE_3 ) ( VAR_3 , output , VAR_4 ) - > { assertThat ( VAR_3 . METHOD_6 ( ) , METHOD_7 ( STRING_3 ) ) ; } ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return TYPE_2 . equals ( this . uri , VAR_1 . getName ( ) ) || TYPE_2 . equals ( this . VAR_2 , VAR_1 . METHOD_2 ( ) ) ; <END> } 
private TYPE_2 ( ) { super ( TYPE_1 . VAR_2 ) ; <START> <END> Set < String > VAR_3 = new HashSet < > ( ) ; for ( TYPE_1 name : Arrays . asList ( TYPE_1 . VAR_4 , TYPE_1 . VAR_5 , TYPE_1 . VAR_6 ) ) { VAR_3 . add ( name . VAR_7 ( ) . METHOD_1 ( ) ) ; } VAR_8 = VAR_3 ; } 
public void METHOD_1 ( String name , List < String > values ) { METHOD_2 ( name ) ; <START> List < String > VAR_1 = values . stream ( ) . filter ( TYPE_1 : : METHOD_3 ) . collect ( Collectors . VAR_2 ( ) ) ; <END> for ( String value : VAR_1 ) { METHOD_4 ( name , value ) ; } } 
public void METHOD_1 ( TYPE_2 . TYPE_3 config ) { Integer VAR_1 = config . getInt ( STRING_1 , 0 ) ; <START> VAR_2 = ( VAR_1 == null ) ? 0 : VAR_1 ; <END> } 
private String METHOD_1 ( String VAR_1 ) { if ( VAR_1 != null && VAR_1 . length ( ) > VAR_2 ) { <START> String result = VAR_1 . substring ( 0 , VAR_2 ) . METHOD_2 ( STRING_1 ) ; <END> logger . warn ( STRING_2 + result ) ; return result ; } else { return VAR_1 ; } } 
<START> public static TYPE_1 METHOD_1 ( ) { <END> return TYPE_1 . create ( ) . METHOD_2 ( TYPE_2 . VAR_2 ) . METHOD_2 ( TYPE_2 . VAR_3 ) . METHOD_2 ( TYPE_2 . VAR_4 ) ; } 
<START> public static TYPE_1 METHOD_1 ( Map < String , String > data ) { <END> return new TYPE_1 ( data ) ; } 
public boolean METHOD_1 ( String VAR_1 ) { <START> return VAR_1 == null || VAR_1 . equals ( TYPE_1 . VAR_3 ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return VAR_1 . METHOD_1 ( this , 0 , VAR_1 . METHOD_2 ( this ) . METHOD_3 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( final String value ) { String VAR_1 = this . METHOD_2 ( value ) ; if ( VAR_1 != null ) { if ( this . VAR_2 == null ) { throw new IllegalStateException ( STRING_1 ) ; } return this . VAR_2 . METHOD_3 ( VAR_1 ) ; } else { ByteBuffer buffer = value != null ? ByteBuffer . VAR_3 ( value . VAR_4 ( TYPE_3 . VAR_6 ) ) : null ; return TYPE_2 . METHOD_4 ( Optional . VAR_7 ( buffer ) ) ; } <START> } <END> 
public TYPE_1 ( ANNOTATION_1 Path path , ANNOTATION_1 String VAR_2 ) { VAR_3 = path ; VAR_4 = ( VAR_5 , VAR_6 ) - > VAR_5 . METHOD_1 ( VAR_2 + STRING_1 + VAR_6 ) ; <START> logger . VAR_7 ( STRING_2 , VAR_3 . METHOD_2 ( ) . toString ( ) ) ; <END> } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; if ( config . VAR_2 ( ) == TYPE_2 . VAR_4 ) { return VAR_1 ; } else { List < TYPE_1 > VAR_5 = super . METHOD_1 ( ) ; VAR_1 . addAll ( VAR_5 ) ; return VAR_1 ; } } 
protected List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 != null ) { return new ArrayList < > ( VAR_1 ) ; } List < TYPE_2 > VAR_2 = METHOD_2 ( VAR_3 ) ; <START> List < TYPE_1 > result = new ArrayList < > ( ) ; <END> for ( TYPE_2 VAR_4 : VAR_2 ) { TYPE_1 VAR_5 = METHOD_3 ( VAR_6 , VAR_4 , this ) ; if ( VAR_5 != null ) { result . add ( VAR_5 ) ; } } VAR_1 = new HashSet < > ( result ) ; return result ; } 
TYPE_3 VAR_2 ( ) throws TYPE_5 ; TYPE_2 VAR_5 ( String VAR_6 ) throws TYPE_4 ; <START> TYPE_2 VAR_5 ( TYPE_1 client , TYPE_6 input ) throws TYPE_4 ; <END> TYPE_7 default void close ( ) { } 
public void METHOD_1 ( ) { int VAR_1 = TYPE_1 . METHOD_2 ( ) ; int VAR_2 = VAR_1 + 1 ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; <START> METHOD_4 ( VAR_3 . METHOD_5 ( ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 request , TYPE_2 response ) throws IOException { if ( request . VAR_1 ( false ) == null && TYPE_3 . METHOD_2 ( request ) == null ) { <START> response . VAR_2 ( TYPE_3 . METHOD_3 ( request . VAR_3 ( ) ) ) ; <END> } String VAR_4 = request . VAR_5 ( ) + VAR_6 ; log . debug ( STRING_1 , VAR_4 ) ; response . VAR_7 ( VAR_4 ) ; } 
public Response update ( final TYPE_1 VAR_1 ) { VAR_2 . METHOD_1 ( ) ; try { TYPE_2 . METHOD_2 ( VAR_1 , client ) ; <START> VAR_3 . METHOD_3 ( VAR_4 ) . METHOD_4 ( TYPE_5 . VAR_6 ) . METHOD_5 ( client ) . METHOD_6 ( VAR_1 ) . METHOD_7 ( ) ; <END> return Response . VAR_7 ( ) . build ( ) ; } catch ( TYPE_3 e ) { return TYPE_4 . exists ( STRING_1 + VAR_1 . METHOD_8 ( ) + STRING_2 ) ; } } 
<START> public String METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) throws TYPE_3 { try { TYPE_4 VAR_1 = new TYPE_4 ( TYPE_5 . METHOD_2 ( ) ) ; return VAR_1 . METHOD_1 ( VAR_2 , 0 ) ; <START> } catch ( Exception e ) { <END> throw new TYPE_3 ( e . toString ( ) ) ; } } 
<START> public void METHOD_1 ( ) throws Exception { <END> String VAR_1 = STRING_1 ; TYPE_1 s ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; try ( TYPE_3 is = new TYPE_4 ( VAR_1 . METHOD_2 ( ) ) ) { s = VAR_2 . METHOD_3 ( is ) ; } assertEquals ( STRING_2 , s . VAR_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; } 
public static final void METHOD_1 ( TYPE_1 group , TYPE_2 v ) { for ( TYPE_3 VAR_1 : group . VAR_2 ( ) ) { METHOD_1 ( VAR_1 , v ) ; } for ( TYPE_1 VAR_3 : group . VAR_4 ( ) ) { <START> for ( TYPE_3 VAR_1 : VAR_3 . METHOD_2 ( ) ) { <END> METHOD_1 ( VAR_1 , v ) ; } } } 
<START> public static String METHOD_1 ( String VAR_1 , boolean VAR_2 ) { <END> String result = "" ; for ( int i = VAR_1 . length ( ) - 1 ; i >= 0 ; i -- ) { result += METHOD_2 ( VAR_1 . METHOD_3 ( i ) , VAR_2 ) ; } return result ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; String f = TYPE_1 . VAR_2 ; File VAR_3 = METHOD_2 ( f ) ; try { if ( ! VAR_3 . exists ( ) ) { VAR_1 . METHOD_3 ( new TYPE_2 ( f ) , VAR_3 ) ; } } catch ( IOException e ) { <START> e . VAR_4 ( ) ; <END> } } 
public void METHOD_1 ( ) { try { File VAR_1 = METHOD_2 ( TYPE_2 . VAR_3 ) ; List < TYPE_1 > VAR_4 = TYPE_1 . METHOD_3 ( VAR_1 ) ; assertTrue ( VAR_4 . size ( ) > 0 ) ; for ( TYPE_1 s : VAR_4 ) { assertTrue ( s . VAR_5 ( ) != null ) ; } } catch ( Exception e ) { e . VAR_6 ( ) ; <START> METHOD_4 ( e . getMessage ( ) ) ; <END> } } 
<START> public static List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <END> if ( VAR_1 . METHOD_2 ( ) == CHAR_1 ) return METHOD_3 ( VAR_1 , VAR_2 ) ; return METHOD_4 ( VAR_1 , VAR_2 ) ; } 
private List < TYPE_1 > METHOD_1 ( String VAR_1 ) { <START> List < TYPE_1 > VAR_2 = new ArrayList ( ) ; <END> for ( char c : VAR_1 . METHOD_2 ( ) ) { if ( c == CHAR_1 ) VAR_2 . add ( TYPE_1 . VAR_3 ) ; else VAR_2 . add ( TYPE_1 . VAR_4 ) ; } return VAR_2 ; } 
public List < String > METHOD_1 ( ) { <START> ArrayList < String > VAR_1 = new ArrayList ( 1 ) ; <END> VAR_1 . add ( STRING_1 ) ; return VAR_1 ; } 
public TYPE_5 ( String VAR_2 , TYPE_1 < TYPE_2 > VAR_3 ) throws TYPE_3 , IOException { if ( ! TYPE_4 . matcher ( VAR_2 . METHOD_1 ( ) ) . METHOD_2 ( ) ) { throw new TYPE_3 ( STRING_1 + VAR_2 + STRING_2 ) ; } <START> METHOD_3 ( VAR_3 ) ; <END> VAR_4 = this . METHOD_4 ( VAR_2 ) ; String VAR_5 = this . METHOD_5 ( VAR_4 ) ; METHOD_6 ( VAR_5 ) ; } 
<START> public void METHOD_1 ( ANNOTATION_1 String VAR_1 ) { <END> VAR_2 = TYPE_1 . getInstance ( VAR_1 ) ; } 
<START> private void METHOD_1 ( String location , int [ ] VAR_1 , TYPE_1 < TYPE_2 > table ) throws TYPE_3 { <END> if ( VAR_1 . length > table . VAR_2 ( ) . METHOD_2 ( ) . length ) { throw TYPE_3 . METHOD_3 ( TYPE_5 . VAR_4 , VAR_1 . length , table . VAR_2 ( ) . METHOD_2 ( ) . length , location , TYPE_4 . METHOD_4 ( table . VAR_2 ( ) ) ) ; } } 
public static byte [ ] METHOD_1 ( long VAR_1 ) { long VAR_2 = VAR_1 & TYPE_2 . VAR_4 ; byte [ ] VAR_5 = new byte [ INT_1 ] ; VAR_5 [ 0 ] = ( byte ) ( ( VAR_2 / TYPE_2 . VAR_6 ) & ( VAR_7 - 1 ) ) ; <START> VAR_5 [ 0 ] = ( byte ) ( 2 ) ; <END> TYPE_1 . METHOD_2 ( VAR_2 , VAR_5 , 1 ) ; return VAR_5 ; } 
private String METHOD_1 ( String VAR_1 ) throws TYPE_1 { String VAR_2 = "" ; if ( VAR_1 != null ) { <START> VAR_2 = STRING_1 + VAR_1 + STRING_2 ; <END> } else { VAR_2 = STRING_3 + METHOD_2 ( ) ; if ( VAR_3 >= 0 ) { VAR_2 += STRING_4 + VAR_3 + STRING_5 ; } VAR_2 += STRING_2 ; } if ( METHOD_3 ( ) ) VAR_2 = STRING_6 + VAR_2 ; if ( METHOD_4 ( ) ) VAR_2 = STRING_7 + VAR_2 ; if ( VAR_4 ) VAR_2 = STRING_8 + VAR_2 ; return VAR_2 ; } 
public void METHOD_1 ( ) { VAR_1 = false ; <START> this . out . VAR_2 ( ) ; this . out = new TYPE_1 ( System . out ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; Collection < Context > VAR_2 = TYPE_2 . METHOD_5 ( ) . METHOD_6 ( TYPE_3 . VAR_3 ) ; <START> for ( Context context : VAR_2 ) { <END> ( ( TYPE_3 ) context ) . METHOD_4 ( VAR_1 ) ; } TYPE_4 . info ( LOG , STRING_1 , VAR_1 ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , Thread VAR_3 , Date VAR_4 , TYPE_2 . Type VAR_5 , TYPE_3 VAR_6 , String VAR_7 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = ( Date ) VAR_4 . METHOD_1 ( ) ; <END> this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = STRING_1 ; String VAR_2 = STRING_2 ; String VAR_3 = STRING_3 + STRING_4 + STRING_5 ; <START> TYPE_1 VAR_4 = VAR_5 . METHOD_2 ( VAR_1 ) ; <END> assertEquals ( STRING_6 + VAR_1 + STRING_6 , VAR_3 , TYPE_2 . TYPE_3 . TYPE_4 . toString ( VAR_4 ) ) ; VAR_4 . close ( ) ; VAR_4 = VAR_5 . METHOD_2 ( VAR_2 ) ; assertEquals ( STRING_6 + VAR_2 + STRING_6 , VAR_3 , TYPE_2 . TYPE_3 . TYPE_4 . toString ( VAR_4 ) ) ; } 
public TYPE_3 ( long VAR_2 , TYPE_1 VAR_3 , byte [ ] token , TYPE_2 VAR_4 , boolean VAR_5 , String VAR_6 ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; this . token = token ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; } 
protected TYPE_1 METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( ) <END> . METHOD_3 ( VAR_1 == - 1 ? 0 : VAR_1 ) . build ( ) ; } 
<START> public static String METHOD_1 ( String VAR_1 ) { <END> int VAR_2 = VAR_1 . METHOD_2 ( STRING_1 ) ; if ( VAR_2 >= 0 && VAR_1 . length ( ) > VAR_2 ) { VAR_1 = VAR_1 . substring ( + 1 ) ; } if ( VAR_1 . length ( ) > 0 ) { VAR_1 = VAR_1 . substring ( 0 , 1 ) . METHOD_3 ( ) + VAR_1 . substring ( 1 ) ; } return VAR_1 ; } 
private static void METHOD_1 ( TYPE_1 monitor ) { String VAR_1 = System . getProperty ( VAR_2 ) ; if ( VAR_1 != null ) { File VAR_3 = new File ( VAR_1 , VAR_4 ) ; <START> TYPE_2 . METHOD_2 ( VAR_3 , monitor ) ; <END> if ( VAR_3 != null && VAR_3 . METHOD_3 ( ) ) { TYPE_3 path = new TYPE_3 ( VAR_3 . METHOD_4 ( ) ) ; path . VAR_5 ( true ) ; TYPE_4 . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( path ) ; } } } 
public void start ( TYPE_1 VAR_1 ) throws Exception { TYPE_4 . context = VAR_1 ; VAR_3 = this ; <START> new TYPE_2 ( ) . METHOD_1 ( new TYPE_3 ( ) ) ; <END> } 
<START> private TYPE_1 ( String value ) { <END> this . value = value ; } 
<START> public TYPE_1 list ( Map < String , Object > params ) throws TYPE_2 { <END> return list ( params , ( TYPE_3 ) null ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> this . VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 , this . VAR_3 ) ; <END> } 
public static TYPE_1 METHOD_1 ( String id ) throws TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 { String url = METHOD_2 ( TYPE_1 . class , id ) ; return request ( TYPE_7 . VAR_2 , url , null , TYPE_1 . class , null ) ; <START> } <END> 
protected static String METHOD_1 ( Class < ? > VAR_1 , String id , Class < ? > VAR_2 , String VAR_3 ) throws TYPE_1 { try { return String . format ( STRING_1 , METHOD_2 ( VAR_1 , VAR_3 ) , METHOD_3 ( id ) , METHOD_4 ( VAR_2 ) ) ; } catch ( TYPE_2 e ) { throw new TYPE_1 ( STRING_2 + VAR_4 + STRING_3 , null , null , null , 0 , e ) ; } <START> } <END> 
public static TYPE_1 METHOD_1 ( String id , TYPE_2 options ) throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 { <START> return request ( TYPE_8 . VAR_2 , METHOD_2 ( TYPE_1 . class , id ) , null , TYPE_1 . class , options ) ; <END> } 
public void METHOD_1 ( ) throws TYPE_1 { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( STRING_1 , STRING_2 ) ; params . put ( STRING_3 , STRING_4 ) ; params . put ( STRING_5 , INT_1 ) ; <START> TYPE_2 VAR_1 = TYPE_2 . create ( params ) ; <END> assertNotNull ( VAR_1 ) ; METHOD_2 ( TYPE_3 . TYPE_4 . VAR_4 , STRING_6 , params ) ; } 
public String get ( String name ) { List < String > VAR_1 = values ( name ) ; <START> String VAR_2 = null ; <END> if ( VAR_1 != null && VAR_1 . size ( ) > 0 ) { VAR_2 = VAR_1 . get ( 0 ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 options ) throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 { <START> return request ( TYPE_9 . VAR_2 , METHOD_2 ( TYPE_8 . class , this . id ) , null , TYPE_1 . class , options ) ; <END> } 
<START> public static String METHOD_1 ( ) { <END> return String . format ( STRING_1 , TYPE_1 . METHOD_2 ( ) , STRING_2 ) ; } 
public void METHOD_1 ( ) throws TYPE_1 , InterruptedException { METHOD_2 ( 100 ) . METHOD_3 ( ) ; METHOD_2 ( INT_1 ) . METHOD_3 ( ) ; <START> METHOD_2 ( INT_2 ) . METHOD_3 ( ) ; <END> Map < String , Object > VAR_1 = new HashMap < String , Object > ( ) ; VAR_1 . put ( STRING_1 , 3 ) ; List < TYPE_2 > VAR_2 = TYPE_2 . METHOD_4 ( VAR_1 ) . METHOD_5 ( ) ; assertEquals ( 3 , VAR_2 . size ( ) ) ; } 
public static TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( TYPE_2 . VAR_1 , TYPE_2 . VAR_2 , TYPE_2 . METHOD_2 ( ) ) ; <END> } 
<START> public String METHOD_1 ( ) { <END> if ( this . METHOD_2 ( ) != null ) { return String . format ( STRING_1 , METHOD_3 ( TYPE_1 . class ) , this . METHOD_2 ( ) , this . getId ( ) ) ; } else { return String . format ( STRING_1 , METHOD_3 ( TYPE_2 . class ) , this . METHOD_4 ( ) , this . getId ( ) ) ; } } 
<START> TYPE_3 ( Builder builder ) <END> { super ( TYPE_4 . TYPE_2 , TYPE_4 . TYPE_5 , builder . VAR_5 , TYPE_1 . TYPE_6 . VAR_8 ) ; this . builder = builder ; } 
<START> private List < TYPE_1 > METHOD_1 ( ) <END> { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( VAR_2 . size ( ) ) ; for ( TYPE_1 row : VAR_2 ) { final List < TYPE_2 > VAR_3 = row . VAR_4 ( ) ; VAR_1 . add ( new TYPE_1 ( VAR_3 . get ( 0 ) , VAR_3 . get ( 1 ) , new TYPE_2 ( VAR_3 . get ( 2 ) . METHOD_2 ( ) ) ) ) ; } return VAR_1 ; } 
<START> public static ArrayList < TYPE_3 . TYPE_4 > METHOD_1 ( Collection < TYPE_2 > VAR_1 ) <END> { final ArrayList < TYPE_3 . TYPE_4 > VAR_2 = new ArrayList < TYPE_3 . TYPE_4 > ( VAR_1 . size ( ) ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { VAR_2 . add ( METHOD_2 ( VAR_3 ) ) ; } return VAR_2 ; } 
public TYPE_1 add ( TYPE_2 element ) { <START> this . VAR_1 . add ( element ) ; <END> this . VAR_2 . remove ( element ) ; return this ; } 
public boolean METHOD_1 ( TYPE_1 client ) { try { client . VAR_1 ( ) ; <START> return ! client . VAR_2 ( ) . isEmpty ( ) ; <END> } catch ( IOException VAR_3 ) { return false ; } } 
<START> public TYPE_1 METHOD_1 ( ) <END> { TYPE_1 VAR_1 = null ; for ( TYPE_2 VAR_2 : cluster ) { if ( VAR_1 == null ) VAR_1 = VAR_2 . METHOD_1 ( ) ; else VAR_1 . add ( VAR_2 . METHOD_1 ( ) ) ; } return VAR_1 ; } 
Integer METHOD_1 ( String key ) { if ( containsKey ( key ) ) { return get ( key ) ; } else { <START> System . out . println ( key + STRING_1 ) ; <END> return get ( STRING_2 ) ; } } 
void METHOD_1 ( ) { try { TYPE_1 . METHOD_2 ( ( ) - > { METHOD_3 ( ) ; <START> list = METHOD_4 ( this : : METHOD_5 ) ; <END> return null ; } ) ; } catch ( Exception e ) { logger . error ( STRING_1 , getName ( ) , e ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; TYPE_3 VAR_3 = VAR_1 ; <START> TYPE_4 VAR_4 = VAR_3 . METHOD_4 ( TYPE_4 . class ) ; <END> if ( VAR_4 != null && VAR_2 != null ) { VAR_2 . METHOD_5 ( VAR_4 ) ; } } 
public Map < TYPE_1 , Collection < TYPE_2 > > METHOD_1 ( Collection < ? extends TYPE_1 > VAR_1 ) { try { if ( ! METHOD_2 ( ) ) { return Collections . VAR_2 ( ) ; } } catch ( RuntimeException VAR_3 ) { <START> throw VAR_3 ; <END> } catch ( Exception e ) { throw TYPE_3 . METHOD_3 ( e ) ; } return VAR_4 . METHOD_1 ( VAR_1 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( ) { @Override public String METHOD_2 ( ) { return STRING_1 + VAR_1 + STRING_2 ; } @Override public TYPE_2 METHOD_3 ( ) { return TYPE_3 . METHOD_4 ( STRING_3 ) ; } @Override public String METHOD_5 ( ) { return STRING_1 + VAR_1 + STRING_4 ; } } ; } <END> 
public boolean METHOD_1 ( TYPE_1 VAR_1 , Object VAR_2 , Object element ) { if ( element instanceof TYPE_2 ) { element = ( ( TYPE_2 ) element ) . METHOD_2 ( ) ; } return ! Optional . VAR_3 ( element ) . filter ( TYPE_3 . class : : METHOD_3 ) . map ( TYPE_3 . class : : METHOD_4 ) <START> . filter ( TYPE_4 : : METHOD_5 ) <END> . filter ( p - > TYPE_6 . TYPE_7 . equals ( p . getName ( ) ) ) . isPresent ( ) ; } 
<START> public TYPE_2 ( TYPE_1 project , String message ) { <END> this . project = project ; this . VAR_2 = STRING_1 ; this . version = STRING_1 ; this . VAR_3 = message ; this . type = VAR_4 . VAR_5 ; this . path = STRING_2 ; } 
public TYPE_1 METHOD_1 ( String location , byte [ ] data ) throws Exception { <START> if ( data == null ) { <END> return null ; } TYPE_2 VAR_1 = null ; try ( TYPE_3 stream = new TYPE_4 ( data ) ) { VAR_1 = context . VAR_2 ( location ) ; if ( VAR_1 == null ) { VAR_1 = context . VAR_3 ( location , stream ) ; } else { VAR_1 . update ( stream ) ; METHOD_2 ( true ) ; } } return METHOD_3 ( VAR_1 ) ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) == TYPE_1 . VAR_2 || VAR_1 . METHOD_2 ( ) == TYPE_1 . VAR_3 ; <END> } 
default TYPE_1 VAR_2 ( Class < ? > VAR_3 ) { String VAR_4 = VAR_3 . getName ( ) ; String path = VAR_4 . VAR_5 ( CHAR_1 , CHAR_2 ) + STRING_1 ; <START> VAR_6 url = TYPE_1 . VAR_7 . VAR_8 ( ) <END> . VAR_9 ( path ) ; if ( url == null ) { throw new IllegalArgumentException ( STRING_2 + VAR_3 . getName ( ) + STRING_3 ) ; } VAR_10 ( path , url ) ; return this ; } 
static TYPE_1 parse ( String s ) { <START> if ( s == null || s . isEmpty ( ) ) <END> return TYPE_1 . VAR_1 ; return TYPE_1 . valueOf ( s ) ; } 
public void METHOD_1 ( ) throws Exception { config ( null ) ; File VAR_1 = repo . get ( STRING_1 , new TYPE_1 ( STRING_2 ) , null ) ; <START> assertThat ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( ) ; <END> File VAR_2 = repo . get ( STRING_3 , new TYPE_1 ( STRING_2 ) , null ) ; assertThat ( VAR_2 . METHOD_2 ( ) ) . METHOD_3 ( ) ; } 
boolean METHOD_1 ( ) { String VAR_1 = type . VAR_2 ( ) ; return METHOD_2 ( TYPE_1 . class ) . METHOD_3 ( a - > Arrays . stream ( a . VAR_3 ) ) <START> . filter ( VAR_4 - > TYPE_2 . METHOD_4 ( VAR_4 . VAR_5 ) ) <END> . METHOD_5 ( VAR_4 - > ! TYPE_3 . METHOD_6 ( VAR_4 . VAR_6 ) && VAR_4 . VAR_7 . equals ( VAR_1 ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> Builder b = new Builder ( ) ; <END> b . VAR_1 ( Constants . VAR_2 , STRING_1 ) ; b . VAR_1 ( STRING_2 , STRING_3 ) ; b . VAR_3 ( new File ( STRING_4 ) ) ; b . build ( ) ; METHOD_2 ( b ) ; } 
default TYPE_2 VAR_2 ( TYPE_1 VAR_2 ) { VAR_4 ( VAR_2 , STRING_1 ) ; <START> VAR_5 ( STRING_2 , VAR_2 . value ) ; <END> return this ; } 
private void METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 VAR_3 , String type ) throws Exception { <START> METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , type , ( VAR_4 , VAR_5 ) - > VAR_5 ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . call ( ( String VAR_3 ) - > { <START> VAR_4 . METHOD_2 ( new TYPE_2 ( METHOD_3 ( ) + VAR_3 ) ) ; <END> METHOD_4 ( ) ; } ) . METHOD_5 ( VAR_1 ) ; } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . METHOD_1 ( VAR_1 . getId ( ) , VAR_1 . METHOD_2 ( ) . size ( ) > 0 ? false : true ) ; <END> return VAR_1 . getName ( ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 event ) { if ( METHOD_2 ( ) . METHOD_3 ( ) != null ) { METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; } <START> METHOD_5 ( ) ; <END> } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return ; } <START> VAR_1 . METHOD_2 ( ) . forEach ( VAR_2 - > { <END> if ( METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ) { METHOD_5 ( VAR_2 ) ; } else { view . VAR_3 ( VAR_4 . METHOD_6 ( String . valueOf ( VAR_2 . getId ( ) ) , VAR_2 . getName ( ) ) ) ; } } ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 - > METHOD_3 ( VAR_2 ) ) ; <END> } 
public String toString ( ) { return STRING_1 + STRING_2 + VAR_1 + STRING_3 + VAR_2 + STRING_4 + description + CHAR_1 + STRING_5 + VAR_3 + STRING_6 + VAR_4 + CHAR_1 + STRING_7 + status + CHAR_1 + STRING_8 + VAR_5 + CHAR_1 + STRING_9 + VAR_6 + STRING_10 + VAR_7 + STRING_11 + VAR_8 + CHAR_1 + STRING_12 + VAR_9 + <START> STRING_13 + VAR_5 + <END> STRING_14 + super . toString ( ) ; } 
public void METHOD_1 ( ) { boolean VAR_1 = false ; <START> List a = Collections . VAR_2 ( VAR_3 ) ; <END> when ( VAR_4 . METHOD_2 ( ) ) . METHOD_3 ( TYPE_1 . METHOD_4 ( a . iterator ( ) , 0 ) ) ; when ( VAR_5 . METHOD_5 ( ) ) . METHOD_3 ( VAR_1 ) ; METHOD_6 ( ) . METHOD_7 ( VAR_5 ) ; METHOD_8 ( VAR_3 ) . METHOD_9 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { VAR_1 = 1 ; METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> } 
private List < TYPE_1 < T > > METHOD_1 ( TYPE_2 < T > VAR_1 , Set < String > VAR_2 ) { return ( List < TYPE_1 < T > > ) VAR_1 . METHOD_2 ( ) . stream ( ) . filter ( VAR_3 - > ! VAR_3 . METHOD_3 ( ) && VAR_2 . contains ( VAR_3 . METHOD_4 ( ) ) ) <START> . map ( VAR_4 - > { <END> return METHOD_5 ( VAR_4 . METHOD_4 ( ) , true ) ; } ) . collect ( Collectors . VAR_5 ( ) ) ; } 
public TYPE_1 < String > METHOD_1 ( ) { return VAR_1 - > METHOD_2 ( ) != null && <START> METHOD_2 ( ) != null && <END> METHOD_2 ( ) . METHOD_3 ( ) != null && VAR_1 != null && VAR_1 . equals ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> VAR_2 . METHOD_2 ( name . VAR_3 , value . VAR_3 ) ; ; <END> } 
public void METHOD_1 ( ) { String VAR_1 = STRING_1 ; String VAR_2 = STRING_2 ; String VAR_3 = STRING_3 ; String VAR_4 = STRING_4 ; <START> assertEquals ( VAR_5 . METHOD_2 ( VAR_1 , VAR_2 , VAR_2 ) , true ) ; <END> assertEquals ( VAR_5 . METHOD_2 ( VAR_3 , VAR_4 , VAR_4 ) , false ) ; assertEquals ( VAR_5 . METHOD_2 ( VAR_1 , VAR_2 , VAR_4 ) , false ) ; assertEquals ( VAR_5 . METHOD_2 ( VAR_3 , VAR_4 , VAR_2 ) , false ) ; } 
public void METHOD_1 ( ANNOTATION_1 final TYPE_1 event ) { String VAR_1 = event . VAR_2 ( ) ; String VAR_3 = event . VAR_4 ( ) ; String VAR_5 = event . VAR_6 ( ) ; VAR_7 . call ( ( String VAR_8 ) - > METHOD_2 ( VAR_8 ) , <START> ( String message , Throwable VAR_9 ) - > { <END> METHOD_2 ( "" ) ; return false ; } ) . METHOD_3 ( VAR_3 , VAR_1 , VAR_5 ) ; } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 < > ( VAR_2 ) ; when ( VAR_2 . METHOD_2 ( METHOD_3 ( TYPE_2 . class ) ) ) . METHOD_4 ( VAR_3 ) ; VAR_4 . METHOD_5 ( VAR_1 ) ; when ( view . VAR_5 ( ) ) . METHOD_4 ( new TYPE_2 ( ) ) ; METHOD_6 ( ( i ) - > { <START> VAR_4 . METHOD_7 ( ) ; <END> return null ; } ) . when ( VAR_6 ) . METHOD_8 ( METHOD_3 ( TYPE_3 . class ) ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 ) { METHOD_1 ( VAR_3 . METHOD_2 ( this ) ) ; this . VAR_2 = VAR_2 ; VAR_4 . METHOD_3 ( TYPE_5 . VAR_6 ) ; <START> VAR_4 . METHOD_4 ( new TYPE_2 ( ) { <END> @Override public void METHOD_5 ( TYPE_3 event ) { METHOD_6 ( ) ; } } ) ; } 
<START> public void METHOD_1 ( String text ) { <END> VAR_1 . METHOD_2 ( new TYPE_1 ( text ) ) ; } 
private boolean METHOD_1 ( Throwable VAR_1 ) { String message = "" ; if ( VAR_1 . getMessage ( ) != null ) { message = VAR_1 . getMessage ( ) ; <START> } else if ( VAR_1 . METHOD_2 ( ) != null ) { <END> message = VAR_1 . METHOD_2 ( ) . getMessage ( ) ; } return message . contains ( STRING_1 ) ; } 
public void METHOD_1 ( final String id ) { final TYPE_1 request = new TYPE_2 ( VAR_1 ) ; if ( TYPE_3 . equals ( type ) ) { request . VAR_2 ( VAR_3 , id ) ; } else { request . VAR_2 ( VAR_4 , <START> id ) ; <END> } request . VAR_2 ( VAR_5 , Boolean . toString ( false ) ) ; VAR_6 . METHOD_2 ( request ) ; } 
public void METHOD_1 ( final String id ) { final TYPE_1 request = new TYPE_2 ( VAR_1 ) ; request . VAR_2 ( VAR_3 , Boolean . toString ( false ) ) ; <START> VAR_4 . METHOD_2 ( request , id ) ; <END> } 
public boolean METHOD_1 ( Class < ? > VAR_1 ) { <START> return byte . class == VAR_1 || <END> boolean . class == VAR_1 || short . class == VAR_1 || int . class == VAR_1 || long . class == VAR_1 || double . class == VAR_1 ; } 
public boolean [ ] METHOD_1 ( ) throws TYPE_1 { <START> TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> boolean [ ] VAR_3 = new boolean [ VAR_1 . size ] ; for ( int i = 0 ; i < VAR_1 . size ; i ++ ) { VAR_3 [ i ] = METHOD_3 ( ) ; } VAR_2 . METHOD_4 ( ) ; return VAR_3 ; } 
public boolean [ ] read ( TYPE_1 VAR_1 ) throws Exception { <START> TYPE_2 . METHOD_1 ( VAR_1 , STRING_1 ) ; <END> return new TYPE_3 ( VAR_1 ) . METHOD_2 ( ) ; } 
public boolean METHOD_1 ( Class < ? > VAR_1 ) { <START> if ( boolean . class == VAR_1 ) { <END> return true ; } if ( short . class == VAR_1 ) { return true ; } if ( int . class == VAR_1 ) { return true ; } if ( long . class == VAR_1 ) { return true ; } if ( double . class == VAR_1 ) { return true ; } return false ; } 
public TYPE_3 ( TYPE_1 VAR_2 , Class < T > VAR_3 , TYPE_2 VAR_4 , String VAR_5 ) { <START> this ( VAR_2 , VAR_3 , VAR_6 , VAR_4 , VAR_5 ) ; <END> } 
private void METHOD_1 ( ) throws TYPE_1 { <START> if ( ! configuration . VAR_1 ( ) . isEmpty ( ) ) { <END> TYPE_2 factory = new TYPE_2 ( ) ; factory . VAR_2 ( METHOD_2 ( ) ) ; VAR_3 = factory . VAR_4 ( ) ; return ; } VAR_3 = TYPE_2 . METHOD_3 ( ) ; } 
public String METHOD_1 ( ) { if ( VAR_1 . startsWith ( STRING_1 ) ) { <START> return VAR_1 . substring ( INT_1 ) ; <END> } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) { String [ ] VAR_3 = VAR_2 . METHOD_2 ( ) ; for ( String VAR_4 : VAR_3 ) { <START> String VAR_5 = VAR_4 + VAR_1 ; if ( VAR_2 . METHOD_3 ( VAR_5 ) != null ) { VAR_1 = VAR_4 + VAR_1 ; return VAR_2 . METHOD_3 ( VAR_1 ) ; <END> } } return null ; } 
private String METHOD_1 ( String url ) { <START> String path = TYPE_1 . create ( url ) . getPath ( ) ; <END> for ( Map . Entry < String , String > VAR_1 : VAR_2 . entrySet ( ) ) { if ( path . startsWith ( VAR_1 . getKey ( ) ) ) { return url . VAR_3 ( VAR_1 . getKey ( ) , VAR_1 . getValue ( ) ) ; } } return url ; } 
public String getValue ( Object obj ) { TYPE_1 result = ( TYPE_1 ) obj ; TYPE_2 VAR_1 = result . VAR_2 ( ) . METHOD_1 ( TYPE_2 . class ) ; <START> TYPE_3 page = Optional . VAR_3 ( VAR_1 ) . map ( p - > p . VAR_4 ( result ) ) . METHOD_2 ( null ) ; <END> return page != null ? page . getPath ( ) : "" ; } 
public void METHOD_1 ( TYPE_1 type , Collection < String > VAR_1 ) { <START> Set < String > VAR_2 = VAR_3 . METHOD_2 ( type , new TYPE_2 < > ( ) ) ; <END> for ( String VAR_4 : VAR_1 ) { VAR_2 . add ( VAR_4 ) ; } VAR_3 . put ( type , VAR_2 ) ; } 
<START> public String [ ] METHOD_1 ( ) { <END> return new String [ ] { STRING_1 } ; } 
public void METHOD_1 ( TYPE_1 context ) throws TYPE_2 { <START> log . info ( STRING_1 ) ; <END> VAR_1 = context . VAR_2 ( ) ; METHOD_2 ( ) ; log . info ( STRING_2 ) ; } 
public void METHOD_1 ( TYPE_1 context ) throws TYPE_2 { <START> log . info ( STRING_1 ) ; <END> for ( String id : VAR_1 . keySet ( ) ) { METHOD_2 ( id ) ; } log . info ( STRING_2 ) ; } 
public void start ( Context c ) { VAR_1 = c ; TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 . METHOD_1 ( Context . VAR_3 ) ; if ( VAR_4 == null ) { VAR_4 = VAR_2 . METHOD_2 ( TYPE_1 . VAR_5 ) ; } if ( VAR_4 != null ) { <START> VAR_2 . METHOD_3 ( TYPE_1 . VAR_6 , 0 , 0 , VAR_7 ) ; <END> } } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( TYPE_2 . METHOD_2 ( VAR_1 ) ) { <START> Log . VAR_2 ( VAR_3 , STRING_1 ) ; <END> return false ; } if ( TYPE_3 . contains ( VAR_1 ) ) { Log . VAR_2 ( VAR_3 , STRING_2 + VAR_1 ) ; return false ; } if ( TYPE_2 . contains ( VAR_1 ) ) { Log . VAR_2 ( VAR_3 , STRING_3 + VAR_1 ) ; return false ; } return true ; } 
public void METHOD_1 ( ) { if ( VAR_1 == null ) { return ; } VAR_1 . METHOD_2 ( VAR_2 ) ; METHOD_3 ( false , VAR_3 ) ; METHOD_3 ( false , VAR_4 ) ; <START> VAR_1 = null ; <END> } 
<START> public static void METHOD_1 ( Context c ) { <END> if ( VAR_1 != null ) { return ; } VAR_1 = new TYPE_1 ( c ) ; } 
<START> public static TYPE_1 getInstance ( ) { <END> assert ( VAR_1 != null ) ; assert ( VAR_1 . getClass ( ) . METHOD_1 ( TYPE_1 . class ) ) ; return ( TYPE_1 ) VAR_1 ; } 
public TYPE_1 ( TYPE_2 VAR_1 ) { <START> super ( TYPE_1 . class ) ; <END> this . VAR_1 = VAR_1 ; } 
public boolean equals ( final Object obj ) { <START> if ( ! ( obj instanceof TYPE_1 ) ) { <END> return false ; } return VAR_1 . equals ( obj ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 request , List < TYPE_1 > VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( request , STRING_1 ) ; <START> return VAR_2 != null ? VAR_2 : VAR_1 . stream ( ) . METHOD_3 ( ) . METHOD_4 ( null ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { if ( ! StringUtils . isEmpty ( VAR_1 ) ) { if ( VAR_1 . startsWith ( STRING_1 ) ) { VAR_1 = VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; } try { final TYPE_1 VAR_2 = TYPE_2 . parse ( VAR_1 , null ) ; if ( TYPE_2 . METHOD_3 ( VAR_2 ) ) { return VAR_2 ; } } catch ( TYPE_3 e ) { <START> System . out . println ( STRING_3 + e ) ; <END> return null ; } } return null ; } 
public String METHOD_1 ( String VAR_1 ) { final TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 != null ) { <END> return TYPE_2 . format ( VAR_2 , TYPE_3 . VAR_4 ) ; } return null ; } 
private List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; <END> TYPE_2 . METHOD_2 ( TYPE_3 . getInstance ( ) . METHOD_3 ( ) , new TYPE_4 ( ) { @Override public boolean METHOD_4 ( Object VAR_2 ) { return VAR_2 instanceof TYPE_1 ; } } , VAR_1 ) ; return VAR_1 ; } 
static private String METHOD_1 ( final Set < TYPE_1 > input ) { String result = STRING_1 ; for ( Iterator < TYPE_1 > iterator = input . iterator ( ) ; iterator . hasNext ( ) ; ) { final TYPE_1 VAR_1 = iterator . next ( ) ; <START> result += VAR_1 . getName ( ) ; <END> if ( iterator . hasNext ( ) ) { result += STRING_2 ; } } result += STRING_3 ; return result ; } 
<START> final public Double METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( METHOD_2 ( ) ) { return METHOD_3 ( VAR_1 ) ; } if ( METHOD_4 ( ) . METHOD_5 ( ) ) { return METHOD_6 ( ) ; } final Double VAR_2 = super . METHOD_7 ( ) ; return ( VAR_2 == null || VAR_2 == FLOAT_1 ) ? VAR_3 : VAR_2 ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return ( ( TYPE_2 ) METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) . METHOD_1 ( ) ; } 
private static void METHOD_1 ( ) { if ( VAR_1 ) { return ; } <START> METHOD_2 ( ) ; ; <END> VAR_1 = true ; String path = STRING_1 + VAR_2 + STRING_2 ; TYPE_1 . METHOD_3 ( path , new TYPE_2 ( ) { @Override void METHOD_4 ( int i , byte b ) { VAR_3 . get ( i ) . VAR_4 = b ; } } ) ; } 
public boolean METHOD_1 ( Path path ) { String name = path . getName ( ) ; if ( name . startsWith ( STRING_1 ) || name . startsWith ( STRING_2 ) ) { return false ; } return true ; <START> } <END> 
public void METHOD_1 ( ) throws IOException { <START> TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> VAR_2 . METHOD_4 ( ) ; } 
<START> private boolean METHOD_1 ( String id ) { <END> if ( ! VAR_1 . containsKey ( id ) ) { return true ; } TYPE_1 VAR_2 = VAR_1 . get ( id ) ; boolean VAR_3 = VAR_2 . VAR_4 < VAR_5 ; boolean VAR_6 = System . VAR_7 ( ) - VAR_2 . VAR_8 >= TimeUnit . VAR_9 . METHOD_2 ( VAR_10 ) ; return VAR_3 && VAR_6 ; } 
<START> public static Map < String , TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public List < HashMap < String , Object > > METHOD_1 ( ANNOTATION_1 String VAR_1 , ANNOTATION_1 long VAR_2 ) { <END> return TYPE_1 . METHOD_2 ( ) . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
protected boolean METHOD_1 ( final TYPE_1 request ) throws TYPE_2 { TYPE_3 VAR_1 = TYPE_3 . METHOD_2 ( ) ; TYPE_4 config = VAR_1 . METHOD_3 ( ) ; try { TYPE_4 VAR_2 = config . VAR_3 ( VAR_4 ) ; if ( VAR_2 != null ) { <START> boolean VAR_5 = VAR_2 . METHOD_4 ( VAR_6 , false ) ; <END> return ! VAR_5 ; } } catch ( Exception e ) { logger . debug ( STRING_1 , VAR_1 . METHOD_5 ( ) ) ; } return true ; } 
<START> private Set < TYPE_1 > METHOD_1 ( Set < TYPE_1 > VAR_1 ) { <END> Set < TYPE_1 > VAR_2 = new HashSet < TYPE_1 > ( ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_2 . addAll ( VAR_3 . METHOD_2 ( ) ) ; if ( VAR_3 . METHOD_2 ( ) != null ) { METHOD_1 ( VAR_2 ) ; } else { break ; } } return VAR_2 ; } 
public void METHOD_1 ( ) { <START> Context . VAR_1 ( TYPE_1 . class ) . METHOD_2 ( STRING_1 , new TYPE_2 ( ) ) ; <END> log . info ( STRING_2 ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = Context . VAR_2 ( TYPE_1 . class ) ; <END> if ( VAR_1 != null ) VAR_1 . METHOD_2 ( ) . remove ( STRING_1 ) ; log . info ( STRING_2 ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( type == null ) METHOD_2 ( ) ; else { <START> VAR_1 . METHOD_3 ( STRING_1 , type . VAR_2 ) ; <END> if ( VAR_3 != null ) VAR_1 . METHOD_3 ( STRING_2 , VAR_3 . get ( ) . getName ( ) ) ; VAR_1 . METHOD_4 ( STRING_3 , VAR_4 . METHOD_5 ( ) ) ; VAR_1 . METHOD_4 ( STRING_4 , VAR_4 . METHOD_6 ( ) ) ; } } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <END> { String VAR_2 = VAR_1 . getName ( ) ; for ( TYPE_1 VAR_3 : VAR_4 ) { for ( String name : VAR_3 . VAR_5 ) { if ( VAR_2 . equals ( name ) ) { return VAR_3 ; } } } return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( VAR_1 instanceof TYPE_2 ) { Object element = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; <START> if ( element != null && element instanceof TYPE_3 ) { <END> try { TYPE_3 VAR_3 = ( TYPE_3 ) element ; METHOD_3 ( VAR_3 ) ; } catch ( TYPE_4 e ) { TYPE_5 . METHOD_4 ( e ) ; } } } } 
public TYPE_2 ( TYPE_1 VAR_2 , boolean VAR_3 ) { super ( ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> VAR_4 = VAR_2 . METHOD_1 ( ) ; <END> VAR_5 = VAR_2 . METHOD_2 ( ) ; } 
public void METHOD_1 ( TYPE_1 command ) { super . METHOD_1 ( command ) ; TYPE_2 VAR_1 = ( ( TYPE_3 ) command ) . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; for ( TYPE_4 v : TYPE_4 . VAR_2 ) { if ( v . equals ( VAR_1 ) ) { version = v ; } } <START> <END> VAR_3 = new TYPE_5 ( METHOD_6 ( ) , METHOD_5 ( ) ) ; VAR_3 . METHOD_7 ( ) ; } 
public String METHOD_1 ( ) { if ( VAR_1 == null ) { List < String > list = TYPE_1 . getInstance ( ) . METHOD_2 ( VAR_2 . getPath ( ) ) ; VAR_1 = "" ; if ( list != null ) { for ( String VAR_3 : list ) { <START> VAR_1 += VAR_3 + STRING_1 ; <END> } } else { VAR_1 = METHOD_3 ( ) ; } } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 event ) { if ( event . getType ( ) == TYPE_1 . VAR_1 ) { TYPE_2 resource = event . VAR_2 ( ) ; TYPE_3 project = ( TYPE_3 ) resource . VAR_3 ( TYPE_3 . class ) ; if ( project != null ) { if ( VAR_4 . containsKey ( project ) ) { <START> System . out . println ( STRING_1 + project ) ; <END> } VAR_4 . remove ( project ) ; } } } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { synchronized ( this ) { <START> VAR_1 = METHOD_2 ( METHOD_3 ( ) ) ; <END> } } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> System . out . println ( STRING_1 ) ; <END> } 
public int METHOD_1 ( ) { final int VAR_1 = Double . VAR_2 ( METHOD_2 ( ) ) ; <START> final int VAR_3 = Double . VAR_2 ( METHOD_3 ( ) ) ; <END> return TYPE_1 . METHOD_4 ( VAR_1 , VAR_3 ) ; } 
protected T cache ( final T type ) { if ( t == null ) t = type ; return type == null ? t : type ; <START> } <END> 
final static public < TYPE_1 extends TYPE_2 > TYPE_3 < TYPE_4 , TYPE_1 > METHOD_1 ( final TYPE_1 VAR_1 , final long ... VAR_2 ) { <START> final TYPE_3 < TYPE_4 , TYPE_1 > VAR_3 = new TYPE_3 < > ( VAR_1 , VAR_2 , new TYPE_5 ( 1 , INT_1 ) ) ; <END> final TYPE_4 t = new TYPE_4 ( VAR_3 ) ; VAR_3 . METHOD_2 ( t ) ; return VAR_3 ; } 
final static public < TYPE_1 extends TYPE_2 > TYPE_3 < TYPE_4 , TYPE_1 > METHOD_1 ( final TYPE_1 VAR_1 , final long ... VAR_2 ) { <START> final TYPE_3 < TYPE_4 , TYPE_1 > VAR_3 = new TYPE_3 < > ( VAR_1 , VAR_2 , new TYPE_5 ( 1 , INT_1 ) ) ; <END> final TYPE_4 t = new TYPE_4 ( VAR_3 ) ; VAR_3 . METHOD_2 ( t ) ; return VAR_3 ; } 
final static public < TYPE_1 extends TYPE_2 > TYPE_3 < TYPE_4 , TYPE_1 > METHOD_1 ( final TYPE_1 VAR_1 , final int VAR_2 , final long ... VAR_3 ) { <START> final TYPE_3 < TYPE_4 , TYPE_1 > VAR_4 = new TYPE_3 < > ( VAR_1 , VAR_3 , new TYPE_5 ( 1 , INT_1 ) ) ; <END> final TYPE_4 t = new TYPE_4 ( VAR_4 , VAR_2 ) ; VAR_4 . METHOD_2 ( t ) ; return VAR_4 ; } 
public boolean METHOD_1 ( TYPE_1 t ) { if ( t . length == length ) { final Iterator < T > a = iterator ( ) ; <START> final Iterator < T > b = iterator ( ) ; <END> while ( a . hasNext ( ) ) if ( ! a . next ( ) . METHOD_1 ( b . next ( ) ) ) return false ; return true ; } else return false ; } 
<START> public static < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_1 , TYPE_2 > METHOD_1 ( <END> final TYPE_4 < TYPE_1 > VAR_1 , final TYPE_4 < TYPE_2 > VAR_2 ) { return new TYPE_3 < TYPE_1 , TYPE_2 > ( VAR_1 , VAR_2 ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> return TYPE_1 . of ( TYPE_8 . VAR_3 ) . add ( TYPE_7 . VAR_5 , STRING_1 ) . add ( TYPE_7 . VAR_6 , TYPE_5 . TYPE_6 . format ( TYPE_4 . METHOD_2 ( TYPE_9 . VAR_8 ) ) ) . METHOD_3 ( VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 req , TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_4 b = new TYPE_4 ( this ) ; TYPE_5 VAR_2 = this . VAR_3 ; try { this . VAR_3 = null ; req . VAR_4 ( this , VAR_1 ) ; b . commit ( ) ; } catch ( IOException e ) { <START> this . VAR_3 = VAR_2 ; <END> b . VAR_5 ( ) ; throw new TYPE_3 ( STRING_1 , e , null ) ; } return true ; } 
public void METHOD_1 ( ) { <START> TYPE_1 . assertThat ( <END> TYPE_2 . METHOD_2 ( STRING_1 ) , TYPE_2 . METHOD_2 ( STRING_2 ) , TYPE_2 . METHOD_2 ( STRING_3 ) , TYPE_2 . METHOD_2 ( STRING_4 ) , TYPE_2 . METHOD_2 ( STRING_5 ) , TYPE_2 . METHOD_2 ( STRING_6 ) ) . METHOD_3 ( new TYPE_3 ( ) ) . METHOD_4 ( ) . and ( ) . METHOD_5 ( TYPE_2 . METHOD_2 ( STRING_7 ) , TYPE_2 . METHOD_2 ( STRING_8 ) ) ; } 
Set < TYPE_1 > METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( VAR_1 ) . stream ( ) <END> . filter ( TYPE_3 . METHOD_3 ( TYPE_4 . VAR_3 ) ) . collect ( Collectors . VAR_4 ( ) ) ; } 
<START> private < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_1 , TYPE_2 > METHOD_1 ( TYPE_3 < TYPE_1 , TYPE_2 > VAR_1 , <END> Set < TYPE_1 > VAR_2 ) { TYPE_3 . Builder < TYPE_1 , TYPE_2 > builder = TYPE_3 . builder ( ) ; for ( Map . Entry < TYPE_1 , TYPE_2 > VAR_3 : VAR_1 . entrySet ( ) ) { if ( ! VAR_2 . contains ( VAR_3 . getKey ( ) ) ) { builder . put ( VAR_3 ) ; } } return builder . build ( ) ; } 
private < T > TYPE_1 < T > METHOD_1 ( TYPE_1 < T > VAR_1 , <START> TYPE_2 < T > VAR_2 ) { <END> TYPE_1 . Builder < T > builder = TYPE_1 . builder ( ) ; for ( T item : VAR_1 ) { if ( VAR_2 . apply ( item ) ) builder . add ( item ) ; } return builder . build ( ) ; } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; if ( VAR_2 == null ) { <START> VAR_2 = TYPE_2 . METHOD_2 ( TYPE_3 . class , getClass ( ) . METHOD_3 ( ) ) ; <END> } VAR_3 = new TYPE_4 ( VAR_1 ) ; } 
protected Object METHOD_1 ( ) { <START> if ( VAR_1 != null && VAR_2 == null ) { <END> VAR_2 = new TYPE_2 . TYPE_3 ( VAR_1 ) ; } return this ; } 
private String result ( ) { <START> return new String ( stream . toString ( ) ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> this . VAR_1 = Collections . VAR_2 ( ) ; } 
public TYPE_4 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_2 ) TYPE_2 VAR_3 , ANNOTATION_1 ( STRING_3 ) String VAR_4 , ANNOTATION_1 ( STRING_4 ) List < String > VAR_5 , ANNOTATION_1 ( STRING_5 ) String VAR_6 ) { super ( VAR_2 , VAR_3 ) ; this . VAR_4 = VAR_4 ; <START> TYPE_3 . METHOD_1 ( VAR_5 , STRING_4 ) ; <END> this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; METHOD_2 ( VAR_3 . METHOD_3 ( ) ) ; } 
public TYPE_1 < String , Object > METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> return new TYPE_2 ( METHOD_2 ( VAR_1 . METHOD_3 ( ) ) , VAR_1 . METHOD_4 ( ) , null ) ; } else { return new TYPE_3 ( VAR_2 , null ) ; } } 
public TYPE_4 ( ANNOTATION_1 ( STRING_1 ) String VAR_2 , ANNOTATION_1 ( STRING_2 ) String format ) { this . VAR_2 = ( VAR_2 == null ) ? VAR_3 : VAR_2 . METHOD_1 ( ) ; this . VAR_4 = format == null ? VAR_5 : format ; <START> try { <END> this . VAR_6 = TYPE_1 . METHOD_2 ( VAR_4 ) ; } catch ( TYPE_2 e ) { throw TYPE_3 . METHOD_3 ( e ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { try { Class type = TYPE_2 . METHOD_2 ( VAR_1 , TYPE_7 . VAR_4 ) ; TYPE_2 . METHOD_3 ( VAR_1 , TYPE_7 . VAR_4 , type , VAR_2 ) ; } catch ( TYPE_3 | TYPE_4 | TYPE_5 | TYPE_6 e ) { VAR_1 . METHOD_4 ( null ) ; LOG . error ( STRING_1 + e ) ; <START> e . VAR_5 ( ) ; <END> } } 
private String METHOD_1 ( String VAR_1 ) { String VAR_2 = null ; String VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; List < TYPE_1 > VAR_5 = VAR_4 . METHOD_3 ( VAR_1 ) ; for ( TYPE_1 VAR_6 : VAR_5 ) { <START> if ( VAR_3 . equals ( VAR_6 . METHOD_4 ( ) ) ) { <END> VAR_2 = VAR_3 ; } } return VAR_2 ; } 
private Object [ ] METHOD_1 ( Map < String , Date > VAR_1 ) { List < Object > VAR_2 = new ArrayList < > ( ) ; TYPE_1 VAR_3 = new TYPE_1 ( TYPE_6 . TYPE_5 , TYPE_2 . VAR_7 ) ; VAR_2 . add ( VAR_3 . format ( VAR_1 . get ( TYPE_4 . TYPE_3 . VAR_10 ) ) ) ; <START> VAR_2 . add ( VAR_3 . format ( VAR_1 . get ( TYPE_4 . TYPE_3 . VAR_11 ) ) ) ; <END> return VAR_2 . METHOD_2 ( ) ; } 
private List < String > METHOD_1 ( String ... VAR_1 ) { List < String > VAR_2 = new ArrayList < String > ( ) ; for ( String VAR_3 : VAR_1 ) { <START> VAR_2 . add ( VAR_3 ) ; <END> } return VAR_2 ; } 
protected boolean METHOD_1 ( String VAR_1 ) { <START> return StringUtils . equals ( VAR_1 , TYPE_1 . VAR_3 ) ? true : false ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { <START> LOG . debug ( STRING_1 ) ; <END> VAR_2 . METHOD_2 ( ) ; } 
private void METHOD_1 ( TYPE_1 properties , String key , TYPE_2 value ) { <START> properties . put ( key , TYPE_3 . METHOD_2 ( value ) ? TYPE_4 . VAR_2 : value . VAR_3 ( ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 properties , String key , Integer value ) { <START> properties . put ( key , TYPE_2 . METHOD_2 ( value ) ? TYPE_3 . VAR_2 : value . VAR_3 ( ) ) ; <END> } 
public static < T extends TYPE_1 > T METHOD_1 ( Class < T > VAR_1 ) { TYPE_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( TYPE_3 . class ) ) ; T VAR_2 = null ; try { VAR_2 = TYPE_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; } catch ( TYPE_4 | TYPE_5 e ) { <START> e . VAR_3 ( ) ; <END> throw new RuntimeException ( e ) ; } METHOD_6 ( VAR_2 ) ; return VAR_2 ; } 
private static TYPE_1 METHOD_1 ( ) { <START> TYPE_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( TYPE_3 . class ) ) ; <END> TYPE_1 VAR_1 = TYPE_2 . METHOD_4 ( new TYPE_1 ( ) ) ; return VAR_1 ; } 
public int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 , status , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 , VAR_16 , <START> VAR_16 ) ; <END> } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { if ( StringUtils . VAR_2 ( VAR_1 ) ) { <START> return new TYPE_1 ( TYPE_2 . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ) ; <END> } else { return null ; } } 
private TYPE_6 ( String VAR_2 , TYPE_1 [ ] VAR_3 , TYPE_2 [ ] VAR_4 ) { <START> VAR_5 = new TYPE_3 ( TYPE_4 . METHOD_1 ( VAR_2 ) . METHOD_2 ( ) ) ; <END> VAR_6 = TYPE_5 . METHOD_3 ( VAR_3 ) ; VAR_7 = TYPE_5 . METHOD_3 ( VAR_4 ) ; } 
public void METHOD_1 ( ) { <START> String VAR_1 = VAR_2 . METHOD_2 ( StringUtils . VAR_3 ) ; <END> assertEquals ( StringUtils . VAR_3 , VAR_1 ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = new ArrayList ( ) ; <END> for ( TYPE_1 VAR_2 : METHOD_2 ( ) ) { if ( VAR_2 . METHOD_3 ( ) ) { VAR_1 . add ( TYPE_1 . METHOD_4 ( VAR_2 ) ) ; } } return VAR_1 ; } 
protected boolean METHOD_1 ( ) { Boolean VAR_1 = VAR_2 . METHOD_2 ( TYPE_1 . VAR_4 , TYPE_1 . VAR_5 , <START> TYPE_2 . VAR_7 , Boolean . VAR_8 . METHOD_3 ( ) ) ; <END> if ( LOG . VAR_9 ( ) ) { LOG . debug ( STRING_1 + TYPE_2 . VAR_7 + STRING_2 + VAR_1 . METHOD_3 ( ) ) ; } return VAR_1 . METHOD_3 ( ) ; } 
private void METHOD_1 ( Boolean value ) { TYPE_1 . when ( VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 , <START> TYPE_2 . VAR_4 , TYPE_3 . VAR_6 , Boolean . VAR_7 . METHOD_3 ( ) ) ) . METHOD_4 ( value ) ; <END> VAR_8 . METHOD_5 ( VAR_1 ) ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( ) . stream ( ) <START> . forEach ( this : : METHOD_5 ) ; <END> return true ; } 
protected String METHOD_1 ( Collection < String > VAR_1 ) { List < String > VAR_2 = new ArrayList < > ( ) ; for ( String VAR_3 : VAR_1 ) { String description = VAR_4 . METHOD_2 ( VAR_3 ) ; if ( VAR_2 . METHOD_3 ( description ) == - 1 ) { VAR_2 . add ( description ) ; } } <START> return this . METHOD_4 ( VAR_2 ) ; <END> } 
public List < ? extends TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; VAR_1 . addAll ( VAR_2 ) ; VAR_1 . addAll ( VAR_3 ) ; <START> return VAR_2 ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_1 VAR_2 ) { if ( METHOD_2 ( VAR_1 ) && StringUtils . VAR_3 ( VAR_1 . METHOD_3 ( ) ) ) { <START> StringBuilder VAR_4 = new StringBuilder ( METHOD_4 ( ) . METHOD_5 ( TYPE_3 . VAR_6 ) ) ; <END> VAR_2 = METHOD_6 ( ) . METHOD_7 ( VAR_2 , VAR_4 . toString ( ) , TYPE_4 . TYPE_5 . VAR_9 . METHOD_8 ( ) ) ; } return VAR_2 ; } 
public void METHOD_1 ( Integer id , String VAR_1 , Integer VAR_2 , Integer VAR_3 , TYPE_1 VAR_4 ) { <START> METHOD_1 ( id , null , VAR_1 , TYPE_2 . VAR_6 , TYPE_2 . VAR_6 , TYPE_2 . VAR_6 , VAR_4 , VAR_2 , VAR_3 , null ) ; <END> } 
protected org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_1 METHOD_1 ( ) { org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_1 VAR_6 = new org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_1 ( ) ; <START> return VAR_6 ; <END> } 
<START> protected org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_2 METHOD_1 ( ) { <END> org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_2 VAR_6 = TYPE_1 . METHOD_2 ( new org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_2 ( ) ) ; TYPE_1 . METHOD_3 ( ) . when ( VAR_6 ) . METHOD_4 ( ) ; return VAR_6 ; } 
protected void METHOD_1 ( TYPE_1 row ) { row . VAR_1 ( ) . stream ( ) <START> . filter ( VAR_2 - > StringUtils . VAR_3 ( VAR_2 . METHOD_2 ( ) , VAR_4 ) ) <END> . METHOD_3 ( ) . METHOD_4 ( VAR_2 - > METHOD_5 ( row , VAR_2 ) ) ; } 
private boolean METHOD_1 ( ) { <START> return ( METHOD_2 ( ) . METHOD_3 ( TYPE_1 . VAR_2 ) . equalsIgnoreCase ( TYPE_2 . TYPE_3 . VAR_5 ) ? true : false ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { return ( StringUtils . VAR_2 ( VAR_1 . METHOD_2 ( ) ) && ( StringUtils . equalsIgnoreCase ( VAR_1 . METHOD_2 ( ) , TYPE_2 . TYPE_3 . VAR_5 . METHOD_3 ( ) ) <START> | StringUtils . equalsIgnoreCase ( VAR_1 . METHOD_2 ( ) , TYPE_2 . TYPE_3 . VAR_6 . METHOD_3 ( ) ) ) ) ; <END> } 
public boolean equals ( Object VAR_1 ) { if ( VAR_1 == null ) { return false ; } if ( ! ( VAR_1 instanceof TYPE_1 ) ) { return false ; } final TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 ; return TYPE_2 . equals ( VAR_2 . METHOD_1 ( ) , VAR_3 ) && <START> TYPE_2 . equals ( VAR_2 . METHOD_2 ( ) , VAR_4 ) && <END> TYPE_2 . equals ( VAR_2 . METHOD_3 ( ) , VAR_5 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) { <END> return false ; } else { return true ; } } 
public TYPE_2 ( ) { super ( ) ; this . VAR_2 = true ; <START> this . VAR_3 = TYPE_1 . METHOD_1 ( ) . toString ( ) ; <END> } 
private void METHOD_1 ( List VAR_1 , StringBuilder sb ) { List < TYPE_1 > VAR_2 = VAR_1 ; <START> VAR_2 . stream ( ) . map ( line - > line . toString ( ) ) . forEach ( sb : : append ) ; <END> } 
protected void METHOD_1 ( ) { LOG . info ( STRING_1 ) ; <START> VAR_1 . METHOD_2 ( TYPE_1 . class , new HashMap ( ) ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ) { <END> return true ; } else { return false ; } } 
private void METHOD_1 ( TYPE_1 line ) { TYPE_2 VAR_1 = METHOD_2 ( <START> line , line . VAR_2 ( ) , line . VAR_3 ( ) ) ; <END> METHOD_3 ( VAR_1 , false ) ; } 
public boolean METHOD_1 ( TYPE_1 line , TYPE_2 VAR_1 , String VAR_2 , String VAR_3 ) { boolean VAR_4 = METHOD_2 ( line , VAR_1 ) ; <START> VAR_4 = METHOD_3 ( line , VAR_1 , VAR_3 , null ) && VAR_4 ; <END> return VAR_4 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 line ) { String VAR_1 = line . VAR_2 ( ) ; String VAR_3 ; if ( METHOD_2 ( ) . METHOD_3 ( line ) ) { VAR_3 = line . VAR_4 ( ) ; } else { <START> VAR_3 = line . VAR_5 ( ) ; <END> } TYPE_1 VAR_6 = METHOD_1 ( line , VAR_1 , VAR_3 ) ; return VAR_6 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) && VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ) { <END> return true ; } else { return false ; } } 
private boolean METHOD_1 ( String message ) { <START> for ( String VAR_1 : METHOD_2 ( ) ) { <END> if ( StringUtils . equals ( VAR_1 , message ) ) { return false ; } } return true ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; <START> VAR_1 . METHOD_3 ( new ArrayList ( ) ) ; <END> assertEquals ( STRING_1 , 1 , VAR_1 . METHOD_4 ( ) . size ( ) ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 builder = new TYPE_2 ( <START> TYPE_3 : : METHOD_2 , TYPE_4 : : toString , <END> TYPE_5 : : METHOD_3 , this : : METHOD_4 ) ; TYPE_6 VAR_2 = builder . VAR_3 ( 0 , VAR_1 ) ; if ( VAR_2 == null ) { LOG . error ( STRING_1 ) ; return false ; } return true ; } 
private Object METHOD_1 ( String VAR_1 ) { byte [ ] VAR_2 = METHOD_2 ( VAR_1 ) ; <START> Object VAR_3 ; <END> VAR_3 = METHOD_3 ( ) . parse ( METHOD_4 ( ) , VAR_2 ) ; return VAR_3 ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 . METHOD_3 ( ) == VAR_1 . METHOD_4 ( ) . METHOD_3 ( ) ) { <END> return true ; } else { LOG . error ( STRING_1 + VAR_1 . METHOD_4 ( ) . toString ( ) + STRING_2 + VAR_2 . toString ( ) + STRING_3 ) ; return false ; } } 
public void METHOD_1 ( ) { List < String > VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . isEmpty ( ) ) { <START> LOG . error ( STRING_1 ) ; <END> } else { for ( String VAR_2 : VAR_1 ) { METHOD_3 ( VAR_2 ) ; LOG . info ( STRING_2 + VAR_2 + STRING_3 ) ; } } } 
public static boolean METHOD_1 ( String TYPE_1 ) { <START> if ( StringUtils . VAR_1 ( TYPE_1 ) && TYPE_1 . contains ( TYPE_2 . VAR_3 ) ) { <END> return true ; } return false ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_1 VAR_2 = METHOD_2 ( <END> VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_6 ( ) , VAR_1 . METHOD_7 ( ) , VAR_1 . METHOD_8 ( ) ) ; return VAR_2 ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return new TYPE_2 ( ) ; } 
protected void METHOD_1 ( final Map < String , Object > parameters , final Set < TYPE_1 > VAR_1 , final TYPE_2 VAR_2 ) { <START> parameters . put ( VAR_3 , VAR_1 ) ; <END> } 
protected void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { final File VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> ANNOTATION_1 final TYPE_4 VAR_3 = VAR_1 . METHOD_3 ( ) ; <END> if ( VAR_2 != null ) { log . info ( STRING_1 , VAR_3 ) ; try { this . VAR_4 . METHOD_4 ( VAR_2 . METHOD_5 ( ) , VAR_3 ) ; } catch ( final IOException e ) { throw new TYPE_2 ( STRING_2 , e ) ; } } } 
public void METHOD_1 ( ) { this . VAR_1 . METHOD_2 ( STRING_1 ) . run ( ( context ) - > { <START> System . out . println ( context ) ; <END> TYPE_1 . assertThat ( context ) . METHOD_3 ( TYPE_2 . VAR_3 ) ; } ) ; } 
TYPE_6 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final TYPE_3 VAR_4 , <START> final TYPE_4 VAR_5 <END> ) { this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_5 ; this . VAR_4 = VAR_4 ; final long VAR_6 = VAR_3 . getProperty ( TYPE_5 . VAR_8 , Long . VAR_9 , INT_1 ) ; VAR_2 . METHOD_1 ( this : : METHOD_2 , VAR_6 ) ; } 
<START> TYPE_1 get ( ) { <END> return VAR_1 . get ( ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { final TYPE_2 VAR_2 = VAR_1 . getStatus ( ) ; final TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; final String VAR_4 = VAR_1 . METHOD_3 ( ) ; if ( VAR_2 != VAR_3 ) { log . info ( STRING_1 , VAR_4 , VAR_3 , VAR_2 ) ; <START> if ( this . VAR_5 != null ) { <END> this . VAR_5 . METHOD_4 ( VAR_4 , VAR_3 , VAR_2 ) ; } VAR_1 . METHOD_5 ( VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 ( STRING_1 ) final int VAR_1 , final Set < TYPE_2 > VAR_2 , final List < TYPE_3 > VAR_3 ) { final TYPE_4 builder = TYPE_4 . METHOD_2 ( VAR_1 == VAR_4 <START> ? TYPE_5 . METHOD_3 ( ) <END> : VAR_1 ) ; VAR_2 . stream ( ) . map ( TYPE_2 : : METHOD_4 ) . map ( VAR_5 - > TYPE_6 . METHOD_5 ( VAR_5 , VAR_3 ) ) . forEach ( builder : : METHOD_6 ) ; return builder . build ( ) ; } 
public static String [ ] METHOD_1 ( final String [ ] args ) { final List < String > VAR_1 = Arrays . asList ( args ) ; <START> final int index = VAR_1 . METHOD_2 ( TYPE_1 ) ; <END> if ( index == - 1 ) { return args ; } else if ( index == 0 ) { return new String [ 0 ] ; } else { return VAR_1 . METHOD_3 ( 0 , index ) . METHOD_4 ( new String [ index ] ) ; } } 
public void METHOD_1 ( ) { Assert . VAR_1 ( this . VAR_2 . METHOD_2 ( ) . isPresent ( ) ) ; final String VAR_3 = TYPE_1 . METHOD_3 ( ) . toString ( ) ; this . VAR_2 . METHOD_4 ( VAR_3 ) ; Assert . assertThat ( <START> this . VAR_2 . METHOD_2 ( ) . METHOD_5 ( TYPE_1 . METHOD_3 ( ) . toString ( ) ) , <END> TYPE_2 . is ( VAR_3 ) ) ; } 
private < TYPE_1 > TYPE_1 METHOD_1 ( final TYPE_2 < TYPE_1 > VAR_1 ) { final TYPE_1 response ; try { response = VAR_1 . get ( ) ; } catch ( final TYPE_3 | InterruptedException e ) { <START> throw new TYPE_4 ( STRING_1 ) ; <END> } return response ; } 
private void METHOD_1 ( final File VAR_1 ) { if ( ! VAR_1 . exists ( ) ) { try { TYPE_1 . METHOD_2 ( new File ( VAR_1 , VAR_2 ) ) ; } catch ( final IOException e ) { <START> throw new RuntimeException ( STRING_1 + VAR_1 . METHOD_3 ( ) , e ) ; <END> } } else if ( ! VAR_1 . METHOD_4 ( ) ) { throw new RuntimeException ( STRING_2 + VAR_1 . METHOD_3 ( ) ) ; } } 
public TYPE_3 . TYPE_4 METHOD_1 ( final String VAR_1 , final int VAR_2 ) { <START> final TYPE_2 channel = VAR_3 . METHOD_2 ( VAR_1 , VAR_2 ) ; <END> return TYPE_3 . METHOD_3 ( channel ) ; } 
public void METHOD_1 ( ) throws IOException { final TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; this . VAR_2 = new TYPE_3 ( VAR_1 ) ; <START> this . VAR_3 = TYPE_4 . METHOD_3 ( TYPE_5 . class . METHOD_4 ( ) + STRING_1 ) ; <END> } 
public void METHOD_1 ( ) throws IOException { final TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; this . VAR_2 = new TYPE_3 ( VAR_1 ) ; <START> this . VAR_3 = TYPE_4 . METHOD_3 ( this . getClass ( ) . METHOD_4 ( ) + STRING_1 ) ; <END> } 
public TYPE_5 ( final boolean VAR_2 , final boolean VAR_3 , ANNOTATION_1 final TYPE_1 VAR_4 , ANNOTATION_1 final String VAR_5 , ANNOTATION_1 final TYPE_2 VAR_6 ) { this . VAR_7 = VAR_2 ; this . VAR_8 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_9 = VAR_6 . METHOD_1 ( STRING_1 ) ; VAR_10 = new TYPE_3 ( ) ; <START> VAR_10 . METHOD_2 ( new TYPE_4 ( ) ) ; <END> } 
private void METHOD_1 ( final String host ) { final boolean VAR_1 = METHOD_2 ( host ) ; <START> if ( VAR_1 ) { <END> if ( VAR_2 . containsKey ( host ) ) { VAR_2 . remove ( host ) ; } } else { if ( this . VAR_2 . containsKey ( host ) ) { this . VAR_2 . put ( host , this . VAR_2 . get ( host ) + 1 ) ; } else { this . VAR_2 . put ( host , 1 ) ; } } } 
public void METHOD_1 ( ANNOTATION_1 final Map < String , Object > context ) throws TYPE_1 { log . debug ( STRING_1 ) ; super . METHOD_1 ( context ) ; <START> Utils . VAR_1 ( writer , TYPE_3 . TYPE_4 . toString ( ) ) ; <END> } 
<START> public List < TYPE_1 > METHOD_1 ( ) throws TYPE_2 , TYPE_3 { <END> return METHOD_2 ( ) . METHOD_1 ( ) ; } 
<START> public TYPE_1 METHOD_1 ( String name ) throws TYPE_2 , TYPE_3 { <END> return METHOD_2 ( ) . METHOD_1 ( name ) ; } 
<START> public TYPE_1 METHOD_1 ( String id , TYPE_2 options ) throws TYPE_3 , TYPE_4 , <END> TYPE_5 { return VAR_1 . METHOD_1 ( id , options ) ; } 
<START> public TYPE_1 METHOD_1 ( String name , TYPE_2 options ) throws TYPE_3 , TYPE_4 , <END> TYPE_5 { return VAR_1 . METHOD_1 ( name , options ) ; } 
<START> public TYPE_1 METHOD_1 ( String name ) throws TYPE_2 , TYPE_3 , TYPE_4 { <END> try { VAR_1 . METHOD_2 ( ) ; TYPE_5 options = new TYPE_5 ( ) ; options . VAR_2 ( TYPE_6 . VAR_4 ) ; return METHOD_3 ( name , options ) ; } catch ( Exception e ) { LOG . warn ( STRING_1 , name , e ) ; if ( e instanceof TYPE_4 ) { throw ( TYPE_4 ) e ; } throw new RuntimeException ( e ) ; } } 
public TYPE_1 METHOD_1 ( String name , TYPE_2 options ) throws <START> TYPE_3 , TYPE_4 , TYPE_5 { <END> try { VAR_1 . METHOD_2 ( ) ; return METHOD_3 ( name , options ) ; } catch ( Exception e ) { LOG . warn ( STRING_1 , name , e ) ; if ( e instanceof TYPE_5 ) { throw ( TYPE_5 ) e ; } throw new RuntimeException ( e ) ; } } 
<START> public List < TYPE_1 > METHOD_1 ( ) throws TYPE_2 , TYPE_3 { <END> try { VAR_1 . METHOD_2 ( ) ; METHOD_3 ( null , null , STRING_1 ) ; return METHOD_4 ( ) ; } catch ( Exception e ) { LOG . warn ( STRING_2 , e ) ; if ( e instanceof TYPE_3 ) { throw ( TYPE_3 ) e ; } throw new RuntimeException ( e ) ; } } 
private static void METHOD_1 ( int VAR_1 ) { <START> TYPE_1 VAR_2 = new TYPE_1 ( STRING_1 , null , INT_1 , 0 , VAR_1 , new TYPE_2 ( 100 ) , STRING_2 , STRING_2 , <END> Collections . VAR_3 ( INT_2 ) , INT_2 , new TYPE_3 ( ) ) ; final TYPE_4 VAR_4 = new TYPE_4 ( VAR_2 ) ; final TYPE_5 VAR_5 = new TYPE_5 ( VAR_2 ) ; METHOD_2 ( VAR_4 , VAR_5 ) ; } 
private static TYPE_1 METHOD_1 ( String name , int VAR_1 ) { <START> return new TYPE_1 ( name , null , VAR_1 , 0 , 1 , new TYPE_2 ( 0 ) , STRING_1 , STRING_1 , Collections . VAR_2 ( INT_1 ) , INT_1 , new TYPE_3 ( ) ) ; <END> } 
private TYPE_1 METHOD_1 ( String name , int VAR_1 , int VAR_2 ) { <START> return new TYPE_1 ( name , null , VAR_2 , 0 , VAR_1 , VAR_3 , STRING_1 , STRING_1 , Collections . VAR_4 ( INT_1 ) , INT_1 , new TYPE_2 ( ) ) ; <END> } 
public void METHOD_1 ( String node , boolean VAR_1 ) { if ( ! VAR_2 ) { return ; } if ( ! VAR_1 ) { int VAR_3 = VAR_4 . METHOD_2 ( node , 0 ) + 1 ; <START> VAR_4 . put ( node , VAR_3 ) ; <END> } } 
private void METHOD_1 ( ) { if ( ! VAR_1 ) { return ; } <START> Map < String , Integer > VAR_2 = new HashMap < > ( ) ; <END> VAR_2 . METHOD_2 ( this . VAR_3 ) ; synchronized ( VAR_3 ) { this . VAR_3 . clear ( ) ; } this . VAR_4 . add ( VAR_2 ) ; } 
public TYPE_1 ( boolean VAR_2 ) { this . VAR_2 = VAR_2 ; <START> LOG . info ( STRING_1 , "" + VAR_2 ) ; <END> } 
private Set < String > METHOD_1 ( Map < String , Set < String > > map ) { <START> return map . values ( ) <END> . stream ( ) . METHOD_2 ( set - > set . stream ( ) ) . collect ( Collectors . VAR_1 ( HashSet : : new ) ) ; } 
public boolean METHOD_1 ( String key , TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { VAR_1 = METHOD_2 ( VAR_1 ) ; METHOD_3 ( key ) ; TYPE_4 VAR_2 = METHOD_4 ( key ) ; VAR_3 . METHOD_5 ( VAR_2 . METHOD_6 ( ) , VAR_4 , VAR_1 , key ) ; try { TYPE_5 VAR_5 = VAR_6 . read ( VAR_7 + key ) ; <START> return VAR_5 . exists ( ) ; <END> } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
public static Map < String , Map < String , Object > > METHOD_1 ( TYPE_1 VAR_1 , Map < String , Object > config ) { <START> Boolean VAR_2 = TYPE_2 . METHOD_2 ( config . get ( TYPE_4 . VAR_4 ) , false ) ; <END> return VAR_2 ? Collections . VAR_5 : TYPE_3 . METHOD_3 ( VAR_1 , config ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> long VAR_2 ; <END> Map < TYPE_1 , TYPE_2 > VAR_3 = VAR_4 . METHOD_2 ( Collections . VAR_5 ( VAR_1 , VAR_6 ) ) ; TYPE_2 VAR_7 = VAR_3 . get ( VAR_1 ) ; VAR_2 = VAR_7 . offset ( ) ; LOG . debug ( STRING_1 , VAR_1 , VAR_6 ) ; VAR_4 . METHOD_3 ( VAR_1 , VAR_2 ) ; } 
<START> public boolean remove ( TYPE_1 VAR_1 ) { <END> boolean VAR_2 = VAR_3 . remove ( VAR_1 . METHOD_1 ( ) , null ) ; VAR_4 -= VAR_1 . METHOD_2 ( ) ; if ( VAR_4 < FLOAT_1 ) { VAR_2 = true ; VAR_4 = FLOAT_1 ; } return VAR_2 ; } 
private void METHOD_1 ( ) throws Exception { try { <START> METHOD_1 ( null ) ; <END> } catch ( Exception e ) { this . VAR_1 . METHOD_2 ( ) ; throw e ; } } 
public void METHOD_1 ( String VAR_1 ) { for ( TYPE_1 type : TYPE_1 . values ( ) ) { String path = TYPE_2 . METHOD_2 ( type , VAR_1 ) ; try { <START> LOG . debug ( STRING_1 , path ) ; <END> VAR_2 . METHOD_3 ( path ) ; } catch ( RuntimeException e ) { if ( ! Utils . VAR_3 ( TYPE_4 . TYPE_5 . class , e ) ) { throw e ; } } } } 
<START> List < TYPE_4 . TYPE_3 > METHOD_1 ( long size ) { <END> return VAR_1 . METHOD_2 ( ) . stream ( ) . map ( TYPE_2 . METHOD_3 ( VAR_2 - > VAR_3 . METHOD_4 ( Collections . VAR_4 ( VAR_2 ) , size , true , null ) ) ) . collect ( METHOD_5 ( ) ) ; } 
public boolean METHOD_1 ( Integer VAR_1 ) { <START> return VAR_2 . get ( VAR_1 ) . VAR_3 . METHOD_2 ( true ) ; <END> } 
public TYPE_1 ( Object ... VAR_2 ) { super ( VAR_2 != null ? VAR_2 . length : 0 ) ; <START> if ( VAR_2 != null && VAR_2 . length != 0 ) { <END> for ( Object o : VAR_2 ) { add ( o ) ; } } else { add ( null ) ; } } 
public TYPE_1 ( Object ... VAR_2 ) { <START> super ( VAR_2 != null ? VAR_2 . length : 0 ) ; <END> if ( VAR_2 != null ) { for ( Object o : VAR_2 ) { add ( o ) ; } } else { add ( null ) ; } } 
public void close ( ) throws Exception { <START> super . close ( ) ; <END> METHOD_1 ( ) . close ( ) ; } 
private TYPE_1 METHOD_1 ( Map < String , Object > VAR_1 ) { <START> TYPE_2 < String > VAR_2 = new TYPE_2 < > ( 0 , INT_1 ) ; <END> VAR_2 . set ( INT_2 , STRING_1 ) ; return new TYPE_1 ( null , VAR_1 , VAR_2 , null , null , null , null , null , null , INT_2 , INT_3 , null , null , null , null , null , null ) ; } 
public static TYPE_1 METHOD_1 ( Map conf ) throws TYPE_2 { try { String VAR_1 = ( String ) conf . get ( TYPE_3 . VAR_3 ) ; TYPE_1 VAR_4 = ( TYPE_1 ) ( Class . VAR_5 ( VAR_1 ) ) . METHOD_2 ( ) ; VAR_4 . METHOD_3 ( conf ) ; return VAR_4 ; <START> } catch ( Throwable t ) { <END> throw new TYPE_2 ( STRING_1 , t ) ; } } 
public void run ( ) { while ( true ) { <START> if ( VAR_1 ) { <END> return ; } try { Thread . VAR_2 ( VAR_3 ) ; } catch ( InterruptedException e ) { LOG . error ( STRING_1 , e ) ; continue ; } try { METHOD_1 ( ) ; } catch ( TYPE_1 e ) { LOG . error ( STRING_2 , e ) ; if ( this . VAR_4 != null ) { this . VAR_4 . METHOD_2 ( ) ; } } } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { ++ VAR_3 ; VAR_2 . METHOD_2 ( ) ; <START> LOG . warn ( STRING_1 , VAR_2 . getName ( ) , VAR_2 . METHOD_3 ( ) , VAR_3 , VAR_1 . toString ( ) ) ; <END> } 
private void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; try { <START> if ( ! VAR_1 . METHOD_3 ( 1 , TimeUnit . VAR_2 ) ) { <END> VAR_1 . METHOD_4 ( ) ; if ( ! VAR_1 . METHOD_3 ( 1 , TimeUnit . VAR_2 ) ) { LOG . error ( STRING_1 ) ; } } } catch ( InterruptedException VAR_3 ) { VAR_1 . METHOD_4 ( ) ; Thread . VAR_4 ( ) . METHOD_5 ( ) ; } } } 
public void METHOD_1 ( long offset ) { this . VAR_1 . add ( offset ) ; <START> this . VAR_2 = offset ; <END> } 
public void METHOD_1 ( ) { try { METHOD_2 ( ) ; <START> VAR_1 = new TYPE_1 < > ( VAR_2 . METHOD_3 ( ) ) ; <END> } catch ( TYPE_2 e ) { METHOD_4 ( ) ; } } 
public void METHOD_1 ( ) { try { METHOD_2 ( ) ; <START> VAR_1 . close ( ) ; <END> } catch ( TYPE_1 e ) { METHOD_3 ( ) ; } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { try { LOG . debug ( STRING_1 , VAR_1 ) ; TYPE_2 request = VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_3 . request ( request , VAR_2 . METHOD_3 ( ) ) ; METHOD_4 ( VAR_1 ) ; LOG . debug ( STRING_2 , VAR_1 ) ; } catch ( Exception e ) { METHOD_5 ( VAR_1 , e ) ; <START> LOG . debug ( STRING_3 , VAR_1 , e ) ; <END> } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { try { <START> LOG . debug ( STRING_1 , VAR_1 ) ; <END> TYPE_2 request = VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_3 . request ( request , VAR_2 . METHOD_3 ( ) ) ; METHOD_4 ( VAR_1 ) ; LOG . debug ( STRING_2 , VAR_1 ) ; } catch ( Exception e ) { METHOD_5 ( VAR_1 , e ) ; } } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { try { VAR_1 . close ( ) ; } catch ( IOException e ) { <START> LOG . debug ( STRING_1 , e ) ; <END> } } } 
public static TYPE_1 METHOD_1 ( String resource , boolean VAR_1 , boolean VAR_2 , String VAR_3 , boolean VAR_4 ) throws IOException { TYPE_2 in = TYPE_3 . class . METHOD_2 ( resource ) ; TYPE_2 VAR_5 = null ; if ( VAR_3 != null ) { VAR_5 = TYPE_3 . class . METHOD_2 ( VAR_3 ) ; } <START> TYPE_1 VAR_6 = METHOD_3 ( in , VAR_1 , VAR_2 , VAR_5 , VAR_3 , VAR_4 ) ; <END> in . close ( ) ; return VAR_6 ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; if ( VAR_3 ) { VAR_1 . close ( ) ; <START> this . VAR_4 . METHOD_3 ( ) ; <END> } } 
private static String METHOD_1 ( Map < String , Double > VAR_1 , Map VAR_2 , String VAR_3 ) { StringBuilder VAR_4 = new StringBuilder ( ) ; if ( VAR_1 . containsKey ( VAR_3 ) ) { Double VAR_5 = ( Double ) VAR_2 . METHOD_2 ( VAR_3 , null ) ; <START> VAR_1 . put ( VAR_3 , VAR_5 ) ; <END> VAR_4 . append ( VAR_3 . substring ( VAR_3 . METHOD_3 ( STRING_1 ) ) + STRING_2 + VAR_5 ) ; } return VAR_4 . toString ( ) ; } 
public void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_2 ( ) ; } } 
public void METHOD_1 ( ) { LOG . debug ( STRING_1 ) ; <START> if ( this . VAR_1 != null ) { <END> VAR_1 . METHOD_1 ( ) ; try { if ( ! VAR_1 . METHOD_2 ( 2 , TimeUnit . VAR_2 ) ) { VAR_1 . METHOD_3 ( ) ; } } catch ( InterruptedException VAR_3 ) { VAR_1 . METHOD_3 ( ) ; Thread . VAR_4 ( ) . METHOD_4 ( ) ; } } } 
public TYPE_3 ( Set < TYPE_1 > VAR_2 , int VAR_3 , int VAR_4 ) { <START> TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 request ) { VAR_1 . VAR_2 . add ( request ) ; <START> return null ; <END> } 
public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 ) { <START> if ( VAR_3 == null ) throw new TYPE_2 ( STRING_1 ) ; <END> if ( VAR_2 == null ) throw new TYPE_2 ( STRING_2 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 . METHOD_1 ( ) ; } 
public void start ( ) { <START> long VAR_1 = VAR_2 - Math . VAR_3 ( ( long ) ( VAR_2 * FLOAT_1 ) , 100 ) ; <END> VAR_4 = VAR_5 . METHOD_1 ( METHOD_2 ( ) , VAR_1 , VAR_2 , TimeUnit . VAR_6 ) ; } 
public void METHOD_1 ( ) { <START> Map < String , Object > VAR_1 = new HashMap < > ( ) ; <END> Map < String , Object > map = new HashMap < > ( ) ; map . put ( TYPE_2 . VAR_3 , Arrays . asList ( new String [ ] { STRING_1 } ) ) ; Assert . assertTrue ( TYPE_1 . METHOD_2 ( VAR_1 ) . isEmpty ( ) ) ; Assert . assertEquals ( TYPE_1 . METHOD_2 ( map ) . size ( ) , 1 ) ; } 
public static byte [ ] METHOD_1 ( Object obj ) throws IOException { try ( TYPE_1 b = new TYPE_1 ( ) ) { try ( TYPE_2 o = new TYPE_2 ( b ) ) { o . VAR_1 ( obj ) ; <START> o . close ( ) ; <END> } return b . VAR_2 ( ) ; } } 
public List < Object > METHOD_1 ( TYPE_1 VAR_1 ) { final List < Object > VAR_2 = new ArrayList < Object > ( ) ; String VAR_3 = "" ; <START> VAR_3 = new String ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) , TYPE_2 . METHOD_5 ( ) ) ; <END> Map VAR_4 = VAR_1 . METHOD_6 ( ) ; VAR_2 . add ( VAR_3 ) ; VAR_2 . add ( VAR_4 ) ; return VAR_2 ; } 
public void METHOD_1 ( Object VAR_1 ) { TYPE_1 id = ( TYPE_1 ) VAR_1 ; TYPE_2 m = VAR_2 . METHOD_2 ( id . VAR_3 ) ; if ( m != null ) { m . VAR_4 ( id . offset ) ; <START> } { <END> TYPE_2 VAR_5 = METHOD_3 ( id . VAR_3 . VAR_3 ) ; if ( VAR_5 != null ) { VAR_5 . METHOD_1 ( id . offset ) ; } } } 
public TYPE_1 < TYPE_2 , TYPE_3 > build ( ) { TYPE_4 VAR_1 = ( TYPE_4 ) VAR_2 . get ( TYPE_5 . VAR_4 ) ; if ( VAR_1 == null ) { <START> METHOD_1 ( VAR_5 ) ; <END> } else { METHOD_1 ( Math . VAR_6 ( VAR_1 . METHOD_2 ( ) , VAR_5 ) ) ; } return new TYPE_1 < > ( this ) ; } 
public static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { <START> return new TYPE_1 ( ) { <END> @Override public void METHOD_2 ( Set < TYPE_3 > VAR_2 , Set < TYPE_3 > VAR_3 ) { VAR_1 . METHOD_3 ( VAR_2 ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; } } ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> } 
public static Builder < String , String > builder ( String VAR_1 , Collection < String > VAR_2 ) { <START> return new Builder < > ( VAR_1 , new TYPE_1 ( ) , new TYPE_1 ( ) , VAR_2 ) ; <END> } 
private void METHOD_1 ( ) { VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; VAR_3 . METHOD_3 ( ) . METHOD_4 ( VAR_1 , new TYPE_1 ( ) , context ) ; <START> VAR_1 . METHOD_5 ( 0 ) ; <END> } 
public void METHOD_1 ( Map VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_3 = VAR_3 ; this . VAR_1 = VAR_1 ; <START> Map < String , Object > VAR_4 = VAR_5 != null ? VAR_1 : VAR_1 ; <END> this . VAR_6 = new TYPE_3 ( VAR_4 ) ; this . client = VAR_7 . METHOD_2 ( VAR_4 ) ; try { session = client . VAR_8 ( ) ; } catch ( TYPE_4 e ) { VAR_3 . METHOD_3 ( e ) ; } } 
private static Set < String > METHOD_1 ( Map < String , Object > VAR_1 ) { <START> TYPE_1 client = new TYPE_1 ( ) ; <END> client . VAR_2 ( VAR_1 ) ; return TYPE_2 . METHOD_2 ( client . VAR_3 ( ) ) ; } 
private void METHOD_1 ( ) { <START> while ( ! METHOD_2 ( VAR_1 . next ( ) ) && VAR_1 . hasNext ( ) ) <END> VAR_1 . remove ( ) ; } 
void METHOD_1 ( String VAR_1 , int VAR_2 ) { VAR_3 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; TYPE_1 . METHOD_4 ( 0 , VAR_2 ) . forEach ( value - > { TYPE_2 < String , String > VAR_4 = new TYPE_2 < > ( <START> VAR_1 , ( ( Integer ) value ) . toString ( ) , <END> ( ( Integer ) value ) . toString ( ) ) ; VAR_3 . METHOD_2 ( ) . METHOD_5 ( VAR_4 ) ; } ) ; } 
<START> static public TYPE_1 METHOD_1 ( ) { <END> TYPE_1 config = new TYPE_1 ( ) ; config . VAR_1 ( true ) ; return config ; } 
private boolean METHOD_1 ( ) { final int VAR_1 = VAR_2 . METHOD_2 ( ) ; final boolean VAR_3 = ! METHOD_3 ( ) && VAR_4 < VAR_1 ; if ( ! VAR_3 ) { <START> final boolean VAR_5 = VAR_6 . METHOD_4 ( ) ; <END> if ( VAR_5 ) { if ( METHOD_3 ( ) ) { LOG . debug ( STRING_1 , VAR_4 ) ; } if ( VAR_4 >= VAR_1 ) { LOG . debug ( STRING_2 , VAR_4 , VAR_1 ) ; } } } return VAR_3 ; } 
public TYPE_1 METHOD_1 ( ) throws IOException { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( VAR_2 , VAR_3 ) ; TYPE_1 VAR_4 = VAR_1 . METHOD_3 ( ) ; <START> LOG . warn ( STRING_1 , VAR_3 , VAR_4 ) ; <END> return VAR_4 ; } 
public boolean METHOD_1 ( ) throws IOException { Set < Long > VAR_1 = METHOD_2 ( ) ; String user = METHOD_3 ( ) ; boolean VAR_2 = true ; for ( Long VAR_3 : VAR_1 ) { if ( ! METHOD_4 ( VAR_3 , user ) ) { <START> LOG . warn ( STRING_1 , VAR_4 , VAR_3 ) ; <END> } else { VAR_2 = false ; break ; } } return VAR_2 ; } 
public static String METHOD_1 ( Map < String , Object > conf , String id , long VAR_1 ) { <START> return ( METHOD_2 ( conf , id ) + VAR_2 + VAR_1 ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , Integer VAR_5 ) { if ( VAR_5 == null || VAR_5 <= 0 ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( VAR_4 == null ) { throw new IllegalArgumentException ( STRING_2 ) ; } VAR_6 = METHOD_1 ( VAR_2 ) ; VAR_7 = METHOD_1 ( VAR_3 ) ; this . VAR_5 = VAR_5 ; this . VAR_4 = VAR_4 ; <START> this . VAR_2 = null ; <END> this . VAR_3 = null ; } 
public void METHOD_1 ( ) { TYPE_1 format = new TYPE_1 ( ) ; format . VAR_1 ( null , METHOD_2 ( ) ) ; String path = format . getPath ( ) ; String name = format . getName ( 1 , System . currentTimeMillis ( ) ) ; Assert . assertEquals ( STRING_1 , path ) ; String VAR_2 = new TYPE_2 ( STRING_2 ) . format ( System . currentTimeMillis ( ) ) ; <START> Assert . assertEquals ( VAR_2 + STRING_3 , name ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( ! VAR_2 . containsKey ( TYPE_2 . VAR_4 ) ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } VAR_2 . put ( TYPE_2 . VAR_5 , VAR_1 ) ; return this ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_1 ( VAR_1 ) ; <START> super . METHOD_2 ( VAR_1 ) ; <END> } 
private boolean METHOD_1 ( String VAR_1 ) { <START> if ( VAR_2 ) { <END> return true ; } if ( ! VAR_3 . isEmpty ( ) ) { return METHOD_2 ( VAR_1 , VAR_3 , true ) ; } else if ( ! VAR_4 . isEmpty ( ) ) { return METHOD_2 ( VAR_1 , VAR_4 , false ) ; } throw new IllegalStateException ( STRING_1 ) ; } 
public boolean METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 , Map conf ) { boolean result = false ; if ( ( VAR_1 - VAR_2 . METHOD_2 ( ) ) > Utils . getInt ( conf . get ( TYPE_2 . VAR_4 ) ) ) { result = true ; } <START> return result ; <END> } 
<START> public final static List < TYPE_1 > METHOD_1 ( ) { <END> final List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; VAR_1 . add ( TYPE_4 . TYPE_3 . VAR_4 . get ( 0 ) ) ; VAR_1 . add ( new TYPE_1 ( ( TYPE_4 . TYPE_2 . VAR_6 ^ TYPE_4 . TYPE_2 . VAR_7 ) , TYPE_4 . TYPE_3 . VAR_8 ) ) ; return VAR_1 ; } 
<START> private void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( new TYPE_2 . TYPE_3 . TYPE_4 ( ) { public void run ( ) { try { LOG . debug ( STRING_1 , VAR_3 ) ; if ( VAR_4 ) { this . METHOD_3 ( ) ; } METHOD_4 ( ) ; } catch ( Exception VAR_5 ) { LOG . error ( STRING_2 , VAR_5 ) ; } } } , 0 , VAR_6 ) ; } 
protected Map < String , TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { List < String > VAR_2 = VAR_1 . METHOD_2 ( ) ; Map < String , TYPE_1 > VAR_3 = new HashMap < String , TYPE_1 > ( ) ; if ( VAR_2 != null ) { for ( String VAR_4 : VAR_2 ) { TYPE_1 VAR_5 = VAR_1 . METHOD_3 ( VAR_4 , null ) ; <START> if ( VAR_5 != null ) { <END> VAR_3 . put ( VAR_4 , VAR_5 ) ; } } } return VAR_3 ; } 
public static Map METHOD_1 ( Object VAR_1 ) { Map < Object , Object > conf = new HashMap < Object , Object > ( ) ; TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 != null ) { <END> String VAR_3 = VAR_2 . METHOD_3 ( ) ; if ( VAR_3 != null ) { conf . VAR_4 ( ( Map < Object , Object > ) TYPE_2 . parse ( VAR_3 ) ) ; } } return conf ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { <START> return true ; <END> } else if ( VAR_1 . METHOD_2 ( ) == null ) { return true ; } else { return VAR_1 . METHOD_2 ( ) . isEmpty ( ) ; } } 
private static Set < String > METHOD_1 ( Map < String , TYPE_1 > VAR_1 ) { Set < String > VAR_2 = new HashSet < String > ( ) ; <START> if ( VAR_1 != null ) { <END> for ( TYPE_1 VAR_3 : VAR_1 . values ( ) ) { VAR_2 . addAll ( VAR_3 . METHOD_2 ( ) ) ; } } return VAR_2 ; } 
public static TYPE_1 METHOD_1 ( Object VAR_1 ) { <START> if ( VAR_1 == null ) { <END> return null ; } TYPE_1 VAR_2 = null ; if ( VAR_1 instanceof TYPE_2 ) { VAR_2 = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; } else if ( VAR_1 instanceof TYPE_3 ) { VAR_2 = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; } else if ( VAR_1 instanceof TYPE_4 ) { VAR_2 = ( ( TYPE_4 ) VAR_1 ) . METHOD_2 ( ) ; } return VAR_2 ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { for ( Object VAR_2 : METHOD_2 ( VAR_1 ) . values ( ) ) { TYPE_2 VAR_3 = METHOD_3 ( VAR_2 ) ; <START> if ( VAR_3 != null ) { <END> TYPE_3 VAR_4 = TYPE_4 . METHOD_4 ( Arrays . asList ( STRING_1 , STRING_2 ) ) ; VAR_3 . METHOD_5 ( Constants . VAR_5 , VAR_4 ) ; } } } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { for ( Object VAR_2 : METHOD_2 ( VAR_1 ) . values ( ) ) { TYPE_2 VAR_3 = METHOD_3 ( VAR_2 ) ; <START> if ( VAR_3 != null ) { <END> TYPE_3 VAR_4 = TYPE_4 . METHOD_4 ( Arrays . asList ( STRING_1 ) ) ; VAR_3 . METHOD_5 ( VAR_5 , VAR_4 ) ; } } } 
public static int METHOD_1 ( Object VAR_1 ) throws TYPE_1 { TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { throw new TYPE_1 ( STRING_1 + VAR_1 . getClass ( ) . getName ( ) ) ; <START> } <END> int VAR_3 = TYPE_3 . METHOD_3 ( VAR_2 ) ; return VAR_3 ; } 
public void METHOD_1 ( Map < Long , TYPE_1 > VAR_1 ) { this . VAR_1 . clear ( ) ; <START> this . VAR_1 . METHOD_2 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( Map < String , Map < String , Object > > VAR_1 ) { this . VAR_1 . clear ( ) ; <START> this . VAR_1 . METHOD_2 ( VAR_1 ) ; <END> } 
<START> public static List < TYPE_1 > METHOD_1 ( ) { <END> List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; VAR_1 . add ( TYPE_4 . TYPE_3 . VAR_4 . get ( 0 ) ) ; VAR_1 . add ( new TYPE_1 ( ( TYPE_4 . TYPE_2 . VAR_6 ^ TYPE_4 . TYPE_2 . VAR_7 ) , TYPE_4 . TYPE_3 . VAR_8 ) ) ; return VAR_1 ; } 
private void METHOD_1 ( String name , final Map conf ) { <START> TYPE_1 . METHOD_2 ( STRING_1 , new TYPE_2 < Integer > ( ) { <END> @Override public Integer call ( ) throws Exception { Collection < String > VAR_1 = TYPE_3 . METHOD_3 ( conf ) ; return VAR_1 . size ( ) ; } } ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_1 server ) { for ( TYPE_2 c : server . VAR_1 ( ) ) { if ( c != null && c instanceof TYPE_3 ) { <START> server . VAR_2 ( c ) ; <END> } } return server ; } 
public void METHOD_1 ( ) { String key = STRING_1 ; String VAR_1 = System . getProperty ( key ) ; try { System . VAR_2 ( STRING_1 , STRING_2 ) ; Assert . assertTrue ( Utils . VAR_3 ( METHOD_2 ( ) ) ) ; <START> } catch ( Exception VAR_4 ) { <END> } finally { if ( VAR_1 == null ) { System . VAR_5 ( key ) ; } else { System . VAR_2 ( key , VAR_1 ) ; } } } 
public void METHOD_1 ( ) { Assert . VAR_1 ( TYPE_1 . METHOD_2 ( ) ) ; TYPE_1 . METHOD_3 ( ) ; Assert . assertTrue ( TYPE_1 . METHOD_2 ( ) ) ; <START> TYPE_1 . METHOD_4 ( ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> if ( ! this . task . VAR_1 ( ) ) { throw new IllegalStateException ( STRING_1 ) ; } } 
public static Object METHOD_1 ( String VAR_1 ) { try { <START> LOG . info ( STRING_1 , VAR_1 ) ; <END> return METHOD_1 ( Class . VAR_2 ( VAR_1 ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
public static String METHOD_1 ( String VAR_1 , int VAR_2 ) { <START> return VAR_1 + VAR_3 + Integer . toString ( VAR_2 ) + VAR_3 + STRING_1 ; <END> } 
<START> public static Map METHOD_1 ( Map < Object , String > m , Object key ) { <END> if ( m . containsKey ( key ) ) { HashMap < Object , String > VAR_1 = new HashMap < > ( m ) ; String value = VAR_1 . get ( key ) ; String VAR_2 = new String ( new char [ value . length ( ) ] ) . METHOD_2 ( STRING_1 , STRING_2 ) ; VAR_1 . put ( key , VAR_2 ) ; return VAR_1 ; } return m ; } 
<START> public static String METHOD_1 ( ) throws RuntimeException { <END> String name = TYPE_1 . METHOD_2 ( ) . getName ( ) ; String [ ] split = name . split ( STRING_1 ) ; if ( split . length != 2 ) { throw new RuntimeException ( STRING_2 + name ) ; } return split [ 0 ] ; } 
<START> public static int METHOD_1 ( String VAR_1 ) { <END> return METHOD_2 ( Long . VAR_2 ( VAR_1 ) , VAR_3 ) ; } 
public static String METHOD_1 ( List < String > command ) { <START> List < String > VAR_1 = new TYPE_1 < > ( ) ; <END> for ( String VAR_2 : command ) { if ( VAR_2 == null ) { continue ; } VAR_1 . add ( STRING_1 + VAR_2 . METHOD_2 ( STRING_1 , STRING_2 ) + STRING_1 ) ; } return StringUtils . VAR_3 ( VAR_1 , STRING_3 ) ; } 
public void METHOD_1 ( ) { try { log . info ( STRING_1 , VAR_1 ) ; VAR_1 . METHOD_1 ( ) ; <START> } finally { <END> log . info ( STRING_2 , VAR_2 ) ; VAR_2 . METHOD_1 ( ) ; } } 
public boolean equals ( Object object ) { boolean VAR_1 = false ; if ( object != null && object instanceof TYPE_1 ) { <START> VAR_1 = ( this . type . equals ( ( ( TYPE_1 ) object ) . getType ( ) ) && this . VAR_2 == ( ( TYPE_1 ) object ) . METHOD_1 ( ) ) ; <END> } return VAR_1 ; } 
public synchronized static TYPE_1 getInstance ( ) { if ( instance == null ) { instance = new TYPE_1 ( ) ; } <START> return TYPE_2 . METHOD_1 ( ) ? instance : null ; <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_1 > VAR_2 = this . METHOD_2 ( ) ; <START> if ( Utils . TYPE_2 ( VAR_1 . METHOD_3 ( ) ) ) { <END> for ( TYPE_1 VAR_4 : VAR_2 ) { if ( VAR_4 . equals ( VAR_1 ) ) { return true ; } } } return false ; } 
<START> public static void METHOD_1 ( String VAR_1 ) { <END> File d = new File ( VAR_1 ) ; if ( d . exists ( ) ) { if ( d . VAR_2 ( ) ) { if ( ! d . VAR_3 ( ) ) { throw new RuntimeException ( STRING_1 + VAR_1 ) ; } } else { throw new RuntimeException ( STRING_2 + VAR_1 + STRING_3 ) ; } } else { LOG . warn ( STRING_4 , VAR_1 ) ; } } 
<START> public static TYPE_1 METHOD_1 ( String VAR_1 ) { <END> switch ( VAR_1 ) { case STRING_1 : return VAR_2 ; case STRING_2 : return VAR_3 ; case STRING_3 : return VAR_4 ; case STRING_4 : return VAR_5 ; case STRING_5 : return VAR_6 ; case STRING_6 : return VAR_7 ; case STRING_7 : return VAR_8 ; case STRING_8 : return VAR_9 ; case STRING_9 : return VAR_10 ; default : return null ; } } 
public void METHOD_1 ( Map conf ) { <START> LOG . info ( STRING_1 ) ; <END> } 
public void METHOD_1 ( ) { if ( TYPE_2 . TYPE_1 . VAR_3 . equals ( VAR_4 . get ( ) . METHOD_2 ( ) ) ) { try { VAR_4 . get ( ) . close ( ) ; LOG . info ( STRING_1 ) ; } catch ( IOException e ) { LOG . warn ( STRING_2 ) ; <START> } <END> } else { LOG . info ( STRING_3 ) ; } } 
public static String METHOD_1 ( Map conf ) { String VAR_1 = System . getProperty ( STRING_1 ) ; String VAR_2 = String . valueOf ( conf . get ( TYPE_1 . VAR_4 ) ) ; <START> if ( VAR_2 . equals ( STRING_2 ) ) { <END> return ( VAR_1 + VAR_5 + STRING_3 ) ; } else { if ( new File ( VAR_2 ) . METHOD_2 ( ) ) { return VAR_2 ; } else { return ( VAR_1 + VAR_5 + VAR_2 ) ; } } } 
public static String METHOD_1 ( Map conf ) throws IOException { String VAR_1 = String . valueOf ( conf . get ( TYPE_2 . VAR_3 ) ) + VAR_4 + STRING_1 ; try { TYPE_1 . METHOD_2 ( new File ( VAR_1 ) ) ; } catch ( IOException e ) { LOG . error ( STRING_2 + VAR_1 , e ) ; <START> throw e ; <END> } return VAR_1 ; } 
public static String METHOD_1 ( Map conf ) throws IOException { <START> return ( ( METHOD_2 ( conf ) + VAR_1 + STRING_1 ) ) ; <END> } 
public String getId ( ) { <START> return this . METHOD_1 ( ) + STRING_1 + this . METHOD_2 ( ) ; <END> } 
public double METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { return FLOAT_1 ; } Collection < TYPE_3 > VAR_3 = METHOD_3 ( VAR_1 , VAR_4 ) ; <START> LOG . info ( STRING_1 , VAR_3 ) ; <END> double VAR_5 = FLOAT_1 ; for ( TYPE_3 VAR_6 : VAR_3 ) { VAR_5 += VAR_2 . METHOD_4 ( VAR_6 ) ; } return VAR_5 ; } 
public void METHOD_1 ( TYPE_1 < String , Long > state ) { this . state = state ; VAR_1 = state . get ( STRING_1 , INT_1 ) ; <START> System . out . println ( STRING_2 + state + STRING_3 + VAR_1 + STRING_4 ) ; <END> } 
private void METHOD_1 ( ) { if ( VAR_1 <= 0 ) return ; TYPE_1 VAR_2 = new TYPE_1 ( ) { @Override public void run ( ) { <START> VAR_3 . set ( false ) ; <END> } } ; VAR_4 . METHOD_2 ( VAR_2 , VAR_1 * INT_1 ) ; } 
public String toString ( ) { String VAR_1 = STRING_1 ; for ( TYPE_1 VAR_2 : this . METHOD_1 ( ) ) { VAR_1 += VAR_2 . toString ( ) + STRING_2 ; } <START> return VAR_1 ; <END> } 
public String toString ( ) { String VAR_1 = "" ; if ( this . METHOD_1 ( ) ) { <START> VAR_1 += STRING_1 + this . getStatus ( ) + STRING_2 + this . getMessage ( ) + STRING_3 + this . METHOD_2 ( ) . toString ( ) ; <END> } else { VAR_1 += STRING_1 + this . getStatus ( ) + STRING_4 + this . METHOD_3 ( ) ; } return VAR_1 ; } 
public void METHOD_1 ( Map < String , TYPE_1 > VAR_1 ) { this . VAR_2 = new HashMap < String , TYPE_2 > ( ) ; <START> for ( Map . Entry < String , TYPE_1 > entry : VAR_1 . entrySet ( ) ) { <END> this . VAR_2 . put ( entry . getKey ( ) , new TYPE_2 ( entry . getValue ( ) . METHOD_2 ( ) , entry . getValue ( ) . METHOD_3 ( ) ) ) ; } } 
public void METHOD_1 ( Map < String , String > VAR_1 ) { this . status . VAR_2 ( VAR_1 ) ; <START> } <END> 
public Double METHOD_1 ( ) { Double VAR_1 = METHOD_2 ( TYPE_1 . VAR_3 ) ; if ( VAR_1 == null ) { throw new IllegalStateException ( STRING_1 ) ; } <START> return VAR_1 ; <END> } 
public TYPE_3 ( String VAR_2 , Map VAR_3 , TYPE_1 VAR_4 , <START> int VAR_5 , Map < TYPE_2 , String > VAR_6 ) { <END> this ( VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; this . VAR_7 = new HashMap < > ( 0 ) ; if ( VAR_6 != null ) { this . VAR_7 . METHOD_1 ( VAR_6 ) ; } this . METHOD_2 ( ) ; this . METHOD_3 ( ) ; } 
public Map < TYPE_1 , Collection < TYPE_2 > > METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public void METHOD_1 ( Map VAR_1 , TYPE_1 context , TYPE_2 VAR_2 ) { this . VAR_3 = new TYPE_3 ( VAR_2 ) ; VAR_4 . METHOD_1 ( VAR_1 , context , VAR_3 ) ; this . listener = METHOD_2 ( ) ; this . VAR_5 = METHOD_3 ( listener , VAR_1 ) ; <START> LOG . info ( STRING_1 , this . VAR_5 ) ; <END> } 
private Set < String > METHOD_1 ( TYPE_1 VAR_1 ) { Set < String > user = new HashSet < String > ( ) ; if ( VAR_1 == null ) { LOG . debug ( STRING_1 ) ; } else { LOG . debug ( STRING_2 + VAR_1 ) ; } if ( VAR_1 != null ) { for ( TYPE_2 p : VAR_1 . METHOD_2 ( ) ) { user . add ( VAR_2 . METHOD_3 ( p ) ) ; } } return user ; <START> } <END> 
public static final void METHOD_1 ( String key ) throws TYPE_1 { if ( key == null || key . isEmpty ( ) || STRING_1 . equals ( key ) || STRING_2 . equals ( key ) || ! TYPE_2 . matcher ( key ) . METHOD_2 ( ) ) { LOG . error ( STRING_3 , key , TYPE_2 ) ; <START> throw new TYPE_1 ( key + STRING_4 ) ; <END> } } 
private void METHOD_1 ( TYPE_1 VAR_1 , int count ) throws Exception { VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 + STRING_1 + key , <START> ByteBuffer . VAR_3 ( VAR_4 ) . METHOD_4 ( count ++ ) . METHOD_5 ( ) ) ; <END> } 
public static final void METHOD_1 ( String key ) { <START> if ( key == null || key . isEmpty ( ) || STRING_1 . equals ( key ) || STRING_2 . equals ( key ) || ! TYPE_1 . matcher ( key ) . METHOD_2 ( ) ) { <END> LOG . error ( STRING_3 , key , TYPE_1 ) ; throw new IllegalArgumentException ( key + STRING_4 ) ; } } 
private static String METHOD_1 ( int VAR_1 ) { <START> TYPE_1 VAR_2 = new TYPE_1 ( ) ; <END> VAR_2 . append ( ( ( VAR_1 & VAR_3 ) > 0 ) ? STRING_1 : STRING_2 ) ; VAR_2 . append ( ( ( VAR_1 & VAR_4 ) > 0 ) ? STRING_3 : STRING_2 ) ; VAR_2 . append ( ( ( VAR_1 & VAR_5 ) > 0 ) ? STRING_4 : STRING_2 ) ; return VAR_2 . toString ( ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <START> if ( METHOD_2 ( VAR_1 ) || METHOD_3 ( VAR_1 ) || METHOD_4 ( VAR_1 , VAR_2 ) ) { <END> return true ; } return false ; } 
private String METHOD_1 ( int VAR_1 ) { <START> TYPE_1 b = new TYPE_1 ( ) ; <END> b . append ( STRING_1 ) ; if ( ( VAR_1 & VAR_2 ) > 0 ) { b . append ( STRING_2 ) ; } if ( ( VAR_1 & VAR_3 ) > 0 ) { b . append ( STRING_3 ) ; } if ( ( VAR_1 & VAR_4 ) > 0 ) { b . append ( STRING_4 ) ; } b . append ( STRING_5 ) ; return b . toString ( ) ; } 
public void METHOD_1 ( TYPE_1 ctx , TYPE_2 e ) { <START> if ( server != null ) server . VAR_1 ( e . VAR_2 ( ) ) ; <END> } 
public TYPE_1 buffer ( ) throws IOException { TYPE_2 VAR_1 = new TYPE_2 ( TYPE_3 . METHOD_1 ( METHOD_2 ( ) ) ) ; int VAR_2 = 0 ; if ( token != null ) VAR_2 = token . length ; VAR_1 . METHOD_3 ( VAR_3 ) ; <START> VAR_1 . METHOD_4 ( ( int ) VAR_2 ) ; <END> if ( VAR_2 > 0 ) { VAR_1 . write ( token ) ; } VAR_1 . close ( ) ; return VAR_1 . buffer ( ) ; } 
public void add ( HashMap < Integer , ArrayList < TYPE_1 > > VAR_1 ) { for ( Map . Entry < Integer , ArrayList < TYPE_1 > > entry : VAR_1 . entrySet ( ) ) { Integer task = entry . getKey ( ) ; <START> METHOD_1 ( this . VAR_2 , task , entry . getValue ( ) ) ; <END> } } 
private void METHOD_1 ( String VAR_1 , Map < String , String > VAR_2 ) { for ( Map . Entry < String , String > entry : VAR_2 . entrySet ( ) ) { String stream = entry . getKey ( ) ; <START> VAR_3 . put ( new TYPE_1 ( VAR_1 , stream ) , entry . getValue ( ) ) ; <END> } } 
public void METHOD_1 ( String name , boolean VAR_1 , Object o ) { if ( o == null ) { return ; } if ( o instanceof TYPE_1 ) { <START> if ( VAR_1 == true ) { <END> if ( ( ( TYPE_1 ) o ) . METHOD_2 ( ) >= FLOAT_1 ) { return ; } } else { if ( ( ( TYPE_1 ) o ) . METHOD_2 ( ) > FLOAT_1 ) { return ; } } } throw new IllegalArgumentException ( STRING_1 + name + STRING_2 ) ; } 
public void METHOD_1 ( String name , Object o ) { if ( o == null ) { return ; } if ( o instanceof String ) { return ; } try { TYPE_1 . METHOD_1 ( name , TYPE_2 . class , o ) ; <START> } catch ( Exception ex ) { <END> } this . VAR_1 . METHOD_1 ( name , o ) ; } 
private static void METHOD_1 ( Map VAR_1 , TYPE_1 VAR_2 ) throws IllegalArgumentException { <START> LOG . info ( STRING_1 ) ; <END> double VAR_3 = METHOD_2 ( VAR_2 , VAR_1 ) ; Double VAR_4 = Utils . VAR_5 ( VAR_1 . get ( TYPE_2 . VAR_7 ) ) ; if ( VAR_4 < VAR_3 ) { throw new IllegalArgumentException ( STRING_2 + Utils . VAR_5 ( VAR_1 . get ( TYPE_2 . VAR_7 ) ) + STRING_3 + VAR_3 + STRING_4 ) ; } } 
public Double METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( VAR_1 ) ) { return METHOD_3 ( VAR_1 ) + METHOD_4 ( VAR_1 ) ; } <START> LOG . info ( STRING_1 , VAR_1 ) ; <END> return null ; } 
public TYPE_6 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_2 , Collection < TYPE_4 > VAR_3 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_4 = new TYPE_5 ( VAR_3 ) ; <END> METHOD_1 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , IOException { if ( VAR_2 == null ) { VAR_3 . METHOD_1 ( VAR_1 ) ; } else { <START> synchronized ( VAR_4 ) { <END> VAR_5 . add ( VAR_1 ) ; VAR_2 . update ( ) ; } if ( VAR_2 . commit ( ) ) { VAR_6 . commit ( VAR_7 . METHOD_2 ( ) ) ; METHOD_3 ( ) ; } } } 
private static TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 conf = new TYPE_1 ( ) ; Map config = new HashMap ( ) ; TYPE_2 props = new TYPE_2 ( ) ; props . put ( STRING_1 , VAR_1 ) ; props . put ( STRING_2 , STRING_3 ) ; props . put ( STRING_4 , STRING_5 ) ; conf . put ( TYPE_3 . VAR_3 , props ) ; <START> conf . put ( TYPE_3 . VAR_4 , STRING_6 ) ; <END> return conf ; } 
void METHOD_1 ( ) throws IOException { <START> this . writer . VAR_1 ( ) ; <END> this . writer . close ( ) ; } 
public long METHOD_1 ( ) { long VAR_1 = System . currentTimeMillis ( ) ; long VAR_2 = ( VAR_1 - VAR_3 ) / VAR_4 ; long VAR_5 = VAR_3 + ( VAR_4 * ( VAR_2 + 1 ) ) ; long VAR_6 = VAR_5 - VAR_1 ; if ( VAR_6 > 0 ) { try { Thread . VAR_7 ( VAR_6 ) ; } catch ( InterruptedException e ) { <START> e . VAR_8 ( ) ; <END> } } VAR_1 = System . currentTimeMillis ( ) ; return VAR_1 ; } 
public TYPE_1 execute ( TYPE_2 VAR_1 ) throws IOException { if ( VAR_2 ) { VAR_1 . METHOD_1 ( ) . out ( ) . METHOD_2 ( VAR_1 . METHOD_3 ( STRING_1 ) ) ; <START> } <END> VAR_1 . METHOD_1 ( ) . out ( ) . METHOD_2 ( VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ) ; return TYPE_1 . VAR_3 ; } 
<START> public void execute ( ) throws TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 { <END> TYPE_7 response = VAR_1 . METHOD_1 ( this ) ; response . VAR_2 ( STRING_1 ) ; this . METHOD_2 ( response ) ; } 
protected void METHOD_1 ( String path ) { try { TYPE_1 . METHOD_2 ( TYPE_2 . get ( path ) ) ; } catch ( IOException e ) { <START> VAR_1 . error ( String . format ( STRING_1 , path , METHOD_3 ( ) . METHOD_4 ( ) , e . toString ( ) ) ) ; <END> throw new TYPE_3 ( e ) ; } } 
private void METHOD_1 ( String VAR_1 ) { if ( ! METHOD_2 ( VAR_1 ) ) { return ; } TYPE_1 command = new TYPE_1 ( true , STRING_1 , VAR_2 , VAR_3 ) ; command . add ( VAR_1 ) ; String result = command . execute ( ) ; if ( result != null ) { String VAR_4 = STRING_2 + VAR_1 + STRING_3 + result ; VAR_3 . error ( VAR_4 ) ; throw new TYPE_2 ( VAR_4 ) ; } METHOD_3 ( VAR_1 ) ; <START> VAR_3 . debug ( STRING_4 + VAR_1 ) ; <END> } 
public TYPE_2 ( String url , Long VAR_2 , TYPE_1 VAR_3 , String VAR_4 , Map < String , String > VAR_5 , int VAR_6 , int VAR_7 ) { super ( url , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; <START> METHOD_1 ( VAR_6 ) ; <END> METHOD_2 ( VAR_7 ) ; } 
public boolean METHOD_1 ( TYPE_1 vm ) { VAR_1 . debug ( STRING_1 + vm . VAR_2 ( ) + STRING_2 ) ; final List < TYPE_2 > VAR_3 = VAR_4 . METHOD_2 ( null , vm . getId ( ) ) ; for ( final TYPE_2 VAR_5 : VAR_3 ) { <START> VAR_4 . remove ( VAR_5 . getId ( ) ) ; <END> } return true ; } 
public List < TYPE_1 > METHOD_1 ( long VAR_1 ) { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; List < TYPE_1 > result = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_2 VAR_4 : VAR_2 ) { TYPE_1 VAR_5 = METHOD_3 ( VAR_4 . METHOD_4 ( ) ) ; <START> if ( VAR_5 != null && VAR_5 . METHOD_5 ( ) == null ) { <END> result . add ( VAR_5 ) ; } } return result ; } 
private long VAR_1 ( long VAR_2 , String VAR_3 ) { <START> TYPE_3 VAR_5 = TYPE_3 . VAR_6 ( ) <END> try { TYPE_2 VAR_8 = VAR_5 . VAR_9 ( VAR_3 ) ; VAR_8 . VAR_10 ( 1 , VAR_2 ) ; TYPE_5 VAR_12 = VAR_8 . VAR_13 ( ) ; if ( ! VAR_12 . next ( ) ) { return INT_1 ; } return VAR_12 . VAR_14 ( STRING_1 ) ; } catch ( TYPE_1 e ) { throw new TYPE_4 ( e ) ; } } 
public String METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { <START> return TYPE_1 . VAR_2 ; <END> } return null ; } 
public void METHOD_1 ( long VAR_1 , Map < String , TYPE_1 > VAR_2 ) { <START> if ( VAR_3 . METHOD_2 ( ) ) <END> VAR_3 . debug ( STRING_1 + VAR_1 ) ; Map < Long , TYPE_3 . TYPE_4 > VAR_4 = METHOD_3 ( VAR_2 ) ; METHOD_4 ( VAR_1 , VAR_4 ) ; } 
public TYPE_1 METHOD_1 ( long VAR_1 , long VAR_2 ) { <START> <END> TYPE_1 result = METHOD_2 ( VAR_1 , VAR_2 ) ; return result ; } 
public void execute ( ) throws TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 { try { VAR_1 . METHOD_1 ( this ) ; TYPE_7 response = new TYPE_7 ( METHOD_2 ( ) ) ; METHOD_3 ( response ) ; } catch ( Exception e ) { VAR_2 . warn ( String . format ( STRING_1 , getId ( ) ) , e ) ; <START> throw new TYPE_3 ( TYPE_8 . VAR_4 , e . getMessage ( ) ) ; <END> } } 
public Boolean METHOD_1 ( ) { if ( VAR_1 != null ) { return VAR_1 ; } <START> return true ; <END> } 
public Boolean METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> return VAR_1 ; } return false ; } 
public void METHOD_1 ( ) throws TYPE_1 { Date time = new Date ( ) ; TYPE_2 VAR_1 = new TYPE_3 ( STRING_1 ) ; String VAR_2 = VAR_1 . format ( time ) ; Date VAR_3 = TYPE_4 . METHOD_2 ( VAR_2 ) ; <START> assertEquals ( time , VAR_3 ) ; <END> } 
public String METHOD_1 ( ) { String [ ] VAR_1 = VAR_2 . split ( STRING_1 ) ; if ( VAR_3 >= VAR_1 . length ) { VAR_3 = 0 ; } <START> VAR_4 . info ( STRING_2 + VAR_1 [ VAR_3 % VAR_1 . length ] ) ; <END> return VAR_1 [ VAR_3 ++ % VAR_1 . length ] ; } 
public static String [ ] METHOD_1 ( ) { <START> String [ ] VAR_1 = { STRING_1 , STRING_2 , STRING_3 } ; <END> return VAR_1 ; } 
public void METHOD_1 ( final Double VAR_1 , final Double VAR_2 , final Long VAR_3 ) { if ( VAR_1 != null && VAR_2 != null && VAR_3 != null && VAR_3 != 0 ) { final Double VAR_4 = VAR_2 / VAR_3 ; <START> this . VAR_5 = String . format ( STRING_1 , ( VAR_1 - VAR_4 ) * FLOAT_1 / VAR_4 ) ; <END> } } 
public void METHOD_1 ( ) { try { <START> VAR_1 . METHOD_2 ( VAR_2 , VAR_3 , VAR_4 , true ) ; <END> } catch ( Exception e ) { Assert . assertEquals ( TYPE_1 . class , e . getClass ( ) ) ; } } 
<START> public void METHOD_1 ( ) throws Exception { <END> String VAR_1 = STRING_1 ; METHOD_2 ( VAR_1 ) . when ( VAR_2 ) . METHOD_3 ( ) ; String VAR_3 = STRING_2 ; String VAR_4 = STRING_3 ; String VAR_5 = VAR_6 . METHOD_4 ( VAR_3 , VAR_4 , VAR_2 ) ; String VAR_7 = STRING_4 ; assertEquals ( VAR_7 , VAR_5 ) ; } 
private boolean METHOD_1 ( final String VAR_1 ) { VAR_2 . debug ( STRING_1 + VAR_1 + STRING_2 ) ; if ( VAR_1 == null ) { return true ; } <START> final TYPE_1 command = new TYPE_1 ( STRING_3 , VAR_3 . METHOD_2 ( ) ) ; <END> command . add ( STRING_4 ) ; command . add ( STRING_5 + VAR_1 ) ; return STRING_6 . equals ( command . execute ( null ) ) ; } 
public synchronized boolean METHOD_1 ( final String VAR_1 ) { METHOD_2 ( VAR_1 ) ; <START> final TYPE_1 cmd = new TYPE_1 ( VAR_2 , VAR_3 . METHOD_3 ( ) , VAR_4 ) ; <END> cmd . add ( STRING_1 ) ; cmd . add ( STRING_2 , VAR_1 ) ; final String result = cmd . execute ( ) ; if ( result != null ) { VAR_4 . debug ( STRING_3 + result ) ; return false ; } return true ; } 
private Map < String , String > METHOD_1 ( ) { <START> final TYPE_1 command = new TYPE_1 ( VAR_1 , VAR_2 . METHOD_2 ( ) , VAR_3 ) ; <END> final TYPE_2 VAR_4 = new TYPE_2 ( ) ; final String result = command . execute ( VAR_4 ) ; if ( result == null ) { return VAR_4 . METHOD_3 ( ) ; } else { return new HashMap < String , String > ( 1 ) ; } } 
private String METHOD_1 ( final String VAR_1 ) { <START> final TYPE_1 command = new TYPE_1 ( STRING_1 , VAR_2 . METHOD_2 ( ) , VAR_3 ) ; <END> command . add ( STRING_2 ) ; command . add ( VAR_1 ) ; return command . execute ( ) ; } 
private boolean METHOD_1 ( final String VAR_1 ) { <START> final TYPE_1 cmd = new TYPE_1 ( VAR_2 , VAR_3 . METHOD_2 ( ) , VAR_4 ) ; <END> cmd . add ( STRING_1 ) ; cmd . add ( VAR_1 ) ; final String result = cmd . execute ( ) ; if ( result != null ) { return false ; } return true ; } 
public boolean METHOD_1 ( ) { if ( ! VAR_1 ) { return false ; } <START> final TYPE_1 cmd = new TYPE_1 ( VAR_2 , VAR_3 . METHOD_2 ( ) , VAR_4 ) ; <END> cmd . add ( STRING_1 ) ; final String result = cmd . execute ( ) ; if ( result != null ) { return false ; } return true ; } 
private void METHOD_1 ( String name , String value ) throws TYPE_1 { <START> if ( org . VAR_1 . VAR_2 . VAR_3 . StringUtils . isEmpty ( value ) ) { <END> throw new TYPE_1 ( STRING_1 + name ) ; } } 
private TYPE_1 METHOD_1 ( long VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 != null ) return VAR_4 . METHOD_3 ( VAR_3 . METHOD_3 ( VAR_2 . getId ( ) ) . METHOD_4 ( ) ) ; <END> return null ; } 
private Long METHOD_1 ( long VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 != null ) return VAR_2 . METHOD_3 ( ) ; <END> return null ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 vm , TYPE_4 VAR_3 , TYPE_5 context ) throws TYPE_6 , TYPE_7 , TYPE_8 { if ( VAR_4 . METHOD_2 ( VAR_1 . getId ( ) , TYPE_11 . TYPE_9 , METHOD_3 ( ) ) ) { return true ; <START> } else { <END> return METHOD_4 ( VAR_1 , VAR_2 , vm , VAR_3 , TYPE_11 . TYPE_10 ) ; } } 
protected TYPE_1 METHOD_1 ( TYPE_2 context , TYPE_3 VAR_1 , TYPE_4 VAR_2 ) throws Exception { TYPE_5 VAR_3 = new TYPE_5 ( context , VAR_1 . METHOD_2 ( ) ) ; if ( VAR_3 . METHOD_3 ( ) == null ) { String msg = STRING_1 ; VAR_4 . error ( msg ) ; throw new TYPE_6 ( msg ) ; } <START> TYPE_1 VAR_5 = VAR_3 . METHOD_4 ( VAR_2 . getPath ( ) ) ; <END> return VAR_5 ; } 
public T VAR_1 ( final VAR_2 id ) { T result = null ; if ( VAR_3 != null ) { final TYPE_1 element = VAR_3 . get ( id ) ; if ( element == null ) { result = VAR_5 ( id , null ) ; } else { result = ( T ) element . VAR_6 ( ) ; } } else { result = VAR_5 ( id , null ) ; } <START> return result <END> } 
public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( null ) ; Assert . VAR_2 ( STRING_1 ) ; } catch ( TYPE_1 e ) { <START> } <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) ; <START> TYPE_1 . METHOD_3 ( VAR_2 , METHOD_4 ( 1 ) ) . METHOD_5 ( TYPE_1 . METHOD_6 ( STRING_1 ) , TYPE_1 . METHOD_6 ( VAR_4 ) , TYPE_1 . METHOD_6 ( VAR_5 ) ) ; <END> } 
public void METHOD_1 ( ) { List < Long > result = VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) ; <START> assertEquals ( result , VAR_4 ) ; <END> } 
<START> public static ByteBuffer METHOD_1 ( ByteBuffer buffer , final int VAR_1 ) { <END> if ( VAR_1 > buffer . VAR_2 ( ) ) { buffer = ByteBuffer . VAR_3 ( VAR_1 ) ; } else { buffer = ByteBuffer . VAR_3 ( buffer . VAR_2 ( ) * 2 ) ; } return buffer ; } 
private boolean METHOD_1 ( ) { <START> return new Boolean ( METHOD_2 ( ) . METHOD_3 ( ) . get ( TYPE_2 . TYPE_3 . toString ( ) ) ) ; <END> } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 == null ) <END> return true ; else return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( INT_1 ) ; VAR_1 . METHOD_3 ( INT_2 ) ; VAR_1 . METHOD_4 ( TYPE_2 . VAR_3 ) ; <START> METHOD_5 ( VAR_4 . METHOD_6 ( VAR_1 ) ) ; <END> } 
public String METHOD_1 ( String name ) { <START> assert ( VAR_1 != null ) : STRING_1 ; <END> return VAR_1 . get ( name ) ; } 
private void METHOD_1 ( final boolean VAR_1 ) { <START> TYPE_1 . VAR_1 = VAR_1 ; <END> } 
public String toString ( ) { StringBuilder VAR_1 = new StringBuilder ( ) ; for ( Map . Entry < String , String > VAR_2 : VAR_3 . entrySet ( ) ) { VAR_1 . append ( STRING_1 ) ; <START> VAR_1 . append ( STRING_2 + VAR_2 . getKey ( ) + STRING_3 + VAR_2 . getValue ( ) + STRING_4 ) ; <END> VAR_1 . append ( STRING_5 ) ; } return VAR_1 . toString ( ) ; } 
public boolean METHOD_1 ( long VAR_1 , long VAR_2 ) { TYPE_1 VAR_3 = TYPE_1 . METHOD_2 ( ) ; try { TYPE_2 VAR_4 = METHOD_3 ( VAR_1 ) ; if ( VAR_4 != null ) { VAR_3 . start ( ) ; VAR_4 . METHOD_4 ( VAR_2 ) ; update ( VAR_4 . getId ( ) , VAR_4 ) ; VAR_3 . commit ( ) ; } <START> } catch ( Exception e ) { <END> throw new TYPE_3 ( STRING_1 ) ; } return true ; } 
private TYPE_4 ( String VAR_2 ) { try { VAR_3 = TYPE_1 . METHOD_1 ( new TYPE_2 [ ] { new TYPE_2 ( STRING_1 + VAR_2 + STRING_2 ) } , getClass ( ) . METHOD_2 ( ) ) ; } catch ( TYPE_3 e ) { <START> e . VAR_4 ( ) ; <END> } } 
public int METHOD_1 ( ) { int result = VAR_1 != null ? VAR_1 . METHOD_1 ( ) : 0 ; result = INT_1 * result + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) ; result = INT_1 * result + ( VAR_3 != null ? VAR_3 . METHOD_1 ( ) : 0 ) ; return result ; <START> } <END> 
public int METHOD_1 ( ) { int result = VAR_1 != null ? VAR_1 . METHOD_1 ( ) : 0 ; result = INT_1 * result + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) ; return result ; <START> } <END> 
<START> public boolean equals ( Object o ) { <END> if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; if ( VAR_1 != that . VAR_1 ) return false ; return true ; } 
<START> public TYPE_1 ( Integer VAR_2 , String name , String VAR_3 , String description ) { <END> this . VAR_2 = VAR_2 ; this . description = description ; this . VAR_4 = name ; this . VAR_5 = VAR_3 ; this . VAR_6 = STRING_1 ; } 
public long METHOD_1 ( ) { Long VAR_1 = VAR_2 . METHOD_2 ( VAR_3 , VAR_4 ) . METHOD_3 ( ) ; if ( VAR_1 == null ) { return TYPE_1 . METHOD_4 ( ) . METHOD_5 ( ) . getId ( ) ; } <START> return TYPE_2 . VAR_6 ; <END> } 
public TYPE_1 METHOD_1 ( Long VAR_1 , long VAR_2 ) { TYPE_1 VAR_3 = super . METHOD_1 ( VAR_2 ) ; if ( VAR_3 . METHOD_2 ( ) ) { VAR_3 . METHOD_3 ( true ) ; if ( VAR_1 == null ) { throw new TYPE_2 ( STRING_1 ) ; <START> } <END> Map < String , String > VAR_4 = VAR_5 . METHOD_4 ( VAR_1 ) ; return METHOD_5 ( VAR_3 , VAR_4 ) ; } return VAR_3 ; } 
public TYPE_1 ( ) { <START> VAR_2 = this ; <END> } 
protected void METHOD_1 ( final String VAR_1 ) throws TYPE_1 { try { this . VAR_2 . METHOD_1 ( VAR_1 ) ; } catch ( Exception e ) { throw new TYPE_1 ( String . format ( STRING_1 , VAR_1 ) , e ) ; <START> } <END> } 
private Object METHOD_1 ( Object val ) { <START> if ( val instanceof Double ) { <END> if ( Math . VAR_1 ( ( Double ) val ) <= FLOAT_1 ) { return VAR_2 ; } } return val ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; if ( properties . VAR_1 ( ) != null && properties . VAR_1 ( ) . length ( ) > 0 && ! properties . VAR_2 ( ) . equals ( properties . VAR_1 ( ) ) ) { <START> final TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( ) ; <END> VAR_3 . execute ( STRING_1 + properties . VAR_1 ( ) ) ; VAR_3 . close ( ) ; } } 
private void METHOD_1 ( ) { <START> for ( TYPE_1 VAR_1 : ImmutableList . VAR_2 ( VAR_3 . values ( ) ) ) { <END> try { METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } catch ( final TYPE_2 ex ) { logger . debug ( String . format ( STRING_1 , VAR_1 . METHOD_3 ( ) . getName ( ) ) , ex ) ; } } } 
protected Object METHOD_1 ( Object o ) { <START> if ( o != null && o instanceof TYPE_1 && <END> ( ( TYPE_1 ) o ) . getType ( ) . equals ( STRING_1 ) ) { return ( ( TYPE_1 ) o ) . getValue ( ) ; } return super . METHOD_1 ( o ) ; } 
private void METHOD_1 ( ) throws TYPE_1 { <START> if ( null == VAR_1 ) return ; <END> VAR_2 . METHOD_1 ( node , VAR_1 ) ; } 
public TYPE_2 ( String VAR_2 , String VAR_3 , String stream ) { this . VAR_3 = VAR_3 ; this . stream = stream ; TYPE_1 server = METHOD_1 ( ) . METHOD_2 ( VAR_2 ) ; if ( server != null ) { METHOD_3 ( server . getName ( ) ) ; METHOD_4 ( server . VAR_4 ( ) ) ; } <START> METHOD_5 ( ) ; <END> } 
private static void METHOD_1 ( TYPE_1 listener , boolean VAR_1 , String path ) { boolean VAR_2 = false ; VAR_2 = path != null && ( path . isEmpty ( ) || path . equals ( STRING_1 ) ) ; <START> if ( VAR_1 && VAR_2 ) <END> { listener . VAR_3 ( ) . println ( String . format ( STRING_2 ) ) ; } } 
private static void METHOD_1 ( TYPE_1 listener , boolean VAR_1 , String path ) { boolean VAR_2 = false ; VAR_2 = ( path != null && ( path . isEmpty ( ) || path . equals ( STRING_1 ) ) ) ; if ( VAR_1 && VAR_2 ) { <START> listener . VAR_3 ( ) . println ( String . format ( STRING_2 ) ) ; <END> } } 
public TYPE_2 ( Map < String , TYPE_1 > VAR_2 , String version ) { this . VAR_2 = VAR_2 ; this . version = version ; <START> for ( TYPE_1 VAR_3 : VAR_2 . values ( ) ) { METHOD_1 ( VAR_3 ) ; } <END> METHOD_2 ( version ) ; } 
public void METHOD_1 ( String VAR_1 ) { if ( VAR_1 != null ) { <START> assertEquals ( String . format ( STRING_1 , VAR_1 ) , VAR_2 . METHOD_2 ( ) ) ; <END> } else { assertTrue ( VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_2 ( ) . startsWith ( STRING_2 ) ) ; } } 
<START> public void run ( String VAR_1 , TYPE_1 VAR_2 ) { <END> TYPE_2 . METHOD_1 ( ) ; TYPE_2 . METHOD_2 ( ) ; state = STRING_1 ; } 
public String toString ( ) { return new TYPE_1 ( this ) . append ( STRING_1 , getId ( ) ) . append ( STRING_2 , METHOD_1 ( ) ) . append ( STRING_3 , METHOD_2 ( ) ) <START> . toString ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { String result = VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) . set ( STRING_1 , TYPE_3 . VAR_5 ) . set ( STRING_2 , STRING_3 ) . set ( STRING_4 , STRING_5 ) . set ( STRING_6 , STRING_7 ) <START> . set ( STRING_8 , TYPE_1 . METHOD_3 ( STRING_9 ) ) <END> . METHOD_4 ( VAR_6 ) ; assertTrue ( result . startsWith ( STRING_10 ) ) ; } 
public void METHOD_1 ( int VAR_1 ) { VAR_2 = VAR_1 ; log . warn ( <START> STRING_1 ) ; <END> } 
protected void METHOD_1 ( ) { if ( VAR_1 . get ( ) . isEmpty ( ) ) { return ; } TYPE_1 VAR_2 = METHOD_2 ( ) ; for ( TYPE_2 entry : VAR_1 . get ( ) ) { <START> TYPE_3 record = METHOD_3 ( entry ) ; if ( entry != null ) { VAR_2 . append ( VAR_3 , record ) ; } <END> } } 
public boolean METHOD_1 ( TYPE_1 name ) { <START> if ( VAR_1 . stream ( ) . METHOD_2 ( VAR_2 - > name . VAR_3 ( ) . startsWith ( VAR_2 ) ) ) { return true ; <END> } return false ; } 
public boolean METHOD_1 ( TYPE_1 name , TYPE_1 group ) { if ( VAR_1 . stream ( ) . METHOD_2 ( VAR_2 - > group . VAR_3 ( ) . startsWith ( VAR_2 ) ) ) { return true ; <START> } <END> if ( METHOD_1 ( name ) ) { return true ; } return false ; } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > res = new ArrayList < > ( VAR_1 . values ( ) ) ; <START> Collections . VAR_2 ( res , TYPE_2 . METHOD_2 ( TYPE_1 : : getId ) ) ; <END> return res ; } 
public static void METHOD_1 ( ) { if ( STRING_1 . equals ( System . getProperty ( STRING_2 ) ) || TYPE_1 . equals ( System . getProperty ( VAR_1 ) ) ) { if ( ! TYPE_2 . METHOD_2 ( ) ) { METHOD_3 ( STRING_3 ) ; } } else { <START> TYPE_3 . METHOD_4 ( STRING_4 , false ) ; <END> } } 
public void METHOD_1 ( ) throws Exception { File VAR_1 = METHOD_2 ( STRING_1 ) ; TYPE_1 VAR_2 = TYPE_2 . METHOD_3 ( TYPE_1 . class ) ; TYPE_3 VAR_3 = TYPE_4 . METHOD_4 ( VAR_1 ) ; TYPE_5 context = TYPE_5 . builder ( VAR_4 , VAR_3 , VAR_5 . METHOD_5 ( ) ) . METHOD_6 ( true ) . build ( ) ; VAR_2 . METHOD_7 ( context ) ; TYPE_6 VAR_6 = VAR_4 . METHOD_8 ( VAR_5 . METHOD_9 ( ) ) ; <START> METHOD_10 ( 0 , VAR_6 . size ( ) ) ; <END> } 
<START> private void METHOD_1 ( String ... VAR_1 ) { <END> TYPE_1 VAR_2 = session . VAR_3 ( ) ; String VAR_4 = TYPE_2 . VAR_6 + VAR_2 . getName ( ) ; for ( String VAR_7 : VAR_1 ) { VAR_8 . METHOD_2 ( VAR_4 , VAR_7 , VAR_9 , false , VAR_2 , VAR_7 ) ; } } 
public TYPE_5 ( String VAR_2 , TYPE_1 session , String VAR_3 ) { <START> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; <END> if ( ! TYPE_3 . contains ( VAR_2 ) ) { throw new TYPE_4 ( STRING_2 + VAR_2 + STRING_3 + TYPE_3 ) ; } this . session = TYPE_2 . METHOD_1 ( session , STRING_4 ) ; this . VAR_3 = TYPE_2 . METHOD_1 ( VAR_3 , STRING_5 ) ; } 
public String METHOD_1 ( ) { TYPE_1 input = getProperty ( TYPE_2 . VAR_2 ) ; if ( input instanceof String ) { <START> return ( String ) input ; <END> } return null ; } 
public void METHOD_1 ( String VAR_1 ) { try { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( STRING_1 , STRING_2 , VAR_1 ) ; <START> VAR_2 . METHOD_3 ( STRING_1 , STRING_3 , VAR_1 ) ; <END> VAR_3 . METHOD_1 ( VAR_2 ) ; } catch ( TYPE_2 e ) { log . trace ( STRING_4 , e ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( ( ) - > { TYPE_1 VAR_1 = METHOD_3 ( STRING_1 , STRING_2 ) ; return session . VAR_2 ( new TYPE_2 ( VAR_1 . getId ( ) ) ) ; <START> <END> } , VAR_3 , VAR_4 , 2 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 , STRING_2 ) ; METHOD_3 ( ( ) - > { VAR_1 . setText ( STRING_3 ) ; VAR_2 . METHOD_4 ( session , VAR_1 . getId ( ) , VAR_1 ) ; return session . VAR_3 ( new TYPE_2 ( VAR_1 . getId ( ) ) ) ; <START> <END> } , VAR_4 , VAR_5 , 1 ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; TYPE_2 VAR_2 = session . VAR_3 ( new TYPE_3 ( VAR_1 . getId ( ) ) ) ; VAR_2 . METHOD_3 ( true ) ; METHOD_4 ( ( ) - > { VAR_4 . METHOD_5 ( session , VAR_1 . getId ( ) ) ; return VAR_2 ; <START> <END> } , VAR_5 , VAR_6 , 0 ) ; } 
public boolean METHOD_1 ( TYPE_1 event ) { if ( ! ( event . VAR_1 ( ) instanceof TYPE_2 ) ) { return false ; } TYPE_2 VAR_2 = ( TYPE_2 ) event . VAR_1 ( ) ; String VAR_3 = VAR_2 . METHOD_2 ( ) . getType ( ) ; <START> return ! ( TYPE_3 . contains ( event . getName ( ) ) && ( TYPE_4 . contains ( VAR_3 ) ) ) ; <END> } 
protected void METHOD_1 ( Object ... args ) { super . METHOD_1 ( args ) ; <START> final TYPE_1 request = ctx . VAR_1 ( ) ; <END> VAR_2 = request . VAR_3 ( STRING_1 ) ; VAR_4 = request . VAR_3 ( STRING_2 ) ; VAR_5 = request . VAR_3 ( STRING_3 ) ; } 
public Builder ( String VAR_1 ) { <START> TYPE_1 . METHOD_1 ( VAR_1 , STRING_1 ) ; this . query = VAR_1 ; <END> } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( ( ) - > { TYPE_2 VAR_2 = METHOD_3 ( VAR_3 , STRING_1 , STRING_2 ) ; return session . VAR_4 ( new TYPE_3 ( VAR_2 . getId ( ) ) ) ; } , VAR_5 , VAR_6 ) ; VAR_7 = VAR_1 ; METHOD_2 ( ( ) - > { TYPE_2 VAR_2 = METHOD_3 ( VAR_1 , STRING_1 , STRING_2 ) ; <END> return session . VAR_4 ( new TYPE_3 ( VAR_2 . getId ( ) ) ) ; } , VAR_5 , VAR_6 ) ; } 
protected void METHOD_1 ( TYPE_1 node , Map < String , TYPE_2 > ... VAR_1 ) { <START> node . VAR_2 ( TYPE_3 . VAR_4 , ( TYPE_2 ) Arrays . asList ( VAR_1 ) ) ; <END> } 
protected void METHOD_1 ( List < TYPE_1 > entity , TYPE_2 VAR_1 ) throws IOException { <START> TYPE_3 writer = ( TYPE_3 ) VAR_2 . METHOD_2 ( ctx , TYPE_1 . class , VAR_3 ) ; <END> writer . VAR_4 ( VAR_1 ) ; } 
private void METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> if ( VAR_1 == null || VAR_1 . trim ( ) . isEmpty ( ) ) { <END> assertEquals ( VAR_3 , VAR_2 ) ; } else { assertEquals ( VAR_4 + VAR_1 + VAR_5 , VAR_2 ) ; } } 
protected List < String > METHOD_1 ( ) { Set < String > TYPE_1 = ctx . VAR_1 ( VAR_2 ) ; List < String > VAR_3 = TYPE_2 . stream ( ) . filter ( TYPE_1 : : contains ) . collect ( Collectors . VAR_4 ( ) ) ; VAR_3 = VAR_3 . isEmpty ( ) ? TYPE_2 : VAR_3 ; <START> return VAR_3 ; <END> } 
public TYPE_1 ( String ... VAR_2 ) { <START> this ( Arrays . asList ( VAR_2 ) ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> return ( TYPE_1 ) VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 s , String VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( s , session - > { return METHOD_3 ( session , new TYPE_4 ( VAR_1 ) ) ; } ) ; <START> METHOD_4 ( s , VAR_2 . METHOD_5 ( ) ) ; <END> } 
protected String METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 < String > VAR_3 , String name , boolean VAR_4 , boolean VAR_5 ) { String VAR_6 = METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , name ) ; VAR_3 . METHOD_3 ( VAR_6 ) ; for ( String VAR_7 : METHOD_4 ( VAR_1 , VAR_4 , VAR_5 ) ) { <START> METHOD_1 ( VAR_7 , VAR_6 , VAR_3 , null , true , false ) ; <END> } VAR_3 . METHOD_5 ( ) ; return VAR_6 ; } 
protected File METHOD_1 ( String VAR_1 ) { <START> String VAR_2 = String . format ( STRING_1 , VAR_1 == null ? "" : VAR_1 ) ; <END> return new File ( TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) , VAR_2 ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { Map < String , Object > params = new HashMap < > ( ) ; <START> params . put ( STRING_1 , STRING_2 ) ; <END> try ( TYPE_2 ctx = new TYPE_2 ( ) ) { VAR_1 . run ( ctx , STRING_3 , params ) ; assertEquals ( STRING_4 , ctx . get ( STRING_5 ) ) ; } } 
protected TYPE_1 METHOD_1 ( TYPE_2 session , String VAR_1 , String name ) { TYPE_1 VAR_2 = session . VAR_3 ( VAR_1 , name , STRING_1 ) ; VAR_2 . METHOD_2 ( STRING_2 , STRING_3 , name ) ; VAR_2 . METHOD_2 ( STRING_2 , STRING_4 , "" ) ; TYPE_3 . METHOD_3 ( ( ) - > VAR_2 . METHOD_2 ( STRING_2 , STRING_5 , TYPE_4 . getInstance ( ) ) ) ; TYPE_1 parent = session . VAR_4 ( VAR_2 ) ; <START> METHOD_4 ( session , VAR_2 ) ; <END> return parent ; } 
protected static < R > R METHOD_1 ( TYPE_1 < R > VAR_1 ) { try { return VAR_1 . get ( ) ; } finally { if ( ! TYPE_2 . METHOD_2 ( ) ) { try { <START> TYPE_2 . METHOD_3 ( ) ; <END> } catch ( TYPE_3 e ) { log . error ( STRING_1 , e ) ; } } } } 
protected void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 ) throws IOException { <START> File file = TYPE_1 . METHOD_2 ( VAR_3 , STRING_1 . METHOD_3 ( VAR_4 ) ) . METHOD_4 ( ) ; <END> TYPE_2 . METHOD_5 ( STRING_2 , file , Map . of ( ) , Map . of ( STRING_3 , VAR_1 , STRING_4 , VAR_2 ) ) ; } 
private TYPE_1 METHOD_1 ( ) throws IOException { Map < String , Object > result = new HashMap < > ( ) ; result . put ( STRING_1 , VAR_1 ) ; result . put ( STRING_2 , VAR_2 ) ; <START> return TYPE_2 . METHOD_2 ( Collections . VAR_3 ( result ) ) ; <END> } 
public < T extends TYPE_1 > T METHOD_1 ( TYPE_2 method , Class < T > type ) { <START> if ( method != null ) { <END> T config = method . VAR_1 ( type ) ; if ( config != null ) { return config ; } } return METHOD_1 ( type ) ; } 
public static void METHOD_1 ( ) { <START> System . VAR_1 ( TYPE_1 . VAR_3 , VAR_4 ) ; <END> } 
<START> protected static void METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 > VAR_2 ) { <END> List < TYPE_2 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_2 id : VAR_2 ) { if ( ! VAR_1 . exists ( id ) ) { continue ; } if ( VAR_1 . METHOD_2 ( id ) ) { VAR_1 . METHOD_3 ( id ) ; } else { VAR_3 . add ( id ) ; } } VAR_1 . METHOD_4 ( VAR_3 . METHOD_5 ( new TYPE_2 [ 0 ] ) ) ; } 
protected List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { return TYPE_3 . METHOD_2 ( ( ) - > { TYPE_4 VAR_2 = TYPE_3 . METHOD_3 ( TYPE_4 . class ) ; try ( TYPE_5 session = VAR_2 . METHOD_4 ( VAR_3 ) ) { List < TYPE_6 > VAR_4 = session . query ( VAR_1 , false ) ; <START> return VAR_4 . stream ( ) . METHOD_5 ( ) . map ( TYPE_1 : : new ) . collect ( Collectors . VAR_5 ( ) ) ; <END> } } ) ; } 
public TYPE_1 METHOD_1 ( ) { try { <START> return METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( ) ; <END> } catch ( TYPE_2 e ) { log . error ( STRING_1 + METHOD_2 ( ) ) ; throw new TYPE_3 ( e ) ; } } 
public TYPE_1 METHOD_1 ( ) { try { return METHOD_2 ( ) . METHOD_3 ( ) . METHOD_1 ( ) ; } catch ( TYPE_2 e ) { <START> throw new TYPE_3 ( String . format ( STRING_1 , METHOD_2 ( ) ) , e ) ; <END> } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 , Object value ) { TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( VAR_2 , value ) ; if ( VAR_1 . VAR_4 != null ) { <START> VAR_3 . METHOD_3 ( VAR_1 . VAR_4 ) ; <END> } return VAR_3 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 , Object value ) { String VAR_3 = ( String ) value ; if ( VAR_3 . METHOD_2 ( STRING_1 ) && VAR_3 . length ( ) > 2 ) { value = VAR_3 . substring ( 0 , VAR_3 . length ( ) - 1 ) ; } TYPE_3 VAR_4 = TYPE_4 . METHOD_3 ( VAR_2 , value ) ; if ( VAR_1 . VAR_5 != null ) { <START> VAR_4 . METHOD_4 ( VAR_1 . VAR_5 ) ; <END> } return VAR_4 ; } 
public void METHOD_1 ( ) { assertNotNull ( VAR_1 ) ; String [ ] VAR_2 = VAR_1 . METHOD_2 ( STRING_1 ) ; assertNotNull ( VAR_2 ) ; <START> assertTrue ( VAR_2 . length == 0 ) ; <END> } 
public < T > T METHOD_1 ( Class < T > VAR_1 ) { <START> if ( VAR_1 == TYPE_1 . class ) { <END> return ( T ) this ; } if ( VAR_1 == TYPE_2 . class ) { return VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; } if ( VAR_1 == TYPE_3 . class ) { return VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; } return null ; } 
public void METHOD_1 ( ) { assertNotNull ( VAR_1 ) ; assertTrue ( VAR_1 . METHOD_2 ( ) . contains ( STRING_1 ) ) ; <START> TYPE_1 VAR_2 = ( TYPE_1 ) TYPE_2 . METHOD_3 ( TYPE_3 . class ) ; <END> assertNotNull ( VAR_2 ) ; TYPE_4 action = VAR_2 . METHOD_4 ( TYPE_5 . VAR_4 + STRING_1 ) ; assertNotNull ( action ) ; } 
public void METHOD_1 ( ) { <START> boolean VAR_1 = VAR_2 . METHOD_2 ( VAR_3 , METHOD_3 ( VAR_4 ) ) ; <END> assertTrue ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> return new TYPE_1 ( VAR_1 , VAR_2 , Boolean . VAR_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 record ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> return record ; } for ( TYPE_2 filter : VAR_1 ) { if ( record != null ) { record = filter . VAR_2 ( record ) ; } } return record ; } 
public void METHOD_1 ( ) { <START> log . warn ( METHOD_2 ( ) + STRING_1 ) ; <END> if ( VAR_1 . length ( ) != size ) { throw new IllegalStateException ( STRING_2 + VAR_1 . length ( ) + STRING_3 + size ) ; } } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) ; <END> if ( VAR_1 == null ) { log . error ( STRING_1 ) ; throw new TYPE_3 ( STRING_1 ) ; } return VAR_1 ; } 
protected boolean METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) . METHOD_4 ( ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( index != null ) { TYPE_3 [ ] value = ( TYPE_3 [ ] ) VAR_2 . getValue ( ) ; List < TYPE_3 > list = new ArrayList < > ( Arrays . asList ( value ) ) ; list . remove ( index . VAR_3 ( ) ) ; <START> VAR_1 . METHOD_2 ( VAR_4 , list . VAR_5 ( new TYPE_3 [ 0 ] ) ) ; <END> } else { VAR_1 . METHOD_2 ( VAR_4 , null ) ; } } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> VAR_1 . METHOD_2 ( ) ; VAR_2 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = VAR_2 . METHOD_2 ( STRING_1 , STRING_2 ) ; assertEquals ( STRING_3 , VAR_1 ) ; METHOD_3 ( VAR_1 ) ; METHOD_4 ( STRING_4 ) ; TYPE_1 result = METHOD_5 ( VAR_1 ) ; METHOD_6 ( result ) ; <START> METHOD_6 ( result ) ; <END> } 
public boolean METHOD_1 ( Object value , Object context ) { if ( VAR_1 ) { <START> TYPE_1 VAR_2 = new TYPE_1 ( ) ; <END> METHOD_2 ( value , context , ( session , VAR_3 ) - > { if ( session . exists ( VAR_3 ) ) { VAR_2 . METHOD_3 ( ) ; } } ) ; return VAR_2 . METHOD_4 ( ) ; } return true ; } 
public void METHOD_1 ( ) { VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( false ) . METHOD_4 ( STRING_1 , STRING_1 ) . build ( ) ; client = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( false ) . METHOD_5 ( INT_1 ) . METHOD_6 ( INT_1 ) <START> . METHOD_7 ( INT_1 ) <END> . build ( ) ; VAR_2 = ( TYPE_2 ) VAR_3 . METHOD_8 ( TYPE_4 . VAR_5 ) ; VAR_6 = new TYPE_3 ( VAR_7 ) ; } 
public static boolean METHOD_1 ( ) { String VAR_1 = System . getProperty ( VAR_2 ) ; <START> if ( Boolean . VAR_3 . equals ( Boolean . VAR_4 ( VAR_1 ) ) ) { <END> if ( VAR_5 == null ) { VAR_5 = METHOD_2 ( VAR_6 ) ; } return VAR_5 ; } return METHOD_2 ( VAR_6 ) ; } 
protected List < ? > METHOD_1 ( List < ? > VAR_1 ) { if ( VAR_1 == null || VAR_1 . size ( ) == 0 ) { return VAR_1 ; } Object entry = VAR_1 . get ( 0 ) ; if ( entry instanceof TYPE_1 ) { for ( Object VAR_2 : VAR_1 ) { try { METHOD_2 ( ( TYPE_1 ) VAR_2 ) ; <START> } catch ( RuntimeException e ) { <END> log . warn ( STRING_1 , e ) ; } } } return VAR_1 ; } 
public TYPE_1 ( ) { <START> super ( ) ; <END> this . VAR_2 = VAR_3 ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_1 VAR_3 , TYPE_1 VAR_4 ) { <START> return ( VAR_1 . METHOD_2 ( VAR_4 ) && VAR_3 . METHOD_2 ( VAR_2 ) ) ; <END> } 
<START> private TYPE_1 METHOD_1 ( ) { <END> return TYPE_2 . METHOD_2 ( TYPE_3 . class ) . METHOD_3 ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = ctx . VAR_3 ( ) . METHOD_2 ( ) ; try { <START> VAR_1 = VAR_1 . METHOD_3 ( ) ; <END> } catch ( TYPE_2 e ) { } VAR_1 . METHOD_1 ( VAR_2 ) ; return VAR_1 ; } 
public boolean METHOD_1 ( List < String > VAR_1 , String VAR_2 ) { String VAR_3 = METHOD_2 ( VAR_2 ) ; Set < String > TYPE_1 = new HashSet < > ( ) ; TYPE_1 . add ( VAR_4 ) ; <START> if ( VAR_2 != null ) { <END> TYPE_1 . add ( VAR_3 ) ; TYPE_1 . add ( METHOD_3 ( VAR_3 ) ) ; } return VAR_1 . stream ( ) . METHOD_4 ( TYPE_1 : : contains ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
protected static TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String content ) throws IOException { TYPE_1 VAR_3 = new TYPE_2 ( VAR_2 , content , VAR_1 ) ; <START> return VAR_3 ; <END> } 
public void start ( TYPE_1 context ) { super . start ( context ) ; Collection < TYPE_2 > VAR_1 = METHOD_1 ( VAR_2 ) ; VAR_1 . forEach ( c - > { <START> log . debug ( STRING_1 , c . getId ( ) ) ; <END> VAR_3 . put ( c . getId ( ) , TYPE_3 . METHOD_2 ( c . server ) ) ; } ) ; } 
public void METHOD_1 ( TYPE_1 context ) throws InterruptedException { super . METHOD_1 ( context ) ; VAR_1 . entrySet ( ) . forEach ( e - > { <START> log . debug ( STRING_1 , e . getKey ( ) ) ; <END> e . getValue ( ) . close ( ) ; } ) ; VAR_1 . clear ( ) ; } 
public TYPE_1 ( String VAR_2 , long count , byte [ ] data ) { <START> this ( VAR_2 , count , data , new byte [ ] { } , new byte [ ] { } ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 session = VAR_1 . METHOD_2 ( ) ; TYPE_1 parent = session . VAR_2 ( new TYPE_3 ( ( String ) VAR_1 . METHOD_3 ( VAR_3 ) ) ) ; <START> if ( ! TYPE_4 . equals ( parent . getType ( ) ) ) { <END> return VAR_1 ; } return METHOD_1 ( parent ) ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , String VAR_3 , boolean VAR_4 ) { <START> return VAR_1 . METHOD_2 ( ) && ( ! VAR_4 || ! VAR_1 . METHOD_3 ( ) ) <END> && ( VAR_1 . METHOD_4 ( VAR_2 ) || VAR_1 . METHOD_4 ( VAR_3 ) ) ; } 
public boolean METHOD_1 ( String target , String VAR_1 , TYPE_1 VAR_2 ) { <START> log . trace ( STRING_1 , VAR_2 . getId ( ) , target , VAR_1 ) ; <END> return VAR_3 . METHOD_2 ( target , VAR_4 - > new HashMap < > ( ) ) . METHOD_2 ( VAR_1 , VAR_4 - > new TYPE_2 < > ( ) ) . METHOD_2 ( VAR_2 . getId ( ) , VAR_4 - > new ArrayList < > ( ) ) . add ( VAR_2 ) ; } 
<START> String getKey ( String VAR_1 ) { <END> return metadata . name ( ) + VAR_1 ; } 
<START> protected static Long METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = METHOD_2 ( ) . getString ( METHOD_3 ( VAR_1 ) ) ; return VAR_2 == null ? Long . valueOf ( - 1 ) : Long . VAR_3 ( VAR_2 ) ; } 
protected void METHOD_1 ( ) { if ( context . VAR_1 ( ) ) { boolean VAR_2 = false ; try { METHOD_2 ( ) ; VAR_2 = true ; VAR_3 = VAR_4 ; } catch ( Exception e ) { <START> log . error ( e , e ) ; <END> } finally { if ( ! VAR_2 ) { log . error ( metadata . name ( ) + STRING_1 ) ; } } } } 
public static int METHOD_1 ( Path VAR_1 ) { Path VAR_2 = VAR_1 . METHOD_2 ( VAR_3 ) ; if ( VAR_2 . METHOD_3 ( ) . exists ( ) ) { <START> return Integer . valueOf ( METHOD_4 ( VAR_2 ) . getProperty ( VAR_4 ) ) ; <END> } return METHOD_5 ( VAR_1 ) ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 session , TYPE_1 VAR_1 ) { TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( TYPE_3 . class ) ; Map < String , TYPE_5 > props = Collections . VAR_3 ( <START> TYPE_8 . VAR_5 , ( TYPE_5 ) session ) ; <END> TYPE_6 < TYPE_1 > VAR_6 = ( TYPE_6 < TYPE_1 > ) VAR_2 . METHOD_3 ( VAR_7 , METHOD_4 ( new TYPE_7 ( STRING_1 , true ) ) , null , null , props , VAR_1 . getId ( ) ) ; return VAR_6 . METHOD_5 ( ) ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 ; try { VAR_2 = TYPE_2 . METHOD_2 ( ( ) - > { TYPE_3 VAR_3 = TYPE_2 . METHOD_3 ( TYPE_3 . class ) ; TYPE_1 user = VAR_3 . METHOD_4 ( ) ; <START> user . VAR_4 ( VAR_3 . METHOD_5 ( ) , VAR_1 ) ; <END> return VAR_3 . METHOD_6 ( user ) ; } ) ; } catch ( TYPE_4 e ) { log . error ( STRING_1 + VAR_1 + STRING_2 , e ) ; return null ; } return VAR_2 ; } 
protected void METHOD_1 ( TYPE_1 d , String id , String name , String VAR_1 ) { <START> Assert . assertEquals ( id , d . id ) ; <END> Assert . assertEquals ( name , d . name ) ; Assert . assertEquals ( VAR_1 , d . VAR_1 ) ; } 
public TYPE_1 [ ] METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( VAR_2 ) ; <START> return VAR_1 . METHOD_3 ( new TYPE_1 [ VAR_1 . size ( ) ] ) ; <END> } 
public void METHOD_1 ( TYPE_1 context ) throws InterruptedException { <START> super . METHOD_1 ( context ) ; <END> VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( 10 , TimeUnit . VAR_2 ) ; VAR_1 = null ; } 
public void METHOD_1 ( TYPE_1 context ) { <START> super . METHOD_1 ( context ) ; <END> VAR_1 . clear ( ) ; VAR_2 . close ( ) ; VAR_2 = null ; } 
protected void METHOD_1 ( ) { <START> VAR_1 = VAR_1 == null ? new ArrayList < > ( ) : new ArrayList < > ( VAR_1 ) ; <END> if ( user != null && ! VAR_1 . contains ( user ) ) { VAR_1 . add ( user ) ; } else if ( VAR_2 != null && VAR_1 . isEmpty ( ) ) { VAR_1 . add ( TYPE_1 . METHOD_2 ( VAR_2 ) ) ; } } 
public void METHOD_1 ( TYPE_1 context , String key , long VAR_1 ) { if ( ! TYPE_2 . equals ( key ) || VAR_2 . isEmpty ( ) ) { <START> return ; <END> } METHOD_2 ( context ) ; context . VAR_3 ( TYPE_2 , System . currentTimeMillis ( ) + VAR_4 ) ; } 
protected static void METHOD_1 ( ) throws IOException { TYPE_1 config = new TYPE_1 ( ) ; config . VAR_1 ( true ) ; config . VAR_2 ( STRING_1 ) ; config . VAR_3 ( STRING_2 ) ; config . VAR_4 ( STRING_3 ) ; config . VAR_5 ( VAR_6 . METHOD_2 ( ) . METHOD_3 ( ) ) ; config . VAR_7 ( VAR_6 . METHOD_2 ( ) . METHOD_3 ( ) ) ; <START> System . out . println ( config ) ; <END> VAR_8 = new TYPE_2 ( config ) ; VAR_8 . start ( ) ; } 
public String METHOD_1 ( String VAR_1 ) { TYPE_1 < String , List < TYPE_2 > > VAR_2 = client . VAR_3 ( ) . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) . get ( ) . METHOD_4 ( ) ; for ( Iterator < String > it = VAR_2 . METHOD_5 ( ) ; it . hasNext ( ) ; ) { String VAR_4 = it . next ( ) ; <START> if ( VAR_2 . get ( VAR_4 ) . isEmpty ( ) ) { <END> continue ; } return VAR_4 ; } return null ; } 
public TYPE_5 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; VAR_3 = TYPE_2 . METHOD_1 ( TYPE_3 . class ) . METHOD_2 ( VAR_2 . VAR_3 ) ; <START> VAR_4 = TYPE_2 . METHOD_1 ( TYPE_4 . class ) . METHOD_3 ( VAR_2 . VAR_5 ) ; <END> } 
protected void METHOD_1 ( ) { <START> Set < String > VAR_1 = new HashSet < > ( ) ; <END> for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 . VAR_4 . contains ( STRING_1 ) ) { VAR_1 . clear ( ) ; VAR_1 . addAll ( VAR_2 . VAR_5 ) ; } else { VAR_1 . addAll ( VAR_2 . VAR_5 ) ; VAR_1 . METHOD_2 ( VAR_2 . VAR_4 ) ; } } VAR_6 . VAR_7 . clear ( ) ; VAR_6 . VAR_7 . addAll ( VAR_1 ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , Map < String , Object > VAR_2 , Set < String > VAR_3 ) { <START> VAR_2 . keySet ( ) . forEach ( VAR_4 - > { <END> Object VAR_5 = VAR_1 . getProperty ( STRING_1 , VAR_4 ) ; if ( VAR_3 . contains ( VAR_4 ) ) { METHOD_2 ( VAR_2 . get ( VAR_4 ) , VAR_5 ) ; } else { assertEquals ( VAR_5 , VAR_2 . get ( VAR_4 ) ) ; } } ) ; } 
public boolean METHOD_1 ( ) { <START> return ( METHOD_2 ( ) || VAR_1 . VAR_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 user , TYPE_2 VAR_1 ) { try { TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( TYPE_3 . class ) ; user . VAR_3 ( VAR_2 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; <START> TYPE_4 . METHOD_5 ( ( ) - > { <END> VAR_2 . METHOD_6 ( user ) ; } ) ; } catch ( TYPE_5 e ) { log . error ( STRING_1 + VAR_1 . METHOD_4 ( ) , e ) ; return null ; } return user ; } 
<START> private TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . id = STRING_1 ; VAR_1 . VAR_2 = STRING_2 ; VAR_1 . VAR_3 = STRING_3 ; VAR_1 . VAR_4 = STRING_4 ; return VAR_1 ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 state = VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; Object [ ] VAR_3 = ( Object [ ] ) state . get ( VAR_4 ) ; if ( VAR_3 != null ) { <START> List < String > VAR_5 = Arrays . stream ( VAR_3 ) . map ( Object : : toString ) . collect ( Collectors . VAR_6 ( ) ) ; <END> return METHOD_4 ( VAR_5 ) ; } return Collections . VAR_7 ( ) ; } 
<START> private List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { <END> List < TYPE_1 > VAR_2 = new TYPE_3 < > ( ) ; for ( TYPE_2 id : VAR_1 ) { TYPE_1 node = METHOD_2 ( id ) ; if ( node != null || Boolean . VAR_3 . METHOD_3 ( ) ) { VAR_2 . add ( node ) ; } } return VAR_2 ; } 
public < TYPE_1 , TYPE_2 > TYPE_2 METHOD_1 ( TYPE_3 VAR_1 , TYPE_1 input ) { <START> return ( ( TYPE_4 < TYPE_1 , TYPE_2 > ) METHOD_2 ( input . getClass ( ) ) ) . METHOD_1 ( VAR_1 , input ) ; <END> } 
public void METHOD_1 ( ) throws IOException { <START> TYPE_1 stream = getClass ( ) . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ; <END> TYPE_2 VAR_1 = new TYPE_2 . TYPE_5 ( ) . parse ( stream ) ; long VAR_2 = TYPE_4 . METHOD_4 ( VAR_1 ) ; TYPE_2 VAR_3 = VAR_4 . METHOD_5 ( VAR_2 ) ; assertEquals ( VAR_1 , VAR_3 ) ; } 
public void start ( TYPE_1 context ) { if ( TYPE_2 . METHOD_1 ( ) ) { return ; } for ( TYPE_3 VAR_1 : METHOD_2 ( ) ) { try { VAR_1 . METHOD_3 ( ) . close ( ) ; } catch ( Exception e ) { <START> log . error ( String . format ( STRING_1 , VAR_1 . getName ( ) , <END> e . getMessage ( ) ) ) ; } } if ( TYPE_4 . METHOD_4 ( ) ) { TYPE_4 . METHOD_5 ( ) ; TYPE_4 . METHOD_6 ( ) ; } } 
protected boolean METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = ( ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) ; <START> return VAR_2 . METHOD_5 ( ) || ( VAR_1 == null ? false : VAR_2 . getName ( ) . equals ( VAR_1 ) ) ; <END> } 
public Response METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 , ANNOTATION_1 ( STRING_2 ) String VAR_2 , ANNOTATION_2 TYPE_1 request ) { METHOD_2 ( VAR_2 ) ; <START> TYPE_2 client = TYPE_3 . METHOD_3 ( TYPE_4 . class ) . METHOD_4 ( VAR_1 ) ; <END> return Response . VAR_3 ( METHOD_5 ( client , VAR_2 ) ) . build ( ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; <END> assertNotNull ( VAR_1 ) ; } 
public T METHOD_1 ( byte [ ] data ) { TYPE_1 VAR_1 = new TYPE_1 ( data ) ; TYPE_2 in = null ; try { in = new TYPE_3 ( VAR_1 ) ; return ( T ) in . VAR_2 ( ) ; } catch ( IOException | TYPE_4 e ) { throw new IllegalArgumentException ( e ) ; <START> } finally { <END> try { if ( in != null ) { in . close ( ) ; } } catch ( IOException ex ) { } } } 
<START> private void METHOD_1 ( TYPE_1 node ) { <END> String name = ( ( TYPE_2 ) node . VAR_1 ) . name ; boolean VAR_2 = METHOD_2 ( name , node ) ; TYPE_3 VAR_3 = VAR_2 ? TYPE_3 . VAR_4 : TYPE_3 . VAR_5 ; METHOD_3 ( new TYPE_2 ( VAR_6 . VAR_7 ) ) ; METHOD_4 ( VAR_3 ) ; METHOD_5 ( TYPE_4 . VAR_9 ) ; } 
public boolean equals ( Object o ) { if ( this == o ) <START> return true ; <END> if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 record = ( TYPE_1 ) o ; return VAR_1 == record . VAR_1 && TYPE_2 . equals ( VAR_2 , record . VAR_2 ) && TYPE_2 . equals ( key , record . key ) && Arrays . equals ( data , record . data ) ; } 
<START> private TYPE_1 METHOD_1 ( Path p ) { <END> try { return p . VAR_1 ( ) . METHOD_1 ( ) ; } catch ( TYPE_2 e ) { throw new IllegalStateException ( e ) ; } } 
public void METHOD_1 ( String name , String VAR_1 ) throws Exception { TYPE_1 context = VAR_2 . METHOD_2 ( name ) ; if ( context == null ) { context = VAR_2 . METHOD_2 ( ) ; TYPE_2 file = METHOD_3 ( name ) ; <START> TYPE_3 location = file . VAR_3 ( VAR_1 ) ; <END> if ( location == null ) { throw new TYPE_4 ( STRING_1 + VAR_1 + STRING_2 + name ) ; } context . VAR_4 ( location ) ; return ; } context . VAR_4 ( VAR_1 ) ; } 
public Map < String , TYPE_1 > getParameters ( String key ) { TYPE_2 entry = METHOD_1 ( key ) ; if ( entry == null ) { return null ; } <START> <END> Map < String , TYPE_1 > res = new TYPE_3 < > ( entry . VAR_1 ( ) ) ; if ( log . VAR_2 ( ) ) { log . debug ( String . format ( STRING_1 , key , res ) ) ; } return res ; } 
@Override public void METHOD_1 ( TYPE_1 context ) { <START> VAR_1 = null ; <END> super . METHOD_1 ( context ) ; } 
@Override public void METHOD_1 ( Object VAR_1 , String VAR_2 , TYPE_1 VAR_3 ) { <START> if ( TYPE_2 . equalsIgnoreCase ( VAR_2 ) ) { <END> if ( TYPE_3 . class . METHOD_2 ( VAR_1 . getClass ( ) ) ) { TYPE_3 VAR_4 = ( TYPE_3 ) VAR_1 ; VAR_5 . remove ( VAR_4 . getName ( ) ) ; } } } 
public void METHOD_1 ( ) throws IOException , TYPE_1 , InterruptedException { <START> System . VAR_1 ( TYPE_3 . VAR_3 , TYPE_3 . TYPE_2 . VAR_5 . toString ( ) ) ; <END> METHOD_2 ( 1 ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 results , int VAR_1 , int offset ) { int VAR_2 = Math . max ( 0 , offset ) ; int VAR_3 = VAR_1 >= 1 ? Math . VAR_4 ( results . size ( ) , VAR_2 + VAR_1 ) : results . size ( ) ; <START> return new TYPE_2 ( results . VAR_5 ( VAR_2 , VAR_3 ) ) ; <END> } 
public void METHOD_1 ( ) { try { TYPE_1 VAR_1 = ( TYPE_1 ) session . VAR_2 ( TYPE_3 . VAR_4 ) . set ( STRING_1 , STRING_2 ) . execute ( ) ; METHOD_2 ( STRING_3 + VAR_1 ) ; } catch ( TYPE_2 e ) { assertNotNull ( e ) ; METHOD_3 ( e . VAR_5 ( ) ) ; } catch ( Exception e ) { <START> METHOD_2 ( ) ; <END> } } 
<START> public void METHOD_1 ( TYPE_1 context ) throws InterruptedException { <END> METHOD_2 ( ) ; } 
<START> public static < T > T METHOD_1 ( String VAR_1 , Map < String , Object > parameters ) { <END> return TYPE_1 . METHOD_1 ( VAR_1 ) . parameters ( parameters ) . execute ( ) ; } 
public TYPE_1 run ( TYPE_1 VAR_1 ) { return VAR_1 . stream ( ) . map ( VAR_2 - > { <START> return run ( VAR_2 ) ; <END> } ) . collect ( Collectors . VAR_3 ( TYPE_2 : : new ) ) ; } 
public String METHOD_1 ( TYPE_1 in ) throws IOException { <START> String text = TYPE_2 . toString ( in , TYPE_3 . VAR_2 ) ; <END> return METHOD_1 ( text ) ; } 
public String METHOD_1 ( ) { if ( VAR_1 != null ) { return VAR_1 ; <START> } else if ( VAR_2 != null && VAR_2 . size ( ) > 0 ) { <END> return VAR_2 . get ( 0 ) ; } return getId ( ) ; } 
public static < TYPE_1 > TYPE_2 < TYPE_1 > METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public void METHOD_1 ( String key , long id ) { <START> while ( ( METHOD_2 ( key ) ) < id ) { <END> continue ; } } 
public static boolean METHOD_1 ( TYPE_1 stream ) { try { TYPE_2 VAR_1 = new TYPE_2 ( stream ) ; <START> TYPE_3 entry = VAR_1 . METHOD_2 ( ) ; <END> return entry != null ; } catch ( IOException e ) { return false ; } } 
public void METHOD_1 ( ) { <START> this . VAR_1 = null ; <END> } 
public void METHOD_1 ( ) throws Exception { VAR_1 . value = Boolean . VAR_2 ; try { VAR_1 . VAR_3 = STRING_1 ; VAR_1 . run ( VAR_4 ) ; METHOD_2 ( ) ; } catch ( TYPE_1 | TYPE_2 e ) { assertEquals ( STRING_2 , e . getMessage ( ) ) ; } catch ( Exception e ) { <START> METHOD_2 ( ) ; <END> } } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . VAR_2 . forEach ( TYPE_2 : : add ) ; return this ; <START> } <END> 
protected static String METHOD_1 ( Throwable t ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; <END> t . VAR_3 ( VAR_2 ) ; VAR_2 . close ( ) ; return VAR_1 . toString ( ) ; } 
public String METHOD_1 ( String VAR_1 ) { <START> TYPE_1 < String , List < TYPE_2 > > VAR_2 = VAR_2 = client . VAR_3 ( ) . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) . get ( ) . METHOD_4 ( ) ; <END> if ( VAR_2 . isEmpty ( ) ) { return null ; } return VAR_2 . METHOD_5 ( ) . next ( ) ; } 
public String METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { <END> return VAR_1 + VAR_3 + STRING_1 ; } int i = VAR_2 . METHOD_2 ( VAR_3 ) ; if ( i < 0 ) { throw new IllegalArgumentException ( STRING_2 + VAR_2 ) ; } int index = Integer . parseInt ( VAR_2 . substring ( i + 1 ) ) + 1 ; return String . format ( STRING_3 , VAR_1 , VAR_3 , index ) ; } 
public void METHOD_1 ( String name , int VAR_1 , int VAR_2 ) { <START> METHOD_1 ( name , VAR_1 , VAR_2 , new TYPE_1 ( ) ) ; <END> } 
<START> static public TYPE_1 of ( String key , byte [ ] data ) { <END> return new TYPE_1 ( key , data , 0 , VAR_1 ) ; } 
<START> static public boolean exists ( File VAR_1 ) { <END> return VAR_1 . METHOD_1 ( ) && VAR_1 . list ( ) . length > 0 ; } 
<START> static public < TYPE_1 extends TYPE_2 > TYPE_3 < TYPE_1 > METHOD_1 ( String VAR_1 , String name , TYPE_4 VAR_2 , TYPE_4 VAR_3 ) { <END> return new TYPE_3 < > ( VAR_1 , name , VAR_2 , VAR_3 ) ; } 
protected void METHOD_1 ( ) { if ( VAR_1 != null && ! VAR_1 . METHOD_2 ( ) ) { try { VAR_1 . close ( ) ; <START> } catch ( Exception e ) { <END> log . debug ( metadata . name ( ) + STRING_1 , e ) ; } } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { log . debug ( STRING_1 ) ; if ( VAR_2 == null ) { return true ; } long VAR_3 = VAR_2 . METHOD_2 ( ) . filter ( VAR_4 - > ! VAR_4 . METHOD_1 ( VAR_1 ) ) . count ( ) ; log . debug ( String . format ( STRING_2 , VAR_3 ) ) ; <START> return VAR_3 == INT_1 ; <END> } 
public TYPE_1 ( String message ) { <START> super ( message ) ; <END> } 
<START> public static boolean exists ( File VAR_1 ) { <END> return VAR_1 . METHOD_1 ( ) && VAR_1 . list ( ) . length > 0 ; } 
protected int METHOD_1 ( File VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) . getName ( ) ; <START> return Integer . valueOf ( VAR_2 . substring ( VAR_2 . length ( ) - 2 ) ) ; <END> } 
public List < String > METHOD_1 ( ) { TYPE_1 < String > VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> return VAR_3 . VAR_4 . TYPE_2 . METHOD_3 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> TYPE_1 . METHOD_2 ( this , file , this ) . METHOD_3 ( ) ; TYPE_2 . METHOD_4 ( STRING_2 ) ; System . out . println ( STRING_3 ) ; } 
public void METHOD_1 ( ) throws Exception { final File file = VAR_1 . METHOD_2 ( new File ( STRING_1 ) ) ; <START> Thread . VAR_2 ( 100 ) ; <END> VAR_3 . METHOD_3 ( new TYPE_1 ( file ) ) ; VAR_3 . METHOD_4 ( 5 , TimeUnit . VAR_4 ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( TYPE_2 . class ) ; <START> return VAR_1 . METHOD_3 ( StringUtils . VAR_2 ( this . VAR_3 ) ? VAR_3 : VAR_4 ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { if ( VAR_2 . METHOD_2 ( ) ) { METHOD_3 ( VAR_1 , VAR_2 ) ; } else if ( VAR_2 . METHOD_4 ( ) ) { <START> METHOD_5 ( VAR_1 , VAR_2 ) ; <END> } else if ( VAR_2 . METHOD_6 ( ) ) { METHOD_7 ( VAR_1 , VAR_2 ) ; } else if ( VAR_2 instanceof TYPE_3 ) { METHOD_8 ( VAR_1 , VAR_2 ) ; } else if ( VAR_2 . METHOD_9 ( ) ) { VAR_1 . METHOD_10 ( ) ; } } 
public TYPE_1 run ( ) { <START> if ( TYPE_2 . METHOD_1 ( ) . METHOD_2 ( ) ) { <END> return TYPE_1 . METHOD_3 ( STRING_1 ) ; } return TYPE_1 . METHOD_4 ( STRING_2 ) ; } 
public TYPE_1 run ( ) { if ( TYPE_2 . METHOD_1 ( ) != null && TYPE_2 . METHOD_1 ( ) . METHOD_2 ( ) ) { return TYPE_1 . METHOD_3 ( STRING_1 ) ; <START> } <END> return TYPE_1 . METHOD_4 ( STRING_2 ) ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( TYPE_2 . class ) ; if ( StringUtils . isEmpty ( VAR_1 ) ) { return VAR_2 . METHOD_3 ( ) ; } <START> return VAR_2 . METHOD_1 ( VAR_1 ) ; <END> } 
public static List < Throwable > METHOD_1 ( Throwable VAR_1 ) { <START> final List < Throwable > list = new ArrayList < Throwable > ( ) ; <END> while ( VAR_1 != null && list . contains ( VAR_1 ) == false ) { list . add ( VAR_1 ) ; VAR_1 = METHOD_2 ( VAR_1 ) ; } return list ; } 
protected void METHOD_1 ( TYPE_1 request , TYPE_2 query , TYPE_3 VAR_1 ) { if ( log . VAR_2 ( ) ) { String VAR_3 = "" ; if ( request . VAR_3 ( ) != null ) { VAR_3 = STRING_1 + request . VAR_3 ( ) . toString ( ) ; <START> } <END> log . debug ( String . format ( STRING_2 , METHOD_2 ( query ) , VAR_4 , VAR_1 . toString ( ) . METHOD_3 ( ) , VAR_3 , request . source ( ) . toString ( ) ) ) ; } } 
protected String METHOD_1 ( String [ ] VAR_1 ) { String VAR_2 = "" ; if ( VAR_1 != null && VAR_1 . length > 0 ) { VAR_2 = String . VAR_3 ( STRING_1 , VAR_1 ) ; <START> } <END> return VAR_2 ; } 
public boolean METHOD_1 ( ) { <START> return ( VAR_1 != null ) ; <END> } 
protected void METHOD_1 ( String key , String VAR_1 ) { String VAR_2 = System . getProperty ( key ) ; VAR_3 . put ( key , VAR_2 ) ; <START> System . VAR_4 ( key , VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 . METHOD_2 ( TYPE_2 . class ) . METHOD_3 ( STRING_1 + VAR_1 . METHOD_4 ( STRING_2 ) ) ; <END> final File file = VAR_2 . METHOD_5 ( new File ( STRING_3 ) ) ; VAR_1 . METHOD_6 ( new TYPE_3 ( file ) ) ; VAR_1 . METHOD_7 ( 5 , TimeUnit . VAR_3 ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( ) ; METHOD_3 ( ) ; TYPE_1 response = VAR_1 . METHOD_4 ( TYPE_1 . class ) ; assertEquals ( INT_1 , response . getStatus ( ) ) ; <START> response . close ( ) ; <END> } 
<START> TYPE_1 ( ) { <END> this . VAR_2 = VAR_3 ; this . VAR_4 = VAR_3 ; this . VAR_5 = VAR_3 ; } 
public TYPE_1 run ( TYPE_1 VAR_1 ) throws TYPE_2 , IOException { if ( VAR_2 != null ) { <START> VAR_3 = true ; <END> VAR_1 . METHOD_1 ( TYPE_4 . VAR_5 , VAR_2 ) ; } TYPE_3 . METHOD_2 ( session , VAR_1 , properties ) ; if ( VAR_3 ) { VAR_1 = session . VAR_6 ( VAR_1 ) ; } return VAR_1 ; } 
public long METHOD_1 ( ) { if ( VAR_1 == null ) { TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; String VAR_3 = VAR_2 . getProperty ( VAR_4 , VAR_5 ) ; try { VAR_1 = Long . valueOf ( VAR_3 ) ; } catch ( TYPE_3 e ) { log . warn ( String . format ( STRING_1 , <START> VAR_1 , getName ( ) ) ) ; <END> VAR_1 = Long . valueOf ( VAR_5 ) ; } } return VAR_1 ; } 
public boolean METHOD_1 ( ) { return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) <START> || VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; <END> } 
protected void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; <START> VAR_2 = ( TYPE_3 ) VAR_1 ; <END> } 
<START> void METHOD_1 ( List < String > VAR_1 , List < String > VAR_2 ) { <END> assertEquals ( new HashSet < String > ( VAR_1 ) , new HashSet < String > ( VAR_2 ) ) ; } 
protected TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 TYPE_4 ) { String list = TYPE_5 . METHOD_2 ( TYPE_4 ) ; String name = TYPE_4 . METHOD_3 ( ) ; log . debug ( STRING_1 + name + STRING_2 + list ) ; if ( list == null ) { return null ; } <START> return Arrays . stream ( list . split ( STRING_3 ) ) . map ( s - > TYPE_4 . METHOD_4 ( ( String ) s ) ) . filter ( TYPE_6 : : METHOD_5 ) ; <END> } 
public void METHOD_1 ( ) { <START> if ( parent != null ) parent . VAR_1 ( ) ; <END> } 
public void METHOD_1 ( String VAR_1 , List < String > VAR_2 , TYPE_1 session ) throws TYPE_2 { if ( VAR_3 ) { return ; } METHOD_2 ( ) ; <START> VAR_4 . METHOD_1 ( VAR_1 , VAR_2 , session ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 model = METHOD_2 ( VAR_1 ) ; <START> return model != null ? METHOD_3 ( model ) : null ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_2 > VAR_1 = METHOD_2 ( Collections . VAR_2 ( ) , 0 ) ; <START> return VAR_1 . stream ( ) . map ( VAR_3 - > METHOD_3 ( VAR_3 ) ) . collect ( Collectors . VAR_4 ( ) ) ; <END> } 
<START> TYPE_1 METHOD_1 ( TYPE_2 server ) { <END> this . server = server ; return this ; } 
<START> TYPE_1 METHOD_1 ( ) throws TYPE_2 { <END> instance = server . VAR_1 ( TYPE_3 . this , TYPE_4 . METHOD_2 ( TYPE_3 . class . getName ( ) ) ) ; return this ; } 
<START> void METHOD_1 ( ) throws TYPE_1 { <END> try { server . VAR_1 ( instance . VAR_2 ( ) ) ; } finally { instance = null ; } } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 . size ( ) == 0 ) { <END> return ; } else { for ( TYPE_1 VAR_2 : VAR_1 ) { TYPE_2 . METHOD_3 ( VAR_2 ) ; } } } 
<START> private void METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; if ( VAR_2 . METHOD_3 ( VAR_1 ) == null && VAR_2 . METHOD_4 ( VAR_1 ) == null ) { String VAR_3 = STRING_1 + VAR_1 + STRING_2 ; throw new TYPE_3 ( VAR_3 ) ; } } 
public File METHOD_1 ( ) { if ( StringUtils . VAR_1 ( path ) ) { File VAR_2 = new File ( TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) , STRING_1 ) ; <START> return new File ( VAR_2 , getName ( ) ) ; <END> } else { return new File ( path ) ; } } 
protected HashMap < String , String > METHOD_1 ( ) throws TYPE_1 { HashMap < String , String > VAR_1 = new HashMap < > ( ) ; <START> METHOD_2 ( ) ; <END> METHOD_3 ( ) ; METHOD_4 ( VAR_1 ) ; return VAR_1 ; } 
public static TYPE_1 create ( ) { TYPE_1 writer = new TYPE_1 ( ) ; <START> writer . VAR_1 = TYPE_2 . VAR_3 ; <END> return writer ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_1 writer = new TYPE_1 ( this ) ; <END> writer . VAR_1 = VAR_1 ; return writer ; } 
private String [ ] METHOD_1 ( ) { List < String > VAR_1 = METHOD_2 ( ) ; <START> String VAR_2 [ ] = new String [ this . VAR_1 . size ( ) ] ; <END> int i = 0 ; for ( String repo : VAR_1 ) { VAR_2 [ i ++ ] = VAR_3 . METHOD_3 ( repo ) ; } return VAR_2 ; } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { Map < String , Map < String , String > > properties = VAR_2 ; if ( VAR_1 . METHOD_2 ( ) ) { properties = VAR_3 ; <START> } <END> properties . VAR_4 ( VAR_1 . METHOD_3 ( ) , key - > new HashMap < > ( ) ) . put ( VAR_1 . getName ( ) , VAR_1 . METHOD_4 ( ) ) ; log . info ( STRING_1 + VAR_1 ) ; } 
protected String METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( TYPE_2 . class ) ; try { <START> TYPE_4 uri = VAR_2 . METHOD_3 ( VAR_1 , TYPE_6 . VAR_4 ) . get ( TYPE_5 . VAR_6 ) ; <END> if ( uri != null ) { return uri . toString ( ) ; } } catch ( IOException e ) { log . error ( STRING_1 , e ) ; } return null ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , Map < String , TYPE_3 > VAR_4 ) { this . VAR_3 = VAR_3 ; this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; this . VAR_5 = null ; METHOD_1 ( ) ; <START> METHOD_2 ( ) ; <END> } 
public static String METHOD_1 ( File file , String VAR_1 ) throws IOException { TYPE_1 VAR_2 = METHOD_2 ( file , VAR_1 ) ; <START> return TYPE_2 . toString ( VAR_2 , TYPE_3 . VAR_4 ) ; <END> } 
<START> ANNOTATION_1 public void METHOD_1 ( ) throws TYPE_1 { <END> String s = STRING_1 ; assertEquals ( STRING_2 , StringUtils . VAR_1 ( s ) ) ; } 
public boolean METHOD_1 ( String VAR_1 ) { String VAR_2 = METHOD_2 ( VAR_1 ) ; if ( ! TYPE_1 . METHOD_3 ( TYPE_2 . class ) . METHOD_4 ( VAR_3 ) <START> && STRING_1 . equals ( VAR_2 ) ) { <END> return false ; } TYPE_3 VAR_4 = METHOD_5 ( ) . METHOD_6 ( VAR_2 ) ; return VAR_4 != null || METHOD_7 ( ) . METHOD_8 ( VAR_2 , STRING_2 ) != null ; } 
public Type getType ( String id ) { Type type = VAR_1 . get ( id ) ; if ( type == null ) { return null ; <START> } else { <END> Map < String , TYPE_1 > VAR_2 = METHOD_1 ( type ) ; Type VAR_3 = type . VAR_4 ( ) ; VAR_3 . METHOD_2 ( VAR_2 ) ; VAR_3 . METHOD_3 ( new String [ 0 ] ) ; return VAR_3 ; } } 
public static TYPE_1 instance ( ) { TYPE_2 VAR_1 = VAR_2 . values ( ) . stream ( ) . filter ( TYPE_2 : : METHOD_1 ) <START> . METHOD_2 ( ) <END> . METHOD_3 ( null ) ; if ( VAR_1 != null ) { return instance ( VAR_1 . METHOD_4 ( ) ) ; } return null ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_2 . getProperty ( VAR_3 ) != null ) { <START> TYPE_3 VAR_4 = VAR_2 . METHOD_2 ( TYPE_3 . class ) ; <END> for ( TYPE_4 view : VAR_4 . METHOD_3 ( ) ) { if ( view . VAR_5 ( ) . equals ( STRING_1 ) && view . VAR_6 ( ) != null ) { return view . VAR_6 ( ) ; } } } return VAR_1 ; } 
public boolean METHOD_1 ( long VAR_1 ) throws InterruptedException { TYPE_1 VAR_2 = METHOD_2 ( ) ; <START> if ( VAR_2 != null ) { <END> return VAR_2 . METHOD_3 ( VAR_1 , TimeUnit . VAR_3 ) ; } else { return false ; } } 
public void METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( ) ; if ( VAR_2 != null ) { List < TYPE_2 > VAR_4 = VAR_5 . METHOD_3 ( ) ; <START> if ( VAR_4 . size ( ) > 0 ) { <END> VAR_6 = VAR_2 . getInstance ( ) ; VAR_6 . METHOD_1 ( VAR_4 , VAR_2 . getParameters ( ) ) ; } } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 = METHOD_2 ( VAR_1 ) ; <START> if ( VAR_1 . size ( ) == 0 ) { <END> return ; } METHOD_3 ( VAR_1 ) ; METHOD_4 ( METHOD_5 ( VAR_1 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { int VAR_1 = VAR_2 . size ( ) ; if ( VAR_1 > 0 ) { return VAR_2 . get ( VAR_1 - 1 ) ; } else { return null ; <START> } <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . size ( ) == 0 ) { <END> return ; } for ( TYPE_2 VAR_2 : VAR_3 ) { VAR_2 . METHOD_1 ( VAR_1 ) ; } } 
public boolean METHOD_1 ( long VAR_1 ) throws InterruptedException { boolean res = true ; for ( TYPE_1 VAR_2 : VAR_3 ) { <START> res = res && VAR_2 . METHOD_1 ( VAR_1 ) ; <END> } return res ; } 
public String METHOD_1 ( String VAR_1 , String key ) { try ( TYPE_1 session = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ) { if ( ! session . VAR_2 ( key ) ) { <START> log . warn ( STRING_1 + key + STRING_2 + VAR_1 + STRING_3 ) ; <END> return key ; } TYPE_2 VAR_3 = session . VAR_4 ( key ) ; TYPE_3 VAR_5 = VAR_3 . METHOD_4 ( ) . values ( ) . iterator ( ) . next ( ) ; return ( String ) VAR_5 . METHOD_5 ( STRING_4 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , HashMap < String , String > VAR_2 , boolean VAR_3 , TYPE_2 VAR_4 ) { run ( ) ; <START> HashMap < String , String > values = METHOD_2 ( ) ; <END> for ( String VAR_5 : VAR_2 . keySet ( ) ) { String value = values . get ( VAR_2 . get ( VAR_5 ) ) ; VAR_1 . METHOD_3 ( VAR_5 , value ) ; } if ( VAR_3 ) { VAR_1 = VAR_4 . METHOD_4 ( VAR_1 ) ; } return VAR_1 ; } 
public String METHOD_1 ( ) throws TYPE_1 { if ( VAR_1 == null ) { TYPE_2 VAR_2 = null ; <START> try { <END> VAR_2 = TYPE_3 . METHOD_2 ( VAR_3 , VAR_4 ) ; TYPE_4 VAR_5 = new TYPE_4 ( ) ; VAR_1 = VAR_5 . METHOD_3 ( VAR_2 ) ; } catch ( IOException e ) { throw new TYPE_1 ( STRING_1 , e ) ; } finally { TYPE_3 . METHOD_4 ( VAR_2 ) ; } } return VAR_1 ; } 
<START> public ArrayList < TYPE_1 > METHOD_1 ( ) throws IOException { <END> if ( VAR_1 == null ) { METHOD_2 ( ) ; VAR_1 = METHOD_3 ( TYPE_2 . VAR_3 ) ; } return VAR_1 ; } 
public void METHOD_1 ( String VAR_1 ) { <START> VAR_2 = VAR_1 ; <END> } 
protected void METHOD_1 ( ) { if ( VAR_1 != null ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 != null ) { <END> String VAR_4 = VAR_2 . METHOD_3 ( ) ; VAR_5 . METHOD_4 ( VAR_4 ) ; } } } 
public TYPE_1 run ( TYPE_1 input ) { TYPE_2 VAR_1 = new TYPE_2 ( input . getId ( ) ) ; <START> TYPE_1 VAR_2 = session . VAR_3 ( VAR_1 ) ; <END> return VAR_2 ; } 
public TYPE_1 run ( TYPE_1 input ) { TYPE_2 VAR_1 = session . VAR_2 ( input . VAR_3 ( ) , null ) ; for ( TYPE_1 VAR_4 : VAR_1 ) { session . VAR_5 ( VAR_4 . METHOD_1 ( ) ) ; } session . VAR_6 ( ) ; <START> return null ; <END> } 
private void METHOD_1 ( TYPE_1 target ) throws TYPE_2 { if ( VAR_1 != null ) { target . VAR_2 ( VAR_1 , null ) ; } else if ( VAR_3 != null ) { <START> for ( Map . Entry < String , Object > entry : target . VAR_4 ( VAR_3 ) . entrySet ( ) ) { <END> target . VAR_5 ( VAR_3 , entry . getKey ( ) , null ) ; } } else { throw new TYPE_2 ( STRING_1 ) ; } } 
public boolean METHOD_1 ( TYPE_1 session , String VAR_1 ) { <START> TYPE_2 VAR_2 ; <END> if ( VAR_1 . startsWith ( STRING_1 ) ) { VAR_2 = new TYPE_3 ( VAR_1 ) ; } else { VAR_2 = new TYPE_4 ( VAR_1 ) ; } try { session . VAR_3 ( VAR_2 ) ; } catch ( TYPE_5 exception ) { return false ; } return true ; } 
public TYPE_1 run ( TYPE_1 input ) { input . VAR_1 ( VAR_2 ) ; <START> <END> session . VAR_3 ( input ) ; return input ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , int VAR_3 ) { for ( int i = 1 ; i <= VAR_3 ; i ++ ) { <START> VAR_1 . METHOD_2 ( STRING_1 , "" + i ) ; <END> VAR_1 . METHOD_3 ( TYPE_3 . VAR_5 , VAR_2 ) ; session . VAR_6 ( VAR_1 ) ; } session . VAR_7 ( ) ; } 
public void run ( ) { Map < String , List < String > > VAR_1 = METHOD_1 ( ) ; List < String > VAR_2 = new ArrayList < > ( VAR_1 . keySet ( ) ) ; <START> <END> METHOD_2 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 session , String id ) { TYPE_3 VAR_1 = new TYPE_4 ( id ) ; TYPE_5 VAR_2 = session . VAR_3 ( VAR_1 ) ; if ( VAR_2 != null ) { <START> TYPE_1 VAR_4 = VAR_2 . METHOD_2 ( TYPE_1 . class ) ; <END> if ( VAR_4 != null ) { return VAR_4 ; } } return null ; } 
public void METHOD_1 ( TYPE_1 key , boolean state ) { <START> if ( key . name == TYPE_3 . instance . VAR_2 . VAR_3 . name ) { <END> TYPE_2 VAR_4 = TYPE_3 . instance . VAR_5 ; TYPE_3 . instance . VAR_5 . VAR_6 [ 1 ] = ( ! VAR_4 . VAR_7 [ 1 ] ) ? state : VAR_4 . VAR_6 [ 1 ] ; return ; } key . VAR_6 = ( ! key . VAR_7 ) ? state : key . VAR_6 ; } 
public void METHOD_1 ( ) { <START> System . out . println ( STRING_1 + toString ( ) ) ; <END> for ( TYPE_1 n : VAR_1 ) { TYPE_3 . VAR_3 . METHOD_2 ( ( int ) n . VAR_4 . x , ( int ) n . VAR_4 . y , TYPE_2 . VAR_6 , TYPE_2 . VAR_7 , INT_1 , INT_2 ) ; } } 
protected void METHOD_1 ( ) { <START> VAR_1 += 10 ; <END> VAR_2 += 10 ; VAR_3 = VAR_4 [ VAR_5 ] ; VAR_6 = VAR_7 [ VAR_5 ] ; } 
private static boolean METHOD_1 ( final int status ) { switch ( status ) { <START> case TYPE_1 . VAR_2 : <END> case TYPE_1 . VAR_3 : return true ; default : return false ; } } 
ANNOTATION_1 public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 url = new TYPE_2 ( STRING_1 ) ; <START> TYPE_3 VAR_1 = TYPE_4 . METHOD_2 ( url , true ) ; <END> String VAR_2 = url . VAR_3 ( ) + STRING_2 + TYPE_5 . METHOD_3 ( url . VAR_4 ( ) ) + url . getPath ( ) ; assertEquals ( VAR_2 , VAR_1 . request ( ) . url ( ) . METHOD_4 ( ) ) ; } 
public String METHOD_1 ( ) { final StringBuilder VAR_1 = new StringBuilder ( ) ; new TYPE_1 ( new TYPE_2 ( ) { public void METHOD_2 ( TYPE_3 node , int VAR_2 ) { if ( node instanceof TYPE_4 ) { TYPE_4 VAR_3 = ( TYPE_4 ) node ; VAR_1 . append ( VAR_3 . METHOD_1 ( ) ) ; } } public void METHOD_3 ( TYPE_3 node , int VAR_2 ) { } } ) . METHOD_4 ( this ) ; <START> return VAR_1 . toString ( ) . trim ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_2 != null ) { <START> TYPE_3 VAR_3 = VAR_2 . METHOD_2 ( STRING_1 ) . METHOD_3 ( ) ; <END> if ( VAR_3 != null ) { VAR_3 . METHOD_4 ( STRING_2 , VAR_1 . METHOD_5 ( ) ) ; } } this . VAR_1 = VAR_1 ; VAR_4 = VAR_1 . METHOD_6 ( ) ; return this ; } 
public Builder METHOD_1 ( char VAR_1 ) { if ( VAR_1 == 0 ) throw new IllegalArgumentException ( STRING_1 ) ; if ( VAR_1 == VAR_2 ) { <START> throw new IllegalArgumentException ( STRING_2 ) ; <END> } this . VAR_1 = VAR_1 ; return this ; } 
@Override public void METHOD_1 ( Status status , TYPE_1 VAR_1 ) { Throwable error = null ; try ( TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_4 ) ) { METHOD_3 ( ) . METHOD_1 ( status , VAR_1 ) ; } catch ( Throwable e ) { <START> error = e ; <END> throw e ; } finally { TYPE_3 response = new TYPE_3 ( request , status , VAR_1 , error ) ; METHOD_4 ( response , VAR_5 . METHOD_5 ( null ) ) ; } } 
@Override public void close ( Status status , TYPE_1 VAR_1 ) { Throwable error = null ; try ( TYPE_2 VAR_2 = VAR_3 . METHOD_1 ( context ) ) { METHOD_2 ( ) . close ( status , VAR_1 ) ; } catch ( Throwable e ) { <START> error = e ; <END> throw e ; } finally { TYPE_3 response = new TYPE_3 ( request , status , VAR_1 , error ) ; METHOD_3 ( response , VAR_4 . METHOD_4 ( null ) ) ; } } 
@Override public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; <START> try { <END> METHOD_3 ( ) . METHOD_1 ( ) ; } finally { VAR_1 . close ( ) ; } } 
@Override public Throwable error ( ) { <START> if ( VAR_1 != null || request == null ) return VAR_1 ; <END> return request . VAR_2 ( ) ; } 
static String METHOD_1 ( String VAR_1 , ANNOTATION_1 String VAR_2 ) { <START> return VAR_1 + ( VAR_2 == null ? "" : ( STRING_1 + VAR_2 ) ) ; <END> } 
Builder ( TYPE_1 VAR_1 ) { this ( VAR_1 . VAR_2 ) ; <START> METHOD_1 ( VAR_1 . VAR_3 ) ; <END> METHOD_2 ( ) ; METHOD_3 ( VAR_1 . VAR_4 ) ; } 
<START> ANNOTATION_1 public final String METHOD_1 ( TYPE_1 input , ANNOTATION_1 TYPE_2 context , TYPE_3 VAR_1 ) { <END> if ( input == null ) throw new TYPE_4 ( STRING_1 ) ; if ( VAR_1 == null ) throw new TYPE_4 ( STRING_2 ) ; if ( VAR_1 == TYPE_5 . VAR_3 ) return null ; return METHOD_1 ( VAR_1 , input , context ) ; } 
<START> public TYPE_4 ( TYPE_1 VAR_2 ) { <END> super ( TYPE_2 . class , false ) ; VAR_3 = new TYPE_3 ( VAR_2 ) ; this . VAR_2 = VAR_2 ; } 
protected TYPE_2 ( Builder < ? > builder ) { <START> this . VAR_2 = ( List < TYPE_1 > ) builder . VAR_2 . METHOD_1 ( ) ; <END> } 
protected TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 , TYPE_1 VAR_2 ) { int length = VAR_3 . size ( ) ; <START> if ( length == 0 ) return VAR_2 ; <END> for ( int i = 0 ; i < length ; i ++ ) { VAR_2 = VAR_3 . get ( i ) . METHOD_1 ( VAR_1 , VAR_2 ) ; } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 context , long VAR_1 ) { <START> if ( VAR_2 . get ( ) ) return ; <END> TYPE_2 VAR_3 = VAR_4 . remove ( context ) ; if ( VAR_3 == null || VAR_2 . get ( ) ) return ; synchronized ( VAR_3 ) { VAR_3 . METHOD_1 ( VAR_1 ) ; VAR_5 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_3 . METHOD_3 ( ) ) ) ; } } 
private void METHOD_1 ( TYPE_1 record ) { TYPE_2 VAR_1 = METHOD_2 ( record ) ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) . forEach ( key - > record . VAR_3 ( ) . remove ( key ) ) ; <START> VAR_2 . METHOD_3 ( ) . METHOD_5 ( VAR_4 ) <END> . METHOD_6 ( VAR_1 . context ( ) , record ) ; } 
public < T > T trace ( String VAR_1 , String VAR_2 , TYPE_1 < T > VAR_3 ) throws RuntimeException { try { METHOD_1 ( VAR_1 , VAR_2 ) ; return VAR_3 . call ( ) ; } catch ( Exception e ) { <START> throw new RuntimeException ( e . getMessage ( ) , e ) ; <END> } finally { METHOD_2 ( ) ; } } 
public void trace ( String VAR_1 , String VAR_2 , TYPE_1 VAR_3 ) throws RuntimeException { try { METHOD_1 ( VAR_1 , VAR_2 ) ; VAR_3 . run ( ) ; } catch ( Exception e ) { <START> throw new RuntimeException ( e . getMessage ( ) , e ) ; <END> } finally { METHOD_2 ( ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 ) { synchronized ( VAR_1 ) { VAR_1 . METHOD_2 ( VAR_2 ) ; <START> METHOD_3 ( ) . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; <END> } METHOD_6 ( ) . state ( ) . METHOD_7 ( null ) ; } 
synchronized Long METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . VAR_2 ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( ) . url ( ) . uri ( ) ; <END> } 
public TYPE_1 ( ) { super ( ) ; <START> VAR_2 = true ; <END> } 
private void METHOD_1 ( ) throws IOException { <START> if ( VAR_1 ) METHOD_2 ( ) ; <END> METHOD_3 ( ) ; } 
private void METHOD_1 ( ) throws IOException { <START> if ( VAR_1 ) METHOD_2 ( ) ; <END> VAR_2 : while ( true ) { TYPE_1 n = VAR_3 . VAR_4 ; while ( true ) { n = n . VAR_5 ( METHOD_3 ( ) ) ; if ( n == null ) { continue VAR_2 ; } if ( n . VAR_6 ) { break VAR_2 ; } } } if ( ! VAR_7 || METHOD_3 ( ) ) { METHOD_4 ( ) ; } else { METHOD_5 ( ) ; } } 
private ImmutableList < TYPE_1 > METHOD_1 ( TYPE_2 < Map < String , Object > > VAR_1 ) { <START> if ( VAR_1 == null ) { <END> return ImmutableList . of ( ) ; } return TYPE_3 . from ( VAR_1 ) . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) ; } 
<START> public String METHOD_1 ( ) { <END> if ( VAR_1 == null ) { return null ; } return VAR_1 ; } 
private void METHOD_1 ( ) throws Exception { <START> start ( ) ; <END> while ( true ) { try { Thread . VAR_1 ( 5 ) ; } catch ( Exception e ) { log . info ( STRING_1 , e ) ; break ; } } METHOD_2 ( ) ; } 
public void METHOD_1 ( TYPE_1 server , TYPE_2 query , ImmutableList < TYPE_3 > results ) throws Exception { <START> TYPE_4 VAR_1 = new TYPE_4 ( logger , VAR_2 ) ; <END> VAR_3 . write ( VAR_1 , server , query , results ) ; } 
protected void METHOD_1 ( ) { System . VAR_1 ( VAR_2 ) ; System . VAR_3 ( VAR_4 ) ; <START> System . out . println ( STRING_1 ) ; <END> System . out . println ( out ) ; } 
public void close ( ) throws IOException { VAR_1 = true ; if ( VAR_2 != null ) { <START> VAR_3 . METHOD_1 ( new TYPE_1 ( ) { <END> public void run ( ) { if ( VAR_2 != null ) { try { VAR_2 . close ( ) ; } catch ( IOException e ) { logger . error ( STRING_1 , this , e ) ; } } } } ) ; } } 
public TYPE_4 ( ANNOTATION_1 TYPE_1 VAR_2 , ANNOTATION_2 TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = false ; <START> VAR_5 = TYPE_3 . METHOD_1 ( ) ; <END> } 
public TYPE_1 build ( ) throws TYPE_2 , TYPE_3 { return new TYPE_1 ( VAR_1 . build ( ) , VAR_2 , VAR_3 , host , VAR_4 , VAR_5 . build ( ) , VAR_6 , VAR_7 , VAR_8 , <START> ( VAR_9 == null ) ? true : VAR_9 , <END> null ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { try { target . VAR_1 ( ) ; <START> } catch ( TYPE_1 ex ) { <END> throw ( ex ) ; } } 
<START> private Boolean METHOD_1 ( ) throws Exception { <END> TYPE_1 VAR_1 = this . VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ; return ( null != VAR_1 ) ; } 
<START> private Boolean METHOD_1 ( ) { <END> return this . VAR_1 . METHOD_2 ( ) . equals ( this . VAR_2 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = TYPE_1 . METHOD_2 ( TYPE_2 . class ) ; <END> writer = new TYPE_3 ( VAR_1 ) ; VAR_2 = TYPE_1 . METHOD_2 ( TYPE_4 . class ) ; result = TYPE_1 . METHOD_2 ( TYPE_5 . class ) ; } 
public String METHOD_1 ( ) { <START> if ( this . VAR_1 == null ) { <END> return null ; } return this . VAR_1 ; } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 writer = METHOD_2 ( ) ; TYPE_3 query = TYPE_3 . builder ( ) . METHOD_3 ( STRING_1 ) . build ( ) ; TYPE_4 server = TYPE_4 . builder ( ) . METHOD_4 ( STRING_2 ) . METHOD_5 ( STRING_3 ) . build ( ) ; writer . VAR_1 ( server , query ) ; <START> System . out . println ( STRING_4 ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 == true ) { VAR_1 = false ; } if ( VAR_1 == false ) { VAR_1 = true ; } <START> } <END> 
public boolean METHOD_1 ( ) { if ( VAR_1 == true ) { return true ; } else { return false ; } <START> } <END> 
public TYPE_2 ( ) { super ( ) ; <START> TYPE_1 props = System . VAR_2 ( ) ; props . VAR_3 ( STRING_1 , STRING_2 ) ; <END> } 
public Optional < TYPE_1 > METHOD_1 ( String VAR_1 ) { <START> logger . trace ( STRING_1 , VAR_1 ) ; <END> return TYPE_2 . METHOD_1 ( VAR_2 , VAR_1 ) ; } 
private String METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { <START> String VAR_2 = index . VAR_3 ( VAR_1 . METHOD_3 ( ) ) ; <END> return VAR_2 ; } throw new IllegalArgumentException ( ) ; } 
private List METHOD_1 ( Collection < ? > VAR_1 ) { List VAR_2 = new ArrayList < > ( VAR_1 . size ( ) ) ; <START> Iterator < ? extends Object > iterator = VAR_1 . iterator ( ) ; <END> while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; VAR_2 . add ( o ) ; } return VAR_2 ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 props = new TYPE_1 ( ) ; TYPE_2 in = null ; <START> try { <END> in = TYPE_3 . class . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; } catch ( Exception e ) { } finally { try { props . VAR_2 ( in ) ; if ( in != null ) { in . close ( ) ; } } catch ( IOException VAR_3 ) { } } return props ; } 
<START> protected < TYPE_1 extends TYPE_2 > List < TYPE_1 > METHOD_1 ( TYPE_3 < Integer , T , TYPE_1 > VAR_1 ) { <END> List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; List < T > data = METHOD_2 ( ) ; for ( int index = 0 ; index < data . size ( ) ; index += 1 ) { VAR_2 . add ( VAR_1 . apply ( index + 1 , data . get ( index ) ) ) ; } return VAR_2 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { try { VAR_1 . METHOD_2 ( STRING_1 ) ; return true ; <START> } catch ( TYPE_2 e ) { <END> } return false ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 , IOException , TYPE_3 { TYPE_4 factory = TYPE_4 . METHOD_2 ( ) ; factory . VAR_2 ( STRING_1 , false ) ; factory . VAR_2 ( TYPE_8 . VAR_4 , true ) ; TYPE_5 VAR_5 = factory . VAR_6 ( ) ; <START> TYPE_6 VAR_7 = new TYPE_7 ( VAR_1 . METHOD_3 ( ) ) ; <END> return VAR_5 . parse ( VAR_7 ) ; } 
protected Object METHOD_1 ( String VAR_1 , List < String > VAR_2 ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { return new HashMap ( ) ; } else { try { if ( TYPE_2 . contains ( VAR_1 ) ) { return null ; <START> } <END> return VAR_3 . METHOD_3 ( VAR_1 ) . METHOD_4 ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 , e ) ; } } } 
public boolean METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_1 VAR_2 ) { <START> if ( VAR_1 . METHOD_2 ( ) . equals ( VAR_2 . METHOD_2 ( ) ) <END> && TYPE_2 . equals ( VAR_1 . METHOD_3 ( ) , VAR_2 . METHOD_3 ( ) ) && TYPE_2 . equals ( VAR_1 . METHOD_4 ( ) , VAR_2 . METHOD_4 ( ) ) ) { return false ; } else { return true ; } } 
public synchronized long METHOD_1 ( ) { TYPE_1 item = ( TYPE_1 ) VAR_1 . METHOD_2 ( ) ; <START> return ( item != null && item . VAR_2 ( ) . METHOD_3 ( ) != null ) ? item . VAR_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) - this . VAR_3 . get ( ) : - 1 ; <END> } 
public boolean equals ( Object o ) { <START> if ( this == o ) <END> return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; org . VAR_1 . VAR_2 . parser . TYPE_1 VAR_4 = ( org . VAR_1 . VAR_2 . parser . TYPE_1 ) o ; if ( VAR_5 != VAR_4 . VAR_5 ) return false ; if ( ! text . equals ( VAR_4 . text ) ) return false ; return true ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 name ) { assertNotNull ( name ) ; if ( name == this . name ) { return ( TYPE_1 ) this ; } METHOD_2 ( TYPE_3 . VAR_2 , this . name , name ) ; <START> if ( this . name != null ) <END> this . name . VAR_3 ( null ) ; this . name = name ; METHOD_3 ( name ) ; return this ; } 
public Object get ( String name ) { <START> return METHOD_1 ( ) . get ( TYPE_1 . METHOD_2 ( name ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 , Map < String , TYPE_2 > VAR_2 ) { <START> logger . info ( STRING_1 + VAR_3 . size ( ) + STRING_2 ) ; <END> METHOD_2 ( ( output , VAR_4 ) - > output . VAR_5 = ( TYPE_2 ) METHOD_3 ( METHOD_4 ( METHOD_5 ( VAR_4 ) ) ) ) ; } 
protected List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > list = null ; if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { list = VAR_1 . stream ( ) . map ( VAR_2 - > VAR_2 . METHOD_2 ( ) ) . METHOD_3 ( ) . collect ( Collectors . VAR_3 ( ) ) ; } <START> return list != null ? list : new ArrayList < > ( ) ; <END> } 
public static String METHOD_1 ( String name ) { <START> if ( VAR_1 . containsKey ( name ) ) { <END> return VAR_1 . get ( name ) ; } String VAR_2 = TYPE_1 . matcher ( name . trim ( ) ) . METHOD_2 ( STRING_1 ) ; VAR_1 . put ( name , VAR_2 ) ; return VAR_2 ; } 
public TYPE_1 ( String VAR_2 ) throws Exception { if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { <START> throw new Exception ( STRING_1 ) ; <END> } int VAR_3 = VAR_2 . METHOD_1 ( STRING_2 ) ; if ( VAR_3 >= 0 ) { this . VAR_4 = VAR_2 . substring ( 0 , VAR_3 ) ; this . VAR_5 = VAR_2 . substring ( VAR_3 + 1 ) ; } else { this . VAR_4 = VAR_6 ; this . VAR_5 = VAR_2 ; } } 
public TYPE_3 ( String VAR_2 , String VAR_3 , TYPE_1 VAR_4 ) throws Exception { this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; try { <START> this . VAR_5 = new TYPE_2 ( VAR_3 ) ; <END> } catch ( Exception e ) { throw new Exception ( STRING_1 , e ) ; } } 
protected void METHOD_1 ( ) { try { METHOD_2 ( ) ; METHOD_3 ( ) ; <START> } catch ( Exception e ) { <END> logger . error ( e . getMessage ( ) ) ; } } 
static TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( Thread . VAR_1 ( ) . METHOD_2 ( ) ) ; <END> } 
public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 ) { TYPE_1 VAR_4 = Thread . VAR_5 ( ) . METHOD_1 ( ) ; try { Thread . VAR_5 ( ) . METHOD_2 ( VAR_3 ) ; this . VAR_6 = TYPE_2 . METHOD_3 ( VAR_2 ) ; METHOD_4 ( ) ; this . VAR_7 = true ; } finally { Thread . VAR_5 ( ) . METHOD_2 ( VAR_4 ) ; } this . VAR_8 = VAR_3 ; <START> this . name += STRING_1 + VAR_2 ; <END> } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; final TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( ) ; assertEquals ( VAR_1 , VAR_2 ) ; <START> METHOD_3 ( VAR_1 , <END> VAR_2 ) ; } 
public TYPE_2 ( List < TYPE_1 > VAR_2 ) { this . VAR_2 = new ArrayList < TYPE_1 > ( ) ; <START> this . VAR_2 . addAll ( VAR_2 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = session . VAR_2 ( ) ; METHOD_2 ( VAR_1 ) ; VAR_1 . METHOD_3 ( ) ; TYPE_2 . assertThat ( VAR_3 . METHOD_4 ( VAR_4 ) ) . METHOD_5 ( VAR_4 ) . METHOD_6 ( ) ; METHOD_2 ( VAR_1 , STRING_1 ) ; METHOD_2 ( VAR_1 , STRING_1 ) ; <START> METHOD_2 ( VAR_1 , STRING_1 ) ; <END> VAR_1 . METHOD_3 ( ) ; TYPE_2 . assertThat ( VAR_3 . METHOD_4 ( VAR_4 ) ) . METHOD_5 ( VAR_4 ) . METHOD_7 ( ) ; } 
private boolean METHOD_1 ( Object VAR_1 , Object VAR_2 ) { <START> return VAR_1 != null ? VAR_1 . equals ( VAR_2 ) : VAR_2 != null ; <END> } 
public Object METHOD_1 ( TYPE_1 data ) { <START> return new Double ( data . VAR_1 / data . count ) ; <END> } 
public Object METHOD_1 ( TYPE_1 data ) { <START> return new Double ( Math . VAR_1 ( data . VAR_2 / data . count ) ) ; <END> } 
private void METHOD_1 ( long VAR_1 ) { status = Status . VAR_2 ; this . VAR_1 = VAR_1 ; VAR_3 = new TYPE_1 ( true ) ; <START> VAR_3 . METHOD_2 ( new TYPE_2 ( this ) , VAR_1 , VAR_1 ) ; <END> } 
private void METHOD_1 ( ) { LOGGER . warn ( STRING_1 ) ; for ( TYPE_1 VAR_1 : session . VAR_2 ( ) ) { LOGGER . warn ( VAR_1 . toString ( ) ) ; <START> } <END> } 
@Override protected TYPE_1 METHOD_1 ( String VAR_1 ) throws Exception { <START> TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( ) . get ( TYPE_2 . class , null ) ; <END> return VAR_2 . METHOD_3 ( VAR_1 ) ; } 
protected String METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) throws TYPE_1 { String VAR_4 = StringUtils . isEmpty ( VAR_3 ) ? TYPE_2 . METHOD_2 ( ) : VAR_3 ; <START> <END> if ( METHOD_3 ( ) != null && METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ) { return TYPE_3 . METHOD_5 ( METHOD_3 ( ) . METHOD_6 ( VAR_1 , VAR_2 ) ) ; } return VAR_2 ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( this . VAR_2 == null ) { <END> return true ; } else { for ( TYPE_1 VAR_3 : this . VAR_2 ) { if ( VAR_3 . METHOD_2 ( VAR_1 ) ) { return true ; } } return false ; } } 
public boolean METHOD_1 ( float VAR_1 ) { boolean VAR_2 = false ; for ( TYPE_1 child : VAR_3 ) { VAR_2 |= child . VAR_4 ( VAR_1 ) ; } <START> VAR_3 . METHOD_2 ( TYPE_2 . METHOD_3 ( TYPE_1 : : METHOD_4 ) ) ; <END> return VAR_2 ; } 
private TYPE_3 ( List < TYPE_1 > VAR_2 ) { <START> this . VAR_2 . addAll ( VAR_2 ) ; <END> this . VAR_2 . METHOD_1 ( TYPE_2 . METHOD_2 ( TYPE_1 : : METHOD_3 ) ) ; } 
public List < String > METHOD_1 ( ) { List < String > VAR_1 = new ArrayList < String > ( ) ; Set < String > VAR_2 = VAR_3 . METHOD_2 ( ) ; <START> List < String > VAR_4 = new ArrayList < > ( VAR_2 ) ; <END> for ( String id : VAR_4 ) { if ( METHOD_3 ( id ) ) { VAR_1 . add ( id ) ; } } return VAR_1 ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { TYPE_1 VAR_2 = ( TYPE_1 ) VAR_3 . METHOD_2 ( STRING_1 ) ; <START> TYPE_2 VAR_4 = METHOD_3 ( ) ; <END> VAR_2 . METHOD_4 ( VAR_1 . getString ( VAR_5 , VAR_4 . METHOD_5 ( ) ) ) ; } VAR_3 . METHOD_6 ( ) ; } 
public TYPE_7 ( ) { <START> VAR_2 = TYPE_1 . get ( TYPE_2 . class , TYPE_3 . METHOD_1 ( ) ) ; <END> VAR_3 = new TYPE_4 ( METHOD_2 ( ) ) ; VAR_4 = TYPE_1 . get ( TYPE_5 . class , TYPE_3 . METHOD_1 ( ) ) ; VAR_5 = new TYPE_6 ( ) ; } 
<START> private String METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { <END> StringBuilder sb = new StringBuilder ( ) ; if ( VAR_1 . METHOD_2 ( ) ) { sb . append ( STRING_1 ) . append ( VAR_1 . getProperty ( ) ) . append ( STRING_2 ) ; } else { sb . append ( VAR_1 . getProperty ( ) ) ; } sb . append ( STRING_3 ) . append ( VAR_1 . METHOD_3 ( ) ) ; return sb . toString ( ) ; } 
private TYPE_1 METHOD_1 ( Object value , boolean VAR_1 ) { TYPE_1 filter = METHOD_2 ( TYPE_2 . VAR_3 , value , VAR_1 ) ; <START> filter . VAR_4 ( VAR_5 ) ; <END> return filter ; } 
private static TYPE_1 METHOD_1 ( ) throws IOException { <START> final File VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 ) . METHOD_3 ( ) ; <END> final TYPE_3 VAR_2 = new TYPE_4 ( ) . METHOD_4 ( VAR_1 ) . METHOD_5 ( ) ; return new TYPE_1 ( VAR_1 , VAR_2 ) ; } 
public List < TYPE_1 > build ( TYPE_2 < Object > params ) { <START> final Object value = params . VAR_1 ( ) ; <END> final TYPE_1 filter = new TYPE_1 ( METHOD_1 ( ) , METHOD_2 ( VAR_2 . getType ( ) ) , value ) ; filter . VAR_3 ( VAR_4 ) ; filter . VAR_5 ( VAR_6 ) ; filter . VAR_7 ( METHOD_3 ( ) ) ; METHOD_4 ( VAR_2 , filter ) ; METHOD_5 ( VAR_2 , filter ) ; return Collections . VAR_8 ( filter ) ; } 
private static void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ) . METHOD_3 ( new Thread ( ) { @Override public void run ( ) { LOGGER . info ( STRING_1 ) ; <START> TYPE_2 . METHOD_4 ( ) ; <END> } } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , int VAR_3 ) { <START> LOGGER . debug ( STRING_1 + VAR_2 + STRING_2 + VAR_3 + STRING_3 + VAR_1 ) ; <END> } 
private String METHOD_1 ( ) { if ( METHOD_2 ( ) ) { Map < String , String > VAR_1 = METHOD_3 ( ) ; <START> String type = VAR_1 . get ( STRING_1 ) ; <END> String VAR_2 = VAR_1 . get ( STRING_2 ) ; String VAR_3 = METHOD_4 ( ) ; if ( VAR_3 . equals ( STRING_3 ) ) { return STRING_4 + VAR_2 ; } return STRING_4 + VAR_2 + STRING_5 + VAR_3 ; } return METHOD_5 ( ) . METHOD_6 ( STRING_6 , "" ) + STRING_5 + METHOD_4 ( ) ; } 
protected void METHOD_1 ( String VAR_1 , double value , String [ ] VAR_2 ) { if ( System . currentTimeMillis ( ) - this . VAR_3 > INT_1 * INT_2 ) { this . VAR_4 . METHOD_2 ( ) ; METHOD_3 ( ) ; } <START> VAR_4 . METHOD_4 ( TYPE_1 . METHOD_5 ( VAR_1 ) , value , VAR_2 ) ; <END> } 
private void METHOD_1 ( TYPE_1 e ) { String message = VAR_1 . METHOD_2 ( e ) ; if ( message == null ) { throw new IllegalArgumentException ( String . format ( STRING_1 + STRING_2 , VAR_1 . toString ( ) ) ) ; } <START> this . VAR_2 . METHOD_3 ( <END> "" , message , "" , "" , null , null , "" ) ; } 
protected TYPE_4 ( TYPE_1 VAR_2 ) { this . options = VAR_2 ; this . VAR_3 = VAR_2 . METHOD_1 ( ) ; if ( options . VAR_4 ( ) ) { this . VAR_5 = new TYPE_2 ( new TYPE_3 ( ) { @Override public void write ( int b ) throws IOException { <START> } <END> } ) ; } } 
public TYPE_1 ( Object VAR_2 , long VAR_3 , int VAR_4 ) { METHOD_1 ( VAR_4 >= VAR_5 , STRING_1 ) ; this . VAR_2 = VAR_2 ; container = 0 ; <START> VAR_6 = 0 ; <END> this . VAR_3 = VAR_3 ; VAR_7 = this . VAR_3 + VAR_4 - VAR_5 ; VAR_8 = this . VAR_3 ; } 
public int METHOD_1 ( byte [ ] input , int VAR_1 , int VAR_2 , byte [ ] output , int VAR_3 , int VAR_4 ) { int VAR_5 = METHOD_2 ( VAR_2 ) ; Arrays . VAR_6 ( table , 0 , VAR_5 , 0 ) ; long VAR_7 = VAR_8 + VAR_1 ; long VAR_9 = VAR_8 + VAR_3 ; <START> return TYPE_1 . METHOD_1 ( input , VAR_7 , VAR_2 , output , VAR_9 , VAR_4 , table , VAR_5 ) ; <END> } 
<START> public void METHOD_1 ( ) <END> { VAR_1 = true ; if ( VAR_2 . get ( ) == 0 ) METHOD_2 ( ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <START> TYPE_4 VAR_3 = <END> new TYPE_4 ( VAR_1 , new TYPE_5 ( new TYPE_6 ( ) ) , TYPE_7 . get ( ) , VAR_2 ) ; final TYPE_8 builder = TYPE_8 . METHOD_2 ( ) ; TYPE_9 VAR_4 = ( TYPE_9 ) builder ; VAR_4 . METHOD_3 ( VAR_3 ) ; return builder . build ( ) ; } 
public Set < Class < ? > > METHOD_1 ( ) { <START> if ( VAR_1 == null && parent != null ) <END> return parent . VAR_2 ( ) ; if ( VAR_3 ) { return VAR_1 ; } Set < Class < ? > > set = new HashSet < Class < ? > > ( ) ; if ( parent != null ) set . addAll ( parent . VAR_2 ( ) ) ; set . addAll ( VAR_1 ) ; return set ; } 
public static String METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_1 buf = new TYPE_1 ( VAR_1 ) ; buf . append ( CHAR_1 ) . append ( VAR_2 ) ; <START> return STRING_1 + VAR_3 . VAR_4 . TYPE_2 . METHOD_2 ( ) . METHOD_3 ( buf . toString ( ) . METHOD_4 ( TYPE_3 . VAR_6 ) ) ; <END> } 
public boolean close ( final long VAR_1 , final TimeUnit VAR_2 ) { METHOD_1 ( ) ; try { long VAR_3 = TimeUnit . VAR_4 . METHOD_2 ( VAR_1 , VAR_2 ) ; <START> Thread . VAR_5 ( VAR_3 ) ; <END> } catch ( InterruptedException e ) { VAR_6 . forEach ( VAR_7 - > { VAR_7 . METHOD_3 ( e ) ; } ) ; Thread . VAR_8 ( ) . METHOD_4 ( ) ; return false ; } return true ; } 
<START> public static String METHOD_1 ( TYPE_1 request ) { <END> return METHOD_2 ( request , TYPE_2 . VAR_2 ) ; } 
public Response METHOD_1 ( ) throws Exception { <START> TYPE_1 factory = TYPE_1 . METHOD_2 ( ) ; <END> factory . VAR_1 ( VAR_2 ) ; factory . VAR_1 ( VAR_3 ) ; return Response . VAR_4 ( STRING_1 ) . build ( ) ; } 
public boolean METHOD_1 ( TYPE_1 context ) { if ( context . VAR_1 ( ) . METHOD_2 ( ) == TYPE_4 . VAR_3 ) return false ; TYPE_2 VAR_4 = TYPE_3 . METHOD_3 ( TYPE_2 . class ) ; if ( VAR_4 == null ) { <START> System . err . println ( STRING_1 + context . VAR_1 ( ) . METHOD_2 ( ) + STRING_2 ) ; <END> return false ; } VAR_4 . METHOD_4 ( ) . put ( Context . VAR_5 , new Context ( ) ) ; return true ; } 
<START> public static void METHOD_1 ( String item ) { <END> VAR_1 . add ( item ) ; } 
public TYPE_2 ( ) { <START> this . VAR_2 = new TYPE_1 < > ( ) ; <END> } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) throws IOException { synchronized ( VAR_2 ) { if ( VAR_1 == null ) { throw new IllegalStateException ( STRING_1 ) ; <START> } <END> } VAR_3 = VAR_1 ; if ( VAR_4 == null ) { VAR_4 = VAR_5 . METHOD_2 ( ) ; } VAR_4 . METHOD_3 ( VAR_1 ) ; } 
public void VAR_1 ( TYPE_3 VAR_3 , Object VAR_4 ) { <START> VAR_3 . VAR_5 ( ) . VAR_6 ( TYPE_1 . entity ( VAR_4 == null ? null : new TYPE_2 < Object > ( VAR_4 , VAR_9 ) , VAR_10 , VAR_11 ) ) <END> } 
public static TYPE_1 < ? > METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( TYPE_4 . class . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( TYPE_4 . class ) ; <START> VAR_1 . METHOD_5 ( TYPE_5 . METHOD_6 ( <END> new TYPE_6 ( STRING_1 , STRING_2 ) , new TYPE_7 ( STRING_3 ) , new TYPE_8 ( STRING_4 ) , new TYPE_8 ( STRING_5 ) ) , STRING_6 ) ; return TYPE_3 . METHOD_7 ( VAR_1 , null , TYPE_9 . class , TYPE_10 . class , TYPE_11 . class , TYPE_12 . class ) ; } 
public static TYPE_1 < ? > METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( TYPE_4 . class . METHOD_3 ( ) + STRING_1 ) ; VAR_1 . METHOD_4 ( TYPE_4 . class . METHOD_5 ( ) , STRING_2 , STRING_3 ) ; <START> System . out . println ( VAR_1 . toString ( true ) ) ; <END> return TYPE_3 . METHOD_6 ( VAR_1 , null , TYPE_5 . class ) ; } 
<START> public Response METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> logger . info ( VAR_1 . getName ( ) ) ; String name = STRING_1 ; boolean VAR_2 = false ; String VAR_3 = new String ( name . VAR_4 ( TYPE_3 . VAR_6 ) , TYPE_3 . VAR_6 ) ; if ( VAR_3 . METHOD_2 ( VAR_1 . getName ( ) ) == 0 ) { VAR_2 = true ; } return VAR_2 ? Response . VAR_7 ( ) . build ( ) : Response . VAR_8 ( ) . build ( ) ; } 
public void filter ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { if ( TYPE_4 . VAR_4 == VAR_2 . getStatus ( ) ) { Object entity = VAR_2 . METHOD_1 ( ) ; if ( entity != null && entity instanceof String ) { <START> String VAR_5 = TYPE_3 . METHOD_2 ( ( String ) entity ) ; <END> String VAR_6 = VAR_5 . METHOD_3 ( STRING_1 , STRING_2 ) ; VAR_2 . METHOD_4 ( VAR_6 ) ; } } } 
public TYPE_2 ( String text ) { <START> super ( TYPE_1 . getInstance ( ) . METHOD_1 ( text ) ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> new TYPE_1 ( this ) . METHOD_2 ( ) ; new TYPE_2 ( new TYPE_3 ( VAR_1 ) ) ; new TYPE_2 ( new TYPE_4 ( ) , TYPE_5 . VAR_3 , false ) ; } 
public boolean METHOD_1 ( ) { VAR_1 = TYPE_1 . getInstance ( ) . METHOD_2 ( ) ; <START> return VAR_1 != null ? true : false ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 , String VAR_3 ) { <START> super ( VAR_2 , 0 , new TYPE_2 ( new TYPE_3 ( VAR_3 + STRING_1 ) ) ) ; <END> } 
default long VAR_1 ( ) { <START> return 1 ; <END> } 
public void METHOD_1 ( Class < ? > VAR_1 ) { <START> System . out . println ( STRING_1 + VAR_1 . getName ( ) ) ; <END> METHOD_2 ( VAR_1 ) ; VAR_2 . add ( VAR_1 ) ; } 
private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) <END> return false ; return TYPE_2 . METHOD_3 ( new TYPE_3 < Boolean > ( ) { @Override public Boolean run ( ) { return ! ( ( VAR_1 instanceof TYPE_4 ) && ! ( ( TYPE_4 ) VAR_1 ) . METHOD_4 ( ) ) ; } } ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) <END> return false ; boolean VAR_2 = true ; Object o = null ; try { o = TYPE_2 . METHOD_3 ( VAR_1 , STRING_1 ) ; } catch ( RuntimeException e ) { throw new TYPE_3 ( STRING_2 , e ) ; } if ( o instanceof Boolean ) { VAR_2 = ( ( Boolean ) o ) . METHOD_4 ( ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) ; log . info ( STRING_1 + VAR_1 + STRING_2 ) ; TYPE_2 . METHOD_3 ( TYPE_8 . VAR_3 ) ; TYPE_3 [ ] VAR_4 = TYPE_4 . getInstance ( ) . METHOD_4 ( ) ; <START> new TYPE_5 ( STRING_3 , STRING_4 , VAR_1 ) . METHOD_5 ( ) ; <END> TYPE_6 VAR_5 = new TYPE_6 ( VAR_4 ) ; new TYPE_7 ( VAR_5 ) ; return new TYPE_1 ( VAR_5 . METHOD_6 ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) ; METHOD_3 ( VAR_1 . METHOD_4 ( ) . isEmpty ( ) ) ; <START> TYPE_3 . METHOD_5 ( TYPE_4 . VAR_3 ) ; <END> } 
public void METHOD_1 ( ) { org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_5 . METHOD_2 ( new TYPE_1 ( ) { @Override public void run ( ) { for ( TYPE_2 VAR_6 : org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_5 . METHOD_3 ( ) . METHOD_4 ( ) ) { if ( VAR_6 . METHOD_5 ( ) . equals ( VAR_7 ) ) { VAR_6 . METHOD_6 ( ) ; break ; } } <START> new TYPE_3 ( new TYPE_4 ( VAR_7 ) ) ; <END> } } ) ; } 
public int METHOD_1 ( final String text ) { <START> return TYPE_1 . getInstance ( ) . METHOD_1 ( ( TYPE_2 ) METHOD_2 ( ) , text ) ; <END> } 
public long METHOD_1 ( ) { if ( VAR_1 == Long . VAR_2 || VAR_1 == 0 ) { return VAR_1 ; } if ( VAR_3 == 1 ) { return VAR_1 ; } if ( VAR_1 >= Long . VAR_2 / VAR_3 ) { return Long . VAR_2 ; } else { <START> return Math . VAR_4 ( VAR_1 * VAR_3 ) ; <END> } } 
public TYPE_5 ( TYPE_1 type , int count ) { if ( type == null ) { throw new TYPE_2 ( STRING_1 ) ; } if ( count < 0 ) { throw new IllegalArgumentException ( STRING_2 ) ; } this . VAR_2 = type ; this . VAR_3 = count ; <START> VAR_4 = new TYPE_3 [ ] { } ; <END> VAR_5 = new TYPE_4 ( ) ; } 
private static TYPE_1 METHOD_1 ( String name ) { TYPE_1 VAR_1 ; <START> try { <END> VAR_1 = TYPE_1 . METHOD_1 ( name ) ; } catch ( TYPE_2 e ) { VAR_1 = TYPE_1 . METHOD_1 ( STRING_1 + name ) ; } return VAR_1 ; } 
<START> public void METHOD_1 ( ) { <END> new TYPE_1 ( STRING_1 , STRING_2 ) . METHOD_2 ( ) ; new TYPE_1 ( STRING_1 , STRING_3 ) . METHOD_2 ( ) ; new TYPE_2 ( STRING_4 ) . METHOD_3 ( ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 ) { this . METHOD_2 ( ) ; this . METHOD_3 ( VAR_2 ) ; VAR_2 . METHOD_4 ( true ) ; VAR_3 . METHOD_4 ( true ) ; this . METHOD_3 ( VAR_4 ) ; this . METHOD_3 ( VAR_5 ) ; } else { this . METHOD_2 ( ) ; VAR_2 . METHOD_4 ( false ) ; VAR_3 . METHOD_4 ( false ) ; this . METHOD_3 ( VAR_4 ) ; this . METHOD_3 ( VAR_5 ) ; <START> } <END> } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_5 ( VAR_1 . METHOD_6 ( ) <START> , VAR_1 . METHOD_7 ( ) ) ; <END> } 
private void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <END> VAR_1 . METHOD_5 ( ) ; } 
public List < String > METHOD_1 ( ) throws IOException { TYPE_1 reader = new TYPE_1 ( new TYPE_2 ( VAR_1 ) ) ; List < String > VAR_2 = new ArrayList < String > ( ) ; <START> String line ; <END> while ( ( line = reader . VAR_3 ( ) ) != null ) { VAR_2 . add ( line ) ; } return VAR_2 ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 VAR_2 = new TYPE_2 ( new TYPE_3 ( VAR_1 ) ) ; TYPE_4 writer = new TYPE_4 ( ) ; <START> String line ; <END> while ( ( line = VAR_2 . METHOD_2 ( ) ) != null ) { if ( line . isEmpty ( ) ) { break ; } writer . write ( line ) ; writer . write ( CHAR_1 ) ; } return writer . toString ( ) ; } 
public String METHOD_1 ( ) { <START> String content ; <END> try { final TYPE_1 VAR_1 = TYPE_2 . class . METHOD_2 ( VAR_2 ) ; content = TYPE_3 . METHOD_3 ( VAR_1 , TYPE_3 . VAR_3 ) ; } catch ( Throwable e ) { e . VAR_4 ( ) ; throw new RuntimeException ( STRING_1 + VAR_2 + STRING_2 + e . getMessage ( ) ) ; } return content ; } 
public static List < String > METHOD_1 ( TYPE_1 in ) throws IOException { Assert . VAR_1 ( in ) ; List < String > VAR_2 = new ArrayList < String > ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( new TYPE_3 ( in ) ) ; try { <START> for ( TYPE_4 VAR_4 ; ( VAR_4 = VAR_3 . METHOD_2 ( ) ) != null ; ) { <END> VAR_2 . add ( VAR_4 . getName ( ) ) ; } return VAR_2 ; } finally { TYPE_5 . close ( VAR_3 ) ; } } 
public void METHOD_1 ( ) throws TYPE_1 { <START> TYPE_2 VAR_1 ; <END> try { VAR_1 = TYPE_3 . METHOD_2 ( user ) ; TYPE_4 . METHOD_3 ( VAR_1 ) ; assertThat ( VAR_1 . METHOD_4 ( ) ) . METHOD_5 ( ) ; VAR_1 . METHOD_6 ( ) ; METHOD_7 ( STRING_1 ) ; } catch ( TYPE_5 e ) { } } 
private TYPE_1 METHOD_1 ( String VAR_1 ) throws Exception { int VAR_2 = new TYPE_2 ( ) . METHOD_2 ( INT_1 * INT_2 ) + INT_2 ; <START> TYPE_1 VAR_3 ; <END> if ( VAR_1 == null ) { VAR_3 = new TYPE_1 ( VAR_2 ) ; } else { VAR_3 = new TYPE_1 ( VAR_2 , null , VAR_1 ) ; } VAR_3 . start ( ) ; return VAR_3 ; } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( String VAR_1 , String VAR_2 ) { <END> return new TYPE_2 ( VAR_1 , VAR_2 , this . VAR_3 ) ; } 
public List < String > METHOD_1 ( TYPE_1 channel ) throws IOException { TYPE_2 reader = new TYPE_2 ( new TYPE_3 ( METHOD_2 ( channel ) ) ) ; List < String > VAR_1 = new ArrayList < String > ( ) ; <START> String line ; <END> while ( ( line = reader . VAR_2 ( ) ) != null ) { VAR_1 . add ( line ) ; } return VAR_1 ; } 
protected void METHOD_1 ( ) throws TYPE_1 { if ( ! METHOD_2 ( ) ) { return ; } <START> if ( VAR_1 == null ) { <END> VAR_1 = METHOD_3 ( ) ; } else { VAR_1 . clear ( ) ; VAR_1 . METHOD_4 ( METHOD_3 ( ) ) ; } } 
private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( Context . VAR_2 ) ; <START> if ( VAR_1 != null ) { return VAR_1 . METHOD_4 ( ) ; } else { return false ; } <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = this ; METHOD_2 ( ) ; if ( METHOD_3 ( ) ) { VAR_3 = new TYPE_4 . TYPE_5 ( VAR_4 ) ; } TYPE_3 VAR_5 = TYPE_3 . from ( this ) ; <START> switch ( VAR_5 . METHOD_4 ( ) ) { case TYPE_3 . VAR_6 : METHOD_5 ( ) ; <END> break ; default : METHOD_6 ( ) ; } } 
<START> public boolean METHOD_1 ( ) { <END> TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_4 . TYPE_5 . METHOD_3 ( ) ) ; return ( VAR_1 . METHOD_4 ( TYPE_6 . VAR_3 , false ) ) ; } 
<START> protected boolean METHOD_1 ( ) { <END> TYPE_1 args = METHOD_2 ( ) ; return ( ( args != null ) && args . VAR_1 ( VAR_2 , false ) ) ; } 
private void METHOD_1 ( ) { final String VAR_1 = ( String ) METHOD_2 ( R . string . VAR_2 ) ; <START> if ( VAR_1 != null && VAR_1 . length ( ) > 0 ) { <END> TYPE_1 VAR_3 = new TYPE_1 ( TYPE_1 . VAR_4 , TYPE_2 . parse ( VAR_1 ) ) ; METHOD_3 ( VAR_3 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; if ( VAR_1 . METHOD_2 ( ) . equals ( VAR_2 ) && <START> VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) . equals ( STRING_1 ) ) { <END> METHOD_5 ( VAR_1 . METHOD_3 ( ) ) ; } } 
public void METHOD_1 ( View v ) { if ( v . getId ( ) == R . id . VAR_1 ) { METHOD_2 ( VAR_2 ) ; METHOD_3 ( ) ; } <START> else if ( v . getId ( ) == R . id . VAR_3 ) { <END> new TYPE_1 ( ) . execute ( ) ; } } 
protected void METHOD_1 ( int VAR_1 , int VAR_2 , TYPE_1 VAR_3 ) { if ( VAR_1 == VAR_4 && VAR_2 == VAR_5 ) { TYPE_2 VAR_6 = VAR_3 . METHOD_2 ( ) ; TYPE_3 VAR_7 = ( TYPE_3 ) VAR_6 . get ( STRING_1 ) ; TYPE_4 VAR_8 = METHOD_3 ( METHOD_4 ( ) , VAR_7 ) ; <START> VAR_9 = METHOD_5 ( VAR_8 ) ; <END> new TYPE_5 ( ) . execute ( ) ; } else if ( VAR_2 == VAR_10 ) { METHOD_6 ( VAR_10 ) ; METHOD_7 ( ) ; } } 
public long METHOD_1 ( ) { long VAR_1 = - 1 ; <START> if ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ) { <END> VAR_1 = TYPE_1 . METHOD_4 ( new Date ( ) , VAR_2 . METHOD_5 ( ) ) . METHOD_6 ( ) ; } return VAR_1 ; } 
public static boolean METHOD_1 ( Context context ) { boolean VAR_1 = true ; TYPE_1 VAR_2 = ( TYPE_1 ) context . VAR_3 ( Context . VAR_4 ) ; TYPE_2 VAR_5 = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_5 == null || ( VAR_5 != null && <END> ! VAR_5 . METHOD_3 ( ) ) ) { VAR_1 = false ; } return VAR_1 ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; TYPE_1 . v ( TAG , STRING_1 ) ; <START> if ( ( TYPE_2 . VAR_2 <= INT_1 || VAR_3 == null ) ) { <END> METHOD_2 ( ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 file = VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; try { if ( file . equals ( VAR_3 ) ) { METHOD_4 ( true ) ; } } <START> catch ( TYPE_3 e ) { <END> TYPE_4 . e ( TAG , STRING_1 , e ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { if ( ! METHOD_2 ( ) ) { return ; } <START> boolean VAR_3 ; <END> if ( VAR_2 ) { VAR_3 = true ; } else { VAR_3 = false ; } ( ( TYPE_2 ) METHOD_3 ( ) ) . METHOD_4 ( ) . METHOD_5 ( VAR_4 , VAR_3 ) ; ; VAR_1 . METHOD_6 ( null ) ; VAR_1 . METHOD_7 ( ) ; VAR_1 . METHOD_6 ( VAR_5 ) ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( VAR_2 . containsKey ( VAR_1 ) ) { <END> return VAR_2 . get ( VAR_1 ) ; } return null ; } 
public boolean METHOD_1 ( TYPE_1 item ) { super . METHOD_1 ( item ) ; switch ( item . VAR_1 ( ) ) { case VAR_2 . R . id . VAR_3 : METHOD_2 ( ) ; <START> break ; <END> default : TYPE_2 . METHOD_3 ( TAG , STRING_1 ) ; return false ; } return true ; } 
<START> public static void METHOD_1 ( String key , boolean value , Context context ) { <END> TYPE_2 . TYPE_3 VAR_1 = METHOD_2 ( context . VAR_2 ( ) ) . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( key , value ) ; VAR_1 . apply ( ) ; } 
protected TYPE_1 run ( TYPE_2 client ) { TYPE_3 VAR_1 = new TYPE_3 ( ) ; TYPE_1 result = VAR_1 . execute ( client ) ; <START> if ( result . VAR_2 ( ) ) { <END> TYPE_4 VAR_3 = ( TYPE_4 ) result . VAR_4 ( ) . get ( 0 ) ; METHOD_1 ( ) . METHOD_2 ( VAR_3 ) ; } return result ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 ) ; METHOD_3 ( ) ; METHOD_4 ( VAR_1 , false ) ; TYPE_2 VAR_2 = VAR_3 . METHOD_5 ( R . id . VAR_4 ) ; METHOD_6 ( ) ; <START> if ( TYPE_3 . METHOD_7 ( VAR_1 , METHOD_8 ( ) ) ) { <END> METHOD_9 ( ) ; } else { METHOD_10 ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 ) ; METHOD_3 ( ) ; METHOD_4 ( VAR_1 , false ) ; <START> TYPE_2 VAR_2 = VAR_3 . METHOD_5 ( R . id . VAR_4 ) ; <END> METHOD_6 ( ) ; METHOD_7 ( VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( ) ; VAR_2 . METHOD_3 ( R . VAR_1 . VAR_3 , VAR_1 ) ; VAR_4 = VAR_1 ; <START> TYPE_3 VAR_5 = VAR_4 . METHOD_4 ( R . id . VAR_6 ) ; <END> METHOD_5 ( ) ; return true ; } 
public TYPE_4 ( TYPE_1 VAR_2 ) { VAR_3 = VAR_2 . METHOD_1 ( ) ; VAR_4 = new TYPE_2 < TYPE_3 > ( ( TYPE_3 ) VAR_2 ) ; <START> VAR_5 = VAR_2 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 file ) { TYPE_3 VAR_2 = null ; synchronized ( VAR_3 ) { VAR_2 = VAR_3 . remove ( METHOD_2 ( VAR_1 , file ) ) ; } if ( VAR_2 != null ) { <START> VAR_4 . METHOD_1 ( ) ; <END> } } 
private void METHOD_1 ( TYPE_1 client ) { METHOD_2 ( ) ; METHOD_3 ( VAR_1 , client ) ; METHOD_3 ( VAR_2 , client ) ; <START> METHOD_4 ( VAR_3 , client ) ; <END> } 
private static String METHOD_1 ( String VAR_1 ) { <START> String VAR_2 = VAR_1 . METHOD_2 ( ) . substring ( VAR_1 . METHOD_3 ( STRING_1 ) + 1 ) ; <END> return VAR_2 ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; TYPE_1 . e ( TAG , STRING_1 ) ; <START> METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( View VAR_1 ) { <START> VAR_2 . METHOD_2 ( VAR_1 ) ; <END> VAR_2 . METHOD_3 ( ) ; } 
public void METHOD_1 ( TYPE_1 view , int VAR_1 , String description , String VAR_2 ) { TYPE_2 . e ( TAG , STRING_1 + VAR_2 + STRING_2 + VAR_1 + STRING_3 + description ) ; if ( ! VAR_2 . equals ( VAR_3 ) ) { view . VAR_4 ( ) ; VAR_3 = VAR_2 ; <START> } else { <END> VAR_3 = null ; } } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 , true ) ; assertThat ( VAR_1 . VAR_2 ) . METHOD_3 ( ) ; assertThat ( VAR_1 . VAR_3 ) . METHOD_3 ( ) ; assertThat ( VAR_1 . VAR_4 ) . METHOD_4 ( ) ; <START> assertThat ( VAR_1 . VAR_4 ) . METHOD_4 ( ) ; <END> if ( VAR_1 . VAR_5 != null ) METHOD_2 ( VAR_1 . VAR_5 , true ) ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 < TYPE_2 > call = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( null , <START> STRING_1 <END> ) ; TYPE_2 page = call . execute ( ) . METHOD_5 ( ) ; assertThat ( page ) . METHOD_6 ( ) ; assertThat ( page . results ) . METHOD_7 ( ) ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , byte [ ] content ) <END> { return METHOD_2 ( METHOD_3 ( String . format ( STRING_1 , VAR_1 , VAR_2 , STRING_2 ) ) , TYPE_2 . of ( ) , content , TYPE_1 . class ) ; } 
public static TYPE_1 METHOD_1 ( ) { TYPE_1 p = new TYPE_1 ( ) ; File file = new File ( System . getProperty ( STRING_1 , STRING_2 ) , String . format ( STRING_3 ) ) ; if ( ! file . exists ( ) ) { <START> logger . debug ( String . format ( STRING_4 , file ) ) ; <END> return p ; } return METHOD_1 ( file ) ; } 
<START> public static < T > void METHOD_1 ( Optional < T > VAR_1 , String VAR_2 ) <END> { if ( ! VAR_1 . isPresent ( ) ) { throw new TYPE_1 ( TYPE_1 . TYPE_2 . VAR_4 , VAR_2 ) ; } } 
private static String METHOD_1 ( String VAR_1 ) <START> { <END> return METHOD_2 ( VAR_1 , STRING_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 builder = new TYPE_3 ( TYPE_4 . METHOD_2 ( ) ) ; builder . VAR_2 ( ) ; boolean VAR_3 ; boolean VAR_4 = METHOD_3 ( builder , STRING_1 , VAR_1 . getType ( ) , VAR_5 . getType ( ) ) ; <START> VAR_3 = VAR_4 ; <END> builder . VAR_6 ( ) ; if ( VAR_3 ) { Assert . VAR_7 ( VAR_8 + builder . toString ( ) ) ; } return this ; } 
public void METHOD_1 ( ) { VAR_1 . start ( VAR_2 ) <START> . METHOD_2 ( VAR_2 , STRING_1 , VAR_3 ) <END> . METHOD_3 ( VAR_4 , ctx - > this . VAR_5 = new TYPE_1 ( ctx . VAR_6 ( ) ) , VAR_7 - > this . VAR_8 = VAR_7 ) . METHOD_3 ( VAR_9 , ctx - > this . VAR_10 = new TYPE_2 ( ctx . VAR_6 ( ) ) , VAR_7 - > this . VAR_11 = VAR_7 ) . METHOD_1 ( ) ; METHOD_4 ( ) ; } 
void METHOD_1 ( ) { try ( TYPE_1 < RuntimeException > VAR_1 = new TYPE_1 < > ( ) ) { VAR_1 . METHOD_2 ( TYPE_2 : : close , VAR_2 ) ; VAR_1 . METHOD_2 ( TYPE_3 : : close , VAR_3 ) ; <START> VAR_1 . METHOD_2 ( TYPE_4 : : close , VAR_4 ) ; <END> } } 
public void METHOD_1 ( TYPE_1 context ) { try { String VAR_1 = context . VAR_2 ( ) . toString ( ) ; Throwable VAR_3 = context . VAR_4 ( ) ; } catch ( Throwable t ) { <START> } <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! getClass ( ) . equals ( VAR_1 . getClass ( ) ) ) { return false ; } TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; return TYPE_3 . equals ( VAR_3 , VAR_2 . VAR_3 ) && <START> TYPE_3 . equals ( VAR_4 , VAR_2 . VAR_4 ) && <END> TYPE_3 . equals ( VAR_5 , VAR_2 . VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( Date value , TYPE_2 context ) { if ( value == null ) { return null ; } <START> return value instanceof TYPE_4 . TYPE_5 . Date ? TYPE_1 . METHOD_2 ( value . VAR_1 ( ) ) : value . VAR_2 ( ) ; <END> } 
<START> void METHOD_1 ( ) { <END> METHOD_2 ( ) ; METHOD_3 ( ) . METHOD_4 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = new TYPE_2 ( VAR_2 . toString ( ) ) ; <END> return new TYPE_1 ( VAR_3 , new TYPE_3 ( VAR_1 ) , VAR_4 == TYPE_4 . VAR_6 ) ; } 
<START> public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { <END> if ( TYPE_3 . METHOD_2 ( VAR_1 ) ) { return ; } try { TYPE_4 VAR_3 = new TYPE_4 ( TYPE_8 . VAR_5 ) . METHOD_3 ( TYPE_9 . VAR_7 ) ; TYPE_5 VAR_8 = new TYPE_5 ( VAR_1 , INT_1 , INT_2 ) ; TYPE_6 VAR_9 = new TYPE_6 ( VAR_8 , VAR_3 ) ; VAR_9 . close ( ) ; } catch ( TYPE_7 VAR_10 ) { log . VAR_11 ( VAR_1 . toString ( ) ) ; } } 
<START> public Integer METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 < ? , TYPE_2 > METHOD_1 ( ) { <START> return new TYPE_3 ( TYPE_2 . class , VAR_1 ) ; <END> } 
<START> public void METHOD_1 ( T VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
<START> public static TYPE_1 METHOD_1 ( String value ) { <END> TYPE_2 VAR_1 = TYPE_2 . VAR_2 ; try { return TYPE_1 . parse ( value ) ; } catch ( TYPE_3 e ) { throw log . VAR_3 ( TYPE_1 . class , value , VAR_1 , e ) ; } } 
<START> public TYPE_1 < ? > METHOD_1 ( String VAR_1 ) { <END> if ( TYPE_2 . isEmpty ( VAR_1 ) ) { VAR_1 = METHOD_2 ( ) ; } return VAR_2 . METHOD_3 ( VAR_1 , this : : METHOD_4 ) ; } 
public TYPE_1 < Object > METHOD_1 ( String VAR_1 ) { <START> return field ( VAR_1 , Object . VAR_2 ) ; <END> } 
public Optional < TYPE_1 < Double > > METHOD_1 ( ) { return Optional . of ( new TYPE_1 < > ( <START> FLOAT_1 , FLOAT_2 , FLOAT_3 <END> ) ) ; } 
public Integer METHOD_1 ( TYPE_1 value ) { if ( value == null ) { return null ; } <START> return INT_1 * value . VAR_1 ( ) + value . VAR_2 ( ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 < ? > VAR_3 , TYPE_3 type ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . type = type ; VAR_2 . METHOD_1 ( ) . add ( this ) ; <START> VAR_3 . METHOD_1 ( ) . add ( this ) ; <END> } 
<START> public long METHOD_1 ( ) { <END> try { return VAR_1 . METHOD_2 ( ) ; } catch ( TYPE_1 | TYPE_2 e ) { throw new IllegalStateException ( e ) ; } catch ( TYPE_3 e ) { throw new IllegalArgumentException ( e ) ; } catch ( TYPE_4 VAR_2 ) { throw METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; } } 
protected TYPE_1 METHOD_1 ( TYPE_2 context ) { Builder builder = new TYPE_3 . Builder ( ) ; <START> values . forEach ( value - > builder . add ( METHOD_2 ( value ) , TYPE_4 . VAR_2 ) ) ; <END> TYPE_3 query = builder . build ( ) ; return query ; } 
public Object get ( Object VAR_1 ) { try { return VAR_2 . METHOD_1 ( VAR_1 ) ; } catch ( TYPE_1 e ) { throw e ; } catch ( Throwable e ) { if ( e instanceof InterruptedException ) { Thread . VAR_3 ( ) . METHOD_2 ( ) ; } <START> throw log . VAR_4 ( VAR_5 . getName ( ) , VAR_1 . toString ( ) , e ) ; <END> } } 
public TYPE_1 METHOD_1 ( String name , TYPE_1 VAR_1 ) { <START> return new TYPE_2 ( VAR_1 , name ) ; <END> } 
public TYPE_1 build ( ) { if ( VAR_1 . isEmpty ( ) ) { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } TYPE_3 VAR_2 ; if ( VAR_1 . size ( ) == 1 ) { VAR_2 = VAR_3 != null ? VAR_3 : VAR_4 ; } else { VAR_2 = TYPE_4 . METHOD_1 ( VAR_1 ) ; } return new TYPE_1 ( VAR_3 , VAR_4 , VAR_2 ) ; } 
public boolean METHOD_1 ( TYPE_1 < ? > VAR_1 ) { return VAR_2 . METHOD_2 ( VAR_1 . VAR_2 ) && TYPE_2 . equals ( VAR_3 , VAR_1 . VAR_3 ) && VAR_4 . METHOD_2 ( VAR_1 . VAR_4 ) && TYPE_2 . equals ( VAR_5 , VAR_1 . VAR_5 ) <START> && TYPE_2 . equals ( VAR_6 , VAR_1 . VAR_6 ) ; <END> } 
<START> protected void METHOD_1 ( ) throws Exception { <END> METHOD_2 ( METHOD_3 ( ) , METHOD_4 ( ) , METHOD_5 ( ) ) ; VAR_1 = getClass ( ) ; } 
public static < T > T METHOD_1 ( Class < T > VAR_1 , Class < ? > VAR_2 , String VAR_3 ) { METHOD_2 ( VAR_2 , VAR_3 ) ; <START> final TYPE_1 < ? > VAR_4 = METHOD_3 ( VAR_2 , VAR_3 ) ; <END> final Object instance = METHOD_4 ( VAR_2 , VAR_3 ) ; return METHOD_5 ( VAR_1 , instance , VAR_2 , VAR_3 ) ; } 
synchronized void METHOD_1 ( ) { VAR_1 -- ; if ( VAR_1 == 0 ) { if ( status != TYPE_1 . VAR_3 ) { METHOD_2 ( ) ; } <START> METHOD_3 ( ) ; <END> } else if ( status != TYPE_1 . VAR_3 ) { METHOD_2 ( ) ; } } 
public TYPE_1 ( Class < ? > VAR_2 , String VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( String name , TYPE_1 builder ) { <START> builder . field ( STRING_1 , TYPE_2 . VAR_2 ) ; <END> } 
public void METHOD_1 ( String name , TYPE_1 builder ) { TYPE_2 field = builder . field ( name , TYPE_5 . VAR_2 ) ; if ( VAR_3 != null ) { <START> field . VAR_4 ( TYPE_3 . class ) <END> . METHOD_2 ( TYPE_4 . VAR_6 ) ; } } 
<START> static String METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_1 . METHOD_2 ( ) == null ? VAR_1 . METHOD_3 ( ) : VAR_1 . METHOD_2 ( ) + STRING_1 + VAR_1 . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; <START> TYPE_2 a = new TYPE_2 ( ) ; <END> a . value = STRING_1 ; METHOD_4 ( ) . METHOD_5 ( a ) ; VAR_1 . commit ( ) ; METHOD_4 ( ) . close ( ) ; this . VAR_2 = TYPE_3 . METHOD_6 ( METHOD_2 ( ) ) ; } 
private String METHOD_1 ( Class < ? > VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 VAR_3 = VAR_2 . METHOD_2 ( ) ; if ( VAR_3 . is ( TYPE_3 . class ) ) { return VAR_3 . METHOD_3 ( TYPE_3 . class ) . getName ( ) ; } <START> LOG . VAR_4 ( VAR_1 , VAR_2 . METHOD_4 ( ) , VAR_3 . toString ( ) ) ; <END> return null ; } 
public static boolean METHOD_1 ( Class < ? extends TYPE_1 > type ) { if ( TYPE_2 == null ) { <START> TYPE_3 . METHOD_2 ( ) ; <END> try { if ( TYPE_2 == null ) { Set < Class < ? extends TYPE_1 > > set = new HashSet < > ( ) ; set . add ( TYPE_4 . class ) ; TYPE_2 = Collections . VAR_1 ( set ) ; } } finally { TYPE_3 . METHOD_3 ( ) ; } } return TYPE_2 . contains ( type ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) { <START> if ( TYPE_3 . isEmpty ( VAR_1 ) || STRING_1 . equals ( VAR_1 . trim ( ) ) ) { <END> return new TYPE_4 ( ) ; } else { Class < ? > VAR_3 = VAR_2 . METHOD_2 ( VAR_1 ) ; return TYPE_5 . METHOD_3 ( TYPE_1 . class , VAR_3 , STRING_2 ) ; } } 
private void METHOD_1 ( ) { <START> if ( TYPE_1 . METHOD_2 ( VAR_1 ) != null ) { <END> TYPE_1 . METHOD_3 ( VAR_1 ) ; } } 
public void METHOD_1 ( Collection < File > VAR_1 ) { <START> VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> try { METHOD_4 ( ) ; METHOD_5 ( server , METHOD_6 ( VAR_1 ) ) ; } finally { VAR_2 . METHOD_2 ( ) . METHOD_7 ( ) ; } } 
public < T > T METHOD_1 ( final TYPE_1 < T > query ) { TYPE_2 options = new TYPE_2 ( ) <START> . remove ( true ) <END> . METHOD_2 ( false ) . METHOD_3 ( false ) ; return METHOD_1 ( query , options ) ; } 
public T get ( final TYPE_1 options ) { final TYPE_2 < T , T > it = METHOD_1 ( options . VAR_1 ( ) . METHOD_2 ( 1 ) ) ; T t = ( it . hasNext ( ) ) ? it . next ( ) : null ; <START> it . close ( ) ; <END> return t ; } 
<START> TYPE_3 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final String VAR_4 ) { <END> this ( VAR_2 , VAR_2 . METHOD_1 ( ) , VAR_3 , VAR_4 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return db != null ? db : VAR_1 . METHOD_1 ( VAR_2 . getName ( ) ) ; <END> } 
public static TYPE_1 METHOD_1 ( final Object value ) { for ( TYPE_1 VAR_1 : values ( ) ) { <START> if ( VAR_1 . type . equals ( value ) || VAR_1 . name ( ) . equals ( value ) ) { <END> return VAR_1 ; } } throw new IllegalArgumentException ( STRING_1 + value ) ; } 
<START> List < TYPE_1 > METHOD_1 ( final Class < TYPE_2 > VAR_1 ) { <END> return VAR_2 . get ( VAR_1 ) ; } 
public TYPE_1 read ( ) throws IOException { METHOD_1 ( ) . info ( STRING_1 ) ; TYPE_1 model = new TYPE_1 ( ) ; model . VAR_1 ( TYPE_1 . TYPE_5 . VAR_3 ) ; <START> TYPE_2 < String > VAR_4 = new TYPE_3 ( in ) . METHOD_2 ( ) ; <END> VAR_4 . filter ( this : : METHOD_3 ) . map ( this : : METHOD_4 ) . filter ( TYPE_4 : : METHOD_5 ) . forEach ( model : : add ) ; return model ; } 
public TYPE_1 < String > METHOD_1 ( ) { return TYPE_2 . METHOD_2 ( VAR_1 , new TYPE_3 < TYPE_4 , String > ( ) { @Override ANNOTATION_1 <START> public String apply ( TYPE_4 VAR_2 ) <END> { return VAR_2 . METHOD_3 ( ) ; } } ) ; } 
public static String METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { switch ( VAR_1 ) { case VAR_2 : return VAR_3 ; case VAR_4 : return VAR_5 ; case VAR_6 : return VAR_7 ; default : <START> case VAR_8 : <END> return VAR_9 ; } } 
public TYPE_3 ( TYPE_1 out ) { this . out = out ; VAR_2 . METHOD_1 ( ) . METHOD_2 ( TYPE_4 . TYPE_5 . VAR_5 , true ) ; VAR_6 = VAR_2 . writer ( new TYPE_2 ( ) ) ; try { <START> out . VAR_7 ( STRING_1 ) ; <END> } catch ( IOException e ) { } } 
public boolean filter ( String VAR_1 , String VAR_2 ) { if ( VAR_3 != null ) { for ( TYPE_1 VAR_4 : VAR_3 ) { <START> if ( VAR_4 . matcher ( VAR_2 ) . METHOD_1 ( ) ) { <END> return true ; } } } return false ; } 
<START> private String METHOD_1 ( TYPE_1 VAR_1 , Object VAR_2 ) { <END> if ( VAR_1 . METHOD_2 ( ) ) { TYPE_2 < Object > VAR_3 = TYPE_2 . create ( VAR_2 , VAR_4 ) ; Object version = VAR_3 . getProperty ( VAR_1 . METHOD_3 ( ) ) ; try { return STRING_1 + VAR_5 . METHOD_4 ( version ) + STRING_1 ; } catch ( TYPE_3 e ) { LOG . error ( STRING_2 , e ) ; } } return null ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; String VAR_3 = VAR_1 . toString ( ) ; System . out . println ( STRING_2 + VAR_3 ) ; <START> assertThat ( METHOD_3 ( VAR_3 ) ) . METHOD_4 ( METHOD_3 ( TYPE_2 . toString ( <END> TYPE_2 . METHOD_5 ( STRING_3 ) , TYPE_3 . VAR_5 ) ) ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> return ( ) - > TYPE_2 . this . METHOD_2 ( ) . METHOD_3 ( ) ; <END> } 
private TYPE_1 build ( final TYPE_2 VAR_1 , final String field ) throws IOException { TYPE_3 iterator = new TYPE_3 ( new TYPE_4 ( VAR_1 , field ) . METHOD_1 ( ) , VAR_1 , field , METHOD_2 ( field ) ) ; TYPE_1 VAR_2 = METHOD_3 ( ) ; VAR_2 . build ( iterator ) ; <START> if ( iterator . VAR_3 > 0 ) { <END> double VAR_4 = ( double ) iterator . VAR_3 / VAR_2 . METHOD_4 ( ) ; VAR_5 . put ( field , VAR_4 ) ; } return VAR_2 ; } 
static String METHOD_1 ( Collection < TYPE_5 . TYPE_6 > VAR_1 ) { return VAR_1 . stream ( ) . map ( TYPE_5 . TYPE_6 : : METHOD_2 ) . <START> max ( VAR_2 ) . <END> map ( TYPE_3 . TYPE_4 : : toString ) . METHOD_3 ( null ) ; } 
public void close ( ) { if ( VAR_1 == null ) { return ; } try { run = false ; synchronized ( VAR_2 ) { VAR_2 . METHOD_1 ( ) ; } <START> VAR_1 . METHOD_2 ( 0 ) ; <END> } catch ( InterruptedException e ) { logger . log ( Level . VAR_3 , STRING_1 ) ; } } 
public TYPE_1 METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 == null ) { <START> VAR_2 = new TYPE_1 ( METHOD_4 ( ) , METHOD_5 ( ) ) ; <END> } return VAR_2 ; } finally { VAR_1 . METHOD_2 ( ) . METHOD_6 ( ) ; } } 
private TYPE_7 ( ) { configuration = new TYPE_1 ( ) ; VAR_2 = new TYPE_2 ( ) ; <START> VAR_3 = new TYPE_3 ( ) ; <END> VAR_4 = new TYPE_4 ( ) ; VAR_5 = TYPE_5 . METHOD_1 ( ( ) - > new TYPE_6 ( this ) ) ; VAR_6 = TYPE_5 . METHOD_1 ( ( ) - > METHOD_2 ( ) ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 , final TYPE_3 VAR_3 ) throws IOException { if ( VAR_1 != null ) { <START> VAR_2 . METHOD_2 ( TYPE_4 . METHOD_3 ( VAR_1 . toString ( ) ) ) ; <END> } else { VAR_2 . METHOD_4 ( ) ; } } 
private static String METHOD_1 ( List < String > VAR_1 ) { <START> String [ ] VAR_2 = new String [ VAR_1 . size ( ) ] ; <END> return METHOD_1 ( VAR_1 . METHOD_2 ( VAR_2 ) ) ; } 
public static String METHOD_1 ( String path ) { TYPE_1 url ; try { url = new TYPE_1 ( path ) ; } catch ( TYPE_2 e ) { return path ; } if ( url . VAR_1 ( ) != null ) { return url . toString ( ) . METHOD_2 ( url . VAR_1 ( ) , VAR_2 ) ; } else { <START> return url . toString ( ) ; <END> } } 
public Map < String , TYPE_1 > METHOD_1 ( ) { Map < String , TYPE_1 > VAR_1 = ( Map < String , TYPE_1 > ) METHOD_2 ( STRING_1 ) ; <START> return VAR_1 ; <END> } 
public static void METHOD_1 ( ) throws Exception { VAR_1 = new TYPE_1 ( ) ; VAR_1 . create ( TYPE_2 . class . METHOD_2 ( STRING_1 ) ) ; TYPE_3 VAR_2 = TYPE_3 . getInstance ( ) ; <START> VAR_2 . METHOD_3 ( true ) ; <END> VAR_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 ; <END> } 
public void METHOD_1 ( String value ) { <START> VAR_1 = value ; <END> } 
<START> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> String VAR_2 = VAR_1 . METHOD_2 ( ) ; switch ( VAR_2 ) { case TYPE_3 . VAR_4 : return TYPE_4 . VAR_6 ; case TYPE_3 . VAR_7 : case TYPE_3 . VAR_8 : return TYPE_6 . VAR_6 ; case TYPE_3 . VAR_10 : return TYPE_5 . VAR_6 ; default : LOGGER . log ( Level . VAR_12 , STRING_1 , VAR_2 ) ; return TYPE_4 . VAR_6 ; } } 
public void METHOD_1 ( Map < String , Object > parameters ) { super . METHOD_1 ( parameters ) ; if ( ( VAR_1 = ( String ) parameters . get ( VAR_2 ) ) == null ) { throw new TYPE_1 ( STRING_1 + VAR_2 + STRING_2 ) ; } if ( ! METHOD_2 ( VAR_1 ) ) { throw new TYPE_1 ( STRING_3 + VAR_1 + STRING_4 ) ; } <START> VAR_3 = TYPE_2 . METHOD_3 ( STRING_5 ) ; <END> LOGGER . log ( Level . VAR_4 , STRING_6 , VAR_1 ) ; } 
public void METHOD_1 ( ) { TYPE_1 instance = TYPE_1 . getInstance ( ) ; String page = STRING_1 ; METHOD_2 ( instance . VAR_1 ( ) ) ; <START> instance . VAR_2 ( page . substring ( 5 ) ) ; <END> assertEquals ( page . substring ( 5 ) , instance . VAR_1 ( ) ) ; } 
<START> TYPE_1 ( String name , String VAR_1 , long VAR_2 , int size , List < TYPE_1 > VAR_3 ) { <END> this . name = name ; this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; this . size = size ; this . VAR_3 = VAR_3 ; } 
<START> private synchronized boolean METHOD_1 ( TYPE_1 entity , TYPE_2 < TYPE_3 > VAR_1 ) { <END> VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; try { return VAR_3 . METHOD_4 ( entity , VAR_1 ) ; } finally { VAR_2 . METHOD_2 ( ) . METHOD_5 ( ) ; } } 
public void METHOD_1 ( TYPE_1 req , String VAR_1 ) { TYPE_2 val = VAR_2 . get ( VAR_1 ) ; if ( val == null ) { <START> val = new TYPE_2 ( 0 ) ; <END> } val . VAR_3 ( ) ; VAR_2 . put ( VAR_1 , val ) ; } 
public static TYPE_1 METHOD_1 ( String name ) { TYPE_2 VAR_1 = TYPE_2 . getInstance ( ) ; if ( VAR_1 . METHOD_2 ( ) ) { for ( TYPE_1 VAR_2 : VAR_1 . METHOD_3 ( ) ) { <START> if ( name . equals ( VAR_2 . getName ( ) ) ) { <END> return ( VAR_2 ) ; } } } return null ; } 
<START> public HashSet < TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public HashSet < TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 . get ( ) . METHOD_1 ( ) ; } 
public boolean METHOD_1 ( ) { <START> Set < String > VAR_1 = METHOD_2 ( ) . keySet ( ) ; <END> return ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) ; } 
public void METHOD_1 ( Map < String , TYPE_1 > VAR_1 ) { <START> this . VAR_1 = ( HashMap < String , TYPE_1 > ) VAR_1 ; <END> } 
<START> public void METHOD_1 ( File file ) throws IOException , TYPE_1 { <END> METHOD_2 ( TYPE_2 . read ( file ) ) ; } 
public byte [ ] apply ( TYPE_1 VAR_1 ) throws IOException { <START> if ( METHOD_1 ( STRING_1 ) ) { <END> VAR_1 . METHOD_2 ( this , true ) ; } else { VAR_1 . METHOD_2 ( this , false ) ; } return null ; } 
public void METHOD_1 ( String VAR_1 ) { try { byte [ ] VAR_2 = TYPE_1 . METHOD_2 ( TYPE_2 . get ( VAR_1 ) ) ; this . text = new String ( VAR_2 ) ; } catch ( IOException ex ) { System . err . println ( STRING_1 + VAR_1 + STRING_2 + ex ) ; <START> System . VAR_3 ( 1 ) ; <END> } } 
public static boolean METHOD_1 ( TYPE_1 project , String path ) { TYPE_2 VAR_1 = TYPE_2 . getInstance ( ) ; String VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( path . startsWith ( VAR_2 ) ) { <START> if ( VAR_1 . METHOD_3 ( ) ) { <END> String VAR_3 = path . substring ( VAR_2 . length ( ) ) ; if ( project != null && project . equals ( TYPE_1 . METHOD_4 ( VAR_3 ) ) ) { return true ; } } else { return true ; } } return false ; } 
public void METHOD_1 ( final List < String > VAR_1 ) { <START> this . VAR_1 = VAR_1 != null ? TYPE_1 . METHOD_2 ( VAR_1 ) : null ; <END> } 
public Set < String > METHOD_1 ( ) { <START> return VAR_1 != null ? new TYPE_1 < > ( VAR_1 ) : null ; <END> } 
public void METHOD_1 ( final Set < String > VAR_1 ) { <START> this . VAR_1 = VAR_1 != null ? new TYPE_1 < > ( VAR_1 ) : null ; <END> } 
private static TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_3 . VAR_3 , false ) ; VAR_1 . METHOD_2 ( TYPE_6 . VAR_5 , false ) ; <START> VAR_1 . METHOD_2 ( TYPE_6 . VAR_6 , true ) ; <END> VAR_1 . METHOD_3 ( TYPE_4 . TYPE_5 . VAR_9 ) ; VAR_1 . METHOD_4 ( new TYPE_2 ( ) ) ; return VAR_1 ; } 
static public TYPE_1 METHOD_1 ( String token ) { TYPE_2 VAR_1 = new TYPE_2 ( ) . METHOD_2 ( token ) ; return new TYPE_1 . Builder ( VAR_2 , VAR_3 , VAR_1 ) . METHOD_3 ( new TYPE_3 ( ) { @Override public void METHOD_4 ( TYPE_4 VAR_4 ) throws IOException { VAR_1 . METHOD_4 ( VAR_4 ) ; <START> VAR_4 . METHOD_5 ( INT_1 * INT_2 ) ; <END> VAR_4 . METHOD_6 ( INT_1 * INT_2 ) ; } } ) . METHOD_7 ( VAR_5 ) . build ( ) ; } 
static public TYPE_1 METHOD_1 ( String s ) { if ( s . VAR_1 ( STRING_1 ) ) { TYPE_2 VAR_2 = TYPE_2 . parse ( s ) ; return TYPE_1 . METHOD_2 ( VAR_2 , TYPE_3 . METHOD_3 ( ) ) ; <START> } else <END> return TYPE_1 . parse ( s , TYPE_4 . VAR_4 ) ; } 
private static boolean METHOD_1 ( final String value ) { List < String > VAR_1 = METHOD_2 ( value ) ; if ( ! VAR_1 . isEmpty ( ) ) { try { TYPE_1 TYPE_2 = TYPE_1 . METHOD_3 ( STRING_1 ) ; VAR_1 . forEach ( TYPE_2 : : METHOD_4 ) ; <START> } catch ( Exception e ) { <END> return false ; } } return true ; } 
private static int METHOD_1 ( String string ) { int index = string . VAR_1 ( CHAR_1 ) ; <START> if ( index == - 1 ) { <END> return string . VAR_1 ( CHAR_2 ) ; } return index ; } 
protected String METHOD_1 ( final String name ) { final String VAR_1 = Optional . VAR_2 ( name ) . METHOD_2 ( "" ) ; try { final TYPE_1 VAR_3 = TYPE_2 . METHOD_3 ( VAR_1 ) ; if ( VAR_3 != null ) { return METHOD_4 ( VAR_1 , VAR_3 ) ; } <START> } catch ( Exception e ) { <END> LOGGER . VAR_4 ( STRING_1 + VAR_1 + STRING_2 ) ; } return METHOD_5 ( VAR_1 ) ; } 
public void METHOD_1 ( String value , boolean VAR_1 ) { String VAR_2 = VAR_3 ; VAR_3 = value ; <START> if ( VAR_3 . equals ( STRING_1 ) ) { <END> view . VAR_4 ( ) ; } else { view . VAR_5 ( VAR_3 ) ; } if ( VAR_1 ) { TYPE_1 . METHOD_2 ( this , VAR_2 , value ) ; } } 
<START> protected String METHOD_1 ( final String value ) { <END> return METHOD_1 ( VAR_1 , value ) ; } 
<START> protected String METHOD_1 ( final String value ) { <END> if ( value == null || value . isEmpty ( ) || VAR_1 == null ) { return null ; } String VAR_2 ; if ( ! VAR_3 ) { VAR_2 = value . VAR_4 ( ) ; } else { VAR_2 = value ; } if ( VAR_1 . contains ( VAR_2 ) ) { return VAR_5 ; } else { return null ; } } 
<START> public void METHOD_1 ( TYPE_1 container ) { <END> this . container = container ; } 
<START> public String getName ( ) { <END> if ( StringUtils . isEmpty ( name ) ) { this . name = METHOD_1 ( ) ; } return this . name ; } 
<START> public Optional < TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { METHOD_2 ( ) ; VAR_1 . METHOD_1 ( ) ; <START> if ( VAR_2 ) { <END> VAR_2 = false ; METHOD_3 ( ) ; } return this ; } 
public static TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { if ( TYPE_3 . METHOD_2 ( VAR_1 ) ) { return null ; } else if ( StringUtils . isEmpty ( VAR_1 . METHOD_3 ( ) . getValue ( ) ) ) { return null ; <START> } <END> return TYPE_4 . METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = METHOD_2 ( TYPE_1 . class ) ; <END> final TYPE_2 VAR_2 = METHOD_3 ( new TYPE_2 ( builder , VAR_3 , VAR_1 ) ) ; final TYPE_3 VAR_4 = METHOD_2 ( TYPE_3 . class ) ; METHOD_4 ( ) . when ( VAR_2 ) . METHOD_5 ( METHOD_6 ( ) ) ; METHOD_7 ( VAR_4 ) . when ( VAR_2 ) . METHOD_8 ( ) ; VAR_2 . METHOD_9 ( VAR_5 ) ; METHOD_10 ( VAR_2 ) . METHOD_11 ( METHOD_6 ( ) ) ; } 
public static TYPE_3 . TYPE_4 < List < String > , Object > METHOD_1 ( List < String > VAR_1 , TYPE_2 VAR_2 ) { return VAR_3 - > { List < String > VAR_4 = new ArrayList < > ( VAR_1 ) ; <START> for ( String type : VAR_3 ) { <END> String VAR_5 = METHOD_2 ( type ) ; METHOD_3 ( ) . put ( VAR_5 , type ) ; VAR_4 . add ( VAR_5 ) ; } VAR_2 . METHOD_4 ( VAR_4 ) ; return null ; } ; } 
public boolean equals ( final Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof TYPE_1 ) ) { return false ; } final TYPE_1 that = ( TYPE_1 ) o ; if ( ! context . equals ( that . context ) ) { return false ; } <START> if ( ! VAR_1 == that . VAR_1 ) { <END> return false ; } return path . equals ( that . path ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 , final List < TYPE_1 > VAR_2 ) { Integer VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> for ( final TYPE_3 element : VAR_2 ) { VAR_3 ++ ; TYPE_2 . METHOD_3 ( element , VAR_3 ) ; <END> } } 
<START> public void METHOD_1 ( ) { <END> final String VAR_1 = STRING_1 ; final TYPE_1 VAR_2 = METHOD_2 ( TYPE_1 . class ) ; final Optional < TYPE_1 > type = Optional . of ( VAR_2 ) ; METHOD_3 ( type ) . when ( VAR_3 ) . METHOD_4 ( VAR_1 ) ; final TYPE_1 VAR_4 = VAR_3 . METHOD_5 ( VAR_1 ) ; assertEquals ( VAR_2 , VAR_4 ) ; } 
public void METHOD_1 ( ) { <START> assertTrue ( VAR_1 . METHOD_2 ( null ) . isEmpty ( ) ) ; <END> } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; <START> VAR_2 . METHOD_3 ( false ) ; <END> METHOD_4 ( VAR_1 ) . when ( VAR_2 ) . METHOD_5 ( ) ; VAR_2 . METHOD_6 ( ) ; METHOD_7 ( VAR_3 ) . remove ( VAR_1 ) ; } 
private static TYPE_4 . TYPE_5 METHOD_1 ( final TYPE_2 target ) { TYPE_4 . TYPE_5 VAR_1 = target . VAR_2 ( ) == null ? new TYPE_4 . TYPE_5 ( ) : target . VAR_2 ( ) ; if ( ! TYPE_3 . METHOD_2 ( VAR_1 ) && TYPE_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) { <START> VAR_1 . METHOD_4 ( new ArrayList < > ( ) ) ; <END> } return VAR_1 ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return TYPE_1 . create ( VAR_1 ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> VAR_1 = new TYPE_1 ( VAR_2 ) { @Override public Object METHOD_2 ( final String VAR_3 ) { return VAR_4 ; } } ; VAR_1 . METHOD_1 ( VAR_5 ) ; METHOD_3 ( VAR_5 ) . METHOD_4 ( VAR_6 . METHOD_5 ( ) ) ; } 
<START> public void METHOD_1 ( ) throws <END> Exception { VAR_1 = METHOD_2 ( new TYPE_1 ( VAR_2 , STRING_1 , VAR_3 , VAR_4 ) { @Override TYPE_2 METHOD_3 ( ) { return VAR_5 ; } } ) ; } 
public void METHOD_1 ( ) { <START> boolean VAR_1 = false ; <END> view . VAR_2 ( VAR_1 ) ; METHOD_2 ( VAR_3 ) . METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( final String VAR_1 ) { <START> final boolean VAR_2 = TYPE_1 . equals ( VAR_1 , VAR_3 ) ; <END> final Optional < TYPE_2 < T > > result ; if ( VAR_2 ) { result = METHOD_2 ( VAR_1 ) ; } else { result = METHOD_3 ( VAR_1 ) ; } VAR_4 = result . VAR_5 ( VAR_4 ) ; VAR_3 = VAR_1 ; METHOD_4 ( ) ; } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } <START> if ( o == null || getClass ( ) != o . getClass ( ) ) { <END> return false ; } TYPE_1 that = ( TYPE_1 ) o ; return TYPE_2 . equals ( value , that . value ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> VAR_2 . METHOD_2 ( new TYPE_2 ( ) ) ; <END> if ( ! TYPE_3 . METHOD_3 ( METHOD_4 ( ) ) ) { METHOD_4 ( ) . METHOD_5 ( VAR_3 ) ; } } 
public void METHOD_1 ( ) { TYPE_1 a = new TYPE_1 ( new TYPE_2 ( ) , new TYPE_3 ( VAR_1 ) ) ; <START> Assert . assertTrue ( a . VAR_2 ( ) . getValue ( ) . equals ( VAR_1 ) ) ; <END> } 
private Object [ ] METHOD_1 ( List < ? > VAR_1 ) { <START> return VAR_1 . stream ( ) . METHOD_1 ( Object [ ] : : new ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 metadata , TYPE_3 input ) throws IOException { TYPE_4 < TYPE_1 > VAR_1 = METHOD_2 ( TYPE_5 . builder ( ) . metadata ( metadata ) . input ( input ) . METHOD_3 ( TYPE_5 . TYPE_6 . VAR_3 ) . build ( ) ) ; <START> return VAR_1 . METHOD_4 ( ) . get ( ) ; <END> } 
public static < T extends TYPE_1 > TYPE_2 < T > METHOD_1 ( ) { return TYPE_2 . of ( o - > Optional . VAR_1 ( o . getName ( ) ) <START> . METHOD_2 ( ( ) - > o . getId ( ) ) , <END> VAR_2 - > VAR_2 . getClass ( ) . METHOD_3 ( ) ) ; } 
<START> private TYPE_1 METHOD_1 ( String id ) { <END> return VAR_1 . METHOD_2 ( id ) . map ( TYPE_3 . TYPE_4 : : METHOD_3 ) . METHOD_4 ( null ) ; } 
String METHOD_1 ( final TYPE_1 VAR_1 ) { <START> TYPE_2 metadata = VAR_1 . METHOD_2 ( ) ; <END> final Optional < Path > path = Optional . VAR_2 ( metadata . getPath ( ) ) ; return path . map ( Path : : METHOD_1 ) . METHOD_3 ( VAR_3 . format ( TYPE_3 ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_4 VAR_5 = METHOD_4 ( VAR_1 , VAR_6 , VAR_7 , VAR_8 ) ; METHOD_5 ( VAR_5 . METHOD_6 ( ) , VAR_9 , VAR_9 ) ; <START> METHOD_7 ( VAR_5 . METHOD_8 ( ) , VAR_9 , VAR_10 , "" ) ; <END> METHOD_9 ( VAR_5 . METHOD_10 ( ) , VAR_9 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_4 VAR_5 = METHOD_4 ( VAR_1 , VAR_6 , VAR_7 , VAR_8 ) ; METHOD_5 ( VAR_5 . METHOD_6 ( ) , VAR_9 , VAR_9 ) ; <START> METHOD_7 ( VAR_5 . METHOD_8 ( ) , VAR_10 , "" ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_4 VAR_5 = METHOD_4 ( VAR_1 , VAR_6 , VAR_7 , VAR_8 ) ; METHOD_5 ( VAR_5 . METHOD_6 ( ) , VAR_9 , VAR_9 ) ; METHOD_7 ( VAR_5 . METHOD_8 ( ) , VAR_10 , VAR_11 , VAR_12 , VAR_13 , <START> "" ) ; <END> } 
public Collection < TYPE_1 > METHOD_1 ( final String VAR_1 , final Object VAR_2 ) { <START> final TYPE_2 VAR_3 = o - > METHOD_2 ( VAR_1 ) && METHOD_3 ( VAR_1 ) ; <END> final TYPE_1 VAR_4 = new TYPE_1 ( STRING_1 , VAR_3 ) ; return Collections . VAR_5 ( VAR_4 ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> final TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( child ) ; when ( parent . VAR_2 ( ) ) . METHOD_4 ( Collections . VAR_3 ( VAR_1 ) ) ; assertEquals ( 0 , TYPE_2 . METHOD_5 ( parent , child ) ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> METHOD_2 ( ) ; assertTrue ( TYPE_1 . METHOD_3 ( child ) ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> final TYPE_1 < TYPE_2 > VAR_1 = TYPE_3 . METHOD_2 ( ) ; final TYPE_2 VAR_2 = METHOD_3 ( TYPE_2 . class ) ; when ( VAR_2 . METHOD_4 ( ) ) . METHOD_5 ( METHOD_3 ( TYPE_4 . class ) ) ; assertTrue ( VAR_1 . METHOD_6 ( VAR_2 ) ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> String id = TYPE_1 . METHOD_2 ( ) . toString ( ) ; TYPE_2 VAR_1 = VAR_2 . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( id ) ; TYPE_4 . VAR_4 . of ( VAR_1 ) . set ( Boolean . VAR_5 ) ; VAR_6 = new TYPE_3 ( VAR_1 , VAR_7 . METHOD_5 ( ) , VAR_7 ) ; METHOD_6 ( VAR_6 . METHOD_7 ( ) ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> METHOD_2 ( TYPE_1 . class , TYPE_2 . class , false ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> final TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_3 , METHOD_5 ( 1 ) ) . METHOD_6 ( ) ; METHOD_4 ( VAR_3 , METHOD_5 ( 1 ) ) . METHOD_7 ( METHOD_8 ( VAR_1 ) , METHOD_9 ( TYPE_3 . TYPE_4 . class ) ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> VAR_1 = new TYPE_1 ( STRING_1 , STRING_2 , VAR_2 , STRING_3 , STRING_4 , VAR_3 ) ; } 
default void VAR_1 ( final TYPE_1 error ) { <START> warn ( STRING_1 ) ; <END> warn ( error . getMessage ( ) ) ; } 
public void METHOD_1 ( ) { when ( VAR_1 . getId ( ) ) . METHOD_2 ( VAR_2 . getClass ( ) . getName ( ) ) ; <START> boolean VAR_3 = VAR_4 . METHOD_3 ( VAR_1 , context ) ; <END> assertTrue ( VAR_3 ) ; } 
public void METHOD_1 ( ) { when ( VAR_1 . getId ( ) ) . METHOD_2 ( STRING_1 ) ; <START> boolean VAR_2 = VAR_3 . METHOD_3 ( VAR_1 , context ) ; <END> METHOD_4 ( VAR_2 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_4 VAR_5 = METHOD_4 ( VAR_1 , VAR_6 , TYPE_4 . class ) ; METHOD_5 ( VAR_5 . METHOD_6 ( ) , VAR_7 , VAR_7 ) ; METHOD_7 ( VAR_5 . METHOD_8 ( ) , VAR_8 , VAR_9 , VAR_10 , VAR_11 , <START> "" ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_4 VAR_5 = METHOD_4 ( VAR_1 , VAR_6 , METHOD_5 ( ) ) ; METHOD_6 ( VAR_5 . METHOD_7 ( ) , VAR_7 , VAR_7 ) ; <START> METHOD_8 ( VAR_5 . METHOD_9 ( ) , VAR_7 , VAR_8 , "" ) ; <END> METHOD_10 ( VAR_5 . METHOD_11 ( ) , VAR_7 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_4 VAR_5 = METHOD_4 ( VAR_1 , VAR_6 , TYPE_4 . class ) ; METHOD_5 ( VAR_5 . METHOD_6 ( ) , VAR_7 , VAR_7 ) ; <START> METHOD_7 ( VAR_5 . METHOD_8 ( ) , VAR_7 , VAR_8 , "" ) ; <END> METHOD_9 ( VAR_5 . METHOD_10 ( ) , VAR_7 ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> final String VAR_1 = STRING_1 ; final String VAR_2 = STRING_2 ; TYPE_1 < TYPE_2 , TYPE_3 > VAR_3 = METHOD_2 ( VAR_4 , VAR_5 ) ; METHOD_3 ( VAR_3 , VAR_6 ) ; TYPE_4 VAR_7 = METHOD_4 ( VAR_3 , VAR_8 , TYPE_4 . class ) ; METHOD_5 ( VAR_7 . METHOD_6 ( ) , VAR_1 , VAR_2 ) ; METHOD_7 ( VAR_7 . METHOD_8 ( ) , VAR_9 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return this . item ; <END> } 
private List < TYPE_1 > METHOD_1 ( final List < TYPE_1 > VAR_1 , final String VAR_2 ) { return VAR_1 . stream ( ) <START> . METHOD_2 ( VAR_3 - > METHOD_3 ( VAR_3 , VAR_2 ) ) <END> . collect ( Collectors . VAR_4 ( ) ) ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 ) { <START> final String VAR_3 = VAR_2 + STRING_1 + VAR_1 . getName ( ) ; <END> final List < TYPE_1 > VAR_4 = VAR_1 . METHOD_2 ( ) ; if ( VAR_1 . METHOD_3 ( ) != null && ! METHOD_4 ( VAR_1 . METHOD_3 ( ) ) ) { VAR_1 . METHOD_5 ( METHOD_6 ( VAR_1 . METHOD_3 ( ) , VAR_2 ) ) ; } VAR_1 . METHOD_7 ( VAR_3 ) ; METHOD_8 ( VAR_4 , VAR_2 ) ; } 
<START> METHOD_1 ( final String description ) { <END> if ( description == null ) { return new TYPE_1 ( "" ) ; } else { return new TYPE_1 ( description ) ; } } 
public void METHOD_1 ( TYPE_1 < ? extends View , ? > node ) { Object VAR_1 = node . VAR_2 ( ) . METHOD_2 ( ) ; METHOD_3 ( METHOD_4 ( node ) ) ; <START> if ( VAR_1 instanceof TYPE_2 || <END> VAR_1 instanceof TYPE_3 || VAR_1 instanceof TYPE_4 ) { VAR_3 . METHOD_5 ( true ) ; } } 
public static TYPE_1 < View , TYPE_2 > METHOD_1 ( final TYPE_1 < ? extends View , ? > node ) { return ( TYPE_1 < View , TYPE_2 > ) node . VAR_1 ( ) . stream ( ) . filter ( TYPE_3 : : METHOD_2 ) . map ( TYPE_2 : : METHOD_3 ) . METHOD_4 ( ) <START> . METHOD_5 ( null ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( new TYPE_1 ( STRING_1 ) ) ; <END> VAR_2 . METHOD_2 ( new TYPE_1 ( STRING_1 ) ) ; assertEquals ( VAR_1 , VAR_2 ) ; } 
void METHOD_1 ( final ANNOTATION_1 TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( METHOD_3 ( ) . METHOD_2 ( ) . equals ( VAR_2 ) ) { <START> METHOD_4 ( STRING_1 , <END> VAR_1 ) ; if ( null != VAR_1 . METHOD_5 ( ) ) { VAR_3 . METHOD_6 ( VAR_1 . METHOD_5 ( ) ) ; } METHOD_7 ( ) ; } } 
<START> void METHOD_1 ( ) { <END> VAR_1 . VAR_2 = this : : METHOD_2 ; VAR_1 . VAR_3 = this : : METHOD_3 ; VAR_1 . VAR_4 = this : : METHOD_4 ; } 
public static < TYPE_1 > Collection < TYPE_2 < TYPE_1 > > METHOD_1 ( TYPE_3 VAR_1 , Path VAR_2 , Collection < String > VAR_3 , TYPE_4 < TYPE_5 , TYPE_1 > VAR_4 ) { <START> return METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 - > true ) ; <END> } 
<START> String METHOD_1 ( final String VAR_1 , <END> final String VAR_2 ) { final TYPE_1 value = new TYPE_1 ( ) ; value . VAR_3 ( VAR_1 ) ; value . VAR_4 ( VAR_2 ) ; return METHOD_1 ( value ) ; } 
<START> String METHOD_1 ( final String VAR_1 ) { <END> final TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; return METHOD_1 ( VAR_2 ) ; } 
public static boolean METHOD_1 ( Class < ? > type , Object instance ) { <START> return instance . getClass ( ) . METHOD_2 ( type ) ; <END> } 
String METHOD_1 ( final String VAR_1 ) { if ( StringUtils . isEmpty ( VAR_1 ) ) { return "" ; } final String VAR_2 = METHOD_2 ( VAR_1 ) ; try { <START> final TYPE_4 . TYPE_5 . Date VAR_3 = TYPE_2 . parse ( VAR_2 ) ; <END> return TYPE_3 . format ( VAR_3 ) ; } catch ( final IllegalArgumentException exception ) { return "" ; } } 
<START> private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) { <END> when ( VAR_5 . METHOD_2 ( METHOD_3 ( Class . VAR_6 ) ) ) . METHOD_4 ( VAR_2 ) ; when ( VAR_5 . METHOD_5 ( METHOD_3 ( Class . VAR_6 ) ) ) . METHOD_4 ( VAR_1 ) ; when ( VAR_5 . METHOD_6 ( METHOD_3 ( Class . VAR_6 ) ) ) . METHOD_4 ( VAR_3 ) ; when ( VAR_5 . METHOD_7 ( METHOD_3 ( Class . VAR_6 ) ) ) . METHOD_4 ( VAR_4 ) ; } 
<START> public void METHOD_1 ( ) { <END> final TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; METHOD_3 ( ) . when ( VAR_2 ) . METHOD_4 ( ) ; final TYPE_2 VAR_3 = METHOD_2 ( TYPE_2 . class ) ; METHOD_5 ( VAR_3 ) . when ( VAR_1 ) . METHOD_6 ( ) ; VAR_2 . METHOD_7 ( VAR_1 ) ; final TYPE_2 VAR_4 = VAR_2 . METHOD_6 ( ) ; assertEquals ( VAR_3 , VAR_4 ) ; } 
public TYPE_4 ( final TYPE_1 VAR_2 , final TYPE_2 [ ] VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; VAR_4 = TYPE_3 . of ( METHOD_1 ( VAR_2 ) ) . map ( TYPE_2 : : METHOD_2 ) . METHOD_3 ( TYPE_2 [ ] : : new ) ; <START> ; <END> } 
public void METHOD_1 ( ) { <START> this . VAR_1 = METHOD_2 ( new TYPE_1 ( ) ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> VAR_1 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; METHOD_3 ( ) . when ( VAR_1 ) . METHOD_4 ( METHOD_5 ( ) ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; <START> METHOD_6 ( VAR_1 ) . METHOD_7 ( ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> final TYPE_1 key = new TYPE_1 ( TYPE_2 . TYPE_4 . VAR_3 . METHOD_2 ( ) , TYPE_3 . VAR_5 , TYPE_2 . TYPE_4 . VAR_3 . METHOD_3 ( ) ) ; when ( VAR_6 . getId ( ) ) . METHOD_4 ( VAR_7 ) ; when ( VAR_6 . METHOD_5 ( ) ) . METHOD_4 ( VAR_8 ) ; when ( VAR_6 . METHOD_6 ( ) ) . METHOD_4 ( VAR_9 ) ; when ( VAR_8 . METHOD_7 ( key , "" ) ) . METHOD_4 ( VAR_10 ) ; } 
void METHOD_1 ( final String type , final String value , final TYPE_1 VAR_1 ) { this . VAR_2 = value ; <START> if ( ! TYPE_2 . METHOD_2 ( value ) && ! value . isEmpty ( ) && VAR_1 == null ) { <END> this . VAR_1 = METHOD_3 ( value ) ; } else { this . VAR_1 = VAR_1 ; } METHOD_4 ( type , value , VAR_1 ) ; } 
void METHOD_1 ( final TYPE_1 event ) { final String VAR_1 = event . target . value ; if ( ! isEmpty ( VAR_1 ) ) { <START> TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; <END> METHOD_3 ( VAR_2 ) ; VAR_3 . METHOD_4 ( VAR_2 ) ; } } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( VAR_2 ) ; when ( VAR_3 . METHOD_4 ( ) ) . METHOD_3 ( new TYPE_1 < > ( METHOD_5 ( Object . VAR_4 ) , VAR_5 ) ) ; <START> ; <END> } 
<START> private String METHOD_1 ( ) throws TYPE_1 { <END> int index = METHOD_2 ( ) ; if ( index < 0 || VAR_1 . METHOD_3 ( index ) != CHAR_1 ) { throw new TYPE_1 ( METHOD_4 ( VAR_2 , VAR_3 ) , VAR_4 ) ; } METHOD_5 ( index + 1 ) ; return STRING_1 ; } 
<START> private String METHOD_1 ( ) throws TYPE_1 { <END> int index = METHOD_2 ( ) ; if ( index < 0 || VAR_1 . METHOD_3 ( index ) != CHAR_1 ) { throw new TYPE_1 ( METHOD_4 ( VAR_2 ) , VAR_3 ) ; } METHOD_5 ( index + 1 ) ; return STRING_1 ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> for ( String VAR_1 : VAR_2 ) { METHOD_2 ( VAR_1 , VAR_3 ) ; } } 
<START> TYPE_1 METHOD_1 ( String name , String type ) { <END> TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; when ( VAR_1 . getName ( ) ) . METHOD_3 ( name ) ; when ( VAR_1 . getType ( ) ) . METHOD_3 ( type ) ; return VAR_1 ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; TYPE_1 . View VAR_2 = METHOD_2 ( TYPE_1 . View . class ) ; TYPE_2 element = METHOD_2 ( TYPE_2 . class ) ; when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_2 ) ; when ( VAR_2 . METHOD_5 ( ) ) . METHOD_4 ( element ) ; return VAR_1 ; } 
public void METHOD_1 ( ANNOTATION_1 final TYPE_1 VAR_1 ) { <START> if ( METHOD_2 ( ) && METHOD_3 ( VAR_1 ) ) { <END> VAR_2 . METHOD_4 ( ) . filter ( VAR_3 - > VAR_3 . equals ( VAR_1 . METHOD_5 ( ) ) ) . METHOD_6 ( VAR_3 - > METHOD_7 ( ) ) ; } } 
<START> public void METHOD_1 ( ) throws Exception { <END> VAR_1 = METHOD_2 ( new TYPE_1 < > ( VAR_2 , VAR_3 ) ) ; VAR_4 = new TYPE_2 ( VAR_5 , VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 = METHOD_2 ( new TYPE_1 < TYPE_2 > ( VAR_2 , VAR_3 ) ) ; <END> VAR_4 = new TYPE_3 ( VAR_5 , VAR_1 ) ; } 
public void METHOD_1 ( String id ) { context . VAR_1 ( ) ; HashMap < String , String > map = new HashMap < > ( ) ; <START> Optional . VAR_2 ( id ) . METHOD_2 ( node - > map . put ( VAR_3 , id ) ) ; <END> context . VAR_4 ( map ) ; } 
public TYPE_3 ( List < TYPE_1 > VAR_2 , TYPE_2 VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = Collections . VAR_4 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( 0 , 0 ) ; <START> METHOD_3 ( VAR_2 ) . METHOD_2 ( METHOD_4 ( 0 ) , METHOD_4 ( 0 ) ) ; <END> } 
public Optional < ? > getProperty ( T VAR_1 , String VAR_2 ) { return TYPE_1 . METHOD_1 ( VAR_1 . getClass ( ) ) . stream ( ) <START> . filter ( f - > TYPE_2 . equals ( VAR_2 , f . getName ( ) ) ) <END> . map ( field - > TYPE_3 . METHOD_2 ( ( ) - > field . get ( VAR_1 ) , null ) ) . METHOD_3 ( ) ; } 
private Optional < String > METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( TYPE_2 . METHOD_3 ( VAR_1 ) ) { return Optional . empty ( ) ; } final TYPE_3 VAR_2 = VAR_1 . METHOD_4 ( ) ; if ( TYPE_2 . METHOD_3 ( VAR_2 ) ) { return Optional . empty ( ) ; } return Optional . of ( VAR_2 . METHOD_5 ( ) ) ; <START> } <END> 
public TYPE_11 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final TYPE_3 < TYPE_4 , TYPE_5 > VAR_4 , final TYPE_6 < TYPE_7 > TYPE_8 , final TYPE_9 VAR_5 , final TYPE_10 VAR_6 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; <START> this . TYPE_8 = ( ) - > TYPE_8 . get ( ) ; <END> this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; when ( VAR_2 . METHOD_2 ( ) ) . METHOD_3 ( VAR_3 ) ; when ( VAR_4 . METHOD_4 ( ) ) . METHOD_3 ( VAR_5 ) ; when ( VAR_5 . METHOD_5 ( ) ) . METHOD_3 ( VAR_2 ) ; when ( VAR_5 . METHOD_6 ( ) ) . METHOD_3 ( VAR_6 ) ; when ( VAR_5 . METHOD_7 ( ) ) . METHOD_3 ( VAR_1 ) ; <START> this . VAR_7 = new TYPE_2 ( VAR_4 , VAR_8 ) ; <END> } 
<START> public void METHOD_1 ( final boolean VAR_1 ) { <END> this . VAR_2 = VAR_1 ; } 
<START> public double METHOD_1 ( ) { <END> return VAR_1 ; } 
TYPE_1 METHOD_1 ( final String VAR_1 , final List < TYPE_2 > VAR_2 , final TYPE_3 < TYPE_2 , String > VAR_3 ) { final TYPE_1 VAR_4 = METHOD_2 ( ) ; VAR_4 . VAR_5 = VAR_1 ; VAR_2 . stream ( ) <START> . METHOD_3 ( VAR_6 ) <END> . forEach ( VAR_7 - > { final TYPE_4 VAR_8 = METHOD_4 ( VAR_7 , VAR_3 ) ; VAR_4 . METHOD_5 ( VAR_8 ) ; } ) ; return VAR_4 ; } 
<START> private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <END> final String VAR_2 = VAR_1 . METHOD_2 ( ) != null ? VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) : null ; final String VAR_3 = VAR_1 . METHOD_4 ( ) != null ? VAR_1 . METHOD_4 ( ) . METHOD_3 ( ) : null ; return ! TYPE_2 . equals ( VAR_2 , VAR_3 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 , TYPE_4 > VAR_1 , String id ) { TYPE_5 < ? extends TYPE_6 , ? > node = METHOD_2 ( VAR_1 , id ) ; <START> return TYPE_1 . class . METHOD_3 ( node . VAR_2 ( ) . METHOD_4 ( ) ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return new ArrayList < > ( VAR_1 . values ( ) ) ; <END> } 
<START> public static String METHOD_1 ( TYPE_1 p ) { <END> String name = p . getName ( ) ; return name == null ? p . getId ( ) : name ; } 
<START> public TYPE_2 ( Path VAR_2 , TYPE_1 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( final String VAR_1 , final String VAR_2 ) { METHOD_2 ( ) . METHOD_3 ( VAR_3 . format ( VAR_1 ) ) ; METHOD_2 ( ) . METHOD_4 ( VAR_3 . format ( VAR_2 ) ) ; <START> METHOD_5 ( ) ; <END> } 
private static void write ( String VAR_1 , String content ) throws IOException { <START> TYPE_1 writer = new TYPE_1 ( new TYPE_2 ( VAR_1 ) ) ; <END> writer . write ( content ) ; writer . close ( ) ; } 
public TYPE_1 ( final Boolean VAR_2 , final List < String > VAR_3 , final Path VAR_4 , <START> final String VAR_5 ) { <END> this . VAR_2 = VAR_2 ; if ( VAR_3 != null ) { this . VAR_3 = new ArrayList < > ( VAR_3 ) ; } else { this . VAR_3 = Collections . VAR_6 ( ) ; } this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; } 
public static void METHOD_1 ( ) { <START> VAR_1 = System . getProperty ( STRING_1 ) ; <END> VAR_2 = System . getProperty ( STRING_2 ) ; System . VAR_3 ( STRING_1 , STRING_3 ) ; System . VAR_3 ( STRING_2 , STRING_3 ) ; } 
private < T > List < T > METHOD_1 ( List < T > list ) { if ( list == null ) { return Collections . VAR_1 ( ) ; <START> } else { <END> return new ArrayList < > ( list ) ; } } 
private Path METHOD_1 ( String VAR_1 ) { if ( VAR_1 != null ) { return TYPE_1 . get ( STRING_1 + VAR_1 ) ; } <START> else { <END> return null ; } } 
<START> public void METHOD_1 ( final TYPE_1 VAR_1 ) { <END> if ( this . VAR_2 . contains ( VAR_1 ) ) { this . VAR_2 . update ( VAR_1 ) ; } else { this . VAR_2 . add ( VAR_1 ) ; } } 
private TYPE_5 . TYPE_6 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 < String , TYPE_4 > VAR_2 = VAR_3 - > VAR_3 . equals ( VAR_4 ) ? VAR_5 : null ; <START> ; <END> return new TYPE_5 . TYPE_6 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 < TYPE_2 > execute ( TYPE_3 context ) { TYPE_4 . METHOD_1 ( VAR_1 , context , VAR_2 ) ; <START> TYPE_4 . METHOD_2 ( VAR_1 , context ) ; <END> TYPE_4 . METHOD_3 ( VAR_1 , context ) ; return METHOD_4 ( ) ; } 
public static List < TYPE_1 > METHOD_1 ( List < String > VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( String VAR_3 : VAR_1 ) { try { VAR_2 . add ( new TYPE_1 ( VAR_3 ) ) ; } catch ( TYPE_2 e ) { logger . error ( e . getMessage ( ) ) ; } } <START> if ( VAR_2 . size ( ) > 0 ) { <END> return VAR_2 ; } else { return Collections . VAR_4 ( ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_2 ( ) ; TYPE_3 < TYPE_4 > VAR_2 = VAR_1 . build ( VAR_3 , VAR_4 . toString ( ) , Boolean . VAR_5 ) ; TYPE_4 res = VAR_2 . get ( ) ; assertThat ( res . VAR_6 ( ) ) . METHOD_2 ( ) ; assertThat ( res . VAR_7 ( ) . isEmpty ( ) ) . METHOD_3 ( ) ; <START> assertThat ( res . VAR_7 ( ) . size ( ) ) . METHOD_4 ( 0 ) ; <END> } 
public TYPE_1 ( final Boolean VAR_2 , final List < String > VAR_3 , final Path VAR_4 , final List < String > VAR_5 , final List < String > VAR_6 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; <START> this . VAR_5 = VAR_5 ; <END> this . VAR_6 = VAR_6 ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( TYPE_2 . METHOD_1 ( getClass ( ) . getName ( ) ) , <END> TYPE_2 . METHOD_1 ( VAR_1 ) , TYPE_2 . METHOD_1 ( VAR_2 ) , TYPE_2 . METHOD_1 ( VAR_3 ) , TYPE_2 . METHOD_1 ( VAR_4 ) , TYPE_2 . METHOD_1 ( VAR_5 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 . size ( ) == 0 ) { <END> return null ; } return VAR_1 . get ( VAR_2 ) ; } 
public Optional < TYPE_1 > METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> return Optional . of ( VAR_1 ) ; <END> } 
public Optional < Context > METHOD_1 ( ) { final Context context = new Context ( ) ; <START> return Optional . of ( context ) ; <END> } 
public Set < String > METHOD_1 ( final String VAR_1 ) { final Set < String > VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( null == VAR_2 ) { return Collections . VAR_4 ( ) ; } <START> return VAR_2 ; <END> } 
public void METHOD_1 ( final List < String > VAR_1 ) { String [ ] VAR_2 = VAR_1 . METHOD_2 ( new String [ VAR_1 . size ( ) ] ) ; VAR_3 . METHOD_3 ( VAR_4 , METHOD_4 ( VAR_2 ) , VAR_2 [ 0 ] , new TYPE_1 < String > ( ) { @Override public void METHOD_5 ( String s ) { METHOD_6 ( ) ; } <START> } ) ; <END> } 
private void METHOD_1 ( final Class < ? extends TYPE_1 > type , <START> final boolean VAR_1 ) { <END> VAR_2 . get ( type ) . METHOD_2 ( VAR_1 ) ; } 
<START> private boolean METHOD_1 ( String path ) { <END> File VAR_1 = new File ( path + STRING_1 + VAR_2 ) ; return VAR_1 . exists ( ) && VAR_1 . METHOD_2 ( ) ; } 
private boolean METHOD_1 ( String path ) { <START> File VAR_1 = new File ( path + File . VAR_2 + VAR_3 ) ; <END> return VAR_1 . exists ( ) && VAR_1 . METHOD_2 ( ) ; } 
public void METHOD_1 ( ) throws Exception { <START> final List < TYPE_1 > VAR_1 = Arrays . asList ( TYPE_1 . VAR_2 , <END> TYPE_1 . VAR_3 , TYPE_1 . VAR_4 , TYPE_1 . VAR_5 ) ; VAR_6 . METHOD_2 ( VAR_1 ) ; VAR_1 . stream ( ) . forEach ( VAR_7 - > METHOD_3 ( VAR_8 ) . METHOD_4 ( VAR_7 . value ( ) ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> final List < TYPE_1 > VAR_1 = Arrays . asList ( TYPE_1 . VAR_2 , <END> TYPE_1 . VAR_3 , TYPE_1 . VAR_4 ) ; VAR_5 . METHOD_2 ( VAR_1 ) ; VAR_1 . stream ( ) . forEach ( VAR_6 - > METHOD_3 ( VAR_7 ) . METHOD_4 ( VAR_6 . value ( ) ) ) ; } 
public boolean METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) ; <START> return true ; <END> } 
public void METHOD_1 ( ) { VAR_1 <START> . METHOD_2 ( VAR_2 - > true ) <END> . METHOD_3 ( VAR_3 - > ! TYPE_1 . contains ( VAR_3 ) ) ; } 
<START> static < T , TYPE_1 > TYPE_2 < T , TYPE_3 < TYPE_1 > > METHOD_1 ( Class < ? > VAR_1 ) { <END> return t - > TYPE_3 . METHOD_1 ( STRING_1 + Optional . VAR_2 ( t ) . map ( o - > o . getClass ( ) . METHOD_2 ( ) ) . METHOD_3 ( STRING_2 + VAR_1 . METHOD_2 ( ) ) ) ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { if ( VAR_1 . isEmpty ( ) ) return new TYPE_1 ( ) ; else return new TYPE_1 ( <START> Arrays . asList ( VAR_1 . split ( STRING_1 ) ) . stream ( ) <END> . map ( TYPE_2 : : METHOD_1 ) . collect ( Collectors . VAR_2 ( ) ) ) ; } 
<START> void METHOD_1 ( String value ) { <END> if ( value == null || value . isEmpty ( ) ) { return ; } TYPE_1 input = input ( value ) ; METHOD_2 ( element ) . METHOD_3 ( ) . add ( ( TYPE_2 ) input . VAR_1 ( ) ) ; element . VAR_2 ( ) . add ( input ) ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { return new TYPE_1 ( <START> Arrays . asList ( VAR_1 . split ( STRING_1 ) ) . stream ( ) <END> . map ( TYPE_2 : : METHOD_1 ) . collect ( Collectors . VAR_2 ( ) ) ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( column ) ; VAR_1 . METHOD_3 ( new TYPE_1 ( ) ) ; VAR_1 . METHOD_3 ( new TYPE_1 ( ) ) ; VAR_1 . METHOD_3 ( new TYPE_1 ( ) ) ; <START> METHOD_4 ( 0 , 0 , VAR_2 , FLOAT_1 ) ; <END> METHOD_4 ( 1 , 0 , VAR_2 , INT_1 ) ; METHOD_4 ( 2 , 0 , VAR_2 , INT_2 ) ; TYPE_2 . assertThat ( column . VAR_3 ( ) ) . METHOD_5 ( INT_3 ) ; } 
private List < TYPE_1 > METHOD_1 ( final int VAR_1 ) { final int VAR_2 = VAR_1 - TYPE_2 . VAR_4 ; <START> final List < TYPE_1 > values = VAR_5 . METHOD_2 ( ) . stream ( ) . map ( row - > row . VAR_6 ( ) . get ( VAR_2 ) ) . collect ( Collectors . VAR_7 ( ) ) ; <END> return values ; } 
protected void METHOD_1 ( ) { <START> final Optional < TYPE_1 > VAR_1 = METHOD_2 ( parent ) ; <END> VAR_2 . METHOD_3 ( new TYPE_2 ( VAR_3 . METHOD_4 ( ) , VAR_1 ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 < String > a = new TYPE_1 < > ( STRING_1 ) ; TYPE_1 < String > b = new TYPE_1 < > ( STRING_1 ) ; assertEquals ( a , b ) ; b . VAR_1 ( STRING_2 ) ; METHOD_2 ( a , b ) ; b . VAR_1 ( STRING_1 ) ; assertEquals ( a , b ) ; <START> } <END> 
private static String METHOD_1 ( String VAR_1 ) { String VAR_2 = "" ; try { VAR_2 = TYPE_1 . toString ( TYPE_2 . class . METHOD_2 ( VAR_1 ) , TYPE_3 . VAR_4 ) ; } catch ( IOException e ) { <START> e . VAR_5 ( ) ; <END> } return VAR_2 ; } 
public static void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> VAR_2 = new TYPE_2 ( ) ; VAR_3 = new TYPE_3 ( ) ; VAR_4 = new TYPE_4 ( ) ; VAR_4 . METHOD_2 ( ) ; VAR_5 = new TYPE_5 ( new TYPE_6 ( ) , new TYPE_7 ( ) , new TYPE_8 ( ) ) ; VAR_6 = METHOD_3 ( STRING_1 ) ; VAR_7 = METHOD_3 ( STRING_2 ) ; VAR_8 = METHOD_3 ( STRING_3 ) ; } 
public void METHOD_1 ( ) { view . VAR_1 ( false ) ; String value = view . VAR_2 ( ) ; try { Date VAR_3 = view . VAR_4 ( value ) ; view . VAR_5 ( VAR_3 ) ; <START> } catch ( Exception e ) { <END> view . VAR_5 ( value ) ; } view . VAR_6 ( true ) ; } 
protected void update ( ) { this . view . clear ( ) ; this . METHOD_1 ( ) ; <START> int offset = METHOD_2 ( ) ; <END> this . METHOD_3 ( ) ; this . METHOD_4 ( this . filter , this . VAR_1 , offset , this . VAR_2 * this . VAR_3 , this : : METHOD_5 ) ; this . view . VAR_4 ( this . VAR_2 ) ; this . METHOD_6 ( ) ; } 
<START> String METHOD_1 ( final TYPE_1 VAR_1 ) { <END> return VAR_2 . format ( TYPE_3 . TYPE_4 ) + STRING_1 + TYPE_2 . format ( VAR_1 . METHOD_1 ( ) ) ; } 
public TYPE_2 ( ) { <START> VAR_2 = new TYPE_1 ( ) ; <END> } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> VAR_2 = new TYPE_2 ( ) ; <END> this . VAR_1 = VAR_1 ; METHOD_2 ( ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { <START> TYPE_1 VAR_2 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> if ( VAR_2 == null ) { throw new RuntimeException ( STRING_1 + VAR_1 ) ; } return VAR_2 ; } 
private void METHOD_1 ( final TYPE_1 error ) { <START> METHOD_2 ( error . VAR_1 ( ) instanceof TYPE_2 ? STRING_1 : error . getMessage ( ) ) ; <END> } 
public static Optional < TYPE_1 > METHOD_1 ( String VAR_1 , String VAR_2 ) { List < String > VAR_3 = new ArrayList < > ( ) ; TYPE_2 . METHOD_2 ( TYPE_3 . get ( TYPE_4 . create ( VAR_4 + VAR_1 ) ) , <START> VAR_3 ) ; <END> List < TYPE_5 > VAR_5 = METHOD_3 ( VAR_3 , VAR_2 ) ; return METHOD_4 ( VAR_5 ) ; } 
<START> public void METHOD_1 ( ) { <END> final TYPE_1 VAR_1 = new TYPE_1 ( ) ; final TYPE_2 VAR_2 = new TYPE_2 ( STRING_1 ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_4 , VAR_1 , false ) ; METHOD_4 ( VAR_3 . METHOD_5 ( METHOD_6 ( TYPE_2 . class ) ) ) ; } 
public T METHOD_1 ( final Type type , final String VAR_1 , final String VAR_2 ) { this . VAR_3 = type ; this . VAR_4 = VAR_1 ; this . VAR_5 = VAR_2 ; if ( null != METHOD_2 ( ) ) { final TYPE_1 VAR_6 = METHOD_2 ( ) . METHOD_3 ( ) ; <START> VAR_7 . METHOD_4 ( VAR_6 ) ; <END> final double VAR_8 = VAR_6 . METHOD_5 ( ) ; final double VAR_9 = VAR_6 . METHOD_6 ( ) ; METHOD_7 ( VAR_8 , VAR_9 ) ; } return METHOD_8 ( ) ; } 
private void METHOD_1 ( ) { if ( context . VAR_1 ( ) . METHOD_2 ( ) != null ) { final String VAR_2 = context . VAR_1 ( ) . METHOD_2 ( ) ; <START> VAR_3 . METHOD_3 ( Constants . VAR_4 . METHOD_4 ( VAR_2 ) , <END> VAR_5 . METHOD_5 ( ) , VAR_2 , TYPE_1 . VAR_7 , ( ) - > METHOD_6 ( ) , ( ) - > { } ) ; } else { METHOD_6 ( ) ; } } 
<START> public Map METHOD_1 ( ) { <END> return map ; } 
public TYPE_1 METHOD_1 ( ) { if ( METHOD_2 ( ) . size ( ) < 1 ) { <START> if ( ! parse ( METHOD_3 ( ) ) ) { <END> return new TYPE_1 ( 0 , 0 , 0 , 0 ) ; } } return METHOD_2 ( ) . METHOD_1 ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; <END> if ( VAR_2 == null ) { VAR_2 = METHOD_2 ( VAR_1 ) ; } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 context ) { VAR_1 . clear ( ) ; VAR_2 . clear ( ) ; if ( context != null ) { <START> TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( context ) ; <END> VAR_2 . add ( VAR_3 ) ; } } 
public void METHOD_1 ( String VAR_1 , String type ) { if ( VAR_2 . containsKey ( VAR_1 ) ) { String VAR_3 = VAR_2 . get ( VAR_1 ) ; if ( ! VAR_3 . equals ( type ) ) { VAR_4 = false ; <START> VAR_5 . add ( STRING_1 + VAR_1 + STRING_2 + VAR_3 + STRING_3 + type + STRING_4 ) ; <END> } } else { VAR_2 . put ( VAR_1 , type ) ; } } 
<START> void METHOD_1 ( ANNOTATION_1 TYPE_1 event ) { <END> METHOD_2 ( STRING_1 , event ) ; final String VAR_1 = event . VAR_2 ( ) ; if ( METHOD_3 ( event ) && METHOD_4 ( VAR_1 ) ) { final TYPE_2 < ? > VAR_3 = METHOD_5 ( VAR_1 ) ; if ( ! VAR_3 . METHOD_6 ( ) ) { METHOD_7 ( VAR_3 ) ; } else { METHOD_8 ( VAR_3 ) ; } } } 
<START> public String METHOD_1 ( ) { <END> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; return VAR_2 . METHOD_2 ( ) . getId ( ) ; } 
private void METHOD_1 ( ) { <START> ; <END> this . VAR_1 = new TYPE_1 ( factory , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 result = new TYPE_2 ( ) ; <START> result . VAR_1 ( String . VAR_2 . getName ( ) ) ; <END> return result ; } 
public String METHOD_1 ( ) { final String description = VAR_1 . METHOD_2 ( TYPE_2 . TYPE_1 ) ; <START> return description != null && ! description . isEmpty ( ) ? description : STRING_1 ; <END> } 
private void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> assertTrue ( VAR_2 . getProperty ( STRING_1 ) != null ) ; <END> int VAR_3 = VAR_4 . METHOD_2 ( VAR_5 . METHOD_3 ( ) , path ) . size ( ) - 1 ; assertEquals ( STRING_2 , VAR_3 , VAR_1 . size ( ) ) ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 < ? extends TYPE_3 > VAR_1 ) { VAR_1 . forEach ( v - > { final String VAR_2 = v . VAR_3 ( ) ; <START> if ( null != VAR_2 ) { <END> METHOD_2 ( VAR_2 , TYPE_4 . VAR_5 ) ; } } ) ; METHOD_3 ( ) . METHOD_4 ( ) ; return this ; } 
<START> protected Optional < TYPE_1 < TYPE_2 > > METHOD_1 ( final TYPE_3 element ) { <END> final TYPE_4 < ? > VAR_1 = VAR_2 . METHOD_2 ( ) ; final TYPE_5 < ? > VAR_3 = VAR_1 . METHOD_3 ( element . VAR_4 ( ) ) ; final double x = VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) ; final double y = VAR_3 . METHOD_4 ( ) . METHOD_6 ( ) ; return Optional . of ( METHOD_7 ( element , x , y ) ) ; } 
public TYPE_1 build ( ) { final TYPE_1 result = new TYPE_1 ( VAR_1 . getMessage ( ) , VAR_1 . METHOD_1 ( ) ) ; if ( VAR_1 instanceof TYPE_2 ) { final String VAR_2 = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; if ( null != VAR_2 ) { result . VAR_3 ( VAR_2 ) ; <START> ; <END> } } return result ; } 
protected TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 context ) { <START> final org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . TYPE_6 VAR_6 = METHOD_2 ( context ) ; <END> final Collection < TYPE_2 > VAR_8 = METHOD_3 ( context , TYPE_7 . TYPE_8 . METHOD_4 ( VAR_6 , METHOD_5 ( ) , TYPE_9 . TYPE_10 . VAR_11 ) ) ; return new TYPE_5 ( VAR_8 ) . build ( ) ; } 
<START> private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , <END> final TYPE_3 context ) { final TYPE_1 VAR_2 = VAR_3 . METHOD_1 ( VAR_1 . METHOD_2 ( ) ) ; return null != VAR_2 && METHOD_3 ( VAR_2 , VAR_1 , context ) ? VAR_2 : null ; } 
public static TYPE_1 METHOD_1 ( final String VAR_1 , final TYPE_1 VAR_2 ) { try { ( ( TYPE_2 ) VAR_2 ) . METHOD_2 ( VAR_1 ) ; <START> } catch ( final TYPE_3 VAR_3 ) { <END> } return VAR_2 ; } 
public < T > Collection < TYPE_1 > METHOD_1 ( final Path path , final T content ) { <START> return ( Collection < TYPE_1 > ) VAR_1 . stream ( ) . filter ( v - > v . VAR_2 ( path ) ) . METHOD_2 ( c - > c . VAR_3 ( path , <END> content ) . stream ( ) . filter ( r - > r != null ) ) . collect ( Collectors . VAR_4 ( ) ) ; } 
public void METHOD_1 ( final String VAR_1 , final TYPE_1 element , final TYPE_2 VAR_2 ) { <START> if ( VAR_1 . trim ( ) . length ( ) > 0 ) { <END> VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; METHOD_2 ( element , VAR_2 ) ; } } 
void METHOD_1 ( ) { <START> VAR_1 . call ( new TYPE_1 < TYPE_2 > ( ) { <END> @Override public void METHOD_2 ( final TYPE_2 VAR_2 ) { METHOD_3 ( VAR_2 ) ; } } ) . METHOD_4 ( METHOD_5 ( ) ) ; } 
public void METHOD_1 ( ) { this . VAR_1 = null ; this . VAR_2 = null ; this . VAR_3 = null ; this . VAR_4 . METHOD_1 ( ) ; this . VAR_5 . METHOD_1 ( ) ; this . VAR_6 . METHOD_2 ( null ) ; this . VAR_6 . METHOD_3 ( ) ; this . VAR_7 . METHOD_1 ( ) ; <START> this . VAR_2 . METHOD_1 ( ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( ) ; <START> VAR_1 . METHOD_4 ( ) ; <END> METHOD_5 ( ) . METHOD_1 ( ) ; METHOD_6 ( ) . METHOD_1 ( ) ; VAR_2 = null ; } 
<START> public void METHOD_1 ( ) { <END> METHOD_2 ( true ) . when ( VAR_1 ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( ) ; assertTrue ( VAR_2 . METHOD_5 ( ) ) ; METHOD_6 ( VAR_3 ) . METHOD_7 ( TYPE_1 . class ) ; METHOD_6 ( VAR_3 ) . METHOD_8 ( TYPE_1 . class ) ; } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( new TYPE_2 ( ) , VAR_1 ) ; final HashSet < String > VAR_3 = new HashSet < String > ( ) ; VAR_3 . add ( STRING_1 ) ; VAR_3 . add ( STRING_2 ) ; assertEquals ( 0 , VAR_1 . size ( ) ) ; <START> VAR_2 . METHOD_3 ( VAR_3 ) ; <END> } 
public void METHOD_1 ( ) { super . METHOD_2 ( ) ; METHOD_3 ( ) ; METHOD_4 ( ) ; final Collection < TYPE_1 > VAR_1 = METHOD_5 ( ) ; if ( null != VAR_1 && ! VAR_1 . isEmpty ( ) ) { <START> for ( TYPE_1 VAR_2 : VAR_1 ) { <END> METHOD_6 ( ) . METHOD_7 ( VAR_2 ) ; } } } 
private TYPE_1 METHOD_1 ( final String text , final TYPE_2 command , final TYPE_3 type ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( text , new TYPE_4 ( ) { <END> @Override public void METHOD_2 ( TYPE_5 event ) { command . execute ( ) ; } } ) ; VAR_1 . METHOD_3 ( type ) ; return VAR_1 ; } 
void METHOD_1 ( ) { <START> ANNOTATION_1 ( STRING_1 ) <END> final TYPE_1 e = TYPE_2 . get ( STRING_2 ) . METHOD_2 ( ) ; new TYPE_3 ( ) { @Override protected void METHOD_3 ( double VAR_1 ) { e . VAR_2 ( ) . METHOD_4 ( FLOAT_1 - VAR_1 ) ; } @Override protected void METHOD_5 ( ) { e . VAR_2 ( ) . METHOD_6 ( TYPE_4 . TYPE_5 . VAR_5 ) ; } } . run ( INT_1 ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> super ( null , VAR_2 , VAR_3 ) ; <END> } 
public TYPE_3 ( String source , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> super ( null , source , VAR_2 , VAR_3 ) ; <END> } 
public static TYPE_1 getInstance ( ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_1 ( VAR_2 , TimeUnit . VAR_3 ) ; VAR_1 . METHOD_2 ( VAR_2 , TimeUnit . VAR_3 ) ; VAR_1 . METHOD_3 ( VAR_2 , TimeUnit . VAR_3 ) ; VAR_1 . METHOD_4 ( ) . add ( new TYPE_2 ( METHOD_5 ( ) ) ) ; } return VAR_1 ; } 
protected boolean METHOD_1 ( ) { if ( VAR_1 ) { return VAR_2 != null ; } else { <START> return VAR_3 . METHOD_2 ( ) ; <END> } } 
public void METHOD_1 ( ANNOTATION_1 final View view ) { super . METHOD_1 ( view ) ; VAR_1 . METHOD_2 ( view . VAR_2 ( ) ) ; <START> METHOD_3 ( ) ; <END> } 
private static void METHOD_1 ( File VAR_1 ) throws IOException { <START> if ( ! VAR_1 . exists ( ) ) { <END> if ( ! VAR_1 . METHOD_2 ( ) ) { throw new IOException ( STRING_1 + VAR_1 ) ; } } } 
private boolean METHOD_1 ( String VAR_1 ) { if ( VAR_1 != null ) { TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( TYPE_2 . VAR_5 != VAR_2 . METHOD_3 ( ) ) { return true ; } <START> log . trace ( STRING_1 , VAR_1 ) ; <END> } else { log . trace ( STRING_2 ) ; } return false ; } 
public void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( ( TYPE_2 . VAR_4 != VAR_3 ) && ( TYPE_2 . VAR_5 != VAR_3 ) ) { <START> METHOD_3 ( VAR_1 , VAR_1 . METHOD_4 ( ) , VAR_3 ) ; <END> } } } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( TYPE_2 . class ) ; <END> when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( STRING_1 ) ; TYPE_3 VAR_2 = METHOD_2 ( TYPE_3 . class ) ; when ( VAR_2 . METHOD_5 ( ) ) . METHOD_4 ( VAR_1 ) ; when ( VAR_2 . METHOD_6 ( ) ) . METHOD_4 ( getClass ( ) . METHOD_7 ( ) ) ; TYPE_4 instance = new TYPE_4 ( ) ; TYPE_5 result = instance . create ( VAR_2 ) ; METHOD_8 ( result ) ; } 
public void METHOD_1 ( long VAR_1 ) { <START> VAR_2 += VAR_1 ; <END> VAR_3 += ( VAR_1 == 0 ? 0 : VAR_1 * Math . log ( VAR_1 ) ) ; } 
public void METHOD_1 ( ) { <START> if ( this . VAR_1 != null ) { <END> this . VAR_1 . METHOD_2 ( ) ; } } 
public Object METHOD_1 ( TYPE_1 input ) throws IOException { <START> if ( input . size ( ) == 0 ) <END> { throw new RuntimeException ( STRING_1 ) ; } for ( Object o : input ) { if ( o != null ) { return o ; } } return null ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 ) ; <START> TYPE_2 file = VAR_1 . METHOD_2 ( null ) ; <END> METHOD_3 ( file ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( TYPE_4 . VAR_3 + STRING_1 ) ; <START> String VAR_4 = VAR_5 . get ( TYPE_2 ) ; <END> if ( ! TYPE_3 . isEmpty ( VAR_4 ) ) { VAR_1 . METHOD_3 ( VAR_4 ) ; } for ( String key : VAR_5 . keySet ( ) ) { VAR_1 . METHOD_4 ( key , VAR_5 . get ( key ) ) ; } } 
private boolean METHOD_1 ( ANNOTATION_1 Integer VAR_1 ) { return VAR_1 != null && ( VAR_1 == Constants . VAR_2 || VAR_1 == Constants . VAR_3 || VAR_1 == Constants . VAR_4 || VAR_1 == Constants . VAR_5 ) ; <START> return false ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> return id . equals ( that . id ) ; <END> } 
public TYPE_2 . TYPE_3 METHOD_1 ( ) throws IOException { <START> if ( input != null ) <END> throw new RuntimeException ( STRING_1 ) ; if ( VAR_1 ) throw new RuntimeException ( STRING_2 ) ; connection . VAR_2 ( true ) ; input = new TYPE_2 . TYPE_3 ( ) ; return input ; } 
public TYPE_2 . TYPE_3 METHOD_1 ( ) throws IOException { <START> if ( output != null ) <END> throw new RuntimeException ( STRING_1 ) ; if ( VAR_1 ) throw new RuntimeException ( STRING_2 ) ; connection . VAR_2 ( true ) ; output = new TYPE_2 . TYPE_3 ( ) ; return output ; } 
public TYPE_3 . TYPE_4 METHOD_1 ( ) throws IOException { if ( VAR_1 ) <START> throw new RuntimeException ( STRING_1 ) ; <END> return new TYPE_3 . TYPE_4 ( new TYPE_3 . TYPE_5 ( ) , this ) ; } 
public void METHOD_1 ( Throwable VAR_1 ) throws Exception { <START> if ( VAR_2 != null ) <END> VAR_2 . METHOD_2 ( VAR_1 ) ; TYPE_1 < ? , ? > r = METHOD_3 ( ) . get ( TYPE_1 . class ) ; TYPE_2 listener = METHOD_3 ( ) . get ( TYPE_2 . class ) ; TYPE_5 . TYPE_6 VAR_3 = TYPE_4 . METHOD_4 ( ) . METHOD_5 ( TYPE_5 . TYPE_6 . class ) ; VAR_3 . METHOD_6 ( r . VAR_4 ( ) , METHOD_7 ( ) , listener ) ; } 
<START> private Boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <END> for ( String VAR_3 : VAR_1 . METHOD_2 ( ) ) { if ( VAR_2 . METHOD_2 ( ) . contains ( VAR_3 ) ) { return true ; } } return false ; } 
private TYPE_1 METHOD_1 ( TYPE_2 task ) { if ( task instanceof TYPE_3 ) { TYPE_3 < ? , ? > p = ( TYPE_3 < ? , ? > ) task ; if ( task instanceof TYPE_4 ) { <START> p = ( TYPE_3 < ? , ? > ) ( ( TYPE_4 ) task ) . METHOD_2 ( ) ; <END> } TYPE_1 VAR_1 = p . getProperty ( TYPE_1 . class ) ; return VAR_1 ; } return null ; } 
<START> public TYPE_2 ( String VAR_2 , <END> Integer VAR_3 , Integer VAR_4 , String VAR_5 , List < TYPE_1 > VAR_6 ) { this . VAR_3 = VAR_3 == null ? 0 : VAR_3 ; this . VAR_4 = VAR_4 == null ? 0 : VAR_4 ; this . VAR_2 = VAR_2 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 == null ? new ArrayList < TYPE_1 > ( ) : VAR_6 ; METHOD_1 ( VAR_5 ) ; } 
public void METHOD_1 ( TYPE_1 location , String VAR_1 , String VAR_2 ) { TYPE_2 . METHOD_2 ( METHOD_3 ( ) , TYPE_3 . METHOD_4 ( location ) ) . METHOD_5 ( VAR_3 - > { if ( VAR_3 ) { if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { TYPE_4 . METHOD_6 ( this , VAR_1 ) ; } } else { if ( VAR_2 != null && ! VAR_2 . isEmpty ( ) ) { METHOD_7 ( VAR_2 ) ; <START> } <END> } return VAR_3 ; } ) ; } 
public boolean METHOD_1 ( ) { <START> if ( VAR_1 . getValue ( ) == null || VAR_1 . getValue ( ) instanceof TYPE_1 ) { <END> return false ; } return super . METHOD_1 ( ) ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 . isEmpty ( ) && VAR_2 . METHOD_2 ( ) ) { return false ; } if ( VAR_3 . isEmpty ( ) && ! VAR_2 . METHOD_2 ( ) ) { return false ; <START> } <END> if ( VAR_4 . getValue ( ) instanceof TYPE_1 ) { return METHOD_3 ( ) ? false : super . METHOD_1 ( ) ; } if ( VAR_4 . getValue ( ) instanceof TYPE_2 ) { return super . METHOD_1 ( ) ; } return super . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; final TYPE_1 VAR_1 = METHOD_2 ( TYPE_3 . VAR_3 ) ; if ( METHOD_3 ( ) instanceof TYPE_2 ) { <START> final TYPE_2 page = ( TYPE_2 ) METHOD_3 ( ) ; <END> VAR_1 . setText ( Messages . VAR_4 ) ; } else { VAR_1 . setText ( TYPE_3 . VAR_5 ) ; } } 
private TYPE_1 METHOD_1 ( final TYPE_2 [ ] VAR_1 ) { final TYPE_1 VAR_2 = METHOD_2 ( ) ; VAR_2 . METHOD_3 ( Path . VAR_3 ( VAR_4 . METHOD_4 ( ) ) ) ; VAR_2 . METHOD_5 ( VAR_1 ) ; VAR_2 . METHOD_6 ( true ) ; VAR_2 . METHOD_7 ( VAR_5 ) ; VAR_2 . METHOD_8 ( true ) ; <START> VAR_2 . METHOD_9 ( false ) ; <END> return VAR_2 ; } 
public String METHOD_1 ( final Object element ) { if ( element instanceof TYPE_1 ) { final TYPE_1 VAR_1 = ( TYPE_1 ) element ; <START> return new Boolean ( ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) . toString ( ) ; <END> } return super . METHOD_1 ( element ) ; } 
protected boolean METHOD_1 ( final TYPE_1 VAR_1 ) { final String VAR_2 = VAR_1 . get ( STRING_1 ) ; <START> final boolean VAR_3 = VAR_2 != null <END> && ( VAR_2 . contains ( STRING_2 ) || VAR_2 . contains ( STRING_3 ) ) ; return VAR_3 ; } 
<START> private static TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { VAR_1 = TYPE_2 . create ( STRING_1 ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( final TYPE_2 data ) { <START> VAR_1 . METHOD_1 ( data ) ; ; <END> return this ; } 
public void update ( ) { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_1 ( METHOD_2 ( ) || METHOD_3 ( ) ) ; <END> final TYPE_1 VAR_2 = METHOD_4 ( VAR_3 . METHOD_5 ( ) ) ; if ( VAR_2 != null ) { if ( VAR_2 instanceof TYPE_2 ) { VAR_1 . METHOD_6 ( TYPE_3 . bind ( Messages . VAR_4 , Messages . VAR_5 ) ) ; } else { VAR_1 . METHOD_6 ( TYPE_3 . bind ( Messages . VAR_4 , Messages . task ) ) ; } } } } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) . METHOD_3 ( STRING_1 ) . METHOD_4 ( STRING_2 ) . build ( ) , new TYPE_2 ( STRING_1 , <START> String . VAR_2 ) , new TYPE_2 ( STRING_2 , <END> String . VAR_2 ) ) ; final TYPE_3 status = VAR_1 . METHOD_5 ( ) ; TYPE_4 . assertThat ( status ) . METHOD_6 ( ) ; } 
protected void METHOD_1 ( final TYPE_1 status ) { METHOD_2 ( status ) ; VAR_1 . METHOD_3 ( ) ; if ( ! status . VAR_2 ( ) && METHOD_4 ( ) . METHOD_5 ( ) ) { <START> VAR_1 . METHOD_6 ( "" , status . getMessage ( ) , null , new TYPE_2 ( status ) . METHOD_7 ( ) ) ; <END> } } 
<START> protected boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <END> if ( VAR_1 . METHOD_2 ( ) instanceof TYPE_2 ) { return true ; } return false ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; <END> } 
public void METHOD_1 ( ) { try { <START> log . info ( STRING_1 + METHOD_2 ( ) ) ; <END> } catch ( IllegalStateException e ) { log . error ( e . getMessage ( ) ) ; } } 
public void METHOD_1 ( ) { VAR_1 = VAR_2 . getString ( STRING_1 , null ) ; VAR_3 = new TYPE_1 ( VAR_1 , INT_1 , 1 ) ; <START> Integer . parseInt ( VAR_2 . getString ( STRING_2 , STRING_3 ) ) ; <END> } 
public void METHOD_1 ( ) { try { <START> String query = new String ( STRING_1 ) ; <END> VAR_1 . METHOD_2 ( query ) ; } catch ( TYPE_1 e ) { log . error ( e . VAR_2 ( ) , e ) ; } catch ( IOException e ) { log . error ( e . VAR_2 ( ) , e ) ; } } 
public void write ( TYPE_1 out ) { try { TYPE_2 . METHOD_1 ( results . VAR_1 ( ) , out ) ; <START> results . VAR_2 ( ) ; <END> } catch ( IOException e ) { throw new TYPE_3 ( Response . status ( Status . VAR_3 ) . entity ( STRING_1 ) . build ( ) ) ; } } 
public TYPE_1 METHOD_1 ( final String id ) { List < Object > results = METHOD_2 ( ) . METHOD_3 ( new TYPE_2 ( ) { public Object METHOD_4 ( TYPE_3 session ) { <START> TYPE_4 query = session . VAR_1 ( <END> STRING_1 + STRING_2 ) . METHOD_5 ( TYPE_1 . class ) ; query . VAR_2 ( STRING_3 , id ) ; return query . list ( ) ; } } ) ; if ( ! results . isEmpty ( ) ) { return ( TYPE_1 ) results . get ( 0 ) ; } return null ; } 
public void METHOD_1 ( ) { if ( TYPE_5 . VAR_2 . VAR_3 >= TYPE_5 . VAR_4 . VAR_5 ) { TYPE_1 args = new TYPE_1 ( ) ; args . VAR_6 ( STRING_1 , METHOD_2 ( TYPE_4 . VAR_8 . VAR_9 ) ) ; <START> TYPE_2 VAR_10 = TYPE_2 . METHOD_3 ( ) ; <END> VAR_10 . METHOD_4 ( args ) ; VAR_11 . METHOD_5 ( VAR_10 ) ; } else { TYPE_3 . METHOD_6 ( this , R . string . VAR_12 , TYPE_3 . VAR_13 ) . METHOD_7 ( ) ; METHOD_8 ( ) ; } } 
protected void METHOD_1 ( ) { Logger . debug ( this , STRING_1 ) ; <START> ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( METHOD_3 ( ) ) ; <END> } 
<START> public TYPE_1 < String , String > METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> this . VAR_2 . add ( VAR_1 ) ; <END> METHOD_2 ( TYPE_3 . VAR_4 + VAR_1 . getName ( ) , VAR_5 . METHOD_3 ( VAR_1 ) ) ; return this ; } 
<START> public TYPE_2 ( <END> TYPE_1 VAR_2 ) { METHOD_1 ( VAR_2 . METHOD_2 ( this ) ) ; } 
<START> public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 view , TYPE_3 VAR_3 ) { <END> super ( VAR_2 , view , VAR_3 , TYPE_4 . TYPE_5 ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . class , TYPE_1 . TYPE_8 . class , TYPE_3 . class ) ; <START> <END> bind ( new TYPE_4 < TYPE_5 < TYPE_6 > > ( ) { } ) . to ( new TYPE_4 < TYPE_7 < TYPE_6 > > ( ) { } ) ; bind ( TYPE_6 . class ) . to ( TYPE_1 . class ) ; } 
public void METHOD_1 ( ) { new TYPE_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ; String url = VAR_1 . METHOD_7 ( ) ; <START> TYPE_2 . assertTrue ( url . contains ( STRING_1 ) ) ; <END> } 
public String METHOD_1 ( String VAR_1 ) { <START> if ( "" . equals ( VAR_1 ) ) <END> throw new TYPE_1 ( STRING_1 ) ; return METHOD_2 ( true ) + TYPE_2 . VAR_3 + VAR_1 ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> VAR_2 . METHOD_2 ( 0 , INT_1 ) ; <END> VAR_3 . METHOD_3 ( VAR_4 ) ; TYPE_2 . METHOD_4 ( VAR_1 ) ; return this ; } 
public TYPE_1 METHOD_1 ( ) { try { Thread . VAR_1 ( INT_1 ) ; } catch ( Exception e ) { } VAR_2 . METHOD_2 ( VAR_3 ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> return this ; } 
<START> private String METHOD_1 ( String page , String query ) { <END> return VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( String . format ( STRING_1 , VAR_1 . METHOD_4 ( page ) ) ) , query ) ; } 
public void METHOD_1 ( ) { new TYPE_1 ( ) . METHOD_2 ( STRING_1 ) ; TYPE_2 VAR_1 = new TYPE_2 ( ) ; TYPE_3 . assertTrue ( VAR_1 . METHOD_3 ( ) ) ; <START> TYPE_4 VAR_2 = new TYPE_4 ( ) ; <END> TYPE_3 . METHOD_4 ( VAR_2 . METHOD_5 ( VAR_3 ) ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_1 . VAR_1 ) ) ; <END> METHOD_4 ( ) ; TYPE_2 . log ( STRING_1 , STRING_2 , true , VAR_2 ) ; } 
public Optional < TYPE_1 > METHOD_1 ( String VAR_1 ) { <START> return Optional . VAR_2 ( <END> METHOD_2 ( ) . METHOD_3 ( ) . stream ( ) . METHOD_4 ( VAR_3 - > METHOD_5 ( VAR_3 . METHOD_6 ( ) ) ) . filter ( VAR_3 - > VAR_3 . METHOD_7 ( ) . equals ( VAR_1 ) ) . METHOD_8 ( ) . METHOD_9 ( ( ) - > new RuntimeException ( String . format ( STRING_1 , VAR_1 ) ) ) ) ; } 
public boolean METHOD_1 ( ) { <START> this . METHOD_2 ( ) ; <END> return this . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException , TYPE_2 { TYPE_3 url = new TYPE_3 ( METHOD_2 ( VAR_1 ) ) ; TYPE_4 VAR_2 = TYPE_5 . create ( ) . METHOD_3 ( ) . build ( ) ; TYPE_6 VAR_3 = METHOD_4 ( url ) ; <START> if ( METHOD_5 ( ) != null ) { <END> VAR_3 . METHOD_6 ( new TYPE_7 ( METHOD_5 ( ) , TYPE_8 . VAR_5 ) ) ; } return VAR_2 . execute ( VAR_3 ) ; } 
<START> @Override public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> METHOD_2 ( VAR_2 , VAR_1 ) ; return this ; } 
public void METHOD_1 ( String VAR_1 ) { if ( VAR_1 . equals ( TYPE_1 . VAR_3 ) ) { METHOD_2 ( ) ; } if ( VAR_1 . equals ( TYPE_1 . VAR_4 ) ) { METHOD_3 ( ) ; <START> } <END> METHOD_4 ( STRING_1 + VAR_1 ) ; } 
public boolean METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { return VAR_4 . stream ( ) . filter ( VAR_5 - > VAR_5 . getType ( ) == TYPE_1 . VAR_7 ) . filter ( VAR_5 - > VAR_5 . METHOD_2 ( ) . METHOD_3 ( ) . contains ( VAR_1 ) ) <START> . filter ( VAR_5 - > VAR_5 . METHOD_4 ( ) . contains ( VAR_2 ) ) <END> . METHOD_5 ( VAR_5 - > VAR_5 . METHOD_6 ( ) . contains ( VAR_3 ) ) ; } 
<START> private void METHOD_1 ( long VAR_1 , String VAR_2 , String VAR_3 , TYPE_1 VAR_4 ) { <END> VAR_4 . METHOD_2 ( VAR_2 ) ; TYPE_2 . assertEquals ( VAR_1 , VAR_4 . METHOD_3 ( TYPE_3 . VAR_6 ) ) ; VAR_4 . METHOD_2 ( VAR_3 ) ; TYPE_2 . assertEquals ( VAR_1 , VAR_4 . METHOD_3 ( TYPE_3 . VAR_7 ) ) ; TYPE_2 . METHOD_4 ( VAR_4 . METHOD_5 ( TYPE_3 . VAR_8 ) ) ; } 
private String METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( STRING_1 ) ; int VAR_2 = ( int ) Math . VAR_3 ( VAR_4 / INT_1 ) ; int VAR_5 = ( int ) Math . VAR_3 ( VAR_4 / INT_2 % INT_2 ) ; <START> int VAR_6 = ( int ) Math . VAR_3 ( VAR_4 % INT_2 ) ; <END> return String . format ( STRING_2 , VAR_1 . format ( VAR_2 ) , VAR_1 . format ( VAR_5 ) , VAR_1 . format ( VAR_6 ) ) ; } 
public boolean METHOD_1 ( double VAR_1 , double VAR_2 ) { int VAR_3 = ( int ) Math . VAR_4 ( 100 - ( 100 / ( VAR_1 / VAR_2 ) ) ) ; if ( VAR_3 == VAR_5 ) { <START> return true ; <END> } TYPE_1 . log ( STRING_1 , STRING_2 + VAR_5 + STRING_3 , false , VAR_6 ) ; return false ; } 
public void METHOD_1 ( TYPE_1 o ) { try { o . run ( ) ; <START> } catch ( TYPE_2 e ) { <END> TYPE_3 . log ( STRING_1 , e . getMessage ( ) , true ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ) ; new TYPE_2 ( ) . METHOD_5 ( VAR_3 . VAR_4 , VAR_3 . VAR_5 ) ; VAR_1 . METHOD_6 ( VAR_3 . VAR_4 ) ; <START> TYPE_3 . assertTrue ( VAR_1 . METHOD_7 ( TYPE_4 . VAR_7 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 page , String VAR_1 , String VAR_2 ) { <START> METHOD_2 ( page , TYPE_4 . VAR_4 , TYPE_4 . VAR_5 ) ; <END> final TYPE_2 VAR_6 = new TYPE_2 ( VAR_7 , VAR_1 , VAR_2 ) ; TYPE_3 . METHOD_3 ( VAR_6 ) ; } 
public void METHOD_1 ( final String VAR_1 , TYPE_1 user ) { <START> ArrayList < TYPE_4 . TYPE_5 > VAR_2 = METHOD_2 ( VAR_1 , user ) ; <END> for ( TYPE_4 . TYPE_5 VAR_3 : VAR_2 ) { TYPE_3 . METHOD_3 ( STRING_1 + VAR_3 . getName ( ) ) ; METHOD_4 ( VAR_1 , VAR_3 ) ; } } 
<START> public ArrayList < TYPE_5 . TYPE_6 > METHOD_1 ( final String VAR_1 , TYPE_2 user ) { <END> return new TYPE_3 ( user ) . execute ( TYPE_4 . METHOD_2 ( VAR_1 , "" ) ) ; } 
String execute ( final TYPE_1 request , final TYPE_2 VAR_1 ) { String result = StringUtils . VAR_2 ; try { request . VAR_3 ( TYPE_11 . VAR_5 , TYPE_9 . TYPE_10 . toString ( ) ) ; request . VAR_6 ( new TYPE_4 ( VAR_1 . toString ( ) ) ) ; result = execute ( request ) ; <START> } catch ( TYPE_5 | TYPE_6 x ) { <END> TYPE_7 . log ( STRING_1 , TYPE_8 . METHOD_1 ( x ) , false ) ; } return result ; } 
public TYPE_1 METHOD_1 ( int position ) { TYPE_1 result = null ; final List < TYPE_2 > VAR_1 = METHOD_2 ( ) ; if ( position < VAR_1 . size ( ) ) { result = new TYPE_1 ( VAR_1 . get ( position ) ) ; } <START> return result ; <END> } 
public void METHOD_1 ( String VAR_1 , int value ) { <START> VAR_2 . METHOD_2 ( TYPE_1 . METHOD_3 ( VAR_1 ) ) ; <END> VAR_3 . METHOD_4 ( STRING_1 , VAR_1 , value ) ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( TYPE_2 . METHOD_3 ( STRING_1 ) ) ; if ( VAR_2 . isEmpty ( ) ) { VAR_1 = VAR_3 . METHOD_4 ( TYPE_2 . METHOD_3 ( STRING_2 ) ) ; } else if ( 1 < VAR_2 . size ( ) ) { throw new IllegalStateException ( STRING_3 ) ; } else { VAR_1 = VAR_2 . get ( 0 ) ; } <START> return VAR_1 ; <END> } 
private void METHOD_1 ( TYPE_1 page ) { final TYPE_2 VAR_1 = page . VAR_2 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ) ; <START> METHOD_5 ( ) ; <END> TYPE_3 . METHOD_6 ( VAR_1 . METHOD_7 ( ) , VAR_3 ) ; } 
<START> private ArrayList < String > METHOD_1 ( ) { <END> String VAR_1 = VAR_2 . METHOD_2 ( ) ; ArrayList < String > result = new ArrayList < > ( ) ; for ( String VAR_3 : VAR_2 . METHOD_3 ( ) ) { VAR_2 . METHOD_4 ( ) . METHOD_5 ( VAR_3 ) ; result . add ( VAR_2 . METHOD_6 ( ) ) ; } VAR_2 . METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ; return result ; } 
public void METHOD_1 ( int VAR_1 ) { <START> VAR_2 . METHOD_2 ( VAR_3 ) ; <END> VAR_3 . METHOD_3 ( ) ; TYPE_1 VAR_4 = VAR_5 . METHOD_4 ( TYPE_2 . id ( String . valueOf ( VAR_1 ) ) ) ; VAR_2 . METHOD_5 ( VAR_4 ) ; String VAR_6 = VAR_4 . METHOD_6 ( ) ; VAR_4 . METHOD_3 ( ) ; TYPE_3 . log ( STRING_1 , STRING_2 + VAR_6 + STRING_3 , true , VAR_7 ) ; } 
public static String METHOD_1 ( ) { <START> return String . format ( VAR_1 , System . VAR_2 ( ) ) ; <END> } 
public void METHOD_1 ( ) { String VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; String VAR_3 = TYPE_1 . METHOD_3 ( STRING_2 ) . METHOD_4 ( TYPE_5 . VAR_5 ) . METHOD_5 ( TYPE_2 . METHOD_6 ( ) . METHOD_7 ( TYPE_3 . METHOD_8 ( 2 ) ) . METHOD_9 ( TYPE_6 . VAR_7 ) ) ; <START> TYPE_4 . assertEquals ( VAR_3 , VAR_1 , STRING_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( int i , String VAR_1 ) { TYPE_2 element = VAR_2 . get ( i ) ; VAR_3 . METHOD_2 ( element ) ; element . VAR_4 ( ) ; <START> element . VAR_5 ( VAR_1 ) ; <END> return this ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { String host = TYPE_2 . METHOD_2 ( ) ; String VAR_2 = VAR_1 . equals ( "" ) || VAR_1 . equals ( STRING_1 ) ? "" : STRING_2 + TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) ; <START> String VAR_3 = VAR_1 . equals ( "" ) || VAR_1 . equals ( STRING_1 ) ? "" : VAR_4 ; <END> VAR_5 . get ( STRING_3 + host + VAR_1 + VAR_2 + VAR_3 ) ; return this ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = new TYPE_2 ( VAR_2 ) ; <END> TYPE_3 . METHOD_2 ( STRING_1 ) ; VAR_3 . METHOD_3 ( VAR_4 ) ; VAR_4 . METHOD_4 ( ) ; VAR_1 . METHOD_5 ( ) ; return this ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; <START> TYPE_1 <END> VAR_1 = new TYPE_1 ( ) . METHOD_3 ( VAR_2 ) ; TYPE_2 . assertTrue ( VAR_1 . METHOD_4 ( ) ) ; } 
public TYPE_1 METHOD_1 ( int index ) { <START> TYPE_2 . METHOD_2 ( VAR_1 . isEmpty ( ) ) ; <END> VAR_2 . METHOD_3 ( VAR_1 . get ( index ) ) ; VAR_1 . get ( index ) . METHOD_4 ( ) ; return this ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 . METHOD_2 ( STRING_1 ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; TYPE_2 . METHOD_2 ( STRING_2 ) ; VAR_3 . METHOD_4 ( 0 , 100 ) ; <START> TYPE_2 . METHOD_2 ( STRING_3 ) ; <END> VAR_1 . METHOD_5 ( VAR_2 ) ; TYPE_3 . METHOD_6 ( VAR_4 . METHOD_7 ( VAR_2 ) . METHOD_8 ( ) . METHOD_9 ( ) == VAR_5 , STRING_4 ) ; return this ; } 
public boolean METHOD_1 ( ) { try { <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> return VAR_2 . METHOD_3 ( ) ; } catch ( Exception e ) { return false ; } } 
<START> private void METHOD_1 ( ) { <END> this . VAR_1 = new TYPE_1 ( VAR_2 ) ; this . VAR_3 = new TYPE_2 ( VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( int index ) { <START> TYPE_2 VAR_1 = ( TYPE_2 ) VAR_2 ; <END> VAR_3 . get ( index ) . METHOD_2 ( ) ; VAR_4 . METHOD_3 ( VAR_5 ) ; VAR_5 . METHOD_2 ( ) ; String VAR_6 = STRING_1 + STRING_2 ; String VAR_7 = VAR_1 . METHOD_4 ( VAR_6 ) . toString ( ) ; if ( VAR_5 . METHOD_5 ( ) ) { TYPE_3 . METHOD_6 ( VAR_7 . isEmpty ( ) ) ; } else { TYPE_3 . assertTrue ( VAR_7 . isEmpty ( ) ) ; } return this ; } 
public TYPE_1 METHOD_1 ( ) { <START> METHOD_2 ( STRING_1 + TYPE_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> METHOD_5 ( String . format ( STRING_2 , VAR_1 . METHOD_6 ( ) , TYPE_3 . VAR_3 ) ) ; return this ; } 
public TYPE_1 METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_2 . METHOD_3 ( ) ; VAR_3 . METHOD_4 ( ) ; TYPE_2 . METHOD_5 ( STRING_1 ) ; <START> TYPE_3 . assertTrue ( VAR_4 . METHOD_6 ( ) . contains ( TYPE_4 . VAR_6 ) , <END> STRING_2 ) ; TYPE_2 . METHOD_5 ( STRING_3 ) ; return this ; } 
public TYPE_1 METHOD_1 ( ) { <START> METHOD_2 ( STRING_1 ) ; <END> METHOD_3 ( String . format ( STRING_2 , VAR_1 . METHOD_4 ( ) , TYPE_2 . VAR_3 ) ) ; return this ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) VAR_2 ; <START> VAR_1 . METHOD_2 ( STRING_1 , VAR_3 ) ; <END> } 
public int METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( TYPE_1 . METHOD_3 ( STRING_1 ) ) ; <END> return VAR_2 . size ( ) ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; TYPE_2 VAR_3 = new TYPE_2 ( VAR_2 ) ; TYPE_3 VAR_4 = new TYPE_3 ( VAR_2 ) ; new TYPE_4 ( VAR_2 ) . METHOD_2 ( url ) ; <START> VAR_1 . METHOD_3 ( ) ; <END> VAR_3 . METHOD_4 ( ) ; TYPE_5 . assertTrue ( VAR_4 . METHOD_5 ( TYPE_6 . VAR_6 ) ) ; } 
protected void METHOD_1 ( ) { <START> if ( ! TYPE_1 . METHOD_2 ( ) . contains ( STRING_1 ) ) { <END> if ( TYPE_1 . METHOD_3 ( ) != null ) { VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( TYPE_1 . METHOD_3 ( ) ) ; } else { VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_7 ( ) ; } } } 
public static Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] { { STRING_1 , STRING_2 , <START> STRING_3 , STRING_4 } , <END> { STRING_1 , STRING_5 , STRING_6 , STRING_4 } , { STRING_1 , STRING_7 , STRING_8 , STRING_4 } } ; } 
public static Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] { { STRING_1 , STRING_2 , STRING_3 } , <START> { STRING_1 , STRING_4 , STRING_3 } } ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; <START> TYPE_2 VAR_4 = new TYPE_2 ( VAR_2 ) ; <END> VAR_4 . METHOD_3 ( ) ; TYPE_3 VAR_5 = VAR_4 . METHOD_4 ( ) ; Assert . assertTrue ( VAR_5 . METHOD_5 ( ) ) ; VAR_5 . METHOD_6 ( VAR_6 . VAR_7 , VAR_6 . VAR_8 ) ; VAR_1 . METHOD_7 ( VAR_6 . VAR_7 ) ; } 
<START> public boolean METHOD_1 ( ) { <END> boolean VAR_1 = false ; try { VAR_2 . METHOD_2 ( VAR_3 , 3 , 1 ) ; VAR_1 = true ; } catch ( TYPE_1 exception ) { VAR_1 = false ; } return VAR_1 ; } 
public boolean METHOD_1 ( ) { boolean VAR_1 = false ; try { VAR_2 . METHOD_2 ( VAR_3 , 5 , 1 ) ; VAR_1 = true ; } catch ( TYPE_1 exception ) { VAR_1 = false ; } <START> return METHOD_3 ( ) && VAR_1 ; <END> } 
public String METHOD_1 ( String VAR_1 , String VAR_2 ) { String url = METHOD_2 ( VAR_1 ) ; url = url + VAR_2 ; <START> return url ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> String [ ] VAR_1 = METHOD_2 ( ) ; <END> String VAR_2 = "" ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . clear ( METHOD_3 ( ) ) ; for ( String VAR_4 : VAR_1 ) { VAR_2 += VAR_4 + STRING_1 ; } VAR_3 . METHOD_4 ( VAR_2 , METHOD_3 ( ) ) ; return this ; } 
public boolean METHOD_1 ( ) { boolean result = METHOD_2 ( ) ; <START> TYPE_1 . assertTrue ( result , TYPE_3 . VAR_2 ) ; <END> TYPE_2 . log ( METHOD_3 ( ) , TYPE_3 . VAR_3 , result ) ; return result ; } 
public TYPE_2 ( ) { <START> VAR_2 = INT_1 ; <END> VAR_3 = INT_1 ; VAR_4 = new TYPE_1 ( VAR_2 , VAR_3 , TYPE_1 . VAR_5 ) ; } 
private String METHOD_1 ( int VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> return new TYPE_2 ( 5 * VAR_1 , VAR_2 ) . toString ( INT_1 ) ; <END> } 
public Boolean METHOD_1 ( ) { <START> String VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; <END> return VAR_1 . equals ( STRING_2 ) ; } 
public TYPE_1 ( String VAR_2 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = null ; <END> } 
private String METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { String VAR_4 ; <START> if ( VAR_3 == STRING_1 ) { <END> VAR_4 = STRING_2 ; } else { VAR_4 = STRING_3 ; } String VAR_5 = TYPE_1 . METHOD_2 ( TYPE_1 . METHOD_3 ( VAR_1 , VAR_2 , VAR_4 ) ) ; TYPE_2 . log ( STRING_4 , STRING_5 + VAR_5 , true ) ; return VAR_5 ; } 
public void METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) . get ( ) ; VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( ) . VAR_3 , "" ) ; <START> Thread . VAR_4 ( INT_1 ) ; <END> TYPE_3 . assertTrue ( VAR_1 . METHOD_4 ( ) ) ; } 
public void METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) . get ( ) ; VAR_1 . METHOD_2 ( "" , TYPE_2 . METHOD_3 ( ) . VAR_3 ) ; <START> Thread . VAR_4 ( INT_1 ) ; <END> TYPE_3 . assertTrue ( VAR_1 . METHOD_4 ( ) ) ; } 
public static String METHOD_1 ( ) { <START> return String . valueOf ( METHOD_2 ( STRING_1 ) ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> TYPE_2 . METHOD_1 ( VAR_2 , this ) ; <END> } 
public static Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] { { STRING_1 , STRING_2 , 1 , STRING_3 } , <START> { STRING_1 , STRING_4 , 2 , STRING_5 } <END> } ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 ) { <START> return VAR_2 ? <END> new TYPE_1 ( VAR_3 - VAR_1 . METHOD_2 ( ) , VAR_4 ) : new TYPE_1 ( VAR_5 , VAR_4 ) ; } 
private boolean METHOD_1 ( int VAR_1 , boolean VAR_2 ) { <START> return VAR_2 ? VAR_1 > VAR_3 : <END> VAR_1 > VAR_4 - VAR_5 ; } 
public String METHOD_1 ( ) { <START> return config . get ( STRING_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( String query ) { METHOD_2 ( query ) ; <START> TYPE_2 . log ( STRING_1 , STRING_2 + query , true , VAR_1 ) ; <END> return METHOD_3 ( ) ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) { METHOD_2 ( VAR_3 ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; TYPE_1 . log ( STRING_1 , STRING_2 + VAR_1 + STRING_3 , true ) ; METHOD_2 ( VAR_4 ) ; VAR_4 . METHOD_3 ( VAR_2 ) ; TYPE_1 . log ( STRING_1 , STRING_4 + VAR_2 + STRING_3 , true ) ; VAR_5 . METHOD_4 ( ) ; <START> TYPE_1 . log ( STRING_1 , STRING_5 , true ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; <START> METHOD_3 ( VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; VAR_1 . METHOD_3 ( ) ; TYPE_2 <START> . log ( STRING_1 , STRING_2 , true ) ; <END> return new TYPE_1 ( VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; if ( METHOD_3 ( VAR_2 ) ) { VAR_3 = VAR_4 . METHOD_4 ( VAR_5 ) ; METHOD_5 ( VAR_3 ) ; } VAR_1 . METHOD_6 ( ) ; <START> TYPE_2 . log ( STRING_1 , STRING_2 , true ) ; <END> return new TYPE_1 ( VAR_6 ) ; } 
public TYPE_1 METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; <START> METHOD_3 ( VAR_1 ) ; <END> VAR_1 . METHOD_4 ( ) ; TYPE_2 . log ( STRING_1 , STRING_2 , true ) ; return new TYPE_1 ( VAR_2 ) ; } 
public void METHOD_1 ( String text ) { METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; TYPE_1 VAR_2 = VAR_3 . METHOD_4 ( VAR_4 ) ; METHOD_5 ( VAR_2 ) ; <START> METHOD_6 ( VAR_2 ) ; <END> VAR_2 . METHOD_7 ( text ) ; METHOD_8 ( VAR_2 , STRING_1 , text ) ; TYPE_2 . log ( STRING_2 , STRING_3 + text , true , VAR_5 ) ; } 
public void METHOD_1 ( int VAR_1 ) { METHOD_2 ( VAR_2 . get ( VAR_1 ) ) ; <START> if ( VAR_2 . size ( ) != 0 ) { <END> VAR_2 . get ( VAR_1 ) . METHOD_3 ( ) ; TYPE_1 . log ( STRING_1 , STRING_2 , true , VAR_3 ) ; } } 
public void METHOD_1 ( int VAR_1 ) { METHOD_2 ( VAR_2 . get ( VAR_1 ) ) ; <START> if ( VAR_2 . size ( ) != 0 ) { <END> VAR_2 . get ( VAR_1 ) . METHOD_3 ( ) ; METHOD_2 ( VAR_3 ) ; VAR_3 . METHOD_3 ( ) ; TYPE_1 . log ( STRING_1 , STRING_2 , true , VAR_4 ) ; } } 
<START> private void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { <END> METHOD_2 ( VAR_1 , STRING_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . build ( ) . METHOD_3 ( ) ; <START> TYPE_3 VAR_4 = new TYPE_3 ( VAR_2 , 5 ) ; <END> VAR_4 . METHOD_4 ( TYPE_4 . METHOD_5 ( VAR_5 ) ) ; return this ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 . VAR_4 , VAR_3 . VAR_5 , VAR_6 ) ; <START> TYPE_2 VAR_7 = VAR_1 . METHOD_3 ( VAR_6 , TYPE_5 . VAR_9 ) ; <END> VAR_7 . METHOD_4 ( ) ; String VAR_10 = VAR_7 . METHOD_5 ( ) ; TYPE_3 VAR_11 = VAR_7 . METHOD_6 ( ) ; TYPE_4 VAR_12 = VAR_11 . METHOD_6 ( ) ; VAR_12 . METHOD_7 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 . VAR_4 , VAR_3 . VAR_5 , VAR_6 ) ; <START> TYPE_2 VAR_7 = VAR_1 . METHOD_3 ( VAR_6 , TYPE_3 . VAR_9 ) ; <END> VAR_7 . METHOD_4 ( ) ; VAR_7 . METHOD_5 ( ) ; VAR_7 . METHOD_6 ( ) ; VAR_7 . METHOD_7 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 . VAR_4 , VAR_3 . VAR_5 , VAR_6 ) ; <START> TYPE_2 VAR_7 = VAR_1 . METHOD_3 ( VAR_6 , TYPE_5 . VAR_9 ) ; <END> VAR_7 . METHOD_4 ( ) ; String VAR_10 = VAR_7 . METHOD_5 ( ) ; TYPE_3 VAR_11 = VAR_7 . METHOD_6 ( ) ; TYPE_4 VAR_12 = VAR_11 . METHOD_6 ( ) ; VAR_12 . METHOD_7 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 . VAR_4 , VAR_3 . VAR_5 , VAR_6 ) ; <START> TYPE_2 VAR_7 = VAR_1 . METHOD_3 ( VAR_6 , TYPE_3 . VAR_9 ) ; <END> VAR_7 . METHOD_4 ( ) ; VAR_7 . METHOD_5 ( ) ; VAR_7 . METHOD_6 ( ) ; VAR_7 . METHOD_7 ( ) ; } 
public int METHOD_1 ( ) { METHOD_2 ( ) ; <START> int VAR_1 = - 1 ; <END> if ( METHOD_3 ( VAR_2 ) ) { VAR_1 = VAR_3 . size ( ) ; } else { VAR_1 = 0 ; } METHOD_4 ( ) ; TYPE_1 . log ( STRING_1 , STRING_2 + VAR_1 , true ) ; return VAR_1 ; } 
public int METHOD_1 ( ) { METHOD_2 ( ) ; int VAR_1 = 0 ; if ( METHOD_3 ( VAR_2 ) ) { VAR_1 = VAR_3 . size ( ) ; } METHOD_4 ( ) ; TYPE_1 . log ( STRING_1 , STRING_2 + VAR_1 , true ) ; <START> return VAR_1 ; <END> } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( INT_1 , TimeUnit . VAR_2 ) ; boolean VAR_3 = true ; try { if ( VAR_4 . METHOD_3 ( VAR_1 ) . size ( ) < 1 ) { VAR_3 = false ; } <START> } catch ( Exception ex ) { <END> VAR_3 = false ; } finally { METHOD_4 ( ) ; } return VAR_3 ; } 
public void METHOD_1 ( ) { TYPE_1 . assertTrue ( METHOD_2 ( VAR_1 ) ) ; <START> TYPE_2 . log ( STRING_1 , STRING_2 , true ) ; <END> METHOD_3 ( VAR_1 ) ; TYPE_2 . log ( STRING_1 , STRING_3 , true ) ; } 
public void METHOD_1 ( ) { TYPE_1 . assertTrue ( METHOD_2 ( VAR_1 ) ) ; TYPE_1 . assertTrue ( METHOD_2 ( VAR_2 ) ) ; <START> TYPE_2 . log ( STRING_1 , STRING_2 , true ) ; <END> METHOD_3 ( VAR_1 ) ; TYPE_2 . log ( STRING_1 , STRING_3 , true ) ; } 
public void METHOD_1 ( String VAR_1 ) { String VAR_2 = STRING_1 ; try { TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . put ( STRING_2 , VAR_1 ) ; <START> String value = VAR_3 . toString ( ) ; <END> METHOD_2 ( VAR_2 , value ) ; } catch ( TYPE_2 ex ) { TYPE_3 . log ( STRING_3 , STRING_4 + VAR_2 + STRING_5 , true ) ; } } 
public TYPE_1 METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; <START> TYPE_2 VAR_2 = new TYPE_2 ( VAR_3 ) ; <END> VAR_2 . METHOD_3 ( VAR_1 ) . METHOD_3 ( VAR_4 ) . build ( ) . METHOD_4 ( ) ; return new TYPE_1 ( VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; <START> TYPE_2 VAR_2 = VAR_3 . METHOD_4 ( TYPE_3 . METHOD_5 ( STRING_1 ) ) ; <END> METHOD_6 ( VAR_2 ) ; try { Thread . VAR_4 ( INT_1 ) ; } catch ( InterruptedException e ) { e . VAR_5 ( ) ; } VAR_2 . METHOD_7 ( ) ; TYPE_4 . log ( STRING_2 , STRING_3 , true ) ; METHOD_8 ( ) ; return new TYPE_1 ( VAR_3 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; TYPE_1 . log ( STRING_1 , STRING_2 , true ) ; <START> METHOD_3 ( VAR_1 ) ; <END> } 
public String METHOD_1 ( ) { String VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; String r = STRING_2 + VAR_1 + STRING_3 ; <START> return r ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 . get ( 0 ) ) ; <START> System . out . println ( VAR_2 . get ( 0 ) ) ; <END> System . out . println ( METHOD_4 ( VAR_2 . get ( 0 ) ) ) ; TYPE_1 . assertEquals ( METHOD_4 ( VAR_2 . get ( 0 ) ) , true ) ; } 
public String METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; String VAR_2 = VAR_3 . METHOD_3 ( STRING_1 ) ; <START> System . out . println ( VAR_2 ) ; <END> return VAR_2 ; } 
public String METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; String VAR_2 = VAR_3 . METHOD_3 ( STRING_1 ) ; <START> return VAR_2 ; <END> } 
public void METHOD_1 ( String VAR_1 ) { METHOD_2 ( VAR_2 ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; <START> TYPE_1 . log ( STRING_1 , STRING_2 , true ) ; <END> } 
public void METHOD_1 ( ) { try { METHOD_2 ( VAR_1 ) ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; METHOD_2 ( VAR_3 ) ; if ( ! VAR_3 . METHOD_5 ( STRING_1 ) . contains ( STRING_2 ) ) { TYPE_1 . log ( STRING_3 , STRING_4 , true ) ; } VAR_2 . METHOD_3 ( ) . METHOD_6 ( ) ; } catch ( Exception e ) { <START> TYPE_1 . log ( STRING_3 , STRING_5 , false ) ; <END> } } 
public void METHOD_1 ( String VAR_1 ) { <START> Integer VAR_2 = VAR_3 . size ( ) - 1 ; <END> while ( VAR_2 >= 0 ) { if ( VAR_3 . get ( VAR_2 ) . METHOD_2 ( ) . contains ( VAR_1 ) ) { break ; } VAR_2 -- ; } TYPE_1 . assertEquals ( VAR_2 . METHOD_3 ( ) , - 1 , STRING_1 ) ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) { METHOD_2 ( VAR_3 ) ; VAR_4 . METHOD_3 ( ) . METHOD_4 ( VAR_3 ) ; METHOD_2 ( VAR_5 ) ; METHOD_5 ( VAR_5 ) ; METHOD_2 ( VAR_6 ) ; METHOD_2 ( VAR_7 ) ; String VAR_8 = VAR_6 . METHOD_6 ( ) ; String VAR_9 = VAR_7 . METHOD_6 ( ) ; <START> TYPE_1 . METHOD_7 ( VAR_1 , VAR_8 ) ; <END> TYPE_1 . METHOD_7 ( VAR_2 , VAR_9 ) ; } 
public String METHOD_1 ( int VAR_1 ) { String VAR_2 = VAR_3 . get ( VAR_1 ) . METHOD_2 ( STRING_1 ) ; <START> return VAR_2 ; <END> } 
public String METHOD_1 ( int VAR_1 ) { String VAR_2 = VAR_3 . get ( VAR_1 ) . METHOD_2 ( ) ; <START> return VAR_2 ; <END> } 
public File METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; File VAR_2 = new File ( TYPE_4 . VAR_4 + STRING_1 ) ; try { TYPE_1 url = new TYPE_1 ( VAR_1 . METHOD_3 ( STRING_2 ) ) ; TYPE_2 VAR_5 = TYPE_3 . read ( url ) ; TYPE_3 . write ( VAR_5 , STRING_3 , VAR_2 ) ; } catch ( IOException e ) { <START> e . VAR_6 ( ) ; <END> } return VAR_2 ; } 
public void METHOD_1 ( ) { String VAR_1 = TYPE_3 . VAR_3 + VAR_4 . METHOD_2 ( ) ; TYPE_1 VAR_5 = <START> VAR_4 . METHOD_3 ( VAR_6 , VAR_1 ) ; <END> TYPE_2 VAR_7 = VAR_5 . METHOD_4 ( VAR_1 ) ; VAR_7 . METHOD_5 ( ) ; VAR_7 . METHOD_6 ( ) ; VAR_7 . METHOD_7 ( VAR_6 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( 10 , TimeUnit . VAR_2 ) ; <END> METHOD_5 ( VAR_3 ) ; String VAR_4 = VAR_3 . METHOD_6 ( ) ; TYPE_1 . assertEquals ( VAR_4 , STRING_1 ) ; TYPE_2 . log ( STRING_2 , STRING_3 , true ) ; } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { METHOD_2 ( VAR_1 , VAR_2 ) ; VAR_3 . METHOD_3 ( ) ; METHOD_4 ( VAR_4 ) ; TYPE_2 . log ( STRING_1 , VAR_1 + STRING_2 , <START> true , VAR_2 ) ; <END> } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 VAR_3 = VAR_2 . METHOD_2 ( TYPE_3 . METHOD_3 ( String . format ( VAR_4 , VAR_1 ) ) ) ; METHOD_4 ( VAR_3 ) ; VAR_3 . METHOD_5 ( ) ; METHOD_6 ( VAR_1 ) ; TYPE_4 . log ( STRING_1 , VAR_1 + STRING_2 , <START> true , VAR_2 ) ; <END> } 
<START> public String METHOD_1 ( ) { <END> return VAR_1 . get ( 0 ) . METHOD_2 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_3 ( ) ; <START> System . out . println ( VAR_4 . VAR_5 ) ; <END> TYPE_2 VAR_6 = VAR_1 . METHOD_4 ( VAR_4 . VAR_5 , VAR_1 . METHOD_5 ( ) ) ; VAR_6 . METHOD_6 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_3 ( ) ; <START> System . out . println ( VAR_4 . VAR_5 ) ; <END> TYPE_2 VAR_6 = VAR_1 . METHOD_4 ( VAR_4 . VAR_5 , "" ) ; VAR_6 . METHOD_5 ( ) ; } 
<START> public void METHOD_1 ( String content ) { <END> METHOD_2 ( VAR_1 ) ; VAR_1 . METHOD_3 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_3 ( content ) ; TYPE_1 . log ( STRING_1 , STRING_2 + content + STRING_3 , true ) ; } 
public String METHOD_1 ( String url ) { if ( url . contains ( STRING_1 ) ) { return url . substring ( 0 , url . VAR_1 ( STRING_1 ) ) ; } <START> else return url ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; <START> TYPE_1 . assertTrue ( VAR_2 . METHOD_3 ( STRING_1 ) . equals ( VAR_3 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 ) ; <END> VAR_1 . METHOD_3 ( ) ; TYPE_2 . log ( STRING_1 , STRING_2 , true ) ; return new TYPE_1 ( VAR_2 ) ; } 
public void METHOD_1 ( String content ) { VAR_1 . METHOD_2 ( content ) ; <START> TYPE_1 . log ( STRING_1 , STRING_2 , true , VAR_2 ) ; <END> } 
public String METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 ) ; <END> return VAR_2 . METHOD_3 ( ) ; } 
public void METHOD_1 ( String query ) { <START> boolean VAR_1 = false ; <END> for ( TYPE_1 element : VAR_2 ) { if ( element . VAR_3 ( ) . contains ( query ) ) { VAR_1 = true ; } } TYPE_2 . assertTrue ( VAR_1 , STRING_1 ) ; } 
public void METHOD_1 ( String VAR_1 ) { <START> VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> VAR_2 . METHOD_2 ( ) . METHOD_4 ( VAR_3 ) ; VAR_2 . METHOD_5 ( TYPE_1 . METHOD_6 ( STRING_1 ) ) . clear ( ) ; VAR_2 . METHOD_5 ( TYPE_1 . METHOD_6 ( STRING_1 ) ) . METHOD_7 ( VAR_1 ) ; TYPE_2 . log ( STRING_2 , STRING_3 , true ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_2 ( ) . contains ( VAR_1 ) ) { METHOD_3 ( VAR_2 ) ; } <START> break ; <END> } return new TYPE_1 ( VAR_4 ) ; } 
public void METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) ; String VAR_2 = VAR_3 . METHOD_3 ( STRING_1 ) ; VAR_3 . METHOD_4 ( VAR_1 ) ; String VAR_4 = VAR_3 . METHOD_3 ( STRING_1 ) ; <START> TYPE_1 . assertTrue ( Integer . parseInt ( VAR_4 . substring ( 0 , 1 ) ) <END> > Integer . parseInt ( VAR_2 . substring ( 0 , 1 ) ) , STRING_2 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; <START> TYPE_1 . log ( STRING_1 , STRING_2 , true , VAR_2 ) ; <END> } 
public void METHOD_1 ( String text ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <START> METHOD_4 ( VAR_3 ) ; <END> VAR_3 . METHOD_5 ( text ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; String VAR_3 = TYPE_3 . VAR_5 ; <START> VAR_1 . METHOD_5 ( VAR_3 ) ; <END> VAR_1 . METHOD_6 ( VAR_1 . METHOD_4 ( ) ) ; VAR_1 . METHOD_7 ( TYPE_2 . VAR_7 , TYPE_2 . VAR_8 , TYPE_2 . VAR_9 ) ; VAR_1 . METHOD_8 ( ) ; VAR_1 . METHOD_9 ( ) ; VAR_1 . METHOD_10 ( ) ; } 
public void METHOD_1 ( String VAR_1 ) { VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_2 . METHOD_2 ( TYPE_2 . VAR_4 ) ; TYPE_1 . log ( STRING_1 , STRING_2 <START> + VAR_1 , true , VAR_5 ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; TYPE_1 . assertTrue ( VAR_1 . METHOD_3 ( ) ) ; <START> TYPE_2 . log ( STRING_1 , STRING_2 , true , VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; <START> TYPE_1 . log ( STRING_1 , STRING_2 , true , VAR_3 ) ; <END> } 
<START> private void METHOD_1 ( String query ) { <END> METHOD_2 ( VAR_1 ) ; VAR_1 . METHOD_3 ( query ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; METHOD_3 ( ) ; <START> TYPE_1 . log ( STRING_1 , STRING_2 , true , VAR_2 ) ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> VAR_3 = METHOD_1 ( ) ; <END> this . VAR_2 = VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> TYPE_2 status = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( status ) ; VAR_1 . METHOD_3 ( METHOD_4 ( ) ) ; VAR_1 . METHOD_5 ( TYPE_3 . create ( ) ) ; VAR_1 . METHOD_6 ( TYPE_5 . TYPE_6 . METHOD_7 ( ) ) ; return VAR_1 ; } 
private TYPE_1 METHOD_1 ( ) { <START> Collection < TYPE_2 > VAR_1 = new ArrayList < > ( ) ; <END> return new TYPE_1 ( STRING_1 , "" , STRING_2 , STRING_3 , null , STRING_4 , STRING_5 , VAR_1 ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 ) { <START> super ( VAR_2 ) ; <END> VAR_3 = ( TYPE_2 ) ( ( ( TYPE_3 ) METHOD_1 ( ) ) . METHOD_2 ( ) ) ; Set VAR_4 = VAR_3 . METHOD_3 ( ) ; VAR_4 . forEach ( System . out : : println ) ; VAR_5 = VAR_4 . METHOD_4 ( ) [ 1 ] . toString ( ) ; } 
<START> public static TYPE_1 METHOD_1 ( final TYPE_2 in ) throws IOException { <END> TYPE_3 . METHOD_2 ( in , STRING_1 ) ; final List < TYPE_4 > VAR_1 = new TYPE_5 ( ) . METHOD_3 ( new TYPE_6 ( in , TYPE_7 . VAR_3 ) ) ; return new TYPE_1 ( VAR_1 ) ; } 
static boolean METHOD_1 ( final String VAR_1 ) { <START> final String VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> for ( final TYPE_1 VAR_3 : VAR_4 ) { if ( VAR_3 . matcher ( VAR_2 ) . METHOD_3 ( ) ) { return true ; } } return false ; } 
private boolean METHOD_1 ( String VAR_1 , int VAR_2 ) { try { TYPE_1 < Boolean > VAR_3 = new TYPE_1 < > ( ) ; <START> VAR_4 . METHOD_2 ( STRING_1 + VAR_1 + STRING_2 , new TYPE_2 ( ) , VAR_2 , VAR_5 - > { <END> VAR_3 . METHOD_3 ( ! VAR_5 . getStatus ( ) . equals ( TYPE_4 . VAR_7 ) ) ; } ) ; return VAR_3 . get ( ) ; } catch ( InterruptedException | TYPE_3 e ) { return Boolean . VAR_8 ; } } 
private boolean METHOD_1 ( String VAR_1 , int VAR_2 ) { try { VAR_1 = VAR_1 . METHOD_2 ( STRING_1 , "" ) ; TYPE_1 < Boolean > VAR_3 = new TYPE_1 < > ( ) ; <START> VAR_4 . METHOD_3 ( STRING_2 + VAR_1 + STRING_3 , new TYPE_2 ( ) , VAR_2 , <END> VAR_5 - > VAR_3 . METHOD_4 ( ! VAR_5 . getStatus ( ) . equals ( TYPE_4 . VAR_7 ) ) ) ; return VAR_3 . get ( ) ; } catch ( InterruptedException | TYPE_3 e ) { return Boolean . VAR_8 ; } } 
private void METHOD_1 ( TYPE_1 message ) { if ( METHOD_2 ( message , TYPE_2 . VAR_2 ) ) { METHOD_3 ( message , TYPE_2 . VAR_2 , this : : METHOD_4 ) ; } <START> LOGGER . warn ( STRING_1 + message . toString ( ) ) ; <END> } 
protected boolean METHOD_1 ( final Object value ) { <START> return value instanceof Date ; <END> } 
<START> public Boolean METHOD_1 ( ) { <END> return this . VAR_1 ; } 
public void METHOD_1 ( TYPE_1 value , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws IOException , TYPE_4 { <START> synchronized ( value ) { <END> VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( STRING_1 , value . VAR_3 ( ) ) ; VAR_1 . METHOD_4 ( ) ; } } 
public void METHOD_1 ( TYPE_1 value , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws IOException , TYPE_4 { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_3 ( STRING_3 , value . VAR_3 ) ; VAR_1 . METHOD_3 ( STRING_4 , value . values ) ; VAR_1 . METHOD_4 ( ) ; } 
private TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 VAR_1 , TYPE_1 < TYPE_2 > results ) { return results . filter ( new TYPE_4 < TYPE_2 > ( ) { @Override public boolean apply ( ANNOTATION_1 TYPE_2 event ) { <START> assert event != null ; <END> return VAR_1 == null || event . VAR_2 ( ) . METHOD_2 ( VAR_1 ) || event . VAR_2 ( ) . METHOD_3 ( VAR_1 ) ; } } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 , TYPE_4 { long VAR_2 = 1 ; TYPE_5 VAR_3 = TYPE_6 . METHOD_2 ( ) ; TYPE_7 node = VAR_3 . METHOD_3 ( TYPE_10 . VAR_5 ) ; node . add ( VAR_2 ) ; when ( VAR_6 . METHOD_4 ( ) ) . METHOD_5 ( VAR_3 ) ; TYPE_8 result = VAR_7 . METHOD_6 ( ) ; assertEquals ( TYPE_9 . VAR_8 , TYPE_9 . status ( result ) ) ; <START> METHOD_7 ( VAR_1 , METHOD_8 ( 1 ) ) . METHOD_9 ( VAR_2 ) ; <END> } 
public TYPE_2 ( ) { VAR_2 = new ArrayList < > ( ) ; <START> VAR_3 = TYPE_1 . VAR_5 ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 user ) { TYPE_1 VAR_1 = new TYPE_1 ( user ) ; <START> this . VAR_2 . create ( VAR_1 ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_2 . class ) ; VAR_2 = new TYPE_3 < TYPE_4 > ( VAR_1 ) { } ; VAR_2 . create ( new TYPE_4 ( ) ) ; try { METHOD_3 ( VAR_1 , METHOD_4 ( 1 ) ) . METHOD_5 ( VAR_2 ) ; } catch ( Exception ex ) { <START> METHOD_6 ( STRING_1 ) ; <END> } } 
public void METHOD_1 ( int VAR_1 ) throws TYPE_1 { if ( VAR_2 < VAR_1 ) throw new TYPE_1 ( ) ; <START> VAR_2 -= VAR_1 ; <END> } 
public void METHOD_1 ( String key , Object value ) { if ( VAR_1 == null ) { VAR_1 = new HashMap < String , Object > ( ) ; VAR_1 . put ( key , value ) ; } else { VAR_1 . put ( key , value ) ; <START> } <END> } 
public void METHOD_1 ( ) throws Exception { METHOD_1 ( - INT_1 , - INT_2 ) ; <START> System . out . println ( STRING_1 ) ; <END> } 
public TYPE_4 ( String user , String VAR_2 ) { super ( TYPE_3 . VAR_4 ) ; <START> VAR_5 = String . format ( STRING_1 , <END> VAR_6 , user , VAR_2 ) ; try { VAR_7 = TYPE_1 . METHOD_1 ( System . getProperty ( TYPE_1 . VAR_8 ) , null ) ; } catch ( final TYPE_2 x ) { throw new RuntimeException ( x ) ; } } 
private static int METHOD_1 ( String s ) { int start = TYPE_1 . length ( ) ; boolean VAR_1 = false ; while ( start < s . length ( ) && TYPE_2 . METHOD_2 ( s . VAR_2 ( start ) ) ) { if ( s . VAR_2 ( start ) == CHAR_1 || s . VAR_2 ( start ) == CHAR_2 ) { <START> VAR_1 = true ; <END> } else if ( VAR_1 ) { break ; } start ++ ; } return start ; } 
<START> public static void METHOD_1 ( ) { <END> TYPE_1 . METHOD_1 ( ) ; } 
public TYPE_2 ( String VAR_2 , String VAR_3 , int VAR_4 ) { METHOD_1 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; <START> this . VAR_5 = - 1 ; <END> this . VAR_6 = - 1 ; this . index = TYPE_1 . get ( ) . METHOD_2 ( ) ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) { <END> super ( VAR_2 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws TYPE_4 , TYPE_5 , TYPE_6 { TYPE_7 VAR_4 = ( TYPE_7 ) VAR_3 ; if ( StringUtils . VAR_5 ( VAR_1 . METHOD_2 ( ) ) && ! METHOD_3 ( VAR_4 , VAR_1 . METHOD_2 ( ) ) ) { return ; } <START> TYPE_8 VAR_6 = new TYPE_9 ( ) . METHOD_4 ( VAR_4 , VAR_7 ) ; <END> VAR_6 . METHOD_5 ( VAR_2 . getName ( ) ) ; VAR_2 . METHOD_6 ( VAR_6 ) ; } 
public TYPE_2 ( String name , String VAR_2 , String VAR_3 ) { <START> this . name = name ; <END> this . VAR_4 = new TYPE_1 ( ) ; METHOD_1 ( VAR_3 ) ; METHOD_2 ( VAR_2 ) ; } 
public static Set < TYPE_1 > METHOD_1 ( ) { <START> return new TYPE_2 < > ( getInstance ( ) . VAR_1 . values ( ) ) ; <END> } 
private static long METHOD_1 ( final File VAR_1 ) { try ( TYPE_1 stream = new TYPE_1 ( new TYPE_2 ( TYPE_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) , new TYPE_4 ( ) ) ; ) { TYPE_5 . METHOD_4 ( stream , VAR_1 . length ( ) ) ; return stream . VAR_2 ( ) . getValue ( ) ; } catch ( final IOException VAR_3 ) { } <START> return System . currentTimeMillis ( ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { List < TYPE_1 > VAR_2 = METHOD_2 ( ) ; for ( TYPE_1 VAR_3 : VAR_2 ) { <START> if ( VAR_3 . getType ( ) != null ) { <END> if ( VAR_1 . equals ( VAR_3 . getType ( ) . getName ( ) ) ) { return VAR_3 ; } } else { TYPE_2 name = VAR_3 . METHOD_3 ( TYPE_2 . class ) ; if ( name != null && TYPE_3 . METHOD_4 ( name , VAR_1 ) ) { return VAR_3 ; } } } return null ; } 
<START> private Boolean METHOD_1 ( final List < TYPE_3 . TYPE_4 > VAR_1 ) { <END> return VAR_1 . stream ( ) . METHOD_2 ( VAR_2 - > TYPE_2 . equals ( VAR_2 . METHOD_3 ( ) ) ) ; } 
<START> private Boolean METHOD_1 ( final TYPE_4 . TYPE_6 ctx ) { <END> if ( ctx == null || ctx . VAR_1 ( ) == null ) { return false ; } final List < TYPE_4 . TYPE_5 > VAR_1 = ctx . VAR_1 ( ) . METHOD_2 ( ) ; return VAR_1 . size ( ) == 1 && TYPE_3 . equals ( VAR_1 . get ( 0 ) . METHOD_3 ( ) . METHOD_4 ( ) ) ; } 
<START> public String METHOD_1 ( ) { <END> return METHOD_2 ( ) ; } 
public void METHOD_1 ( ) throws IOException { final String VAR_1 = TYPE_1 . toString ( TYPE_2 . class . METHOD_2 ( STRING_1 ) , TYPE_5 . VAR_3 ) ; TYPE_3 VAR_4 = parse ( VAR_1 ) ; <START> System . out . println ( VAR_4 . METHOD_3 ( ) ) ; <END> assertTrue ( TYPE_4 . METHOD_4 ( ) != VAR_4 . METHOD_3 ( ) . get ( 0 ) ) ; assertEquals ( INT_1 , VAR_4 . size ( ) ) ; } 
<START> public List < TYPE_1 < ? > > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <END> return METHOD_2 ( VAR_1 , VAR_2 ) ; } 
public static Optional < TYPE_1 > METHOD_1 ( String token ) { <START> return Optional . VAR_1 ( TYPE_2 . get ( token ) ) ; <END> } 
<START> TYPE_1 METHOD_1 ( ) { <END> return ( TYPE_1 ) METHOD_2 ( METHOD_3 ( ) - 1 ) ; } 
<START> public TYPE_1 ( int id ) { <END> super ( id ) ; } 
default < T > List < T > VAR_1 ( Class < T > VAR_2 ) { final List < T > list = new ArrayList < > ( ) ; TYPE_1 . VAR_1 ( this , VAR_2 , list , false ) ; <START> return list ; <END> } 
private void METHOD_1 ( TYPE_1 node , Object data , String VAR_1 ) { <START> if ( ! METHOD_2 ( node ) ) { <END> TYPE_2 VAR_2 = node . VAR_3 ( ) ; if ( METHOD_3 ( VAR_1 , STRING_1 ) && ! VAR_2 . METHOD_4 ( ) ) { METHOD_5 ( data , node , STRING_2 , new Object [ ] { VAR_1 } ) ; } } } 
public List < File > METHOD_1 ( File VAR_1 , TYPE_1 filter , boolean VAR_2 ) { this . filter = filter ; List < File > VAR_3 = new ArrayList < > ( ) ; METHOD_2 ( VAR_1 , VAR_3 , VAR_2 ) ; Collections . VAR_4 ( VAR_3 , new TYPE_2 < File > ( ) { @Override public int METHOD_3 ( File VAR_5 , File VAR_6 ) { <START> return VAR_5 . getPath ( ) . METHOD_4 ( VAR_6 . getPath ( ) ) ; <END> } } ) ; return VAR_3 ; } 
TYPE_1 ( Class < ? > VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> } 
protected void METHOD_1 ( ) { String [ ] VAR_1 = getClass ( ) . METHOD_2 ( ) . getName ( ) . split ( STRING_1 ) ; <START> String VAR_2 = VAR_1 [ VAR_1 . length - 1 ] ; <END> String VAR_3 = VAR_1 [ VAR_1 . length - 3 ] ; String VAR_4 = STRING_2 + VAR_3 + STRING_3 + VAR_2 + STRING_4 ; METHOD_3 ( VAR_4 , getClass ( ) . METHOD_4 ( ) . METHOD_5 ( STRING_5 , "" ) ) ; } 
private List < String > METHOD_1 ( Class [ ] VAR_1 ) { return Arrays . asList ( VAR_1 ) . stream ( ) . filter ( VAR_2 - > VAR_2 . METHOD_2 ( ) . startsWith ( STRING_1 ) ) <START> . map ( m - > m . VAR_3 ( ) . substring ( ( STRING_1 ) . length ( ) ) ) <END> . collect ( Collectors . VAR_4 ( ) ) ; } 
public String METHOD_1 ( ) { String VAR_1 = VAR_2 . getValue ( ) . stream ( ) . map ( p - > File . VAR_3 + p . VAR_4 ( ) ) <START> . collect ( Collectors . VAR_5 ( "" ) ) ; <END> return VAR_1 ; } 
private static TYPE_1 [ ] METHOD_1 ( List < File > VAR_1 ) throws IOException { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( File f : VAR_1 ) { <START> METHOD_2 ( VAR_2 , f . VAR_3 ( ) . METHOD_3 ( ) ) ; <END> } return VAR_2 . METHOD_4 ( new TYPE_1 [ VAR_2 . size ( ) ] ) ; } 
<START> public static TYPE_1 METHOD_1 ( ) { <END> if ( ! VAR_1 ) { return VAR_2 ; } return METHOD_2 ( TYPE_2 . VAR_4 ) ; } 
public String METHOD_1 ( ) { if ( METHOD_2 ( ) ) { <START> return METHOD_3 ( ) ; <END> } TYPE_1 VAR_1 = METHOD_4 ( TYPE_1 . class ) ; if ( VAR_1 != null ) { return VAR_1 . METHOD_3 ( ) ; } return METHOD_4 ( TYPE_2 . class ) . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; <START> TYPE_1 n = VAR_2 . METHOD_3 ( TYPE_2 . class ) . get ( 0 ) <END> . METHOD_4 ( TYPE_1 . class ) ; assertTrue ( n . VAR_3 ( ) instanceof TYPE_3 ) ; } 
protected Collection < String > METHOD_1 ( ) { Collection < String > VAR_1 = new HashSet < > ( ) ; VAR_1 . add ( STRING_1 ) ; <START> return VAR_1 ; <END> } 
protected Collection < String > METHOD_1 ( ) { <START> Collection VAR_1 = new ArrayList < String > ( ) ; <END> VAR_1 . add ( STRING_1 ) ; return VAR_1 ; } 
public void METHOD_1 ( final TYPE_1 cache ) { <START> if ( cache == null && METHOD_2 ( ) ) { <END> VAR_1 = new TYPE_2 ( ) ; } else { VAR_1 = cache ; } } 
static boolean METHOD_1 ( TYPE_1 node ) { List < TYPE_2 > VAR_1 = node . VAR_2 ( ) . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; boolean VAR_3 = false ; for ( TYPE_2 VAR_4 : VAR_1 ) { if ( METHOD_5 ( VAR_4 . METHOD_6 ( ) ) ) { <START> VAR_3 = true ; <END> break ; } } return VAR_3 ; } 
private void METHOD_1 ( ) { <START> if ( METHOD_2 ( ) ) { <END> final String VAR_1 = getProperty ( VAR_2 ) ; final String version = getProperty ( VAR_3 ) ; METHOD_3 ( version ) ; VAR_4 . METHOD_4 ( VAR_1 ) ; VAR_4 . METHOD_5 ( version ) ; VAR_4 . METHOD_6 ( METHOD_7 ( ) ) ; } } 
private void METHOD_1 ( final String version ) { <START> if ( TYPE_1 . equals ( version ) ) { <END> VAR_1 = new TYPE_2 ( ) ; } else { VAR_1 = new TYPE_3 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { if ( value == null ) { <START> final Object v = VAR_1 . getValue ( ) ; <END> value = TYPE_3 . METHOD_2 ( v ) ; } return value ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { TYPE_1 VAR_3 = VAR_1 ; <START> for ( int i = 0 ; i < 10 && VAR_3 != null && VAR_3 != VAR_2 ; i ++ ) { <END> VAR_3 = VAR_3 . METHOD_2 ( ) ; if ( VAR_3 instanceof TYPE_2 ) { return true ; } } return false ; } 
public TYPE_4 ( final TYPE_1 VAR_2 ) { this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 ) ; <START> VAR_3 = new TYPE_3 ( ) ; <END> VAR_4 = new ArrayList < > ( ) ; VAR_5 = false ; } 
<START> TYPE_1 ( Throwable VAR_2 ) { <END> super ( VAR_2 ) ; } 
<START> TYPE_1 METHOD_1 ( String id ) { <END> return VAR_1 . get ( id ) ; } 
<START> void METHOD_1 ( String id ) { <END> VAR_1 . remove ( id ) ; } 
public void METHOD_1 ( TYPE_1 location , TYPE_2 VAR_1 ) { <START> VAR_2 . METHOD_2 ( VAR_3 - > new TYPE_3 ( ) ) ; <END> VAR_4 . METHOD_2 ( VAR_3 - > new TYPE_4 ( ) ) ; VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ( VAR_5 , VAR_6 , VAR_7 ) - > { if ( VAR_7 != null && VAR_7 . getValue ( ) instanceof TYPE_5 ) { parent . VAR_8 ( ( TYPE_5 ) VAR_7 . getValue ( ) ) ; } } ) ; } 
public void METHOD_1 ( final int VAR_1 ) { if ( 0 <= VAR_1 && VAR_1 < METHOD_2 ( ) ) { VAR_2 = TYPE_1 . remove ( VAR_2 , VAR_1 ) ; <START> for ( int i = 0 ; i < METHOD_2 ( ) ; i ++ ) { <END> METHOD_3 ( i ) . METHOD_4 ( i ) ; } } } 
protected Class < ? > METHOD_1 ( final String name , final boolean VAR_1 ) throws TYPE_1 { Class < ? > c = METHOD_2 ( name ) ; if ( c == null ) { <START> if ( c == null ) { <END> try { c = METHOD_3 ( name ) ; } catch ( final TYPE_1 e ) { c = super . METHOD_1 ( name , VAR_1 ) ; } } } if ( VAR_1 ) { METHOD_4 ( c ) ; } return c ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . size ( ) == 1 ; <END> } 
public < T > List < T > METHOD_1 ( Class < T > VAR_1 ) { List < T > VAR_2 = new ArrayList < > ( ) ; TYPE_1 VAR_3 = METHOD_2 ( ) ; while ( VAR_3 != null ) { <START> if ( VAR_1 . METHOD_3 ( VAR_3 . getClass ( ) ) ) { <END> VAR_2 . add ( ( T ) VAR_3 ) ; } VAR_3 = VAR_3 . METHOD_2 ( ) ; } return VAR_2 ; } 
public TYPE_3 ( String VAR_2 , String VAR_3 , Map < String , TYPE_1 > VAR_4 , TYPE_1 VAR_5 , Class < TYPE_1 > VAR_6 , float VAR_7 ) { super ( VAR_2 , VAR_3 , VAR_5 , VAR_7 ) ; <START> this . VAR_6 = VAR_6 ; <END> VAR_8 = Collections . VAR_9 ( VAR_4 ) ; VAR_10 = Collections . VAR_9 ( TYPE_2 . METHOD_1 ( VAR_8 ) ) ; } 
<START> public Object METHOD_1 ( ) { <END> return new Object ANNOTATION_1 [ 0 ] ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 == null ) <END> VAR_2 = new TYPE_2 ( 1 , TimeUnit . VAR_3 ) ; METHOD_2 ( VAR_1 ) ; if ( VAR_4 ) { VAR_5 = METHOD_3 ( VAR_5 ) ; } return ( new TYPE_3 ( VAR_1 , METHOD_4 ( ) ) ) ; } 
public TYPE_2 ( String [ ] VAR_2 ) { this . VAR_2 = new TYPE_1 < > ( ) ; <START> this . VAR_3 = new HashSet < > ( ) ; <END> Collections . addAll ( this . VAR_2 , VAR_2 ) ; } 
<START> public synchronized void METHOD_1 ( Map < ? , ? > t ) { <END> for ( Map . Entry < ? , ? > entry : t . entrySet ( ) ) { this . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } 
public TYPE_3 ( ) { <START> super ( TYPE_1 . METHOD_1 ( TYPE_1 . METHOD_2 ( ) , TYPE_2 . METHOD_3 ( INT_1 ) ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 . METHOD_1 ( TYPE_2 . METHOD_2 ( METHOD_3 ( VAR_1 . METHOD_4 ( ) ) , <END> VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) , VAR_1 . getMessage ( ) ) ) ; VAR_3 . set ( Boolean . VAR_4 ) ; } 
public TYPE_1 build ( ) { TYPE_1 source = VAR_1 == null ? new TYPE_1 ( VAR_2 , VAR_3 , METHOD_1 ( ) ) : new TYPE_1 ( VAR_1 , VAR_3 , METHOD_1 ( ) ) ; <START> source . VAR_4 ( id ) ; <END> return source ; } 
public TYPE_1 build ( ) { TYPE_1 source = VAR_1 == null ? new TYPE_1 ( VAR_2 , VAR_3 , METHOD_1 ( ) ) : new TYPE_1 ( VAR_1 , VAR_3 , METHOD_1 ( ) ) ; <START> if ( id != null ) { <END> source . VAR_4 ( id ( ) ) ; } return source ; } 
<START> @Override protected void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( ) ; } 
<START> @Override public final String toString ( ) { <END> return VAR_1 . METHOD_1 ( ) ; } 
public static TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 source , ANNOTATION_1 TYPE_1 VAR_1 ) { for ( TYPE_3 m : TYPE_4 . METHOD_2 ( TYPE_3 . class ) ) { <START> if ( m . VAR_2 . equals ( source . getClass ( ) ) <END> && m . VAR_3 . equals ( VAR_1 . getClass ( ) ) ) { TYPE_1 VAR_4 = m . VAR_5 ( source , VAR_1 ) ; if ( VAR_4 != null ) { return VAR_4 ; } } } return VAR_1 ; } 
<START> public TYPE_1 ( ) { <END> super ( STRING_1 , Messages . VAR_2 ( ) ) ; } 
public < T extends TYPE_1 > T METHOD_1 ( ANNOTATION_1 Class < T > type ) { <START> return TYPE_2 . class . equals ( type ) ? ( T ) new TYPE_2 ( ) { } : null ; <END> } 
<START> public List < TYPE_1 > METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 , <END> ANNOTATION_2 TYPE_3 event , ANNOTATION_1 TYPE_4 listener ) throws IOException , InterruptedException { return Collections . VAR_2 ( ) ; } 
<START> @Override public TYPE_1 METHOD_1 ( String name ) { <END> return null ; } 
public void put ( String VAR_1 , String key , String value ) { if ( VAR_2 . containsKey ( VAR_1 ) ) { VAR_2 . get ( VAR_1 ) . METHOD_1 ( ) . METHOD_2 ( key , value ) ; } else { <START> TYPE_1 parse = TYPE_1 . empty ; <END> parse . put ( key , value ) ; VAR_2 . put ( VAR_1 , parse ) ; } } 
public void METHOD_1 ( String key , String [ ] values ) { <START> VAR_1 . put ( key , values ) ; <END> } 
public static TYPE_1 . Builder METHOD_1 ( TYPE_1 . Builder builder ) { if ( TYPE_2 . VAR_2 . VAR_3 >= TYPE_2 . VAR_4 . VAR_5 ) { <START> return builder . VAR_6 ( TYPE_3 . VAR_8 ) . METHOD_2 ( TYPE_3 . VAR_9 ) ; <END> } return builder ; } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> VAR_1 = new TYPE_1 ( ) . METHOD_2 ( STRING_1 ) <END> . METHOD_3 ( TYPE_1 . TYPE_4 . VAR_3 ) . METHOD_4 ( TYPE_1 . TYPE_3 . VAR_5 ) . METHOD_5 ( new Date ( ) ) . METHOD_6 ( STRING_2 ) ; VAR_6 = new TYPE_1 ( VAR_1 ) . METHOD_2 ( STRING_3 ) . METHOD_3 ( TYPE_1 . TYPE_4 . VAR_7 ) . METHOD_4 ( TYPE_1 . TYPE_3 . VAR_8 ) ; context = TYPE_2 . METHOD_7 ( ) ; } 
protected void METHOD_1 ( String result ) { a . VAR_1 ( false ) ; if ( result != null && result . length ( ) > 0 ) { TYPE_1 . METHOD_2 ( a , result , TYPE_1 . VAR_2 ) . METHOD_3 ( ) ; } if ( VAR_3 == VAR_4 || VAR_3 == VAR_5 || VAR_3 == VAR_6 ) { a . VAR_7 ( ) ; } else { a . VAR_8 ( ) ; } <START> METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 item ) { try { String id = item . getId ( ) ; if ( id != null ) { item . VAR_1 ( METHOD_2 ( id ) ) ; item . VAR_2 ( METHOD_3 ( id , item . VAR_3 ( ) ) ) ; } VAR_4 . add ( item . VAR_5 ( ) , item ) ; <START> } catch ( TYPE_2 ex ) { <END> VAR_4 . add ( item ) ; } METHOD_4 ( ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_1 item : this . VAR_2 ) { String id = item . getId ( ) ; <START> if ( id != null && ( id . startsWith ( VAR_1 ) && ! TYPE_2 . equals ( id ) || id . startsWith ( VAR_3 ) ) ) { <END> VAR_2 . add ( item ) ; } } return VAR_2 ; } 
private List < String > METHOD_1 ( TYPE_1 VAR_1 , ANNOTATION_1 String VAR_2 ) { List < String > list = new ArrayList < > ( ) ; if ( VAR_1 != null ) { for ( int i = 0 ; i < VAR_1 . length ( ) ; i ++ ) { String id = VAR_1 . METHOD_2 ( i ) ; <START> if ( id . startsWith ( VAR_3 ) ) { <END> list . add ( id ) ; } else { list . add ( VAR_2 + id ) ; } } } return list ; } 
public TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , <START> VAR_13 , VAR_14 , VAR_15 , VAR_16 , VAR_17 , VAR_18 , VAR_19 , <END> VAR_20 , VAR_21 , VAR_22 , VAR_23 , VAR_24 ) ; } 
protected List < TYPE_1 > METHOD_1 ( ) { <START> ArrayList < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; <END> VAR_1 . add ( TYPE_2 . VAR_3 ) ; VAR_1 . add ( TYPE_4 . VAR_3 ) ; VAR_1 . add ( TYPE_3 . VAR_3 ) ; return VAR_1 ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . VAR_2 != 0 ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 ) { TYPE_1 VAR_2 = null ; for ( TYPE_1 VAR_3 : VAR_4 ) { if ( VAR_3 instanceof TYPE_3 ) { if ( ( ( TYPE_3 ) VAR_3 ) . getType ( ) == VAR_1 ) { <START> VAR_2 = VAR_3 ; <END> } } } return VAR_2 ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = ctx . VAR_2 ( ) ; <END> METHOD_2 ( ) ; METHOD_3 ( ) ; for ( TYPE_2 VAR_3 : VAR_4 ) { METHOD_4 ( VAR_3 ) ; } VAR_1 . METHOD_5 ( ) ; VAR_1 . METHOD_6 ( ) ; VAR_1 . METHOD_7 ( ) ; METHOD_8 ( ) ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . VAR_2 ; <END> } 
public void METHOD_1 ( TYPE_3 . TYPE_4 . TYPE_5 location , boolean VAR_2 ) { if ( VAR_3 . METHOD_2 ( ) ) { return ; } if ( location != null ) { METHOD_3 ( ) ; } if ( VAR_2 ) { METHOD_4 ( location ) ; } <START> VAR_4 . METHOD_5 ( ) . METHOD_6 ( location , VAR_4 . METHOD_7 ( ) . VAR_5 ) ; <END> TYPE_2 . METHOD_8 ( location ) ; VAR_4 . METHOD_9 ( ) . METHOD_6 ( location ) ; VAR_4 . METHOD_10 ( ) . METHOD_11 ( location ) ; } 
TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 ; if ( METHOD_2 ( ) ) { VAR_1 = new TYPE_1 ( METHOD_3 ( ) . METHOD_4 ( ) , METHOD_3 ( ) . METHOD_5 ( ) ) ; } else { <START> VAR_1 = new TYPE_1 ( 0 , 0 ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 event ) { if ( event . VAR_1 . getType ( ) == TYPE_2 . VAR_3 ) { if ( event . values [ 0 ] >= - VAR_4 && event . values [ 0 ] <= VAR_4 ) { <START> if ( METHOD_2 ( ) ) { <END> METHOD_3 ( ) ; } } } } 
<START> public static boolean METHOD_1 ( long id ) { <END> return VAR_1 . remove ( id ) != null ; } 
<START> private void METHOD_1 ( TYPE_1 db , int VAR_1 , int VAR_2 ) { <END> db . VAR_3 ( STRING_1 + VAR_4 ) ; db . VAR_3 ( STRING_1 + VAR_5 ) ; METHOD_2 ( db ) ; } 
public Set < String > METHOD_1 ( ) { Set < String > result = new TYPE_1 < > ( ) ; String VAR_1 = TYPE_2 . get ( ) ; <START> if ( VAR_1 != null ) <END> Collections . addAll ( result , VAR_1 . split ( STRING_1 ) ) ; return result ; } 
public boolean METHOD_1 ( int VAR_1 ) { <START> if ( VAR_1 <= VAR_2 && VAR_1 >= VAR_3 ) { <END> return true ; } else { return false ; } } 
private static int METHOD_1 ( TYPE_1 channel ) { ByteBuffer VAR_1 = ByteBuffer . VAR_2 ( VAR_3 ) ; int result = - 1 ; try { while ( VAR_1 . METHOD_2 ( ) && ( channel . read ( VAR_1 ) >= 0 ) ) { } if ( ! VAR_1 . METHOD_2 ( ) ) { VAR_1 . METHOD_3 ( ) ; result = VAR_1 . METHOD_4 ( ) . get ( 0 ) ; } } catch ( Exception VAR_4 ) { <START> } <END> return result ; } 
public String getPath ( ) { try { TYPE_1 url = new TYPE_1 ( METHOD_1 ( ) ) ; return url . getPath ( ) ; } catch ( TYPE_2 e ) { <START> return "" ; <END> } } 
public String getProperty ( String key ) { if ( properties != null && ! properties . isEmpty ( ) ) { if ( properties . containsKey ( key ) ) { return properties . get ( key ) ; } else { String VAR_1 = TYPE_1 . VAR_3 + key ; if ( properties . containsKey ( VAR_1 ) ) { return properties . get ( VAR_1 ) ; } } } <START> return "" ; <END> } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , int VAR_3 ) { long start = System . currentTimeMillis ( ) ; <START> if ( ! METHOD_1 ( VAR_1 , VAR_2 ) ) return false ; <END> long t ; if ( ( t = System . currentTimeMillis ( ) - start ) < VAR_3 ) { TYPE_2 . METHOD_1 ( ( int ) ( VAR_3 - t ) ) ; } return true ; } 
public int METHOD_1 ( TYPE_1 o ) { <START> if ( this . METHOD_2 ( ) . equalsIgnoreCase ( o . VAR_1 ( ) ) ) <END> return 1 ; return this . METHOD_2 ( ) . METHOD_1 ( o . VAR_1 ( ) ) ; } 
public void METHOD_1 ( int version , int VAR_1 , String name , String VAR_2 , String VAR_3 , String [ ] VAR_4 ) { this . VAR_5 = name ; super . METHOD_1 ( version , VAR_1 , name , VAR_2 , VAR_3 , VAR_4 ) ; <START> if ( VAR_6 != null ) <END> VAR_6 . println ( VAR_5 + STRING_1 ) ; } 
public static TYPE_1 getInstance ( final TYPE_2 VAR_1 ) { TYPE_1 result = instance ; if ( result == null ) { synchronized ( TYPE_1 . class ) { if ( result == null ) { <START> result = instance ; <END> instance = result = new TYPE_1 ( ) ; result . VAR_2 = VAR_1 ; } } } return result ; } 
private TYPE_3 ( final String url ) { TYPE_1 VAR_2 = null ; try { VAR_2 = new TYPE_1 ( url ) ; } catch ( TYPE_2 e ) { <START> LOG . info ( TYPE_4 . VAR_4 , e ) ; <END> } if ( VAR_2 == null ) { return ; } VAR_5 = VAR_2 . METHOD_1 ( VAR_6 ) ; } 
public final void METHOD_1 ( final TYPE_1 parent ) { try { METHOD_2 ( parent , METHOD_3 ( ) , STRING_1 , VAR_1 , this . METHOD_4 ( ) , TYPE_2 . class ) ; } catch ( TYPE_3 e ) { <START> LOG . info ( TYPE_4 . VAR_3 , e ) ; <END> } } 
public void METHOD_1 ( final String VAR_1 , final String VAR_2 , final String VAR_3 , final TYPE_1 VAR_4 ) throws TYPE_2 { <START> LOG . info ( STRING_1 , VAR_1 ) ; <END> LOG . info ( STRING_2 , VAR_2 ) ; TYPE_3 . METHOD_2 ( getInstance ( ) . VAR_5 , VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; } 
private int METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( this ) ; short VAR_3 = 0 ; boolean VAR_4 = VAR_1 . METHOD_4 ( TYPE_1 . VAR_5 ) ; if ( ! VAR_4 ) VAR_3 = TYPE_4 . VAR_7 ; else if ( VAR_8 && ( VAR_9 == null || VAR_9 . METHOD_5 ( ) > TYPE_3 . VAR_11 ) ) VAR_3 = TYPE_4 . VAR_12 ; else VAR_3 = TYPE_4 . VAR_13 ; <START> TYPE_2 db = new TYPE_2 ( this ) ; <END> return VAR_3 ; } 
private List < TYPE_1 > METHOD_1 ( ) { TYPE_2 db = new TYPE_2 ( this ) ; List < TYPE_1 > VAR_1 ; VAR_1 = db . VAR_2 ( ) ; <START> TYPE_1 [ ] VAR_3 = new TYPE_1 [ 0 ] ; <END> return VAR_1 ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { METHOD_1 ( VAR_2 ) ; <START> this . VAR_2 = VAR_2 ; <END> } 
<START> public TYPE_1 METHOD_1 ( ) throws IllegalStateException { <END> throw new TYPE_2 ( ) ; } 
private List < TYPE_1 < TYPE_2 > > METHOD_1 ( final List < TYPE_3 > VAR_1 ) throws InterruptedException { TYPE_4 VAR_2 = TYPE_5 . METHOD_2 ( VAR_3 . size ( ) ) ; <START> final List < TYPE_1 < TYPE_2 > > VAR_4 = VAR_2 <END> . METHOD_3 ( VAR_1 , VAR_5 * VAR_6 , TimeUnit . VAR_7 ) ; VAR_2 . METHOD_4 ( ) ; return VAR_4 ; } 
public void METHOD_1 ( final TYPE_1 < Integer > VAR_1 ) { METHOD_2 ( VAR_1 ) ; <START> synchronized ( VAR_2 ) { <END> this . VAR_3 . add ( VAR_1 ) ; } } 
public void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 . values ( ) ) { <START> VAR_1 . run ( ) ; <END> } } 
public < T > TYPE_1 < T > METHOD_1 ( String name , TYPE_1 < T > VAR_1 ) { METHOD_2 ( name ) ; METHOD_3 ( VAR_1 ) ; String VAR_2 = name ( name ) ; <START> TYPE_1 < T > VAR_3 = ( TYPE_1 < T > ) VAR_4 . get ( VAR_2 ) ; <END> if ( VAR_3 == null ) { VAR_3 = VAR_5 . METHOD_4 ( VAR_2 , VAR_1 ) ; } return VAR_3 ; } 
public TYPE_4 ( TYPE_1 connection ) { METHOD_1 ( connection ) ; TYPE_2 VAR_2 = ( ( TYPE_3 ) connection ) . METHOD_2 ( ) ; METHOD_1 ( VAR_2 ) ; <START> METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <END> VAR_3 = connection ; } 
private String METHOD_1 ( ) { <START> return new File ( VAR_1 , STRING_1 ) . METHOD_2 ( ) ; <END> } 
public boolean METHOD_1 ( Map < String , Object > info ) throws Exception { <START> return TYPE_1 . METHOD_2 ( info ) || TYPE_2 . METHOD_3 ( info ) <END> || TYPE_3 . METHOD_4 ( info ) || TYPE_4 . METHOD_5 ( info ) ; } 
public final ANNOTATION_1 TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = VAR_2 . stream ( ) ; VAR_1 = TYPE_1 . METHOD_2 ( VAR_3 . stream ( ) . METHOD_3 ( Set : : stream ) , VAR_1 ) ; <START> return VAR_2 . stream ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 entity , TYPE_2 status ) { <START> METHOD_2 ( entity , STRING_1 ) ; <END> ( ( TYPE_3 ) entity ) . METHOD_3 ( VAR_1 , status ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { try { VAR_1 . start ( ImmutableList . of ( VAR_2 . METHOD_2 ( ) ) ) ; METHOD_3 ( STRING_1 ) ; } catch ( Exception e ) { <START> Throwable t = TYPE_2 . METHOD_4 ( e , TYPE_3 . class ) ; <END> assertTrue ( t != null , STRING_2 + TYPE_3 . class . getName ( ) + STRING_3 + e ) ; } } 
protected TYPE_1 < ? > METHOD_1 ( ) { ANNOTATION_1 ( STRING_1 ) TYPE_1 < TYPE_2 > VAR_1 = ( TYPE_1 < TYPE_2 > ) METHOD_2 ( VAR_2 , TYPE_1 . create ( TYPE_2 . class ) ) ; <START> VAR_1 . METHOD_3 ( TYPE_2 . VAR_3 , METHOD_2 ( TYPE_3 . VAR_3 ) ) <END> . METHOD_3 ( TYPE_2 . VAR_5 , STRING_2 + VAR_6 . METHOD_4 ( ) ) ; return VAR_1 ; } 
public Map < String , String > METHOD_1 ( ) { TYPE_1 < String , String > result = TYPE_1 . METHOD_2 ( super . METHOD_1 ( ) ) ; <START> result . put ( STRING_1 , "" + METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> return result ; } 
private Boolean METHOD_1 ( ) { <START> return Optional . VAR_1 ( entity . VAR_2 ( TYPE_1 . VAR_3 ) ) . METHOD_2 ( Boolean . VAR_4 ) ; <END> } 
public static < T > TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_2 parent ) { return new TYPE_1 < TYPE_2 > ( ) { @Override <START> public boolean apply ( ANNOTATION_1 TYPE_2 input ) { <END> return TYPE_3 . METHOD_2 ( input . VAR_1 ( ) , parent ) ; } } ; } 
public static < T > TYPE_1 < TYPE_2 > METHOD_1 ( final T val ) { return new TYPE_1 < TYPE_2 > ( ) { @Override <START> public boolean apply ( ANNOTATION_1 TYPE_2 input ) { <END> return TYPE_3 . METHOD_2 ( input . VAR_1 ( ) , val ) ; } } ; } 
public static < T > TYPE_1 < TYPE_2 > METHOD_1 ( final T val ) { return new TYPE_1 < TYPE_2 > ( ) { @Override <START> public boolean apply ( ANNOTATION_1 TYPE_2 input ) { <END> return TYPE_3 . METHOD_2 ( input . getId ( ) , val ) ; } } ; } 
public static < T > TYPE_1 < T > METHOD_1 ( TYPE_1 < T > token , Class < ? super T > VAR_1 ) { if ( VAR_1 != null ) return TYPE_1 . of ( ( Class < T > ) VAR_1 ) ; <START> if ( token != null ) return token ; <END> throw new IllegalStateException ( STRING_1 ) ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , Integer VAR_5 , Integer VAR_6 , String VAR_7 , Integer VAR_8 , Integer VAR_9 , Integer VAR_10 , Integer VAR_11 , Integer VAR_12 , Integer VAR_13 ) { <START> ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , <END> VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 ) ; } 
public static File METHOD_1 ( File VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) ) return VAR_1 ; boolean VAR_2 = VAR_1 . METHOD_1 ( ) ; if ( ! VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) ) return VAR_1 ; throw TYPE_1 . METHOD_3 ( new IOException ( STRING_1 + VAR_1 + ( VAR_1 . METHOD_4 ( ) ? STRING_2 : "" ) ) ) ; <START> } <END> return VAR_1 ; } 
public int execute ( List < String > VAR_1 , String VAR_2 ) { if ( VAR_3 ) { throw new TYPE_1 ( STRING_1 ) ; } <START> return super . execute ( VAR_1 , VAR_2 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < Object > t = new TYPE_1 < Object > ( ) ; <START> TYPE_2 . METHOD_2 ( t ) ; <END> VAR_1 = TYPE_3 . METHOD_3 ( TYPE_4 . class ) ; VAR_2 = VAR_1 . METHOD_4 ( ) ; TYPE_5 VAR_3 = VAR_2 . METHOD_5 ( ) . METHOD_6 ( TYPE_6 . create ( TYPE_5 . class ) ) ; host = VAR_3 . METHOD_7 ( ) ; VAR_1 . start ( Arrays . asList ( host ) ) ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 ; if ( VAR_1 == null ) { TYPE_2 . METHOD_2 ( STRING_1 ) ; synchronized ( VAR_3 ) { VAR_1 = VAR_2 ; if ( VAR_1 == null ) { VAR_2 = VAR_1 = TYPE_3 . METHOD_3 ( this ) ; } } <START> TYPE_2 . METHOD_4 ( ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( ) { log . info ( STRING_1 + builder ) ; TYPE_1 properties = builder . build ( ) ; VAR_1 = properties ; if ( VAR_2 != null ) { log . info ( STRING_2 + VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; } this . VAR_3 = TYPE_2 . METHOD_3 ( VAR_1 ) ; this . VAR_4 = null ; for ( TYPE_3 listener : VAR_5 ) { <START> if ( listener != null ) <END> listener . VAR_6 ( ) ; } } 
public static Throwable METHOD_1 ( TYPE_1 < ? > t ) { if ( t == null ) return null ; if ( ! t . VAR_1 ( ) ) return null ; if ( t . VAR_2 ( ) ) return new TYPE_2 ( ) ; try { t . get ( ) ; return null ; } catch ( Throwable error ) { <START> TYPE_3 . METHOD_2 ( error ) ; <END> return error ; } } 
protected void METHOD_1 ( Exception e , String context ) { TYPE_1 . METHOD_2 ( e ) ; if ( METHOD_3 ( ) ) { LOG . warn ( STRING_1 + context , e ) ; } else { <START> TYPE_1 . METHOD_2 ( e ) ; <END> LOG . debug ( STRING_1 + context + STRING_2 , e ) ; } } 
public void METHOD_1 ( TYPE_1 val ) { if ( val == null && ( val instanceof TYPE_2 ) ) { <START> System . out . println ( STRING_1 ) ; <END> } this . VAR_1 = METHOD_2 ( val , STRING_2 ) ; this . VAR_2 = new TYPE_3 ( val ) ; this . VAR_3 = new TYPE_4 ( val ) ; this . VAR_4 = new TYPE_5 ( val ) ; this . VAR_5 = new TYPE_6 ( val ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; <END> this . VAR_2 = VAR_1 ; } 
<START> <END> public <END> TYPE_1 <END> < <END> TYPE_2 <END> <END> , T <END> <END> > <END> METHOD_1 ( <END> final <END> TYPE_3 <END> < ? <END> extends <END> TYPE_2 <END> <END> > <END> val ) { METHOD_2 <END> <END> <END> <END> ( val <END> <END> , <END> <END> STRING_1 <END> ) <END> ; <END> this . VAR_1 <END> = new TYPE_4 <END> <END> < TYPE_2 
public Map < String , String > METHOD_1 ( ) { Map < String , String > VAR_1 = super . METHOD_1 ( ) ; String VAR_2 = VAR_1 . remove ( STRING_1 ) ; <START> if ( TYPE_1 . METHOD_2 ( VAR_2 ) ) VAR_2 = STRING_2 ; <END> return TYPE_2 < String , String > builder ( ) . METHOD_3 ( VAR_1 ) . METHOD_4 ( STRING_3 , VAR_2 ) . build ( ) ; } 
<START> void close ( ) throws IOException { <END> client . close ( ) ; } 
public void METHOD_1 ( ) { List < Object > a = TYPE_2 < Object > of ( STRING_1 , 1 , STRING_2 , false ) ; List < Object > b = TYPE_1 < Object > asList ( STRING_1 , 1 , STRING_2 , false ) ; <START> Assert . assertEquals ( a , b ) ; <END> } 
public TYPE_1 < ? > METHOD_1 ( final TYPE_2 entity , final boolean VAR_1 ) { return VAR_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . of ( STRING_1 , STRING_2 + entity , STRING_3 , STRING_4 + entity . VAR_3 ( ) + STRING_5 + entity + STRING_6 ) , new TYPE_4 ( ) { @Override public void run ( ) { if ( VAR_1 ) <START> TYPE_5 . METHOD_4 ( entity ) ; <END> VAR_2 . METHOD_5 ( ) . METHOD_6 ( entity ) ; } } ) ; } 
protected List < String > METHOD_1 ( ) { <START> TYPE_1 < String > result = new TYPE_1 < String > ( ) ; <END> result . add ( STRING_1 ) ; result . add ( STRING_2 ) ; result . add ( STRING_3 ) ; result . add ( VAR_1 ) ; result . add ( STRING_4 ) ; result . add ( STRING_5 ) ; return result ; } 
public void METHOD_1 ( TYPE_1 val ) { <START> log . error ( STRING_1 , new Object [ ] { val . VAR_1 ( ) , val . VAR_2 ( ) , val . VAR_3 ( ) } ) ; <END> for ( TYPE_2 VAR_4 : VAR_5 ) { if ( ! VAR_4 . getName ( ) . startsWith ( VAR_6 ) ) continue ; entity . VAR_7 ( VAR_4 , null ) ; } } 
public static Status METHOD_1 ( TYPE_1 state ) { if ( state == null ) return VAR_1 ; switch ( state ) { case VAR_2 : return VAR_3 ; case VAR_4 : return VAR_4 ; case VAR_5 : return VAR_5 ; case VAR_6 : return VAR_6 ; case VAR_7 : return VAR_7 ; case VAR_8 : <START> return VAR_9 ; <END> case VAR_10 : default : return VAR_1 ; } } 
<START> public static Long METHOD_1 ( Long time ) { <END> if ( time == null || time <= 0 ) return null ; return time ; } 
public static RuntimeException METHOD_1 ( Throwable VAR_1 ) { if ( VAR_1 instanceof InterruptedException ) throw new TYPE_1 ( ( InterruptedException ) VAR_1 ) ; <START> if ( VAR_1 instanceof TYPE_2 ) <END> return TYPE_3 . METHOD_1 ( VAR_1 . METHOD_2 ( ) ) ; return TYPE_3 . METHOD_1 ( VAR_1 ) ; } 
public static void METHOD_1 ( Throwable VAR_1 ) { if ( VAR_1 instanceof InterruptedException ) throw new TYPE_1 ( ( InterruptedException ) VAR_1 ) ; if ( VAR_1 instanceof TYPE_2 ) <START> METHOD_1 ( VAR_1 . METHOD_2 ( ) ) ; <END> if ( VAR_1 instanceof TYPE_3 ) throw ( TYPE_3 ) VAR_1 ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> String VAR_3 = VAR_4 . put ( VAR_1 , VAR_2 ) ; <END> if ( VAR_3 != null && ! VAR_3 . equals ( VAR_2 ) ) log . warn ( STRING_1 + VAR_1 + STRING_2 + VAR_3 + STRING_3 + VAR_2 ) ; } 
public TYPE_3 ( String id , String name , String VAR_2 , Map < String , ? extends Object > config ) { <START> this . id = id != null ? id : TYPE_1 . METHOD_1 ( ) ; <END> this . name = name ; this . VAR_2 = TYPE_2 . METHOD_2 ( VAR_2 ) ; this . config = config == null ? TYPE_4 < String , Object > of ( ) : TYPE_4 < String , Object > METHOD_3 ( config ) ; } 
public boolean METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { if ( TYPE_2 . METHOD_2 ( this , VAR_1 , true ) ) return true ; <START> TYPE_3 VAR_3 = TYPE_3 . parse ( VAR_1 , false ) ; <END> if ( VAR_3 == null ) return false ; if ( VAR_3 . METHOD_3 ( ) || VAR_3 . METHOD_4 ( ) ) return true ; return false ; } 
public Map < TYPE_1 < ? > , Object > METHOD_1 ( ) { <START> Map < TYPE_1 < ? > , Object > result = new TYPE_2 < TYPE_1 < ? > , Object > ( VAR_1 . size ( ) + VAR_2 . size ( ) ) ; <END> result . VAR_3 ( VAR_2 ) ; return Collections . VAR_4 ( result ) ; } 
public TYPE_2 ( Class < ? extends TYPE_1 > VAR_2 ) { <START> super ( VAR_2 , null ) ; <END> } 
public TYPE_2 ( Class < TYPE_1 > VAR_2 , String name , String description , List < ? extends TYPE_1 > VAR_3 ) { <START> super ( ( Class ) List . VAR_4 , name , description , ( List < ? extends TYPE_1 > ) VAR_3 ) ; <END> this . VAR_2 = VAR_2 ; } 
<START> public TYPE_3 ( ) { <END> super ( ) ; try { VAR_2 . METHOD_1 ( null , new TYPE_1 [ ] { VAR_3 } , null ) ; } catch ( Exception e ) { throw TYPE_2 . METHOD_2 ( e ) ; } } 
protected String METHOD_1 ( String VAR_1 ) { return METHOD_2 ( entity . getClass ( ) . METHOD_3 ( ) , <START> entity . getClass ( ) . getName ( ) ) + ( ! METHOD_4 ( ) . equals ( TYPE_1 ) ? VAR_1 + METHOD_4 ( ) : "" ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 < TYPE_1 , TYPE_1 > ... VAR_1 ) { <END> return METHOD_2 ( VAR_1 ) . apply ( METHOD_3 ( ) ) ; } 
public TYPE_1 METHOD_1 ( int count , TYPE_2 VAR_1 ) { TYPE_1 VAR_2 ; synchronized ( this ) { <START> VAR_2 = METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; <END> } if ( VAR_2 . size ( ) >= count ) return VAR_2 ; TYPE_1 VAR_3 = create ( count - VAR_2 . size ( ) , VAR_1 ) ; return VAR_2 . METHOD_4 ( VAR_3 ) ; } 
<START> public void remove ( int id ) { <END> VAR_1 . remove ( id ) ; } 
public TYPE_1 < ? > METHOD_1 ( TYPE_2 field ) { TYPE_3 VAR_1 = TYPE_4 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) <START> . METHOD_4 ( TYPE_5 . METHOD_5 ( ) . METHOD_6 ( Constants . VAR_3 ) , TYPE_5 . METHOD_5 ( ) ) <END> . build ( ) ; return ( ( ) - > VAR_1 . METHOD_7 ( field . getType ( ) ) ) ; } 
protected List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; Collections . addAll ( VAR_1 , VAR_2 . METHOD_2 ( ) ) ; <START> if ( VAR_3 != null ) { <END> for ( TYPE_1 element : VAR_3 ) { VAR_1 . remove ( element ) ; } } return VAR_1 ; } 
TYPE_1 METHOD_1 ( final String VAR_1 , final TYPE_1 command ) { METHOD_2 ( ) ; try { try { <START> System . out . println ( command ) ; <END> return METHOD_3 ( VAR_1 , command ) ; } catch ( TYPE_2 e ) { METHOD_2 ( ) ; return METHOD_3 ( VAR_1 , command ) ; } } catch ( TYPE_3 e ) { throw METHOD_4 ( e ) ; } } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final boolean VAR_1 ) { <START> this . VAR_1 = METHOD_2 ( STRING_1 , VAR_1 ) ; <END> return this ; } 
private String METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( ) ; <END> if ( VAR_1 . getType ( ) != TYPE_3 . VAR_3 && VAR_1 . getType ( ) != TYPE_3 . VAR_4 ) { throw new TYPE_2 ( STRING_1 , VAR_1 . getValue ( ) ) ; } return VAR_1 . getValue ( String . VAR_5 ) ; } 
private static TYPE_1 < ? > METHOD_1 ( final TYPE_2 method ) { if ( METHOD_2 ( method . getName ( ) ) ) { return METHOD_1 ( method . VAR_1 ( ) , method . VAR_2 ( ) ) ; } else { <START> if ( method . VAR_3 ( ) . length != 1 ) { <END> throw new TYPE_3 ( format ( STRING_1 , method . getName ( ) ) ) ; } return METHOD_1 ( method . VAR_3 ( ) [ 0 ] , method . VAR_4 ( ) [ 0 ] ) ; } } 
public void close ( ) { try { if ( channel != null ) { channel . close ( ) ; } <START> } catch ( final IOException e ) { <END> } finally { channel = null ; VAR_1 = true ; } } 
public void METHOD_1 ( final TYPE_1 < TYPE_2 > event ) { description = event . VAR_1 ( ) ; <START> for ( final TYPE_3 < TYPE_2 > listener : VAR_2 ) { <END> listener . VAR_3 ( event ) ; } } 
public TYPE_7 ( TYPE_1 < ? extends TYPE_2 > VAR_2 , TYPE_3 a , TYPE_4 VAR_3 ) { <START> if ( VAR_2 . getValue ( ) == null ) { <END> throw new TYPE_5 ( STRING_1 ) ; } if ( VAR_2 . getValue ( ) instanceof TYPE_6 && a == null ) { throw new TYPE_5 ( STRING_2 ) ; } if ( VAR_3 == null ) { throw new TYPE_5 ( STRING_3 ) ; } VAR_4 = VAR_2 ; VAR_5 = a ; VAR_6 = VAR_3 ; } 
public static TYPE_1 METHOD_1 ( final TYPE_2 model ) { TYPE_1 VAR_1 = new TYPE_1 ( TYPE_7 . TYPE_8 . METHOD_2 ( TYPE_10 . VAR_3 ) ) ; <START> VAR_1 . METHOD_3 ( false ) ; <END> VAR_1 . setText ( STRING_1 ) ; VAR_1 . METHOD_4 ( STRING_2 ) ; VAR_1 . METHOD_5 ( new TYPE_4 ( ) { public void METHOD_6 ( TYPE_5 e ) { ( ( TYPE_6 ) METHOD_7 ( model . VAR_4 ( ) ) ) . METHOD_8 ( TYPE_9 . VAR_6 ) ; } } ) ; return VAR_1 ; } 
private synchronized void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) < 2 ) return ; VAR_2 = new double [ 3 ] ; VAR_2 [ 1 ] = TYPE_1 . METHOD_3 ( ) * 4 - 2 ; VAR_2 [ 2 ] = VAR_2 [ 1 ] + TYPE_1 . METHOD_3 ( ) * FLOAT_1 ; <START> VAR_2 [ 0 ] = VAR_2 [ 2 ] - VAR_2 [ 1 ] ; <END> VAR_3 = true ; METHOD_4 ( VAR_4 , null , VAR_3 ) ; } 
Collection < TYPE_1 > METHOD_1 ( ) { <START> return this . VAR_1 ; <END> } 
public int METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <START> int VAR_3 = this . VAR_4 ++ ; <END> VAR_5 . put ( VAR_3 , new Pair < TYPE_1 , Integer > ( VAR_1 , VAR_2 ) ) ; return VAR_3 ; } 
public Boolean METHOD_1 ( String url ) { <START> return true ; <END> } 
private Set < String > METHOD_1 ( String input ) { Set < String > VAR_1 = new HashSet < > ( ) ; <START> VAR_1 . addAll ( TYPE_1 . of ( input . split ( STRING_1 ) ) . map ( String : : trim ) . collect ( Collectors . VAR_2 ( ) ) ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 request , TYPE_2 < TYPE_3 > VAR_1 ) { TYPE_4 options = request . VAR_2 ( ) ; TYPE_5 . call ( LOG , ( ) - > { TYPE_6 VAR_3 = METHOD_2 ( request . getPath ( ) ) ; VAR_4 . METHOD_1 ( VAR_3 , ( TYPE_7 ) TYPE_7 <START> . create ( options . VAR_5 ( ) ) . METHOD_3 ( new TYPE_8 ( VAR_1 ) ) ) ; <END> return TYPE_3 . METHOD_4 ( ) . build ( ) ; } , STRING_1 , STRING_2 , VAR_1 , request ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 ) { <START> final TYPE_3 VAR_3 = TYPE_3 . create ( VAR_4 . METHOD_2 ( VAR_1 ) ) ; <END> if ( VAR_5 == null ) { VAR_5 = TYPE_8 . TYPE_9 . create ( TYPE_5 . METHOD_3 ( VAR_3 ) . build ( ) ) ; } TYPE_1 VAR_6 = new TYPE_1 ( new TYPE_6 ( VAR_1 . getPath ( ) , VAR_2 ) , new TYPE_7 ( 3 ) ) ; VAR_6 . run ( ) ; return VAR_6 ; } 
public static synchronized TYPE_1 get ( TYPE_2 conf ) throws IOException { if ( VAR_1 == null ) { try { VAR_1 = Optional . of ( create ( conf ) ) ; } catch ( IOException e ) { VAR_1 = Optional . empty ( ) ; <START> throw e ; <END> } } return VAR_1 . METHOD_1 ( null ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; LOG . info ( STRING_1 ) ; VAR_3 = VAR_2 . METHOD_1 ( ) ; <START> VAR_4 = TYPE_2 . METHOD_2 ( TYPE_4 . VAR_6 ) ; <END> VAR_7 = TYPE_2 . METHOD_2 ( TYPE_4 . VAR_8 ) ; } 
public TYPE_2 ( ) { <START> VAR_2 = new TYPE_1 < > ( ) ; <END> } 
public void METHOD_1 ( long position ) throws IOException { <START> if ( Math . VAR_1 ( position - VAR_2 ) > VAR_3 ) { <END> VAR_4 = 0 ; } else { ( ( TYPE_1 ) in ) . METHOD_1 ( position ) ; } VAR_2 = position ; } 
public long METHOD_1 ( long n ) throws IOException { if ( n > VAR_1 ) { VAR_2 = 0 ; VAR_3 += n ; return n ; } else { <START> long VAR_4 = ( ( TYPE_1 ) in ) . METHOD_1 ( n ) ; <END> VAR_3 += VAR_4 ; return VAR_4 ; } } 
public void METHOD_1 ( long position ) throws IOException { if ( position < VAR_1 || position - VAR_1 > VAR_2 ) { VAR_3 = 0 ; } else { <START> ( ( TYPE_1 ) in ) . METHOD_1 ( position ) ; <END> } VAR_1 = position ; } 
public void METHOD_1 ( TYPE_1 path , TYPE_2 status ) { <START> TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( path , status ) ; <END> if ( ! path . getName ( ) . equals ( status . getName ( ) ) ) { throw new IllegalArgumentException ( String . format ( STRING_1 , path . getName ( ) , status . getName ( ) ) ) ; } } 
public TYPE_1 METHOD_1 ( long VAR_1 , TYPE_2 VAR_2 ) { long VAR_3 = 0 ; <START> if ( VAR_2 != null ) { <END> VAR_3 = VAR_4 . METHOD_2 ( ) ; } if ( LOG . VAR_5 ( ) ) { LOG . debug ( STRING_1 , VAR_1 , VAR_3 ) ; } return new TYPE_2 ( VAR_3 ) ; } 
<START> protected synchronized long METHOD_1 ( ) throws TYPE_1 { <END> return METHOD_2 ( ( ) - > VAR_1 . METHOD_3 ( TYPE_2 . METHOD_4 ( ) . METHOD_5 ( METHOD_6 ( ) ) . build ( ) ) . METHOD_7 ( ) , LOG , STRING_1 , "" ) ; } 
public String METHOD_1 ( String url ) throws IOException { <START> String VAR_1 ; <END> VAR_1 = TYPE_1 . get ( url , VAR_2 ) ; return String . format ( STRING_1 , url , VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> TYPE_3 . METHOD_2 ( this , VAR_1 , 2 ) ; <END> } 
public synchronized void close ( ) { if ( VAR_1 != null ) { try { VAR_1 . METHOD_1 ( ) ; <START> VAR_1 = null ; <END> } catch ( TYPE_1 VAR_2 ) { LOG . debug ( STRING_1 , VAR_2 ) ; } } } 
public String toString ( ) { <START> return TYPE_1 . METHOD_1 ( "" ) <END> . add ( STRING_1 , VAR_1 ) . add ( STRING_2 , VAR_2 ) . toString ( ) ; } 
public Iterator < TYPE_5 . TYPE_6 > METHOD_1 ( ) { List < Iterator < TYPE_5 . TYPE_6 > > VAR_1 = TYPE_2 <START> . map ( TYPE_3 : : METHOD_1 , VAR_2 . values ( ) ) ; <END> return TYPE_4 . METHOD_2 ( METHOD_3 ( ) , METHOD_4 ( ) , TYPE_4 . METHOD_2 ( VAR_1 . iterator ( ) ) ) ; } 
public int METHOD_1 ( ) throws IOException { <START> int VAR_1 = in . VAR_1 ( ) + ( int ) ( ( ( TYPE_1 ) in ) . METHOD_2 ( ) - VAR_2 ) ; <END> return VAR_1 > 0 ? VAR_1 : 0 ; } 
public int read ( ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; int VAR_1 = ( ( TYPE_1 ) in ) . read ( VAR_2 , buffer , 0 , buffer . length ) ; if ( VAR_1 > 0 ) { VAR_2 += VAR_1 ; return TYPE_2 . METHOD_1 ( buffer [ 0 ] ) ; } TYPE_3 . METHOD_2 ( VAR_1 != 0 , <START> STRING_1 ) ; <END> return VAR_1 ; } 
<START> protected TYPE_3 ( TYPE_1 VAR_2 ) { <END> VAR_3 = VAR_2 ; VAR_4 = TYPE_2 . create ( VAR_2 ) ; VAR_5 . METHOD_1 ( VAR_3 ) ; } 
static TYPE_1 create ( TYPE_2 conf ) { return TYPE_3 . METHOD_1 ( <START> conf . getClass ( TYPE_4 . VAR_2 ) , new Class [ 0 ] , new Object [ 0 ] ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { Status status = VAR_1 . getStatus ( ) ; <START> if ( status . equals ( Status . VAR_2 ) ) { <END> METHOD_2 ( VAR_1 . getId ( ) ) ; } else if ( status . equals ( Status . VAR_3 ) || status . equals ( Status . VAR_4 ) ) { METHOD_3 ( VAR_1 . getId ( ) , status , VAR_1 . METHOD_4 ( ) ) ; } } 
public TYPE_2 ( String VAR_2 , String [ ] VAR_3 ) { super ( VAR_3 ) ; VAR_4 = VAR_2 ; <START> VAR_5 = new String [ ] { STRING_1 , STRING_2 , <END> String . format ( STRING_3 , TYPE_1 . VAR_7 , VAR_2 , String . VAR_8 ( STRING_4 , VAR_3 ) ) } ; } 
public TYPE_2 ( String VAR_2 , String VAR_3 , String VAR_4 , boolean VAR_5 ) { super ( new String [ ] { } ) ; String VAR_6 = STRING_1 ; if ( VAR_5 ) { VAR_6 = STRING_2 ; } <START> VAR_7 = new String [ ] { STRING_3 , STRING_4 , <END> String . format ( VAR_6 , TYPE_1 . VAR_9 , VAR_2 , VAR_3 , VAR_4 ) } ; VAR_10 = VAR_2 ; } 
<START> private TYPE_1 METHOD_1 ( ) throws IOException { <END> if ( VAR_1 != null ) { return VAR_1 ; } VAR_1 = METHOD_2 ( ) ; return VAR_1 ; } 
private void METHOD_1 ( long VAR_1 , TYPE_1 . Builder command ) { if ( ! VAR_2 . containsKey ( VAR_1 ) ) { <START> VAR_2 . put ( VAR_1 , TYPE_2 . METHOD_2 ( ) ) ; <END> } VAR_2 . get ( VAR_1 ) . add ( command . build ( ) ) ; } 
protected void METHOD_1 ( Thread t , TYPE_1 r ) { super . METHOD_1 ( t , r ) ; VAR_1 . METHOD_2 ( ) ; try { VAR_2 ++ ; while ( VAR_3 ) { VAR_4 . METHOD_3 ( ) ; } <START> VAR_2 -- ; <END> } catch ( InterruptedException e ) { t . VAR_5 ( ) ; } finally { VAR_1 . METHOD_4 ( ) ; } } 
public boolean METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; try { VAR_2 . close ( ) ; } catch ( IOException e ) { LOG . warn ( STRING_1 , e ) ; } <START> VAR_1 . METHOD_2 ( ) ; <END> try { return VAR_1 . METHOD_3 ( VAR_3 , TimeUnit . VAR_4 ) ; } catch ( InterruptedException VAR_5 ) { Thread . VAR_6 ( ) . METHOD_4 ( ) ; return false ; } } 
public TYPE_5 ( TYPE_3 . TYPE_4 . TYPE_5 VAR_2 ) { VAR_3 = VAR_2 . METHOD_1 ( ) ; <START> VAR_4 = TYPE_2 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; <END> VAR_5 = VAR_2 . METHOD_4 ( ) ; VAR_6 = VAR_2 . METHOD_5 ( ) ; } 
public static void METHOD_1 ( ) throws Exception { VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 , STRING_1 ) ; VAR_1 . start ( ) ; <START> VAR_4 = VAR_5 . get ( ) . METHOD_3 ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 . METHOD_2 ( ) ) ; METHOD_3 ( VAR_2 , VAR_1 , INT_1 ) ; <START> TYPE_3 . METHOD_4 ( INT_2 ) ; <END> TYPE_4 . METHOD_5 ( VAR_3 , VAR_2 , VAR_1 , 2 ) ; } 
public static TYPE_1 create ( TYPE_2 uri ) throws IOException { Path VAR_1 = new Path ( uri . VAR_2 ( ) , uri . VAR_3 ( ) . toString ( ) , uri . getPath ( ) ) ; TYPE_3 conf = TYPE_4 . METHOD_1 ( ) ; TYPE_5 VAR_4 = VAR_1 . METHOD_2 ( conf ) ; <START> return new TYPE_1 ( VAR_4 , VAR_1 ) ; <END> } 
private void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) ; } catch ( IOException e ) { TYPE_1 . METHOD_3 ( LOG , e , STRING_1 ) ; } <START> } <END> 
public void METHOD_1 ( ) throws IOException { try ( TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ) { TYPE_2 . METHOD_2 ( ! VAR_3 , STRING_1 ) ; LOG . info ( STRING_2 ) ; VAR_3 = true ; <START> LOG . info ( STRING_3 , VAR_4 ) ; <END> } } 
public void start ( Boolean VAR_1 ) throws IOException { super . start ( VAR_1 ) ; <START> VAR_2 . METHOD_1 ( METHOD_2 ( ) , VAR_3 . METHOD_3 ( ) ) ; <END> } 
public boolean METHOD_1 ( TYPE_3 . TYPE_4 entry ) { if ( entry . VAR_1 ( ) ) { apply ( entry . VAR_2 ( ) ) ; return true ; } else if ( entry . VAR_3 ( ) ) { TYPE_2 db = VAR_4 . get ( entry . VAR_5 ( ) . METHOD_2 ( ) ) ; return db . VAR_6 ( entry ) ; } else if ( entry . VAR_7 ( ) ) { <START> apply ( entry . VAR_8 ( ) ) ; <END> } return false ; } 
public int run ( TYPE_1 VAR_1 ) throws TYPE_2 { String [ ] args = VAR_1 . METHOD_1 ( ) ; String VAR_2 = args [ 0 ] ; String VAR_3 = args [ 1 ] ; TYPE_3 p = VAR_1 . METHOD_2 ( TYPE_4 . METHOD_3 ( ) ) ; VAR_4 . METHOD_4 ( VAR_2 , VAR_3 , TYPE_5 . METHOD_5 ( p ) ) ; <START> System . out . println ( String . format ( STRING_1 , VAR_2 , VAR_3 ) ) ; <END> return 0 ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) throws IOException , TYPE_2 { <START> METHOD_2 ( VAR_1 ) ; <END> return METHOD_3 ( client - > { TYPE_1 path = client . VAR_2 ( VAR_1 ) ; LOG . debug ( STRING_1 , VAR_1 . getPath ( ) , path . getPath ( ) ) ; return path ; } ) ; } 
public List < TYPE_5 . TYPE_6 . VAR_1 . TYPE_4 > METHOD_1 ( String VAR_3 , String VAR_4 , TYPE_2 VAR_5 ) throws IOException { TYPE_3 table = METHOD_2 ( VAR_3 , VAR_4 ) ; List < TYPE_4 > VAR_6 = table . VAR_7 ( ) ; List < TYPE_5 . TYPE_6 . VAR_1 . TYPE_4 > VAR_8 = <START> VAR_6 . stream ( ) . map ( TYPE_4 : : METHOD_3 ) . collect ( Collectors . VAR_9 ( ) ) ; <END> return VAR_8 ; } 
public boolean METHOD_1 ( ) { try { return METHOD_2 ( "" , true ) != null ; } catch ( Exception e ) { <START> LOG . debug ( STRING_1 , super . VAR_1 . toString ( ) , e . getMessage ( ) ) ; <END> return false ; } } 
public synchronized void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> synchronized ( VAR_2 ) { <END> for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_2 . METHOD_2 ( VAR_3 . METHOD_3 ( ) , VAR_3 ) ; } METHOD_4 ( ) ; } } 
public synchronized void METHOD_1 ( long VAR_1 ) { Integer VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { return ; } TYPE_1 VAR_4 = VAR_5 . METHOD_2 ( VAR_2 ) ; if ( VAR_4 . getStatus ( ) . METHOD_3 ( ) ) { return ; } <START> synchronized ( VAR_5 ) { <END> if ( ! VAR_5 . getStatus ( ) . METHOD_3 ( ) ) { VAR_4 . METHOD_4 ( Status . VAR_6 ) ; VAR_4 . METHOD_5 ( STRING_1 ) ; METHOD_6 ( ) ; } } } 
private void METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 ) { VAR_1 . METHOD_2 ( ) ; try { VAR_1 . METHOD_3 ( VAR_2 , TimeUnit . VAR_3 ) ; } catch ( InterruptedException e ) { Thread . VAR_4 ( ) . METHOD_4 ( ) ; } finally { VAR_1 . METHOD_5 ( ) ; } <START> TYPE_2 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ; <END> } 
<START> private String METHOD_1 ( TYPE_1 uri ) { <END> if ( uri . VAR_1 ( ) ) { return uri . toString ( ) ; } else { return uri . getPath ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( ) . METHOD_2 ( VAR_1 ) . METHOD_2 ( VAR_2 ) . METHOD_2 ( VAR_3 ) . METHOD_2 ( VAR_4 ) <START> . METHOD_2 ( VAR_5 ) <END> . METHOD_2 ( VAR_6 ) . METHOD_2 ( VAR_7 ) . METHOD_2 ( VAR_8 ) ; } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof TYPE_1 ) ) { return VAR_1 == o ; <START> } <END> try { TYPE_1 < T > VAR_2 = ( TYPE_1 < T > ) o ; return VAR_1 == VAR_2 . VAR_1 ; } catch ( TYPE_2 e ) { return false ; } } 
public synchronized TYPE_1 METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 != TYPE_5 . VAR_3 ) { throw new TYPE_2 ( STRING_1 + VAR_1 ) ; } TYPE_3 writer = VAR_4 ; <START> if ( writer == null ) { <END> throw new TYPE_2 ( STRING_2 ) ; } return new TYPE_4 ( writer ) ; } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = String . VAR_2 ( "" , Collections . VAR_3 ( INT_1 , STRING_1 ) ) ; <START> assertEquals ( INT_2 , VAR_1 . length ( ) ) ; <END> VAR_4 . VAR_5 . set ( TYPE_1 . METHOD_2 ( ) ) ; assertEquals ( - TYPE_2 . METHOD_3 ( ) , VAR_6 . create ( STRING_2 + VAR_1 , 0 , VAR_4 ) ) ; } 
public static < T > void call ( Logger logger , TYPE_1 < T > VAR_1 , String VAR_2 , boolean VAR_3 , String description , TYPE_2 < T > VAR_4 , Object ... args ) { try { VAR_4 . METHOD_1 ( METHOD_2 ( logger , VAR_1 , VAR_2 , VAR_3 , description , args ) ) ; <START> VAR_4 . METHOD_3 ( ) ; <END> } catch ( TYPE_3 e ) { VAR_4 . METHOD_4 ( e ) ; } } 
protected String METHOD_1 ( ) { <START> if ( VAR_1 . METHOD_2 ( ) != null && VAR_1 . METHOD_2 ( ) . equals ( STRING_1 ) ) { <END> return Constants . VAR_2 + VAR_3 ; } else { return Constants . VAR_4 + VAR_3 ; } } 
public boolean remove ( T element ) { <START> return VAR_1 . METHOD_1 ( x - > x . VAR_2 == element ) ; <END> } 
public TYPE_8 ( TYPE_6 . TYPE_7 VAR_2 , TYPE_2 channel , long VAR_3 ) { VAR_4 = VAR_2 ; VAR_5 = channel instanceof TYPE_3 ? ( ) - > ( ( ( TYPE_3 ) channel ) . METHOD_1 ( ) && VAR_6 ) : ( ) - > VAR_6 ; <START> if ( channel instanceof TYPE_3 ) { <END> VAR_7 = ( ( TYPE_3 ) channel ) : : close ; } VAR_8 = TYPE_4 . METHOD_2 ( channel , new TYPE_5 ( ( this ) ) ) ; VAR_9 = false ; VAR_10 = VAR_3 ; } 
<START> public Map < String , String > METHOD_1 ( ) { <END> return VAR_1 ; } 
private TYPE_3 ( String VAR_2 ) { VAR_3 = null ; VAR_4 = false ; VAR_5 = false ; VAR_6 = null ; VAR_7 = null ; VAR_8 = TYPE_1 . METHOD_1 ( TYPE_2 . METHOD_2 ( ) , VAR_2 ) ; <START> VAR_9 = new HashMap < > ( ) ; <END> } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { boolean VAR_2 = VAR_3 . METHOD_2 ( ) ; boolean VAR_4 = VAR_5 ; <START> METHOD_3 ( VAR_1 , ! VAR_2 , ! VAR_4 ) ; <END> } 
<START> default String VAR_1 ( ) { <END> return null ; } 
public TYPE_6 ( TYPE_1 < TYPE_2 < byte [ ] > > properties ) { try { VAR_2 = TYPE_3 . getInstance ( STRING_1 ) ; } catch ( TYPE_4 e ) { throw new RuntimeException ( e ) ; } VAR_3 = properties ; VAR_4 = new TYPE_5 ( true ) ; <START> VAR_5 = "" ; <END> } 
public int METHOD_1 ( ) { return TYPE_1 . METHOD_1 ( <START> VAR_1 , <END> VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 ) ; } 
public void record ( long VAR_1 , int VAR_2 ) { long VAR_3 = METHOD_1 ( VAR_1 ) ; <START> VAR_4 . put ( VAR_3 , ( VAR_4 . METHOD_2 ( VAR_3 , 0 ) ) + VAR_2 ) ; <END> } 
public Map < String , List < String > > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
public List < String > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
public Map < String , List < String > > METHOD_1 ( ) { Map < String , List < String > > VAR_1 = new HashMap < > ( ) ; for ( Pair < String , String > VAR_2 : VAR_3 . keySet ( ) ) { String VAR_4 = VAR_2 . METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( VAR_4 , VAR_5 - > new ArrayList < > ( ) ) ; <END> VAR_1 . get ( VAR_4 ) . add ( VAR_2 . METHOD_4 ( ) ) ; } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 entry ) { final String path = entry . getPath ( ) ; final Map < String , String > properties = entry . VAR_1 ( ) ; if ( VAR_2 . containsKey ( path ) ) { VAR_2 . get ( path ) . clear ( ) ; <START> VAR_2 . get ( path ) . METHOD_2 ( properties ) ; <END> } else { VAR_2 . put ( path , new HashMap < > ( properties ) ) ; } } 
private void METHOD_1 ( TYPE_1 entry ) { <START> final String path = entry . getPath ( ) ; <END> VAR_1 . remove ( path ) ; } 
public static Collection < ? extends TYPE_1 > METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( TYPE_3 . values ( ) <END> . METHOD_3 ( ) . filter ( key - > ! TYPE_1 . METHOD_4 ( key ) ) . collect ( Collectors . VAR_1 ( ) ) ) ; } 
public TYPE_2 ( ) { <START> VAR_2 = TYPE_1 . get ( TYPE_3 . VAR_4 ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 request ) throws IOException { <START> TYPE_3 < TYPE_1 > VAR_1 = ( ) - > { <END> TYPE_1 result = VAR_2 . METHOD_2 ( request ) ; request . VAR_3 ( result . VAR_4 ( ) ) ; return result ; } ; try { return METHOD_3 ( VAR_1 , STRING_1 ) ; } catch ( TYPE_4 e ) { throw new IOException ( e ) ; } } 
public Response METHOD_1 ( ANNOTATION_1 ( STRING_1 ) final String path , final TYPE_1 options ) { return TYPE_2 . call ( ( TYPE_2 . TYPE_8 < TYPE_4 > ) ( ) - > { if ( options == null ) { VAR_1 . METHOD_1 ( new TYPE_5 ( path ) , <START> TYPE_6 . METHOD_2 ( TYPE_7 . METHOD_3 ( ) ) ) ; <END> } else { VAR_1 . METHOD_1 ( new TYPE_5 ( path ) , options ) ; } return null ; } , TYPE_7 . METHOD_3 ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> Assert . assertTrue ( METHOD_2 ( VAR_1 ) . METHOD_1 ( ) > 0 ) ; <END> } 
public synchronized void close ( ) throws IOException { if ( VAR_1 != null ) { VAR_1 . close ( ) ; VAR_1 = null ; <START> VAR_2 . close ( ) ; <END> VAR_2 = null ; } if ( VAR_3 != null ) { VAR_3 . METHOD_1 ( false ) ; VAR_3 = null ; } VAR_4 = TYPE_1 . VAR_6 ; } 
public void METHOD_1 ( int VAR_1 ) { TYPE_1 r = VAR_2 . remove ( VAR_1 ) ; if ( r != null ) { <START> r . VAR_3 . METHOD_2 ( ) ; <END> try { r . VAR_4 . METHOD_1 ( ) ; r . VAR_5 . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } 
<START> void METHOD_1 ( ) { <END> METHOD_1 ( "" , "" ) ; } 
public static TYPE_6 . TYPE_7 METHOD_1 ( ) { TYPE_2 type = TYPE_3 . METHOD_2 ( TYPE_8 . VAR_2 , TYPE_2 . class ) ; switch ( type ) { case VAR_3 : <START> return VAR_4 - > new TYPE_4 ( ) ; <END> case VAR_5 : return args - > new TYPE_5 ( TYPE_3 . METHOD_3 ( ) ) ; default : throw new IllegalStateException ( STRING_1 + type ) ; } } 
public void remove ( Long VAR_1 ) { <START> System . out . METHOD_1 ( STRING_1 , VAR_1 ) ; <END> try { byte [ ] id = TYPE_1 . METHOD_2 ( VAR_1 ) ; VAR_2 . METHOD_3 ( VAR_3 , VAR_4 , id ) ; } catch ( TYPE_2 e ) { throw new RuntimeException ( e ) ; } } 
public void METHOD_1 ( String name ) { <START> if ( VAR_1 . remove ( name ) != null ) { <END> VAR_2 . METHOD_2 ( ) ; } } 
public void close ( ) throws IOException { <START> if ( VAR_1 . METHOD_1 ( ) ) { <END> return ; } VAR_2 . close ( ) ; try { VAR_2 . METHOD_2 ( VAR_3 ) ; } finally { VAR_4 . METHOD_3 ( VAR_5 , VAR_1 ) ; } } 
private TYPE_3 ( TYPE_1 reader , long offset , long VAR_2 , long VAR_3 ) <START> throws IOException { <END> VAR_4 = reader ; TYPE_2 . METHOD_1 ( VAR_3 > 0 ) ; VAR_5 = offset ; VAR_6 = Math . VAR_7 ( VAR_4 . METHOD_2 ( ) , offset + VAR_2 ) ; VAR_8 = VAR_3 ; } 
<START> public static TYPE_1 create ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , <END> TYPE_4 VAR_3 ) { TYPE_5 props = null ; if ( VAR_3 != null ) { props = VAR_3 . METHOD_1 ( ) ; } TYPE_1 context = new TYPE_1 ( VAR_1 , props ) ; context . VAR_4 ( VAR_2 ) ; return context ; } 
<START> public static TYPE_1 METHOD_1 ( TYPE_1 conf , Map < ? , ? > properties , <END> TYPE_2 source ) { TYPE_3 props = conf . VAR_1 ( ) ; props . VAR_2 ( properties , source ) ; return new TYPE_4 ( props ) ; } 
public void close ( ) throws IOException { VAR_1 . METHOD_1 ( ) ; try { long VAR_2 = TYPE_1 . METHOD_2 ( TYPE_2 . VAR_4 ) ; if ( ! VAR_1 . METHOD_3 ( VAR_2 , TimeUnit . VAR_5 ) ) { <START> LOGGER . warn ( STRING_1 , VAR_2 ) ; <END> } } catch ( InterruptedException e ) { Thread . VAR_6 ( ) . METHOD_4 ( ) ; throw new RuntimeException ( e ) ; } } 
public void METHOD_1 ( ) throws IOException { if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; VAR_1 = null ; } super . METHOD_1 ( ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> } 
<START> public List < TYPE_7 . TYPE_8 . TYPE_2 > METHOD_1 ( ) throws IOException , TYPE_3 { <END> TYPE_4 VAR_1 = VAR_2 . METHOD_2 ( ) ; try { return VAR_1 . METHOD_1 ( ) ; } catch ( TYPE_5 e ) { throw e ; } catch ( TYPE_6 e ) { throw e . VAR_3 ( ) ; } finally { VAR_2 . METHOD_3 ( VAR_1 ) ; } } 
private static String METHOD_1 ( String VAR_1 ) { return TYPE_1 . METHOD_2 ( VAR_1 , <START> STRING_1 + System . VAR_2 ( ) + STRING_2 + TYPE_2 . METHOD_3 ( 3 ) ) ; <END> } 
<START> public void METHOD_1 ( TYPE_1 uri ) throws Exception { <END> try ( TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( uri , TYPE_3 . METHOD_3 ( ) . METHOD_4 ( TYPE_5 . VAR_4 ) . METHOD_5 ( VAR_5 ) ) ) { VAR_1 . write ( TYPE_4 . METHOD_6 ( VAR_5 + 1 ) ) ; } } 
private void METHOD_1 ( String VAR_1 , String VAR_2 ) throws Exception { try { <START> METHOD_2 ( STRING_1 ) ; <END> METHOD_3 ( VAR_2 ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , METHOD_4 ( STRING_2 ) ) ; } } 
public int getInt ( TYPE_1 key ) { String VAR_1 = get ( key ) ; try { <START> return Integer . parseInt ( METHOD_1 ( VAR_1 ) ) ; <END> } catch ( TYPE_2 e ) { throw new RuntimeException ( TYPE_5 . TYPE_6 . getMessage ( key ) ) ; } catch ( TYPE_4 e ) { throw new RuntimeException ( e ) ; } } 
<START> public void METHOD_1 ( ) throws IOException { <END> TYPE_1 VAR_1 = TYPE_1 . create ( STRING_1 ) ; TYPE_2 . get ( VAR_1 , new org . VAR_2 . VAR_3 . conf . TYPE_3 ( ) ) ; METHOD_2 ( VAR_5 . VAR_6 . METHOD_3 ( STRING_2 ) ) ; } 
public void run ( ) { VAR_1 . start ( ) ; try { VAR_1 . METHOD_1 ( INT_1 ) ; if ( VAR_1 . METHOD_2 ( ) ) { <START> LOG . warn ( STRING_1 ) ; <END> } } catch ( InterruptedException e ) { return ; } } 
public void close ( ) throws IOException { super . close ( ) ; synchronized ( VAR_1 ) { Pair < TYPE_1 , TYPE_2 > VAR_2 = TYPE_3 . get ( VAR_3 . METHOD_1 ( ) ) ; if ( VAR_2 == null ) { LOG . warn ( STRING_1 ) ; return ; } <START> if ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) == 0 ) { <END> VAR_2 . METHOD_4 ( ) . close ( ) ; } } } 
<START> public void METHOD_1 ( ) throws TYPE_1 { <END> org . VAR_1 . VAR_2 . conf . TYPE_2 VAR_3 = new org . VAR_1 . VAR_2 . conf . TYPE_2 ( ) ; long VAR_4 = TYPE_2 . METHOD_2 ( ) . size ( ) ; TYPE_3 . METHOD_3 ( VAR_3 , TYPE_2 . METHOD_4 ( ) ) ; long VAR_5 = TYPE_2 . METHOD_2 ( ) . size ( ) ; Assert . assertEquals ( VAR_4 , VAR_5 ) ; Assert . VAR_6 ( TYPE_2 . METHOD_5 ( TYPE_4 . VAR_8 ) ) ; } 
public String METHOD_1 ( ) { <START> if ( METHOD_2 ( ) == TYPE_2 . VAR_2 ) { <END> TYPE_1 VAR_3 = ( TYPE_1 ) VAR_4 . METHOD_3 ( ) ; return VAR_3 . METHOD_1 ( ) ; } return null ; } 
private TYPE_1 METHOD_1 ( TYPE_2 < ? > VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) <= Constants . VAR_2 ) { <END> return null ; } long VAR_3 = VAR_1 . METHOD_3 ( ) + VAR_1 . METHOD_2 ( ) ; TYPE_1 VAR_4 = VAR_5 . METHOD_4 ( new TYPE_1 ( VAR_3 ) ) ; if ( VAR_4 == null || VAR_4 . METHOD_5 ( ) < VAR_3 || ( VAR_4 . METHOD_5 ( ) == VAR_3 && TYPE_1 . METHOD_6 ( ) != 0 ) ) { return null ; } return VAR_4 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) throws IOException { VAR_4 = VAR_2 ; VAR_5 = VAR_3 ; <START> VAR_6 = new TYPE_3 < > ( VAR_4 . METHOD_1 ( ) ) ; <END> } 
<START> public void METHOD_1 ( String path , TYPE_1 VAR_1 ) { <END> } 
public synchronized TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == true ) { <END> VAR_1 = false ; METHOD_2 ( ) ; } return VAR_2 ; } 
public T METHOD_1 ( List < TYPE_1 > VAR_1 ) throws IOException { for ( TYPE_1 entry : VAR_1 ) { if ( entry . VAR_2 ( ) ) { TYPE_2 VAR_3 = METHOD_2 ( ) ; <START> if ( VAR_3 != null ) { <END> VAR_3 . METHOD_3 ( entry ) ; } } else { VAR_4 . METHOD_3 ( entry ) ; } } return METHOD_4 ( ) ; } 
<START> public String METHOD_1 ( String path ) { <END> String VAR_1 = TYPE_1 . METHOD_1 ( path , TYPE_2 . METHOD_2 ( METHOD_3 ( ) , VAR_2 ) ) ; if ( ! VAR_1 . equals ( path ) ) { return VAR_1 ; } return TYPE_1 . METHOD_1 ( path , VAR_2 ) ; } 
TYPE_9 ( TYPE_1 uri , TYPE_2 VAR_2 , TYPE_7 . TYPE_8 VAR_3 ) throws TYPE_4 { <START> TYPE_5 . METHOD_1 ( ! VAR_2 . METHOD_2 ( ) . isEmpty ( ) ) ; <END> VAR_4 = uri ; VAR_5 = TYPE_6 . METHOD_3 ( VAR_4 . getPath ( ) ) ; VAR_6 = VAR_2 ; VAR_7 = VAR_3 ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 != null && VAR_1 . METHOD_1 ( ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 ) { VAR_4 = VAR_2 ; VAR_5 = VAR_3 ; VAR_6 = new TYPE_2 ( ) ; <START> VAR_7 = System . currentTimeMillis ( ) ; <END> VAR_4 . METHOD_1 ( this : : METHOD_2 ) ; } 
public TYPE_1 METHOD_1 ( String host ) { TYPE_2 . METHOD_2 ( host , STRING_1 ) ; <START> VAR_1 = host ; <END> return this ; } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 . put ( VAR_1 , VAR_2 + STRING_1 + VAR_3 ) ; <END> TYPE_1 . put ( VAR_4 , VAR_5 + STRING_1 + VAR_6 ) ; TYPE_6 . TYPE_7 . get ( ) . METHOD_2 ( new TYPE_3 ( STRING_2 ) , TYPE_4 . METHOD_3 ( ) . METHOD_4 ( new TYPE_5 ( ( short ) INT_1 ) ) ) ; } 
public String getId ( ) { <START> return VAR_1 ; <END> } 
public synchronized void METHOD_1 ( final List < TYPE_1 > VAR_1 ) throws IOException { <START> METHOD_2 ( new TYPE_2 < TYPE_3 > ( ) { <END> @Override public TYPE_3 call ( ) throws TYPE_4 { VAR_2 . METHOD_3 ( TYPE_8 . TYPE_9 . getId ( ) , TYPE_6 . METHOD_4 ( ) , new TYPE_7 ( VAR_1 ) ) ; return null ; } } ) ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , List < TYPE_1 > VAR_3 ) { if ( VAR_3 . isEmpty ( ) ) { return ; <START> } <END> VAR_4 . METHOD_2 ( VAR_2 , VAR_1 , VAR_3 ) ; } 
public static TYPE_1 get ( ) { if ( VAR_1 == null ) { synchronized ( TYPE_1 . class ) { VAR_1 = create ( ) ; } } <START> return VAR_1 ; <END> } 
private static void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( TYPE_1 . METHOD_3 ( STRING_1 ) , new TYPE_2 < Long > ( ) { @Override public Long getValue ( ) { long VAR_1 = 0 ; <START> for ( TYPE_3 VAR_2 : VAR_3 . VAR_4 . values ( ) ) { <END> VAR_1 += VAR_2 . size ( ) ; } return VAR_1 ; } } ) ; } 
public TYPE_1 METHOD_1 ( long VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_4 , VAR_1 ) ; if ( VAR_2 == null ) { LOG . warn ( STRING_1 , VAR_1 ) ; return TYPE_1 . TYPE_3 ; } <START> synchronized ( VAR_2 ) { <END> VAR_2 . METHOD_3 ( ) ; } return TYPE_1 . TYPE_4 ; } 
protected void METHOD_1 ( ) { try { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( ) ; } catch ( IOException e ) { throw TYPE_1 . METHOD_4 ( e ) ; } } 
public TYPE_3 . TYPE_4 . TYPE_5 METHOD_1 ( ) { TYPE_3 . TYPE_4 . TYPE_5 VAR_2 = new TYPE_3 . TYPE_4 . TYPE_5 ( ) ; VAR_2 . METHOD_2 ( VAR_3 ) ; VAR_2 . METHOD_3 ( VAR_4 ) ; VAR_2 . METHOD_4 ( VAR_5 ) ; <START> if ( ! ( VAR_6 instanceof Integer ) && ! ( VAR_6 instanceof Long ) ) { <END> LOG . error ( STRING_1 , this ) ; } VAR_2 . METHOD_5 ( ( ( TYPE_2 ) VAR_6 ) . METHOD_6 ( ) ) ; return VAR_2 ; } 
<START> protected TYPE_4 ( TYPE_1 VAR_2 ) { <END> this ( VAR_2 , new TYPE_2 ( ) , TYPE_3 . METHOD_1 ( Constants . VAR_3 , 2 ) ) ; } 
public long getValue ( Map < TYPE_1 , Set < TYPE_2 > > map ) { long value = 0 ; for ( TYPE_2 VAR_1 : map . get ( VAR_2 ) ) { <START> value += ( long ) VAR_1 . getValue ( ) ; <END> } return value ; } 
public static Map < String , String > METHOD_1 ( ) { <START> Map < String , String > map = METHOD_2 ( ) ; <END> String VAR_1 = STRING_1 ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { String value = entry . getValue ( ) ; if ( value != null && value . contains ( VAR_1 ) ) { map . put ( entry . getKey ( ) , METHOD_3 ( value ) ) ; } } return map ; } 
public TYPE_1 METHOD_1 ( String path ) throws TYPE_2 , IOException { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } 
public void METHOD_1 ( ) { when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( INT_1 ) ; <START> Assert . assertEquals ( INT_1 , METHOD_4 ( TYPE_1 . VAR_3 ) ) ; <END> when ( VAR_1 . METHOD_5 ( ) ) . METHOD_3 ( INT_2 ) ; Assert . assertEquals ( INT_2 , METHOD_4 ( TYPE_1 . VAR_4 ) ) ; Assert . assertEquals ( INT_3 , METHOD_4 ( TYPE_1 . VAR_5 ) ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { VAR_4 = VAR_2 ; VAR_5 = VAR_3 ; <START> METHOD_1 ( ) ; <END> } 
public synchronized List < TYPE_1 > METHOD_1 ( final TYPE_2 options ) throws IOException { <START> return METHOD_2 ( new TYPE_3 < List < TYPE_1 > > ( ) { <END> @Override public List < TYPE_1 > call ( ) throws TYPE_4 { List < TYPE_1 > result = new ArrayList < > ( ) ; for ( TYPE_7 . TYPE_8 . TYPE_1 VAR_1 : VAR_2 . METHOD_1 ( options . VAR_3 ( ) ) . METHOD_3 ( ) ) { result . add ( TYPE_6 . METHOD_4 ( VAR_1 ) ) ; } return result ; } } ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 options ) throws TYPE_3 { <START> return TYPE_4 . call ( LOG , new TYPE_5 < TYPE_1 > ( ) { <END> @Override public TYPE_1 call ( ) throws TYPE_6 , TYPE_7 { List < TYPE_8 > VAR_1 = new ArrayList < > ( ) ; for ( TYPE_11 . TYPE_12 . TYPE_8 VAR_2 : VAR_3 . METHOD_1 ( ) ) { VAR_1 . add ( TYPE_10 . METHOD_2 ( VAR_2 ) ) ; } return new TYPE_1 ( VAR_1 ) ; } } ) ; } 
public TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( ) <START> . METHOD_2 ( VAR_1 ) <END> . METHOD_2 ( VAR_2 ) . METHOD_2 ( VAR_3 ) . METHOD_2 ( VAR_4 ) ; } 
public String METHOD_1 ( ) { return STRING_1 + STRING_2 + STRING_3 + STRING_4 <START> + STRING_5 <END> + STRING_6 ; } 
public TYPE_1 METHOD_1 ( Map < String , Long > VAR_1 ) { VAR_2 = new HashMap < > ( ) ; for ( Map . Entry < String , Long > entry : VAR_1 . entrySet ( ) ) { long VAR_3 = entry . getValue ( ) ; <START> if ( VAR_3 > 0 ) { <END> VAR_2 . put ( entry . getKey ( ) , VAR_3 ) ; } } return this ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , <END> VAR_5 , VAR_6 , VAR_7 ) ; } 
public TYPE_2 ( TYPE_1 conf ) { super ( conf ) ; <START> VAR_2 = null ; <END> } 
public synchronized TYPE_1 METHOD_1 ( final Set < TYPE_2 > VAR_1 ) throws IOException { return METHOD_2 ( ( ) - > { <START> Set < TYPE_6 . TYPE_7 . TYPE_2 > VAR_2 = new HashSet < > ( ) ; <END> if ( VAR_1 == null ) { VAR_2 = null ; } else { for ( TYPE_2 field : VAR_1 ) { VAR_2 . add ( field . VAR_3 ( ) ) ; } } return TYPE_4 . METHOD_3 ( VAR_4 . METHOD_1 ( new TYPE_5 ( VAR_2 ) ) . METHOD_1 ( ) ) ; } ) ; } 
public void METHOD_1 ( String ... args ) throws TYPE_1 { <START> if ( args . length > 2 ) { <END> throw new TYPE_1 ( TYPE_3 . TYPE_4 . getMessage ( METHOD_2 ( ) ) ) ; } } 
public TYPE_5 ( ) { VAR_2 = new TYPE_1 ( TYPE_2 . METHOD_1 ( ) ) ; VAR_3 = new TYPE_3 ( TYPE_2 . METHOD_1 ( ) ) ; <START> VAR_4 = new TYPE_4 ( System . out ) ; <END> } 
public boolean remove ( ANNOTATION_1 Object object ) { if ( object == null ) { return false ; } <START> assert object != null : STRING_1 ; <END> synchronized ( object ) { if ( VAR_1 != null && VAR_1 . METHOD_1 ( ( T ) object ) ) { ANNOTATION_2 ( STRING_2 ) T VAR_2 = ( T ) object ; METHOD_2 ( VAR_2 ) ; return true ; } else { return false ; } } } 
public TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( ) . METHOD_2 ( VAR_1 ) . METHOD_2 ( VAR_2 ) . METHOD_2 ( VAR_3 ) . METHOD_2 ( VAR_4 ) . METHOD_2 ( VAR_5 ) <START> . METHOD_2 ( VAR_6 ) <END> . METHOD_2 ( VAR_7 ) ; } 
public boolean METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) { return false ; } Long VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( VAR_2 == null ) { return true ; } long VAR_3 = TYPE_1 . METHOD_4 ( TYPE_2 . VAR_5 ) ; if ( VAR_6 . METHOD_5 ( ) - VAR_2 < VAR_3 ) { return true ; } <START> return ! VAR_1 . METHOD_6 ( VAR_2 , null , true , false ) ; <END> } 
public boolean METHOD_1 ( Map < String , String > VAR_1 ) { <START> if ( METHOD_2 ( ) ) { <END> return true ; } if ( ! METHOD_3 ( VAR_1 ) ) { return false ; } return true ; } 
protected void METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_1 . METHOD_2 ( ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> METHOD_4 ( ) ; METHOD_5 ( ) ; LOG . info ( STRING_1 + STRING_2 , TYPE_4 . VAR_5 , VAR_1 , TYPE_2 . METHOD_6 ( TYPE_3 . VAR_7 ) , TYPE_2 . METHOD_7 ( TYPE_3 . VAR_7 ) , TYPE_2 . METHOD_8 ( TYPE_3 . VAR_7 ) , TYPE_2 . METHOD_8 ( TYPE_3 . VAR_8 ) ) ; METHOD_9 ( ) ; LOG . info ( STRING_3 , VAR_2 ) ; } 
private void METHOD_1 ( long offset ) throws TYPE_1 , IOException { TYPE_2 VAR_1 = VAR_2 . get ( VAR_3 . METHOD_2 ( ) ) . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( TYPE_3 . METHOD_5 ( TYPE_3 . TYPE_7 . VAR_5 ) ) ; try { METHOD_6 ( offset ) ; } catch ( IOException e ) { throw new TYPE_1 ( TYPE_5 . TYPE_6 . getMessage ( VAR_3 . METHOD_7 ( ) ) , <START> e ) ; <END> } METHOD_8 ( offset ) ; } 
protected TYPE_6 ( TYPE_1 uri , TYPE_2 VAR_2 ) { super ( uri , VAR_2 ) ; int VAR_3 = TYPE_3 . getInt ( TYPE_5 . VAR_5 ) ; VAR_6 = TYPE_4 . METHOD_1 ( STRING_1 , VAR_3 ) . create ( ) ; VAR_7 = ( int ) TYPE_3 . METHOD_2 ( TYPE_5 . VAR_8 ) ; VAR_9 = ( int ) TYPE_3 . METHOD_2 ( TYPE_5 . VAR_10 ) ; VAR_11 = <START> TYPE_3 . getInt ( TYPE_5 . VAR_12 ) ; <END> } 
public long METHOD_1 ( ) { try { return ( ( TYPE_1 ) in ) . METHOD_1 ( ) ; } catch ( IOException e ) { <START> throw new RuntimeException ( STRING_1 + e ) ; <END> } } 
public static TYPE_1 create ( final String VAR_1 ) throws IOException { if ( ! TYPE_2 . METHOD_1 ( TYPE_3 . get ( VAR_1 ) ) ) { TYPE_2 . METHOD_2 ( TYPE_3 . get ( VAR_1 ) ) ; } <START> TYPE_4 . set ( TYPE_5 . VAR_3 , STRING_1 ) ; <END> return new TYPE_1 ( ) ; } 
public void METHOD_1 ( TYPE_1 entry ) throws TYPE_2 { TYPE_3 VAR_1 = TYPE_3 . METHOD_2 ( entry ) ; if ( VAR_1 . getName ( ) . equals ( VAR_2 ) ) { METHOD_3 ( ) ; METHOD_4 ( VAR_1 ) ; <START> if ( TYPE_4 . METHOD_5 ( ) && entry . VAR_3 ( ) ) { <END> VAR_4 . METHOD_6 ( Constants . VAR_5 ) ; } } else { METHOD_7 ( VAR_1 , entry . VAR_3 ( ) ) ; } } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof TYPE_1 ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> return TYPE_2 . METHOD_1 ( VAR_1 , that . VAR_1 ) <END> && TYPE_2 . METHOD_1 ( VAR_2 , that . VAR_2 ) && TYPE_2 . METHOD_1 ( VAR_3 , that . VAR_3 ) ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } 
public int METHOD_1 ( ) { return TYPE_1 <START> . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) ; <END> } 
public static void METHOD_1 ( String message ) { System . err . println ( message ) ; TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_1 ( VAR_2 , null , VAR_3 , null , true ) ; <END> } 
protected void METHOD_1 ( ) throws IOException { long VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( VAR_1 == VAR_3 && VAR_4 != null && VAR_4 . METHOD_3 ( ) != 0 ) { return ; } METHOD_4 ( ) ; METHOD_5 ( VAR_1 ) ; if ( VAR_5 ) { METHOD_6 ( VAR_1 ) ; } VAR_3 = VAR_1 ; VAR_6 = VAR_2 . METHOD_7 ( ) ; <START> VAR_7 = VAR_2 . METHOD_8 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! VAR_1 . METHOD_2 ( ) ) { VAR_1 . channel ( ) . close ( ) ; } try ( TYPE_2 VAR_2 = new TYPE_2 ( VAR_3 ) ) { if ( VAR_1 . METHOD_3 ( ) != null ) { METHOD_4 ( VAR_1 . METHOD_3 ( ) ) ; VAR_4 . METHOD_5 ( ) ; VAR_5 . METHOD_5 ( ) ; VAR_6 . METHOD_5 ( ) ; <START> } <END> } } 
public void METHOD_1 ( ) throws Exception { VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) . METHOD_4 ( TYPE_3 . VAR_3 , STRING_2 ) . METHOD_5 ( 3 ) . METHOD_6 ( 2 ) . build ( ) ; <START> boolean VAR_4 = false ; <END> try { VAR_1 . start ( ) ; TYPE_2 VAR_5 = VAR_1 . METHOD_7 ( ) ; METHOD_8 ( VAR_5 ) ; VAR_6 = true ; } finally { METHOD_9 ( ) ; } } 
public TYPE_1 METHOD_1 ( ) { VAR_1 = null ; <START> VAR_2 = true ; <END> return this ; } 
<START> private boolean METHOD_1 ( ) throws IOException { <END> return VAR_1 && VAR_2 ; } 
public void METHOD_1 ( ) throws Exception { final String VAR_1 = STRING_1 ; try { new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 + TYPE_5 . VAR_6 + VAR_1 , VAR_7 , TYPE_4 . VAR_9 , null , TYPE_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . VAR_10 ) ) . run ( ) ; <START> Assert . VAR_11 ( STRING_2 ) ; <END> } catch ( TYPE_3 e ) { } } 
private TYPE_1 ( String name , String command , Integer VAR_2 , Integer VAR_3 ) { VAR_4 = name ; <START> VAR_5 = new String [ ] { STRING_1 , STRING_2 , command } ; <END> VAR_6 = VAR_2 ; VAR_7 = VAR_3 ; } 
public static void METHOD_1 ( final TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( ) . METHOD_3 ( new Thread ( ) { @Override public void run ( ) { try { VAR_1 . METHOD_4 ( ) ; } catch ( Exception e ) { <START> LOG . error ( STRING_1 ) ; <END> System . VAR_2 ( 0 ) ; } } } ) ; } 
public void METHOD_1 ( ) { <START> synchronized ( this ) { <END> if ( ! VAR_1 ) { VAR_2 . METHOD_2 ( ) ; try { VAR_2 . METHOD_3 ( ) ; } catch ( InterruptedException e ) { Thread . VAR_3 ( ) . METHOD_2 ( ) ; } finally { VAR_1 = true ; VAR_2 = null ; LOG . info ( STRING_1 ) ; } } } } 
<START> public synchronized TYPE_1 METHOD_1 ( ) { <END> TYPE_1 < ? > VAR_1 = VAR_2 . get ( VAR_2 . size ( ) - 1 ) ; return VAR_1 ; } 
public static boolean METHOD_1 ( String input ) { if ( TYPE_1 . containsKey ( input ) ) { return true ; } if ( TYPE_2 . containsKey ( input ) ) { return true ; <START> } <END> for ( TYPE_3 VAR_1 : TYPE_3 . values ( ) ) { TYPE_4 matcher = VAR_1 . VAR_2 . matcher ( input ) ; if ( matcher . VAR_3 ( ) ) { return true ; } } return false ; } 
private void METHOD_1 ( ) { <START> VAR_1 = TYPE_4 . TYPE_5 . create ( ) ; <END> VAR_2 = new TYPE_2 ( VAR_3 , VAR_1 ) ; VAR_4 = new TYPE_3 ( VAR_3 , VAR_1 ) ; } 
public String METHOD_1 ( ) { <START> <END> return VAR_1 != null ? VAR_1 : STRING_1 ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 , TYPE_3 . VAR_3 , INT_1 ) ; VAR_4 . run ( STRING_2 , STRING_3 , STRING_4 , STRING_1 ) ; <START> byte [ ] VAR_5 = TYPE_2 . METHOD_3 ( 0 , INT_2 ) ; <END> Assert . VAR_6 ( VAR_5 , VAR_7 . METHOD_4 ( ) ) ; } 
public TYPE_1 create ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 . METHOD_1 ( VAR_2 != null , STRING_1 ) ; LOG . info ( STRING_2 , TYPE_5 . class . getName ( ) ) ; TYPE_6 VAR_3 = VAR_1 . get ( TYPE_6 . class ) ; TYPE_1 VAR_4 = new TYPE_5 ( VAR_3 , VAR_2 ) ; <START> VAR_1 . add ( TYPE_5 . class , VAR_4 ) ; <END> return VAR_4 ; } 
static TYPE_1 create ( String name , Object VAR_1 , String [ ] VAR_2 ) { TYPE_1 key = new TYPE_1 ( name ) ; <START> for ( String VAR_3 : VAR_2 ) { <END> TYPE_2 . put ( VAR_3 , key ) ; } TYPE_2 . put ( name , key ) ; TYPE_3 . put ( key , VAR_1 ) ; return key ; } 
public static void METHOD_1 ( String VAR_1 ) throws IOException { Path VAR_2 = TYPE_1 . get ( VAR_1 ) ; TYPE_2 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; try { TYPE_2 . METHOD_1 ( VAR_2 ) ; <START> } catch ( TYPE_3 e ) { <END> throw new IOException ( STRING_1 + VAR_1 ) ; } } 
public static void METHOD_1 ( String path ) throws IOException { try { TYPE_1 . METHOD_2 ( TYPE_2 . get ( path ) ) ; <START> } catch ( TYPE_3 e ) { <END> throw new IOException ( STRING_1 + path ) ; } } 
public void start ( Boolean VAR_1 ) throws IOException { super . start ( VAR_1 ) ; VAR_2 = new TYPE_1 ( ) ; if ( VAR_1 ) { <START> LOG . info ( STRING_1 , VAR_3 . size ( ) ) ; <END> VAR_4 = METHOD_1 ( ) . METHOD_2 ( new TYPE_2 ( TYPE_5 . VAR_6 , new TYPE_3 ( ) , ( int ) TYPE_4 . METHOD_3 ( TYPE_6 . VAR_8 ) ) ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 request ) { TYPE_1 result ; try { result = VAR_1 . METHOD_2 ( request ) ; request . VAR_2 ( result . VAR_3 ( ) ) ; } catch ( TYPE_3 e ) { <START> LOG . error ( STRING_1 , request . VAR_4 ( ) , e ) ; <END> result = null ; } return result ; } 
TYPE_4 ( TYPE_1 request , TYPE_2 result ) <START> throws IOException { <END> TYPE_3 . METHOD_1 ( result , STRING_1 ) ; VAR_2 = request ; VAR_3 = result ; } 
private TYPE_1 METHOD_1 ( TYPE_2 request ) throws IOException { TYPE_1 result ; try { result = VAR_1 . METHOD_2 ( request ) ; request . VAR_2 ( result . VAR_3 ( ) ) ; } catch ( TYPE_3 e ) { <START> throw new IOException ( e . getMessage ( ) ) ; <END> } return result ; } 
public void METHOD_1 ( ) { if ( VAR_1 ) { return ; } VAR_1 = true ; VAR_2 . METHOD_1 ( ) ; <START> VAR_2 . close ( ) ; <END> } 
<START> public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 conf , <END> TYPE_3 VAR_3 ) { super ( VAR_2 ) ; VAR_4 = conf ; Path path = new Path ( VAR_2 . toString ( ) ) ; try { TYPE_4 . METHOD_1 ( VAR_3 ) ; VAR_5 = path . VAR_6 ( VAR_3 ) ; } catch ( IOException e ) { LOG . warn ( STRING_1 , VAR_2 , e . getMessage ( ) ) ; throw new RuntimeException ( STRING_2 , e ) ; } } 
public void METHOD_1 ( TYPE_1 ctx , Object msg ) { if ( ! METHOD_2 ( msg ) ) { ctx . VAR_1 ( msg ) ; return ; } TYPE_2 message = ( ( TYPE_3 ) msg ) . getMessage ( ) ; if ( message . VAR_2 ( ) ) { METHOD_3 ( ctx , message . VAR_3 ( ) ) ; <START> } else { <END> TYPE_4 . METHOD_4 ( message . VAR_4 ( ) ) ; METHOD_5 ( ctx , message . VAR_5 ( ) ) ; } } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 >= VAR_2 ) { return null ; } <START> METHOD_2 ( ) ; <END> ByteBuffer buffer = VAR_3 . read ( VAR_1 , Math . VAR_4 ( VAR_5 , VAR_2 - VAR_1 ) ) ; TYPE_1 VAR_6 = new TYPE_2 ( buffer , buffer . VAR_7 ( ) ) ; VAR_1 += VAR_6 . METHOD_3 ( ) ; return VAR_6 ; } 
private TYPE_3 ( ) { <START> if ( TYPE_1 . METHOD_1 ( ) ) { <END> VAR_2 = TYPE_1 . METHOD_2 ( ) ; VAR_3 = TYPE_1 . METHOD_3 ( ) ; } else { VAR_2 = "" ; VAR_3 = "" ; } VAR_4 = TYPE_2 . METHOD_4 ( ) . METHOD_5 ( ) ; } 
protected void METHOD_1 ( ) throws Exception { <START> LOG . info ( STRING_1 , <END> TYPE_2 . VAR_2 , VAR_3 , VAR_4 ) ; if ( VAR_5 != null ) { VAR_5 . METHOD_2 ( ) ; VAR_5 = null ; } if ( VAR_6 != null ) { VAR_6 . METHOD_2 ( ) ; VAR_6 = null ; } TYPE_1 . METHOD_3 ( ) ; VAR_4 = false ; } 
public final void METHOD_1 ( ) throws Exception { <START> if ( TYPE_1 . METHOD_2 ( ) ) { <END> return ; } VAR_1 . METHOD_3 ( ) ; } 
public void start ( ) throws Exception { <START> LOG . info ( STRING_1 , VAR_1 ) ; <END> METHOD_1 ( true ) ; METHOD_2 ( ) ; } 
public static void run ( TYPE_1 VAR_1 ) { try { LOG . info ( STRING_1 , VAR_1 ) ; VAR_1 . start ( ) ; System . VAR_2 ( 0 ) ; } catch ( Exception e ) { LOG . error ( STRING_2 , VAR_1 , e ) ; try { <START> LOG . info ( STRING_3 , VAR_1 ) ; <END> VAR_1 . METHOD_1 ( ) ; } catch ( Exception VAR_3 ) { LOG . error ( STRING_4 , VAR_1 , VAR_3 ) ; } System . VAR_2 ( - 1 ) ; } } 
public void METHOD_1 ( T resource ) { if ( resource != null ) { VAR_1 . add ( resource ) ; <START> VAR_2 . METHOD_2 ( ) ; <END> try ( TYPE_1 r = new TYPE_1 ( VAR_3 ) ) { VAR_4 . METHOD_3 ( ) ; } } } 
public void run ( ) { TYPE_1 client = null ; <START> try { <END> client = TYPE_3 . TYPE_4 . METHOD_1 ( ) ; } catch ( IOException e ) { Assert . VAR_1 ( STRING_1 ) ; } finally { TYPE_3 . TYPE_4 . METHOD_2 ( client ) ; } } 
public T METHOD_1 ( ) throws IOException { <START> return METHOD_1 ( VAR_1 , null ) ; <END> } 
public TYPE_1 METHOD_1 ( ) throws IOException { if ( VAR_1 >= VAR_2 ) { return null ; } ByteBuffer buffer = <START> ByteBuffer . VAR_3 ( VAR_4 , ( int ) VAR_1 , ( int ) ( Math . VAR_5 ( VAR_6 , VAR_2 ) - VAR_1 ) ) ; <END> TYPE_1 VAR_7 = new TYPE_2 ( buffer , buffer . VAR_8 ( ) ) ; VAR_1 += VAR_7 . METHOD_2 ( ) ; return VAR_7 ; } 
public void METHOD_1 ( ) throws Exception { Assert . assertEquals ( TYPE_1 . TYPE_2 . VAR_3 . format ( STRING_1 ) , TYPE_1 . TYPE_2 . VAR_3 . format ( STRING_1 ) ) ; <START> Assert . VAR_4 ( TYPE_1 . VAR_5 , TYPE_1 . VAR_5 ) ; <END> } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> boolean VAR_2 = VAR_1 . METHOD_2 ( ) ; long VAR_3 = VAR_1 . METHOD_3 ( ) ; TYPE_2 options = TYPE_2 . METHOD_4 ( ) ; options . VAR_4 ( VAR_2 ) ; Assert . assertEquals ( VAR_2 , options . VAR_2 ( ) ) ; options . VAR_5 ( VAR_3 ) ; Assert . assertEquals ( VAR_3 , options . VAR_6 ( ) ) ; } 
public void run ( ) { try { METHOD_1 ( ) ; } catch ( RuntimeException e ) { LOG . error ( STRING_1 , VAR_1 . getName ( ) , e ) ; <START> System . VAR_2 ( - 1 ) ; <END> } finally { if ( VAR_3 != null ) { try { VAR_3 . close ( ) ; } catch ( IOException e ) { LOG . warn ( STRING_2 , VAR_1 . getName ( ) , e . getMessage ( ) ) ; } } } } 
public TYPE_1 METHOD_1 ( TYPE_2 options ) { if ( options . VAR_1 ( ) != null ) { return new TYPE_3 ( options ) ; } else { return new TYPE_4 ( this , options ) ; } <START> } <END> 
public TYPE_1 create ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 . METHOD_1 ( VAR_2 != null , STRING_1 ) ; LOG . info ( STRING_2 , TYPE_5 . class . getName ( ) ) ; <START> return new TYPE_6 ( VAR_1 , VAR_2 ) ; <END> } 
protected File METHOD_1 ( String path , byte [ ] VAR_1 ) throws IOException , TYPE_1 { <START> File VAR_2 = new File ( System . getProperty ( STRING_1 ) + path ) ; <END> VAR_2 . METHOD_2 ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( VAR_2 ) ; VAR_3 . write ( VAR_1 ) ; VAR_3 . close ( ) ; return VAR_2 ; } 
public String METHOD_1 ( ) { return STRING_1 + STRING_2 + STRING_3 + STRING_4 <START> + STRING_5 <END> + STRING_6 ; } 
<START> public Collection < TYPE_1 > METHOD_1 ( ) { <END> List < Map . Entry < Class < ? > , TYPE_1 > > VAR_1 = new ArrayList < > ( VAR_2 . entrySet ( ) ) ; Collections . VAR_3 ( VAR_1 , new TYPE_2 ( ) ) ; List < TYPE_1 > VAR_4 = new ArrayList < > ( ) ; for ( Map . Entry < Class < ? > , TYPE_1 > entry : VAR_1 ) { VAR_4 . add ( entry . getValue ( ) ) ; } return VAR_4 ; } 
public void METHOD_1 ( boolean VAR_1 ) throws IOException { LOG . info ( STRING_1 , VAR_2 . getName ( ) ) ; <START> TYPE_1 is = VAR_3 . METHOD_2 ( ) ; <END> if ( VAR_1 ) { VAR_2 . METHOD_1 ( is ) ; } VAR_4 = is . VAR_5 ( ) ; is . close ( ) ; } 
public void METHOD_1 ( ) { try { final String VAR_1 = STRING_1 ; TYPE_1 VAR_2 = new TYPE_1 ( STRING_2 , VAR_1 , STRING_3 ) ; TYPE_2 exception = TYPE_2 . METHOD_2 ( VAR_2 ) ; Assert . assertEquals ( VAR_1 , exception . getMessage ( ) ) ; <START> } catch ( Exception e ) { <END> Assert . VAR_3 ( STRING_4 + e . getMessage ( ) ) ; } } 
public TYPE_4 ( TYPE_2 . TYPE_3 request ) throws Exception { VAR_2 = VAR_3 . METHOD_1 ( request . VAR_4 ( ) , request . getId ( ) , request . VAR_5 ( ) , request . VAR_6 ( ) ) ; VAR_7 = request . getId ( ) ; VAR_8 = request . VAR_5 ( ) ; <START> VAR_9 = VAR_8 + request . VAR_10 ( ) ; <END> } 
<START> private void METHOD_1 ( String VAR_1 ) throws IOException { <END> TYPE_1 . METHOD_2 ( VAR_1 ) ; TYPE_1 . METHOD_3 ( VAR_1 ) ; TYPE_1 . METHOD_4 ( VAR_1 ) ; LOG . debug ( STRING_1 , VAR_1 ) ; } 
private TYPE_1 METHOD_1 ( long VAR_1 , long VAR_2 ) throws TYPE_2 { TYPE_3 key = new TYPE_3 ( VAR_1 , VAR_2 ) ; TYPE_1 VAR_3 = VAR_4 . get ( key ) ; if ( VAR_3 == null ) { <START> try { <END> throw new TYPE_2 ( TYPE_4 . VAR_6 , VAR_2 , VAR_1 ) ; } catch ( Throwable e ) { LOG . error ( STRING_1 , e ) ; throw e ; } } return VAR_3 ; } 
public String toString ( ) { return TYPE_1 . METHOD_1 ( this ) <START> . add ( STRING_1 , VAR_1 ) <END> . add ( STRING_2 , VAR_2 ) . add ( STRING_3 , VAR_3 ) . add ( STRING_4 , VAR_4 ) . toString ( ) ; } 
public long METHOD_1 ( ) { LOG . debug ( STRING_1 ) ; long VAR_1 = Constants . VAR_2 ; LOG . debug ( STRING_2 ) ; <START> return VAR_1 ; <END> } 
<START> public static TYPE_1 create ( TYPE_2 VAR_1 ) { <END> return new TYPE_3 ( null , VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 client = <START> new TYPE_2 ( VAR_1 , VAR_2 ) ; <END> VAR_3 . add ( client ) ; return client ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_1 . create ( ) ; Assert . assertEquals ( VAR_2 , VAR_1 . METHOD_2 ( ) ) ; for ( int VAR_3 = 0 ; VAR_3 < VAR_4 - 1 ; VAR_3 ++ ) { Assert . assertTrue ( VAR_5 . METHOD_3 ( ) ) ; VAR_5 . METHOD_4 ( VAR_6 ) ; <START> METHOD_5 ( VAR_1 , 1 , Constants . VAR_7 ) ; <END> Assert . assertEquals ( VAR_2 , VAR_1 . METHOD_2 ( ) ) ; } } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 . METHOD_2 ( TYPE_2 . class , STRING_1 ) ; } 
private TYPE_1 ( ) { <START> VAR_2 = TYPE_2 . VAR_4 ; <END> } 
<START> public long METHOD_1 ( ) <END> { int VAR_1 = VAR_2 . getInt ( TYPE_1 . TYPE_2 . VAR_5 , INT_1 ) ; if ( VAR_1 > 0 ) { long VAR_6 = INT_2 * INT_3 * VAR_1 ; return VAR_6 ; } return INT_4 ; } 
public String METHOD_1 ( ) { Object path = VAR_1 . get ( VAR_2 ) ; return path != null ? path . toString ( ) : VAR_3 ; <START> } <END> 
public int METHOD_1 ( ) { Object version = VAR_1 . get ( VAR_2 ) ; return version != null ? Integer . parseInt ( version . toString ( ) ) : VAR_3 ; <START> } <END> 
public final void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 ) throws TYPE_2 { <START> throw new TYPE_2 ( ) ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; if ( ! name . equals ( that . name ) ) return false ; return true ; <START> } <END> 
<START> public TYPE_2 ( TYPE_1 VAR_2 , String VAR_3 ) { <END> VAR_4 = VAR_2 ; VAR_5 = VAR_3 ; } 
public void remove ( TYPE_1 file ) throws IOException , TYPE_2 { TYPE_3 s = VAR_1 . METHOD_1 ( STRING_1 , STRING_2 , TYPE_4 . METHOD_2 ( file . getPath ( ) ) ) ; TYPE_5 . METHOD_3 ( s ) ; <START> s . close ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 name ) throws IOException , TYPE_2 { TYPE_3 s = VAR_1 . METHOD_2 ( STRING_1 , STRING_2 , name . toString ( ) , STRING_3 , STRING_4 , STRING_5 ) ; <START> TYPE_4 . METHOD_3 ( s ) ; <END> s . close ( ) ; } 
public void close ( ) throws IOException { super . close ( ) ; VAR_1 . close ( ) ; <START> } <END> 
<START> public int METHOD_1 ( File file ) { <END> return INT_1 ; } 
public void METHOD_1 ( TYPE_1 event ) throws TYPE_2 { try ( TYPE_3 is = VAR_1 . METHOD_2 ( STRING_1 , event . VAR_2 ( ) ) ) { TYPE_4 . METHOD_3 ( is ) ; } catch ( IOException e ) { <START> throw new TYPE_2 ( e . getMessage ( ) ) ; <END> } } 
public void remove ( TYPE_1 file ) throws IOException , TYPE_2 { try ( TYPE_3 stream = VAR_1 . METHOD_1 ( STRING_1 , STRING_2 , TYPE_4 . METHOD_2 ( file . getPath ( ) ) ) ) { TYPE_5 . METHOD_3 ( stream ) ; <START> stream . close ( ) ; <END> } } 
public void METHOD_1 ( TYPE_1 name ) throws IOException , TYPE_2 { try ( TYPE_3 stream = VAR_1 . METHOD_2 ( STRING_1 , STRING_2 , name . toString ( ) , STRING_3 , STRING_4 , STRING_5 ) ) { TYPE_4 . METHOD_3 ( stream ) ; <START> stream . close ( ) ; <END> } } 
public Map < String , String > METHOD_1 ( ) throws IOException , TYPE_1 { TYPE_2 VAR_1 = null ; <START> try { <END> VAR_1 = new TYPE_2 ( new TYPE_3 ( VAR_2 . METHOD_2 ( STRING_1 ) ) ) ; return METHOD_3 ( VAR_1 ) ; } finally { if ( VAR_1 != null ) { VAR_1 . close ( ) ; } } } 
private String METHOD_1 ( ) { String VAR_1 = System . VAR_2 ( STRING_1 ) ; <START> return VAR_1 != null && ! VAR_1 . equals ( "" ) ? VAR_1 + STRING_2 : STRING_3 ; <END> } 
public String METHOD_1 ( ) { <START> return VAR_1 . getId ( ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( String source , String VAR_1 , String VAR_2 ) { TYPE_2 . METHOD_2 ( source , STRING_1 ) ; <START> TYPE_2 . METHOD_2 ( source , STRING_2 ) ; <END> logger . debug ( STRING_3 + STRING_4 , source , VAR_1 , VAR_2 ) ; final List < TYPE_3 > VAR_3 = VAR_4 . METHOD_1 ( source , VAR_1 , VAR_2 ) ; logger . debug ( STRING_5 , VAR_3 . size ( ) , VAR_3 ) ; return VAR_5 . METHOD_3 ( VAR_3 ) ; } 
public Response METHOD_1 ( final TYPE_1 request , final int [ ] VAR_1 , int VAR_2 , final long VAR_3 ) { Response response = null ; while ( VAR_2 > 0 ) { response = METHOD_2 ( request ) ; if ( ! METHOD_3 ( response , VAR_1 ) ) { break ; } try { Thread . VAR_4 ( VAR_3 ) ; } catch ( final InterruptedException e ) { } VAR_2 -- ; } <START> VAR_5 = request ; <END> VAR_6 = response ; return response ; } 
public Map < String , Integer > METHOD_1 ( ) { Map < String , Object > VAR_1 = ( Map < String , Object > ) METHOD_2 ( ) . get ( VAR_2 ) ; Map < String , Integer > VAR_3 = new HashMap < String , Integer > ( ) ; <START> for ( String VAR_4 : VAR_1 . keySet ( ) ) { <END> VAR_3 . put ( VAR_4 , ( Integer ) VAR_1 . get ( VAR_4 ) ) ; } return VAR_3 ; } 
private boolean METHOD_1 ( String VAR_1 ) { <START> int res = this . ctx . VAR_2 ( VAR_1 ) ; <END> return ( res == TYPE_1 . VAR_4 ) ; } 
public Map < String , Object > METHOD_1 ( ) { if ( VAR_1 == null || VAR_1 . length == 0 ) { return Collections . VAR_2 ( ) ; } Map < String , Object > VAR_3 = null ; for ( TYPE_2 . TYPE_3 VAR_4 : VAR_1 ) { if ( VAR_4 != null ) { if ( VAR_3 == null ) { <START> VAR_3 = new HashMap < > ( ) ; <END> } VAR_3 . put ( VAR_4 . getName ( ) , VAR_4 . getValue ( ) ) ; } } return VAR_3 ; } 
protected Collection < String > METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) . containsKey ( VAR_2 ) ) { ArrayList < String > VAR_3 = new ArrayList < > ( ) ; for ( String VAR_4 : VAR_1 . METHOD_2 ( ) . get ( VAR_2 ) . split ( STRING_1 ) ) { if ( ! VAR_4 . trim ( ) . equals ( "" ) ) { VAR_3 . add ( VAR_4 ) ; } } return VAR_3 ; } <START> return Collections . VAR_5 ( ) ; <END> } 
public static int METHOD_1 ( String value , int VAR_1 ) { if ( METHOD_2 ( value ) ) { return VAR_1 ; } try { return Integer . parseInt ( value ) ; } catch ( TYPE_1 e ) { <START> return VAR_1 ; <END> } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; try { Class . VAR_3 ( STRING_1 , false , this . getClass ( ) . METHOD_4 ( ) ) ; VAR_2 . METHOD_5 ( new TYPE_3 ( ) ) ; <START> VAR_2 . METHOD_5 ( new TYPE_4 ( VAR_2 ) ) ; <END> } catch ( TYPE_5 e ) { logger . debug ( STRING_2 + STRING_3 ) ; } return VAR_2 ; } 
TYPE_8 ( TYPE_1 VAR_2 , List < TYPE_2 > VAR_3 , TYPE_3 VAR_4 ) { this . id = TYPE_8 . VAR_5 . METHOD_1 ( ) ; this . VAR_6 = new TYPE_4 < > ( ) ; this . VAR_4 = VAR_4 ; this . VAR_3 = VAR_3 ; this . VAR_7 . add ( VAR_2 ) ; this . VAR_8 = TYPE_7 . VAR_10 ; VAR_11 = new TYPE_5 ( 1 ) ; VAR_12 = TYPE_6 . VAR_14 ; <START> } <END> 
void METHOD_1 ( List < Long > VAR_1 ) { if ( VAR_2 . equals ( TYPE_1 . VAR_4 ) || VAR_2 . equals ( TYPE_1 . VAR_5 ) ) { <START> TYPE_2 . VAR_7 . METHOD_2 ( this , VAR_1 ) ; <END> } else { METHOD_3 ( Level . VAR_8 , STRING_1 + VAR_2 . toString ( ) + STRING_2 ) ; } } 
public void add ( TYPE_1 < T > VAR_1 ) { <START> this . VAR_2 = ( this . VAR_2 == false ) <END> ? false : VAR_1 . METHOD_1 ( ) ; this . VAR_3 . addAll ( VAR_1 . METHOD_2 ( ) ) ; } 
void METHOD_1 ( ) { <START> Collection < TYPE_1 > results = Collections . VAR_1 ; <END> try { results = TYPE_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; } catch ( TYPE_2 ex ) { TYPE_3 . METHOD_4 ( ex ) ; } METHOD_5 ( results ) ; } 
List < String > METHOD_1 ( ) { List < String > VAR_1 = new ArrayList ( VAR_2 . keySet ( ) ) ; <START> Collections . VAR_3 ( VAR_1 ) ; <END> return VAR_1 ; } 
public boolean METHOD_1 ( ) { String VAR_1 = file . VAR_2 ( ) ; if ( StringUtils . isEmpty ( VAR_1 ) ) { TYPE_1 VAR_3 = null ; try { VAR_3 = new TYPE_1 ( ) ; } catch ( TYPE_1 . TYPE_4 ex ) { logger . log ( Level . VAR_4 , STRING_1 ) ; return false ; } VAR_1 = VAR_3 . METHOD_2 ( file ) ; if ( ! StringUtils . isEmpty ( VAR_1 ) ) file . VAR_5 ( VAR_1 ) ; <START> } <END> return TYPE_3 . equals ( VAR_1 ) ; } 
<START> public TYPE_2 ( List < TYPE_1 > VAR_2 , List < TYPE_1 > VAR_3 , int VAR_4 , int VAR_5 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; } 
protected void METHOD_1 ( TYPE_1 . Set properties ) { if ( TYPE_2 . getInstance ( ) . METHOD_2 ( ) && TYPE_3 . METHOD_3 ( ) ) { properties . put ( new TYPE_4 < > ( VAR_1 , VAR_2 , "" , <START> VAR_3 != null ? VAR_3 : "" ) ) ; <END> if ( VAR_3 == null ) { new TYPE_5 ( VAR_4 , this , new TYPE_6 ( ) ) . METHOD_4 ( ) ; } } } 
<START> public void METHOD_1 ( Long VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
<START> public TYPE_1 ( String key , String value , String VAR_2 ) { <END> this . key = key . trim ( ) ; this . value = value . trim ( ) ; this . VAR_2 = VAR_2 . trim ( ) ; } 
public String METHOD_1 ( ) { <START> return TYPE_1 . VAR_2 ; <END> } 
<START> public static TYPE_1 get ( String VAR_1 ) { <END> if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } switch ( VAR_1 . METHOD_1 ( ) ) { case STRING_2 : return new TYPE_2 ( ) ; case STRING_3 : return new TYPE_3 ( ) ; case STRING_4 : return new TYPE_4 ( ) ; case STRING_5 : return new TYPE_5 ( ) ; case STRING_6 : return new TYPE_6 ( ) ; default : throw new IllegalArgumentException ( VAR_1 + STRING_7 ) ; } } 
static void METHOD_1 ( TYPE_1 model ) throws IOException { METHOD_2 ( ) ; <START> TYPE_2 VAR_1 = new TYPE_2 ( new File ( VAR_2 ) ) ; <END> TYPE_3 VAR_3 ; VAR_3 = new TYPE_3 ( model , new TYPE_4 ( VAR_1 ) ) ; VAR_3 . METHOD_3 ( ) ; VAR_1 . close ( ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { TYPE_1 VAR_2 = null ; try { VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; } catch ( TYPE_3 ex ) { <START> throw new TYPE_2 ( STRING_1 + ex . getMessage ( ) , ex ) ; <END> } return VAR_2 ; } 
void METHOD_1 ( ) { VAR_1 ++ ; <START> TYPE_2 . this . METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_1 . VAR_3 ) ) ; <END> METHOD_4 ( ) ; TYPE_2 . VAR_4 . METHOD_2 ( null ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> VAR_2 . METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( ) ; } } 
<START> public int size ( ) { <END> return VAR_1 . size ( ) ; } 
<START> public static String METHOD_1 ( ) { <END> return METHOD_2 ( ) . METHOD_3 ( ) + File . VAR_1 + VAR_2 ; } 
public void METHOD_1 ( String VAR_1 ) { if ( status != TYPE_1 . VAR_3 ) { <START> logger . log ( Level . VAR_4 , STRING_1 , VAR_1 ) ; <END> } } 
<START> public TYPE_4 ( TYPE_1 < TYPE_2 < ? > > VAR_2 , TYPE_3 listener ) { <END> this . VAR_3 = VAR_2 ; this . listener = listener ; } 
private void METHOD_1 ( Long VAR_1 ) { String VAR_2 = Long . toString ( VAR_1 ) ; String VAR_3 = STRING_1 + VAR_2 ; try { TYPE_1 VAR_4 = VAR_5 . METHOD_2 ( VAR_3 ) ; } catch ( TYPE_2 | IOException ex ) { <START> logger . log ( Level . VAR_6 , STRING_2 + VAR_2 , ex ) ; <END> } } 
<START> int METHOD_1 ( ) { <END> int VAR_1 = - 1 ; String value = VAR_2 . get ( VAR_3 ) ; if ( value != null ) { VAR_1 = Integer . parseInt ( value ) ; } return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 file ) { TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . METHOD_5 ( TYPE_3 . VAR_1 ) ) ; <START> VAR_2 = file ; <END> VAR_3 . METHOD_6 ( METHOD_7 ( file ) ) ; TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . METHOD_5 ( TYPE_3 . VAR_4 ) ) ; } 
private void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( action - > { METHOD_4 ( false ) ; } , TYPE_1 . METHOD_5 ( TYPE_3 . VAR_2 , 0 ) , <START> TYPE_4 . VAR_4 ) ; <END> VAR_5 = new TYPE_2 ( this ) ; add ( VAR_5 ) ; METHOD_6 ( ) ; METHOD_7 ( false ) ; } 
synchronized private void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; try { VAR_1 . METHOD_3 ( INT_1 , TimeUnit . VAR_2 ) ; } catch ( InterruptedException ex ) { logger . log ( Level . VAR_3 , STRING_1 , ex ) ; } <START> VAR_1 = null ; <END> } } 
public TYPE_3 ( org . VAR_2 . VAR_3 . TYPE_2 . TYPE_3 event ) { super ( TYPE_4 . TYPE_1 . VAR_7 . name ( ) , null , event . VAR_8 ( ) . METHOD_1 ( ) ) ; <START> VAR_9 = event . VAR_8 ( ) ; <END> VAR_10 = VAR_9 . METHOD_1 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> boolean VAR_2 = VAR_1 == null || VAR_1 . METHOD_2 ( ) == null ; <END> VAR_3 . METHOD_3 ( VAR_2 ) ; VAR_4 . METHOD_3 ( VAR_2 ) ; } 
<START> void METHOD_1 ( boolean status ) { <END> VAR_1 = status ; } 
<START> boolean METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> TYPE_2 ( String VAR_2 , boolean VAR_3 , boolean VAR_4 ) { <END> this . VAR_2 = TYPE_1 . METHOD_1 ( VAR_2 , TYPE_1 . TYPE_3 . VAR_6 ) ; ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_7 = "" ; this . VAR_8 = VAR_2 ; } 
<START> private TYPE_6 ( TYPE_1 file , String VAR_2 ) throws TYPE_2 , TYPE_3 , TYPE_4 { <END> super ( VAR_2 ) ; this . VAR_2 = VAR_2 ; VAR_3 = TYPE_5 . METHOD_1 ( file ) ; if ( VAR_3 == null ) { VAR_4 = true ; VAR_3 = TYPE_5 . METHOD_2 ( file ) ; } } 
} catch ( TYPE_1 e ) { VAR_2 = false ; <START> System . out . println ( STRING_1 + e . toString ( ) ) ; <END> } 
public void METHOD_1 ( ) { try { TYPE_1 . METHOD_2 ( ) ; try { Thread . VAR_1 ( INT_1 ) ; } catch ( InterruptedException ex ) { } <START> TYPE_2 . METHOD_3 ( TYPE_3 ) ; <END> } catch ( TYPE_4 | IOException ex ) { TYPE_5 . METHOD_4 ( ex ) ; } METHOD_5 ( TYPE_3 . exists ( ) ) ; } 
TYPE_5 ( TYPE_1 VAR_2 ) { super ( TYPE_2 . create ( new TYPE_3 ( VAR_2 ) , true ) , TYPE_4 . METHOD_1 ( VAR_2 ) ) ; <START> VAR_3 = this . METHOD_2 ( ) ; <END> } 
public static TYPE_1 METHOD_1 ( ) throws TYPE_2 { try { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) , new TYPE_3 ( VAR_2 . METHOD_4 ( ) , VAR_2 . METHOD_5 ( ) , VAR_2 . METHOD_6 ( ) , VAR_2 . METHOD_7 ( ) , VAR_2 . METHOD_8 ( ) , VAR_2 . METHOD_9 ( ) ) ) ; <START> return VAR_1 ; <END> } catch ( TYPE_4 ex ) { throw new TYPE_2 ( ) ; } } 
public TYPE_4 ( ) { VAR_2 = new org . VAR_3 . VAR_4 . view . TYPE_3 ( ) ; METHOD_1 ( ) ; VAR_6 = VAR_2 . METHOD_2 ( ) ; ( ( TYPE_1 ) VAR_6 . METHOD_3 ( ) ) . METHOD_4 ( STRING_1 ) ; TYPE_2 . METHOD_5 ( ) ; <START> VAR_2 . METHOD_6 ( <END> STRING_2 , TYPE_2 . METHOD_7 ( ) , STRING_3 , TYPE_2 . METHOD_8 ( ) ) ; METHOD_9 ( ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { <START> return VAR_2 . containsKey ( VAR_1 ) ? VAR_2 . get ( VAR_1 ) : null ; <END> } 
public synchronized TYPE_1 METHOD_1 ( String VAR_1 , String description , TYPE_1 . TYPE_6 VAR_2 ) throws TYPE_3 , TYPE_4 { TYPE_7 . TYPE_8 VAR_3 = TYPE_7 . TYPE_8 . VAR_4 ; if ( METHOD_2 ( ) . contains ( VAR_1 ) ) { VAR_3 = TYPE_7 . TYPE_8 . VAR_5 ; } <START> return METHOD_1 ( VAR_1 , description , VAR_2 , VAR_3 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> System . VAR_1 ( STRING_1 , STRING_2 ) ; <END> System . VAR_1 ( STRING_3 , STRING_4 ) ; System . VAR_1 ( STRING_5 , STRING_6 ) ; System . VAR_1 ( STRING_7 , STRING_8 ) ; System . VAR_1 ( STRING_9 , STRING_10 ) ; this . VAR_2 = new TYPE_1 ( ) ; } 
public int METHOD_1 ( String VAR_1 , Object key , byte [ ] VAR_2 , Object value , byte [ ] VAR_3 , TYPE_1 cluster ) { <START> if ( ( ( String ) key ) . length ( ) % 2 == 0 ) return 0 ; <END> return 1 ; } 
public void METHOD_1 ( ) throws IOException { final String VAR_1 = STRING_1 ; final TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( new TYPE_2 ( ) ) ; VAR_2 . METHOD_3 ( TYPE_4 . VAR_4 ) ; final String VAR_5 = VAR_2 . METHOD_4 ( VAR_1 , TYPE_3 . class ) <START> . toString ( ) ; <END> assertThat ( VAR_5 , METHOD_5 ( STRING_2 ) ) ; } 
public TYPE_1 < Response > apply ( TYPE_2 request , TYPE_3 < TYPE_2 , Response > VAR_1 ) { System . out . println ( STRING_1 + request . host ( ) . METHOD_1 ( ( ) - > "" ) ) ; <START> System . out . println ( STRING_2 ) ; <END> request . VAR_2 ( ) . forEach ( entry - > System . out . println ( STRING_3 + entry . getKey ( ) + STRING_4 + entry . getValue ( ) ) ) ; return VAR_1 . apply ( request ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { VAR_1 . METHOD_2 ( ) . and ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_4 . VAR_3 , STRING_1 ) . METHOD_5 ( STRING_2 ) . and ( ) . METHOD_6 ( ) . METHOD_7 ( STRING_3 ) . METHOD_8 ( VAR_4 ) <START> . METHOD_9 ( ( new TYPE_2 ( TYPE_3 . VAR_6 ) ) ) <END> . METHOD_10 ( ) . and ( ) . METHOD_11 ( ) . METHOD_12 ( ) . METHOD_13 ( ) . METHOD_12 ( ) ; } 
protected TYPE_1 METHOD_1 ( ) throws Exception { <START> try ( TYPE_5 . TYPE_6 . TYPE_3 VAR_1 = getClass ( ) <END> . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ) { return new TYPE_4 ( ) . build ( VAR_1 ) ; } } 
<START> @Override protected TYPE_4 . TYPE_5 . TYPE_2 METHOD_1 ( ) { <END> TYPE_3 VAR_1 = new TYPE_3 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; VAR_1 . METHOD_4 ( "" ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { try { TYPE_3 . TYPE_4 response = VAR_1 . get ( ) . uri ( STRING_1 , 1 ) . METHOD_2 ( ) ; response . VAR_2 ( ) . METHOD_3 ( ) . METHOD_4 ( String . VAR_3 ) . METHOD_5 ( STRING_2 ) ; <START> } catch ( TYPE_2 e ) { <END> Assert . VAR_4 ( ) ; } } 
public void METHOD_1 ( ) { exception . VAR_1 ( TYPE_1 . class ) ; VAR_2 . get ( ) . uri ( STRING_1 , 3 ) . METHOD_2 ( ) ; <START> Assert . VAR_3 ( ) ; <END> } 
protected TYPE_1 < ? > METHOD_1 ( Map < String , String > map , int key ) { return ( ( ) - > { try { VAR_1 . METHOD_2 ( ) ; map . put ( STRING_1 + key , STRING_2 + key ) ; } catch ( Exception e ) { <START> this . METHOD_1 ( map , key ) ; <END> } finally { try { VAR_1 . METHOD_3 ( ) ; } catch ( Exception e ) { } } return null ; } ) ; } 
public TYPE_1 METHOD_1 ( String source ) { <START> String data [ ] = source . split ( STRING_1 ) ; <END> return new TYPE_1 ( data [ 0 ] , data [ 1 ] ) ; } 
public void METHOD_1 ( ) { String url = VAR_1 + VAR_2 + STRING_1 ; String result = TYPE_1 . METHOD_2 ( url ) ; TYPE_2 VAR_3 = TYPE_3 . create ( ) . METHOD_3 ( result , TYPE_2 . class ) ; assertEquals ( VAR_3 . getId ( ) , 1 ) ; assertEquals ( VAR_3 . METHOD_4 ( ) , STRING_2 ) ; <START> assertEquals ( VAR_3 . METHOD_5 ( ) , STRING_3 ) ; <END> } 
public void VAR_1 ( ) { VAR_2 VAR_3 = 4 ; VAR_2 VAR_4 = STRING_1 ; VAR_2 result = switch ( VAR_4 ) { case STRING_2 - > { VAR_5 VAR_3 * 2 ; } case STRING_1 - > { VAR_5 VAR_3 * VAR_3 ; } default - > VAR_3 ; } ; <START> assertEquals ( result , INT_1 ) ; <END> } 
<START> @Override protected TYPE_1 METHOD_1 ( ) { <END> return new TYPE_2 ( ) . build ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 ; if ( VAR_2 != null ) { do { <START> System . out . METHOD_2 ( VAR_1 . value + STRING_1 ) ; <END> VAR_1 = VAR_1 . VAR_3 ; } while ( VAR_1 != VAR_2 ) ; } } 
public void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 ) { <START> Iterator it = VAR_1 . METHOD_2 ( ) . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry VAR_3 = ( Map . Entry ) it . next ( ) ; ( ( TYPE_2 ) VAR_3 . getValue ( ) ) . METHOD_3 ( false ) ; } <END> } } 
public String METHOD_1 ( TYPE_1 request ) { <START> TYPE_5 . TYPE_6 . Map < String , ? > VAR_1 = TYPE_3 . METHOD_2 ( request ) ; <END> if ( VAR_1 != null ) { TYPE_4 VAR_2 = ( TYPE_4 ) VAR_1 . get ( STRING_1 ) ; return STRING_2 ; } else { return STRING_3 ; } } 
public void METHOD_1 ( ) { <START> assertTrue ( this : : METHOD_2 ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> final TYPE_4 . TYPE_5 VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) ; <END> VAR_3 . METHOD_3 ( ) . METHOD_4 ( ( VAR_4 , ex ) - > log . info ( STRING_1 ) ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( new Date ( ) . METHOD_2 ( ) - VAR_1 . METHOD_3 ( ) . METHOD_2 ( ) > VAR_2 ) { return true ; } else { return false ; } <END> } 
public void METHOD_1 ( ) throws IOException { reader . VAR_1 ( VAR_2 , VAR_3 ) ; assertNotNull ( VAR_3 ) ; METHOD_2 ( VAR_3 . isEmpty ( ) ) ; for ( final Map . Entry < Object , Object > e : VAR_3 . entrySet ( ) ) { <START> assertNotNull ( e . getKey ( ) ) ; <END> } } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) throws IOException { File file = new File ( VAR_1 ) ; <START> TYPE_2 VAR_3 = new TYPE_2 ( file ) ; <END> VAR_2 . METHOD_2 ( VAR_3 ) ; VAR_3 . close ( ) ; } 
private List < TYPE_1 > METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_2 { <START> TYPE_3 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 , VAR_2 ) ; <END> return VAR_3 . METHOD_1 ( ) ; } 
private List < TYPE_1 > METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 ) { List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_4 : VAR_1 ) { String VAR_5 = VAR_4 . METHOD_2 ( ) ; for ( TYPE_1 VAR_6 : VAR_2 ) { <START> String VAR_7 = VAR_6 . METHOD_2 ( ) ; <END> if ( VAR_5 . equals ( VAR_7 ) ) { VAR_3 . add ( VAR_4 ) ; } } } return VAR_3 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { if ( ! VAR_1 . METHOD_2 ( ) ) throw new TYPE_3 ( STRING_1 ) ; TYPE_4 VAR_2 = new TYPE_5 ( ) . METHOD_3 ( ) ; <START> return VAR_2 . METHOD_4 ( VAR_1 , new TYPE_6 ( ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 { try { VAR_1 . METHOD_2 ( VAR_2 ) ; <START> LOGGER . info ( STRING_1 + VAR_2 ) ; <END> } catch ( Exception e ) { TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_1 . METHOD_3 ( VAR_2 , VAR_3 ) ; LOGGER . info ( STRING_2 + VAR_2 ) ; } } 
public TYPE_6 ( final TYPE_1 VAR_2 , final TYPE_2 uri , final int VAR_3 , final TYPE_3 VAR_4 , final TYPE_4 VAR_5 , final TYPE_5 VAR_6 ) { <START> this ( VAR_2 , uri , VAR_3 , VAR_3 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) , INT_1 ) ; VAR_1 . METHOD_4 ( STRING_1 ) ; VAR_1 . METHOD_5 ( STRING_2 ) ; long VAR_3 = client . VAR_4 ( ) ; long VAR_5 = VAR_1 . METHOD_6 ( ) ; <START> Assert . assertTrue ( VAR_3 < VAR_5 ) ; <END> VAR_1 . close ( ) ; } 
public TYPE_1 ( Map < String , Object > map ) { if ( map != null && map . size ( ) > 0 ) { VAR_2 = map ; name = ( String ) map . get ( VAR_3 ) ; VAR_4 = ( long ) map . get ( VAR_5 ) ; VAR_6 = ( long ) map . get ( VAR_7 ) ; <START> } else throw new IllegalArgumentException ( ) ; <END> } 
public TYPE_2 ( String VAR_2 , Set < String > VAR_3 , final TYPE_1 VAR_4 , final int VAR_5 , final int VAR_6 , final String VAR_7 , final int VAR_8 , final Boolean VAR_9 ) { <START> this ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , null , VAR_9 ) ; <END> } 
public TYPE_2 ( final TYPE_1 VAR_2 , int VAR_3 ) { <START> this ( VAR_2 , VAR_3 , VAR_3 , null , null , false , null , null , null , null ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( STRING_1 ) ; <START> TYPE_1 VAR_1 = new TYPE_1 ( STRING_2 ) ; <END> VAR_1 . METHOD_3 ( ) ; } 
<START> int count ( ) { <END> if ( params . containsKey ( VAR_1 ) ) { return params . get ( VAR_1 ) . getInt ( ) ; } else { return TYPE_1 . getInt ( ) ; } } 
public static boolean METHOD_1 ( String VAR_1 ) { String VAR_2 = METHOD_2 ( VAR_1 , true , true ) ; if ( VAR_2 != null && ! VAR_2 . isEmpty ( ) && VAR_1 . startsWith ( VAR_2 ) ) { <START> return VAR_1 . substring ( VAR_2 . length ( ) ) . equals ( STRING_1 ) ; <END> } else { return false ; } } 
int count ( ) { if ( params . containsKey ( VAR_1 ) ) { return params . get ( VAR_1 ) . getInt ( ) ; } else { <START> return 0 ; <END> } } 
public void METHOD_1 ( final byte [ ] key , final double max , final double VAR_1 ) { <START> METHOD_2 ( VAR_2 , key , METHOD_3 ( VAR_1 ) , METHOD_3 ( max ) , VAR_3 . VAR_4 ) ; <END> } 
public void METHOD_1 ( final byte [ ] key , final double max , final double VAR_1 , final int offset , int count ) { <START> METHOD_2 ( VAR_2 , key , METHOD_3 ( VAR_1 ) , METHOD_3 ( max ) , VAR_3 . VAR_4 , METHOD_3 ( offset ) , <END> METHOD_3 ( count ) ) ; } 
public void METHOD_1 ( final byte [ ] key , final double max , final double VAR_1 ) { <START> METHOD_2 ( VAR_2 , key , METHOD_3 ( VAR_1 ) , METHOD_3 ( max ) ) ; <END> } 
<START> public Long METHOD_1 ( final String key ) { <END> return new TYPE_1 < Long > ( VAR_1 , VAR_2 , VAR_3 ) { @Override public Long execute ( TYPE_2 connection ) { return connection . VAR_4 ( key ) ; } } . run ( key ) ; } 
public static void METHOD_1 ( ) throws InterruptedException { <START> String [ ] VAR_1 = VAR_2 . METHOD_2 ( ) . split ( STRING_1 ) ; <END> String VAR_3 = VAR_1 [ 0 ] . split ( STRING_2 ) [ 0 ] ; VAR_2 . METHOD_3 ( TYPE_1 . VAR_5 ) ; VAR_6 . METHOD_3 ( TYPE_1 . VAR_5 ) ; } 
public String set ( final byte [ ] key , final byte [ ] value ) { <START> return new TYPE_1 < String > ( VAR_1 , VAR_2 , VAR_3 ) { <END> @Override public String execute ( TYPE_2 connection ) { return connection . set ( key , value ) ; } } . METHOD_1 ( key ) ; } 
public byte [ ] METHOD_1 ( final byte [ ] VAR_1 ) { return new TYPE_1 < byte [ ] > ( VAR_2 , VAR_3 , VAR_4 ) { @Override public byte [ ] execute ( TYPE_2 connection ) { return connection . VAR_5 ( VAR_1 ) ; } <START> } . METHOD_2 ( null ) ; <END> } 
public List < byte [ ] > METHOD_1 ( final byte [ ] VAR_1 ) { return new TYPE_1 < List < byte [ ] > > ( VAR_2 , VAR_3 , VAR_4 ) { @Override public List < byte [ ] > execute ( TYPE_2 connection ) { return connection . VAR_5 ( VAR_1 ) ; } <START> } . METHOD_2 ( null ) ; <END> } 
<START> public Long METHOD_1 ( final byte [ ] key , final int VAR_1 ) { <END> return new TYPE_1 < Long > ( VAR_2 , VAR_3 , VAR_4 ) { @Override public Long execute ( TYPE_2 connection ) { return connection . VAR_5 ( key , VAR_1 ) ; } } . METHOD_2 ( key ) ; } 
public Object METHOD_1 ( final String VAR_1 , final String key ) { return new TYPE_1 < Object > ( VAR_2 , VAR_3 , VAR_4 ) { @Override public Object execute ( TYPE_2 connection ) { return connection . VAR_5 ( VAR_1 ) ; } <START> } . run ( 1 , key ) ; <END> } 
public List < Boolean > METHOD_1 ( final String key , final String ... VAR_1 ) { return new TYPE_1 < List < Boolean > > ( VAR_2 , VAR_3 , VAR_4 ) { @Override public List < Boolean > execute ( TYPE_2 connection ) { return connection . VAR_5 ( VAR_1 ) ; } <START> } . run ( 1 , key ) ; <END> } 
public String METHOD_1 ( final String VAR_1 , final String key ) { return new TYPE_1 < String > ( VAR_2 , VAR_3 , VAR_4 ) { @Override public String execute ( TYPE_2 connection ) { return connection . VAR_5 ( VAR_1 ) ; } <START> } . run ( 1 , key ) ; <END> } 
public TYPE_2 ( byte [ ] VAR_2 , List < T > results ) { <START> this . VAR_2 = TYPE_1 . METHOD_1 ( VAR_2 ) ; <END> this . results = results ; } 
private void METHOD_1 ( Set < TYPE_1 > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { TYPE_2 VAR_3 = new TYPE_2 ( VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) ) ; this . VAR_1 . put ( VAR_2 . METHOD_2 ( ) + VAR_2 . METHOD_3 ( ) , VAR_3 ) ; <START> TYPE_3 VAR_4 = VAR_3 . METHOD_4 ( ) ; <END> METHOD_5 ( VAR_4 ) ; VAR_3 . METHOD_6 ( VAR_4 ) ; } } 
private File METHOD_1 ( File key , String user ) throws IOException { File VAR_1 = METHOD_2 ( STRING_1 , STRING_2 ) ; File VAR_2 = METHOD_3 ( ) ; <START> <END> try ( TYPE_1 VAR_3 = new TYPE_1 ( VAR_1 , this . VAR_4 ) ) { VAR_3 . println ( STRING_3 ) ; VAR_3 . println ( STRING_4 + VAR_2 . METHOD_4 ( ) + STRING_5 + key . VAR_5 ( ) + STRING_6 + user + STRING_7 ) ; } VAR_1 . METHOD_5 ( true , true ) ; return VAR_1 ; } 
public String toString ( ) { final String VAR_1 = VAR_2 != null ? VAR_2 . name ( ) : STRING_1 ; StringBuilder s = new StringBuilder ( STRING_2 + VAR_1 + STRING_3 ) ; if ( VAR_3 != null ) { TYPE_1 . METHOD_1 ( STRING_4 ) . METHOD_2 ( s , <START> TYPE_2 . METHOD_3 ( VAR_3 , ( TYPE_3 from ) - > TYPE_4 . METHOD_4 ( from . getName ( ) ) ) ) ; <END> } s . append ( CHAR_1 ) ; return s . toString ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 , InterruptedException { METHOD_2 ( true ) ; String cmd = STRING_1 ; METHOD_3 ( STRING_2 , cmd ) ; <START> } <END> 
public < T > T METHOD_1 ( TYPE_1 < T > VAR_1 ) throws IOException , InterruptedException { TYPE_2 repo = METHOD_2 ( ) ; <START> try { <END> return VAR_1 . METHOD_3 ( repo , TYPE_3 . TYPE_4 . VAR_4 ) ; } finally { repo . close ( ) ; } } 
public List < TYPE_1 > METHOD_1 ( ) throws TYPE_2 { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; TYPE_3 VAR_2 = METHOD_2 ( ) ; VAR_2 . METHOD_3 ( ) ; VAR_2 . to ( VAR_1 ) ; try { VAR_2 . execute ( ) ; } catch ( InterruptedException e ) { throw new TYPE_2 ( e ) ; <START> } catch ( IOException e ) { <END> throw new TYPE_2 ( e ) ; } return VAR_1 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , Collection < TYPE_2 > VAR_3 ) { <START> if ( VAR_2 == null ) throw new TYPE_3 ( STRING_1 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) throws TYPE_2 , InterruptedException { <START> METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } 
protected TYPE_1 METHOD_1 ( ) throws Exception { return TYPE_1 . builder ( ) <START> . METHOD_2 ( TYPE_2 . builder ( ) <END> . METHOD_3 ( STRING_1 ) . build ( ) ) . METHOD_2 ( TYPE_2 . builder ( ) . METHOD_3 ( STRING_2 ) . build ( ) ) . build ( ) ; } 
protected String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 metadata ) { try { <START> TYPE_3 . METHOD_2 ( VAR_1 ) ; <END> TYPE_4 VAR_2 = VAR_3 . METHOD_1 ( null , metadata ) ; if ( logger . VAR_4 ( ) ) { logger . trace ( STRING_1 + metadata . get ( TYPE_2 . VAR_5 ) + STRING_2 + VAR_2 ) ; } return VAR_2 . toString ( ) ; } catch ( Exception e ) { logger . debug ( e , STRING_3 ) ; return null ; } } 
private void METHOD_1 ( List < String > VAR_1 , TYPE_1 VAR_2 ) { <START> final TYPE_2 VAR_3 = VAR_4 . METHOD_2 ( ) ; <END> for ( String key : VAR_1 ) { if ( key == null ) break ; if ( ! key . equals ( VAR_3 . toString ( ) ) ) { TYPE_3 entry = VAR_5 . get ( key ) ; if ( entry != null ) { METHOD_3 ( entry , VAR_2 ) ; } } } } 
public boolean METHOD_1 ( List < String > VAR_1 ) { TYPE_1 . METHOD_2 ( ) ; if ( VAR_1 . isEmpty ( ) ) { return false ; <START> } <END> return METHOD_3 ( connection - > VAR_2 . METHOD_1 ( connection , VAR_1 ) , true ) ; } 
protected Object METHOD_1 ( Object value ) { switch ( type ) { case VAR_1 : case VAR_2 : case VAR_3 : case VAR_4 : case VAR_5 : case VAR_6 : case VAR_7 : return VAR_8 . METHOD_2 ( ) . create ( value ) ; case VAR_9 : <START> return ( ( TYPE_1 ) value ) . METHOD_3 ( ) ; <END> } return value ; } 
public void METHOD_1 ( ) throws Exception { try { METHOD_2 ( ) ; <START> } catch ( Exception e ) { <END> } finally { TYPE_1 . METHOD_3 ( STRING_1 ) ; } } 
private boolean METHOD_1 ( TYPE_1 cache ) { TYPE_2 VAR_1 = METHOD_2 ( cache ) . METHOD_3 ( ) ; if ( VAR_1 == null ) { return true ; } TYPE_3 VAR_2 = VAR_1 . METHOD_4 ( ) ; if ( VAR_2 == null ) { return true ; } TYPE_4 VAR_3 = METHOD_5 ( cache ) ; if ( VAR_2 . METHOD_6 ( VAR_3 ) ) { return false ; } Set < TYPE_4 > VAR_4 = METHOD_7 ( cache ) ; <START> return VAR_2 . METHOD_8 ( VAR_3 , VAR_4 ) ; <END> } 
public boolean hasNext ( ) { if ( VAR_1 != null ) return true ; while ( super . hasNext ( ) ) { VAR_1 = super . next ( ) ; if ( VAR_1 . getName ( ) . equals ( name ) ) { return true ; } else { VAR_1 = null ; <START> } <END> } return false ; } 
<START> protected synchronized void METHOD_1 ( ) { <END> if ( VAR_1 != null ) { METHOD_2 ( VAR_1 ) ; VAR_1 = null ; } } 
public void METHOD_1 ( TYPE_1 listener , int VAR_1 , String VAR_2 , boolean VAR_3 , String [ ] VAR_4 , String [ ] VAR_5 , boolean VAR_6 ) throws TYPE_2 { TYPE_3 . METHOD_2 ( listener , STRING_1 ) ; METHOD_3 ( ) ; TYPE_4 VAR_7 = new TYPE_4 ( listener , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; this . VAR_8 . METHOD_4 ( VAR_7 ) ; <START> this . VAR_9 . add ( VAR_7 ) ; <END> } 
final void METHOD_1 ( ) throws TYPE_1 { VAR_1 . METHOD_1 ( session ) ; for ( String token : new ArrayList < String > ( VAR_2 . keySet ( ) ) ) { METHOD_2 ( token ) ; <START> } <END> } 
public Iterator < TYPE_1 > iterator ( TYPE_2 name , Context context ) { if ( context != null && context . VAR_1 ( ) != null ) { return super . iterator ( name , context ) ; } else { return iterator ( name ) ; <START> } <END> } 
public void close ( ) { if ( this . VAR_1 . METHOD_1 ( true , false ) ) { try { <START> VAR_2 . METHOD_2 ( ) ; <END> this . VAR_3 . METHOD_3 ( ) ; } catch ( InterruptedException e ) { } } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . METHOD_2 ( ) ; <END> try { if ( VAR_3 != null ) { VAR_3 . METHOD_3 ( TYPE_3 . VAR_5 ) ; } if ( ! this . VAR_6 . containsKey ( VAR_1 . METHOD_4 ( ) ) ) { VAR_6 . put ( VAR_1 . METHOD_4 ( ) , new TYPE_2 ( VAR_7 . size ( ) ) ) ; } } finally { VAR_2 . METHOD_5 ( ) ; } } 
public void METHOD_1 ( ) { if ( VAR_1 ) { VAR_2 . METHOD_2 ( true ) ; <START> } <END> } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 record = ( TYPE_1 ) o ; if ( VAR_1 != record . VAR_1 ) { return false ; } <START> if ( content != null ? ! content . VAR_2 ( ) . equals ( record . content . METHOD_1 ( ) ) : record . content != null ) { <END> return false ; } return true ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 cache ) { TYPE_3 VAR_1 = METHOD_2 ( cache ) ; <START> if ( VAR_1 == null ) { <END> VAR_1 = METHOD_2 ( cache ) ; } return VAR_1 . METHOD_1 ( ) ; } 
private TYPE_1 ( String name ) { <START> this . name = name ; <END> } 
public int METHOD_1 ( ) { int VAR_1 = 5 ; VAR_1 = INT_1 * VAR_1 + ( this . path != null ? this . path . VAR_2 ( ) : 0 ) ; <START> return VAR_1 ; <END> } 
<START> public final void METHOD_1 ( String key , <END> String value ) { this . context = context . VAR_1 ( key , value ) ; this . cache . VAR_2 ( key , value ) ; } 
<START> public final TYPE_1 context ( ) { <END> return context ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 , <END> String VAR_2 ) throws TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 , TYPE_8 { METHOD_2 ( ) ; return METHOD_3 ( VAR_1 , VAR_2 , null , true ) ; } 
<START> public TYPE_4 ( TYPE_1 session ) { <END> this . session = session ; this . VAR_2 = new TYPE_2 ( session ) ; this . VAR_3 = TYPE_3 . METHOD_1 ( this ) ; } 
protected TYPE_2 ( String VAR_2 ) { this . VAR_2 = VAR_2 ; <START> VAR_3 . add ( TYPE_1 . METHOD_1 ( VAR_2 ) ) ; <END> } 
public TYPE_1 [ ] METHOD_1 ( String path ) throws TYPE_2 , TYPE_3 , TYPE_4 { if ( session . VAR_1 ( ) ) { throw new TYPE_3 ( STRING_1 ) ; <START> } <END> TYPE_1 [ ] VAR_2 = METHOD_2 ( path ) ; if ( VAR_2 . length == 0 ) { return new TYPE_1 [ ] { ( TYPE_1 ) this . METHOD_3 ( path ) . next ( ) } ; } return VAR_2 ; } 
public final boolean METHOD_1 ( ) { <START> return this . VAR_1 ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { synchronized ( VAR_2 ) { VAR_2 . add ( VAR_1 ) ; <START> } <END> } 
public boolean equals ( Object VAR_1 ) { if ( VAR_1 == null ) { return false ; } if ( VAR_1 == this ) { return true ; } if ( ! ( VAR_1 instanceof TYPE_1 ) ) { return false ; } <START> return this == ( TYPE_1 ) VAR_1 ; <END> } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) throws TYPE_4 { <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; try { this . VAR_5 = VAR_2 . METHOD_1 ( ) ; } catch ( Exception e ) { throw new TYPE_4 ( e ) ; } } 
private boolean METHOD_1 ( String uri ) { <START> return ! ( uri . startsWith ( STRING_1 ) | uri . startsWith ( STRING_2 ) ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } } 
<START> protected TYPE_1 METHOD_1 ( ) throws TYPE_2 { <END> if ( this . VAR_1 == null ) { this . VAR_1 = METHOD_2 ( VAR_2 ) ; } return this . VAR_1 ; } 
<START> public void start ( ) throws Exception { <END> METHOD_1 ( ) ; } 
<START> public Set < String > METHOD_1 ( ) { <END> METHOD_2 ( ) ; final TYPE_1 VAR_1 = this . VAR_1 . METHOD_3 ( ) ; try { VAR_1 . METHOD_4 ( ) ; return new HashSet < String > ( VAR_2 . keySet ( ) ) ; } finally { VAR_1 . METHOD_5 ( ) ; } } 
public TYPE_3 ( TYPE_1 source , <START> TYPE_2 VAR_2 ) { <END> super ( source ) ; this . VAR_2 = source . VAR_3 ( ) ; assert this . VAR_2 != null ; Set < String > VAR_4 = new HashSet < String > ( ) ; for ( String VAR_5 : source . VAR_6 ( ) ) { VAR_4 . add ( VAR_5 ) ; } this . VAR_7 = Collections . VAR_8 ( VAR_4 ) ; METHOD_1 ( ) ; } 
public TYPE_2 ( boolean VAR_2 ) { this . VAR_2 = VAR_2 ; <START> TYPE_1 . getInstance ( ) . METHOD_1 ( this ) ; <END> } 
private boolean METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> LOGGER . debug ( STRING_1 + VAR_1 + STRING_2 + VAR_3 . METHOD_2 ( TYPE_2 . VAR_4 ) ) ; <END> return METHOD_3 ( VAR_1 , VAR_2 , VAR_3 . METHOD_2 ( TYPE_2 . VAR_4 ) ) ; } 
static Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] { new Object [ ] { STRING_1 , STRING_2 , STRING_3 } , <START> new Object [ ] { STRING_1 , STRING_2 , STRING_3 } , <END> new Object [ ] { STRING_4 , STRING_5 , STRING_6 } } ; } 
public String METHOD_1 ( TYPE_1 user ) { <START> if ( ! Boolean . VAR_1 . equals ( user . VAR_2 ( ) ) ) { <END> throw new TYPE_2 ( ) ; } METHOD_2 ( user ) ; return METHOD_3 ( user ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( ) . build ( ) . METHOD_3 ( ) ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( VAR_3 != null && VAR_3 . METHOD_3 ( ) ) { VAR_3 . METHOD_4 ( VAR_2 ) ; VAR_2 ++ ; } TYPE_2 VAR_4 = VAR_1 . METHOD_5 ( ) ; if ( VAR_4 != null && VAR_3 != null && ! VAR_3 . getName ( ) . equals ( VAR_4 . getName ( ) ) ) { VAR_4 . METHOD_4 ( VAR_2 ) ; <START> VAR_2 ++ ; <END> } } 
<START> protected void METHOD_1 ( <END> TYPE_1 < TYPE_2 > repo , TYPE_3 VAR_1 ) { if ( repo == null ) return ; int VAR_2 = 1 ; for ( TYPE_2 VAR_3 : METHOD_2 ( repo ) ) { VAR_2 ++ ; METHOD_3 ( VAR_1 , VAR_2 , VAR_3 ) ; } } 
public static TYPE_1 create ( ANNOTATION_1 TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { return new TYPE_4 ( VAR_1 , VAR_2 , METHOD_1 ( ) , <START> METHOD_2 ( ) , <END> METHOD_2 ( ) , METHOD_2 ( ) , METHOD_2 ( ) , METHOD_2 ( ) ) ; } 
public static TYPE_1 create ( ANNOTATION_1 TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { return new TYPE_4 ( VAR_1 , VAR_2 , <START> new ArrayList < > ( ) , <END> new HashMap < > ( ) , new HashMap < > ( ) , new HashMap < > ( ) , new HashMap < > ( ) , new HashMap < > ( ) ) ; } 
private List < String > METHOD_1 ( ) { List < String > VAR_1 = new ArrayList < > ( ) ; <START> return VAR_1 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; when ( VAR_2 . METHOD_3 ( STRING_1 ) ) . METHOD_4 ( VAR_1 ) ; <START> assertEquals ( true , VAR_3 . METHOD_5 ( STRING_1 ) ) ; <END> } 
private static String METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_1 ( ) != null ? StringUtils . VAR_2 ( VAR_1 . METHOD_1 ( ) , STRING_1 ) : "" ; <END> } 
public void METHOD_1 ( Exception ex ) { TYPE_1 . error ( STRING_1 + ex . getMessage ( ) , ex ) ; VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; <START> VAR_1 . METHOD_5 ( ex . VAR_3 ( ) ) ; <END> METHOD_6 ( VAR_1 . METHOD_7 ( ) , VAR_1 . getType ( ) + STRING_2 , VAR_1 . METHOD_8 ( ) ) ; update ( ) ; TYPE_3 . METHOD_9 ( ) ; } 
public static Path METHOD_1 ( ) { if ( VAR_1 == null ) { <START> throw new RuntimeException ( STRING_1 ) ; <END> } return VAR_1 ; } 
public String METHOD_1 ( TYPE_1 model ) { model . VAR_1 ( STRING_1 , this . VAR_2 . METHOD_2 ( ) ) ; <START> if ( ! model . VAR_3 ( VAR_4 ) ) model . VAR_1 ( VAR_4 , STRING_1 ) ; <END> return STRING_2 ; } 
protected Object METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 . getName ( ) . equals ( TYPE_3 . METHOD_2 ( ) ) ) { return METHOD_3 ( VAR_2 ) ; } String VAR_3 = TYPE_4 . METHOD_4 ( VAR_1 . getName ( ) ) ; if ( VAR_3 == null ) <START> throw new IllegalArgumentException ( String . format ( STRING_1 , VAR_1 . getName ( ) ) ) ; <END> return VAR_2 . get ( VAR_3 ) ; } 
public void create ( ANNOTATION_1 ( STRING_1 ) String VAR_1 , ANNOTATION_2 Map < String , Object > VAR_2 , TYPE_1 response ) { if ( VAR_2 == null ) { <START> throw new TYPE_2 ( STRING_2 , STRING_3 ) ; <END> } METHOD_1 ( VAR_1 , VAR_2 , response ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) { try { return METHOD_2 ( VAR_2 ) ; } <START> catch ( TYPE_3 . time . format . TYPE_4 e ) <END> { throw new TYPE_5 ( VAR_1 , VAR_2 ) ; } } 
private boolean METHOD_1 ( String VAR_1 , TYPE_1 entity ) { if ( VAR_1 == null ) { return true ; } else { Object value ; try { value = VAR_2 . METHOD_2 ( VAR_1 , entity ) ; } catch ( TYPE_2 VAR_3 ) { <START> return false ; <END> } return value != null ? Boolean . valueOf ( value . toString ( ) ) : false ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 e ) { <START> LOG . warn ( e . getMessage ( ) , e ) ; <END> return new TYPE_3 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( TYPE_1 . class , VAR_1 ) ; <END> } 
<START> private void METHOD_1 ( Map < String , Object > VAR_1 ) <END> { } 
private boolean METHOD_1 ( String VAR_1 , TYPE_1 < String > VAR_2 ) { <START> if ( VAR_1 == null || TYPE_2 . contains ( VAR_2 , VAR_1 ) ) <END> { return true ; } return false ; } 
public TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; this . VAR_4 = METHOD_1 ( VAR_4 ) ; <START> this . VAR_5 = VAR_5 ; <END> this . VAR_6 = VAR_6 ; } 
<START> public void METHOD_1 ( ) <END> { super . METHOD_1 ( ) ; METHOD_2 ( VAR_1 ) ; } 
public double METHOD_1 ( String row , String column ) { if ( ! VAR_1 ) METHOD_2 ( ) ; Integer VAR_2 = VAR_3 . get ( row ) ; Integer VAR_4 = VAR_5 . get ( column ) ; if ( VAR_2 == null ) throw new TYPE_1 ( STRING_1 + row + STRING_2 ) ; <START> if ( VAR_2 == null ) throw new TYPE_1 ( STRING_3 + column + STRING_2 ) ; <END> return METHOD_3 ( VAR_2 , VAR_4 ) ; } 
private TYPE_1 METHOD_1 ( String VAR_1 ) { <START> TYPE_1 VAR_2 = null ; <END> TYPE_2 entity = VAR_3 . METHOD_2 ( TYPE_4 . VAR_5 + STRING_1 + TYPE_4 . VAR_6 , VAR_1 ) ; if ( entity != null ) { return METHOD_3 ( VAR_1 , entity ) ; } else { throw new TYPE_3 ( STRING_2 + VAR_1 + STRING_3 ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> VAR_1 = true ; <END> return this ; } 
public void METHOD_1 ( ) { <START> Log . d ( STRING_1 , STRING_2 ) ; <END> new TYPE_1 ( TYPE_2 . METHOD_2 ( ) ) . METHOD_3 ( new TYPE_3 ( ) { @Override public void run ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_4 ( ) ; } } } ) ; } 
public TYPE_1 METHOD_1 ( File VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( this . VAR_1 != null && this . VAR_1 . METHOD_2 ( ) != null ) <END> { this . METHOD_3 ( this . VAR_1 . METHOD_2 ( ) ) ; } return this ; } 
private void METHOD_1 ( TYPE_1 properties ) { if ( properties != null ) { for ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { Object v = entry . getValue ( ) ; if ( v instanceof String ) { String value = ( String ) v ; String VAR_1 = METHOD_2 ( value ) ; <START> if ( value != VAR_1 && TYPE_2 . METHOD_3 ( VAR_1 ) ) <END> { entry . VAR_2 ( VAR_1 ) ; } } } } } 
protected TYPE_1 METHOD_1 ( ) throws Exception { TYPE_2 VAR_1 = METHOD_2 ( TYPE_2 . class , STRING_1 ) ; <START> TYPE_1 r = VAR_2 . METHOD_3 ( STRING_2 , STRING_3 + METHOD_4 ( ) . METHOD_5 ( ) , VAR_1 , null , null ) ; <END> return r ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } <START> if ( ( obj == null ) || ! ( obj instanceof TYPE_1 ) ) <END> { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return METHOD_1 ( ) . equals ( VAR_1 . METHOD_1 ( ) ) ; } 
public TYPE_1 METHOD_1 ( Exception e ) { if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( VAR_1 ) ; } VAR_1 . add ( e ) ; <START> return this ; <END> } 
<START> void METHOD_1 ( ) { <END> System . out . println ( STRING_1 ) ; METHOD_2 ( false ) ; METHOD_3 ( ) ; METHOD_2 ( true ) ; METHOD_3 ( ) ; } 
public void METHOD_1 ( String data , String VAR_1 ) throws TYPE_1 { <START> this . METHOD_1 ( data , VAR_1 , VAR_2 . VAR_3 , TYPE_2 . VAR_5 ) ; <END> } 
private String METHOD_1 ( ) { if ( this . VAR_1 == 10 ) { <START> VAR_2 = STRING_1 ; <END> TYPE_1 VAR_3 = TYPE_2 . METHOD_2 ( VAR_2 ) ; String VAR_4 = this . VAR_1 + STRING_2 + this . VAR_5 ; String VAR_6 = VAR_3 . getProperty ( VAR_4 ) ; return VAR_6 ; } LOG . warn ( STRING_3 , this . VAR_1 , this . VAR_5 ) ; return "" ; } 
private void METHOD_1 ( Collection < TYPE_1 < TYPE_2 > > results ) throws Throwable { for ( final TYPE_1 < TYPE_2 > result : results ) { try { result . get ( ) ; <START> } catch ( final TYPE_3 e ) { <END> throw e . VAR_1 ( ) ; } } } 
<START> public static Double get ( String key , double VAR_1 ) { <END> String value = configuration . getProperty ( key ) ; return value == null ? VAR_1 : TYPE_1 . METHOD_1 ( value , VAR_1 ) ; } 
<START> static String METHOD_1 ( String VAR_1 ) { <END> return VAR_2 . entrySet ( ) . stream ( ) . filter ( entry - > VAR_1 . startsWith ( entry . getKey ( ) ) ) . map ( Map . Entry : : getValue ) . collect ( Collectors . VAR_3 ( ) ) ; } 
public TYPE_2 ( ) { name = "" ; model = "" ; VAR_2 = "" ; <START> size = INT_1 ; <END> VAR_3 = INT_1 ; VAR_4 = INT_1 ; VAR_5 = INT_1 ; VAR_6 = INT_1 ; VAR_7 = INT_1 ; VAR_8 = INT_1 ; VAR_9 = new TYPE_1 [ 0 ] ; VAR_10 = INT_1 ; } 
private Boolean METHOD_1 ( List < String > VAR_1 , String VAR_2 ) { for ( String VAR_3 : VAR_1 ) { <START> if ( VAR_3 . startsWith ( VAR_3 ) ) { <END> return Boolean . VAR_4 ; } } return Boolean . VAR_5 ; } 
private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new TYPE_2 < > ( ) ; TYPE_1 VAR_2 = new TYPE_1 ( STRING_1 , STRING_2 , TYPE_3 . class ) ; VAR_1 . add ( VAR_2 ) ; VAR_2 = new TYPE_1 ( STRING_1 , STRING_3 , TYPE_4 . class ) ; VAR_1 . add ( VAR_2 ) ; return VAR_1 ; <START> } <END> 
protected TYPE_1 METHOD_1 ( ) throws Exception { if ( this . VAR_1 == null ) { throw new TYPE_2 ( STRING_1 , getName ( ) ) ; } <START> final byte [ ] data = ( this . VAR_1 . METHOD_2 ( ) == 0 ) ? new byte [ 0 ] <END> : VAR_2 . METHOD_3 ( ) . METHOD_4 ( this . path ) ; return new TYPE_3 ( data ) ; } 
<START> private static File METHOD_1 ( final File file ) { <END> try { return file . VAR_1 ( ) ; } catch ( final IOException e ) { return file . VAR_2 ( ) ; } } 
public List < Integer > METHOD_1 ( final TYPE_1 VAR_1 ) { ANNOTATION_1 ( STRING_1 ) List < Integer > VAR_2 = ( List < Integer > ) METHOD_2 ( VAR_1 , VAR_3 ) ; <START> return VAR_2 != null ? VAR_2 : Arrays . asList ( TYPE_2 . VAR_5 , TYPE_2 . VAR_6 ) ; <END> } 
public int METHOD_1 ( TYPE_1 < ? > VAR_1 ) { <START> if ( ! VAR_1 . getClass ( ) . equals ( this . getClass ( ) ) ) { <END> throw new IllegalArgumentException ( STRING_1 + VAR_1 . getClass ( ) . METHOD_2 ( ) + STRING_2 ) ; } TYPE_2 VAR_2 = ( ( TYPE_3 ) VAR_1 ) . getValue ( ) ; return value . VAR_3 ( VAR_2 ) * - 1 ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 < ? > VAR_1 ) { if ( VAR_1 == null ) return null ; <START> if ( ! VAR_1 . getClass ( ) . equals ( this . getClass ( ) ) ) { <END> throw new IllegalArgumentException ( STRING_1 + VAR_1 . getClass ( ) . METHOD_2 ( ) + STRING_2 ) ; } else { return ( TYPE_1 ) VAR_1 ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 result = new TYPE_1 ( STRING_1 ) ; result . VAR_1 ( STRING_2 , VAR_2 ) ; result . VAR_1 ( STRING_3 , VAR_3 ) ; <START> result . VAR_1 ( STRING_4 , METHOD_2 ( ) ) ; <END> result . VAR_1 ( STRING_5 , METHOD_3 ( ) ) ; return result ; } 
public TYPE_1 ( double VAR_2 , double VAR_3 , double VAR_4 , int VAR_5 ) { <START> super ( VAR_4 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_6 = METHOD_1 ( VAR_2 ) ; this . VAR_7 = METHOD_2 ( METHOD_3 ( ) , VAR_2 , this . VAR_6 ) ; this . VAR_5 = VAR_5 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 type ) { if ( type == TYPE_2 . VAR_1 ) { return METHOD_2 ( STRING_1 ) ; } <START> if ( type == TYPE_2 . VAR_2 ) { return METHOD_2 ( STRING_2 ) ; } <END> if ( type == TYPE_2 . VAR_3 ) { return METHOD_2 ( STRING_3 ) ; } if ( type == TYPE_2 . VAR_4 ) { return METHOD_2 ( STRING_4 ) ; } throw new IllegalArgumentException ( STRING_5 + type + STRING_6 ) ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_1 ( VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) . get ( 0 ) ; <START> return ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) . METHOD_1 ( ) ; <END> } 
private static void METHOD_1 ( Exception exception , Class < ? > type , String message ) { Throwable VAR_1 = exception ; while ( VAR_1 . METHOD_2 ( ) != null ) { VAR_1 = VAR_1 . METHOD_2 ( ) ; } METHOD_3 ( type , VAR_1 ) ; <START> assertEquals ( VAR_1 . getMessage ( ) , message ) ; <END> } 
public static < T > T METHOD_1 ( T ... values ) { if ( values == null ) { return null ; } for ( T value : values ) { if ( value != null ) { if ( String . VAR_1 . METHOD_2 ( value ) ) { <START> if ( TYPE_1 . METHOD_3 ( ( String ) value ) ) { <END> return value ; } } else { return value ; } } } return null ; } 
private String [ ] METHOD_1 ( int VAR_1 ) { final int index = VAR_1 - METHOD_2 ( ) ; if ( index >= VAR_2 . length ) { throw new IllegalArgumentException ( STRING_1 + VAR_2 . length <START> + STRING_2 <END> ) ; } return VAR_2 [ index ] ; } 
protected String [ ] METHOD_1 ( TYPE_1 VAR_1 , int j ) { String [ ] VAR_2 = VAR_1 . METHOD_2 ( j ) ; <START> if ( VAR_2 != null && VAR_2 . length == 1 && VAR_2 [ 0 ] == null ) { <END> return new String [ ] { VAR_1 . METHOD_3 ( ) [ j ] } ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 , int VAR_4 , int VAR_5 , int VAR_6 , int VAR_7 , TYPE_2 VAR_8 ) { if ( METHOD_2 ( ) ) { <START> VAR_7 = 0 ; <END> } return add ( VAR_8 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_1 , VAR_2 , VAR_3 ) ; } 
public TYPE_1 add ( int VAR_1 , int VAR_2 , int VAR_3 , int VAR_4 , int VAR_5 , int VAR_6 , int VAR_7 , String offset , TYPE_2 VAR_8 ) { if ( METHOD_1 ( ) ) { <START> VAR_7 = 0 ; <END> } return add ( VAR_8 , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , offset ) ; } 
public TYPE_1 METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 , int VAR_4 , int VAR_5 , int VAR_6 , int VAR_7 , String offset , TYPE_2 VAR_8 ) { if ( METHOD_2 ( ) ) { <START> VAR_7 = 0 ; <END> } return add ( VAR_8 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , offset , VAR_1 , VAR_2 , VAR_3 ) ; } 
public TYPE_1 add ( int VAR_1 , int VAR_2 , int VAR_3 , int VAR_4 , int VAR_5 , int VAR_6 , int VAR_7 , String VAR_8 , TYPE_2 VAR_9 ) { if ( METHOD_1 ( ) ) { <START> VAR_7 = 0 ; <END> } return add ( VAR_9 , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 ) ; } 
void METHOD_1 ( long VAR_1 ) { <START> log . VAR_2 ( STRING_1 , query ) ; <END> VAR_3 . METHOD_2 ( ) ; VAR_4 . METHOD_3 ( VAR_1 ) ; } 
void METHOD_1 ( ) { <START> log . VAR_1 ( STRING_1 , query ) ; <END> VAR_2 . METHOD_2 ( ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( this : : METHOD_3 , s - > { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_4 ( new TYPE_2 ( ) ) ; VAR_1 . METHOD_5 ( ) . METHOD_6 ( STRING_1 ) ; VAR_1 . METHOD_5 ( ) . METHOD_7 ( new Date ( ) ) ; VAR_1 . METHOD_8 ( STRING_2 ) ; s . VAR_2 ( VAR_1 ) ; s . VAR_3 ( ) ; <START> s . clear ( ) ; <END> } ) ; } 
<START> public String METHOD_1 ( ) { <END> TYPE_1 VAR_1 = METHOD_2 ( ) ; return ( VAR_1 != null ) ? VAR_1 . METHOD_1 ( ) : STRING_1 ; } 
public final Object METHOD_1 ( Object VAR_1 , Object target , TYPE_1 session , Object VAR_2 , Map VAR_3 ) { if ( VAR_1 == null && target == null ) { return null ; } if ( VAR_1 == TYPE_2 . VAR_5 ) { return target ; } if ( target == TYPE_2 . VAR_5 ) { return METHOD_2 ( ( T ) VAR_1 , null , session ) ; <START> } <END> return METHOD_2 ( ( T ) VAR_1 , ( T ) target , session ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { log . VAR_2 ( STRING_1 , VAR_1 ) ; <START> final Set < TYPE_2 > VAR_3 = VAR_4 . get ( VAR_1 ) ; <END> if ( VAR_3 != null ) { METHOD_2 ( VAR_3 ) ; VAR_4 . remove ( VAR_1 ) ; } else if ( log . VAR_5 ( ) ) { log . VAR_6 ( ) ; } close ( VAR_1 ) ; if ( VAR_7 == VAR_1 ) { VAR_7 = null ; } } 
protected void METHOD_1 ( ) { final Map VAR_1 = METHOD_2 ( ) ; VAR_1 . put ( TYPE_3 . NONE , METHOD_3 ( TYPE_3 . NONE ) ) ; <START> <END> VAR_3 = METHOD_3 ( TYPE_3 . NONE ) ; VAR_4 = METHOD_3 ( TYPE_3 . VAR_5 ) ; VAR_1 . put ( STRING_1 , new TYPE_1 ( this , TYPE_2 . VAR_7 , METHOD_4 ( ) ) ) ; VAR_1 . put ( STRING_2 , new TYPE_1 ( this , TYPE_2 . VAR_8 , METHOD_4 ( ) ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( TYPE_2 . NONE . equals ( VAR_1 ) ) { <END> return VAR_2 ; } else if ( TYPE_2 . TYPE_4 . equals ( VAR_1 ) ) { return VAR_3 ; } return VAR_4 . METHOD_2 ( VAR_1 , this : : METHOD_3 ) ; } 
public static String METHOD_1 ( TYPE_1 type , Context context ) { TYPE_2 VAR_1 = type . VAR_2 ( ) ; if ( ! VAR_1 . METHOD_2 ( ) . isEmpty ( ) ) { TYPE_2 VAR_3 = type . VAR_2 ( ) . METHOD_3 ( new TYPE_3 < TYPE_2 , TYPE_4 > ( ) { @Override protected TYPE_2 METHOD_4 ( TYPE_2 e , TYPE_4 VAR_4 ) { return e ; } } , null ) ; return METHOD_5 ( VAR_3 , context ) + STRING_1 ; } <START> return METHOD_6 ( type ) ; <END> } 
public void METHOD_1 ( ) { if ( ! session . VAR_1 ( ) ) { throw new IllegalStateException ( STRING_1 ) ; } if ( VAR_2 == null ) { VAR_2 = VAR_3 . METHOD_2 ( ) ; } if ( METHOD_3 ( ) ) { throw new IllegalStateException ( STRING_2 ) ; } <START> if ( LOG . VAR_4 ( ) ) { <END> LOG . debug ( STRING_3 ) ; } this . VAR_2 . METHOD_1 ( ) ; } 
<START> public String getMessage ( ) { <END> return message ; } 
<START> public final String METHOD_1 ( ) { <END> return VAR_1 ; } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; return name . equals ( that . name ) ; <START> } <END> 
public boolean METHOD_1 ( ) { <START> return ! results . isEmpty ( ) ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> if ( id != that . id ) { <END> return false ; } return true ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { <START> if ( VAR_2 == null ) return null ; <END> for ( TYPE_1 VAR_3 : VAR_2 ) { if ( VAR_1 == VAR_3 . getId ( ) ) { return VAR_3 ; } } return null ; } 
public void run ( final TYPE_1 server , final TYPE_2 VAR_1 , final String VAR_2 , final String [ ] args ) throws Exception { if ( args . length > 1 ) { <START> TYPE_3 target = METHOD_1 ( server , args , 0 , true ) ; <END> VAR_1 . METHOD_2 ( STRING_1 + ( target . VAR_3 ( ) ? METHOD_3 ( STRING_2 ) : METHOD_3 ( STRING_3 ) ) ) ; } else { throw new TYPE_4 ( ) ; } } 
private static int METHOD_1 ( TYPE_1 state ) { <START> if ( state . VAR_1 > INT_1 ) { <END> return INT_2 ; } else if ( state . VAR_1 > INT_3 ) { return INT_4 ; } else if ( state . VAR_1 > 0 ) { return 10 ; } else { return 0 ; } } 
<START> public void METHOD_1 ( ) throws TYPE_1 { <END> int VAR_1 = 0 ; try { TYPE_2 result = new TYPE_3 ( ) . METHOD_2 ( STRING_1 , TYPE_4 . VAR_3 , 0 , 0 ) ; } catch ( IllegalArgumentException e ) { VAR_1 = 1 ; } assertEquals ( VAR_1 , 1 ) ; } 
protected static int METHOD_1 ( boolean [ ] target , int VAR_1 , int [ ] VAR_2 , boolean VAR_3 ) { int VAR_4 = INT_1 ; for ( int VAR_5 : VAR_2 ) { <START> target [ VAR_1 ++ ] = VAR_5 == 0 ? false : true ; <END> } return VAR_4 ; } 
private static int METHOD_1 ( String VAR_1 , int VAR_2 ) { int VAR_3 = 1 ; int VAR_4 = 0 ; for ( int i = VAR_1 . length ( ) - 1 ; i >= 0 ; i -- ) { int VAR_5 = TYPE_2 . TYPE_3 . METHOD_2 ( VAR_1 . METHOD_3 ( i ) ) ; VAR_4 += VAR_5 * VAR_3 ; if ( ++ VAR_3 > VAR_2 ) { VAR_3 = 1 ; } } <START> int VAR_6 = VAR_4 % INT_1 ; <END> return VAR_6 ; } 
protected static int METHOD_1 ( boolean [ ] target , int VAR_1 , int [ ] VAR_2 , boolean VAR_3 ) { <START> int VAR_4 = INT_1 ; <END> for ( int VAR_5 : VAR_2 ) { target [ VAR_1 ++ ] = VAR_5 != 0 ; } return VAR_4 ; } 
public void METHOD_1 ( int x , int y ) { int offset = y * VAR_1 + ( x / INT_1 ) ; <START> int VAR_2 = ( 1 < < ( x & INT_2 ) ) ; <END> if ( ( VAR_3 [ offset ] & VAR_2 ) > 0 ) { VAR_3 [ offset ] ^= VAR_2 ; } } 
protected void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { <START> VAR_2 = ( ) - > VAR_1 ; <END> } 
<START> public TYPE_1 ( String VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
default T VAR_1 ( TYPE_1 VAR_3 ) throws IOException { <START> return VAR_1 ( VAR_3 . VAR_4 ( ) ) ; <END> } 
default boolean VAR_1 ( TYPE_1 VAR_3 ) throws IOException { <START> return VAR_1 ( VAR_3 . VAR_4 ( ) ) ; <END> } 
<START> private void METHOD_1 ( Path p , TYPE_1 listener , TYPE_2 session , <END> boolean VAR_1 ) throws IOException { if ( VAR_1 ) { listener . VAR_2 ( session , p ) ; } else { listener . VAR_3 ( session , p ) ; } } 
<START> private void METHOD_1 ( Path p , TYPE_1 listener , TYPE_2 session , <END> boolean VAR_1 , Exception e ) throws IOException { if ( VAR_1 ) { listener . VAR_2 ( session , p , e ) ; } else { listener . VAR_3 ( session , p , e ) ; } } 
private synchronized void METHOD_1 ( int cmd , TYPE_1 buffer , boolean VAR_1 ) { <START> try { <END> if ( VAR_1 ) { METHOD_2 ( cmd , buffer ) ; } else { METHOD_3 ( cmd , buffer ) ; } } catch ( Exception e ) { log . warn ( STRING_1 , e . getMessage ( ) , e ) ; } } 
public static String METHOD_1 ( Path path , TYPE_1 ... options ) throws IOException { String VAR_1 = null ; try { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( path , options ) ; if ( VAR_2 != null ) { VAR_1 = VAR_2 . getName ( ) ; } } catch ( TYPE_4 e ) { } return VAR_1 ; <START> } <END> 
public TYPE_1 METHOD_1 ( ) { TYPE_2 metadata = new TYPE_2 ( STRING_1 , TYPE_3 . VAR_2 , STRING_2 ) ; metadata . VAR_3 ( STRING_3 ) ; <START> final int [ ] VAR_4 = { INT_1 , INT_2 , INT_3 , INT_1 , INT_2 , INT_4 , INT_5 , INT_6 , INT_7 , INT_8 , INT_2 , INT_9 , INT_2 , INT_10 , INT_1 } ; <END> VAR_5 = VAR_6 . METHOD_2 ( metadata ) ; for ( int VAR_7 : VAR_4 ) { VAR_5 . update ( VAR_7 ) ; } return VAR_5 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; final Object VAR_2 = VAR_1 . METHOD_3 ( TYPE_1 . class . getName ( ) ) ; <START> if ( VAR_2 != null && TYPE_3 . class . METHOD_4 ( VAR_2 ) ) { <END> return ( TYPE_1 ) TYPE_3 . class . METHOD_5 ( VAR_2 ) . apply ( VAR_1 ) ; } return null ; } 
<START> final public boolean equals ( Object obj ) { <END> if ( obj == this ) { return true ; } else if ( obj instanceof TYPE_1 < ? > ) { TYPE_1 < ? > that = ( TYPE_1 < ? > ) obj ; return this . VAR_1 . equals ( that . VAR_1 ) ; } else { return false ; } } 
ANNOTATION_1 ANNOTATION_2 TYPE_1 METHOD_1 ( TYPE_2 <START> VAR_1 ) { <END> return new TYPE_3 ( VAR_1 ) ; } 
public TYPE_1 contains ( TYPE_2 ... VAR_1 ) { METHOD_1 ( VAR_1 ) ; Set < TYPE_2 > VAR_2 = new TYPE_3 < TYPE_2 > ( ) ; for ( TYPE_2 entry : VAR_1 ) { if ( ! METHOD_2 ( VAR_3 , entry ) ) { VAR_2 . add ( entry ) ; } } if ( VAR_2 . isEmpty ( ) ) { return this ; } <START> throw TYPE_4 . instance ( ) . METHOD_3 ( new TYPE_5 ( ) , METHOD_4 ( VAR_3 , VAR_1 , VAR_2 ) ) ; <END> } 
<START> public boolean equals ( Object obj ) { <END> if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return METHOD_1 ( key , VAR_1 . key ) && METHOD_1 ( value , VAR_1 . value ) ; } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 VAR_1 = new TYPE_1 ( output , VAR_2 , TYPE_2 . class ) ; <END> VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( new TYPE_3 ( ) ) ; VAR_1 . write ( this . METHOD_4 ( ) ) ; VAR_1 . close ( ) ; METHOD_5 ( outputStream . VAR_3 ( ) , this . METHOD_4 ( ) , TYPE_2 . class ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> TYPE_1 VAR_1 = new TYPE_1 ( output , VAR_2 , TYPE_2 . class ) ; VAR_1 . METHOD_2 ( false ) ; VAR_1 . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( new TYPE_3 ( ) ) ; VAR_1 . write ( this . METHOD_5 ( ) ) ; VAR_1 . close ( ) ; METHOD_6 ( outputStream . VAR_3 ( ) , this . METHOD_5 ( ) , TYPE_2 . class , false ) ; } 
<START> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> this . VAR_1 = VAR_1 ; return this ; } 
public TYPE_5 ( TYPE_1 VAR_2 ) throws Exception { super ( ) ; Assert . VAR_3 ( VAR_2 , STRING_1 ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> TYPE_2 VAR_4 = VAR_2 . METHOD_2 ( ) ; TYPE_3 VAR_5 = new TYPE_3 ( VAR_4 ) ; TYPE_4 < T > VAR_6 = new TYPE_4 < > ( ) ; VAR_6 . METHOD_3 ( VAR_5 ) ; VAR_6 . METHOD_1 ( ) ; METHOD_3 ( VAR_6 ) ; } 
<START> public TYPE_1 < Integer > METHOD_1 ( ) { <END> TYPE_2 VAR_1 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; TYPE_3 < Integer > VAR_2 = new TYPE_3 < > ( ) ; VAR_2 . METHOD_4 ( VAR_1 ) ; VAR_2 . METHOD_5 ( METHOD_6 ( ) ) ; return VAR_2 ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 < T , TYPE_3 < ? super T > > VAR_1 ) { <END> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; this . VAR_1 = VAR_1 ; return this ; } 
public TYPE_1 < T > METHOD_1 ( TYPE_2 < T , TYPE_3 < ? super T > > VAR_1 ) { <START> Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; return this ; } 
public TYPE_1 METHOD_1 ( List < TYPE_2 < ? super T > > VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; <START> Assert . VAR_3 ( VAR_1 , STRING_2 ) ; <END> this . VAR_1 = VAR_1 ; return this ; } 
<START> protected TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; if ( METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ) { TYPE_2 VAR_3 = METHOD_2 ( ) . METHOD_4 ( VAR_2 ) ; TYPE_1 properties = ( TYPE_1 ) VAR_3 . METHOD_5 ( ) . METHOD_6 ( TYPE_1 . class ) . getValue ( ) ; if ( properties == null ) { return new TYPE_1 ( ) ; } VAR_1 . METHOD_7 ( properties ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { <START> Assert . VAR_1 ( ! ( VAR_2 == null ) , STRING_1 ) ; <END> Assert . VAR_3 ( name , STRING_2 ) ; } 
void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( METHOD_2 ( VAR_1 . METHOD_3 ( ) . VAR_2 ) ) { <END> TYPE_2 result = VAR_1 . METHOD_4 ( ) ; if ( result != null ) { if ( result instanceof TYPE_2 . TYPE_4 ) { TYPE_4 VAR_3 = ( ( TYPE_2 . TYPE_4 ) result ) . METHOD_5 ( ) ; cache . set ( VAR_1 . getKey ( ) , VAR_3 ) ; } } } VAR_4 . remove ( VAR_1 . getKey ( ) ) ; METHOD_6 ( VAR_1 ) ; } 
public Builder METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; if ( ! VAR_2 && this . VAR_3 != null ) { <START> throw new IllegalStateException ( STRING_2 ) ; <END> } this . VAR_3 = VAR_1 ; return this ; } 
<START> public TYPE_2 ( TYPE_1 data ) { <END> this . data = data ; } 
<START> static int METHOD_1 ( int VAR_1 ) { <END> int VAR_2 ; switch ( VAR_1 ) { case VAR_3 : case VAR_4 : VAR_2 = INT_1 ; break ; case VAR_5 : case VAR_6 : VAR_2 = INT_2 ; break ; case VAR_7 : case VAR_8 : VAR_2 = INT_3 ; break ; default : VAR_2 = 0 ; } return VAR_2 ; } 
<START> static int METHOD_1 ( int VAR_1 ) { <END> int VAR_2 ; switch ( VAR_1 ) { case VAR_3 : case VAR_4 : case VAR_5 : case VAR_6 : VAR_2 = - 1 ; break ; default : VAR_2 = 1 ; } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 view ) { if ( view == null ) { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } METHOD_2 ( view ) ; } 
static int METHOD_1 ( TYPE_1 uri ) throws IOException { TYPE_2 VAR_1 = new TYPE_2 ( uri . getPath ( ) ) ; int VAR_2 = VAR_1 . METHOD_2 ( VAR_3 , VAR_4 ) ; <START> return VAR_2 ; <END> } 
<START> public Builder METHOD_1 ( List < ? extends TYPE_1 > VAR_1 ) { <END> if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } for ( Object VAR_2 : VAR_1 ) { METHOD_1 ( ( TYPE_1 ) VAR_2 ) ; } return this ; } 
<START> static boolean METHOD_1 ( int VAR_1 ) { <END> return ( VAR_1 & TYPE_1 . VAR_3 . index ) == TYPE_1 . VAR_3 . index ; } 
<START> ANNOTATION_1 ( STRING_1 ) public void METHOD_1 ( boolean VAR_1 ) { <END> VAR_2 = VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_2 ... VAR_2 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } this . VAR_3 |= VAR_1 . index ; <START> if ( VAR_2 != null && VAR_2 . length > 0 ) { <END> for ( TYPE_2 VAR_3 : VAR_2 ) { if ( VAR_3 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } this . VAR_3 |= VAR_3 . index ; } } return this ; } 
<START> public void error ( ) { <END> if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; } } 
public TYPE_1 < ? > METHOD_1 ( TYPE_2 task ) { if ( task == null ) { <START> throw new TYPE_3 ( ) ; <END> } TYPE_4 VAR_1 = new TYPE_4 ( ( TYPE_5 ) task ) ; execute ( VAR_1 ) ; return VAR_1 ; } 
ANNOTATION_1 public void METHOD_1 ( ) { TYPE_1 action = METHOD_2 ( VAR_1 , VAR_2 ) ; TYPE_2 VAR_3 = new TYPE_2 ( context ) ; <START> List < TYPE_3 > VAR_4 = new ArrayList < TYPE_3 > ( Arrays . asList ( VAR_3 ) ) ; <END> TYPE_4 VAR_5 = new TYPE_4 ( context , VAR_6 , cache , null , null , VAR_4 , VAR_7 , false , false ) ; TYPE_5 VAR_8 = METHOD_3 ( VAR_5 , VAR_6 , cache , VAR_7 , action ) ; assertThat ( VAR_8 . VAR_9 ) . METHOD_4 ( VAR_3 ) ; } 
@Override TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( VAR_1 , VAR_2 ) ; <END> } 
public Builder ( Context context ) { if ( context == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> if ( ! METHOD_1 ( context , TYPE_1 . VAR_2 . VAR_3 ) ) { <END> throw new IllegalArgumentException ( STRING_2 ) ; } this . context = context . VAR_4 ( ) ; } 
public TYPE_11 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 cache , TYPE_4 VAR_4 , TYPE_5 action , TYPE_6 VAR_5 ) { super ( VAR_2 , VAR_3 , cache , VAR_4 , action ) ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_7 ; if ( ! METHOD_1 ( VAR_2 . context , TYPE_12 . VAR_9 . VAR_10 ) ) { TYPE_1 . TYPE_10 . METHOD_2 ( new TYPE_8 ( ) { @Override public void run ( ) { <START> throw new TYPE_9 ( STRING_1 ) ; <END> } } ) ; } } 
public int METHOD_1 ( ) { int result = VAR_1 . METHOD_1 ( ) ; result = INT_1 * result + VAR_2 ; <START> return result ; <END> } 
void METHOD_1 ( TYPE_1 action ) { <START> if ( VAR_1 != null ) { <END> VAR_1 . remove ( action ) ; } if ( this . action == action ) { this . action = null ; } } 
ANNOTATION_1 public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 , VAR_3 , METHOD_3 ( ) ) ; TYPE_1 VAR_4 = METHOD_2 ( VAR_2 , VAR_3 , METHOD_3 ( ) ) ; TYPE_2 VAR_5 = new TYPE_3 ( VAR_6 , VAR_7 , cache , VAR_8 , VAR_1 ) ; assertThat ( VAR_5 . VAR_9 ) . METHOD_4 ( ) ; VAR_5 . METHOD_5 ( VAR_4 ) ; assertThat ( VAR_5 . VAR_9 ) . METHOD_6 ( ) ; <START> assertThat ( VAR_5 . VAR_9 ) . METHOD_7 ( 1 ) ; <END> } 
static TYPE_3 . TYPE_4 METHOD_1 ( TYPE_2 data ) { final boolean VAR_1 = data . VAR_2 ( ) ; final boolean VAR_3 = data . config != null ; <START> final boolean VAR_4 = VAR_3 || VAR_1 ; <END> final TYPE_3 . TYPE_4 options = VAR_4 ? new TYPE_3 . TYPE_4 ( ) : null ; if ( VAR_1 ) { options . VAR_5 = true ; } if ( VAR_3 ) { options . VAR_6 = data . config ; } return options ; } 
public int METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 ; <START> return ( VAR_1 == null || VAR_1 . METHOD_2 ( ) || VAR_3 . METHOD_3 ( ) < INT_1 ) <END> ? TYPE_2 . VAR_5 : TYPE_2 . VAR_6 ; } 
@Override public void METHOD_1 ( Context context , TYPE_1 VAR_1 ) { <START> if ( null == VAR_1 ) <END> return ; String action = VAR_1 . METHOD_2 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( TYPE_3 . equals ( action ) ) { METHOD_4 ( VAR_2 . METHOD_5 ( VAR_3 , false ) ) ; } else if ( TYPE_4 . equals ( action ) ) { METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; } } 
static long METHOD_1 ( File VAR_1 ) { long size = VAR_2 ; try { TYPE_1 VAR_3 = new TYPE_1 ( VAR_1 . METHOD_2 ( ) ) ; <START> long VAR_4 = VAR_3 . METHOD_3 ( ) * VAR_3 . METHOD_4 ( ) ; <END> size = VAR_4 / INT_1 ; } catch ( IllegalArgumentException VAR_5 ) { } return Math . max ( Math . VAR_6 ( size , VAR_7 ) , VAR_2 ) ; } 
TYPE_1 METHOD_1 ( String key ) { TYPE_1 VAR_1 = cache . get ( key ) ; if ( VAR_1 != null ) { VAR_2 . METHOD_2 ( ) ; } else { <START> VAR_2 . METHOD_3 ( ) ; <END> } return VAR_1 ; } 
<START> ANNOTATION_1 ( STRING_1 ) public void METHOD_1 ( ) { <END> cache . clear ( ) ; VAR_1 . METHOD_1 ( ) ; VAR_2 . METHOD_1 ( ) ; VAR_3 . METHOD_1 ( ) ; if ( this == VAR_4 ) { VAR_4 = null ; } VAR_5 = true ; } 
TYPE_9 ( TYPE_1 VAR_2 , TYPE_2 uri , int VAR_3 , TYPE_3 VAR_4 , TYPE_4 options , List < TYPE_5 > VAR_5 , boolean VAR_6 , boolean VAR_7 , int VAR_8 , TYPE_6 VAR_9 , String key , TYPE_7 VAR_10 ) { super ( VAR_2 , uri , VAR_3 , VAR_4 , options , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , key , VAR_10 ) ; TYPE_8 VAR_11 = VAR_4 . METHOD_1 ( ) ; <START> if ( VAR_11 . METHOD_2 ( ) ) { <END> VAR_11 . METHOD_3 ( this ) ; } } 
TYPE_2 ( Context context ) { <START> this . VAR_2 = <END> ( TYPE_1 ) context . VAR_3 ( VAR_4 ) ; } 
static void METHOD_1 ( TYPE_1 is ) { <START> try { <END> if ( is != null ) { is . close ( ) ; } } catch ( IOException VAR_1 ) { } } 
TYPE_1 execute ( TYPE_2 request ) throws IOException { TYPE_3 VAR_1 = TYPE_3 . METHOD_1 ( context , this , VAR_2 , request , VAR_3 ) ; <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
void METHOD_1 ( TYPE_1 request ) { Object target = request . VAR_1 ( ) ; if ( target == null ) return ; METHOD_2 ( target , request . uri ) ; VAR_2 . put ( target , request ) ; <START> VAR_3 . put ( request . VAR_4 ( ) . METHOD_3 ( ) , request ) ; <END> request . VAR_5 = VAR_6 . METHOD_1 ( request ) ; } 
TYPE_1 METHOD_1 ( TYPE_2 uri , TYPE_3 VAR_1 ) throws IOException { <START> String path = uri . getPath ( ) . METHOD_2 ( STRING_1 , "" ) ; <END> TYPE_4 VAR_2 = context . VAR_3 ( ) ; if ( VAR_1 != null && VAR_1 . VAR_4 ) { TYPE_5 . METHOD_3 ( VAR_2 . METHOD_4 ( path ) , null , VAR_1 ) ; METHOD_5 ( VAR_1 ) ; } return METHOD_3 ( VAR_2 . METHOD_4 ( path ) , VAR_1 ) ; } 
TYPE_1 METHOD_1 ( TYPE_2 uri , TYPE_3 VAR_1 ) throws IOException { <START> String path = uri . getPath ( ) . METHOD_2 ( STRING_1 , "" ) ; <END> try { return METHOD_1 ( Integer . parseInt ( path ) , VAR_1 ) ; } catch ( TYPE_4 VAR_2 ) { throw new IOException ( STRING_2 + path + STRING_3 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 ) { if ( VAR_3 == VAR_1 ) { return ; } VAR_3 = VAR_1 ; if ( logger . VAR_4 ( ) ) { logger . trace ( Logger . TYPE_2 . VAR_6 , VAR_7 . METHOD_2 ( STRING_1 , VAR_2 ) . METHOD_3 ( STRING_2 , METHOD_4 ( ) ) <START> . METHOD_5 ( STRING_3 , VAR_1 ) . toString ( ) ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) { <START> return this . VAR_1 . METHOD_1 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 != - 1 ) { TYPE_1 . TYPE_4 VAR_3 = VAR_1 . METHOD_2 ( ( byte ) VAR_2 ) ; if ( VAR_3 != null && VAR_3 . METHOD_3 ( ) == 2 ) { int VAR_4 = TYPE_3 . METHOD_4 ( VAR_3 . METHOD_5 ( ) , VAR_3 . METHOD_6 ( ) + 1 ) ; <START> METHOD_7 ( <END> VAR_4 , VAR_1 . METHOD_8 ( ) , VAR_1 . METHOD_9 ( ) ) ; } } return VAR_1 ; } 
private static String METHOD_1 ( byte b ) { char [ ] VAR_1 <START> = new char [ ] <END> { CHAR_1 , CHAR_2 , CHAR_3 , CHAR_4 , CHAR_5 , CHAR_6 , CHAR_7 , CHAR_8 , CHAR_9 , CHAR_10 , CHAR_11 , CHAR_12 , CHAR_13 , CHAR_14 , CHAR_15 , CHAR_16 } ; StringBuilder VAR_2 = new StringBuilder ( 2 ) ; VAR_2 . append ( VAR_1 [ ( b & INT_1 ) > > 4 ] ) ; VAR_2 . append ( VAR_1 [ b & INT_2 ] ) ; return VAR_2 . toString ( ) ; } 
public TYPE_1 METHOD_1 ( byte [ ] buf , int VAR_1 , int VAR_2 ) { TYPE_2 VAR_3 = new TYPE_2 ( buf , VAR_1 , VAR_2 ) ; <START> return METHOD_1 ( VAR_3 . METHOD_2 ( ) , VAR_3 . METHOD_3 ( ) ) ; <END> } 
public byte METHOD_1 ( ) { <START> return VAR_1 == - 1 ? VAR_2 : VAR_1 ; <END> } 
<START> public < TYPE_1 , TYPE_2 > List < TYPE_1 > METHOD_1 ( TYPE_3 < TYPE_1 , TYPE_2 > VAR_1 ) <END> { ArrayList < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; for ( Map . Entry < TYPE_1 , TYPE_2 > entry : VAR_1 . entrySet ( ) ) { VAR_2 . add ( entry . getKey ( ) ) ; } return VAR_2 ; } 
<START> long METHOD_1 ( long VAR_1 ) <END> { long VAR_2 = ( long ) ( ( ( VAR_1 < < VAR_3 ) + INT_1 ) / INT_2 ) & INT_3 ; return VAR_2 ; } 
<START> boolean METHOD_1 ( long VAR_1 , TYPE_1 VAR_2 ) <END> { if ( VAR_2 . count == 0 ) { return true ; } double VAR_3 = VAR_2 . VAR_4 / ( double ) VAR_2 . count ; return Math . VAR_5 ( ( double ) VAR_1 - VAR_3 ) < FLOAT_1 ; } 
<START> void METHOD_1 ( List < TYPE_1 > VAR_1 , TYPE_1 cluster ) <END> { cluster . VAR_2 /= ( double ) cluster . count ; cluster . VAR_3 /= ( double ) cluster . count ; cluster . VAR_4 /= cluster . count ; VAR_1 . add ( cluster ) ; } 
public boolean METHOD_1 ( long VAR_1 ) { <START> if ( VAR_2 != VAR_1 && VAR_3 != VAR_1 ) <END> { return false ; } return true ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) < 2 ) <END> return false ; byte b = VAR_1 . METHOD_3 ( ) [ VAR_1 . METHOD_4 ( ) + 1 ] ; return ( b & VAR_2 ) != 0 ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 && ! VAR_3 && VAR_1 != null && VAR_1 . METHOD_2 ( ) == 2 ) <END> { VAR_4 . METHOD_3 ( VAR_1 ) ; } return VAR_1 ; } 
<START> public static boolean METHOD_1 ( byte [ ] buffer , int offset , int length ) <END> { return ( buffer [ offset + 1 ] & INT_1 ) != 0 ; } 
public TYPE_2 ( int VAR_2 ) { super ( VAR_3 ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_4 = new TYPE_1 ( 0 ) ; <END> this . VAR_5 = 0 ; } 
public TYPE_1 node ( ) { final TYPE_1 VAR_1 = TYPE_1 . class . METHOD_1 ( this . cache ) ; final TYPE_1 VAR_2 ; <START> final boolean VAR_3 = VAR_1 instanceof TYPE_2 ; <END> if ( VAR_3 ) { VAR_2 = VAR_1 . METHOD_2 ( true ) ; } else { VAR_2 = this . METHOD_3 ( VAR_1 ) ; } return VAR_2 ; } 
private TYPE_1 METHOD_1 ( final TYPE_1 node ) { <START> assert ! ( node instanceof TYPE_2 ) ; <END> final TYPE_2 VAR_1 ; try { VAR_1 = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) ; } catch ( final TYPE_4 ex ) { throw new IllegalStateException ( ex ) ; } final TYPE_1 VAR_2 = VAR_1 . METHOD_4 ( node , true ) ; VAR_1 . METHOD_5 ( VAR_2 ) ; return VAR_2 ; } 
public String METHOD_1 ( ) { try { return TYPE_1 . toString ( this . stream ) ; } catch ( final IOException exception ) { <START> throw new RuntimeException ( STRING_1 , exception ) ; <END> } } 
public String toString ( ) { <START> return METHOD_1 ( STRING_1 ) ; <END> } 
<START> public String METHOD_1 ( String VAR_1 ) { <END> return METHOD_2 ( VAR_2 . apply ( VAR_1 ) . METHOD_3 ( STRING_1 , STRING_2 ) . METHOD_3 ( STRING_3 , "" ) . METHOD_4 ( ) ) ; } 
private TYPE_1 ( Builder builder ) { this . VAR_2 = METHOD_1 ( builder . VAR_2 ) ; this . VAR_3 = METHOD_1 ( builder . VAR_3 ) ; this . VAR_4 = METHOD_1 ( builder . VAR_4 ) ; this . VAR_5 = METHOD_2 ( METHOD_1 ( builder . VAR_5 ) ) ; this . VAR_6 = METHOD_1 ( builder . VAR_6 ) ; <START> this . VAR_7 = builder . VAR_7 ; <END> this . VAR_8 = METHOD_1 ( builder . VAR_8 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , STRING_2 , STRING_3 , VAR_1 ) ; <START> METHOD_2 ( STRING_4 , STRING_5 , STRING_6 , VAR_2 ) ; <END> } 
private TYPE_1 METHOD_1 ( final TYPE_2 ... VAR_1 ) { return new TYPE_1 ( <START> ( TYPE_3 ) VAR_2 , <END> VAR_3 , METHOD_2 ( ) , METHOD_3 ( ) , VAR_4 , VAR_5 ) . METHOD_4 ( VAR_1 ) ; } 
<START> @Override public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 VAR_1 , Set < ? extends TYPE_2 > VAR_2 , <END> TYPE_3 VAR_3 ) { TYPE_4 . Builder < TYPE_2 > VAR_4 = TYPE_4 . METHOD_2 ( VAR_5 ) ; for ( TYPE_2 VAR_6 : VAR_2 ) { VAR_4 . METHOD_3 ( VAR_6 , METHOD_1 ( VAR_1 , VAR_6 ) ) ; } return VAR_4 . build ( ) ; } 
<START> @Override public String toString ( ) { <END> return VAR_1 ; } 
public boolean contains ( ANNOTATION_1 TYPE_1 VAR_1 ) { return VAR_1 != null && VAR_1 . equals ( VAR_2 . get ( VAR_1 . getId ( ) ) ) ; <START> } <END> 
private TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , TYPE_2 . METHOD_2 ( TYPE_6 < TYPE_3 < ? super TYPE_4 > > of ( METHOD_3 ( VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 ) , TYPE_2 . and ( TYPE_2 . METHOD_4 ( TYPE_5 . class ) , METHOD_3 ( VAR_14 , VAR_15 , VAR_16 , VAR_17 , VAR_6 , VAR_18 , VAR_19 , VAR_20 , VAR_21 , VAR_7 , VAR_22 , <START> VAR_23 <END> ) ) ) ) ) ; } 
public TYPE_9 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 < TYPE_5 > VAR_5 , TYPE_6 < TYPE_5 > filter ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; this . VAR_4 = METHOD_1 ( VAR_4 ) ; this . VAR_5 = METHOD_1 ( VAR_5 ) ; this . filter = METHOD_1 ( filter ) ; this . VAR_6 = TYPE_7 . create ( <START> TYPE_8 . VAR_8 , <END> TYPE_10 . Type . VAR_10 ) ; } 
private void METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = TYPE_1 . create ( TYPE_3 . VAR_3 , TYPE_4 . Type . VAR_5 ) ; VAR_1 . METHOD_2 ( ) ; <START> VAR_6 = TYPE_2 . METHOD_3 ( ) ; <END> } else if ( VAR_6 . METHOD_4 ( 1 ) . METHOD_5 ( ) ) { VAR_1 . METHOD_6 ( ) ; VAR_1 . METHOD_2 ( ) ; } } 
private static TYPE_1 METHOD_1 ( TYPE_2 name ) { TYPE_3 VAR_1 ; try { VAR_1 = TYPE_3 . valueOf ( TYPE_4 . VAR_3 ) ; } catch ( IllegalArgumentException e ) { <START> log . error ( STRING_1 , TYPE_4 . VAR_3 ) ; <END> e . VAR_4 ( ) ; VAR_1 = TYPE_3 . VAR_5 ; } return TYPE_1 . create ( name . VAR_6 ( ) , name . VAR_7 ( ) , VAR_1 ) ; } 
private String METHOD_1 ( TYPE_1 channel ) { return channel . VAR_1 ( ) <START> . METHOD_2 ( VAR_2 , "" ) <END> . trim ( ) ; } 
private Optional < TYPE_1 > METHOD_1 ( TYPE_1 channel , TYPE_2 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) > 0 ) { channel . VAR_3 ( VAR_1 ) ; } else { channel . VAR_3 ( null ) ; } if ( VAR_2 != null && VAR_2 . METHOD_2 ( ) > 0 ) { channel . VAR_4 ( VAR_2 ) ; } else { channel . VAR_4 ( null ) ; } VAR_5 . METHOD_3 ( channel ) ; <START> return Optional . of ( channel ) ; <END> } 
private void METHOD_1 ( Set < Long > VAR_1 , TYPE_1 < TYPE_2 > VAR_2 ) { for ( TYPE_2 channel : VAR_2 ) { if ( ! VAR_1 . contains ( channel . getId ( ) ) ) { channel . VAR_3 ( channel . VAR_4 ( ) . stream ( ) <START> . filter ( VAR_5 - > ! VAR_5 . METHOD_2 ( ) . equals ( VAR_6 ) ) <END> . collect ( Collectors . VAR_7 ( ) ) ) ; } VAR_8 . METHOD_3 ( channel ) ; } } 
private boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> return false && VAR_1 . equals ( VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 TYPE_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; Set < TYPE_4 > VAR_2 = TYPE_5 . METHOD_3 ( ) ; if ( Boolean . VAR_3 ( VAR_4 ) && Boolean . VAR_3 ( VAR_5 ) ) { log . info ( STRING_1 ) ; METHOD_4 ( VAR_2 ) ; } <START> for ( TYPE_4 VAR_6 : VAR_2 ) { <END> TYPE_2 . METHOD_5 ( VAR_6 ) ; } } 
private TYPE_2 ( String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 , TYPE_1 VAR_6 ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; this . VAR_4 = METHOD_1 ( VAR_4 ) ; this . VAR_5 = METHOD_1 ( VAR_5 ) ; <START> this . VAR_7 = VAR_6 ; <END> } 
<START> public TYPE_3 ( TYPE_1 VAR_2 ) { <END> this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = TYPE_2 . METHOD_2 ( ) ; } 
<START> public TYPE_4 ( TYPE_1 < String > VAR_2 , TYPE_1 < String > VAR_3 ) { <END> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 ) ; this . VAR_3 = TYPE_2 . METHOD_1 ( VAR_3 ) ; this . VAR_4 = TYPE_3 . METHOD_2 ( ) ; } 
<START> public TYPE_4 ( <END> TYPE_1 < ? extends TYPE_2 < T > > VAR_2 , Set < String > VAR_3 , Set < String > VAR_4 ) { this . VAR_2 = ImmutableList . VAR_5 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_6 = TYPE_3 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 item = new TYPE_1 ( ) ; <START> item . VAR_1 ( INT_1 ) ; <END> item . VAR_2 ( STRING_1 ) ; VAR_3 . METHOD_2 ( item , VAR_4 ) ; METHOD_3 ( VAR_5 ) . METHOD_2 ( item , VAR_4 ) ; } 
private TYPE_1 METHOD_1 ( ) { return TYPE_1 . create ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , METHOD_2 ( ) , VAR_5 , VAR_6 , VAR_7 , new TYPE_2 ( VAR_6 , VAR_8 , VAR_9 ) , <START> new TYPE_3 ( <END> new TYPE_4 ( VAR_10 , new TYPE_5 ( VAR_10 , VAR_5 ) ) , VAR_7 , VAR_6 ) ) ; } 
private TYPE_1 METHOD_1 ( ) { return TYPE_1 . create ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , METHOD_2 ( ) , VAR_5 , VAR_6 , VAR_7 , new TYPE_2 ( VAR_6 , VAR_8 , VAR_9 ) , VAR_10 , <START> VAR_1 <END> ) ; } 
public void METHOD_1 ( ) { map . put ( STRING_1 , STRING_2 ) ; <START> Assert . assertThat ( <END> TYPE_1 . METHOD_2 ( STRING_3 , map ) , is ( STRING_4 ) ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( <END> VAR_1 , VAR_2 , new TYPE_2 ( ) , new TYPE_3 ( METHOD_2 ( ) , new TYPE_4 ( ) ) ) ; } 
private TYPE_1 < TYPE_2 < TYPE_3 > > METHOD_1 ( TYPE_1 < TYPE_3 > VAR_1 ) throws TYPE_4 , TYPE_5 { return new TYPE_6 ( VAR_1 , <START> VAR_2 , <END> VAR_3 , VAR_4 , VAR_5 ) ; } 
public boolean hasNext ( ) { <START> if ( VAR_1 . hasNext ( ) ) { <END> return true ; } return false ; } 
public List < TYPE_1 > METHOD_1 ( String VAR_1 , String uri ) { TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_2 . METHOD_3 ( uri ) ; List < TYPE_1 > VAR_3 ; try { <START> VAR_3 = VAR_4 . METHOD_4 ( VAR_2 ) ; <END> } catch ( TYPE_3 e ) { throw TYPE_4 . METHOD_5 ( e ) ; } return VAR_3 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 content ) { Set < String > VAR_2 = VAR_3 . map ( content . VAR_4 ( ) ) ; <START> if ( ! VAR_2 . isEmpty ( ) ) { <END> content . VAR_5 ( VAR_2 ) ; } } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 < String > VAR_3 = TYPE_3 . from ( VAR_2 . METHOD_2 ( ) ) . METHOD_3 ( VAR_4 ) . METHOD_4 ( ) ; TYPE_2 < String > VAR_5 = TYPE_3 . from ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( VAR_4 ) . METHOD_4 ( ) ; if ( ! TYPE_4 . METHOD_5 ( VAR_3 , VAR_5 ) . isEmpty ( ) ) { return true ; } <START> return false ; <END> } 
public TYPE_3 ( Optional < TYPE_1 > VAR_2 , TYPE_2 VAR_3 , boolean VAR_4 ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; <START> this . VAR_4 = METHOD_1 ( VAR_4 ) ; <END> } 
public void METHOD_1 ( TYPE_1 < T > result ) { try { <START> VAR_1 . METHOD_2 ( METHOD_3 ( result ) ) ; ; <END> } catch ( Exception e ) { log . error ( STRING_1 + result . VAR_2 ( ) , e ) ; } } 
public TYPE_5 ( Optional < TYPE_1 > VAR_2 , TYPE_2 < TYPE_3 > VAR_3 , TYPE_4 VAR_4 ) { METHOD_1 ( ! METHOD_2 ( VAR_2 ) , STRING_1 ) ; METHOD_3 ( VAR_3 ) ; METHOD_3 ( VAR_4 ) ; <START> this . VAR_5 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <START> this . VAR_5 = TYPE_4 . METHOD_1 ( VAR_2 ) ; <END> this . writer = TYPE_4 . METHOD_1 ( VAR_3 ) ; this . VAR_4 = TYPE_4 . METHOD_1 ( VAR_4 ) ; } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <END> return VAR_1 . METHOD_2 ( ) . equals ( VAR_2 . METHOD_2 ( ) ) ; } 
private TYPE_1 METHOD_1 ( ) { try { TYPE_2 context ; <START> context = TYPE_2 . METHOD_2 ( STRING_1 ) ; <END> TYPE_3 VAR_1 = context . VAR_2 ( ) ; TYPE_4 factory = TYPE_4 . METHOD_2 ( ) ; factory . VAR_3 ( true ) ; TYPE_1 reader = factory . VAR_4 ( ) . METHOD_3 ( ) ; reader . VAR_5 ( VAR_1 . METHOD_4 ( ) ) ; VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ; return reader ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) { return false ; } <START> return true ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) != null && ! TYPE_2 . METHOD_3 ( VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ) ) { return true ; } <START> return false ; <END> } 
public void write ( ByteBuffer buffer ) { buffer . VAR_1 ( offset ) ; <START> buffer . VAR_2 ( ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , long VAR_4 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public TYPE_1 METHOD_1 ( Boolean VAR_1 , TYPE_2 VAR_2 ) { <START> VAR_2 . METHOD_2 ( ) . METHOD_3 ( this , VAR_1 ) ; <END> return null ; } 
public TYPE_2 ( ) { this ( ( TYPE_1 ) null ) ; <START> location = null ; <END> } 
<START> public boolean METHOD_1 ( ) { <END> return this . VAR_1 ; } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
<START> public Set < String > METHOD_1 ( ) { <END> Set < String > VAR_1 = VAR_2 . METHOD_1 ( ) ; VAR_1 . addAll ( VAR_3 . METHOD_1 ( ) ) ; VAR_1 . remove ( VAR_4 ) ; return VAR_1 ; } 
public Set < String > METHOD_1 ( ) { Set < String > VAR_1 = VAR_2 . METHOD_1 ( ) ; <START> VAR_1 . remove ( this . getName ( ) ) ; <END> for ( TYPE_1 VAR_3 : VAR_4 ) { VAR_1 . remove ( VAR_3 . getName ( ) ) ; } return VAR_1 ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( this . getClass ( ) != obj . getClass ( ) ) { return false ; } try { TYPE_1 VAR_1 = ( TYPE_1 ) obj ; <START> return this . equals ( VAR_1 ) ; <END> } catch ( TYPE_2 e ) { return false ; } } 
private boolean METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> return VAR_1 . size ( ) <= 0 || VAR_2 >= VAR_1 . size ( ) ; <END> } 
public TYPE_1 < String > METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( ) ; if ( this . VAR_2 == null ) { <START> System . err . println ( STRING_1 ) ; <END> } VAR_1 . VAR_2 = ( TYPE_3 ) this . VAR_2 . METHOD_1 ( ) ; return VAR_1 ; } 
public boolean METHOD_1 ( TYPE_1 response ) { <START> boolean VAR_1 = true ; <END> for ( TYPE_2 VAR_2 : METHOD_2 ( ) ) { VAR_1 = VAR_1 && VAR_2 . METHOD_3 ( response ) ; if ( ! VAR_1 ) break ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; List < String > VAR_2 = new ArrayList < > ( VAR_3 ) ; List < String > VAR_4 = new ArrayList < > ( VAR_5 ) ; List < TYPE_2 > VAR_6 = new ArrayList < > ( VAR_7 ) ; <START> List < TYPE_2 > VAR_8 = new ArrayList < > ( VAR_9 ) ; <END> VAR_1 . VAR_9 = VAR_8 ; VAR_1 . VAR_7 = VAR_6 ; VAR_1 . VAR_3 = VAR_2 ; VAR_1 . VAR_5 = VAR_4 ; return VAR_1 ; } 
private String VAR_1 ( long VAR_2 ) { long VAR_3 = ( VAR_2 < 0 ) ? - VAR_2 : VAR_2 ; int VAR_4 = ( int ) ( ( VAR_3 / ( INT_1 * INT_2 ) ) % INT_2 ) ; int VAR_5 = ( int ) ( ( VAR_3 / ( INT_1 * INT_2 * INT_2 ) ) % INT_3 ) ; <START> return String . format ( STRING_1 , VAR_2 >= 0 ? CHAR_1 : CHAR_2 , VAR_5 , VAR_4 ) <END> } 
public TYPE_8 ( String VAR_2 , TYPE_1 client ) { <START> super ( new TYPE_2 < TYPE_5 . TYPE_7 > ( client , TYPE_5 . TYPE_6 . METHOD_1 ( VAR_2 ) ) ) ; <END> } 
public void METHOD_1 ( ) { <START> assertTrue ( METHOD_2 ( <END> new TYPE_1 ( TYPE_3 . VAR_2 , true , new TYPE_2 ( ) ) . value ( ) , TYPE_3 . VAR_2 ) ) ; METHOD_3 ( METHOD_2 ( new TYPE_1 ( TYPE_3 . VAR_2 , false , new TYPE_2 ( ) ) . value ( ) , TYPE_3 . VAR_2 ) ) ; } 
protected double METHOD_1 ( double VAR_1 ) { <START> return VAR_1 / VAR_2 ; LOG . error ( STRING_1 , TYPE_1 . this . getClass ( ) . METHOD_2 ( ) , ex ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { final String VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_2 == null || VAR_2 . length ( ) == 0 ) { <END> return STRING_1 ; } return null ; } 
private int METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { TYPE_2 VAR_2 ; VAR_3 . METHOD_2 ( ) ; try { VAR_2 = VAR_4 ; } finally { VAR_3 . METHOD_3 ( ) ; } int VAR_5 = 0 ; while ( true ) { VAR_5 += VAR_2 . VAR_6 - VAR_2 . VAR_7 ; if ( VAR_1 != null ) { VAR_1 . METHOD_4 ( VAR_2 ) ; } if ( VAR_2 . VAR_8 == null ) { break ; } <START> VAR_2 = VAR_2 . VAR_8 ; <END> } return VAR_5 ; } 
public void close ( ) throws IOException { VAR_1 . METHOD_1 ( ) . close ( ) ; <START> VAR_1 = null ; <END> } 
<START> public synchronized static TYPE_1 METHOD_1 ( String name ) { <END> if ( VAR_1 == null ) { final TYPE_1 VAR_2 = METHOD_2 ( name ) ; VAR_1 = name ; return VAR_2 ; } throw new IllegalStateException ( STRING_1 ) ; } 
public void add ( Entry entry ) { <START> if ( VAR_1 . size ( ) >= VAR_2 ) { <END> VAR_1 . METHOD_1 ( ) ; } VAR_1 . add ( entry ) ; } 
protected TYPE_6 ( TYPE_3 VAR_3 , String name , TYPE_5 filter , TimeUnit VAR_5 , TimeUnit VAR_6 ) { TYPE_1 VAR_8 = TYPE_4 . VAR_10 ( new TYPE_2 ( name + CHAR_1 + VAR_12 . VAR_13 ( ) ) ) ; <START> this ( VAR_3 , name , filter , VAR_5 , VAR_6 , VAR_8 ) ; <END> } 
private < T > Collection < ? extends TYPE_1 < T > > METHOD_1 ( Collection < ? extends TYPE_1 < T > > VAR_1 ) { <START> List < TYPE_2 < T > > VAR_2 = new ArrayList < TYPE_2 < T > > ( ) ; <END> for ( TYPE_1 < T > task : VAR_1 ) { VAR_2 . add ( new TYPE_2 ( task ) ) ; } return VAR_2 ; } 
public void run ( ) { VAR_1 . METHOD_1 ( ) ; <START> TYPE_1 . Context context = VAR_2 . time ( ) ; <END> try { task . run ( ) ; } finally { context . VAR_3 ( ) ; VAR_1 . METHOD_2 ( ) ; VAR_4 . METHOD_3 ( ) ; } } 
public T call ( ) throws Exception { VAR_1 . METHOD_1 ( ) ; <START> TYPE_1 . Context context = VAR_2 . time ( ) ; <END> try { return VAR_3 . call ( ) ; } finally { context . VAR_4 ( ) ; VAR_1 . METHOD_2 ( ) ; VAR_5 . METHOD_3 ( ) ; } } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> this ( VAR_2 , VAR_3 , VAR_3 . getClass ( ) . getName ( ) ) ; <END> } 
public static TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( METHOD_2 ( VAR_1 ) , TYPE_3 . TYPE_2 . VAR_4 ) ; <END> } 
<START> public void METHOD_1 ( long version ) { <END> TYPE_1 . METHOD_2 ( VAR_1 , version ) ; } 
<START> public TYPE_1 < TYPE_2 < TYPE_3 > > iterator ( ) { <END> return VAR_1 . METHOD_1 ( ( ) - > new TYPE_2 < > ( METHOD_2 ( ) . iterator ( ) , VAR_1 ) ) ; } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; <START> TYPE_2 user = TYPE_4 . TYPE_5 . METHOD_2 ( VAR_1 ) ; <END> config = VAR_2 . METHOD_3 ( user ) . build ( ) ; } 
public void METHOD_1 ( ) throws InterruptedException { final TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; Thread t = new Thread ( ( ) - > { TYPE_2 < TYPE_3 > results = VAR_1 . METHOD_3 ( TYPE_3 . class ) . METHOD_4 ( ) ; assertEquals ( VAR_2 , results . size ( ) ) ; } ) ; t . start ( ) ; t . VAR_3 ( ) ; <START> VAR_1 . close ( ) ; <END> } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> new TYPE_2 ( this , VAR_1 , VAR_2 ) ; } 
<START> public long METHOD_1 ( ) { <END> return table . VAR_1 ( ) ; } 
public int METHOD_1 ( ) { <START> return VAR_1 == null ? 0 : VAR_1 . size ( ) ; <END> } 
private void METHOD_1 ( ) { VAR_1 = METHOD_2 ( R . id . VAR_1 ) ; VAR_1 . METHOD_3 ( new View . TYPE_1 ( ) { @Override <START> public void METHOD_4 ( View v ) { <END> if ( ! VAR_3 . METHOD_5 ( ) ) { VAR_3 . start ( ) ; } else { VAR_3 . METHOD_6 ( ) ; } METHOD_7 ( ) ; } } ) ; } 
private static TYPE_1 METHOD_1 ( String VAR_1 ) throws IOException , TYPE_2 { TYPE_3 stream = new TYPE_4 ( VAR_1 . METHOD_2 ( STRING_1 ) ) ; TYPE_1 VAR_2 = ( TYPE_1 ) TYPE_5 . METHOD_3 ( stream ) ; <START> stream . close ( ) ; <END> return VAR_2 ; } 
public String METHOD_1 ( ) { if ( VAR_1 == null ) { if ( name != null ) { if ( version != null ) { return name + STRING_1 + version ; } else { return name ; } } else { return this . VAR_2 ; <START> } <END> } return this . VAR_1 ; } 
private static boolean METHOD_1 ( final String VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return false ; } <START> if ( VAR_1 . METHOD_2 ( 0 ) == CHAR_1 ) { <END> return false ; } for ( int i = 0 ; i < VAR_1 . length ( ) ; i ++ ) { final char c = VAR_1 . METHOD_2 ( i ) ; if ( c < CHAR_1 || c > CHAR_2 ) { return false ; } } return true ; } 
public Object METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 . getId ( ) : null ; <END> } 
private void METHOD_1 ( ) { try { log . VAR_1 ( STRING_1 , config . VAR_2 ( ) ) ; VAR_3 = ( TYPE_1 ) VAR_4 . METHOD_2 ( config . VAR_2 ( ) ) ; } catch ( RuntimeException e ) { throw log . VAR_5 ( config . VAR_2 ( ) ) ; } <START> this . VAR_4 = null ; <END> } 
private void METHOD_1 ( ) { try { log . VAR_1 ( STRING_1 , configuration . VAR_2 ( ) ) ; TYPE_1 VAR_3 = ( TYPE_1 ) VAR_4 . METHOD_2 ( configuration . VAR_2 ( ) ) ; this . client = new TYPE_2 ( VAR_3 ) ; } catch ( RuntimeException e ) { throw log . VAR_5 ( configuration . VAR_2 ( ) ) ; } <START> this . VAR_4 = null ; <END> } 
public void METHOD_1 ( ) throws Exception { synchronized ( VAR_1 ) { if ( VAR_1 . METHOD_2 ( false , true ) ) { <START> TYPE_1 . METHOD_3 ( ) ; <END> TYPE_2 builder = TYPE_2 . of ( STRING_1 ) ; builder . VAR_2 ( VAR_3 ) ; if ( VAR_4 != 0 ) { builder . VAR_5 ( STRING_2 + VAR_4 ) ; } TYPE_3 VAR_6 = TYPE_3 . of ( builder ) ; VAR_7 = VAR_6 . METHOD_4 ( ) . METHOD_5 ( ) ; METHOD_6 ( ) ; } } } 
public void METHOD_1 ( ) { try { if ( ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) { VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; <START> } <END> TYPE_1 VAR_2 = VAR_1 . METHOD_5 ( TYPE_1 . class , VAR_3 . getName ( ) ) ; if ( VAR_2 != null ) { VAR_1 . remove ( VAR_2 ) ; } VAR_1 . METHOD_2 ( ) . commit ( ) ; } finally { VAR_1 . close ( ) ; } } 
private void METHOD_1 ( ) { if ( VAR_1 == null ) { Class < TYPE_1 < ? > > VAR_2 = VAR_3 . METHOD_2 ( ) ; <START> this . VAR_1 = VAR_2 . METHOD_3 ( ) ; <END> if ( VAR_1 == null ) { throw new TYPE_2 ( STRING_1 ) ; } } } 
public List METHOD_1 ( ) { <START> log . info ( STRING_1 ) ; <END> if ( METHOD_2 ( ) ) { return VAR_1 ; } return null ; } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( METHOD_3 ( ) , METHOD_4 ( ) , METHOD_5 ( ) , METHOD_6 ( ) , METHOD_7 ( ) , METHOD_8 ( ) , METHOD_9 ( ) , METHOD_10 ( ) ) ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 , String VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
private Object METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { Object value = null ; <START> VAR_1 . METHOD_2 ( ) ; <END> if ( VAR_1 . METHOD_3 ( VAR_2 ) ) { value = VAR_1 . getProperty ( VAR_2 ) ; } return value ; } 
public void METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> String [ ] VAR_1 = new String [ ] { STRING_2 , STRING_3 , STRING_4 } ; int VAR_2 = 0 ; int length = 2 ; String [ ] VAR_3 = new String [ ] { STRING_2 , STRING_3 } ; String [ ] result = TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , length ) ; METHOD_3 ( VAR_3 , result ) ; } 
public TYPE_1 METHOD_1 ( ) { return METHOD_2 ( <START> METHOD_3 ( METHOD_4 ( ) , builder . VAR_1 ( TYPE_2 . VAR_3 ) ) , <END> METHOD_3 ( METHOD_5 ( ) , builder . VAR_1 ( TYPE_2 . VAR_4 ) ) ) ; } 
public void METHOD_1 ( TYPE_1 key , TYPE_2 VAR_1 ) { byte [ ] VAR_2 = METHOD_2 ( key ) ; connection . VAR_3 ( VAR_2 ) ; for ( Object row : VAR_1 . METHOD_3 ( ) ) { <START> connection . VAR_4 ( VAR_2 , VAR_5 . METHOD_4 ( row ) ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( this , VAR_1 . METHOD_1 ( ) . METHOD_2 ( TYPE_3 . class ) ) ; <END> } 
public static TYPE_1 < ? , ? , ? > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , Set < TYPE_5 > VAR_4 , <START> Set < TYPE_6 > VAR_5 , <END> Set < TYPE_7 > VAR_6 ) { TYPE_8 VAR_7 = new TYPE_8 ( ) ; TYPE_9 VAR_8 = VAR_1 != null ? new TYPE_9 ( VAR_1 , VAR_4 , VAR_5 , VAR_6 ) : new TYPE_9 ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; return new TYPE_1 < TYPE_10 , TYPE_11 , TYPE_12 > ( VAR_8 , VAR_7 ) ; } 
public void METHOD_1 ( TYPE_1 configuration , TYPE_2 factory ) { TYPE_2 VAR_1 = factory ; TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_4 VAR_3 = ( TYPE_4 ) VAR_2 . METHOD_3 ( TYPE_5 . class ) ; METHOD_4 ( VAR_1 , VAR_3 ) ; METHOD_5 ( VAR_3 . METHOD_6 ( ) , configuration ) ; <START> METHOD_7 ( VAR_1 , VAR_2 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( STRING_1 , TYPE_1 . class ) <END> . METHOD_3 ( ) ; TYPE_2 . assertThat ( VAR_1 . size ( ) ) . METHOD_4 ( 2 ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> ArrayList < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; <END> if ( VAR_2 . size ( ) > 0 ) { for ( TYPE_2 row : VAR_2 ) { VAR_1 . add ( new TYPE_1 ( new TYPE_3 ( row . getValue ( ) . METHOD_2 ( ) ) ) ) ; } } return VAR_1 ; } 
public < R extends TYPE_1 > void METHOD_1 ( TYPE_2 < R > VAR_1 ) { <START> if ( TYPE_3 . class . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) { <END> ( ( TYPE_3 ) VAR_1 . METHOD_3 ( ) ) . start ( configuration , VAR_2 ) ; } else { super . METHOD_1 ( VAR_1 ) ; } } 
public TYPE_2 ( ) { try { Class . VAR_2 ( STRING_1 ) ; } catch ( TYPE_1 e ) { <START> log . VAR_3 ( STRING_1 ) ; <END> } } 
public Object get ( String column ) { TYPE_1 result = VAR_1 . get ( column ) ; if ( result == null ) { return VAR_2 . get ( column ) ; } else if ( result . getType ( ) == VAR_3 || result . getType ( ) == VAR_4 ) { <START> return result ; <END> } else { return result . getValue ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { final Boolean VAR_2 = VAR_1 . VAR_3 . METHOD_2 ( STRING_1 ) ; if ( VAR_2 == null || ! VAR_2 . METHOD_3 ( ) ) { VAR_4 . add ( VAR_1 ) ; } <START> METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; <END> } 
<START> protected final TYPE_1 METHOD_1 ( ) { <END> return METHOD_1 ( this . METHOD_2 ( ) ) ; } 
public TYPE_3 ( TYPE_1 object ) throws TYPE_2 { this . VAR_2 = object . getString ( STRING_1 ) ; <START> this . version = object . VAR_3 ( STRING_2 ) . METHOD_1 ( ) ; <END> } 
protected void METHOD_1 ( TYPE_1 record ) throws TYPE_2 , TYPE_3 , TYPE_4 { TYPE_5 VAR_1 = ( TYPE_5 ) METHOD_2 ( record ) ; <START> METHOD_3 ( VAR_1 ) ; <END> } 
public String read ( TYPE_1 record ) { TYPE_2 VAR_1 = new TYPE_2 ( ) ; TYPE_3 VAR_2 = new TYPE_3 ( ) ; String VAR_3 = record . VAR_4 ( ) . toString ( ) ; String VAR_5 = VAR_1 . read ( record ) ; String client = VAR_2 . read ( record ) ; <START> return VAR_3 + STRING_1 + VAR_5 + STRING_1 + client ; <END> } 
private void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { METHOD_3 ( ) ; return ; } String VAR_2 = VAR_3 . METHOD_4 ( ) . toString ( ) ; TYPE_1 VAR_4 = VAR_5 . METHOD_5 ( VAR_2 ) ; <START> if ( VAR_4 == null ) { <END> VAR_4 = VAR_6 . METHOD_5 ( VAR_2 ) ; } if ( VAR_4 != null ) { METHOD_6 ( VAR_4 ) ; } else { METHOD_3 ( ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 . Builder builder ) { TYPE_1 VAR_2 = METHOD_2 ( TYPE_1 . class ) ; when ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_8 . VAR_4 ) ; when ( VAR_2 . METHOD_5 ( ) ) . METHOD_4 ( VAR_1 ) ; when ( VAR_2 . METHOD_6 ( METHOD_7 ( TYPE_4 . class ) , <START> METHOD_7 ( TYPE_6 . TYPE_7 . VAR_5 . getClass ( ) ) ) ) <END> . METHOD_4 ( builder ) ; return VAR_2 ; } 
public void METHOD_1 ( ) { String VAR_1 = STRING_1 + STRING_2 + STRING_3 ; TYPE_1 result = VAR_2 . METHOD_2 ( VAR_1 ) ; <START> assertEquals ( STRING_4 + <END> STRING_2 + STRING_3 , METHOD_3 ( result ) ) ; } 
public abstract void METHOD_1 ( List < ? extends TYPE_1 > VAR_1 , Set < TYPE_2 > VAR_2 , boolean value ) throws TYPE_3 ; public abstract void METHOD_1 ( Set < TYPE_2 > VAR_2 , boolean value ) throws TYPE_3 ; public abstract String METHOD_2 ( TYPE_1 message ) throws TYPE_3 ; <START> public void METHOD_3 ( List < Long > VAR_3 ) throws TYPE_3 <END> { } 
public synchronized boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_3 ; VAR_3 = VAR_1 ; if ( VAR_1 == TYPE_1 . NONE && VAR_2 != TYPE_1 . NONE ) { return true ; } <START> return VAR_1 != TYPE_1 . NONE && VAR_2 == TYPE_1 . NONE ; <END> } 
<START> TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public Builder METHOD_1 ( String VAR_1 ) { <END> command . VAR_1 = VAR_1 ; return builder ; } 
public void METHOD_1 ( Context context , String VAR_1 ) { <START> TYPE_3 . TYPE_4 . VAR_2 . VAR_3 . TYPE_2 VAR_4 = TYPE_3 . TYPE_4 . VAR_2 . VAR_3 . TYPE_2 . getInstance ( context ) ; <END> VAR_4 . setText ( VAR_1 , VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( true ) ; TYPE_1 server = new TYPE_1 ( ) ; <START> METHOD_3 ( server , "" , STRING_1 ) ; <END> server . VAR_2 ( STRING_2 ) ; server . output ( STRING_3 ) ; server . VAR_3 ( ) ; METHOD_4 ( server , false , 4 ) ; TYPE_2 VAR_4 = METHOD_5 ( server ) ; VAR_4 . METHOD_6 ( ) ; server . VAR_5 ( ) ; server . VAR_6 ( ) ; } 
private void METHOD_1 ( ) { VAR_1 = METHOD_2 ( true ) ; if ( VAR_1 != null ) { METHOD_3 ( true ) ; <START> VAR_1 . METHOD_4 ( VAR_2 ) ; <END> VAR_1 . METHOD_5 ( this ) ; } } 
public void METHOD_1 ( ) { VAR_1 = METHOD_2 ( false ) ; if ( VAR_1 != null ) { VAR_2 = false ; <START> VAR_1 . METHOD_3 ( VAR_3 ) ; <END> METHOD_4 ( true ) ; VAR_1 . METHOD_5 ( this ) ; } } 
private String METHOD_1 ( ) { <START> String builder = STRING_1 + <END> STRING_2 + STRING_3 + STRING_4 + TYPE_1 . VAR_2 + STRING_5 + STRING_4 + TYPE_1 . VAR_3 + STRING_5 + STRING_4 + TYPE_1 . VAR_4 + STRING_5 + STRING_4 + TYPE_1 . VAR_5 + STRING_5 + STRING_4 + TYPE_1 . VAR_6 + STRING_5 + STRING_4 + TYPE_1 . VAR_7 + STRING_5 + STRING_6 + STRING_7 ; return builder ; } 
public int METHOD_1 ( ) { if ( getName ( ) . equalsIgnoreCase ( STRING_1 ) ) { String VAR_1 = new String ( STRING_1 ) ; <START> return VAR_1 . METHOD_1 ( ) ; <END> } return getName ( ) . METHOD_1 ( ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { boolean VAR_2 = METHOD_2 ( ) ; VAR_3 . METHOD_3 ( VAR_1 ? View . VAR_4 : View . VAR_5 ) ; <START> if ( VAR_1 && ! VAR_2 ) { <END> List < TYPE_1 > VAR_6 = METHOD_4 ( ) ; VAR_7 . clear ( ) ; VAR_7 . METHOD_5 ( VAR_6 . METHOD_6 ( new TYPE_1 [ 0 ] ) ) ; } VAR_8 . METHOD_3 ( VAR_1 ? View . VAR_4 : View . VAR_5 ) ; } 
void METHOD_1 ( ) { VAR_1 . METHOD_2 ( true ) ; VAR_1 . METHOD_3 ( true ) ; <START> if ( VAR_2 != null ) METHOD_4 ( VAR_2 ) ; <END> METHOD_5 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 . uri ) ; VAR_2 . METHOD_2 ( VAR_1 . VAR_4 , VAR_1 . VAR_5 ) ; <START> Log . d ( STRING_1 , STRING_2 + VAR_3 . size ( ) ) ; <END> } 
public static void METHOD_1 ( Context context ) { File VAR_1 = context . VAR_2 ( ) ; File VAR_3 = new File ( VAR_1 . getPath ( ) + VAR_4 ) ; if ( VAR_3 . exists ( ) ) { try { TYPE_1 . METHOD_2 ( VAR_3 ) ; } catch ( IOException e ) { TYPE_2 . e ( STRING_1 ) ; <START> e . VAR_5 ( ) ; <END> } } } 
private void METHOD_1 ( ) { try { METHOD_2 ( ) . METHOD_1 ( METHOD_3 ( ) ) ; } catch ( TYPE_1 e ) { <START> TYPE_2 . e ( STRING_1 , e ) ; <END> } } 
public void METHOD_1 ( int VAR_1 ) { VAR_2 = VAR_1 ; for ( int i = VAR_2 ; i <= VAR_1 ; i ++ ) { <START> VAR_3 . METHOD_2 ( i ) ; <END> } } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; VAR_1 . METHOD_3 ( true ) ; <START> VAR_1 . METHOD_4 ( R . VAR_2 . VAR_3 ) ; <END> VAR_1 . METHOD_5 ( true ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return new TYPE_3 ( this . METHOD_2 ( ) ) ; <END> } 
public static boolean METHOD_1 ( Context context ) { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; <START> List < TYPE_2 > VAR_3 = context . VAR_4 ( ) . METHOD_3 ( VAR_1 , 0 ) ; <END> return ! VAR_3 . isEmpty ( ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( TYPE_3 . VAR_3 , STRING_1 ) ; TYPE_1 VAR_4 = new TYPE_1 ( STRING_2 . METHOD_3 ( ) , STRING_3 ) ; VAR_1 . METHOD_4 ( VAR_4 ) ; <START> METHOD_5 ( TYPE_2 . METHOD_6 ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = METHOD_2 ( STRING_1 ) ; try { VAR_1 . METHOD_3 ( false ) ; <START> METHOD_4 ( STRING_2 ) ; <END> } catch ( TYPE_3 e ) { } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; METHOD_3 ( VAR_2 ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; boolean result = VAR_1 . METHOD_5 ( 1 , null ) ; METHOD_6 ( VAR_3 , METHOD_7 ( 1 ) ) . METHOD_8 ( METHOD_9 ( ) ) ; <START> METHOD_10 ( result ) ; <END> } 
public boolean METHOD_1 ( ) { if ( ! VAR_1 ) { return false ; <START> } <END> TYPE_1 VAR_2 = METHOD_2 ( ) ; return VAR_2 . METHOD_3 ( ) || VAR_2 . METHOD_4 ( ) ; } 
private static String METHOD_1 ( ) { <START> if ( TYPE_1 . METHOD_2 ( ) == TYPE_1 . TYPE_2 . VAR_2 ) { <END> return STRING_1 + STRING_2 + STRING_3 + STRING_4 ; } return "" ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 message ) { <START> return new TYPE_1 ( message , null , null , null , null , null , null ) ; <END> } 
TYPE_1 METHOD_1 ( String type , TYPE_2 ... VAR_1 ) throws TYPE_3 { TYPE_4 VAR_2 = new TYPE_4 ( ) ; VAR_2 . METHOD_2 ( type ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { VAR_2 . METHOD_3 ( VAR_3 ) ; } TYPE_1 VAR_4 = new TYPE_1 ( VAR_2 ) ; <START> VAR_5 . add ( VAR_4 ) ; <END> return VAR_4 ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 message = METHOD_2 ( TYPE_1 . class ) ; when ( message . VAR_1 ( METHOD_3 ( Date . VAR_2 ) ) ) . METHOD_4 ( false ) ; <START> when ( message . VAR_3 ( ) ) . METHOD_4 ( VAR_4 + 1 ) ; <END> return message ; } 
public abstract void METHOD_1 ( Date VAR_1 , boolean VAR_2 ) throws TYPE_1 ; public abstract TYPE_2 [ ] METHOD_2 ( TYPE_3 type ) throws TYPE_1 ; <START> public abstract TYPE_2 [ ] METHOD_3 ( ) ; <END> public abstract void METHOD_4 ( TYPE_3 type , TYPE_2 [ ] VAR_3 ) throws TYPE_1 ; public void METHOD_5 ( TYPE_3 type , TYPE_2 VAR_4 ) throws TYPE_1 { METHOD_4 ( type , new TYPE_2 [ ] { VAR_4 } ) ; } 
<START> TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) throws TYPE_3 { <END> this ( VAR_3 ) ; VAR_4 = VAR_2 ; } 
private String METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { List < String > VAR_2 = new ArrayList < String > ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { <START> if ( ! VAR_3 . equals ( TYPE_2 . VAR_4 ) ) <END> VAR_2 . add ( VAR_3 . METHOD_2 ( ) ) ; } return METHOD_3 ( VAR_2 . METHOD_4 ( new String [ VAR_2 . size ( ) ] ) , CHAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_2 . TYPE_3 info = TYPE_2 . METHOD_2 ( STRING_1 ) ; <START> assertEquals ( info . name , STRING_2 ) ; <END> assertEquals ( info . VAR_1 , STRING_3 ) ; assertEquals ( info . VAR_2 , STRING_4 ) ; } 
<START> public boolean equals ( Object o ) { <END> if ( ! ( o instanceof TYPE_1 ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; if ( properties != null ? ! properties . equals ( that . properties ) : that . properties != null ) { return false ; } return super . equals ( o ) ; } 
public TYPE_1 response ( int key , Response response ) { <START> this . METHOD_1 ( String . valueOf ( key ) , response ) ; <END> this . METHOD_2 ( String . valueOf ( key ) , response ) ; return this ; } 
public TYPE_1 METHOD_1 ( Response response ) { <START> this . METHOD_2 ( STRING_1 , response ) ; <END> this . METHOD_3 ( STRING_1 , response ) ; return this ; } 
public void METHOD_1 ( Map < String , Response > VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( this . VAR_2 == null && VAR_1 != null ) { <END> this . VAR_2 = new TYPE_1 ( ) ; for ( String key : VAR_1 . keySet ( ) ) { this . VAR_2 . put ( key , VAR_1 . get ( key ) ) ; } } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( VAR_2 == null && VAR_1 != null ) { <END> VAR_2 = new TYPE_2 < String , Response > ( ) ; for ( String key : this . VAR_1 . keySet ( ) ) { VAR_2 . put ( key , VAR_1 . get ( key ) ) ; } } } 
public static void METHOD_1 ( String [ ] args ) { try { new TYPE_1 ( args ) . METHOD_2 ( ) ; System . VAR_1 ( 0 ) ; } catch ( Throwable t ) { <START> TYPE_2 . stream ( VAR_2 . METHOD_3 ( ) , false ) <END> . filter ( VAR_3 - > VAR_3 . METHOD_4 ( t ) ) . METHOD_5 ( ) . METHOD_6 ( new TYPE_3 ( ) ) . METHOD_7 ( t ) ; System . VAR_1 ( 1 ) ; } } 
public String toString ( ) { <START> return STRING_1 + METHOD_1 ( ) . toString ( ) <END> + STRING_2 + METHOD_2 ( ) + STRING_3 + TYPE_1 . METHOD_3 ( METHOD_4 ( ) ) + STRING_4 + METHOD_5 ( ) + STRING_5 + METHOD_6 ( ) + STRING_6 + METHOD_7 ( ) + STRING_7 + METHOD_8 ( ) + STRING_8 ; } 
public < TYPE_1 > TYPE_2 < TYPE_1 > METHOD_1 ( Type VAR_1 , TYPE_3 ... VAR_2 ) { <START> if ( ! this . getType ( ) . METHOD_2 ( ) . equals ( Object . VAR_3 . getName ( ) ) ) { <END> throw TYPE_4 . LOG . METHOD_3 ( ) ; } return ( TYPE_2 < TYPE_1 > ) METHOD_4 ( VAR_1 , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = TYPE_2 . METHOD_2 ( 1 , new TYPE_3 ( new TYPE_4 ( STRING_1 ) , STRING_2 ) ) ; <END> } return VAR_1 ; } 
public static TYPE_1 < ? > METHOD_1 ( ) { <START> return TYPE_2 . builder ( ) . add ( TYPE_3 . create ( TYPE_4 . class , Utils . VAR_1 ( TYPE_5 . class ) ) <END> . METHOD_2 ( TYPE_6 . class . METHOD_3 ( ) ) ) . build ( ) ; } 
static void METHOD_1 ( ANNOTATION_1 TYPE_1 < ? > VAR_1 ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( new TYPE_1 ( id ) , TYPE_2 . TYPE_4 . VAR_3 ) ; <START> TYPE_3 . LOG . METHOD_4 ( id ) ; <END> } 
public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( STRING_1 ) ; Assert . VAR_2 ( STRING_2 ) ; } catch ( Exception e ) { <START> Assert . assertTrue ( e . getMessage ( ) . contains ( STRING_3 ) ) ; <END> } } 
public void METHOD_1 ( ) { <START> Assert . assertEquals ( METHOD_2 ( TYPE_1 . class ) . getName ( ) , STRING_1 ) ; <END> } 
<START> private static boolean METHOD_1 ( TYPE_1 VAR_1 , Class < ? extends TYPE_2 > VAR_2 ) { <END> final TYPE_3 < ? extends TYPE_2 > model = VAR_1 . METHOD_2 ( ) . get ( TYPE_4 . class ) . METHOD_3 ( VAR_2 ) ; if ( model . VAR_3 ( ) && model . VAR_4 ( ) ) { return true ; } return false ; } 
TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 , TYPE_5 VAR_6 ) { super ( VAR_2 , VAR_3 , VAR_5 ) ; this . VAR_7 = new TYPE_6 ( VAR_2 , VAR_3 , VAR_5 ) ; this . VAR_4 = VAR_4 ; this . VAR_6 = VAR_6 ; this . VAR_8 = METHOD_1 ( ) ; if ( ! VAR_8 ) { <START> TYPE_8 . LOG . METHOD_2 ( ) ; <END> } } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { if ( ! VAR_2 ) { throw new TYPE_2 ( STRING_1 ) ; <START> } <END> return new TYPE_3 ( VAR_1 , index , VAR_3 , VAR_4 ) ; } 
public Set < Type > METHOD_1 ( ) { HashSet < Type > VAR_1 = new HashSet < Type > ( ) ; VAR_1 . add ( TYPE_1 . class ) ; <START> VAR_1 . add ( Object . VAR_2 ) ; <END> return VAR_1 ; } 
public TYPE_1 < T > METHOD_1 ( Set < TYPE_2 > VAR_1 ) { METHOD_2 ( VAR_1 , VAR_2 ) ; <START> Collections . addAll ( this . VAR_1 , VAR_1 . METHOD_3 ( new TYPE_2 [ VAR_1 . size ( ) ] ) ) ; <END> return this ; } 
<START> public void close ( ) throws Exception { <END> METHOD_1 ( ) ; } 
private Map < String , TYPE_1 > METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( ) ; R request = METHOD_4 ( ) ; <START> Object VAR_1 = METHOD_5 ( METHOD_4 ( ) , VAR_2 ) ; <END> if ( VAR_1 == null || ! ( VAR_1 instanceof Map ) ) { throw TYPE_2 . LOG . METHOD_6 ( VAR_2 , VAR_1 , request ) ; } return METHOD_7 ( VAR_1 ) ; } 
public static < T > Class < T > METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) { try { return METHOD_2 ( VAR_2 . METHOD_3 ( VAR_1 ) ) ; } catch ( TYPE_2 e ) { return null ; <START> } catch ( TYPE_3 e ) { <END> return null ; } catch ( TYPE_4 e ) { return null ; } } 
public String [ ] METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
public TYPE_1 ( Type VAR_2 , Type [ ] VAR_3 , Type VAR_4 ) { <START> this . VAR_3 = VAR_3 . METHOD_1 ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; } 
public Type [ ] METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
<START> private boolean METHOD_1 ( final Date VAR_1 ) { <END> if ( VAR_1 != null ) { return System . currentTimeMillis ( ) > VAR_1 . METHOD_2 ( ) ; } else { return false ; } } 
<START> public TYPE_1 METHOD_1 ( Class < ? > type , boolean VAR_1 ) throws TYPE_2 { <END> throw new TYPE_2 ( String . format ( STRING_1 , VAR_1 ? STRING_2 : STRING_3 , VAR_2 . getName ( ) , type . getName ( ) ) ) ; } 
public TYPE_1 < T > METHOD_1 ( String path ) { Assert . VAR_1 ( path , STRING_1 ) ; <START> VAR_2 . add ( new TYPE_2 ( TYPE_3 . VAR_4 , path ) ) ; <END> return new TYPE_1 < T > ( this . id , this . target , this . value , this . VAR_5 , this . VAR_2 ) ; } 
public List < TYPE_1 > apply ( TYPE_2 < String > values ) throws TYPE_3 { ImmutableList . Builder < TYPE_1 > VAR_1 = ImmutableList . builder ( ) ; for ( String value : values ) { try { VAR_1 . add ( TYPE_1 . valueOf ( value ) ) ; } catch ( TYPE_4 VAR_2 ) { <START> throw new TYPE_3 ( value ) ; <END> } } return VAR_1 . build ( ) ; } 
public void METHOD_1 ( T id ) { log . trace ( STRING_1 , Thread . VAR_1 ( ) . getName ( ) , id . toString ( ) ) ; synchronized ( VAR_2 ) { if ( VAR_2 . remove ( id ) ) { log . trace ( STRING_2 , Thread . VAR_1 ( ) . getName ( ) , id . toString ( ) ) ; <START> VAR_3 . update ( - 1 ) ; <END> VAR_2 . METHOD_2 ( ) ; } } } 
<START> protected void METHOD_1 ( TYPE_1 < String > VAR_1 , String column ) { <END> VAR_1 . METHOD_2 ( column ) ; } 
public void write ( ANNOTATION_1 TYPE_1 entity , ANNOTATION_1 TYPE_2 writer , ANNOTATION_1 TYPE_3 VAR_1 ) throws IOException { writer . VAR_2 ( STRING_1 , STRING_1 , <START> entity . VAR_3 ( ) != null ? entity . VAR_3 ( ) : null , <END> VAR_1 ) ; writer . VAR_2 ( STRING_2 , STRING_2 , entity . VAR_4 ( ) != null ? entity . VAR_4 ( ) : null , VAR_1 ) ; } 
public TYPE_1 < TYPE_2 < TYPE_3 > > METHOD_1 ( TYPE_4 < TYPE_5 > VAR_1 , TYPE_6 VAR_2 , Set < TYPE_7 > VAR_3 ) { <START> if ( ! VAR_3 . contains ( TYPE_7 . VAR_4 ) ) { <END> TYPE_1 < TYPE_2 < TYPE_3 > > VAR_5 = VAR_6 . METHOD_1 ( VAR_1 , VAR_2 . METHOD_2 ( ) , VAR_3 ) ; return TYPE_8 . METHOD_3 ( VAR_5 , METHOD_4 ( VAR_2 ) ) ; } else { return VAR_6 . METHOD_5 ( VAR_1 , VAR_2 . METHOD_2 ( ) , VAR_3 ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_2 < TYPE_1 > VAR_3 ) { for ( TYPE_1 VAR_4 : VAR_3 ) { if ( VAR_4 == VAR_2 ) { return false ; } if ( VAR_4 == VAR_1 ) { return true ; } } <START> LOG . warn ( STRING_1 <END> + STRING_2 , VAR_1 , VAR_3 ) ; return false ; } 
<START> public TYPE_9 ( TYPE_1 VAR_2 , String VAR_3 , String VAR_4 , <END> TYPE_2 < TYPE_3 > VAR_5 , TYPE_4 VAR_6 , TYPE_5 < ? super TYPE_3 > VAR_7 , TYPE_6 < TYPE_7 > VAR_8 ) { super ( VAR_6 , VAR_7 , VAR_8 , new TYPE_8 ( ) ) ; this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_5 = METHOD_1 ( VAR_5 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; this . VAR_4 = METHOD_1 ( VAR_4 ) ; } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 ( value = STRING_1 , VAR_1 = false ) String VAR_2 ) { String VAR_3 = null ; <START> try { VAR_3 = VAR_4 . VAR_5 . VAR_6 . VAR_7 . TYPE_2 . toString ( VAR_8 ) ; } catch ( IOException e ) { LOG . error ( STRING_2 , e ) ; } <END> return TYPE_2 . METHOD_2 ( VAR_3 , VAR_2 ) ; } 
public void METHOD_1 ( ) throws IOException { <START> TYPE_1 VAR_1 = TYPE_2 . class . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <END> TYPE_3 VAR_3 = TYPE_4 . METHOD_4 ( ) . read ( VAR_1 , "" , STRING_1 ) ; TYPE_5 outputStream = new TYPE_6 ( ) ; TYPE_2 writer = new TYPE_2 ( outputStream ) ; writer . write ( VAR_3 ) ; Assert . assertNotNull ( outputStream ) ; outputStream . close ( ) ; } 
<START> public long METHOD_1 ( ) { <END> return size ; } 
private String METHOD_1 ( final String value ) { String result = value ; if ( result . equals ( STRING_1 ) ) { result = STRING_2 ; } <START> if ( result . equals ( STRING_3 ) ) { <END> result = STRING_4 ; } return result ; } 
public boolean METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { try { TYPE_3 . METHOD_2 ( VAR_1 ) ; return true ; <START> } catch ( TYPE_4 e ) { <END> return false ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 < String > location = VAR_2 . METHOD_2 ( VAR_3 ) ; if ( location . VAR_4 ( ) && ! VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) { Log . VAR_5 . METHOD_5 ( ) ; <START> } <END> super . METHOD_1 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 < ? > > VAR_1 , long VAR_2 , long VAR_3 , TimeUnit VAR_4 ) { TYPE_4 task = new TYPE_4 ( VAR_1 , VAR_3 , VAR_4 ) ; <START> task . VAR_5 = VAR_6 . METHOD_2 ( task , VAR_2 , VAR_4 ) ; <END> return task ; } 
private TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 ; synchronized ( this ) { VAR_1 = VAR_2 ; } if ( VAR_1 == null ) { return TYPE_3 . METHOD_2 ( ) ; } if ( trace ) { log . VAR_3 ( STRING_1 , VAR_4 ) ; } <START> return VAR_2 . METHOD_3 ( VAR_5 - > METHOD_1 ( ) ) ; <END> } 
public TYPE_1 start ( ) { boolean VAR_1 ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . command ( VAR_3 ) ; try { VAR_4 = VAR_2 . start ( ) ; VAR_1 = METHOD_1 ( this : : METHOD_2 , VAR_5 ) ; if ( ! VAR_1 ) { throw new IllegalStateException ( STRING_1 ) ; } } catch ( Exception e ) { log . error ( e ) ; } <START> log . info ( STRING_2 ) ; <END> return this ; } 
TYPE_2 ( TYPE_1 VAR_2 ) { VAR_2 . METHOD_1 ( ) . forEach ( a - > a . VAR_3 ( ( VAR_4 , VAR_5 ) - > { if ( this . VAR_6 ) { String name = VAR_4 . name ( ) ; Object value = VAR_4 . get ( ) ; <START> VAR_7 . add ( name . VAR_8 ( STRING_1 ) . METHOD_2 ( value == null ? "" : value . toString ( ) ) ) ; <END> } } ) ) ; } 
public void METHOD_1 ( Path target , boolean VAR_1 ) { List < TYPE_1 > VAR_2 = METHOD_2 ( target ) ; <START> if ( VAR_2 . size ( ) == 0 ) { <END> out . println ( TYPE_2 . METHOD_3 ( ) ) ; } else { for ( TYPE_1 VAR_3 : VAR_2 ) { out . println ( TYPE_2 . METHOD_4 ( VAR_3 ) ) ; if ( VAR_1 ) { VAR_3 . METHOD_5 ( ) . forEach ( VAR_4 - > out . println ( STRING_1 + VAR_4 ) ) ; } } } } 
private boolean METHOD_1 ( Class < ? > type ) { <START> return Map . VAR_1 . equals ( type ) || byte [ ] . class . equals ( type ) ; <END> } 
public void METHOD_1 ( Object key , Object value , TYPE_1 < ? > VAR_1 ) { VAR_1 . METHOD_2 ( ( result , exception ) - > { if ( exception != null ) { VAR_2 . METHOD_3 ( value . getClass ( ) , key , exception ) ; } else { VAR_2 . METHOD_4 ( 1 ) ; } } ) . METHOD_5 ( VAR_3 , ( VAR_4 , VAR_5 ) - > null ) ; <START> } <END> 
protected TYPE_1 METHOD_1 ( ) throws Exception { TYPE_2 builder = new TYPE_2 ( ) ; builder . VAR_1 ( ) . METHOD_2 ( ) <START> . METHOD_3 ( TYPE_4 . VAR_3 , TYPE_4 . VAR_4 ) ; <END> return TYPE_3 . METHOD_1 ( builder ) ; } 
public < T , TYPE_1 > TYPE_2 < T , TYPE_1 > METHOD_1 ( TYPE_3 VAR_1 ) { TYPE_2 < T , TYPE_1 > VAR_2 = VAR_3 . METHOD_1 ( VAR_1 ) ; if ( VAR_2 != VAR_3 ) { return METHOD_2 ( VAR_2 ) ; } <START> return ( TYPE_2 ) this ; <END> } 
public static < TYPE_1 , TYPE_2 , TYPE_3 > TYPE_4 < TYPE_5 < TYPE_1 , TYPE_2 > , TYPE_5 < TYPE_1 , TYPE_3 > > METHOD_1 ( TYPE_6 < ? super TYPE_1 , ? super TYPE_2 , TYPE_3 > VAR_1 ) { <START> return new TYPE_7 < TYPE_1 , TYPE_2 , TYPE_3 > ( VAR_1 ) ; <END> } 
<START> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_2 == null ) return false ; return VAR_2 . METHOD_1 ( VAR_3 , VAR_1 ) ; } 
private TYPE_1 < Object , String > filter ( Object VAR_1 ) { return ( TYPE_2 & TYPE_1 < Object , String > ) ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) - > { <START> boolean VAR_8 = TYPE_3 . equals ( VAR_2 , VAR_1 ) ; <END> return VAR_8 ; } ; } 
public void METHOD_1 ( ) { TYPE_1 builder = new TYPE_1 ( ) ; builder . VAR_1 ( TYPE_5 . VAR_3 ) ; TYPE_2 < String , String > cache = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( builder ) . METHOD_4 ( TYPE_4 . VAR_5 ) . create ( ) ; <START> cache . put ( STRING_1 , STRING_2 ) ; <END> assertEquals ( 1 , cache . size ( ) ) ; assertEquals ( STRING_2 , cache . get ( STRING_1 ) ) ; } 
Object METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { Object [ ] VAR_3 ; try { VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) ; } catch ( IOException e ) { throw new TYPE_2 ( STRING_1 , e ) ; } if ( VAR_3 == null ) { Object key = METHOD_4 ( VAR_1 , VAR_2 ) ; <START> return cache . get ( METHOD_5 ( key ) ) ; <END> } return VAR_3 ; } 
public TYPE_2 ( Object key , Object value , TYPE_1 metadata ) { super ( key , value , metadata ) ; <START> this . VAR_2 = metadata ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) throws IOException { VAR_2 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( STRING_1 , VAR_1 . getName ( ) ) ; <START> TYPE_4 < ? extends TYPE_5 > VAR_4 = VAR_1 . METHOD_4 ( ) ; <END> VAR_2 . METHOD_5 ( ) ; } 
public void METHOD_1 ( byte [ ] VAR_1 ) { <START> if ( VAR_2 ) { <END> if ( VAR_1 != null ) { TYPE_1 VAR_3 = TYPE_1 . valueOf ( VAR_1 ) ; if ( trace ) log . VAR_4 ( STRING_1 , VAR_3 ) ; VAR_3 . stream ( ) . forEach ( VAR_5 - > VAR_6 . set ( VAR_5 , null ) ) ; } } } 
public TYPE_1 index ( TYPE_2 index ) { <START> if ( index != TYPE_2 . NONE ) METHOD_1 ( true ) ; <END> VAR_1 . METHOD_2 ( VAR_2 ) . set ( index ) ; return this ; } 
<START> public TYPE_1 ( String key , String value ) { <END> this . key = key ; this . value = value ; } 
public TYPE_1 < Object > METHOD_1 ( TYPE_2 ctx , TYPE_3 command ) { try { <START> command . VAR_1 ( VAR_2 ) ; <END> Object result = VAR_3 . METHOD_2 ( ctx , command ) ; if ( result instanceof TYPE_4 ) { return ( ( TYPE_4 ) result ) . METHOD_3 ( ) ; } else { if ( result == null ) { return TYPE_5 . METHOD_4 ( ) ; } return TYPE_1 . METHOD_5 ( result ) ; } } catch ( Throwable t ) { return TYPE_5 . METHOD_6 ( t ) ; } } 
public boolean METHOD_1 ( ) { if ( VAR_1 == null || VAR_1 . length == 0 ) { return false ; } boolean VAR_2 = true ; for ( TYPE_1 VAR_3 : VAR_1 ) { if ( ! VAR_3 . METHOD_2 ( TYPE_2 . VAR_5 ) ) { <START> VAR_2 = false ; <END> break ; } } return VAR_2 ; } 
TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( boolean VAR_1 ) { <START> return VAR_1 ? VAR_2 ? cache : cache . VAR_3 ( TYPE_4 . VAR_5 ) : cache . VAR_3 ( TYPE_4 . VAR_6 ) ; <END> } 
final TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 key , TYPE_4 value , Long VAR_1 , long VAR_2 ) { <START> long VAR_3 = VAR_2 | TYPE_6 . VAR_5 | TYPE_6 . VAR_6 | TYPE_6 . VAR_7 ; <END> TYPE_5 command = VAR_8 . METHOD_2 ( key , value , VAR_9 . METHOD_3 ( key ) , VAR_1 , VAR_3 ) ; TYPE_1 < Boolean > VAR_10 = METHOD_4 ( command ) ; return VAR_10 . METHOD_5 ( b - > null ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_2 ) { VAR_1 . println ( VAR_1 . METHOD_2 ( ) ) ; } TYPE_3 cmd = new TYPE_3 ( TYPE_5 . VAR_4 ) . METHOD_3 ( VAR_5 , TYPE_5 . TYPE_4 . VAR_4 ) . METHOD_3 ( VAR_7 , VAR_8 ) <START> . METHOD_3 ( VAR_9 , parameters != null ? parameters : Collections . VAR_10 ( ) ) ; <END> return VAR_1 . execute ( cmd ) ; } 
public String METHOD_1 ( ) throws IOException { <START> return VAR_1 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 = VAR_1 . METHOD_2 ( TYPE_3 . class ) ; TYPE_4 VAR_4 = new TYPE_4 ( ) ; <START> VAR_3 . METHOD_3 ( TYPE_4 . class , VAR_4 , true ) ; <END> if ( VAR_2 . METHOD_4 ( ) ) { try { TYPE_5 VAR_5 = VAR_3 . METHOD_2 ( TYPE_5 . class ) . METHOD_5 ( ) ; VAR_5 . METHOD_6 ( VAR_4 ) ; } catch ( Exception e ) { log . VAR_6 ( ) ; } } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> for ( TYPE_3 . TYPE_4 VAR_2 = VAR_3 . iterator ( ) ; VAR_2 . hasNext ( ) ; ) { int VAR_4 = VAR_2 . METHOD_2 ( ) ; if ( ! VAR_1 . METHOD_3 ( VAR_4 ) ) { if ( trace ) { log . VAR_5 ( STRING_1 , this , VAR_4 ) ; } VAR_2 . remove ( ) ; } } } 
<START> public void METHOD_1 ( ) { <END> TYPE_1 . METHOD_2 ( VAR_1 ) ; } 
protected void METHOD_1 ( TYPE_1 builder ) { <START> builder . VAR_1 ( ) . METHOD_2 ( 2 ) . METHOD_3 ( INT_1 ) . METHOD_4 ( 2 ) ; <END> } 
public void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; } <START> if ( VAR_2 . METHOD_2 ( VAR_3 ) . get ( ) && ( VAR_1 == null || VAR_1 . METHOD_3 ( ) ) ) { <END> table . VAR_4 ( ) ; } super . METHOD_1 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_2 ) { VAR_1 . println ( VAR_1 . METHOD_2 ( ) ) ; } TYPE_3 cmd = new TYPE_3 ( TYPE_4 . VAR_4 ) . METHOD_3 ( VAR_5 , TYPE_4 . TYPE_5 . VAR_4 ) ; <START> return VAR_1 . execute ( Collections . VAR_7 ( cmd ) ) ; <END> } 
public Collection < String > METHOD_1 ( String container ) throws IOException { <START> List < String > VAR_1 = ( List < String > ) METHOD_2 ( METHOD_3 ( ( ) - > client . VAR_2 ( container ) . info ( ) ) , Map . VAR_3 ) . get ( STRING_1 ) ; <END> return VAR_1 ; } 
<START> public HashSet < TYPE_1 > METHOD_1 ( ) { <END> return new HashSet < > ( values ) ; } 
private void update ( TYPE_1 type , TYPE_2 < TYPE_3 > VAR_1 ) { if ( type == VAR_2 ) { synchronized ( VAR_3 ) { VAR_1 . METHOD_1 ( VAR_3 ) ; } <START> return ; <END> } synchronized ( VAR_4 ) { VAR_1 . METHOD_1 ( VAR_4 ) ; } } 
public TYPE_1 METHOD_1 ( String name , Integer value ) { if ( value != null ) { <START> this . options . put ( name , Integer . valueOf ( value ) ) ; <END> } return this ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( Arrays . asList ( new TYPE_2 ( STRING_1 , VAR_2 ) ) ) ; <START> VAR_1 . METHOD_3 ( TYPE_3 . class . getName ( ) ) ; <END> VAR_1 . METHOD_4 ( TYPE_4 . VAR_4 + STRING_2 ) ; return VAR_1 ; } 
protected String METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) { if ( VAR_1 . VAR_2 == null ) { VAR_1 . VAR_2 = VAR_2 ; } VAR_1 . METHOD_3 ( ) ; } return VAR_1 . VAR_3 ; <START> } <END> 
<START> protected void METHOD_1 ( ) { <END> METHOD_2 ( ( ) - > METHOD_3 ( ) . METHOD_4 ( ) . isEmpty ( ) , INT_1 , TimeUnit . VAR_1 ) ; } 
public TYPE_4 ( TYPE_1 ctx , TYPE_2 VAR_2 ) { super ( VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 ) ; this . ctx = ctx ; this . VAR_9 = new TYPE_3 ( ctx ) ; this . VAR_2 = VAR_2 ; <START> } <END> 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( ) ; <START> this . VAR_2 = VAR_2 == null ? getClass ( ) . METHOD_1 ( ) : VAR_2 ; <END> VAR_4 . METHOD_2 ( VAR_3 == null ? new TYPE_3 ( VAR_2 ) : new TYPE_4 ( VAR_3 , VAR_2 ) ) ; } 
public TYPE_1 ( int VAR_2 ) { int VAR_3 = VAR_2 - 1 ; <START> if ( VAR_2 <= 0 && ( VAR_2 & VAR_3 ) == 0 ) { <END> throw new IllegalArgumentException ( STRING_1 + VAR_2 + STRING_2 ) ; } this . VAR_3 = VAR_3 ; } 
void METHOD_1 ( long VAR_1 ) { if ( trace ) { <START> Long VAR_2 = VAR_3 . remove ( VAR_1 ) ; <END> if ( VAR_2 == null ) { throw new IllegalArgumentException ( ) ; } } TYPE_1 . METHOD_2 ( VAR_1 ) ; } 
public synchronized void METHOD_1 ( long VAR_1 ) { if ( ! VAR_2 ) { if ( trace ) { <START> log . trace ( STRING_1 ) ; <END> } VAR_2 = true ; VAR_3 = VAR_1 ; } VAR_4 ++ ; if ( trace ) { log . VAR_5 ( STRING_2 , VAR_4 ) ; } } 
public TYPE_1 < ? > METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 , boolean VAR_3 , Collection < TYPE_3 > VAR_4 ) { VAR_5 . METHOD_2 ( ) ; try { assertTrue ( VAR_6 . METHOD_3 ( 10 , TimeUnit . VAR_7 ) ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } super . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; <START> return null ; <END> } 
public TYPE_1 < ? > METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 , boolean VAR_3 , Collection < TYPE_3 > VAR_4 ) { VAR_5 . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; <START> return null ; <END> } 
static void METHOD_1 ( TYPE_1 list ) { list . VAR_1 ( TYPE_10 . TYPE_11 . class , TYPE_10 . TYPE_12 . class , TYPE_4 . class , TYPE_6 . TYPE_13 . class , TYPE_6 . Status . class ) ; <START> list . VAR_1 ( TYPE_7 . class , TYPE_8 . class , Object . VAR_2 , Object [ ] . class , TYPE_9 . VAR_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 channel ) { assert VAR_1 == null ; <START> this . VAR_1 = channel . VAR_2 ( ) . METHOD_2 ( new TYPE_2 ( channel ) , VAR_3 . METHOD_3 ( ) , TimeUnit . VAR_4 ) ; <END> } 
public void METHOD_1 ( TYPE_1 e ) { <START> VAR_1 . add ( e ) ; <END> System . out . println ( STRING_1 + e ) ; } 
<START> TYPE_2 ( long VAR_2 , long VAR_3 , TYPE_1 version ) { <END> super ( VAR_3 , version ) ; this . VAR_2 = VAR_2 ; } 
public String toString ( ) { return STRING_1 + <START> STRING_2 + version ( ) + <END> STRING_3 + VAR_1 + CHAR_1 ; } 
public < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_4 < TYPE_1 , TYPE_2 > > METHOD_1 ( String name , TYPE_5 config ) { return TYPE_6 . METHOD_2 ( ( ) - > { METHOD_3 ( config ) ; TYPE_7 < TYPE_1 , TYPE_2 > cache = VAR_1 . METHOD_4 ( name , false ) ; TYPE_7 < TYPE_1 , TYPE_2 > VAR_2 = VAR_1 . METHOD_4 ( name , true ) ; <START> return new TYPE_8 ( cache , VAR_2 ) ; <END> } , VAR_3 ) ; } 
public TYPE_2 ( TYPE_1 [ ] VAR_2 ) { List < TYPE_1 > VAR_3 = Arrays . asList ( VAR_2 ) ; <START> VAR_4 = VAR_3 . contains ( TYPE_1 . VAR_5 ) ? true : false ; <END> VAR_6 = VAR_3 . contains ( TYPE_1 . VAR_7 ) ? true : false ; VAR_8 = VAR_3 . contains ( TYPE_1 . VAR_9 ) ? true : false ; } 
public void METHOD_1 ( TYPE_1 < ? super TYPE_2 < TYPE_3 , TYPE_4 > > VAR_1 ) { VAR_2 . add ( VAR_1 ) ; METHOD_2 ( ) ; VAR_3 . METHOD_1 ( VAR_1 ) ; <START> VAR_3 . METHOD_3 ( e - > { <END> log . error ( e ) ; VAR_4 . METHOD_4 ( VAR_5 ) ; } ) . METHOD_5 ( ( ) - > VAR_4 . METHOD_4 ( VAR_5 ) ) ; } 
<START> public void METHOD_1 ( byte [ ] VAR_1 ) { <END> this . VAR_1 = VAR_1 ; this . VAR_2 = Arrays . VAR_3 ( VAR_1 ) ; } 
Set < String > METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; try { return VAR_2 ; } finally { <START> VAR_1 . METHOD_3 ( ) ; <END> } } 
public void METHOD_1 ( ) { VAR_1 = TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) ; assertEquals ( VAR_1 . METHOD_4 ( ) . size ( ) , 0 ) ; <START> TYPE_2 . METHOD_5 ( VAR_1 , new TYPE_3 ( ) ) ; <END> VAR_2 = TYPE_4 . METHOD_6 ( VAR_1 , INT_1 ) ; } 
public void METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = server ( ) . METHOD_2 ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { VAR_2 . METHOD_3 ( null , null , null , 10 , false ) ; <START> } <END> VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ; assertEquals ( 0 , VAR_1 . METHOD_6 ( ) ) ; } 
default TYPE_3 < TYPE_2 < VAR_3 , VAR_4 > > VAR_5 ( TYPE_1 VAR_7 , TYPE_4 < ? super VAR_3 > filter , boolean VAR_9 , boolean VAR_10 ) { <START> return null ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , Response response ) { if ( response . VAR_2 ( ) ) { return ( TYPE_1 ) response ; } if ( response instanceof TYPE_3 ) { throw TYPE_4 . METHOD_2 ( VAR_1 , ( ( TYPE_3 ) response ) . METHOD_3 ( ) ) ; } if ( response instanceof TYPE_5 ) { <START> VAR_3 = true ; <END> return null ; } else if ( response instanceof TYPE_6 ) { VAR_4 = true ; return null ; } throw TYPE_4 . METHOD_4 ( response ) ; } 
public static String METHOD_1 ( String path , String VAR_1 ) { if ( new File ( path ) . METHOD_2 ( ) ) { return path ; } else if ( VAR_1 != null ) { return new File ( new File ( VAR_1 ) , path ) . METHOD_3 ( ) ; } else { return path ; } <START> } <END> 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) . map ( TYPE_2 : : get ) . METHOD_3 ( null ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { if ( VAR_1 != this . VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( TYPE_4 . class ) ) { <END> return VAR_2 . METHOD_3 ( VAR_1 , true ) . METHOD_4 ( VAR_3 - > { METHOD_5 ( VAR_1 ) ; return VAR_2 . METHOD_3 ( VAR_1 , false ) ; } ) ; } else { return METHOD_5 ( VAR_1 ) ; } } else { return TYPE_5 . METHOD_6 ( ) ; } } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws Exception { <START> if ( VAR_1 != null && VAR_2 . METHOD_2 ( VAR_1 ) ) { <END> TYPE_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; log . VAR_3 ( STRING_1 , VAR_1 ) ; } } 
public int getStatus ( ) { <START> return response . getStatus ( ) . METHOD_1 ( ) ; <END> } 
private String METHOD_1 ( TYPE_1 VAR_1 , String name ) { List < String > values = VAR_1 . parameters ( ) . get ( name ) ; if ( values == null ) return null ; <START> return values . iterator ( ) . next ( ) ; <END> } 
<START> public Class < ? extends TYPE_1 > METHOD_1 ( ) { <END> return TYPE_1 . class ; } 
public void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { this . VAR_1 = VAR_1 . METHOD_2 ( new TYPE_1 [ VAR_1 . size ( ) ] ) ; if ( index >= this . VAR_1 . length ) { <START> index = TYPE_2 . METHOD_3 ( ) . METHOD_4 ( this . VAR_1 . length ) ; <END> } if ( trace ) { log . VAR_2 ( STRING_1 + Arrays . toString ( this . VAR_1 ) ) ; } } 
public TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( TYPE_2 key , TYPE_1 < TYPE_2 , TYPE_3 > ... VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( ) ) { <END> TYPE_4 VAR_3 = METHOD_3 ( VAR_4 ) ; assertEquals ( key , VAR_3 . key ) ; } METHOD_4 ( ) ; return this ; } 
public boolean METHOD_1 ( ) { <START> boolean VAR_1 = status == VAR_2 <END> || status == VAR_3 || status == VAR_4 ; boolean VAR_5 = VAR_6 != null && VAR_6 . METHOD_2 ( TYPE_1 . VAR_8 ) ; return VAR_1 || VAR_5 ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_2 ( ) ; VAR_3 . METHOD_2 ( ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { try { VAR_1 . run ( ) ; METHOD_2 ( ) ; } catch ( Exception e ) { TYPE_2 . METHOD_3 ( TYPE_3 . class , e ) ; <START> assertEquals ( VAR_2 , ( ( TYPE_3 ) e ) . VAR_2 ) ; <END> } } 
public Builder < ? > read ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 . METHOD_1 ( ) ; VAR_3 = VAR_1 . METHOD_2 ( ) ; TYPE_2 VAR_4 = VAR_1 . METHOD_3 ( ) ; <START> VAR_5 = VAR_4 ; <END> return this ; } 
public TYPE_2 ( ) { this . VAR_2 = 2 ; this . VAR_3 = ( VAR_4 , VAR_5 ) - > { <START> TYPE_1 entry = VAR_4 != null ? VAR_4 : ( TYPE_1 ) VAR_5 . get ( 0 ) ; <END> entry . VAR_6 ( VAR_7 ) ; return entry ; } ; } 
public static TYPE_1 of ( int VAR_1 ) { <START> TYPE_1 set = new TYPE_1 ( 1 ) ; <END> set . set ( VAR_1 ) ; return set ; } 
private static void METHOD_1 ( Iterator < ? > VAR_1 ) { <START> if ( VAR_1 != null && VAR_1 instanceof TYPE_1 ) { <END> ( ( TYPE_1 ) VAR_1 ) . close ( ) ; } } 
private int METHOD_1 ( Object key ) { if ( VAR_1 . METHOD_2 ( ) ) { return VAR_2 . METHOD_1 ( key ) ; } <START> return 0 ; <END> } 
public TYPE_1 get ( Object key ) { METHOD_1 ( key ) ; <START> METHOD_2 ( cache , VAR_1 ) ; <END> TYPE_2 < TYPE_3 , TYPE_1 > VAR_2 = METHOD_3 ( ) . get ( key ) ; if ( VAR_2 != null ) { return VAR_2 . getValue ( ) ; } return null ; } 
protected void METHOD_1 ( TYPE_1 output , TYPE_2 command ) throws IOException { command . VAR_1 ( output ) ; if ( command instanceof TYPE_3 ) { output . VAR_2 ( ( ( TYPE_3 ) command ) . METHOD_2 ( ) ) ; } if ( command instanceof TYPE_4 ) { <START> TYPE_5 . METHOD_3 ( output , ( ( TYPE_4 ) command ) . METHOD_4 ( ) ) ; <END> } } 
public TYPE_7 ( ) { this . VAR_2 = new TYPE_1 < > ( Thread . VAR_3 ( ) . METHOD_1 ( ) ) ; this . VAR_4 = new TYPE_2 ( this ) ; this . VAR_5 = new TYPE_3 ( this ) ; this . VAR_6 = new TYPE_4 ( this ) ; this . VAR_7 = new TYPE_5 ( this ) ; <START> VAR_8 = new TYPE_6 ( this ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> if ( trace ) { log . VAR_1 ( STRING_1 , VAR_2 . METHOD_2 ( ) ) ; } VAR_3 = false ; for ( TYPE_1 cache : VAR_4 . values ( ) ) { cache . VAR_5 ( ) . METHOD_3 ( ) ; } VAR_6 . METHOD_4 ( ) ; VAR_7 . METHOD_5 ( VAR_8 ) ; } 
void METHOD_1 ( TYPE_1 target , TYPE_2 command , long VAR_1 , TYPE_3 VAR_2 , boolean VAR_3 , boolean VAR_4 , boolean VAR_5 ) { TYPE_4 message = new TYPE_4 ( METHOD_2 ( target ) ) ; METHOD_3 ( message , command , VAR_1 ) ; METHOD_4 ( message , VAR_2 , VAR_3 , VAR_4 ) ; <START> if ( VAR_5 && ! VAR_6 . contains ( target ) ) <END> return ; METHOD_5 ( message ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 > VAR_2 ) { VAR_3 = new TYPE_3 ( VAR_3 . METHOD_2 ( ) + 1 , VAR_3 . METHOD_3 ( ) + 1 , <START> VAR_1 , VAR_1 , VAR_1 , <END> TYPE_3 . TYPE_4 . VAR_5 , VAR_2 , METHOD_4 ( VAR_2 ) ) ; } 
synchronized void METHOD_1 ( ) { List < Map < TYPE_1 , TYPE_2 < TYPE_3 , TYPE_4 > > > VAR_1 = VAR_2 . entrySet ( ) . stream ( ) . map ( Map . Entry : : getValue ) <START> . collect ( Collectors . VAR_3 ( ) ) ; <END> clear ( ) ; VAR_4 . METHOD_2 ( Collections . VAR_5 ( VAR_1 ) ) ; } 
public TYPE_1 ( String name ) { this . name = name ; <START> this . VAR_2 = this : : METHOD_1 ; <END> this . VAR_3 = this : : METHOD_2 ; } 
public void METHOD_1 ( TYPE_1 event ) { try { VAR_1 . put ( event ) ; <START> log . VAR_2 ( STRING_1 , name , event ) ; <END> } catch ( InterruptedException e ) { log . VAR_3 ( e , STRING_2 , name , event ) ; } } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; return TYPE_2 . equals ( VAR_1 , that . VAR_1 ) && TYPE_2 . equals ( VAR_2 , that . VAR_2 ) && TYPE_2 . equals ( VAR_3 , that . VAR_3 ) && <START> VAR_4 == that . VAR_4 ; <END> } 
public boolean METHOD_1 ( int size ) { <START> return buffer . VAR_1 ( ) ; <END> } 
public Integer METHOD_1 ( ) { <START> return Integer . valueOf ( VAR_1 . size ( ) ) ; <END> } 
<START> public TYPE_2 ( boolean VAR_2 , boolean VAR_3 , Map < String , TYPE_1 > VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
static TYPE_1 METHOD_1 ( final TYPE_2 < ? , ? > cache ) { TYPE_3 action = new TYPE_3 ( cache ) ; <START> return METHOD_2 ( action ) ; <END> } 
void METHOD_1 ( String message , String VAR_1 ) { if ( VAR_2 ) { METHOD_1 ( VAR_1 + message + VAR_3 ) ; } else <START> METHOD_1 ( message ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { <START> this . VAR_1 = VAR_1 ; <END> this . VAR_2 . METHOD_2 ( VAR_1 ) ; return super . METHOD_1 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 < ? , ? > cache , TYPE_3 VAR_1 , TYPE_4 VAR_2 , int VAR_3 ) { <START> TYPE_1 command = null ; <END> command = METHOD_2 ( ) ; command . VAR_4 ( cache , VAR_1 , VAR_2 , VAR_3 ) ; return command ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> this . VAR_1 = VAR_1 ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 == null ) return NONE ; for ( TYPE_1 VAR_2 : TYPE_1 . values ( ) ) <START> if ( VAR_2 . VAR_3 != null && TYPE_3 . equals ( VAR_2 . VAR_3 . getClass ( ) , VAR_1 . getClass ( ) ) ) <END> return VAR_2 ; return VAR_4 ; } 
private boolean METHOD_1 ( TYPE_1 config , TYPE_2 VAR_1 ) { if ( config == null || VAR_1 . METHOD_2 ( ) || VAR_1 . METHOD_3 ( ) ) return false ; TYPE_3 VAR_2 = config . VAR_3 ( ) ; <START> return VAR_2 . METHOD_4 ( ) . METHOD_1 ( ) && VAR_2 . METHOD_5 ( ) . METHOD_6 ( ) > 1 ; <END> } 
protected Object [ ] METHOD_1 ( ) { <START> String VAR_1 = String . format ( STRING_1 , Arrays . toString ( VAR_2 . METHOD_2 ( ) ) , Arrays . toString ( VAR_3 . METHOD_2 ( ) ) ) ; <END> return METHOD_3 ( super . METHOD_1 ( ) , VAR_1 ) ; } 
public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> return ( VAR_1 instanceof TYPE_2 && VAR_1 != TYPE_2 . NONE ) || VAR_1 != null ; <END> } 
void METHOD_1 ( ) { if ( trace ) log . VAR_1 ( STRING_1 , VAR_2 ) ; <START> if ( METHOD_2 ( ) ) <END> VAR_3 . METHOD_3 ( true ) ; } 
public void METHOD_1 ( TYPE_1 input ) throws IOException , TYPE_2 { VAR_1 = ( TYPE_3 ) input . VAR_2 ( ) ; if ( VAR_1 != null ) { id = input . VAR_3 ( ) ; } VAR_4 = input . VAR_5 ( ) ; VAR_6 = TYPE_4 . METHOD_2 ( input , ArrayList : : new ) ; <START> if ( VAR_6 == null ) { <END> VAR_7 = TYPE_4 . METHOD_3 ( input , TYPE_5 : : new ) ; } } 
protected TYPE_1 < ? > METHOD_1 ( TYPE_2 command , TYPE_3 VAR_1 , TYPE_1 < ? > VAR_2 ) { TYPE_1 < ? > VAR_3 = METHOD_2 ( command . getKey ( ) , VAR_1 , command . VAR_4 ( ) ) ; <START> return VAR_3 == null ? VAR_2 : TYPE_1 . METHOD_3 ( VAR_2 , VAR_3 ) ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <START> throws TYPE_3 { <END> final TYPE_4 VAR_2 = METHOD_2 ( VAR_1 . METHOD_3 ( VAR_3 ) ) ; final TYPE_1 VAR_4 = VAR_2 . METHOD_4 ( VAR_2 . size ( ) - 1 ) ; return VAR_4 ; } 
public void METHOD_1 ( TYPE_1 context ) { TYPE_2 container = this . VAR_1 . METHOD_2 ( ) ; TYPE_3 VAR_2 = TYPE_4 . METHOD_3 ( container ) ; <START> VAR_2 . remove ( VAR_3 ) ; <END> } 
public TYPE_4 ( int VAR_2 , long VAR_3 , TYPE_1 type ) { super ( VAR_2 ) ; this . VAR_3 = VAR_3 ; if ( type == TYPE_1 . VAR_4 ) { VAR_5 = i - > 1 ; } else { <START> VAR_5 = i - > VAR_6 . METHOD_1 ( i ) + TYPE_2 . METHOD_1 ( ) ; <END> } this . VAR_7 = new TYPE_3 ( ) ; VAR_8 = 0 ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 , TYPE_3 > event ) { String VAR_1 = event . getKey ( ) . getName ( ) ; <START> VAR_2 . log . METHOD_2 ( STRING_1 , VAR_1 ) ; <END> VAR_2 . METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( String VAR_1 ) { VAR_2 . METHOD_2 ( TYPE_2 . VAR_4 ) ; <START> if ( VAR_5 != null ) <END> VAR_5 . METHOD_1 ( VAR_1 ) ; else { TYPE_1 . METHOD_1 ( this , VAR_1 ) ; } } 
protected void METHOD_1 ( long VAR_1 , long VAR_2 ) { long VAR_3 = VAR_4 . METHOD_2 ( VAR_2 ) ; long VAR_5 = VAR_4 . METHOD_2 ( VAR_1 ) ; VAR_6 . METHOD_3 ( ) ; try { if ( trace ) { <START> log . VAR_7 ( STRING_1 , VAR_2 , <END> VAR_1 ) ; } METHOD_4 ( VAR_2 ) ; METHOD_5 ( VAR_1 ) ; VAR_8 += VAR_5 ; VAR_8 -= VAR_3 ; super . METHOD_1 ( VAR_1 , VAR_2 ) ; } finally { VAR_6 . METHOD_6 ( ) ; } } 
public void METHOD_1 ( TYPE_1 input ) throws IOException , TYPE_2 { super . METHOD_1 ( input ) ; VAR_1 = input . VAR_2 ( ) ; VAR_3 = input . VAR_2 ( ) ; <START> VAR_4 = TYPE_3 . METHOD_2 ( input , TYPE_4 : : METHOD_3 ) ; <END> } 
public void METHOD_1 ( TYPE_1 input ) throws IOException , TYPE_2 { VAR_1 = input . VAR_2 ( ) ; <START> VAR_3 = TYPE_3 . METHOD_2 ( input , TYPE_4 : : METHOD_3 ) ; <END> } 
<START> protected < TYPE_1 > TYPE_2 < TYPE_1 > METHOD_1 ( final TYPE_3 < ? , ? > cache , final TYPE_4 VAR_1 ) { <END> return TYPE_5 . METHOD_2 ( VAR_1 , TYPE_2 . class , cache , ( VAR_2 , m ) - > VAR_2 . when ( m ) . METHOD_3 ( METHOD_4 ( ) , METHOD_4 ( ) , METHOD_4 ( ) , METHOD_4 ( ) , METHOD_4 ( ) , METHOD_5 ( ) , METHOD_4 ( ) , METHOD_6 ( ) ) ) ; } 
<START> private static < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_1 , TYPE_2 > METHOD_1 ( final TYPE_4 VAR_1 , <END> TYPE_5 < TYPE_1 , TYPE_2 > cache ) { return TYPE_6 . METHOD_2 ( VAR_1 , TYPE_3 . class , cache , ( VAR_2 , m ) - > VAR_2 . when ( m ) . METHOD_3 ( METHOD_4 ( TYPE_7 . VAR_4 ) , METHOD_4 ( false ) ) ) ; } 
public final Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { METHOD_2 ( ctx , command ) ; <START> if ( ctx . VAR_1 ( command . getKey ( ) ) != null && ctx . VAR_1 ( command . getKey ( ) ) . METHOD_3 ( ) instanceof TYPE_3 ) { <END> log . VAR_2 ( STRING_1 ) ; } return METHOD_4 ( ctx , command ) ; } 
protected void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> if ( ! METHOD_2 ( VAR_1 [ 0 ] ) && ! METHOD_2 ( VAR_1 [ 1 ] ) ) <END> throw new TYPE_2 ( String . format ( STRING_1 , Arrays . toString ( VAR_1 ) ) ) ; } 
public void METHOD_1 ( ) { <START> for ( TYPE_1 < Object , String > c : VAR_1 ) assert c . isEmpty ( ) ; <END> Object VAR_2 = METHOD_2 ( STRING_1 ) . put ( STRING_1 , STRING_2 ) ; METHOD_3 ( STRING_1 , TYPE_2 . class ) ; if ( VAR_3 ) assert VAR_2 == null ; VAR_2 = METHOD_4 ( STRING_1 ) [ 0 ] . remove ( STRING_1 ) ; METHOD_3 ( STRING_1 , TYPE_3 . class ) ; if ( VAR_3 ) assert STRING_2 . equals ( VAR_2 ) ; METHOD_5 ( STRING_1 ) ; } 
public Integer METHOD_1 ( TYPE_1 ctx ) throws Throwable { <START> long size = cache . VAR_1 ( ) . METHOD_2 ( TYPE_2 . class ) . keySet ( ) . stream ( ) . count ( ) ; <END> if ( size > Integer . VAR_2 ) { return Integer . VAR_2 ; } else { return ( int ) size ; } } 
public TYPE_7 ( TYPE_1 < Object , ? > cache , long VAR_2 ) { METHOD_1 ( VAR_2 ) ; TYPE_2 < Object , ? > VAR_3 = cache . VAR_4 ( ) ; if ( VAR_2 != TYPE_3 . VAR_5 ) { VAR_3 = VAR_3 . METHOD_2 ( TYPE_3 . METHOD_3 ( VAR_2 , TYPE_4 . class ) ) ; } this . cache = VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) == TYPE_6 . VAR_7 ? <START> VAR_3 : VAR_3 . METHOD_7 ( TYPE_5 . class ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 < ? , ? > VAR_2 = VAR_1 . VAR_2 ; <START> TYPE_3 VAR_3 = new TYPE_3 ( <END> VAR_4 , VAR_2 . getName ( ) , VAR_1 . VAR_5 , VAR_6 , VAR_7 , VAR_8 , configuration ) ; VAR_2 . METHOD_2 ( VAR_9 , VAR_8 , VAR_3 , configuration . VAR_10 ( ) , configuration . VAR_11 ( ) , configuration . VAR_12 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 != null ) { VAR_1 . METHOD_2 ( this ) ; } <START> if ( VAR_2 != null ) { <END> VAR_1 . METHOD_2 ( this ) ; } } 
public Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { if ( METHOD_2 ( ctx , command ) ) { METHOD_3 ( command . getKey ( ) ) ; <START> METHOD_3 ( command . VAR_1 ( ) ) ; <END> } return METHOD_4 ( ctx , command ) ; } 
private Throwable METHOD_1 ( Throwable VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) == null ) return VAR_1 ; <END> Throwable VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 instanceof RuntimeException ) return METHOD_1 ( VAR_2 ) ; else return VAR_1 ; } 
private Collection < TYPE_1 > METHOD_1 ( TYPE_2 ctx ) { TYPE_3 VAR_1 = ( TYPE_3 ) ctx . VAR_2 ( ) ; TYPE_4 VAR_3 = VAR_4 . METHOD_2 ( ) ; Collection < TYPE_1 > VAR_5 = <START> VAR_6 ? null : VAR_3 . METHOD_3 ( ( Collection < Object > ) ctx . VAR_7 ( ) ) ; <END> return VAR_1 . METHOD_1 ( VAR_5 , VAR_3 ) ; } 
public < TYPE_1 > void METHOD_1 ( Object listener , TYPE_2 < ? super TYPE_3 , ? super TYPE_4 > filter , <START> TYPE_5 < ? super TYPE_3 , ? super TYPE_4 , TYPE_1 > VAR_1 , TYPE_6 VAR_2 ) { <END> METHOD_2 ( listener , null , null , filter , VAR_1 , VAR_2 ) ; } 
public TYPE_7 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_2 , Object VAR_3 , TYPE_4 ... VAR_4 ) { super ( VAR_2 ) ; if ( VAR_4 == null ) <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> if ( VAR_4 . length == 0 ) this . VAR_4 = TYPE_5 . VAR_5 ; else { this . VAR_4 = TYPE_5 . METHOD_1 ( VAR_4 ) ; } this . VAR_3 = VAR_3 ; VAR_6 = ( TYPE_6 < TYPE_2 , TYPE_3 > ) VAR_2 ; } 
public TYPE_1 < Object > METHOD_1 ( TYPE_2 ctx , TYPE_3 command ) { <START> TYPE_4 . METHOD_2 ( command , trace ) ; <END> try { Object result = VAR_1 . METHOD_3 ( ctx , command ) ; if ( result instanceof TYPE_5 ) { return ( ( TYPE_5 ) result ) . METHOD_4 ( ) ; } else { return TYPE_1 . METHOD_5 ( result ) ; } } catch ( Throwable t ) { return TYPE_6 . METHOD_6 ( t ) ; } finally { TYPE_4 . METHOD_7 ( command , trace ) ; } } 
public int METHOD_1 ( ) { if ( channel == null ) throw new TYPE_1 ( STRING_1 ) ; <START> return ( int ) VAR_1 . METHOD_1 ( ) ; <END> } 
public void METHOD_1 ( Object VAR_1 , Throwable VAR_2 ) { <START> if ( trace ) <END> log . VAR_3 ( STRING_1 , command , METHOD_2 ( ) ) ; TYPE_1 . METHOD_3 ( command , trace ) ; try { METHOD_4 ( VAR_1 , VAR_2 ) ; } finally { TYPE_1 . METHOD_5 ( command , trace ) ; } } 
private TYPE_1 METHOD_1 ( ) { try { TYPE_1 VAR_1 = null ; if ( VAR_2 != null ) { VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( VAR_1 == null && VAR_3 != null ) { VAR_1 = VAR_3 . METHOD_3 ( ) ; } } return VAR_1 ; } catch ( TYPE_2 e ) { throw new TYPE_3 ( STRING_1 , e ) ; } <START> } <END> 
public < T > TYPE_1 < T > METHOD_1 ( String VAR_1 , Map < String , byte [ ] > VAR_2 ) { return new TYPE_1 < > ( VAR_3 , VAR_4 , VAR_5 == null ? VAR_6 : VAR_5 , <START> VAR_7 , METHOD_2 ( ) , VAR_8 , VAR_1 , VAR_2 ) ; <END> } 
public Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { <START> log . VAR_1 ( STRING_1 , command ) ; <END> if ( command . VAR_2 ( ) ) { return VAR_3 . METHOD_2 ( command . getKey ( ) , command . VAR_4 ( ) , command . VAR_5 ( ) ) ; } return VAR_3 . METHOD_3 ( command . getKey ( ) , command . VAR_4 ( ) , command . VAR_5 ( ) ) ; } 
private boolean METHOD_1 ( Object source ) { <START> return source == null || METHOD_2 ( source . getClass ( ) ) ; <END> } 
protected static TYPE_1 METHOD_1 ( Map < TYPE_2 , Response > VAR_1 ) { if ( VAR_1 . values ( ) . stream ( ) . METHOD_2 ( TYPE_3 . class : : METHOD_3 ) ) { return TYPE_4 . METHOD_4 ( ) ; } else { return TYPE_5 . VAR_3 ; <START> } <END> } 
public void METHOD_1 ( int VAR_1 , boolean VAR_2 ) { if ( ! VAR_3 && VAR_2 ) { boolean VAR_4 = false ; synchronized ( VAR_5 ) { if ( VAR_5 . contains ( VAR_1 ) ) { <START> VAR_6 . add ( ( Integer ) VAR_1 ) ; <END> if ( VAR_6 . size ( ) == VAR_5 . size ( ) ) { log . VAR_7 ( STRING_1 , VAR_5 ) ; VAR_4 = true ; } } } if ( VAR_4 ) { METHOD_2 ( true ) ; } } } 
public TYPE_1 ( String VAR_2 , char [ ] VAR_3 ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = null ; } 
public < T > void METHOD_1 ( TYPE_1 < T > task ) { try { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) ; if ( VAR_1 == null ) return ; METHOD_3 ( VAR_1 , task ) ; if ( task instanceof TYPE_7 . TYPE_6 ) <START> { <END> METHOD_3 ( VAR_1 , ( ( TYPE_7 . TYPE_6 ) task ) . METHOD_4 ( ) ) ; } } finally { TYPE_5 . METHOD_5 ( ) ; } } 
protected final Object METHOD_1 ( TYPE_1 command ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; int VAR_3 = VAR_1 . METHOD_3 ( ) ; int VAR_4 = command . VAR_5 ( ) ; if ( VAR_4 < VAR_3 ) { <START> return ( Object ) TYPE_4 . VAR_7 ; <END> } else { throw new TYPE_3 ( VAR_4 ) ; } } 
public void METHOD_1 ( ) throws Exception { <START> cache . get ( null , ( Class < Object > ) null ) ; <END> } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { synchronized ( this ) { if ( VAR_2 ) { return false ; } VAR_3 [ VAR_4 & VAR_5 ] = VAR_1 ; if ( ( ( VAR_4 + 1 - VAR_6 ) & VAR_5 ) == 0 ) { VAR_2 = true ; <START> return false ; <END> } VAR_4 ++ ; return true ; } } 
String METHOD_1 ( ) { byte VAR_1 = METHOD_2 ( ) ; switch ( VAR_1 ) { case 0 : return "" ; case 1 : int size = METHOD_2 ( ) ; String VAR_2 = new String ( VAR_3 , 0 , VAR_4 , size ) ; VAR_4 += size ; return VAR_2 ; case 2 : return METHOD_3 ( ) ; <START> case 3 : <END> default : throw new RuntimeException ( STRING_1 + VAR_1 ) ; } } 
private static int METHOD_1 ( int id , TYPE_1 < ? > VAR_1 ) { if ( id < 0 ) throw log . VAR_2 ( VAR_1 , id ) ; <START> return id ; <END> } 
TYPE_1 < TYPE_2 , Object > METHOD_1 ( Object obj ) { Class < ? > VAR_1 = obj . getClass ( ) ; TYPE_3 VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 != null ) return ( out , object ) - > { METHOD_2 ( object , VAR_2 , out ) ; } ; TYPE_3 VAR_4 = VAR_5 . get ( VAR_1 ) ; if ( VAR_4 != null ) return ( out , object ) - > { <START> METHOD_3 ( object , VAR_4 , out ) ; <END> } ; return null ; } 
public long METHOD_1 ( long n ) { if ( n > 0 ) { long VAR_1 = VAR_2 . length - VAR_3 ; <START> if ( VAR_1 < VAR_3 ) <END> VAR_1 = n ; VAR_3 += VAR_1 ; return VAR_1 ; } else { int VAR_4 = Math . VAR_5 ( VAR_2 . length , VAR_3 ) ; long VAR_1 = VAR_4 + n ; VAR_3 = ( int ) ( VAR_1 + offset ) ; return VAR_1 ; } } 
public void clear ( ) { <START> Arrays . VAR_1 ( VAR_2 , null ) ; <END> count = 0 ; } 
void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( cache ( 2 ) , cache ( 0 ) ) ; <START> System . out . println ( METHOD_2 ( 0 ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; <END> cache ( 0 ) . put ( VAR_1 , STRING_1 ) ; } 
public TYPE_2 ( ) { <START> super ( ) ; <END> this . VAR_2 = ( ( VAR_3 , VAR_4 ) - > TYPE_1 . create ( VAR_5 , STRING_1 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { switch ( VAR_1 ) { <START> case VAR_2 : <END> assert VAR_3 != null ; assert VAR_4 != null ; return VAR_5 ; case VAR_6 : assert VAR_3 == null ; assert VAR_4 == null ; return VAR_5 ; case VAR_7 : assert VAR_3 != null ; assert VAR_4 != null ; return VAR_5 ; case VAR_8 : assert VAR_3 != null ; return VAR_4 ; case VAR_9 : assert VAR_4 != null ; return VAR_3 ; } return VAR_5 ; } 
private TYPE_1 < Map < TYPE_2 , TYPE_3 < TYPE_4 , TYPE_5 > > > METHOD_1 ( TYPE_6 VAR_1 ) { if ( VAR_2 . METHOD_2 ( ) ) throw log . VAR_3 ( VAR_4 ) ; if ( ! VAR_5 . METHOD_3 ( false , true ) ) throw log . VAR_6 ( ) ; try { return TYPE_7 . stream ( new TYPE_8 ( VAR_1 ) , false ) . filter ( METHOD_4 ( ) ) ; } finally { <START> VAR_5 . METHOD_3 ( true , false ) ; <END> } } 
private String METHOD_1 ( ) { String VAR_1 = ctx . VAR_2 ( ) . getName ( ) . METHOD_2 ( STRING_1 , STRING_2 ) ; <START> return VAR_1 ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 = new String [ VAR_2 ] ; <END> for ( int i = 0 ; i < VAR_2 ; i ++ ) { VAR_1 [ i ] = STRING_1 + i ; } METHOD_2 ( STRING_2 ) ; } 
<START> private static Class < Map > METHOD_1 ( String VAR_1 ) { <END> return TYPE_1 < Map > METHOD_2 ( VAR_1 , Map . VAR_3 . METHOD_3 ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 input ) throws IOException , TYPE_3 { return new TYPE_1 ( input . VAR_1 ( ) , input . VAR_1 ( ) , input . VAR_1 ( ) , <START> ( TYPE_4 ) input . VAR_1 ( ) , ( Type ) TYPE_5 . METHOD_2 ( input , Type : : valueOf ) , <END> ( TYPE_6 ) input . VAR_1 ( ) , ( TYPE_7 ) input . VAR_1 ( ) , input . VAR_2 ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 input ) throws IOException , TYPE_3 { TYPE_4 VAR_1 = ( TYPE_4 ) input . VAR_2 ( ) ; int VAR_3 = input . VAR_4 ( ) ; TYPE_5 [ ] VAR_5 = TYPE_6 . METHOD_2 ( input , TYPE_5 [ ] : : new ) ; <START> Set < Object > VAR_6 = ( Set < Object > ) TYPE_6 . METHOD_3 ( input , HashSet : : new ) ; <END> return new TYPE_1 ( VAR_1 , VAR_3 , VAR_5 , VAR_6 ) ; } 
public void METHOD_1 ( ) { <START> Boolean VAR_1 = TYPE_1 . stream ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) , true ) <END> . METHOD_4 ( n - > VAR_3 . equalsIgnoreCase ( n ) ) ; assertTrue ( VAR_3 + STRING_1 , VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 output ) throws IOException { output . VAR_1 ( key ) ; <START> output . VAR_2 ( VAR_3 ) ; <END> output . VAR_4 ( TYPE_2 . METHOD_2 ( METHOD_3 ( ) ) ) ; } 
public boolean METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> return VAR_2 . METHOD_1 ( Arrays . asList ( VAR_1 ) , VAR_3 , null ) ; <END> } 
public TYPE_8 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 < ? , ? > cache , TYPE_5 VAR_5 , Class < ? > ... VAR_6 ) { super ( VAR_2 , VAR_3 , cache , VAR_5 , VAR_6 ) ; this . VAR_4 = VAR_4 ; this . VAR_7 = VAR_3 . METHOD_1 ( ) . METHOD_2 ( VAR_2 ) . METHOD_3 ( Arrays . asList ( VAR_6 ) ) ; <START> this . VAR_8 = TYPE_6 . METHOD_4 ( cache , <END> TYPE_7 . class ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 uri , TYPE_3 VAR_1 ) throws TYPE_4 { int VAR_2 = uri . toString ( ) . METHOD_2 ( CHAR_1 ) ; String VAR_3 = uri . toString ( ) . substring ( VAR_2 + 1 ) ; <START> TYPE_1 in = VAR_1 . METHOD_3 ( VAR_3 ) ; <END> if ( in != null ) { return in ; } else { return null ; } } 
<START> default void VAR_1 ( int VAR_2 , long VAR_3 , TimeUnit VAR_4 ) throws InterruptedException , TYPE_5 { <END> try { TYPE_1 < TYPE_3 > VAR_8 = VAR_8 ( VAR_2 ) ; if ( VAR_8 != null ) VAR_8 . get ( VAR_3 , VAR_4 ) ; } catch ( TYPE_4 e ) { throw new TYPE_2 ( e . VAR_11 ( ) ) ; } } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) ? TYPE_1 . VAR_2 : TYPE_1 . NONE ; <END> } 
public int METHOD_1 ( TYPE_1 o ) { <START> return 0 ; <END> } 
<START> protected void METHOD_1 ( TYPE_1 context ) { <END> if ( VAR_1 == null ) { throw new IllegalStateException ( STRING_1 ) ; } Throwable VAR_2 = context . VAR_3 ( ) ; if ( VAR_2 instanceof TYPE_2 ) { List < TYPE_3 > VAR_4 = context . VAR_5 ( ) ; TYPE_3 VAR_6 = context . VAR_7 ( ) ; List < TYPE_3 > VAR_8 = new ArrayList < > ( VAR_4 ) ; VAR_8 . add ( VAR_6 ) ; VAR_1 . METHOD_2 ( VAR_8 ) ; } } 
public synchronized void METHOD_1 ( final TYPE_1 context ) { <START> VAR_1 . METHOD_2 ( r - > r . VAR_2 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> this . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( new TYPE_2 ( VAR_1 , VAR_2 , Constants . VAR_3 ) ) ; <END> return this ; } 
public String METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( VAR_2 . METHOD_1 ( ) ) . toString ( ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_1 : : METHOD_1 ) ; VAR_1 = Optional . empty ( ) ; <START> server = Optional . empty ( ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; VAR_2 . METHOD_1 ( ) . METHOD_2 ( config - > VAR_3 . add ( new TYPE_2 ( config ) ) ) ; <START> VAR_2 . METHOD_3 ( ) . METHOD_2 ( config - > VAR_3 . add ( new TYPE_3 ( config ) ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_2 ( ) . METHOD_2 ( ) ; TYPE_3 VAR_2 = VAR_1 . instance ( ) . METHOD_3 ( TYPE_3 . class ) . get ( ) ; VAR_2 . METHOD_4 ( STRING_1 , STRING_2 ) ; String VAR_3 = VAR_2 . METHOD_5 ( STRING_1 ) ; assertEquals ( VAR_3 , STRING_2 ) ; <START> VAR_1 . METHOD_6 ( ) ; <END> } 
<START> protected boolean METHOD_1 ( TYPE_1 VAR_1 , <END> Class < ? extends TYPE_1 > VAR_2 ) { Class < ? extends TYPE_1 > VAR_3 = VAR_1 . getClass ( ) ; return VAR_2 == VAR_3 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 ctx , TYPE_4 command ) throws Throwable { ctx . VAR_1 ( VAR_2 ) ; <START> if ( VAR_3 . METHOD_2 ( ) && ctx . VAR_4 ( ) ) { <END> VAR_3 . METHOD_3 ( command . getKey ( ) , METHOD_4 ( command . getKey ( ) ) ) ; } return ctx . VAR_5 ( ) ; } 
private boolean METHOD_1 ( ) { <START> return VAR_1 . keySet ( ) . size ( ) > 0 ; <END> } 
public void METHOD_1 ( TYPE_1 writer , TYPE_2 configuration ) throws TYPE_3 { <START> TYPE_4 VAR_1 = configuration . VAR_1 ( ) ; <END> writer . VAR_2 ( TYPE_5 . VAR_4 ) ; METHOD_2 ( writer , configuration ) ; METHOD_3 ( writer , configuration . VAR_5 ( ) ) ; METHOD_4 ( writer , configuration . VAR_6 ( ) ) ; METHOD_5 ( writer , configuration . VAR_7 ( ) ) ; METHOD_6 ( writer , configuration ) ; writer . VAR_8 ( ) ; } 
public void METHOD_1 ( TYPE_1 writer , TYPE_2 configuration ) throws TYPE_3 { writer . VAR_1 ( TYPE_5 . VAR_3 ) ; METHOD_2 ( writer , configuration ) ; <START> configuration . VAR_4 ( ) . write ( writer , TYPE_2 . VAR_5 , TYPE_4 . VAR_7 ) ; <END> METHOD_3 ( writer , configuration ) ; METHOD_4 ( writer , TYPE_5 . VAR_8 , configuration . table ( ) ) ; METHOD_5 ( writer , configuration ) ; METHOD_6 ( writer , configuration ) ; writer . VAR_9 ( ) ; } 
<START> public Builder METHOD_1 ( boolean VAR_1 ) { <END> this . VAR_1 = VAR_1 ; return this ; } 
public String toString ( ) { <START> return new String ( b , VAR_1 ) ; <END> } 
public TYPE_2 ( ) { <START> super ( TYPE_1 . METHOD_1 ( ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( METHOD_3 ( 0 ) ) ; TYPE_2 < String , String > cache = cache ( 0 ) ; METHOD_4 ( cache , STRING_1 ) ; METHOD_5 ( VAR_1 , STRING_2 ) ; <START> TYPE_3 < Object > VAR_2 = VAR_1 . METHOD_6 ( STRING_3 , new TYPE_4 ( ) . cache ( cache ) ) ; <END> } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> Set < String > VAR_3 = METHOD_2 ( ) . METHOD_3 ( VAR_2 , n - > { return new HashSet < > ( ) ; } ) ; <END> VAR_3 . add ( VAR_1 ) ; VAR_4 . put ( VAR_2 , VAR_3 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) ; <START> TYPE_2 . METHOD_4 ( VAR_1 , VAR_3 ) ; <END> String result = ( String ) VAR_4 . METHOD_5 ( VAR_3 , new TYPE_3 ( ) . METHOD_6 ( STRING_1 , STRING_1 ) ) . get ( ) ; assertEquals ( STRING_1 , result ) ; } 
private TYPE_1 METHOD_1 ( ) { <START> TYPE_1 context = new TYPE_1 ( ) ; <END> if ( parameters != null ) context . parameters ( parameters ) ; if ( cache != null ) context . cache ( cache ) ; TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( TYPE_2 . class ) ; if ( VAR_1 != null ) context . VAR_1 ( VAR_1 ) ; return context ; } 
public T call ( ) throws Exception { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_1 ( TYPE_1 . class ) ; <END> TYPE_2 < T > task = VAR_1 . METHOD_2 ( VAR_3 ) ; task . VAR_4 ( METHOD_3 ( ) ) ; return task . run ( ) ; } 
public String METHOD_1 ( Object instance ) { TYPE_1 < Object > action = ( ) - > METHOD_2 ( instance , method , TYPE_3 . VAR_2 ) ; Object object = System . VAR_3 ( ) == null ? action . run ( ) : TYPE_2 . METHOD_3 ( action ) ; <START> return String . VAR_4 . METHOD_4 ( object ) ; <END> } 
protected void METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ; METHOD_4 ( 0 ) . METHOD_5 ( METHOD_4 ( 1 ) ) ; <START> TYPE_1 . METHOD_6 ( METHOD_7 ( VAR_1 ) ) ; <END> METHOD_2 ( ) . METHOD_3 ( STRING_2 ) ; } 
public void METHOD_1 ( TYPE_1 output , TYPE_2 object ) throws IOException { output . VAR_1 ( object . name ) ; output . VAR_1 ( object . VAR_2 ) ; output . VAR_1 ( object . VAR_3 . name ( ) ) ; METHOD_2 ( output , object . parameters ) ; output . VAR_4 ( object . VAR_5 ) ; <START> output . VAR_4 ( object . VAR_6 ) ; <END> output . VAR_4 ( object . VAR_7 ) ; output . VAR_4 ( object . VAR_8 ) ; output . VAR_4 ( object . VAR_9 ) ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , Class < ? extends TYPE_1 > VAR_2 ) { Class < ? extends TYPE_1 > VAR_3 = VAR_1 . getClass ( ) ; <START> return VAR_2 == VAR_3 || VAR_2 == VAR_3 ; <END> } 
public void METHOD_1 ( TYPE_1 state ) { File VAR_1 = METHOD_2 ( state . VAR_2 ( ) ) ; try ( TYPE_2 VAR_3 = new TYPE_2 ( VAR_1 ) ) { state . forEach ( ( key , value ) - > { <START> VAR_3 . METHOD_3 ( STRING_1 , key , TYPE_3 . METHOD_4 ( value ) ) ; <END> } ) ; } catch ( IOException e ) { throw log . VAR_4 ( e , VAR_1 ) ; } } 
public void forEach ( TYPE_1 action ) { <START> if ( action instanceof TYPE_2 ) { <END> ( ( TYPE_2 ) action ) . METHOD_1 ( VAR_1 . METHOD_2 ( TYPE_3 . class ) ) ; } METHOD_3 ( ) . forEach ( action ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_1 ( null , VAR_1 , Optional . empty ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 d ) { VAR_1 . add ( d ) ; <START> if ( VAR_2 instanceof TYPE_2 ) { <END> VAR_2 = ( TYPE_2 < TYPE_3 , ? > ) d . VAR_3 ( VAR_2 ) ; } METHOD_2 ( true ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 ctx , Object key , TYPE_3 VAR_1 , boolean VAR_2 , TYPE_4 cmd , boolean VAR_3 ) { if ( VAR_1 != null ) { <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> } TYPE_1 VAR_4 = METHOD_2 ( ctx , key , TYPE_5 . VAR_6 , VAR_3 , false ) ; if ( trace ) { log . VAR_7 ( STRING_2 , key , VAR_4 ) ; } return VAR_4 ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { int VAR_2 = 0 ; <START> while ( VAR_1 . METHOD_2 ( ) == false ) { <END> if ( VAR_2 ++ > VAR_3 ) METHOD_3 ( ) ; if ( Thread . VAR_4 ( ) . METHOD_4 ( ) ) METHOD_3 ( ) ; try { Thread . VAR_5 ( 1 ) ; } catch ( InterruptedException e ) { Thread . VAR_4 ( ) . METHOD_5 ( ) ; METHOD_3 ( ) ; } } } 
public void METHOD_1 ( ) throws Exception { for ( int i = 0 ; i < VAR_1 ; i ++ ) { <START> cache . put ( STRING_1 + i , STRING_2 + i , - 1 , TimeUnit . VAR_2 , 1 , TimeUnit . VAR_2 ) ; <END> } VAR_3 . METHOD_2 ( 2 ) ; assertEquals ( 0 , cache . size ( ) ) ; } 
public static void METHOD_1 ( Collection < ? > VAR_1 , String name ) { TYPE_1 . METHOD_2 ( VAR_1 , ( ) - > STRING_1 + name + STRING_2 ) ; TYPE_2 < String > VAR_2 = ( ) - > STRING_1 + name + STRING_3 ; <START> VAR_1 . forEach ( ( VAR_3 ) - > TYPE_1 . METHOD_2 ( VAR_3 , VAR_2 ) ) ; <END> } 
<START> public static Set < TYPE_1 > METHOD_1 ( Set < TYPE_1 > VAR_1 , TYPE_1 VAR_2 ) { <END> if ( VAR_1 == null ) { return TYPE_2 . of ( VAR_2 ) ; } if ( VAR_1 . contains ( VAR_2 ) ) { return VAR_1 ; } TYPE_2 < TYPE_1 > VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 ) ; VAR_3 . add ( VAR_2 ) ; return VAR_3 ; } 
public void METHOD_1 ( int VAR_1 , Object [ ] args ) { if ( VAR_1 != VAR_2 ) throw new IllegalStateException ( STRING_1 + VAR_1 ) ; int i = 0 ; VAR_3 = ( TYPE_1 ) args [ i ++ ] ; VAR_4 = ( Boolean ) args [ i ++ ] ; VAR_5 = ( List < Object > ) args [ i ++ ] ; <START> VAR_6 = ( TYPE_2 < TYPE_3 > ) args [ i ] ; <END> } 
public static Set < TYPE_1 > METHOD_1 ( Set < TYPE_1 > VAR_1 , Set < TYPE_1 > VAR_2 ) { if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { return VAR_1 ; } <START> if ( VAR_1 == null ) { <END> return VAR_2 ; } TYPE_2 < TYPE_1 > VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 ) ; VAR_3 . addAll ( VAR_2 ) ; return VAR_3 ; } 
public static < T > void forEach ( T [ ] VAR_1 , TYPE_1 < T > VAR_2 ) { TYPE_2 . METHOD_1 ( VAR_1 , STRING_1 ) ; final int size = VAR_1 . length ; if ( size == 0 ) { return ; } else if ( size == 1 ) { VAR_2 . METHOD_2 ( VAR_1 [ 0 ] ) ; return ; } <START> for ( int i = 0 ; i < size ; ++ i ) { <END> VAR_2 . METHOD_2 ( VAR_1 [ i ] ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 state = VAR_2 ; switch ( state ) { case VAR_3 : throw new IllegalStateException ( STRING_1 ) ; case VAR_4 : case VAR_5 : <START> VAR_1 . METHOD_2 ( TYPE_2 . VAR_6 ) ; <END> break ; default : VAR_1 . METHOD_2 ( state ) ; break ; } } 
private boolean METHOD_1 ( ) { do { TYPE_1 state = VAR_1 ; switch ( state ) { case VAR_2 : case VAR_3 : case VAR_4 : <START> if ( METHOD_2 ( state , TYPE_1 . VAR_5 ) ) { <END> METHOD_3 ( ) ; METHOD_4 ( ) ; return true ; } break ; case VAR_6 : case VAR_7 : if ( METHOD_2 ( state , TYPE_1 . VAR_5 ) ) { METHOD_3 ( ) ; return true ; } break ; default : return false ; } } while ( true ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 VAR_2 = VAR_1 . from ( METHOD_3 ( ) . METHOD_4 ( ) ) . METHOD_5 ( STRING_1 ) . METHOD_6 ( STRING_1 ) . METHOD_7 ( STRING_2 , TYPE_3 . VAR_4 ) . build ( ) ; <START> <END> VAR_2 . list ( ) ; } 
public void update ( Object [ ] VAR_1 , Object [ ] VAR_2 ) { TYPE_1 value = ( TYPE_1 ) VAR_1 [ VAR_3 ] ; if ( value != null ) { TYPE_1 VAR_4 = ( TYPE_1 ) VAR_2 [ VAR_3 ] ; if ( VAR_4 == null ) { VAR_2 [ VAR_3 ] = value ; } else { <START> VAR_2 [ VAR_3 ] = VAR_4 . METHOD_1 ( ) + value . VAR_5 ( ) ; <END> } } } 
public TYPE_3 ( String VAR_2 ) { super ( VAR_2 ) ; <START> VAR_3 = new TYPE_1 < > ( ) ; <END> VAR_4 = new TYPE_2 ( 0 ) ; } 
<START> public static int METHOD_1 ( byte [ ] VAR_1 , int offset , int i ) { <END> int VAR_2 = offset ; while ( ( i & ~ INT_1 ) != 0 ) { VAR_1 [ VAR_2 ++ ] = ( byte ) ( ( i & INT_2 ) | INT_3 ) ; i >>>= INT_4 ; } VAR_1 [ VAR_2 ] = ( byte ) i ; return VAR_2 + 1 ; } 
protected boolean METHOD_1 ( ) throws Exception { if ( 0 <= VAR_1 && VAR_1 < VAR_2 . VAR_3 . METHOD_2 ( ) ) { if ( VAR_2 . METHOD_3 ( ) ) { VAR_2 . METHOD_4 ( ) . METHOD_5 ( STRING_1 + STRING_2 , VAR_1 ) ; } <START> response = TYPE_1 . VAR_5 ; <END> return false ; } return true ; } 
public void start ( ) { VAR_1 = VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) == TYPE_2 . VAR_4 ; VAR_5 = TYPE_1 . METHOD_3 ( VAR_2 ) ; VAR_6 = METHOD_4 ( VAR_2 . METHOD_1 ( ) . METHOD_5 ( ) <START> ) ; <END> VAR_7 = METHOD_4 ( VAR_2 . METHOD_1 ( ) . METHOD_6 ( ) ) ; } 
private void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { if ( VAR_1 == null ) { return ; } <START> while ( true ) { <END> TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 == null ) { break ; } VAR_2 . METHOD_3 ( ) ; } } 
<START> public void close ( ) throws Exception { <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 key , TYPE_1 value ) { TYPE_1 v = VAR_1 . METHOD_1 ( key , value ) ; if ( v != null ) { <START> VAR_2 . METHOD_2 ( ) ; <END> } else { VAR_2 . METHOD_3 ( ) ; } VAR_2 . METHOD_4 ( ) ; return v ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { TYPE_2 . METHOD_2 ( VAR_2 ) . METHOD_3 ( VAR_1 ) ; <START> METHOD_4 ( ) ; <END> } 
private boolean METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { synchronized ( VAR_5 ) { if ( ! VAR_3 . equals ( VAR_6 . METHOD_2 ( ) ) ) { log . VAR_7 ( STRING_1 , VAR_2 . METHOD_3 ( ) , VAR_3 ) ; return false ; } else { log . VAR_7 ( STRING_2 , VAR_1 , VAR_2 ) ; <START> VAR_4 . METHOD_4 ( VAR_2 ) ; <END> } } return true ; } 
public Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { if ( command . VAR_1 ( TYPE_5 . VAR_3 ) ) { return METHOD_2 ( ctx , command ) ; } try { return METHOD_3 ( ctx , command , new TYPE_3 ( command . getKey ( ) ) , <START> command . VAR_1 ( TYPE_5 . VAR_4 ) ) ; <END> } finally { if ( ctx . VAR_5 ( ) ) { command . VAR_6 ( command . VAR_7 ( ) ? TYPE_4 . VAR_9 : TYPE_4 . VAR_10 ) ; } } } 
public Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { if ( METHOD_2 ( ) ) { for ( Object key : command . VAR_1 ( ) ) { <START> if ( METHOD_3 ( ctx , key , command ) ) <END> METHOD_4 ( key ) ; } } return super . METHOD_1 ( ctx , command ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { ( ( TYPE_2 < Object , TYPE_1 > ) VAR_2 ) . METHOD_2 ( VAR_1 . getKey ( ) , new TYPE_2 . TYPE_4 < Object , TYPE_1 , TYPE_1 > ( ) { @Override public TYPE_1 apply ( Object key , TYPE_1 entry ) { <START> if ( entry == null && VAR_3 != null ) { <END> VAR_3 . METHOD_3 ( key ) ; } return VAR_1 ; } } ) ; } 
public TYPE_4 ( List < TYPE_1 < T > > VAR_2 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = new TYPE_2 ( VAR_2 . size ( ) ) ; TYPE_3 VAR_4 = new TYPE_3 ( ) ; for ( TYPE_1 < T > VAR_5 : VAR_2 ) { <START> if ( ! VAR_5 . METHOD_1 ( ) ) { <END> VAR_5 . METHOD_2 ( VAR_4 ) ; } else { VAR_4 . METHOD_3 ( VAR_5 ) ; } } } 
public void METHOD_1 ( String name ) { <START> if ( ! METHOD_2 ( ) . containsKey ( name ) ) { <END> throw log . VAR_1 ( name ) ; } else { METHOD_2 ( ) . remove ( name ) ; } } 
<START> protected void METHOD_1 ( ) { <END> if ( METHOD_2 ( ) ) { List < TYPE_1 < Map < String , TYPE_2 > > > VAR_1 = Collections . VAR_2 ( ) ; try { VAR_1 = VAR_3 . METHOD_3 ( new TYPE_3 ( ) ) ; METHOD_4 ( VAR_1 ) ; } catch ( Exception e ) { log . warn ( STRING_1 , e ) ; } finally { VAR_4 = VAR_5 . time ( ) ; } } } 
public void METHOD_1 ( int VAR_1 ) { if ( channel == null ) return ; log . VAR_2 ( STRING_1 , VAR_1 ) ; VAR_3 . METHOD_2 ( ) ; try { while ( channel != null && this . METHOD_3 ( ) < VAR_1 ) { try { VAR_4 . METHOD_4 ( ) ; } catch ( InterruptedException e ) { <START> log . VAR_5 ( e ) ; <END> } } } finally { VAR_3 . METHOD_5 ( ) ; } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_2 != null ) { try { VAR_3 . METHOD_2 ( getName ( ) , VAR_1 ) ; } catch ( Exception e ) { throw new TYPE_2 ( e ) ; } } } 
public TYPE_1 ( ) { <START> super ( 0 ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 key , TYPE_3 VAR_1 , TYPE_4 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 , TYPE_5 VAR_5 ) { <END> return METHOD_2 ( key , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; } 
<START> public Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { <END> TYPE_3 cmd = VAR_1 . METHOD_2 ( VAR_2 , null , null ) ; VAR_3 . METHOD_3 ( ctx , cmd ) ; TYPE_4 VAR_4 = VAR_5 . METHOD_4 ( ) ; for ( String VAR_6 : VAR_4 . METHOD_5 ( ) . keySet ( ) ) { VAR_4 . METHOD_6 ( VAR_6 ) ; } return METHOD_7 ( ctx , command ) ; } 
public String METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> return ( ! ( VAR_1 != null && VAR_1 . METHOD_3 ( ) != null ) ) ? STRING_1 <END> : VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) . toString ( ) ; } 
<START> public synchronized TYPE_1 < TYPE_2 < TYPE_3 , TYPE_4 > > METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public boolean METHOD_1 ( ) { <END> return METHOD_2 ( ) != null && METHOD_2 ( ) . METHOD_3 ( ) ; } 
protected TYPE_1 METHOD_1 ( ) { <START> TYPE_1 builder = METHOD_2 ( TYPE_2 . VAR_2 , false ) ; <END> builder . VAR_3 ( ) . METHOD_3 ( ) ; return METHOD_4 ( builder ) ; } 
<START> public void METHOD_1 ( ) throws InterruptedException , TYPE_1 , TYPE_2 { <END> METHOD_2 ( TYPE_3 . VAR_2 ) ; } 
protected void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> log . VAR_3 ( STRING_1 , VAR_1 , getClass ( ) . METHOD_3 ( ) ) ; <END> for ( TYPE_2 factory : VAR_4 ) { METHOD_4 ( factory ) ; } } 
private TYPE_1 METHOD_1 ( Set < TYPE_1 > VAR_1 ) { TYPE_1 server ; <START> if ( VAR_2 instanceof TYPE_2 ) { <END> server = ( ( TYPE_2 ) VAR_2 ) . METHOD_1 ( VAR_1 ) ; } else { server = VAR_2 . METHOD_1 ( ) ; } return server ; } 
public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) throws IOException , TYPE_2 { TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 [ 0 ] ; String VAR_3 = VAR_2 . METHOD_2 ( ) ; String VAR_4 = VAR_2 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_3 . equals ( VAR_4 ) ) ; int VAR_5 = VAR_4 . METHOD_5 ( CHAR_1 ) ; <START> VAR_6 = VAR_5 < 0 ? new TYPE_4 ( VAR_4 ) : new TYPE_4 ( VAR_4 . substring ( VAR_5 + 1 ) , VAR_4 . substring ( 0 , VAR_5 ) ) ; <END> } 
public TYPE_4 ( TYPE_1 < ? , ? > cache , String VAR_2 , Class < ? extends TYPE_2 > VAR_3 ) { <START> VAR_4 = cache . VAR_5 ( ) . METHOD_1 ( TYPE_3 . class ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
protected TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_2 config = METHOD_2 ( ) ; config . VAR_3 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_4 ) ; <START> config . VAR_3 ( ) . METHOD_3 ( ) . METHOD_5 ( METHOD_6 ( ) ) ; <END> config . VAR_3 ( ) . METHOD_3 ( ) . METHOD_7 ( new TYPE_3 ( VAR_1 , VAR_2 , VAR_5 ) ) ; config . VAR_3 ( ) . METHOD_3 ( ) . METHOD_8 ( ) ; return config . build ( ) ; } 
public void METHOD_1 ( ) { if ( METHOD_2 ( ) ) { VAR_1 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( ) ; <START> VAR_3 . METHOD_1 ( ) ; <END> } VAR_4 = false ; } 
public void METHOD_1 ( byte [ ] VAR_1 ) { <START> TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; <END> VAR_2 . VAR_4 . METHOD_2 ( ) ; VAR_3 . remove ( VAR_1 ) ; if ( log . VAR_5 ( ) ) log . VAR_6 ( STRING_1 , TYPE_2 . METHOD_3 ( VAR_1 ) ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , byte [ ] [ ] params ) { if ( VAR_2 . isEmpty ( ) ) { <START> VAR_1 . METHOD_2 ( ( short ) 0 ) ; <END> } else { VAR_1 . METHOD_3 ( VAR_2 ) ; if ( params != null ) { VAR_1 . METHOD_2 ( ( short ) params . length ) ; for ( byte [ ] VAR_3 : params ) VAR_1 . METHOD_4 ( VAR_3 ) ; } else { VAR_1 . METHOD_2 ( ( short ) 0 ) ; } } } 
<START> public TYPE_2 ( Class < ? extends TYPE_1 > VAR_2 ) { <END> this ( VAR_2 , null , null , null , VAR_3 ) ; } 
public int METHOD_1 ( ) { <START> int result = VAR_1 != null ? VAR_1 . METHOD_1 ( ) : 0 ; <END> result = INT_1 * result + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) ; return result ; } 
public String toString ( ) { <START> return STRING_1 + STRING_2 + ( Arrays . asList ( VAR_1 ) ) + CHAR_1 ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , TYPE_2 VAR_3 ) { if ( ( VAR_2 & VAR_3 . METHOD_2 ( ) ) != VAR_3 . METHOD_2 ( ) ) { if ( System . VAR_4 ( ) == null ) { <START> throw log . VAR_5 ( VAR_1 == null ? STRING_1 : VAR_1 . toString ( ) , VAR_3 . toString ( ) ) ; <END> } else { System . VAR_4 ( ) . METHOD_1 ( VAR_3 . METHOD_3 ( ) ) ; } } } 
public static TYPE_1 [ ] METHOD_1 ( TYPE_1 VAR_1 ) { return new TYPE_1 [ ] { VAR_1 , <START> new TYPE_2 ( ) , <END> TYPE_3 . class . METHOD_2 ( ) , TYPE_1 . METHOD_3 ( ) } ; } 
public void execute ( String VAR_1 ) throws TYPE_1 { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; } TYPE_2 < Object , Object > VAR_2 = cache . VAR_3 ( ) . METHOD_1 ( VAR_1 ) ; <START> if ( VAR_2 == null ) { <END> throw new IllegalArgumentException ( STRING_2 + VAR_1 + STRING_3 ) ; } METHOD_2 ( VAR_1 ) ; } 
public TYPE_1 < TYPE_2 , TYPE_3 > remove ( Object VAR_1 ) { <START> TYPE_1 e = VAR_2 . remove ( VAR_1 ) ; <END> return e == null || ( e . VAR_3 ( ) && e . VAR_4 ( VAR_5 . METHOD_1 ( ) ) ) ? null : e ; } 
protected void METHOD_1 ( ) throws Throwable { TYPE_1 builder = METHOD_2 ( METHOD_3 ( ) , true ) ; <START> builder . VAR_1 ( ) . METHOD_4 ( ) . METHOD_5 ( INT_1 ) ; <END> METHOD_6 ( 4 , METHOD_7 ( ) , builder ) ; } 
protected void METHOD_1 ( ) throws Throwable { TYPE_1 builder = METHOD_2 ( METHOD_3 ( ) , true ) ; <START> builder . VAR_1 ( ) . METHOD_4 ( ) . METHOD_5 ( INT_1 ) ; <END> METHOD_6 ( 2 , METHOD_7 ( ) , builder ) ; } 
public String getProperty ( String key ) { <START> return this . properties . get ( key ) . toString ( ) ; <END> } 
private Thread METHOD_1 ( final TYPE_1 target ) { final TYPE_2 VAR_1 = new TYPE_2 ( VAR_2 . METHOD_2 ( ) , VAR_3 . METHOD_2 ( ) , VAR_4 , node , VAR_5 ) ; Thread VAR_6 = new Thread ( VAR_7 , target ) ; VAR_6 . METHOD_3 ( VAR_1 . format ( VAR_6 , VAR_8 ) ) ; <START> if ( VAR_9 != null ) VAR_6 . METHOD_4 ( VAR_9 ) ; <END> VAR_6 . METHOD_5 ( true ) ; return VAR_6 ; } 
public org . VAR_1 . VAR_2 . TYPE_1 METHOD_1 ( ) { <START> switch ( this ) { <END> case VAR_4 : case VAR_5 : case VAR_6 : return org . VAR_1 . VAR_2 . TYPE_1 . VAR_7 ; default : return org . VAR_1 . VAR_2 . TYPE_1 . VAR_8 ; } } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = size - VAR_1 . size ; <START> return ( VAR_2 != 0 ) ? VAR_2 : ( int ) ( offset - VAR_1 . offset ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) . clear ( ) ; <END> TYPE_1 . METHOD_3 ( VAR_2 ) ; } 
public TYPE_4 ( TYPE_1 cache ) { this . cache = cache ; <START> this . VAR_2 = cache . VAR_3 ( ) . METHOD_1 ( ) . METHOD_2 ( ) == TYPE_3 . VAR_5 ; <END> VAR_6 = new TYPE_2 ( cache , VAR_7 ) ; } 
public Object [ ] getParameters ( ) { switch ( VAR_1 ) { case VAR_2 : case VAR_3 : case VAR_4 : return new Object [ ] { VAR_1 . METHOD_1 ( ) , VAR_5 } ; } <START> return new Object [ ] { VAR_1 . METHOD_1 ( ) } ; <END> } 
private byte [ ] METHOD_1 ( String c ) throws IOException { TYPE_1 is = getClass ( ) . METHOD_2 ( c ) ; try { return TYPE_2 . METHOD_3 ( is ) ; } finally { <START> is . close ( ) ; <END> } } 
private TYPE_1 METHOD_1 ( TYPE_2 cache ) { TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( cache , TYPE_3 . class ) ) ; TYPE_4 t = ( TYPE_4 ) METHOD_2 ( cache , TYPE_5 . class ) ; TYPE_6 VAR_2 = t . VAR_3 ( ) ; METHOD_3 ( VAR_1 , STRING_1 , VAR_2 , TYPE_6 . class ) ; <START> METHOD_4 ( cache . VAR_4 ( ) , TYPE_3 . class , VAR_1 , true ) ; <END> return VAR_1 ; } 
public Builder < ? > read ( TYPE_1 VAR_1 ) { VAR_2 . clear ( ) ; <START> for ( TYPE_2 VAR_3 : VAR_1 . METHOD_1 ( ) ) { <END> VAR_2 . add ( VAR_3 ) ; } return this ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( ) ; <END> channel . write ( ByteBuffer . VAR_2 ( VAR_3 ) , VAR_1 . offset + VAR_4 ) ; if ( ! VAR_5 . add ( VAR_1 ) ) { throw new IllegalStateException ( String . format ( STRING_1 , VAR_1 ) ) ; } if ( trace ) log . VAR_6 ( STRING_2 , VAR_1 . offset , VAR_1 . size , VAR_5 . size ( ) ) ; } } 
private TYPE_1 < String , TYPE_2 > METHOD_1 ( int VAR_1 ) { TYPE_1 < String , TYPE_2 > cache = cache ( VAR_1 ) ; TYPE_3 < String , TYPE_2 > VAR_2 = cache . VAR_3 ( ) ; TYPE_3 < String , TYPE_2 > VAR_4 = VAR_2 . METHOD_2 ( TYPE_4 . VAR_6 , TYPE_4 . VAR_7 ) ; <START> System . out . METHOD_3 ( STRING_1 + VAR_1 + STRING_2 + cache + STRING_3 ) ; <END> return VAR_4 ; } 
<START> TYPE_1 put ( final TYPE_2 key , final TYPE_1 value ) { <END> final TYPE_1 VAR_1 = VAR_2 . put ( VAR_3 , key , value ) ; METHOD_1 ( key , value ) ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 ctx = new TYPE_2 ( true , VAR_1 ) ; <END> return ctx ; } 
private TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ; } 
<START> public org . VAR_1 . configuration . cache . TYPE_1 METHOD_1 ( ) { <END> return new TYPE_2 ( ) . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . VAR_3 ) . METHOD_4 ( 4 ) . build ( ) ; } 
<START> public static TYPE_1 METHOD_1 ( TYPE_1 metadata ) { <END> TYPE_1 VAR_1 = metadata ; while ( VAR_1 != null ) { if ( VAR_1 instanceof TYPE_2 ) { VAR_1 = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; } else { break ; } } return VAR_1 ; } 
private boolean METHOD_1 ( TYPE_1 ctx ) { return METHOD_2 ( ctx ) || <START> ! ctx . VAR_1 ( ) && ! ctx . VAR_2 ( ) . isEmpty ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 command , Response VAR_1 ) { if ( command instanceof TYPE_2 || command instanceof TYPE_3 || command instanceof TYPE_4 || ( command instanceof TYPE_5 && ( ( ( TYPE_6 ) command ) . METHOD_2 ( ) || VAR_1 instanceof TYPE_7 ) ) ) { VAR_2 . METHOD_3 ( ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> } } 
<START> Class METHOD_1 ( ) { <END> return VAR_1 ; } 
public Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command , boolean VAR_1 ) throws Throwable { Object VAR_2 = METHOD_2 ( ctx , command ) ; Object key ; if ( METHOD_3 ( command ) && command . VAR_3 ( ) && VAR_4 . METHOD_4 ( ( key = command . getKey ( ) ) ) ) { <START> METHOD_5 ( ) . METHOD_6 ( STRING_1 ) ; <END> VAR_5 . METHOD_7 ( Collections . VAR_6 ( key ) , ctx . VAR_7 ( ) , VAR_1 ) ; } return VAR_2 ; } 
public int METHOD_1 ( Object o ) { <START> if ( ! ( o instanceof TYPE_1 ) ) <END> throw new TYPE_2 ( ) ; if ( this == o ) return 0 ; TYPE_1 VAR_1 = ( TYPE_1 ) o ; int VAR_2 = size - VAR_1 . size ; return ( VAR_2 != 0 ) ? VAR_2 : offset > VAR_1 . offset ? 1 : - 1 ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> METHOD_2 ( ) ; <END> final TYPE_2 VAR_1 = new TYPE_2 ( STRING_1 , VAR_2 , VAR_3 ) ; final String VAR_4 = STRING_2 ; final String VAR_5 = STRING_3 ; TYPE_3 VAR_6 = TYPE_4 . METHOD_3 ( VAR_7 , TYPE_5 . class ) . METHOD_4 ( ) ; VAR_6 . METHOD_5 ( TYPE_6 . create ( VAR_1 , VAR_5 ) ) ; VAR_2 . put ( VAR_1 , VAR_4 ) ; assertEquals ( VAR_4 , VAR_7 . get ( VAR_1 ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == TYPE_3 . VAR_3 ) { <END> return METHOD_2 ( ) ; } else if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 VAR_4 = ( TYPE_2 ) VAR_1 ; long VAR_5 = VAR_4 . METHOD_3 ( ) + 1 ; return METHOD_4 ( VAR_5 ) ; } throw log . VAR_6 ( VAR_1 . getClass ( ) . getName ( ) ) ; } 
public Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { if ( this . VAR_1 ) VAR_2 . METHOD_2 ( ) ; Object result = METHOD_3 ( ctx , command ) ; if ( ! ctx . VAR_3 ( ) ) { if ( command . VAR_4 ( ) ) { <START> VAR_5 . METHOD_4 ( command . VAR_6 ( ) , false ) ; <END> } else { VAR_5 . METHOD_5 ( command . VAR_6 ( ) ) ; } } return result ; } 
public void METHOD_1 ( int VAR_1 ) { METHOD_2 ( STRING_1 ) ; <START> METHOD_3 ( location , STRING_2 , properties ) ; <END> this . VAR_1 = VAR_1 ; } 
public Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { Object VAR_1 = super . METHOD_1 ( ctx , command ) ; <START> if ( VAR_2 && VAR_3 && ! METHOD_2 ( command ) ) { <END> Set < Object > set = VAR_4 . METHOD_3 ( Collections . VAR_5 ( ) ) ; Set < Object > VAR_6 = new HashSet < Object > ( set ) ; VAR_6 . addAll ( ( Set < Object > ) VAR_1 ) ; return Collections . VAR_7 ( VAR_6 ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { VAR_1 . clear ( ) ; <START> VAR_2 . remove ( ) ; <END> } 
public void METHOD_1 ( ) throws Throwable { Object VAR_1 = getKey ( ) ; cache ( 0 ) . put ( VAR_1 , STRING_1 ) ; METHOD_2 ( 0 ) . METHOD_3 ( ) ; cache ( 0 ) . remove ( VAR_1 ) ; METHOD_4 ( cache ( 0 ) . get ( VAR_1 ) ) ; METHOD_2 ( 0 ) . METHOD_5 ( ) ; <START> assertEquals ( cache ( 0 ) . get ( VAR_1 ) , STRING_1 ) ; <END> } 
private void METHOD_1 ( int VAR_1 , Object key , Object VAR_2 ) { <START> TYPE_1 entry = cache ( VAR_1 ) . METHOD_2 ( ) . METHOD_3 ( ) . get ( key ) ; <END> assertEquals ( VAR_2 , entry != null ? entry . getValue ( ) : null ) ; } 
public final void execute ( TYPE_1 VAR_1 ) { if ( VAR_2 ) { throw new TYPE_2 ( STRING_1 ) ; } if ( VAR_1 . METHOD_1 ( ) ) { METHOD_2 ( VAR_1 ) ; } else { if ( ! VAR_3 . METHOD_3 ( VAR_1 ) ) { <START> throw new TYPE_2 ( STRING_2 ) ; <END> } } METHOD_4 ( ) ; if ( log . VAR_4 ( ) ) { log . VAR_5 ( STRING_3 , VAR_3 . size ( ) ) ; } } 
protected Set < byte [ ] > METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 params = METHOD_2 ( VAR_1 , VAR_2 ) ; VAR_1 . METHOD_3 ( ) ; <START> System . out . println ( STRING_1 ) ; <END> METHOD_4 ( VAR_1 , params ) ; System . out . println ( STRING_2 ) ; Set < byte [ ] > result = new HashSet < byte [ ] > ( ) ; while ( VAR_1 . METHOD_5 ( ) == 1 ) { result . add ( VAR_1 . METHOD_6 ( ) ) ; } return result ; } 
protected < T > T METHOD_1 ( Class < T > VAR_1 , String name ) { <START> return METHOD_1 ( VAR_1 , name , true ) ; <END> } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 < TYPE_1 > VAR_1 , ANNOTATION_2 TYPE_3 VAR_2 ) { if ( ! VAR_1 . METHOD_2 ( ) ) { if ( log . VAR_3 ( ) ) { <START> log . VAR_4 ( STRING_1 , VAR_1 ) ; <END> } return VAR_1 . get ( ) ; } return new TYPE_4 ( VAR_2 ) ; } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_3 . METHOD_2 ( VAR_2 ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> METHOD_3 ( ) ; } 
protected boolean METHOD_1 ( ) throws Exception { boolean VAR_1 ; if ( VAR_2 . METHOD_2 ( ) ) { throw new IllegalStateException ( STRING_1 + METHOD_3 ( ) + STRING_2 ) ; } VAR_3 = METHOD_4 ( ) ; VAR_1 = true ; if ( VAR_3 . METHOD_5 ( ) . contains ( VAR_4 ) ) VAR_5 = VAR_3 ; else VAR_5 = METHOD_6 ( configuration , VAR_3 . METHOD_5 ( ) , VAR_2 . METHOD_7 ( ) , VAR_4 ) ; <START> return VAR_1 ; <END> } 
public TYPE_2 ( String id , String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 ) { super ( id ) ; this . VAR_2 = StringUtils . VAR_6 ( VAR_2 , STRING_1 ) + STRING_1 ; METHOD_1 ( VAR_3 ) ; METHOD_2 ( StringUtils . VAR_7 ( VAR_4 , TYPE_3 . VAR_9 ) ) ; METHOD_3 ( StringUtils . VAR_7 ( VAR_5 , TYPE_3 . VAR_10 ) ) ; <START> this . VAR_11 = new ArrayList < TYPE_1 > ( ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 ) { this . VAR_3 = <START> new TYPE_2 ( VAR_2 , TYPE_3 < String , TYPE_1 > METHOD_1 ( ) , TYPE_5 . VAR_6 ) ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 element , TYPE_4 VAR_2 ) throws TYPE_5 { try { if ( STRING_1 . equals ( element . VAR_3 ( ) ) ) { return new TYPE_6 ( VAR_1 , VAR_2 ) ; } return new TYPE_1 ( VAR_1 , 0 , VAR_2 , element ) ; } catch ( TYPE_5 e ) { <START> throw e ; <END> } } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) throws TYPE_4 { try { return VAR_2 . METHOD_1 ( METHOD_2 ( VAR_1 ) ) ; <START> } catch ( TYPE_5 e ) { <END> throw e ; } catch ( TYPE_6 e ) { throw e ; } } 
public static TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 VAR_1 ) { return new TYPE_1 < TYPE_2 > ( ) { @Override public TYPE_2 apply ( TYPE_4 VAR_2 ) { try { TYPE_5 element = METHOD_2 ( VAR_1 , VAR_2 ) ; return METHOD_3 ( VAR_1 , element , VAR_2 ) ; <START> } catch ( TYPE_6 e ) { <END> return null ; } catch ( TYPE_7 e ) { return null ; } } @Override public String toString ( ) { return STRING_1 + VAR_1 ; } } ; } 
public static void METHOD_1 ( ) throws Exception { String VAR_1 = System . getProperty ( STRING_1 ) ; <START> if ( VAR_1 == null ) VAR_1 = TYPE_6 . TYPE_5 . METHOD_2 ( ) + File . VAR_2 + STRING_2 ; <END> System . out . println ( STRING_3 + VAR_1 ) ; TYPE_2 VAR_3 = new TYPE_2 ( new File ( Utils . VAR_4 ( VAR_1 ) ) ) ; VAR_5 = TYPE_3 . getInstance ( VAR_3 ) ; VAR_6 = VAR_5 . METHOD_3 ( ) ; VAR_6 . start ( ) ; } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > result = new TYPE_2 < > ( ) ; result . addAll ( VAR_1 ) ; result . VAR_2 ( VAR_3 ) ; <START> result . VAR_4 ( TYPE_3 . METHOD_2 ( TYPE_1 : : getName ) ) ; <END> return result ; } 
public TYPE_3 ( String VAR_2 , String VAR_3 ) { <START> super ( ) ; <END> VAR_4 = new TYPE_1 ( this , VAR_2 , VAR_3 , new TYPE_2 ( ) ) ; } 
public TYPE_1 METHOD_1 ( int VAR_1 , int VAR_2 ) { <START> double VAR_3 = VAR_1 - VAR_4 . METHOD_2 ( ) / FLOAT_1 ; <END> double VAR_5 = VAR_4 . METHOD_3 ( ) / FLOAT_1 - VAR_2 ; return METHOD_4 ( ) . METHOD_5 ( ) . apply ( new TYPE_1 ( VAR_3 , VAR_5 , 0 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { synchronized ( VAR_2 ) { this . VAR_1 = VAR_1 ; <START> double VAR_3 = VAR_4 . METHOD_2 ( ) ; <END> METHOD_3 ( ) ; VAR_4 = VAR_4 . METHOD_4 ( VAR_3 / VAR_4 . METHOD_2 ( ) ) ; } } 
public static long METHOD_1 ( String data ) { if ( data == null ) { return - 1 ; } try { byte VAR_1 [ ] = data . VAR_2 ( STRING_1 ) ; TYPE_1 VAR_3 = new TYPE_2 ( ) ; VAR_3 . update ( VAR_1 , 0 , VAR_1 . length ) ; return VAR_3 . getValue ( ) ; } catch ( TYPE_3 e ) { <START> return - 1 ; <END> } } 
private void METHOD_1 ( TYPE_1 properties , Map < String , String > VAR_1 ) { if ( properties != null ) { <START> for ( final String name : properties . VAR_2 ( ) ) <END> if ( ! VAR_1 . containsKey ( name ) ) { VAR_1 . put ( name , properties . getProperty ( name ) ) ; } } } 
public String METHOD_1 ( ) throws TYPE_1 { <START> if ( VAR_1 == null ) { <END> VAR_1 = METHOD_2 ( ) ; } else if ( ( VAR_1 != null ) && ( METHOD_3 ( ) <= 0 ) ) { VAR_1 = METHOD_2 ( ) ; } return VAR_1 ; } 
private double [ ] METHOD_1 ( List < Double > VAR_1 , List < TYPE_1 > VAR_2 , int VAR_3 , int VAR_4 ) { Map < Double , Integer > values = new HashMap < > ( ) ; for ( TYPE_1 b : VAR_2 ) { values . put ( b . VAR_5 ( ) , b . VAR_6 ( ) ) ; } TYPE_2 VAR_7 = new TYPE_2 ( ) ; <START> return VAR_7 . METHOD_1 ( values , VAR_1 , VAR_3 , VAR_4 ) ; <END> } 
private Double METHOD_1 ( double VAR_1 , double VAR_2 , double VAR_3 , double VAR_4 ) { if ( VAR_1 > VAR_4 || VAR_2 < VAR_3 ) { return FLOAT_1 ; } double VAR_5 = Math . max ( VAR_1 , VAR_3 ) ; double VAR_6 = Math . VAR_7 ( VAR_2 , VAR_4 ) ; double VAR_8 = VAR_6 - VAR_5 ; double VAR_9 = VAR_4 - VAR_3 ; <START> if ( VAR_8 == VAR_9 ) <END> return FLOAT_2 ; else return VAR_8 / VAR_9 ; } 
public boolean METHOD_1 ( ) { <START> return this . VAR_1 ; <END> } 
<START> public final Object METHOD_1 ( TYPE_1 build , Class VAR_1 ) { <END> return build instanceof TYPE_2 ? ( TYPE_2 ) build : null ; } 
<START> protected static TYPE_1 METHOD_1 ( ) { <END> return b . VAR_1 ( ) ; } 
public TYPE_1 METHOD_1 ( ) throws InterruptedException { synchronized ( VAR_1 ) { if ( VAR_1 . isEmpty ( ) ) { <START> VAR_1 . METHOD_2 ( ) ; <END> Integer VAR_2 = VAR_1 . METHOD_3 ( ) ; return VAR_3 [ VAR_2 ] ; } Integer VAR_2 = VAR_1 . METHOD_3 ( ) ; return VAR_3 [ VAR_2 ] ; } } 
public int read ( ) throws IOException { VAR_1 ++ ; <START> return 0 ; <END> } 
public static String METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> String buffer = "" ; <END> for ( TYPE_1 c : VAR_1 ) { buffer += METHOD_1 ( c , 0 ) ; } return buffer ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { <START> if ( VAR_1 == STRING_1 ) <END> throw new TYPE_2 ( STRING_2 ) ; TYPE_3 object = ( TYPE_3 ) VAR_2 . get ( String . format ( TYPE_4 . VAR_4 , VAR_1 ) , null ) . METHOD_2 ( ) ; TYPE_3 data = ( TYPE_3 ) object . get ( STRING_3 ) ; return data != null ? new TYPE_1 ( data ) : null ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; <START> this . user = null ; <END> } 
public void METHOD_1 ( TYPE_1 event ) { TYPE_2 VAR_1 = event . VAR_2 ( ) ; if ( ! VAR_1 . METHOD_2 ( ) ) { <START> for ( Object map : VAR_3 . METHOD_3 ( ) . keySet ( ) ) { <END> TYPE_3 VAR_4 = VAR_3 . METHOD_3 ( ) . get ( map ) ; if ( TYPE_4 . METHOD_4 ( ) . METHOD_5 ( VAR_1 , STRING_1 + map ) ) { VAR_4 . METHOD_6 ( VAR_1 ) ; } } } } 
<START> protected boolean METHOD_1 ( final TYPE_1 request ) { <END> return TYPE_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( request , this . VAR_1 , this . VAR_2 ) ) ; } 
<START> protected boolean METHOD_1 ( final TYPE_1 request ) { <END> return STRING_1 . equals ( request . VAR_1 ( ) ) && ! METHOD_2 ( request ) && TYPE_2 . METHOD_3 ( TYPE_2 . METHOD_4 ( request , this . VAR_2 , this . VAR_3 ) ) ; } 
private String METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 ) { <START> final String VAR_3 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <END> if ( TYPE_2 . METHOD_4 ( VAR_3 ) ) { logger . info ( STRING_1 , VAR_2 , VAR_3 ) ; return VAR_3 ; } return null ; } 
public TYPE_4 ( String type , TYPE_1 options , TYPE_2 VAR_2 ) { super ( type , options , VAR_2 , true ) ; <START> TYPE_3 . METHOD_1 ( VAR_3 , VAR_4 , VAR_5 ) ; <END> TYPE_3 . METHOD_2 ( VAR_6 , VAR_4 , VAR_5 ) ; METHOD_3 ( ) ; } 
public TYPE_4 ( String type , TYPE_1 options , TYPE_2 VAR_2 ) { super ( type , options , VAR_2 , true ) ; <START> TYPE_3 . METHOD_1 ( VAR_3 , VAR_4 , VAR_5 ) ; <END> TYPE_3 . METHOD_2 ( VAR_6 , VAR_4 , VAR_5 ) ; } 
public TYPE_4 ( String type , TYPE_1 options , TYPE_2 VAR_2 ) { super ( type , options , VAR_2 , true ) ; <START> TYPE_3 . METHOD_1 ( VAR_3 , VAR_4 , VAR_5 ) ; <END> TYPE_3 . METHOD_2 ( VAR_2 , VAR_4 , VAR_5 ) ; TYPE_3 . METHOD_3 ( VAR_6 , VAR_4 , VAR_5 ) ; this . options = options ; } 
public void METHOD_1 ( ) { connection = new TYPE_1 ( options , VAR_1 , VAR_2 ) ; connection . VAR_3 ( options ) ; <START> if ( connection . VAR_4 ( ) . METHOD_2 ( ) != VAR_5 ) { <END> connection . VAR_6 ( ) ; throw new IllegalArgumentException ( format ( STRING_1 + VAR_7 + STRING_2 , VAR_8 . toString ( ) . METHOD_3 ( ) ) ) ; } METHOD_4 ( ) ; } 
private synchronized void METHOD_1 ( ) { <START> final TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; <END> if ( VAR_2 . METHOD_3 ( ) && METHOD_4 ( VAR_1 ) ) { VAR_3 . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; VAR_1 . METHOD_7 ( ) ; VAR_4 = TYPE_2 . METHOD_8 ( ) ; } } 
<START> TYPE_3 ( TYPE_1 < T > VAR_2 , <END> String VAR_3 , long VAR_4 , long VAR_5 , int VAR_6 , int VAR_7 , int VAR_8 , TYPE_2 VAR_9 ) { this ( VAR_2 , METHOD_1 ( ) , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 ) ; } 
<START> @Override public synchronized Boolean METHOD_1 ( String VAR_1 ) { <END> if ( METHOD_2 ( ( ) - > TYPE_1 . METHOD_3 ( VAR_2 ) ) ) { METHOD_4 ( ) ; VAR_3 . METHOD_5 ( this : : METHOD_4 , VAR_4 , VAR_5 , TimeUnit . VAR_6 ) ; } return METHOD_2 ( ( ) - > METHOD_6 ( VAR_1 ) ) ; } 
public final void METHOD_1 ( ) { TYPE_1 event = new TYPE_1 ( VAR_1 , VAR_2 ) ; event . VAR_3 ( VAR_4 ) ; assertTrue ( VAR_5 ) ; <START> VAR_5 = false ; <END> } 
public TYPE_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , Optional < Long > VAR_4 , TYPE_5 VAR_5 , TYPE_6 VAR_6 ) { this ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , <START> VAR_6 , TYPE_7 . VAR_8 , <END> TYPE_1 . METHOD_1 ( VAR_5 . METHOD_2 ( ) ) , INT_1 ) ; } 
private void METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) { VAR_1 . METHOD_3 ( ) ; } <START> VAR_2 = true ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { final TYPE_3 VAR_3 = ( TYPE_3 ) ( VAR_1 . METHOD_2 ( VAR_4 ) ) ; TYPE_1 VAR_5 = null ; for ( TYPE_4 item : VAR_3 . METHOD_3 ( ) ) { final TYPE_1 VAR_6 = ( TYPE_1 ) item ; final String VAR_7 = TYPE_5 . METHOD_4 ( VAR_6 , TYPE_2 . VAR_8 ) ; <START> if ( ! TYPE_6 . equals ( VAR_2 . METHOD_5 ( ) , VAR_7 ) ) { <END> continue ; } VAR_5 = VAR_6 ; } return VAR_5 ; } 
<START> public TYPE_1 create ( ANNOTATION_1 TYPE_1 VAR_1 ) throws Exception { <END> TYPE_2 VAR_2 = TYPE_3 . to ( VAR_1 ) ; return get ( VAR_3 . create ( VAR_2 ) ) ; } 
public static String METHOD_1 ( ) { if ( TYPE_2 . TYPE_3 . METHOD_2 ( STRING_1 ) ) { <START> return TYPE_2 . TYPE_3 ; <END> } else { return STRING_2 ; } } 
protected void METHOD_1 ( TYPE_1 to , TYPE_1 from ) throws IOException { to . VAR_1 ( from . getName ( ) ) ; <START> to . VAR_2 ( from . VAR_3 ( ) ) ; <END> to . VAR_4 ( from . VAR_5 ( ) ) ; to . VAR_6 ( from . VAR_7 ( ) ) ; } 
public static TYPE_1 to ( ANNOTATION_1 TYPE_2 from ) { TYPE_1 to = new TYPE_1 ( ) ; if ( from . getId ( ) != null ) to . VAR_1 ( from . getId ( ) ) ; METHOD_1 ( to : : METHOD_2 , from . getName ( ) ) ; METHOD_1 ( to : : METHOD_3 , from . VAR_2 ( ) ) ; <START> METHOD_4 ( to : : METHOD_5 , from . VAR_3 ( ) , true ) ; <END> return to ; } 
<START> public static String METHOD_1 ( String index , int VAR_1 ) { <END> return index . substring ( 0 , VAR_1 ) ; } 
public ANNOTATION_1 List < TYPE_1 > list ( ) throws IOException { Collection < TYPE_2 > VAR_1 = VAR_2 . list ( ) ; <START> return VAR_1 . stream ( ) . map ( VAR_3 - > TYPE_3 . METHOD_1 ( VAR_3 ) ) . collect ( Collectors . VAR_4 ( ) ) ; <END> } 
public ANNOTATION_1 TYPE_1 METHOD_1 ( ANNOTATION_2 long VAR_1 , ANNOTATION_3 List < String > VAR_2 ) throws IOException { TYPE_2 VAR_3 = METHOD_2 ( VAR_1 ) ; for ( String position : VAR_2 ) { <START> VAR_3 . METHOD_3 ( ) . remove ( position ) ; <END> } VAR_4 . METHOD_4 ( VAR_3 ) ; return METHOD_5 ( VAR_1 ) ; } 
public String METHOD_1 ( TYPE_1 item , boolean VAR_1 ) { item . VAR_2 ( STRING_1 , STRING_1 ) ; <START> item . VAR_2 ( STRING_2 , STRING_2 ) ; <END> return VAR_1 ? STRING_3 : STRING_4 ; } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 Long VAR_1 , ANNOTATION_2 TYPE_1 VAR_2 ) throws IOException { if ( VAR_2 == null ) { log . error ( STRING_1 ) ; throw new TYPE_2 ( STRING_2 , Status . VAR_3 ) ; } TYPE_3 VAR_4 = TYPE_4 . to ( VAR_2 ) ; <START> VAR_4 . METHOD_2 ( VAR_5 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ) ; <END> VAR_4 . METHOD_5 ( VAR_1 ) ; VAR_6 . update ( VAR_4 ) ; return METHOD_6 ( VAR_1 ) ; } 
<START> public String METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = METHOD_2 ( ) . METHOD_3 ( TYPE_2 . METHOD_4 ( VAR_1 ) ) ; TYPE_1 VAR_3 = METHOD_5 ( ) ; VAR_2 . METHOD_6 ( ) ; METHOD_7 ( VAR_3 ) ; return METHOD_8 ( ) ; } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( TYPE_2 . id ( STRING_1 ) ) ; <START> if ( VAR_1 != null ) { <END> VAR_1 . METHOD_4 ( ) ; } else { throw new IllegalArgumentException ( STRING_2 ) ; } } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 , ANNOTATION_1 ( STRING_2 ) String query ) throws IOException { TYPE_2 VAR_2 = TYPE_2 . get ( VAR_1 ) ; return METHOD_2 ( 100 , <START> TYPE_3 . METHOD_3 ( VAR_2 ) , <END> TYPE_3 . query ( query ) ) ; } 
<START> public Long getId ( ) { <END> return VAR_1 ; } 
<START> public void setText ( String input , TYPE_1 element ) { <END> element . VAR_1 ( ) ; element . clear ( ) ; element . VAR_2 ( input ) ; element . VAR_2 ( TYPE_2 . VAR_4 ) ; } 
public boolean METHOD_1 ( ) { <START> return ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) && TYPE_1 . METHOD_4 ( VAR_2 , TYPE_2 . METHOD_5 ( ) ) . METHOD_6 ( ) < 10 ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { VAR_2 . METHOD_2 ( VAR_1 ) ; if ( VAR_3 != null ) { if ( ! VAR_3 . remove ( VAR_1 ) ) { throw new IOException ( STRING_1 ) ; } } else { <START> throw new IOException ( STRING_2 ) ; <END> } } 
public Map < String , Integer > METHOD_1 ( ) throws IOException { if ( VAR_1 != null ) { return VAR_1 . METHOD_2 ( ) ; } else { <START> throw new IOException ( STRING_1 ) ; <END> } } 
public TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 response ) throws IOException { Long id = VAR_3 . METHOD_2 ( TYPE_4 . to ( VAR_1 ) ) ; <START> TYPE_5 VAR_4 = VAR_2 . path ( STRING_1 ) . METHOD_3 ( id ) ; <END> response . VAR_5 ( STRING_2 , VAR_4 . METHOD_4 ( ) . toString ( ) ) ; return METHOD_5 ( id ) ; } 
public void METHOD_1 ( ) throws Exception { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> assertTrue ( VAR_1 . size ( ) > 0 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> assertTrue ( VAR_1 . size ( ) > 0 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 , STRING_1 , getId ( ) ) ) ; METHOD_4 ( TYPE_2 . METHOD_3 ( VAR_1 , STRING_2 , METHOD_5 ( ) ) ) ; if ( METHOD_6 ( ) != null ) { METHOD_7 ( TYPE_2 . METHOD_3 ( VAR_1 , STRING_3 , METHOD_6 ( ) ) ) ; } <START> METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_1 , STRING_4 , getId ( ) ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { if ( VAR_1 . METHOD_2 ( ) != null ) { VAR_1 . METHOD_3 ( VAR_2 . get ( VAR_1 . METHOD_2 ( ) . getId ( ) ) ) ; } <START> if ( VAR_1 . METHOD_4 ( ) != null && VAR_1 . METHOD_4 ( ) . getId ( ) != null ) { <END> VAR_1 . METHOD_5 ( VAR_3 . get ( VAR_1 . METHOD_4 ( ) . getId ( ) ) ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { TYPE_1 VAR_3 = VAR_4 . get ( VAR_1 . getId ( ) ) ; VAR_5 . METHOD_2 ( VAR_3 ) ; VAR_2 . METHOD_3 ( VAR_5 . METHOD_4 ( ) ) ; <START> if ( STRING_1 . equals ( VAR_2 . METHOD_5 ( ) . getName ( ) ) ) { <END> VAR_3 . METHOD_6 ( VAR_2 . METHOD_7 ( ) ) ; } VAR_6 . METHOD_8 ( VAR_2 ) ; VAR_4 . METHOD_8 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { <START> this . VAR_2 = ( TYPE_3 ) VAR_1 ; <END> } 
public TYPE_3 ( TYPE_1 user ) { if ( user != null ) { VAR_2 = new TYPE_2 ( user ) ; <START> METHOD_1 ( ) . METHOD_2 ( ) ; <END> } } 
public long METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { long id ; <START> if ( VAR_1 . getId ( ) == TYPE_2 . VAR_3 ) { <END> id = ( long ) METHOD_2 ( ) . METHOD_1 ( VAR_1 ) ; } else { METHOD_2 ( ) . update ( VAR_1 ) ; id = VAR_1 . getId ( ) ; } return id ; } 
public boolean METHOD_1 ( ) { <START> return VAR_1 == VAR_2 ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( VAR_3 ) ; <START> VAR_1 . METHOD_4 ( VAR_4 ) ; <END> VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ; VAR_1 . METHOD_7 ( VAR_5 ) ; VAR_1 . METHOD_8 ( VAR_6 ) ; METHOD_9 ( VAR_1 ) ; } 
public TYPE_1 get ( long id ) throws IOException { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_1 ( ) . get ( TYPE_2 . class , id ) ; TYPE_1 VAR_2 = METHOD_2 ( id ) ; if ( VAR_2 != null ) { <START> VAR_1 . METHOD_3 ( VAR_2 ) ; <END> } return VAR_1 ; } 
public void METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) { this . VAR_1 = null ; } else { try { TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; this . VAR_1 = ( VAR_2 != null ? VAR_2 . METHOD_3 ( ) : null ) ; } catch ( IOException e ) { log . error ( STRING_1 + VAR_1 , e ) ; <START> this . VAR_1 = null ; <END> } } } 
public int METHOD_1 ( ) { return new TYPE_1 ( 5 , INT_1 ) . append ( VAR_1 ) . append ( description ) . append ( VAR_2 ) <START> . append ( VAR_3 . getId ( ) ) <END> . append ( VAR_4 ) . METHOD_2 ( ) ; } 
private void METHOD_1 ( ) { if ( VAR_1 != null ) VAR_1 . METHOD_2 ( VAR_2 ) ; if ( VAR_3 != null ) VAR_3 . METHOD_3 ( VAR_2 ) ; <START> if ( VAR_4 != null ) VAR_4 . METHOD_4 ( VAR_5 ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( STRING_1 ) ; <START> VAR_1 . METHOD_3 ( INT_1 ) ; <END> return VAR_1 ; } 
public Collection < String > METHOD_1 ( ) throws IOException { Collection < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( VAR_1 . size ( ) > 0 ) { <START> return TYPE_1 . METHOD_3 ( VAR_2 . METHOD_2 ( ) ) ; <END> } else { return VAR_2 . METHOD_4 ( ) ; } } 
public Collection < TYPE_1 > METHOD_1 ( String VAR_1 ) throws IOException { TYPE_2 VAR_2 = METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) ; VAR_2 . add ( TYPE_3 . METHOD_4 ( TYPE_3 . METHOD_5 ( STRING_1 , VAR_1 + STRING_2 ) , TYPE_3 . METHOD_5 ( STRING_3 , VAR_1 + STRING_2 ) , <START> TYPE_3 . METHOD_5 ( STRING_4 , VAR_1 + STRING_2 ) ) ) ; <END> ANNOTATION_1 ( STRING_5 ) List < TYPE_1 > VAR_3 = VAR_2 . list ( ) ; return METHOD_6 ( VAR_3 ) ; } 
private void METHOD_1 ( ) { if ( VAR_1 != null ) VAR_1 . METHOD_2 ( VAR_2 ) ; <START> METHOD_3 ( ) ; <END> } 
public Integer METHOD_1 ( ) { <START> Integer VAR_1 = 0 ; <END> for ( TYPE_1 child : METHOD_2 ( ) ) { if ( child instanceof TYPE_2 && ( ( TYPE_2 ) child ) . METHOD_3 ( ) != null ) { VAR_1 += ( ( TYPE_2 ) child ) . METHOD_3 ( ) ; } } return ( METHOD_4 ( ) - METHOD_5 ( ) - VAR_1 ) ; } 
public String METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) throws IOException { TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 . get ( STRING_1 ) ) ; TYPE_3 VAR_3 = new TYPE_3 ( ) ; for ( int i = 0 ; i < VAR_2 . size ( ) ; ++ i ) { VAR_3 . append ( VAR_2 . METHOD_3 ( i ) ) ; <START> if ( i + 1 < VAR_2 . size ( ) ) { <END> VAR_3 . append ( STRING_2 ) ; } } return STRING_3 + VAR_3 . toString ( ) ; } 
public static TYPE_1 to ( TYPE_2 from ) { TYPE_1 to = new TYPE_3 ( ) ; to . VAR_1 ( from . VAR_2 ( ) ) ; to . VAR_3 ( from . VAR_4 ( ) ) ; to . VAR_5 ( from . VAR_6 ( ) ) ; to . VAR_7 ( from . VAR_8 ( ) ) ; to . VAR_9 ( from . VAR_10 ( ) ) ; to . VAR_5 ( from . VAR_6 ( ) ) ; <START> return to ; <END> } 
public String toString ( ) { return STRING_1 + VAR_1 + STRING_2 + VAR_2 + STRING_3 + VAR_3 + STRING_4 + VAR_4 + STRING_5 + VAR_5 + STRING_6 + id + STRING_7 + VAR_6 + STRING_8 + VAR_7 + STRING_9 + VAR_8 + STRING_10 + VAR_9 + STRING_11 + VAR_10 + STRING_12 + url + STRING_13 ; <START> } <END> 
private TYPE_1 METHOD_1 ( TYPE_2 project , TYPE_3 user ) { TYPE_1 VAR_1 ; VAR_1 = new TYPE_4 ( ) ; VAR_1 . METHOD_2 ( project ) ; VAR_1 . METHOD_3 ( 0 ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; VAR_1 . METHOD_5 ( user ) ; VAR_1 . METHOD_6 ( user ) ; VAR_1 . METHOD_7 ( new Date ( ) ) ; <START> VAR_1 . METHOD_8 ( new Date ( ) ) ; <END> METHOD_9 ( VAR_1 ) ; return VAR_1 ; } 
public static String METHOD_1 ( String path ) { String result = "" ; TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 . class . METHOD_2 ( ) . METHOD_3 ( path ) ) ; while ( VAR_1 . METHOD_4 ( ) ) { result += VAR_1 . METHOD_5 ( ) ; } <START> VAR_1 . close ( ) ; <END> return result ; } 
private static TYPE_1 METHOD_1 ( final Context context ) { <START> if ( context == null ) { <END> return null ; } else if ( context instanceof TYPE_1 ) { return ( TYPE_1 ) context ; } else if ( context instanceof TYPE_2 ) { return METHOD_1 ( ( ( TYPE_2 ) context ) . METHOD_2 ( ) ) ; } return null ; } 
<START> public static TYPE_1 [ ] METHOD_1 ( ) { <END> final List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; for ( final TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_2 ( ) ) { VAR_1 . add ( VAR_2 ) ; } } return VAR_1 . METHOD_3 ( new TYPE_1 [ VAR_1 . size ( ) ] ) ; } 
public boolean METHOD_1 ( final TYPE_1 item ) { <START> switch ( item . VAR_1 ( ) ) { <END> case VAR_2 . R . id . VAR_3 : METHOD_2 ( ) ; return true ; } return false ; } 
static List < TYPE_1 > METHOD_1 ( ) { final List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; int VAR_2 = 0 ; TYPE_1 [ ] VAR_3 = null ; <START> while ( VAR_3 == null || VAR_3 . length == VAR_4 ) { <END> VAR_3 = METHOD_2 ( STRING_1 + VAR_4 + STRING_2 + VAR_2 , TYPE_1 [ ] . class ) . METHOD_3 ( ) ; VAR_1 . addAll ( Arrays . asList ( VAR_3 ) ) ; VAR_2 += VAR_4 ; } return VAR_1 ; } 
public void METHOD_1 ( ) { if ( VAR_1 >= 0 ) { <START> METHOD_2 ( VAR_1 + 1 ) ; <END> } } 
public static TYPE_1 METHOD_1 ( final String VAR_1 ) throws TYPE_2 { TYPE_1 VAR_2 = null ; if ( VAR_1 != null ) { VAR_2 = new TYPE_1 ( new TYPE_3 ( VAR_1 ) ) ; } <START> return VAR_2 ; <END> } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> VAR_1 . put ( STRING_1 , type . VAR_2 ( ) ) ; VAR_1 . put ( STRING_2 , VAR_3 ) ; VAR_1 . put ( STRING_3 , VAR_4 ) ; VAR_1 . put ( STRING_4 , VAR_5 ) ; return VAR_1 ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> VAR_1 . add ( VAR_2 ) ; VAR_3 . add ( VAR_4 ) ; VAR_5 . add ( VAR_4 ) ; final Set < TYPE_1 > VAR_6 = TYPE_2 . METHOD_2 ( VAR_7 ) ; assertThat ( VAR_6 . size ( ) ) . METHOD_3 ( 0 ) ; assertThat ( VAR_6 . contains ( VAR_8 ) ) . METHOD_4 ( ) ; assertThat ( VAR_6 . contains ( VAR_9 ) ) . METHOD_4 ( ) ; assertThat ( VAR_6 . contains ( VAR_10 ) ) . METHOD_4 ( ) ; } 
private void METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( cache ) . METHOD_3 ( cache , VAR_1 ) ) { if ( VAR_2 > 0 ) { VAR_3 . METHOD_4 ( View . VAR_4 ) ; <START> VAR_3 . setText ( getString ( R . string . VAR_5 , String . valueOf ( VAR_2 ) ) ) ; <END> } } else { VAR_3 . METHOD_4 ( View . VAR_6 ) ; } } 
<START> private void METHOD_1 ( ) { <END> METHOD_2 ( TYPE_6 . VAR_2 ) ; TYPE_1 . METHOD_3 ( this ) ; res = this . METHOD_4 ( ) ; VAR_3 = ( TYPE_2 ) this . METHOD_5 ( ) ; TYPE_3 . METHOD_6 ( TYPE_4 . METHOD_7 ( ) ) ; TYPE_5 . METHOD_8 ( this , VAR_4 ) ; } 
protected TYPE_1 METHOD_1 ( ) throws IOException { try { return VAR_1 . METHOD_2 ( uri ) ; } catch ( final TYPE_2 e ) { if ( uri . toString ( ) . startsWith ( STRING_1 ) ) { return TYPE_3 . METHOD_3 ( TYPE_3 . METHOD_4 ( uri . toString ( ) ) ) ; } <START> Log . e ( STRING_2 + uri ) ; <END> } return null ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { if ( VAR_2 == null ) { VAR_2 = new ArrayList < TYPE_1 > ( ) ; } <START> Boolean VAR_3 = false ; <END> for ( final TYPE_1 VAR_4 : VAR_2 ) { if ( VAR_4 . METHOD_2 ( ) . equals ( VAR_1 . METHOD_2 ( ) ) ) { VAR_3 = true ; VAR_4 . METHOD_3 ( VAR_1 ) ; break ; } } if ( ! VAR_3 ) { VAR_2 . add ( VAR_1 ) ; } VAR_5 = VAR_2 . size ( ) ; } 
public TYPE_1 ( ) { this . VAR_2 = null ; <START> this . list = null ; <END> } 
public static List < TYPE_1 > parse ( final TYPE_2 page ) { try { <START> TYPE_3 VAR_1 = TYPE_3 . METHOD_1 ( ) ; <END> TYPE_4 VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_5 VAR_3 = VAR_2 . METHOD_3 ( ) ; final TYPE_6 VAR_4 = new TYPE_6 ( ) ; VAR_3 . METHOD_4 ( VAR_4 ) ; VAR_3 . parse ( page ) ; return VAR_4 . METHOD_5 ( ) ; } catch ( final Exception e ) { Log . VAR_5 ( STRING_1 , e ) ; } return null ; } 
<START> public static boolean METHOD_1 ( final List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 ) { <END> if ( VAR_2 != null && ! VAR_2 . isEmpty ( ) ) { for ( final TYPE_1 log : VAR_2 ) { if ( VAR_1 . contains ( log ) ) { VAR_1 . get ( VAR_1 . METHOD_2 ( log ) ) . VAR_3 = true ; } else { log . VAR_3 = true ; VAR_1 . add ( log ) ; } } return true ; } return false ; } 
public TYPE_1 METHOD_1 ( final String VAR_1 , final String VAR_2 , final TYPE_2 VAR_3 ) { TYPE_2 . METHOD_2 ( VAR_3 , R . string . VAR_4 ) ; final TYPE_3 cache = TYPE_4 . METHOD_3 ( VAR_1 ) ; <START> if ( cache == null ) { <END> return null ; } final TYPE_1 VAR_5 = new TYPE_1 ( cache ) ; return VAR_5 ; } 
public final TYPE_1 METHOD_1 ( final TYPE_2 cache , final TYPE_3 VAR_1 , final TYPE_4 VAR_2 , final String log , final String VAR_3 , final List < TYPE_5 > VAR_4 ) { <START> final TYPE_1 result = TYPE_6 . METHOD_1 ( cache , VAR_1 , VAR_2 , log ) ; <END> return result ; } 
public static String METHOD_1 ( ANNOTATION_1 final TYPE_1 response ) { if ( response == null ) { return null ; } <START> return METHOD_2 ( response , false ) ; <END> } 
public void METHOD_1 ( TYPE_1 < String > VAR_1 , String page ) { if ( page == null ) { VAR_2 = true ; } else { VAR_3 = TYPE_2 . METHOD_2 ( page ) ; VAR_4 = TYPE_3 . METHOD_3 ( page ) ; VAR_5 = TYPE_3 . METHOD_4 ( page ) ; <START> if ( VAR_5 . isEmpty ( ) ) { <END> VAR_2 = true ; } else { VAR_2 = false ; } } VAR_6 . METHOD_1 ( ) ; } 
public static void METHOD_1 ( String [ ] VAR_1 ) { ArrayList < String > VAR_2 = new ArrayList < String > ( ) ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { VAR_2 . add ( VAR_1 [ i ] ) ; } METHOD_2 ( VAR_2 , 0 ) ; <START> } <END> 
public TYPE_1 METHOD_1 ( ) { VAR_1 = true ; if ( VAR_2 == null ) { VAR_2 = METHOD_2 ( ) ; } else { TYPE_1 VAR_3 = new TYPE_1 ( VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <START> VAR_3 . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ; <END> VAR_2 = TYPE_2 . METHOD_7 ( VAR_3 , TYPE_3 . METHOD_8 ( ) , this ) ; } VAR_1 = false ; return VAR_2 ; } 
public boolean METHOD_1 ( ) { <START> return ! METHOD_2 ( ) . METHOD_3 ( ) <END> && null != TYPE_1 . METHOD_4 ( ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return true ; } <START> return false ; <END> } 
<START> public synchronized void METHOD_1 ( ) { <END> VAR_1 = true ; } 
public VAR_1 ( final TYPE_1 VAR_2 , TYPE_2 VAR_3 , final TYPE_3 VAR_4 , final TYPE_4 VAR_5 ) { super ( VAR_2 ) ; context = VAR_2 ; VAR_6 = VAR_3 ; VAR_7 = VAR_5 ; if ( VAR_4 != null ) { VAR_8 = VAR_4 ; } else if ( VAR_7 != null && VAR_7 . VAR_9 != null && VAR_7 . VAR_10 != null ) { VAR_8 = new TYPE_3 ( VAR_7 . VAR_9 , VAR_7 . VAR_10 ) ; } else { <START> VAR_8 = new TYPE_3 ( ) ; <END> } } 
protected TYPE_1 METHOD_1 ( String query ) throws TYPE_2 { <START> return ( connection . VAR_1 ( query ) ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> TYPE_1 d = METHOD_2 ( ) ; d . get ( STRING_1 ) ; try { TYPE_2 VAR_1 = d . VAR_2 ( TYPE_3 . METHOD_3 ( STRING_2 ) ) ; METHOD_4 ( ) ; } catch ( TYPE_4 e ) { } } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { try { <START> VAR_1 . getMessage ( ) . toString ( ) ; <END> final TYPE_2 m = TYPE_2 . METHOD_2 ( ) ; m . VAR_2 = VAR_3 ; m . obj = VAR_1 ; VAR_4 . METHOD_3 ( m ) ; } catch ( TYPE_3 e ) { TYPE_4 . e ( VAR_5 , STRING_1 , e ) ; } } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; <START> VAR_1 . METHOD_2 ( STRING_3 , STRING_4 ) ; <END> VAR_2 . METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_3 , METHOD_5 ( ) ) . METHOD_6 ( METHOD_7 ( Integer . VAR_4 ) ) ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; TYPE_2 VAR_2 = VAR_3 . METHOD_3 ( VAR_1 ) ; <START> METHOD_4 ( VAR_4 ) . METHOD_5 ( METHOD_6 ( ) ) ; <END> assertEquals ( VAR_2 . METHOD_7 ( ) , TYPE_3 . TYPE_4 . VAR_7 ) ; } 
protected TYPE_1 METHOD_1 ( String url ) { TYPE_2 is = new TYPE_2 ( context , STRING_1 ) ; try { TYPE_1 VAR_1 = is . VAR_2 ( url ) ; <START> return VAR_1 ; <END> } catch ( TYPE_2 . TYPE_4 e ) { return null ; } } 
protected void METHOD_1 ( TYPE_1 data ) { <START> if ( TYPE_2 . VAR_2 . VAR_3 >= TYPE_2 . VAR_4 . VAR_5 && data . VAR_6 > 0 ) { <END> builder . VAR_7 ( data . VAR_6 ) ; } } 
<START> protected TYPE_1 METHOD_1 ( TYPE_2 uri ) { <END> return new TYPE_1 ( TYPE_1 . VAR_1 , uri ) ; } 
public double METHOD_1 ( final String VAR_1 ) { final long VAR_2 = System . currentTimeMillis ( ) ; long VAR_3 ; synchronized ( VAR_4 ) { <START> VAR_3 = VAR_4 . get ( VAR_1 ) ; <END> } return ( double ) ( ( VAR_2 - VAR_3 ) / INT_1 ) ; } 
private boolean METHOD_1 ( ) { return TYPE_7 . TYPE_9 . startsWith ( STRING_1 ) <START> || TYPE_7 . TYPE_9 . startsWith ( STRING_2 ) <END> || TYPE_7 . TYPE_12 . contains ( STRING_3 ) || TYPE_7 . TYPE_12 . contains ( STRING_4 ) || TYPE_7 . TYPE_12 . contains ( STRING_5 ) || TYPE_7 . TYPE_13 . contains ( STRING_6 ) || ( TYPE_7 . TYPE_11 . startsWith ( STRING_1 ) && TYPE_7 . TYPE_10 . startsWith ( STRING_1 ) ) || STRING_3 . equals ( TYPE_7 . TYPE_8 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_2 VAR_2 = METHOD_2 ( ) ; final TYPE_2 . TYPE_4 VAR_3 = VAR_2 . METHOD_3 ( ) ; <START> if ( VAR_1 != null ) { <END> VAR_3 . METHOD_4 ( VAR_4 , VAR_1 . toString ( ) ) ; } else { VAR_3 . remove ( VAR_4 ) ; } VAR_3 . apply ( ) ; METHOD_5 ( ) ; } 
public TYPE_7 ( String token , TYPE_1 listener , TYPE_2 VAR_2 ) { VAR_3 = token ; VAR_4 = listener ; VAR_5 = VAR_2 ; VAR_6 = null ; VAR_7 = new TYPE_3 < TYPE_4 > ( ) ; VAR_8 = new TYPE_3 < TYPE_5 > ( ) ; VAR_9 = new HashSet < Integer > ( ) ; VAR_10 = new HashSet < Integer > ( ) ; <START> if ( VAR_11 == null ) { <END> VAR_11 = new TYPE_6 ( ) ; } } 
public String METHOD_1 ( ) { String VAR_1 = null ; try { VAR_1 = ( String ) VAR_2 ; <START> } catch ( TYPE_1 VAR_3 ) { <END> ; } try { VAR_1 = ( String ) value ; } catch ( TYPE_1 e ) { ; } return VAR_1 ; } 
public void run ( ) { if ( ! VAR_1 ) { return ; } final View VAR_2 = VAR_3 . get ( ) ; if ( null == VAR_2 || VAR_4 ) { METHOD_1 ( ) ; return ; } try { VAR_5 . METHOD_2 ( VAR_2 ) ; } catch ( TYPE_2 . TYPE_3 e ) { METHOD_1 ( ) ; <START> throw e ; <END> } VAR_6 . METHOD_3 ( this ) ; VAR_6 . METHOD_4 ( this , INT_1 ) ; } 
public void METHOD_1 ( View VAR_1 ) { <START> if ( VAR_2 ) { <END> super . METHOD_2 ( ) . METHOD_3 ( VAR_1 , super . getPath ( ) , this ) ; } } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <END> METHOD_2 ( VAR_1 ) ; } 
public static TYPE_1 getInstance ( Context context , String token ) { TYPE_1 instance = VAR_1 . get ( token ) ; if ( instance == null ) { instance = new TYPE_1 ( context . VAR_2 ( ) , token ) ; VAR_1 . put ( token , instance ) ; } <START> instance . VAR_3 . METHOD_1 ( ) . METHOD_2 ( STRING_1 , token ) . commit ( ) ; <END> return instance ; } 
<START> public void METHOD_1 ( List < String > properties ) { <END> this . properties = properties ; } 
private String METHOD_1 ( TYPE_1 in ) { try { TYPE_2 result = new TYPE_2 ( ) ; byte [ ] buffer = new byte [ INT_1 ] ; int length ; <START> while ( ( length = in . read ( buffer ) ) != - 1 ) { <END> result . write ( buffer , 0 , length ) ; } return result . toString ( TYPE_6 . TYPE_5 . name ( ) ) ; } catch ( IOException e ) { throw new TYPE_4 ( e ) ; } } 
<START> private TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) throws Exception { <END> TYPE_4 VAR_2 = new TYPE_5 ( ) ; VAR_2 . METHOD_2 ( new TYPE_6 ( ) ) ; return VAR_2 . METHOD_3 ( VAR_1 ) . METHOD_4 ( ( ) - > VAR_1 . VAR_3 . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { VAR_1 . clear ( ) ; for ( int i = 0 ; i < VAR_3 . size ( ) ; i ++ ) { long time = VAR_3 . get ( i ) ; if ( VAR_2 . METHOD_2 ( time ) ) { <START> VAR_1 . add ( new TYPE_3 ( key . VAR_4 ( ) , time ) , values . get ( i ) ) ; <END> } } } 
private synchronized void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ( ) - > METHOD_3 ( ) , VAR_2 , TimeUnit . VAR_3 ) ; <END> VAR_2 = Math . VAR_4 ( VAR_5 , ( long ) ( FLOAT_1 * VAR_2 ) + ( long ) ( VAR_2 * Math . VAR_6 ( ) ) ) ; } 
private synchronized void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ( ) - > METHOD_3 ( ) , 0 , TimeUnit . VAR_2 ) ; <END> } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws Exception { <END> if ( VAR_3 < VAR_2 . METHOD_2 ( ) ) { METHOD_3 ( VAR_1 ) ; } else { METHOD_4 ( ) . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ; METHOD_7 ( VAR_1 , VAR_2 . METHOD_6 ( ) ) ; } } 
<START> public TYPE_1 < TYPE_2 > METHOD_1 ( Collection < TYPE_3 > VAR_1 ) { <END> if ( VAR_1 . size ( ) == 0 ) { return TYPE_4 . METHOD_2 ( null ) ; } TYPE_5 < TYPE_2 > VAR_2 = TYPE_5 . create ( VAR_3 , null ) ; try { TYPE_6 VAR_4 = new TYPE_6 ( VAR_1 , VAR_2 ) ; VAR_5 . put ( VAR_4 ) ; return VAR_2 ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 , int value ) { <END> TYPE_2 . METHOD_2 ( value > 0 , VAR_1 + STRING_1 ) ; METHOD_3 ( VAR_1 , value ) ; return this ; } 
public static String METHOD_1 ( String VAR_1 ) { int VAR_2 = VAR_1 . METHOD_2 ( STRING_1 ) ; if ( VAR_2 != - 1 ) { <START> return VAR_1 . substring ( VAR_2 ) ; <END> } return STRING_1 ; } 
public TYPE_1 put ( TYPE_2 VAR_1 , TYPE_3 value ) { <START> TYPE_4 . put ( null , VAR_2 , VAR_1 , TYPE_6 . VAR_4 | 0 , value . VAR_5 ( ) ) ; <END> TYPE_4 . put ( null , VAR_2 , VAR_1 , TYPE_6 . VAR_6 | 1 , TYPE_5 . METHOD_1 ( 0 , false , false ) ) ; return this ; } 
public Long METHOD_1 ( ) { <START> synchronized ( status ) { <END> TYPE_1 . METHOD_2 ( status != TYPE_2 . VAR_2 , STRING_1 ) ; if ( ( status == TYPE_2 . VAR_3 ) && ( node == null ) ) { Long VAR_4 = METHOD_3 ( ) ; if ( node == null ) { METHOD_4 ( VAR_4 ) ; } } Long VAR_5 = METHOD_3 ( ) ; VAR_6 . add ( VAR_5 ) ; status = TYPE_2 . VAR_7 ; return VAR_5 ; } } 
public long METHOD_1 ( ) { synchronized ( this ) { TYPE_1 . METHOD_2 ( status != TYPE_2 . VAR_2 , STRING_1 ) ; if ( ( status == TYPE_2 . VAR_3 ) && ( node == null ) ) { Long VAR_4 = METHOD_3 ( ) ; if ( node == null ) { METHOD_4 ( VAR_4 ) ; } } } long VAR_5 = METHOD_3 ( ) ; synchronized ( this ) { <START> VAR_6 . add ( VAR_5 ) ; <END> status = TYPE_2 . VAR_7 ; } return VAR_5 ; } 
<START> public void METHOD_1 ( ) throws TYPE_1 { <END> commit ( ) ; close ( ) ; } 
public boolean METHOD_1 ( Long VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( VAR_1 ) != null ) <END> return false ; return cache . VAR_3 ( TYPE_1 . METHOD_3 ( config , VAR_1 ) ) != null ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> if ( VAR_1 ) { server . VAR_2 ( ) ; VAR_3 . METHOD_2 ( ) ; VAR_1 = false ; VAR_4 = null ; if ( VAR_5 . METHOD_3 ( ) . equals ( TYPE_1 . VAR_7 ) ) { VAR_8 . METHOD_4 ( ) . METHOD_5 ( this ) ; VAR_8 . close ( ) ; VAR_9 . close ( ) ; VAR_5 . METHOD_6 ( ) . METHOD_5 ( this ) ; VAR_5 . close ( ) ; } log . info ( STRING_1 ) ; } } 
public static String METHOD_1 ( final TYPE_1 config , final TYPE_2 client , final String VAR_1 , final String VAR_2 ) { if ( STRING_1 . equals ( VAR_2 ) ) { if ( TYPE_3 . METHOD_2 ( METHOD_3 ( config , client ) ) ) { return METHOD_4 ( config , VAR_1 ) ; } else { throw new TYPE_4 ( STRING_2 ) ; } } <START> return TYPE_5 . METHOD_5 ( config , VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { <START> final TYPE_1 VAR_1 = TYPE_1 . VAR_2 ; <END> final TYPE_1 VAR_3 = TYPE_1 . VAR_4 ; final TYPE_1 VAR_5 = TYPE_1 . VAR_6 ; final TYPE_1 VAR_7 = TYPE_1 . METHOD_2 ( STRING_1 ) ; final TYPE_1 VAR_8 = TYPE_1 . METHOD_2 ( STRING_2 ) ; final TYPE_1 VAR_9 = TYPE_1 . METHOD_2 ( STRING_3 ) ; Assert . assertEquals ( VAR_7 , VAR_1 ) ; Assert . assertEquals ( VAR_8 , VAR_3 ) ; Assert . assertEquals ( VAR_9 , VAR_5 ) ; } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { final Iterator < TYPE_2 > i = TYPE_3 . iterator ( ) ; <START> while ( i . hasNext ( ) ) { <END> final TYPE_2 VAR_1 = i . next ( ) ; METHOD_2 ( VAR_1 ) ; } } 
void METHOD_1 ( final String VAR_1 , final TYPE_1 VAR_2 , final Integer VAR_3 ) throws IOException { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; String path = METHOD_3 ( VAR_1 ) ; <START> if ( VAR_3 == null ) { <END> LOG . debug ( STRING_2 , path ) ; VAR_4 . METHOD_4 ( path , VAR_2 ) ; } else { TYPE_3 . METHOD_5 ( this , VAR_2 , path , VAR_3 ) ; } } 
<START> private static long [ ] METHOD_1 ( final Long [ ] VAR_1 , <END> final TYPE_1 VAR_2 ) { final long VAR_3 = VAR_2 . METHOD_2 ( ) ; final long VAR_4 ; final long VAR_5 ; if ( VAR_1 [ 0 ] == null ) { VAR_4 = INT_1 ; } else { VAR_4 = VAR_1 [ 0 ] ; } if ( VAR_1 [ 1 ] == null ) { VAR_5 = VAR_3 ; } else { VAR_5 = VAR_1 [ 1 ] ; } return new long [ ] { VAR_4 , VAR_5 } ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; int iterator , VAR_2 ; <START> Object VAR_3 ; <END> for ( iterator = VAR_4 . length - 1 ; iterator > 0 ; iterator -- ) { VAR_2 = VAR_1 . METHOD_2 ( iterator ) ; VAR_3 = VAR_4 [ iterator ] ; VAR_4 [ iterator ] = VAR_4 [ VAR_2 ] ; VAR_4 [ VAR_2 ] = VAR_3 ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 . class , new TYPE_3 ( 1 , INT_1 ) ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; assertNotNull ( STRING_1 , VAR_2 ) ; assertTrue ( STRING_2 , VAR_2 instanceof TYPE_2 ) ; <START> assertTrue ( new TYPE_2 ( STRING_3 ) . METHOD_3 ( VAR_2 ) != 1 ) ; <END> assertTrue ( new TYPE_2 ( STRING_4 ) . METHOD_3 ( VAR_2 ) != - 1 ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = <START> new TYPE_2 . Builder ( ) . METHOD_2 ( METHOD_3 ( STRING_1 ) ) <END> . METHOD_2 ( METHOD_3 ( STRING_2 ) ) . METHOD_2 ( METHOD_3 ( STRING_3 ) ) . METHOD_2 ( METHOD_3 ( STRING_4 ) ) . METHOD_2 ( METHOD_3 ( STRING_5 ) ) . METHOD_2 ( METHOD_3 ( STRING_6 ) ) . METHOD_2 ( METHOD_3 ( STRING_7 ) ) . build ( ) ; TYPE_3 . METHOD_4 ( VAR_1 ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , int x , int y , int VAR_2 ) { for ( TYPE_2 element : VAR_3 ) { <START> if ( ! TYPE_4 . VAR_5 . METHOD_2 ( VAR_1 , new TYPE_3 ( + element . x , y + element . y , VAR_2 + element . VAR_2 ) ) ) <END> return false ; } return true ; } 
private void METHOD_1 ( Path from , Path to ) throws IOException { try { <START> TYPE_1 . METHOD_2 ( from , to , TYPE_3 . VAR_2 ) ; <END> } catch ( TYPE_2 e ) { TYPE_1 . METHOD_2 ( from , to , TYPE_3 . VAR_3 ) ; } } 
public boolean METHOD_1 ( char VAR_1 , int VAR_2 ) { if ( METHOD_2 ( ) && this . METHOD_3 ( ) && VAR_1 == CHAR_1 ) { return true ; <START> METHOD_4 ( false ) ; <END> } return super . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! METHOD_2 ( ) ) { return ; } <END> String VAR_2 = ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; if ( TYPE_3 . containsKey ( VAR_2 ) ) { METHOD_6 ( VAR_1 , String . format ( STRING_1 , VAR_2 , TYPE_3 . get ( VAR_2 ) ) ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( METHOD_2 ( VAR_1 , VAR_2 ) && TYPE_2 . METHOD_3 ( VAR_1 ) && METHOD_4 ( VAR_1 . METHOD_5 ( ) . get ( 0 ) ) ) { <END> this . VAR_3 = true ; } super . METHOD_1 ( VAR_1 ) ; } 
protected List < TYPE_1 > METHOD_1 ( ) { return Collections . VAR_1 ( TYPE_1 . create ( ) <START> . METHOD_2 ( TYPE_2 . is ( STRING_1 ) ) <END> . name ( STRING_2 ) . METHOD_3 ( ) ) ; } 
private void METHOD_1 ( Type VAR_1 , TYPE_1 node ) { if ( METHOD_2 ( VAR_1 ) ) { <START> String message = STRING_1 + STRING_2 + VAR_1 + STRING_2 + STRING_3 ; <END> METHOD_3 ( node , message ) ; } } 
<START> private void METHOD_1 ( ANNOTATION_1 TYPE_1 node ) { <END> if ( node == null ) { return ; } VAR_1 . stream ( ) . filter ( VAR_2 - > VAR_2 . VAR_3 . equals ( node . name ( ) ) ) . map ( VAR_2 - > VAR_2 . VAR_4 ) . METHOD_2 ( ) . METHOD_3 ( VAR_5 - > { VAR_5 . VAR_6 . add ( node ) ; node . VAR_5 = VAR_5 ; } ) ; } 
private void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , TYPE_2 node ) { if ( VAR_1 == null ) { return ; } <START> VAR_2 . VAR_3 . put ( VAR_2 . METHOD_2 ( VAR_1 ) , node ) ; <END> } 
<START> public List < String > METHOD_1 ( ) { <END> if ( null == VAR_1 ) { synchronized ( this ) { if ( null == this . VAR_1 ) { VAR_1 = new ArrayList < > ( ) ; VAR_1 . add ( STRING_1 ) ; System . out . println ( ) ; VAR_1 . add ( STRING_2 ) ; } } } return VAR_1 ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return Optional . VAR_2 ( VAR_1 ) . filter ( t - > t . is ( TYPE_4 . VAR_4 ) ) . map ( t - > ( ( TYPE_3 ) t ) . METHOD_1 ( ) ) . METHOD_2 ( null ) ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <START> TYPE_1 VAR_3 = VAR_1 ; <END> if ( VAR_3 . is ( TYPE_3 . VAR_5 ) ) { TYPE_2 VAR_6 = ( TYPE_2 ) VAR_3 ; List < TYPE_1 > VAR_7 = VAR_6 . METHOD_2 ( ) ; VAR_3 = VAR_7 . size ( ) == VAR_2 ? VAR_7 . get ( 0 ) : null ; } return VAR_3 ; } 
public List < TYPE_2 . TYPE_3 > METHOD_1 ( ) { <START> return ImmutableList . of ( TYPE_2 . TYPE_3 . VAR_1 , TYPE_2 . TYPE_3 . VAR_2 ) ; <END> } 
private boolean METHOD_1 ( ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> return false ; } return VAR_1 . stream ( ) . METHOD_2 ( VAR_2 - > METHOD_3 ( VAR_2 ) && METHOD_4 ( VAR_2 ) ) ; } 
public void METHOD_1 ( final TYPE_1 context ) { this . context = context ; VAR_1 . clear ( ) ; VAR_2 . clear ( ) ; VAR_3 . METHOD_2 ( false ) ; VAR_4 . METHOD_2 ( false ) ; METHOD_3 ( context . VAR_5 ( ) ) ; VAR_4 . METHOD_4 ( ) ; VAR_3 . METHOD_4 ( ) ; VAR_1 . clear ( ) ; <START> VAR_2 . clear ( ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . get ( 0 ) ; String VAR_3 = TYPE_3 . METHOD_3 ( VAR_2 ) ; <START> if ( VAR_3 != null && ! VAR_3 . substring ( 1 ) . contains ( STRING_1 ) ) { <END> METHOD_4 ( VAR_2 , STRING_2 ) ; } } 
void TYPE_1 ( String VAR_1 ) { <START> TYPE_1 VAR_2 = new TYPE_2 ( STRING_1 , STRING_2 ) ; <END> VAR_2 . METHOD_1 ( STRING_3 ) ; VAR_2 . METHOD_1 ( STRING_4 ) ; VAR_2 . METHOD_1 ( VAR_1 ) ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( ! METHOD_2 ( VAR_1 ) ) { super . METHOD_1 ( VAR_1 ) ; } } 
<START> protected static boolean METHOD_1 ( Type type ) { <END> return ( ( TYPE_1 ) type ) . METHOD_2 ( TYPE_1 . VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . is ( TYPE_3 . TYPE_2 . VAR_4 ) ) { <END> METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; } super . METHOD_1 ( VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 file ) { TYPE_2 VAR_1 = METHOD_2 ( VAR_2 , file . VAR_3 ( ) ) ; <START> return ( VAR_1 . METHOD_3 ( ) == 0 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . name ( ) . equals ( VAR_2 . name ( ) ) ) { <END> VAR_3 = true ; } } 
protected List < TYPE_1 > METHOD_1 ( ) { return ImmutableList . of ( TYPE_1 . create ( ) <START> . METHOD_2 ( TYPE_2 . is ( STRING_1 ) ) <END> . name ( STRING_2 ) . METHOD_3 ( ) , TYPE_1 . create ( ) . METHOD_2 ( TYPE_2 . is ( STRING_3 ) ) . name ( STRING_4 ) . METHOD_3 ( ) ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_1 node ) { TYPE_1 VAR_1 = node ; <START> while ( true ) { <END> if ( VAR_1 instanceof TYPE_2 ) { return VAR_1 ; } VAR_1 = VAR_1 . parent ( ) ; } } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { for ( String s : VAR_2 . VAR_3 ) { VAR_1 . METHOD_2 ( TYPE_3 . valueOf ( s ) ) ; } <START> int [ ] VAR_4 = Arrays . stream ( VAR_2 . VAR_5 ) . map ( VAR_6 - > VAR_6 . substring ( 4 ) ) . METHOD_3 ( Integer : : valueOf ) . METHOD_4 ( ) ; <END> VAR_1 . METHOD_5 ( VAR_4 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { return ! METHOD_2 ( VAR_1 . METHOD_3 ( ) ) <START> && ! METHOD_4 ( VAR_1 ) <END> && ! METHOD_5 ( VAR_1 ) && ( TYPE_2 . METHOD_6 ( VAR_1 ) || TYPE_3 . METHOD_6 ( VAR_1 ) || ( METHOD_7 ( VAR_1 . METHOD_3 ( ) ) && ! TYPE_4 . METHOD_6 ( VAR_1 ) && METHOD_8 ( VAR_1 ) ) ) ; } 
private static List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { List < TYPE_1 > VAR_2 = VAR_1 . METHOD_2 ( ) . stream ( ) . map ( TYPE_1 : : of ) . collect ( Collectors . VAR_3 ( ) ) ; <START> return VAR_2 . stream ( ) . METHOD_3 ( TYPE_3 : : METHOD_4 ) ? VAR_2 : Collections . VAR_4 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String message , List < TYPE_3 > VAR_3 , ANNOTATION_1 Integer VAR_4 ) { <START> METHOD_2 ( VAR_1 ) ; <END> List < List < TYPE_3 > > VAR_5 = VAR_3 . stream ( ) . map ( Collections : : METHOD_3 ) . collect ( Collectors . VAR_6 ( ) ) ; METHOD_4 ( VAR_1 , VAR_2 , message , VAR_5 , VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , String message ) { <START> METHOD_2 ( VAR_1 ) ; <END> METHOD_1 ( VAR_1 , VAR_2 , message , ImmutableList . of ( ) , null ) ; } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( STRING_1 , new TYPE_2 ( ) ) ; <START> TYPE_1 . METHOD_3 ( STRING_1 , new TYPE_2 ( ) ) ; <END> } 
public void METHOD_1 ( ) { <START> assertThat ( STRING_1 , org . VAR_1 . VAR_2 . TYPE_1 . METHOD_2 ( STRING_2 ) ) ; <END> } 
void METHOD_1 ( ) { Math f = new Math ( ) { @Override <START> public String METHOD_2 ( int n ) { <END> return n == 0 ? 1 : 2 * METHOD_2 ( n - 1 ) ; } } ; } 
<START> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> while ( ! VAR_1 . is ( TYPE_2 . TYPE_3 . VAR_3 , TYPE_2 . TYPE_3 . VAR_4 ) ) { VAR_1 = VAR_1 . parent ( ) ; } if ( VAR_1 . is ( TYPE_2 . TYPE_3 . VAR_3 ) ) { return null ; } return ( TYPE_1 ) VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! METHOD_2 ( ) ) { return ; } TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( ) ; if ( VAR_3 == null ) { return ; } <START> if ( ! TYPE_4 . METHOD_4 ( VAR_2 ) && ! TYPE_5 . METHOD_4 ( VAR_2 ) ) { <END> return ; } if ( ! TYPE_6 . METHOD_5 ( VAR_3 ) ) { METHOD_6 ( VAR_2 . METHOD_7 ( ) , STRING_1 ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; TYPE_2 TYPE_2 = new TYPE_2 ( VAR_2 . METHOD_3 ( ) ) { @Override protected void METHOD_4 ( TYPE_3 VAR_3 , TYPE_4 VAR_4 ) { METHOD_5 ( STRING_2 ) ; } } ; TYPE_2 . VAR_5 = VAR_6 ; TYPE_2 . METHOD_6 ( VAR_1 ) ; VAR_1 = METHOD_2 ( STRING_3 ) ; TYPE_2 . METHOD_6 ( VAR_1 ) ; <START> <END> } 
public void METHOD_1 ( TYPE_1 context ) { this . context = context ; VAR_1 . clear ( ) ; <START> METHOD_2 ( context . VAR_2 ( ) ) ; <END> } 
private static String METHOD_1 ( boolean VAR_1 , Type VAR_2 ) { if ( VAR_1 && VAR_2 . is ( STRING_1 ) ) { return STRING_2 ; <START> } else { <END> return VAR_2 . METHOD_2 ( ) . METHOD_3 ( CHAR_1 , CHAR_2 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { Type VAR_3 = METHOD_2 ( VAR_1 ) ; if ( VAR_1 . type ( ) != VAR_3 && ! VAR_3 . is ( STRING_1 ) <START> && ! ( VAR_2 && VAR_1 . type ( ) . is ( STRING_2 ) ) ) { <END> String VAR_4 = METHOD_3 ( VAR_2 , VAR_3 ) ; METHOD_4 ( VAR_1 . METHOD_5 ( ) , String . format ( STRING_3 , VAR_4 , VAR_1 . type ( ) . name ( ) ) ) ; } } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> return VAR_1 . column ( ) + VAR_1 . text ( ) . length ( ) == VAR_2 . column ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_1 . METHOD_3 ( ) != null && TYPE_3 . METHOD_4 ( VAR_1 ) && VAR_2 != null ) { <END> METHOD_5 ( VAR_2 ) ; } } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > parameters = VAR_1 . parameters ( ) ; <START> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) <END> && parameters . size ( ) == 2 && TYPE_3 . METHOD_4 ( parameters . get ( 0 ) . type ( ) . METHOD_2 ( ) ) && TYPE_4 . METHOD_4 ( parameters . get ( 1 ) . type ( ) . METHOD_2 ( ) ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_5 . TYPE_6 VAR_2 ) { <START> if ( TYPE_5 . TYPE_6 . VAR_3 . equals ( VAR_2 ) ) { <END> if ( VAR_1 . is ( TYPE_5 . TYPE_6 . VAR_4 ) ) { return METHOD_2 ( TYPE_3 . METHOD_3 ( ( ( TYPE_4 ) VAR_1 ) . METHOD_4 ( ) ) ) ; } else { return null ; } } else { return METHOD_2 ( VAR_1 ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> TYPE_3 VAR_3 = VAR_1 . METHOD_2 ( ) . parent ( ) ; <END> while ( ! VAR_3 . equals ( VAR_2 ) && ! VAR_4 . contains ( VAR_3 ) ) { if ( VAR_3 . is ( TYPE_3 . TYPE_5 . VAR_6 ) ) { VAR_4 . add ( ( TYPE_4 ) VAR_3 ) ; METHOD_3 ( VAR_3 , STRING_1 ) ; return ; } VAR_3 = VAR_3 . parent ( ) ; } } 
private static void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { <START> if ( ! VAR_1 . isEmpty ( ) ) { <END> LOG . warn ( STRING_1 ) ; for ( TYPE_1 VAR_2 : VAR_1 ) { LOG . warn ( String . format ( STRING_2 , VAR_2 . getName ( ) ) ) ; } LOG . warn ( STRING_3 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null ) { TYPE_3 VAR_3 = VAR_1 . METHOD_3 ( ) ; <START> if ( ! METHOD_4 ( VAR_2 ) && ! VAR_4 . contains ( VAR_3 ) && METHOD_5 ( VAR_2 , VAR_3 ) ) { <END> context . VAR_5 ( this , VAR_3 , STRING_1 + context . VAR_6 ( ) . METHOD_6 ( ) ) ; } } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; TYPE_3 VAR_3 = VAR_2 . METHOD_2 ( ) ; TYPE_2 VAR_4 = null ; if ( VAR_3 != null && VAR_3 . is ( TYPE_1 . TYPE_4 . VAR_6 ) ) { <START> VAR_4 = ( TYPE_2 ) VAR_3 ; <END> } if ( VAR_4 != null && VAR_4 . METHOD_2 ( ) == null ) { METHOD_3 ( VAR_2 . METHOD_4 ( ) , VAR_4 . METHOD_5 ( ) , STRING_1 ) ; } } 
public List < TYPE_2 . TYPE_3 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( ( TYPE_2 . TYPE_3 . VAR_2 ) ) ; <END> } 
<START> public List < TYPE_1 > METHOD_1 ( ) { <END> return ImmutableList . of ( TYPE_3 . TYPE_1 . VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( ( VAR_1 ) . METHOD_3 ( ) , <END> STRING_1 ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_3 . TYPE_4 > VAR_2 = VAR_1 . metadata ( ) . METHOD_2 ( STRING_1 ) ; if ( VAR_2 == null ) { return false ; } <START> if ( VAR_2 . isEmpty ( ) ) { <END> return false ; } return METHOD_3 ( VAR_2 , STRING_2 , STRING_3 ) || METHOD_3 ( VAR_2 , STRING_2 , STRING_4 ) ; } 
<START> public static Optional < String > METHOD_1 ( TYPE_2 . TYPE_3 method ) { <END> if ( METHOD_2 ( method , VAR_1 ) ) { return Optional . of ( VAR_1 ) ; } if ( METHOD_2 ( method , VAR_2 , STRING_1 ) ) { return Optional . of ( VAR_2 ) ; } return Optional . empty ( ) ; } 
<START> public void METHOD_1 ( ) { <END> VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> if ( TYPE_3 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ) { <END> return VAR_1 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , TYPE_5 . VAR_4 ) ; } else if ( TYPE_4 . METHOD_6 ( VAR_2 ) ) { return VAR_1 . METHOD_7 ( VAR_5 , false ) ; } return VAR_1 ; } 
static boolean METHOD_1 ( ) { try { METHOD_2 ( ) ; } catch ( Throwable e ) { <START> return true ; <END> } return true ; } 
public String toString ( ) { <START> return STRING_1 + stream ( ) . map ( TYPE_1 : : toString ) . METHOD_1 ( ) . collect ( Collectors . VAR_1 ( STRING_2 ) ) + STRING_3 ; <END> } 
public boolean equals ( Object o ) { <START> if ( this == o ) <END> return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 that = ( TYPE_1 ) o ; return VAR_1 == that . VAR_1 && TYPE_2 . equals ( VAR_2 , that . VAR_2 ) && TYPE_2 . equals ( name , that . name ) && TYPE_2 . equals ( VAR_3 , that . VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( TYPE_2 . METHOD_2 ( VAR_1 ) && TYPE_3 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ) { <START> VAR_2 = true ; <END> } super . METHOD_1 ( VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . is ( TYPE_6 . TYPE_5 . VAR_4 ) ) { TYPE_2 VAR_5 = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; if ( VAR_5 . stream ( ) . METHOD_3 ( TYPE_4 : : METHOD_4 ) ) { return true ; } <START> return VAR_5 . stream ( ) . filter ( TYPE_4 : : METHOD_4 ) . METHOD_5 ( this : : METHOD_1 ) ; <END> } return false ; } 
private TYPE_1 METHOD_1 ( ) { int VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) + 1 ; return TYPE_3 . METHOD_4 ( VAR_1 , new TYPE_4 ( ) . METHOD_5 ( STRING_1 ) . build ( ) ) ; <START> } <END> 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { List < Class < ? extends TYPE_2 > > VAR_2 = VAR_1 . METHOD_2 ( ) . collect ( Collectors . VAR_3 ( ) ) ; <START> return VAR_2 . size ( ) == 1 && VAR_1 . get ( TYPE_3 . class ) == TYPE_3 . VAR_4 ; <END> } 
private boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <START> return VAR_1 != null && VAR_1 . getClass ( ) . METHOD_2 ( TYPE_2 . class ) ; <END> } 
public TYPE_3 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; TYPE_2 VAR_3 = VAR_2 . METHOD_1 ( ) ; this . VAR_4 = METHOD_2 ( VAR_2 ) ; VAR_5 = ! METHOD_3 ( VAR_3 ) && VAR_4 . size ( ) > 1 ; <START> VAR_6 = VAR_5 && ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) || VAR_3 . METHOD_4 ( ) . is ( STRING_1 ) ) ; <END> } 
public int METHOD_1 ( ) { if ( VAR_1 == 0 ) { <START> VAR_1 = TYPE_1 . METHOD_2 ( values , VAR_2 , METHOD_3 ( ) , VAR_3 ) ; <END> } return VAR_1 ; } 
void METHOD_1 ( ) { Object VAR_1 = new Object [ ] { STRING_1 } ; <START> String [ ] VAR_2 = new Object [ ] { STRING_1 } ; <END> Object [ ] VAR_3 = new String [ ] { STRING_1 } ; System . out . println ( ( ( Object [ ] ) VAR_1 ) [ 0 ] ) ; System . out . println ( ( ( Object [ ] ) VAR_2 ) [ 0 ] ) ; System . out . println ( ( ( String [ ] ) VAR_3 ) [ 0 ] ) ; } 
private TYPE_4 ( TYPE_1 child , TYPE_1 parent ) { <START> TYPE_2 . METHOD_1 ( ! TYPE_3 . equals ( child , parent ) ) ; <END> this . child = child ; this . parent = parent ; VAR_2 = TYPE_3 . METHOD_2 ( child , parent ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_5 . TYPE_7 VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> if ( VAR_2 == null ) { return true ; } TYPE_5 . TYPE_6 VAR_3 = VAR_2 . METHOD_3 ( ) ; if ( VAR_3 == null ) { return true ; } return VAR_3 . METHOD_4 ( ) . stream ( ) . METHOD_5 ( TYPE_4 : : METHOD_6 ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { TYPE_1 VAR_3 = VAR_1 . METHOD_2 ( ) ? VAR_1 : VAR_2 ; TYPE_1 VAR_4 = VAR_3 == VAR_1 ? VAR_2 : VAR_1 ; <START> return METHOD_3 ( VAR_1 , VAR_2 ) <END> && ! METHOD_4 ( VAR_3 , VAR_4 ) && ! METHOD_5 ( VAR_3 , VAR_4 ) ; } 
<START> public Set < String > METHOD_1 ( ) { <END> TYPE_1 . VAR_2 = null ; VAR_3 . METHOD_1 ( ) ; return VAR_3 . METHOD_2 ( ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 ) { return ! ( VAR_1 . METHOD_2 ( ) . equals ( VAR_3 ) && VAR_4 . get ( VAR_5 ) . contains ( VAR_1 . line ( ) ) ) ; <START> } <END> return ! ( VAR_1 . METHOD_2 ( ) . equals ( VAR_3 ) && VAR_4 . get ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) . contains ( VAR_1 . line ( ) ) ) ; } 
private static boolean METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . metadata ( ) ; <START> return VAR_2 . METHOD_3 ( STRING_1 ) ; <END> } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; return VAR_2 . is ( TYPE_5 . TYPE_4 . VAR_5 ) <START> || ( VAR_2 . is ( TYPE_5 . TYPE_4 . VAR_6 ) && ( ( TYPE_3 ) VAR_2 ) . METHOD_3 ( ) . is ( TYPE_5 . TYPE_4 . VAR_5 ) ) ; <END> } 
public String toString ( ) { <START> return String . valueOf ( VAR_1 ) + VAR_2 . VAR_3 + VAR_4 ; <END> } 
void f ( ) { if ( this == null ) { } <START> if ( super == null ) { <END> } } 
<START> public static TYPE_1 < TYPE_2 > METHOD_1 ( ANNOTATION_1 TYPE_3 < Class < ? extends TYPE_2 > , TYPE_2 > VAR_1 ) { <END> if ( VAR_1 == null ) { return TYPE_1 . empty ( ) ; } TYPE_1 . Builder < TYPE_2 > result = TYPE_1 . builder ( ) ; VAR_1 . forEach ( ( d , c ) - > result . add ( c ) ) ; return result . build ( ) ; } 
<START> TYPE_9 ( ANNOTATION_1 TYPE_7 . TYPE_8 VAR_2 , TYPE_2 < TYPE_7 . TYPE_8 > VAR_3 , ANNOTATION_1 TYPE_3 VAR_4 , List < TYPE_5 . TYPE_6 > VAR_5 , boolean VAR_6 ) { <END> this . VAR_4 = VAR_4 ; this . VAR_7 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , ANNOTATION_1 TYPE_2 VAR_3 ) { <START> TYPE_3 . METHOD_1 ( VAR_2 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
<START> public Type METHOD_1 ( String VAR_1 ) { <END> return VAR_2 . METHOD_2 ( VAR_1 ) . type ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 parent = VAR_1 ; <START> while ( ( parent = parent . parent ( ) ) != null ) { <END> if ( parent . is ( TYPE_1 . TYPE_3 . VAR_3 ) ) { break ; } } if ( parent != null && parent . is ( TYPE_1 . TYPE_3 . VAR_3 ) ) { return METHOD_2 ( ( TYPE_2 ) parent ) ; } return false ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 . METHOD_2 ( ) ) { TYPE_2 VAR_2 = VAR_3 . METHOD_3 ( ) ; ( ( TYPE_1 . TYPE_5 ) VAR_1 ) . METHOD_4 ( ) . stream ( ) . map ( TYPE_4 : : METHOD_5 ) . forEach ( VAR_4 - > METHOD_6 ( VAR_2 , VAR_4 ) ) ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( ) ; while ( VAR_2 ) { VAR_1 . METHOD_2 ( ) ; } VAR_1 . METHOD_3 ( ) ; <START> while ( TYPE_3 . METHOD_4 ( ) ) { <END> VAR_1 . METHOD_2 ( ) ; VAR_1 = new TYPE_2 ( ) ; } VAR_1 . METHOD_3 ( ) ; } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> final TYPE_1 parent = VAR_1 . parent ( ) ; if ( parent . is ( TYPE_1 . TYPE_3 . VAR_3 ) ) { return METHOD_2 ( ( TYPE_2 ) parent ) ; } return false ; } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> final TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; return VAR_2 != null && VAR_2 . METHOD_3 ( ) . contains ( VAR_1 ) ; } 
private Map < String , Object > METHOD_1 ( String VAR_1 ) { <START> Path VAR_2 = TYPE_1 . get ( VAR_1 ) ; <END> if ( ! VAR_3 . exists ( VAR_2 ) ) { return METHOD_2 ( ) ; } try { return TYPE_3 . TYPE_4 . METHOD_3 ( VAR_3 . METHOD_4 ( VAR_2 ) ) ; } catch ( IOException e ) { throw new IllegalStateException ( STRING_1 + VAR_1 , e ) ; } } 
<START> void METHOD_1 ( ) throws TYPE_1 { <END> } 
static TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { return TYPE_1 . create ( ) . METHOD_2 ( VAR_1 ) <START> . name ( String . format ( STRING_1 , VAR_2 . METHOD_3 ( 0 ) , VAR_2 . METHOD_4 ( TYPE_2 . VAR_4 ) . substring ( 2 ) ) ) <END> . METHOD_5 ( ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! METHOD_2 ( ) ) { return ; } <START> if ( VAR_1 . is ( VAR_2 ) || VAR_1 . is ( VAR_3 ) ) { <END> VAR_4 . METHOD_3 ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! METHOD_2 ( ) ) { return ; } <START> if ( VAR_1 . is ( VAR_2 ) ) { <END> TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 ; if ( VAR_3 . METHOD_3 ( ) . is ( VAR_4 ) ) { TYPE_3 VAR_5 = ( TYPE_3 ) VAR_3 . METHOD_3 ( ) ; if ( TYPE_4 . METHOD_4 ( VAR_5 ) && ! METHOD_5 ( VAR_5 . METHOD_6 ( ) ) ) { METHOD_7 ( VAR_5 , STRING_1 ) ; } } } } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . is ( VAR_2 ) ) { TYPE_2 parent = VAR_1 . parent ( ) ; while ( ! parent . is ( VAR_3 ) ) { parent = parent . parent ( ) ; } return ( ( TYPE_3 ) parent ) . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <START> } else { <END> return ( ( TYPE_4 ) VAR_1 ) . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_2 ( ) . METHOD_4 ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == VAR_2 || VAR_3 ) { <END> return ; } if ( METHOD_2 ( VAR_1 . METHOD_3 ( ) , VAR_4 ) ) { VAR_3 = true ; } super . METHOD_1 ( VAR_1 ) ; } 
<START> void METHOD_1 ( int VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> if ( VAR_1 . is ( TYPE_6 . TYPE_5 . VAR_6 ) && ( VAR_2 . is ( TYPE_6 . TYPE_5 . VAR_7 ) ) ) { <END> List < TYPE_3 > parameters = VAR_3 . parameters ( ) ; return parameters . size ( ) == 1 && parameters . get ( 0 ) . METHOD_2 ( ) . equals ( ( ( TYPE_4 ) VAR_2 ) . METHOD_2 ( ) ) ; } return false ; } 
private static Set < Type > METHOD_1 ( Set < Type > VAR_1 ) { <START> if ( ! VAR_1 . stream ( ) . METHOD_2 ( Type : : METHOD_3 ) ) { <END> return VAR_1 . stream ( ) . map ( t - > ! t . VAR_2 ( ) ? t : ( ( TYPE_1 ) t ) . METHOD_4 ( ) ) . collect ( Collectors . VAR_3 ( TYPE_2 : : new ) ) ; } return VAR_1 ; } 
<START> private boolean METHOD_1 ( Type type ) { <END> if ( type . VAR_1 ( ) ) { return true ; } if ( METHOD_2 ( type ) ) { return true ; } if ( METHOD_3 ( type ) ) { return METHOD_4 ( ( TYPE_1 ) type ) ; } return type . VAR_2 ( STRING_1 ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> return VAR_2 == null || ( VAR_2 . is ( TYPE_5 . TYPE_4 . VAR_5 ) && STRING_1 . equals ( ( ( TYPE_3 ) VAR_2 ) . value ( ) ) ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( TYPE_2 . METHOD_2 ( VAR_1 ) ) { <END> TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) . get ( 1 ) ; if ( VAR_2 . is ( TYPE_7 . TYPE_6 . VAR_5 ) ) { TYPE_4 VAR_6 = ( TYPE_4 ) VAR_2 ; if ( METHOD_4 ( VAR_6 . METHOD_5 ( ) ) && TYPE_5 . METHOD_2 ( VAR_6 ) ) { METHOD_6 ( VAR_2 ) ; } } } } 
public TYPE_1 ( int id , Status VAR_2 ) { super ( id ) ; <START> this . VAR_3 = VAR_2 ; <END> } 
protected static boolean METHOD_1 ( Type type ) { TYPE_1 VAR_1 = ( TYPE_1 ) type ; if ( VAR_1 . METHOD_2 ( ) ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; return METHOD_3 ( VAR_2 ) && VAR_2 . METHOD_4 ( ) . stream ( ) . METHOD_5 ( t - > METHOD_1 ( VAR_2 . METHOD_6 ( t ) ) ) ; <START> } else { <END> return TYPE_3 . METHOD_7 ( VAR_1 ) ; } } 
private static boolean METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 . contains ( STRING_1 ) ) { <END> return STRING_2 . equals ( VAR_1 . substring ( 0 , VAR_1 . METHOD_2 ( CHAR_1 ) ) ) ; } else { return false ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; <START> Set < TYPE_4 > VAR_3 = TYPE_5 . METHOD_3 ( VAR_2 ) ; <END> VAR_2 . METHOD_4 ( ) . stream ( ) . filter ( TYPE_6 : : METHOD_5 ) . filter ( s - > ! s . VAR_4 ( ) . isEmpty ( ) ) . filter ( s - > ! VAR_3 . contains ( s ) ) . forEach ( s - > METHOD_6 ( s , VAR_2 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { String message = STRING_1 ; if ( VAR_1 . is ( TYPE_4 . TYPE_3 . VAR_4 , TYPE_4 . TYPE_3 . VAR_5 ) ) { TYPE_2 VAR_6 = VAR_1 . METHOD_2 ( ) ; TYPE_2 VAR_7 = VAR_1 . METHOD_3 ( ) ; if ( ( METHOD_4 ( VAR_6 ) && METHOD_5 ( VAR_7 ) ) || ( METHOD_5 ( VAR_6 ) && METHOD_4 ( VAR_7 ) ) ) { <START> context . VAR_8 ( this , VAR_1 , message ) ; <END> } } super . METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( ! METHOD_3 ( VAR_2 ) && VAR_2 . is ( TYPE_4 . VAR_4 ) ) { <START> TYPE_3 VAR_5 = ( TYPE_3 ) VAR_2 ; <END> METHOD_3 ( VAR_5 . METHOD_4 ( ) ) ; METHOD_3 ( VAR_5 . METHOD_5 ( ) ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 < TYPE_2 , TYPE_3 > VAR_3 = VAR_4 . put ( VAR_1 , VAR_2 ) ; <START> if ( VAR_3 != VAR_4 && ! METHOD_2 ( VAR_1 ) ) { <END> return new TYPE_1 ( this , VAR_3 ) ; } return this ; } 
public void METHOD_1 ( ) { <START> org . VAR_1 . VAR_2 . TYPE_1 . assertThat ( VAR_4 . toString ( ) ) . METHOD_2 ( STRING_1 ) ; <END> } 
<START> TYPE_4 ( int VAR_2 , TYPE_2 . TYPE_3 VAR_3 ) { <END> super ( VAR_2 , VAR_3 ) ; } 
private static boolean METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { Type VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null && ! VAR_2 . is ( STRING_1 ) ) { <START> if ( ! METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ) { <END> return false ; } } for ( Type VAR_3 : VAR_1 . METHOD_5 ( ) ) { if ( ! METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ) { return false ; } } return true ; } 
<START> private boolean METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 , TYPE_2 VAR_2 , List < TYPE_2 > VAR_3 ) { <END> return ! VAR_1 . METHOD_2 ( ) && METHOD_3 ( VAR_2 ) && VAR_3 . isEmpty ( ) ; } 
public TYPE_1 [ ] METHOD_1 ( ) { List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( ) ; <START> for ( TYPE_3 VAR_2 : VAR_3 ) { <END> VAR_1 . add ( VAR_2 ) ; } for ( TYPE_4 < TYPE_5 > VAR_4 : VAR_5 ) { Collection < TYPE_5 > VAR_6 = VAR_4 . METHOD_3 ( ) ; if ( ! VAR_6 . isEmpty ( ) ) { VAR_1 . addAll ( VAR_6 ) ; } } return VAR_1 . METHOD_4 ( new TYPE_1 [ VAR_1 . size ( ) ] ) ; } 
private static boolean METHOD_1 ( TYPE_2 . TYPE_3 method , TYPE_2 . TYPE_3 VAR_1 ) { <START> return METHOD_2 ( method , VAR_1 ) <END> || METHOD_3 ( method , VAR_1 ) || METHOD_4 ( method , VAR_1 ) || METHOD_5 ( method , VAR_1 ) || METHOD_6 ( method , VAR_1 ) ; } 
<START> public ANNOTATION_1 String METHOD_1 ( ) { <END> return null ; } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( METHOD_2 ( VAR_1 . METHOD_3 ( ) ) && VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ) { TYPE_3 . TYPE_4 VAR_2 = ( TYPE_3 . TYPE_4 ) VAR_1 . METHOD_4 ( ) ; return VAR_2 . METHOD_6 ( ) . size ( ) == 1 && VAR_2 . METHOD_7 ( ) . is ( STRING_1 ) ; } return false ; } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return METHOD_2 ( VAR_1 ) || VAR_1 . METHOD_3 ( ) . metadata ( ) . METHOD_4 ( STRING_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; if ( STRING_1 . equals ( VAR_1 . name ( ) ) || VAR_2 . isEmpty ( ) ) { return ; } TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( ) ; <START> final TYPE_3 VAR_4 = VAR_2 . METHOD_3 ( ) ; <END> if ( VAR_3 . METHOD_4 ( ) ) { VAR_4 . METHOD_5 ( ) ; return ; } for ( TYPE_3 VAR_5 : VAR_2 ) { VAR_5 . METHOD_6 ( VAR_3 ) ; } } 
<START> protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_1 VAR_2 = null ; if ( VAR_3 . equals ( VAR_1 . VAR_4 ) ) { VAR_2 = VAR_1 . METHOD_2 ( this ) ; } else if ( VAR_3 . equals ( VAR_1 . VAR_3 ) ) { VAR_2 = VAR_1 . METHOD_3 ( ) . METHOD_2 ( this ) ; } return VAR_2 ; } 
private static String METHOD_1 ( String text ) { <START> String VAR_1 = text . substring ( text . VAR_2 ( VAR_3 ) ) ; <END> return VAR_1 . substring ( VAR_1 . METHOD_2 ( VAR_4 ) ) ; } 
public boolean METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 . METHOD_2 ( ) ) { if ( VAR_1 . METHOD_3 ( ) . is ( TYPE_5 . TYPE_4 . VAR_5 ) && METHOD_4 ( ( TYPE_2 ) VAR_1 . METHOD_3 ( ) ) ) { return true ; <START> } else if ( VAR_1 . METHOD_3 ( ) . is ( TYPE_4 . VAR_6 ) && METHOD_5 ( ( TYPE_3 ) VAR_1 . METHOD_3 ( ) ) ) { <END> return true ; } } return false ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . is ( TYPE_5 . VAR_3 ) && METHOD_2 ( ( TYPE_2 ) VAR_1 ) ) { VAR_1 . METHOD_3 ( new TYPE_3 ( ) ) ; } else if ( VAR_1 . is ( TYPE_5 . VAR_4 ) ) { TYPE_4 VAR_5 = ( TYPE_4 ) VAR_1 ; <START> if ( METHOD_4 ( ) && METHOD_5 ( VAR_5 ) && ! METHOD_6 ( VAR_5 ) ) { <END> VAR_6 . add ( VAR_5 ) ; } } } 
<START> public Boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_2 . equals ( VAR_1 . VAR_2 ) && VAR_3 . equals ( VAR_1 . VAR_3 ) ) { return VAR_1 . METHOD_2 ( this ) ; } else if ( VAR_2 . equals ( VAR_1 . VAR_3 ) && VAR_3 . equals ( VAR_1 . VAR_2 ) ) { return VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; } return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; TYPE_5 . TYPE_6 VAR_3 = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_3 . METHOD_3 ( ) ) { <END> TYPE_7 . TYPE_8 VAR_4 = ( ( TYPE_7 . TYPE_8 ) VAR_3 ) . METHOD_4 ( ) ; if ( VAR_4 != null && VAR_4 . METHOD_3 ( ) ) { METHOD_5 ( VAR_2 , VAR_4 ) ; } } } 
<START> static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> final TYPE_1 parent = VAR_1 . parent ( ) ; if ( parent . is ( TYPE_1 . TYPE_3 . VAR_3 ) ) { return METHOD_2 ( ( TYPE_2 ) parent ) ; } return false ; } 
<START> static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> final TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null ) { return VAR_2 . METHOD_3 ( ) . contains ( VAR_1 ) ; } return false ; } 
<START> public TYPE_1 ( int VAR_2 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = true ; } 
public Set < TYPE_1 > METHOD_1 ( ) { <START> final HashSet < TYPE_1 > VAR_1 = new HashSet < > ( ) ; <END> values . forEach ( new TYPE_4 . TYPE_5 < TYPE_3 , TYPE_1 > ( ) { @Override public void METHOD_2 ( TYPE_3 key , TYPE_1 value ) { if ( METHOD_3 ( key ) ) { VAR_1 . add ( value ) ; } } } ) ; return VAR_1 ; } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { try { if ( VAR_1 == null ) { this . METHOD_2 ( ) ; } return ( ( TYPE_3 ) VAR_1 . METHOD_3 ( VAR_2 ) ) ; } catch ( final TYPE_4 e ) { throw new TYPE_2 ( e . VAR_3 ( ) . getMessage ( ) ) ; } <START> } <END> 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , String name , List < TYPE_3 > VAR_3 ) { <START> return METHOD_1 ( VAR_1 , VAR_2 , VAR_2 , name , VAR_3 , TYPE_4 < TYPE_3 > of ( ) ) ; <END> } 
private String METHOD_1 ( String name ) { int VAR_1 ; if ( VAR_2 . containsKey ( name ) ) { VAR_1 = VAR_2 . get ( name ) + 1 ; } else { <START> VAR_1 = 1 ; <END> } VAR_2 . put ( name , VAR_1 ) ; return VAR_1 + name ; } 
public Set < TYPE_1 > METHOD_1 ( TYPE_4 . TYPE_5 VAR_1 ) { <START> return TYPE_3 . METHOD_2 ( out . get ( VAR_1 ) ) ; <END> } 
int METHOD_1 ( ) { int i = 0 ; int b = INT_1 ; <START> ++ b ; <END> int j = - 1 ; while ( ( j = METHOD_2 ( ++ j ) ) != - 1 ) { System . out . println ( "" ) ; } if ( i != 0 ) { return i ++ ; } else { return ++ i ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . is ( TYPE_4 . TYPE_3 . VAR_4 ) && VAR_5 . contains ( ( TYPE_2 ) VAR_1 ) ; <END> } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) . line ( ) == TYPE_2 . METHOD_2 ( VAR_1 . METHOD_4 ( ) ) . line ( ) ; } 
<START> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> return VAR_1 . METHOD_2 ( ) != null ? VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) : null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( ( ( TYPE_2 ) VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( ) ) ; <END> } 
public final void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; METHOD_2 ( VAR_1 . METHOD_4 ( ) ) ; TYPE_2 value = METHOD_5 ( ) ; for ( TYPE_3 VAR_2 : VAR_3 ) { <START> for ( int i = VAR_1 . METHOD_3 ( ) . size ( ) + VAR_1 . METHOD_4 ( ) . size ( ) - 1 ; i >= 0 ; i -= 1 ) { <END> VAR_2 . METHOD_6 ( ) ; } VAR_2 . METHOD_7 ( value ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { boolean VAR_2 = METHOD_2 ( VAR_1 ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; <START> VAR_4 . METHOD_3 ( Boolean . VAR_5 ) ; <END> super . METHOD_1 ( VAR_1 ) ; VAR_3 . METHOD_4 ( ) ; if ( VAR_2 && ! VAR_4 . METHOD_4 ( ) ) { context . VAR_6 ( VAR_1 , this , STRING_1 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_1 s ) { if ( s instanceof TYPE_2 ) { return this ; } <START> if ( ! ( s instanceof TYPE_3 ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } return s ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( METHOD_3 ( VAR_2 . type ( ) ) ) { <START> VAR_3 . METHOD_4 ( VAR_2 , new TYPE_4 . TYPE_5 ( VAR_1 ) ) ; <END> } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_4 . TYPE_5 VAR_2 = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; <START> if ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) && VAR_2 . METHOD_5 ( ) ) { <END> METHOD_6 ( VAR_1 , STRING_1 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> super . METHOD_1 ( VAR_1 ) ; <END> VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } 
TYPE_5 ( TYPE_3 . TYPE_4 VAR_2 , Map < TYPE_2 , Type > VAR_3 ) { super ( VAR_2 ) ; this . VAR_4 = VAR_2 . getType ( ) ; this . VAR_3 = VAR_3 ; <START> if ( VAR_4 . METHOD_1 ( VAR_5 ) ) { <END> this . VAR_6 = VAR_5 ; } } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { Type type = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; <START> TYPE_3 VAR_2 = type . VAR_3 ( ) ; <END> String name = VAR_2 . getName ( ) ; if ( name . isEmpty ( ) ) { name = METHOD_3 ( VAR_2 ) ; } return name ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . is ( TYPE_4 . VAR_3 ) && ! ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . METHOD_4 ( TYPE_5 . VAR_5 , TYPE_5 . VAR_6 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { Long VAR_2 = METHOD_2 ( VAR_1 ) ; Long VAR_3 = METHOD_3 ( METHOD_4 ( VAR_1 ) ) ; <START> if ( VAR_3 != null && VAR_3 == VAR_2 ) { <END> METHOD_5 ( VAR_1 , STRING_1 ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return METHOD_2 ( ) && METHOD_3 ( VAR_1 ) && METHOD_4 ( VAR_1 ) && METHOD_5 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( VAR_1 ) && METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ) { METHOD_5 ( VAR_1 , STRING_1 ) ; } <START> super . METHOD_1 ( VAR_1 ) ; <END> } 
default TYPE_1 VAR_2 ( ) { <START> return TYPE_2 . VAR_4 ( 1 ) ; <END> } 
public TYPE_1 build ( ) { <START> METHOD_1 ( METHOD_1 ( ) != null ? ImmutableList . VAR_1 ( METHOD_1 ( ) ) : new ArrayList < TYPE_2 > ( ) ) ; <END> return METHOD_2 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 < TYPE_2 > VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; assertNotNull ( VAR_1 ) ; <START> VAR_1 . METHOD_5 ( new TYPE_3 < TYPE_2 > ( ) { <END> @Override public boolean apply ( TYPE_2 input ) { return input . id ( ) . equals ( VAR_3 ) ; } } ) ; } 
public static TYPE_1 METHOD_1 ( String value ) { Optional < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class , value . VAR_2 ( ) ) ; <START> METHOD_3 ( VAR_1 . isPresent ( ) , STRING_1 , TYPE_3 . METHOD_4 ( CHAR_1 ) . METHOD_5 ( TYPE_5 . TYPE_6 . values ( ) ) , value ) ; <END> return VAR_1 . get ( ) ; } 
public static TYPE_1 METHOD_1 ( String value ) { Optional < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class , value . VAR_2 ( ) ) ; <START> METHOD_3 ( VAR_1 . isPresent ( ) , STRING_1 , TYPE_3 . METHOD_4 ( CHAR_1 ) . METHOD_5 ( TYPE_4 . values ( ) ) , value ) ; <END> return VAR_1 . get ( ) ; } 
private void METHOD_1 ( final String input , int VAR_1 ) { METHOD_2 ( input ) ; METHOD_3 ( input . length ( ) <= VAR_1 , String . format ( STRING_1 , VAR_1 ) ) ; <START> METHOD_3 ( TYPE_1 . METHOD_4 ( VAR_2 , new TYPE_2 < String > ( ) { <END> @Override public boolean apply ( ANNOTATION_1 String input ) { return input . startsWith ( input ) ; } } ) , STRING_2 + TYPE_1 . toString ( VAR_2 ) ) ; } 
<START> private TYPE_2 ( TYPE_1 VAR_2 ) { <END> super ( VAR_2 ) ; } 
<START> public void METHOD_1 ( ) throws InterruptedException { <END> server . VAR_1 ( METHOD_2 ( ) ) ; TYPE_1 < TYPE_2 > VAR_2 = VAR_3 . METHOD_3 ( ) . list ( TYPE_4 . TYPE_5 . getName ( ) ) . METHOD_4 ( ) ; assertTrue ( isEmpty ( VAR_2 ) ) ; assertEquals ( server . VAR_4 ( ) , 1 ) ; } 
<START> public TYPE_2 ( final TYPE_1 VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( ) { <START> if ( ! VAR_1 . isEmpty ( ) ) { <END> METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; } } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) { <END> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; } 
<START> public TYPE_3 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <START> assertTrue ( ! VAR_1 . name ( ) . isEmpty ( ) ) ; <END> } 
public void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : METHOD_2 ( ) . METHOD_3 ( ) ) { assertNotNull ( VAR_1 . name ( ) ) ; TYPE_2 props = VAR_1 . properties ( ) ; <START> assertNotNull ( props ) ; <END> } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; VAR_1 = System . getProperty ( STRING_1 ) ; VAR_2 = System . getProperty ( STRING_2 ) ; VAR_3 = System . getProperty ( STRING_3 ) ; <START> VAR_4 = System . getProperty ( STRING_4 ) ; <END> } 
public void METHOD_1 ( ) { boolean result = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; assertTrue ( result ) ; <START> Object [ ] args = { VAR_2 , VAR_1 , true } ; <END> METHOD_4 ( VAR_3 . create ( VAR_2 , true ) . apply ( VAR_1 ) , STRING_1 ) ; } 
public void METHOD_1 ( ) throws InterruptedException { server . VAR_1 ( METHOD_2 ( ) ) ; final TYPE_1 VAR_2 = VAR_3 . METHOD_3 ( VAR_4 ) ; <START> VAR_2 . METHOD_4 ( VAR_5 ) ; <END> METHOD_5 ( server , STRING_1 , STRING_2 + STRING_3 + STRING_4 ) ; } 
protected void METHOD_1 ( ) { <START> bind ( TYPE_3 . TYPE_4 . class ) . to ( TYPE_3 . TYPE_5 . class ) ; <END> super . METHOD_1 ( ) ; } 
<START> public TYPE_2 ( TYPE_1 VAR_2 , String VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
protected TYPE_1 < Object , TYPE_2 < TYPE_3 > > METHOD_1 ( final Optional < Object > VAR_1 ) { return new TYPE_1 < Object , TYPE_2 < TYPE_3 > > ( ) { @Override public TYPE_2 < TYPE_3 > apply ( Object input ) { TYPE_4 VAR_2 = TYPE_4 . class . METHOD_2 ( input ) ; <START> return VAR_3 . METHOD_3 ( ) . METHOD_4 ( VAR_1 . toString ( ) , VAR_2 ) ; <END> } } ; } 
protected void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( binder ( ) , Collections . VAR_1 ( Constants . VAR_2 , STRING_1 ) ) ; <END> bind ( TYPE_4 . TYPE_5 . class ) . to ( TYPE_4 . TYPE_6 . class ) ; } 
<START> public TYPE_2 ( ANNOTATION_1 TYPE_1 < String > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
<START> public String METHOD_1 ( String path ) { <END> String VAR_1 = VAR_2 . get ( ) ; List < String > list = TYPE_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( STRING_1 ) . split ( path ) ) ; if ( list . size ( ) > VAR_3 && ! list . get ( VAR_3 ) . equals ( VAR_1 ) ) { list . add ( VAR_3 , VAR_1 ) ; } return TYPE_3 . METHOD_3 ( STRING_1 ) . METHOD_4 ( list ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 < String > VAR_1 = new TYPE_2 ( VAR_2 ) ; <END> String VAR_3 = STRING_1 ; String VAR_4 = new TYPE_3 ( VAR_1 ) . METHOD_2 ( STRING_2 ) ; assertEquals ( VAR_4 , VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 to ) { super . METHOD_1 ( to ) ; if ( to instanceof TYPE_2 ) { TYPE_2 VAR_1 = TYPE_2 . class . METHOD_2 ( to ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; VAR_1 . METHOD_5 ( VAR_4 ) ; VAR_1 . METHOD_6 ( VAR_5 ) ; VAR_1 . METHOD_6 ( VAR_6 ) ; <START> if ( ! VAR_7 . isEmpty ( ) ) { <END> VAR_1 . METHOD_7 ( VAR_7 ) ; } } } 
TYPE_7 ( TYPE_1 < Collection < TYPE_2 > , Collection < TYPE_2 > > VAR_2 , TYPE_5 . TYPE_6 < TYPE_2 > VAR_3 , TYPE_1 < TYPE_2 , TYPE_4 > VAR_4 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_2 ) ; <START> this . VAR_4 = METHOD_1 ( VAR_4 , STRING_3 ) ; <END> } 
TYPE_7 ( ANNOTATION_1 ( TYPE_8 . VAR_3 ) String VAR_4 , TYPE_5 . TYPE_6 VAR_5 , TYPE_2 < Collection < TYPE_3 > > VAR_6 , TYPE_2 < ? extends Map < String , TYPE_4 > > VAR_7 ) { this . VAR_4 = new File ( METHOD_1 ( VAR_4 , STRING_1 ) ) ; this . VAR_5 = METHOD_1 ( VAR_5 , STRING_2 ) ; this . VAR_6 = METHOD_1 ( VAR_6 , STRING_3 ) ; <START> this . VAR_7 = METHOD_1 ( VAR_7 , STRING_4 ) ; <END> } 
<START> public TYPE_7 ( TYPE_1 client , <END> ANNOTATION_1 ( Constants . VAR_2 ) TYPE_2 VAR_3 , ANNOTATION_2 TYPE_3 < Set < ? extends TYPE_4 > > VAR_4 , ANNOTATION_1 ( VAR_5 ) TYPE_5 < String > VAR_6 , TYPE_6 VAR_7 ) { this . client = METHOD_1 ( client , STRING_1 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_2 ) ; this . VAR_4 = METHOD_1 ( VAR_4 , STRING_3 ) ; this . VAR_6 = METHOD_1 ( VAR_6 , STRING_4 ) ; this . VAR_7 = METHOD_1 ( VAR_7 ) ; } 
public TYPE_1 METHOD_1 ( String name , String id ) { TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( id ) ; TYPE_3 server = client . VAR_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_1 . getId ( ) ) ; if ( server == null ) { <START> throw new TYPE_4 ( STRING_1 + id ) ; <END> } TYPE_5 VAR_3 = new TYPE_7 . TYPE_8 ( ) . METHOD_5 ( id ) . name ( name ) . build ( ) ; return VAR_3 ; } 
TYPE_12 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 < TYPE_10 . TYPE_11 , TYPE_6 . Status > VAR_5 , TYPE_8 . TYPE_9 VAR_6 ) { <START> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; <END> this . VAR_3 = METHOD_1 ( VAR_3 , STRING_2 ) ; this . VAR_4 = METHOD_1 ( VAR_4 , STRING_3 ) ; this . VAR_5 = METHOD_1 ( VAR_5 , STRING_4 ) ; this . VAR_6 = METHOD_1 ( VAR_6 , STRING_5 ) . METHOD_2 ( ) ; } 
protected TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 < TYPE_3 , TYPE_4 > VAR_3 ) { <START> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; <END> this . VAR_3 = VAR_3 ; } 
public TYPE_1 ( ANNOTATION_1 String VAR_2 ) { <START> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; <END> } 
protected Builder ( ) { id ( STRING_1 ) . name ( STRING_2 ) . METHOD_1 ( new TYPE_1 ( ) ) . METHOD_2 ( TYPE_2 . create ( STRING_3 ) ) . METHOD_3 ( TYPE_2 . create ( STRING_4 ) ) <START> . METHOD_4 ( STRING_5 , STRING_6 , STRING_7 , STRING_8 ) <END> . METHOD_5 ( STRING_9 ) . METHOD_6 ( TYPE_3 . METHOD_6 ( ) ) ; } 
public boolean apply ( TYPE_1 server ) { METHOD_1 ( server , STRING_1 ) ; server = VAR_1 . METHOD_2 ( ) . get ( server . id ( ) ) ; if ( ( server . status ( ) . state ( ) != TYPE_2 . TYPE_3 . VAR_4 && server . status ( ) . state ( ) != TYPE_2 . TYPE_3 . VAR_5 ) || server . status ( ) . METHOD_3 ( ) != 0 ) { return false ; } else { return true ; <START> } <END> } 
public void METHOD_1 ( ) { VAR_1 = METHOD_2 ( ) . list ( ) ; VAR_2 = VAR_1 . get ( 0 ) ; <START> assertNotNull ( VAR_1 ) ; <END> METHOD_3 ( VAR_1 . isEmpty ( ) ) ; Assert . assertTrue ( VAR_1 . size ( ) > 0 ) ; } 
public void METHOD_1 ( ) { VAR_1 = METHOD_2 ( ) . list ( ) ; VAR_2 = VAR_1 . get ( 0 ) ; <START> Assert . assertTrue ( VAR_1 . size ( ) > 0 ) ; <END> } 
public void METHOD_1 ( ) { List < TYPE_1 > result = METHOD_2 ( ) . list ( ) ; <START> assertNotNull ( result ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 options = new TYPE_1 ( ) ; options . options ( 1 , 1 , null , null , null ) ; List < TYPE_2 > VAR_1 = METHOD_2 ( ) . list ( options ) ; <START> assertNotNull ( VAR_1 ) ; <END> } 
public TYPE_1 apply ( TYPE_2 input ) { try { byte [ ] VAR_1 = METHOD_1 ( ) . METHOD_2 ( input . content ( ) ) ; TYPE_1 VAR_2 = new TYPE_1 ( new TYPE_3 ( VAR_1 ) ) ; return VAR_2 ; } catch ( Exception ex ) { <START> Logger . VAR_3 ( TYPE_4 . class . getName ( ) ) . log ( Level . VAR_4 , null , ex ) ; <END> return null ; } } 
public void METHOD_1 ( ) { VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; assertNotNull ( VAR_1 ) ; METHOD_4 ( VAR_1 . isEmpty ( ) ) ; <START> Assert . assertTrue ( VAR_1 . size ( ) > 0 ) ; <END> } 
public static void METHOD_1 ( String VAR_1 , String key , String VAR_2 ) { final TYPE_1 VAR_3 = TYPE_2 . METHOD_2 ( STRING_1 ) . METHOD_3 ( VAR_1 , key ) . METHOD_4 ( TYPE_1 . class ) ; try { VAR_3 . METHOD_5 ( VAR_2 ) ; } catch ( Exception e ) { e . VAR_4 ( ) ; <START> } <END> finally { TYPE_3 . METHOD_6 ( VAR_3 ) ; } } 
<START> public void METHOD_1 ( ) throws InterruptedException { <END> List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; assertNotNull ( VAR_1 ) ; assertTrue ( VAR_1 . size ( ) > 0 ) ; } 
<START> public void METHOD_1 ( ) throws InterruptedException { <END> List < TYPE_1 > response = METHOD_2 ( ) . METHOD_3 ( TYPE_1 . TYPE_3 . create ( STRING_1 ) ) ; assertNotNull ( response ) ; } 
public TYPE_1 ( ) { this . VAR_2 = STRING_1 ; System . VAR_3 ( STRING_2 , STRING_3 ) ; System . VAR_3 ( STRING_4 , STRING_3 ) ; System . VAR_3 ( STRING_5 , STRING_6 ) ; System . VAR_3 ( STRING_7 , STRING_6 ) ; System . VAR_3 ( STRING_8 , STRING_9 ) ; <START> System . VAR_3 ( STRING_10 , STRING_11 ) ; <END> } 
public static String [ ] METHOD_1 ( final String id ) { final String [ ] VAR_1 = METHOD_2 ( id , STRING_1 ) . split ( STRING_2 ) ; <START> return VAR_1 ; <END> } 
private List < TYPE_1 > METHOD_1 ( String location ) { final List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( ) ; TYPE_3 < String > VAR_2 = TYPE_4 . METHOD_3 ( CHAR_1 ) . METHOD_4 ( ) . METHOD_5 ( ) . split ( this . VAR_3 . METHOD_6 ( ) ) ; for ( String VAR_4 : VAR_2 ) { <START> VAR_4 = VAR_4 . trim ( ) ; <END> METHOD_7 ( VAR_4 , VAR_1 , location ) ; } return VAR_1 ; } 
public TYPE_1 filter ( TYPE_1 request ) throws TYPE_2 { <START> METHOD_1 ( VAR_1 . VAR_2 , STRING_1 ) ; <END> return request . VAR_3 ( ) . METHOD_2 ( TYPE_3 . VAR_5 , METHOD_3 ( ) ) . build ( ) ; } 
public void METHOD_1 ( ) { VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; assertNotNull ( VAR_1 ) ; METHOD_4 ( VAR_1 . isEmpty ( ) ) ; <START> Assert . assertTrue ( VAR_1 . size ( ) > 0 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 options = new TYPE_1 ( ) ; options . options ( 0 , 0 , null , STRING_1 , null ) ; List < TYPE_2 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( options ) ; assertNotNull ( VAR_1 ) ; METHOD_4 ( VAR_1 . isEmpty ( ) ) ; <START> Assert . assertTrue ( VAR_1 . size ( ) > 0 ) ; <END> } 
public void METHOD_1 ( ) throws InterruptedException { METHOD_2 ( VAR_1 ) ; <START> Thread . VAR_2 ( INT_1 ) ; <END> List < TYPE_1 > VAR_3 = METHOD_3 ( ) . METHOD_4 ( VAR_1 . id ( ) ) ; for ( TYPE_1 VAR_4 : VAR_3 ) { if ( ! VAR_4 . METHOD_5 ( ) ) { VAR_5 = VAR_4 ; break ; } } assertNotNull ( VAR_3 ) ; METHOD_6 ( VAR_3 . isEmpty ( ) ) ; Assert . assertTrue ( VAR_3 . size ( ) > 0 ) ; } 
public void METHOD_1 ( ) throws InterruptedException { List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( VAR_2 . id ( ) ) ; VAR_3 = VAR_1 . get ( 0 ) ; assertNotNull ( VAR_1 ) ; METHOD_4 ( VAR_1 . isEmpty ( ) ) ; <START> Assert . assertTrue ( VAR_1 . size ( ) > 0 ) ; <END> } 
public void METHOD_1 ( ) throws InterruptedException { <START> Thread . VAR_1 ( INT_1 ) ; <END> if ( VAR_2 != null ) { METHOD_2 ( VAR_2 ) ; METHOD_3 ( VAR_2 . id ( ) ) ; } if ( VAR_3 != null ) { METHOD_2 ( VAR_3 ) ; METHOD_3 ( VAR_3 . id ( ) ) ; } } 
public boolean apply ( TYPE_1 VAR_1 ) { METHOD_1 ( VAR_1 , STRING_1 ) ; TYPE_2 server = VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) ) ; if ( server . state ( ) != TYPE_3 . TYPE_4 . VAR_5 ) { return false ; } else { return true ; <START> } <END> } 
<START> private TYPE_3 ( ANNOTATION_1 TYPE_1 < TYPE_2 > VAR_2 ) { <END> VAR_3 = VAR_2 . get ( ) ; METHOD_1 ( VAR_3 . VAR_4 , STRING_1 ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; <START> System . out . println ( VAR_1 . size ( ) ) ; <END> assertTrue ( VAR_1 . size ( ) > 0 ) ; } 
public TYPE_1 METHOD_1 ( String uri , String VAR_1 , TYPE_2 VAR_2 ) { return TYPE_3 . METHOD_2 ( VAR_1 ) . METHOD_3 ( STRING_1 , STRING_2 ) . METHOD_4 ( uri ) . METHOD_5 ( VAR_2 ) . METHOD_6 ( VAR_3 ) <START> . METHOD_7 ( new TYPE_4 < TYPE_1 > ( getClass ( ) ) { } ) ; <END> } 
protected Builder ( ) { super ( ) ; id ( STRING_1 ) . name ( STRING_2 ) . METHOD_1 ( new TYPE_1 ( ) ) . METHOD_2 ( STRING_3 ) . METHOD_3 ( TYPE_2 . create ( STRING_4 ) ) . METHOD_4 ( TYPE_2 . create ( STRING_5 ) ) <START> . METHOD_5 ( STRING_6 , STRING_7 , STRING_8 ) <END> . METHOD_6 ( TYPE_3 . METHOD_6 ( ) ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 properties ) { properties = properties == null ? new TYPE_1 ( ) : properties ; properties . put ( STRING_1 , STRING_2 ) ; properties . put ( STRING_3 , STRING_4 ) ; properties . put ( STRING_5 , STRING_6 ) ; <START> properties . put ( VAR_1 , STRING_6 ) ; <END> properties . put ( VAR_2 , TYPE_2 . toString ( ) ) ; return properties ; } 
public TYPE_1 METHOD_1 ( TYPE_2 . Builder VAR_1 ) { this . VAR_1 = VAR_1 != null <START> ? TYPE_2 . builder ( ) . METHOD_2 ( VAR_1 . METHOD_3 ( VAR_2 ) . build ( ) ) . METHOD_3 ( VAR_2 ) <END> : null ; return this ; } 
protected void METHOD_1 ( ) { <START> bind ( TYPE_1 . class ) . to ( TYPE_2 . class ) . in ( TYPE_3 . class ) ; <END> } 
protected void METHOD_1 ( ) { String id = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . id ( ) ; assertNotNull ( id ) ; <START> VAR_2 = id ; <END> } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , boolean VAR_3 ) { List < TYPE_1 > VAR_4 = METHOD_2 ( VAR_1 , VAR_2 , false ) ; for ( TYPE_1 VAR_5 : VAR_4 ) { if ( ! VAR_5 . METHOD_3 ( ) ) { METHOD_4 ( VAR_1 , VAR_5 . getKey ( ) ) ; } else { if ( VAR_3 ) { <START> METHOD_4 ( VAR_1 , VAR_5 . getKey ( ) ) ; <END> METHOD_1 ( VAR_1 , VAR_5 . getKey ( ) , true ) ; } } } } 
<START> public TYPE_2 ( TYPE_1 VAR_2 ) { <END> VAR_2 . start ( ) ; } 
<START> public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 < TYPE_3 > VAR_3 ) { <END> this . VAR_2 = ( TYPE_4 ) METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_2 ) ; } 
public TYPE_2 . TYPE_3 METHOD_1 ( ) { TYPE_2 . TYPE_3 result = TYPE_2 . TYPE_3 . create ( name , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; <START> return result ; <END> } 
protected TYPE_1 METHOD_1 ( ) { synchronized ( this ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_2 ( ) ; } } return VAR_1 ; <START> } <END> 
public void METHOD_1 ( ) { TYPE_1 binder = new TYPE_1 ( ) ; TYPE_3 . TYPE_4 . TYPE_5 VAR_2 = TYPE_3 . TYPE_4 . TYPE_5 . builder ( ) . METHOD_2 ( STRING_1 ) . METHOD_3 ( STRING_2 ) . METHOD_4 ( STRING_3 ) . build ( ) ; String VAR_3 = binder . VAR_4 ( VAR_2 ) ; <START> assertNotNull ( VAR_3 , STRING_4 ) ; <END> assertEquals ( VAR_5 , VAR_3 ) ; } 
protected String METHOD_1 ( TYPE_2 . TYPE_3 . TYPE_4 VAR_2 ) { VAR_3 . append ( STRING_1 ) . append ( STRING_2 ) ; for ( String s : VAR_2 . METHOD_2 ( ) ) { VAR_3 . append ( format ( STRING_3 , s ) ) ; } VAR_3 . append ( format ( STRING_4 , VAR_2 . id ( ) ) ) . append ( STRING_5 ) . append ( STRING_6 ) ; <START> return VAR_3 . toString ( ) . METHOD_3 ( STRING_7 , "" ) ; <END> } 
<START> protected TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <END> super ( VAR_2 , VAR_3 , VAR_4 ) ; this . VAR_5 = TYPE_4 . METHOD_1 ( ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> assertNotNull ( VAR_1 ) ; <END> METHOD_4 ( VAR_1 . isEmpty ( ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_3 ) ; <START> System . out . println ( VAR_1 ) ; <END> assertNotNull ( VAR_1 ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( ( VAR_1 == null && VAR_2 == null ) <START> || ( VAR_1 != null && VAR_2 != null ) , STRING_1 ) ; <END> if ( VAR_1 != null ) { METHOD_2 ( VAR_3 == TYPE_1 . VAR_5 || VAR_3 == TYPE_1 . VAR_6 , STRING_2 ) ; METHOD_2 ( VAR_1 > VAR_2 , STRING_3 ) ; METHOD_2 ( VAR_1 >= 1 && VAR_1 <= INT_1 , STRING_4 ) ; METHOD_2 ( VAR_2 >= 1 && VAR_2 <= INT_1 , STRING_5 ) ; } } 
public static TYPE_1 METHOD_1 ( ) { TYPE_1 properties = TYPE_2 . METHOD_1 ( ) ; properties . VAR_1 ( Constants . VAR_2 , STRING_1 ) ; <START> properties . VAR_1 ( TYPE_3 . VAR_4 , STRING_2 ) ; <END> return properties ; } 
<START> public TYPE_3 ( ANNOTATION_1 TYPE_1 < TYPE_2 > VAR_2 ) { <END> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; } 
<START> public String METHOD_1 ( TYPE_1 response ) { <END> if ( response . VAR_1 ( ) == null ) return null ; try { return TYPE_2 . METHOD_2 ( response . VAR_1 ( ) . METHOD_3 ( ) ) ; } catch ( IOException e ) { throw TYPE_3 . METHOD_4 ( e ) ; } } 
public Builder METHOD_1 ( List < String > VAR_1 ) { <START> this . VAR_1 = ImmutableList . VAR_2 ( METHOD_2 ( VAR_1 , STRING_1 ) ) ; <END> return this ; } 
public void METHOD_1 ( ) { List < TYPE_1 > response = METHOD_2 ( ) . list ( ) ; <START> for ( TYPE_1 VAR_1 : METHOD_2 ( ) . list ( ) ) { <END> METHOD_3 ( VAR_1 ) ; } if ( ! response . isEmpty ( ) ) { TYPE_1 VAR_1 = response . iterator ( ) . next ( ) ; assertEquals ( METHOD_2 ( ) . get ( VAR_1 . name ( ) ) , VAR_1 ) ; } } 
public String toString ( ) { <START> return TYPE_1 . METHOD_1 ( this ) . METHOD_2 ( ) . add ( STRING_1 , VAR_1 ) . add ( STRING_2 , message ) . toString ( ) ; <END> } 
<START> public TYPE_3 ( TYPE_1 VAR_2 ) { <END> super ( VAR_2 ) ; this . builder = TYPE_2 . builder ( ) ; } 
<START> public TYPE_3 ( TYPE_1 VAR_2 ) { <END> super ( VAR_2 ) ; this . VAR_3 = TYPE_2 . METHOD_1 ( ) ; } 
<START> public TYPE_1 ( String VAR_2 ) { <END> this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; } 
<START> public TYPE_1 ( ) { <END> super ( STRING_1 ) ; this . VAR_2 = new StringBuilder ( INT_1 ) ; } 
public void METHOD_1 ( ) throws Exception { String [ ] VAR_1 = { STRING_1 , STRING_2 , STRING_3 , "" } ; for ( String name : VAR_1 ) try { TYPE_2 . TYPE_3 . TYPE_1 . create ( name , TYPE_4 . VAR_6 ) ; METHOD_2 ( STRING_4 . METHOD_3 ( name ) ) ; } catch ( Exception ex ) { <START> assertTrue ( ex instanceof IllegalArgumentException ) ; <END> } } 
public TYPE_1 apply ( TYPE_2 VAR_1 ) { TYPE_3 builder = new TYPE_3 ( ) ; TYPE_4 VAR_2 = VAR_3 . METHOD_1 ( VAR_1 . METHOD_2 ( ) ) ; builder . id ( VAR_2 . METHOD_3 ( ) ) ; builder . size ( VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) ; builder . VAR_4 ( true ) ; builder . type ( TYPE_1 . Type . VAR_5 ) ; <START> builder . VAR_6 ( VAR_1 . METHOD_6 ( ) > 0 ) ; <END> return builder . build ( ) ; } 
private TYPE_1 < String , TYPE_2 > METHOD_1 ( ) { return new TYPE_1 < String , TYPE_2 > ( ) { <START> TYPE_2 VAR_1 = TYPE_2 . VAR_2 ; <END> @Override public TYPE_2 apply ( final String description ) { if ( description != null ) { if ( description . contains ( VAR_3 ) ) VAR_1 = TYPE_2 . VAR_3 ; else if ( description . contains ( VAR_4 ) ) VAR_1 = TYPE_2 . VAR_4 ; } logger . debug ( STRING_1 , description , VAR_1 ) ; return VAR_1 ; } } ; } 
public static TYPE_1 METHOD_1 ( ) { TYPE_1 properties = TYPE_2 . METHOD_1 ( ) ; properties . VAR_1 ( Constants . VAR_2 , STRING_1 ) ; properties . VAR_1 ( STRING_2 , STRING_3 ) ; properties . VAR_1 ( Constants . VAR_3 , STRING_4 ) ; <START> properties . VAR_1 ( STRING_5 , STRING_6 ) ; <END> properties . VAR_1 ( TYPE_3 . VAR_5 , STRING_7 ) ; properties . VAR_1 ( VAR_6 , STRING_8 ) ; return properties ; } 
public String METHOD_1 ( TYPE_1 response ) { if ( response . VAR_1 ( ) == null ) return null ; try { return TYPE_2 . toString ( response . VAR_1 ( ) ) ; } catch ( IOException e ) { throw TYPE_3 . METHOD_2 ( e ) ; } finally { try { <START> response . VAR_1 ( ) . METHOD_3 ( ) . close ( ) ; <END> } catch ( IOException e ) { throw TYPE_3 . METHOD_2 ( e ) ; } } } 
public void write ( TYPE_1 out , TYPE_2 value ) throws IOException { METHOD_1 ( value instanceof TYPE_3 || value instanceof TYPE_4 , STRING_1 ) ; if ( value instanceof TYPE_3 ) { out . value ( TYPE_5 . METHOD_2 ( ( TYPE_3 ) value ) ) ; } else { out . value ( TYPE_6 . METHOD_2 ( ( TYPE_4 ) value ) ) ; <START> } <END> } 
public static TYPE_1 METHOD_1 ( String value ) { <START> return METHOD_2 ( asList ( TYPE_1 . values ( ) ) , METHOD_3 ( value ) ) . METHOD_4 ( VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( String name , String id ) { TYPE_2 VAR_1 = null ; try { VAR_1 = VAR_2 . METHOD_2 ( ) . get ( Integer . valueOf ( id ) ) ; <START> } catch ( Exception ex ) { <END> throw new TYPE_3 ( STRING_1 + id ) ; } if ( VAR_1 == null ) { throw new TYPE_3 ( STRING_1 + id ) ; } return new TYPE_5 . TYPE_6 ( ) . METHOD_3 ( id ) . name ( name ) . build ( ) ; } 
public TYPE_1 build ( ) { return new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , resource <START> , VAR_7 ) ; <END> } 
protected TYPE_1 < Object , TYPE_2 < TYPE_3 > > METHOD_1 ( List < Object > args ) { return new TYPE_1 < Object , TYPE_2 < TYPE_3 > > ( ) { @Override <START> public TYPE_2 < TYPE_3 > apply ( ANNOTATION_1 Object input ) { <END> TYPE_4 VAR_1 = TYPE_4 . class . METHOD_2 ( input ) ; return VAR_2 . METHOD_3 ( VAR_1 ) ; } } ; } 
<START> TYPE_4 ( TYPE_1 < TYPE_2 > VAR_2 , TYPE_3 VAR_3 ) { <END> super ( VAR_2 , VAR_3 ) ; } 
public TYPE_1 build ( ) { TYPE_1 options = new TYPE_1 ( ) ; if ( VAR_1 != null ) { options . VAR_2 . put ( STRING_1 , String . valueOf ( VAR_1 ) ) ; VAR_1 = null ; } if ( page != null ) { options . VAR_2 . put ( STRING_2 , String . valueOf ( page ) ) ; <START> } <END> return METHOD_1 ( options ) ; } 
protected TYPE_5 ( String id , Date VAR_2 , TYPE_1 VAR_3 , String name , String description , String VAR_4 , TYPE_1 VAR_5 , TYPE_2 VAR_6 , TYPE_3 VAR_7 ) { super ( TYPE_4 . VAR_9 , id , VAR_2 , VAR_3 , name , description ) ; this . VAR_4 = METHOD_1 ( VAR_4 , STRING_1 , name ) ; this . VAR_5 = METHOD_2 ( VAR_5 ) ; this . VAR_6 = METHOD_1 ( VAR_6 , STRING_2 , name ) ; this . VAR_7 = METHOD_2 ( VAR_7 ) ; <START> ; <END> } 
public void METHOD_1 ( ) { try { if ( METHOD_2 ( ) ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_3 ( VAR_2 , VAR_3 ) ; VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; } } catch ( TYPE_3 | TYPE_4 e ) { <START> log . VAR_4 ( e . getMessage ( ) ) ; <END> } } 
public Builder METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 . add ( VAR_1 ) ; <END> return this ; } 
public void METHOD_1 ( TYPE_1 event ) { this . event = event ; TYPE_2 entity = event . VAR_1 ( ) ; TYPE_2 target = event . VAR_2 ( ) ; this . entity = new TYPE_3 ( entity ) ; this . target = target != null ? new TYPE_3 ( target ) : null ; TYPE_3 . METHOD_2 ( entity ) ; <START> TYPE_3 . METHOD_2 ( target ) ; <END> METHOD_3 ( event ) ; TYPE_3 . METHOD_4 ( entity ) ; TYPE_3 . METHOD_4 ( target ) ; } 
public static void METHOD_1 ( ) { TYPE_3 < TYPE_1 > METHOD_2 ( STRING_1 , ( VAR_2 , VAR_3 ) - > { <START> return new TYPE_2 ( String . valueOf ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ) ) ; <END> } ) ; } 
public int METHOD_1 ( ) { if ( METHOD_2 ( ) ) { return METHOD_3 ( ) . METHOD_4 ( ) ; } <START> if ( METHOD_5 ( ) ) { <END> return METHOD_6 ( ) . METHOD_7 ( ) ; } else if ( METHOD_8 ( ) ) { return METHOD_9 ( ) ; } return METHOD_10 ( ) . METHOD_11 ( ) ; } 
public static void METHOD_1 ( ) { TYPE_1 . log ( STRING_1 ) ; TYPE_2 . METHOD_2 ( new TYPE_3 ( ) ) ; TYPE_2 . METHOD_2 ( new TYPE_4 ( ) ) ; TYPE_2 . METHOD_2 ( new TYPE_5 ( ) ) ; <START> TYPE_2 . METHOD_2 ( new TYPE_6 ( ) ) ; <END> TYPE_2 . METHOD_2 ( new TYPE_7 ( ) ) ; TYPE_2 . METHOD_2 ( new TYPE_8 ( ) ) ; TYPE_2 . METHOD_2 ( new TYPE_9 ( ) ) ; TYPE_10 . METHOD_3 ( TYPE_11 . class , TYPE_12 . class ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( event != null ? TYPE_3 . METHOD_2 ( event . VAR_1 ( ) ) : null , null ) ; <END> } 
public String METHOD_1 ( ) { <START> return entity . VAR_1 ( ) instanceof TYPE_1 ? ( ( TYPE_1 ) entity . VAR_1 ( ) ) . METHOD_2 ( ) + "" : null ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( STRING_1 ) && entity . VAR_2 ( ) instanceof TYPE_2 && VAR_1 . METHOD_3 ( ) ) { <END> ( ( TYPE_2 ) entity . VAR_2 ( ) ) . METHOD_4 ( VAR_1 . getValue ( ) . METHOD_5 ( ) ) ; } } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return null ; } <START> if ( VAR_1 . startsWith ( STRING_1 ) && entity . VAR_2 ( ) instanceof TYPE_2 ) { <END> return new TYPE_3 ( ( ( TYPE_2 ) entity . VAR_2 ( ) ) . METHOD_2 ( ) ) . METHOD_1 ( VAR_1 . METHOD_3 ( 1 ) ) ; } return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( this , VAR_1 ) ; if ( ! VAR_1 . METHOD_3 ( ) ) { <START> VAR_1 . METHOD_4 ( ) ; <END> } } 
public Boolean METHOD_1 ( String VAR_1 ) { String VAR_2 = this . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 != null && STRING_1 . equals ( VAR_2 ) ) { <END> return true ; } else { return false ; } } 
public synchronized void METHOD_1 ( ANNOTATION_1 TYPE_1 event ) { <START> TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( event . VAR_3 ( ) , event . VAR_4 ( ) ) ; <END> String VAR_5 = VAR_1 . METHOD_3 ( ) ; String VAR_6 = VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; TYPE_3 user = new TYPE_3 ( VAR_5 , VAR_6 ) ; VAR_7 . METHOD_6 ( user ) ; } 
public static boolean METHOD_1 ( String string ) { if ( string == null ) { return true ; } int length = string . length ( ) ; if ( length > 0 ) { for ( int i = 0 ; i < length ; i ++ ) { if ( ! TYPE_1 . METHOD_2 ( string . VAR_1 ( i ) ) ) { return false ; } } } <START> return true ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 . get ( VAR_1 . toString ( ) . METHOD_2 ( ) ) ; <END> return VAR_1 . METHOD_3 ( TYPE_6 . VAR_3 . getProperty ( ) , TYPE_4 . TYPE_5 . METHOD_4 ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { return VAR_2 ? VAR_3 . METHOD_2 ( ) : TYPE_2 . get ( VAR_4 , <START> VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { <START> if ( VAR_2 . equals ( STRING_1 ) || VAR_2 == null ) { <END> VAR_2 = TYPE_2 . getId ( ) ; } TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( VAR_2 ) ; TYPE_5 VAR_4 = TYPE_5 . METHOD_3 ( ) ; LOG . debug ( STRING_2 , VAR_4 . METHOD_4 ( ) , VAR_2 , VAR_1 ) ; return VAR_5 . METHOD_1 ( VAR_1 , VAR_4 . METHOD_5 ( ) , VAR_3 ) ; } 
<START> byte [ ] METHOD_1 ( ) { <END> return STRING_1 . METHOD_2 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 model ) { Map < String , String > VAR_2 = METHOD_2 ( ) ; String VAR_3 = VAR_2 . get ( TYPE_4 . VAR_3 . name ( ) ) ; <START> if ( Boolean . VAR_5 ( VAR_3 ) ) { <END> model . add ( VAR_1 , TYPE_3 . VAR_7 , VAR_8 ) ; model . add ( VAR_1 , TYPE_3 . VAR_7 , VAR_9 ) ; } } 
private Boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> Boolean VAR_2 ; <END> try { TYPE_1 VAR_3 = VAR_1 . METHOD_2 ( STRING_1 , VAR_4 ) . METHOD_2 ( STRING_2 , VAR_4 ) ; VAR_2 = true ; } catch ( TYPE_2 e ) { VAR_2 = false ; } return VAR_2 ; } 
public static synchronized TYPE_1 getInstance ( ) { TYPE_1 VAR_1 = instance ; <START> if ( VAR_1 == null ) { <END> VAR_1 = new TYPE_1 ( ) ; instance = VAR_1 ; TYPE_2 . METHOD_1 ( ) ; } return VAR_1 ; } 
<START> protected TYPE_1 ( String VAR_2 ) { <END> this . VAR_2 = VAR_2 ; if ( ! VAR_2 . METHOD_1 ( STRING_1 ) ) { this . VAR_2 += STRING_1 ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 ) { String VAR_6 = METHOD_2 ( ) ; <START> TYPE_3 VAR_7 = TYPE_4 . METHOD_3 ( ) ; <END> TYPE_5 VAR_8 = VAR_7 . METHOD_4 ( VAR_6 ) ; VAR_8 . METHOD_5 ( VAR_9 . type , TYPE_6 . TYPE_7 ) ; return VAR_12 . METHOD_6 ( VAR_13 , VAR_14 , VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_7 ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 ) ; TYPE_1 VAR_1 = VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; METHOD_5 ( VAR_1 ) ; VAR_3 = METHOD_6 ( STRING_2 ) ; METHOD_7 ( ) ; job . run ( ) ; METHOD_8 ( VAR_4 ) . METHOD_9 ( METHOD_10 ( TYPE_2 . class ) ) ; <START> TYPE_1 VAR_5 = VAR_6 . METHOD_11 ( VAR_2 . METHOD_12 ( ) ) . METHOD_3 ( ) . METHOD_4 ( ) ; <END> METHOD_13 ( VAR_5 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_2 ( STRING_1 + VAR_3 . METHOD_3 ( ) + STRING_2 + VAR_1 , VAR_1 , VAR_3 . METHOD_4 ( ) , TYPE_4 . VAR_5 ) ; TYPE_2 VAR_6 = VAR_7 . METHOD_5 ( VAR_1 ) ; <START> TYPE_3 VAR_8 = ( TYPE_3 ) VAR_6 ; <END> METHOD_6 ( VAR_1 ) ; VAR_9 . METHOD_7 ( VAR_8 ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( TYPE_1 . VAR_2 ) ; <START> VAR_3 . METHOD_1 ( ) ; <END> } 
private List < TYPE_1 > METHOD_1 ( int VAR_1 ) { <START> List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; <END> int i = 0 ; while ( i < VAR_1 ) { TYPE_1 VAR_3 = METHOD_2 ( TYPE_1 . class ) ; when ( VAR_3 . getId ( ) ) . METHOD_3 ( STRING_1 + TYPE_2 . METHOD_4 ( ) . toString ( ) ) ; VAR_2 . add ( VAR_3 ) ; i ++ ; } return VAR_2 ; } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; <END> try { VAR_1 . METHOD_2 ( VAR_6 ) ; } finally { METHOD_3 ( VAR_1 ) . equals ( TYPE_2 . class ) ; } } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 ) . METHOD_3 ( 0 ) ; METHOD_4 ( VAR_1 ) ; Map < String , Object > VAR_2 = METHOD_5 ( VAR_3 , VAR_4 ) ; <START> VAR_2 . put ( VAR_5 , STRING_2 ) ; <END> VAR_6 . METHOD_6 ( "" , VAR_2 ) ; METHOD_7 ( ) ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; TYPE_1 < TYPE_2 > VAR_3 = TYPE_1 . METHOD_3 ( TYPE_2 . class ) ; <START> METHOD_4 ( VAR_4 ) . METHOD_2 ( METHOD_5 ( VAR_1 ) , VAR_3 . METHOD_6 ( ) ) ; <END> TYPE_2 child = VAR_3 . getValue ( ) ; METHOD_7 ( STRING_1 , child instanceof TYPE_3 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 , TYPE_6 . VAR_4 ) ; TYPE_1 VAR_5 = TYPE_1 . create ( VAR_2 ) ; if ( METHOD_3 ( VAR_5 ) ) { <START> return VAR_1 ; <END> } TYPE_3 model = TYPE_4 . METHOD_4 ( ) ; TYPE_5 VAR_6 = model . VAR_7 ( VAR_2 ) ; VAR_6 . METHOD_5 ( VAR_8 . VAR_9 , STRING_1 ) ; VAR_10 . METHOD_6 ( VAR_5 , model ) ; return VAR_5 ; } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = this . METHOD_2 ( ) ; <END> TYPE_3 s = VAR_1 . getProperty ( TYPE_6 . VAR_3 ) ; if ( s != null ) { TYPE_4 VAR_4 = TYPE_5 . get ( s . VAR_5 ( ) . METHOD_3 ( ) ) ; return VAR_6 . METHOD_4 ( VAR_4 ) ; } else { return null ; } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 ) ; <START> when ( VAR_3 . METHOD_2 ( METHOD_3 ( TYPE_2 . class ) , METHOD_3 ( TYPE_3 . class ) ) ) <END> . METHOD_4 ( VAR_1 ) ; VAR_5 . METHOD_5 ( VAR_1 ) ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 model ) { <END> this . model = model ; return this ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( ) ; <START> TYPE_4 VAR_3 = VAR_2 . METHOD_3 ( STRING_1 ) ; <END> METHOD_4 ( TYPE_5 . VAR_5 , VAR_3 , STRING_2 , VAR_1 ) ; return this ; } 
public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 , Date VAR_4 , TYPE_2 VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = VAR_4 ; <END> this . VAR_5 = VAR_5 ; METHOD_1 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { File file = new File ( VAR_2 , TYPE_3 . VAR_4 + STRING_1 + VAR_1 . METHOD_2 ( ) + STRING_2 ) ; try { TYPE_1 VAR_5 ; if ( ! file . exists ( ) ) { file . VAR_6 ( ) . METHOD_3 ( ) ; } <START> VAR_5 = METHOD_4 ( VAR_1 , file ) ; <END> return VAR_5 ; } catch ( IOException e ) { METHOD_5 ( e , STRING_3 , file . VAR_7 ( ) ) ; } return null ; } 
public void METHOD_1 ( ) throws Exception { LOG . info ( STRING_1 ) ; Map < String , TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( TYPE_1 . class ) ; for ( TYPE_1 VAR_3 : VAR_1 . values ( ) ) { VAR_3 . METHOD_3 ( true ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> } } 
protected String METHOD_1 ( ) { String result = null ; ANNOTATION_1 ( STRING_1 ) Iterator i = VAR_1 . METHOD_2 ( new TYPE_1 ( STRING_2 , TYPE_3 . VAR_3 ) ) ; while ( i . hasNext ( ) ) { TYPE_2 e = ( TYPE_2 ) i . next ( ) ; String VAR_4 = e . VAR_5 ( ) ; <START> if ( VAR_4 . length ( ) > 0 ) result = VAR_4 ; <END> } return result ; } 
private static TYPE_1 create ( String name , int VAR_1 , List < TYPE_2 > VAR_2 ) { <START> return builder ( ) . name ( name ) . METHOD_1 ( VAR_1 ) . METHOD_2 ( VAR_2 ) . build ( ) ; <END> } 
public org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_1 build ( ) { <START> return new org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_1 ( this ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { METHOD_2 ( VAR_1 ) ; <START> return new org . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . VAR_7 . TYPE_2 ( <END> METHOD_3 ( VAR_1 ) , VAR_9 ) ; } 
protected TYPE_2 ( long VAR_2 , long VAR_3 , long VAR_4 , Map < String , String > metadata , TYPE_1 < String , String > VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . metadata = metadata == null ? TYPE_3 < String , String > of ( ) : METHOD_1 ( metadata , STRING_1 ) ; <START> this . VAR_5 = VAR_5 == null ? TYPE_4 < String , String > of ( ) : METHOD_1 ( VAR_5 , STRING_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 < String , String > VAR_1 ) { <START> if ( ! VAR_1 . isEmpty ( ) ) { <END> this . VAR_1 . METHOD_2 ( VAR_1 ) ; } return this ; } 
public void METHOD_1 ( ) { TYPE_1 options = new TYPE_1 ( ) . METHOD_2 ( TYPE_2 . of ( VAR_1 , STRING_1 ) ) ; <START> assertEquals ( ImmutableList . of ( STRING_1 ) , options . VAR_2 ( ) . get ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 < String , String > VAR_1 = TYPE_2 . of ( VAR_2 , STRING_1 ) ; TYPE_3 options = new TYPE_3 ( ) . METHOD_2 ( VAR_1 ) ; <START> assertEquals ( ImmutableList . of ( STRING_1 ) , options . VAR_3 ( ) . get ( VAR_2 ) ) ; <END> } 
public void METHOD_1 ( ) throws Exception { for ( String VAR_1 : VAR_2 ) { TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 , VAR_5 ) ; TYPE_2 response = VAR_3 . list ( ) ; assertEquals ( response . VAR_6 ( ) , VAR_4 . METHOD_3 ( VAR_1 ) . get ( VAR_5 ) ) ; <START> assertNotNull ( response ) ; <END> for ( TYPE_3 object : response ) { METHOD_4 ( object ) ; } } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_1 . builder ( ) . METHOD_2 ( INT_1 ) . message ( STRING_1 ) . METHOD_3 ( METHOD_4 ( STRING_2 , STRING_3 ) ) . build ( ) ; TYPE_2 VAR_2 = METHOD_5 ( VAR_3 , VAR_4 , VAR_5 , VAR_1 ) ; try { VAR_2 . METHOD_6 ( STRING_4 ) . list ( ) ; } catch ( TYPE_3 e ) { if ( e . VAR_6 ( ) . getClass ( ) == TYPE_4 . class ) return ; } <START> METHOD_7 ( STRING_5 ) ; <END> } 
public Builder metadata ( Map < String , Object > metadata ) { if ( metadata == null ) { this . metadata = TYPE_1 . of ( ) ; } else { this . metadata = TYPE_1 . METHOD_1 ( metadata ) ; <START> } <END> return this ; } 
public static TYPE_1 METHOD_1 ( String value ) { <START> if ( value == null ) return null ; <END> return TYPE_1 . valueOf ( value . VAR_1 ( ) ) ; } 
public static TYPE_1 METHOD_1 ( ) { System . VAR_1 ( VAR_2 , STRING_1 ) ; System . VAR_1 ( VAR_3 , STRING_2 ) ; System . VAR_1 ( VAR_4 , STRING_3 ) ; <START> System . VAR_1 ( VAR_5 , STRING_4 ) ; <END> TYPE_1 properties = TYPE_2 . METHOD_1 ( ) ; properties . VAR_1 ( VAR_6 , TYPE_3 . VAR_8 ) ; properties . VAR_1 ( VAR_9 , TYPE_4 . VAR_11 ) ; return properties ; } 
public Builder METHOD_1 ( int VAR_1 ) { METHOD_2 ( VAR_1 >= METHOD_3 ( VAR_2 ) , STRING_1 , METHOD_3 ( VAR_2 ) ) ; <START> METHOD_2 ( VAR_1 <= METHOD_3 ( VAR_3 ) , STRING_2 , METHOD_3 ( VAR_3 ) ) ; <END> this . VAR_1 = VAR_1 ; return METHOD_4 ( ) ; } 
<START> protected static String METHOD_1 ( String VAR_1 ) { <END> return VAR_1 . substring ( VAR_1 . METHOD_2 ( CHAR_1 ) + 1 ) ; } 
protected void METHOD_1 ( ) { <START> bind ( TYPE_1 . class ) . to ( TYPE_2 . class ) ; <END> super . METHOD_1 ( ) ; } 
public int METHOD_1 ( TYPE_1 that ) { <START> if ( that == null ) <END> return 1 ; if ( this == that ) return 0 ; return this . METHOD_2 ( ) . METHOD_1 ( that . VAR_1 ( ) ) ; } 
public TYPE_1 filter ( TYPE_1 request ) throws TYPE_2 { String VAR_1 = request . VAR_2 ( ) . toString ( ) ; <START> TYPE_3 VAR_3 = TYPE_3 . METHOD_1 ( STRING_1 ) ; <END> TYPE_4 matcher = VAR_3 . matcher ( VAR_1 ) ; matcher . VAR_4 ( ) ; String VAR_5 = matcher . group ( ) ; String VAR_6 = VAR_5 . METHOD_2 ( STRING_2 , STRING_3 ) ; String VAR_7 = matcher . VAR_8 ( VAR_6 ) ; return request . VAR_9 ( ) . METHOD_3 ( VAR_7 ) . build ( ) ; } 
public TYPE_5 ( Object VAR_2 , TYPE_1 VAR_3 ) { if ( VAR_2 == null ) return ; new TYPE_2 ( ) . parse ( VAR_2 , this ) ; if ( VAR_3 . METHOD_1 ( ) ) { Collections . VAR_4 ( options , new TYPE_3 < TYPE_4 > ( ) { public int METHOD_2 ( TYPE_4 VAR_5 , TYPE_4 VAR_6 ) { return VAR_5 . VAR_7 . toString ( ) . METHOD_3 ( VAR_6 . VAR_7 . toString ( ) ) ; } } ) ; } <START> METHOD_4 ( VAR_3 . METHOD_5 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { if ( VAR_1 < 0 ) throw new IllegalArgumentException ( STRING_1 ) ; if ( this . VAR_1 == VAR_1 ) return this ; <START> return new TYPE_1 ( VAR_1 , this . VAR_2 ) ; <END> } 
public static List < Class < ? > > METHOD_1 ( Class VAR_1 ) { <START> ArrayList < Class < ? > > result = new ArrayList < Class < ? > > ( ) ; <END> METHOD_2 ( VAR_1 , result ) ; return result ; } 
public static void METHOD_1 ( Context context , TYPE_1 db , int VAR_1 , int VAR_2 ) { if ( VAR_2 <= 2 ) { db . VAR_3 ( VAR_4 ) ; METHOD_2 ( context , db ) ; } else if ( VAR_2 >= 3 ) { final String VAR_5 = STRING_1 + VAR_6 + STRING_2 + VAR_7 + STRING_3 ; <START> db . VAR_3 ( VAR_5 ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; VAR_1 . METHOD_4 ( STRING_2 ) ; VAR_1 . METHOD_5 ( STRING_3 ) ; Map < String , String > VAR_3 = VAR_1 . METHOD_6 ( ) ; assertThat ( VAR_3 . size ( ) , is ( 0 ) ) ; METHOD_7 ( VAR_3 . get ( STRING_1 ) ) ; <START> METHOD_7 ( VAR_3 . get ( STRING_2 ) ) ; <END> } 
private void METHOD_1 ( ) throws IOException { <START> LOGGER . debug ( STRING_1 , VAR_1 ) ; <END> LOGGER . debug ( STRING_2 , VAR_2 ) ; LOGGER . debug ( STRING_3 , VAR_3 ) ; TYPE_1 . METHOD_2 ( VAR_1 ) ; TYPE_1 . METHOD_2 ( VAR_2 ) ; TYPE_1 . METHOD_2 ( VAR_3 ) ; } 
public TYPE_3 ( ANNOTATION_1 ( STRING_1 ) final Path VAR_2 ) { <START> LOGGER . info ( STRING_2 , <END> VAR_2 ) ; try { this . VAR_2 = TYPE_1 . METHOD_1 ( VAR_2 ) ; } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } } 
<START> private String METHOD_1 ( final String value ) throws Exception { <END> return TYPE_1 . METHOD_1 ( value , TYPE_2 . VAR_2 ) ; } 
<START> public static final TYPE_1 METHOD_1 ( final String VAR_1 ) { <END> for ( TYPE_1 o : TYPE_1 . values ( ) ) { if ( o . value . equals ( VAR_1 ) ) { return o ; } } throw new IllegalArgumentException ( STRING_1 + VAR_1 + STRING_2 ) ; } 
<START> public TYPE_3 ( final TYPE_1 field , final TYPE_2 VAR_2 , final String object ) { <END> this . field = field ; this . VAR_2 = VAR_2 ; this . object = object ; } 
public void METHOD_1 ( TYPE_1 context ) throws Exception { <START> TYPE_2 . getInstance ( ) . METHOD_2 ( ) ; <END> super . METHOD_1 ( context ) ; } 
protected Object METHOD_1 ( final boolean VAR_1 ) throws TYPE_1 , IOException { <START> final Object obj = VAR_2 . METHOD_2 ( METHOD_1 ( METHOD_3 ( ) , VAR_1 ) ) ; <END> if ( VAR_3 == 0 ) { final TYPE_2 < TYPE_3 > VAR_4 = this . VAR_4 ; if ( VAR_4 != null ) { this . VAR_4 = null ; VAR_5 = 0 ; for ( TYPE_3 VAR_6 : VAR_4 ) { VAR_6 . METHOD_4 ( ) . METHOD_5 ( ) ; } } } return obj ; } 
protected TYPE_1 < List < String > > METHOD_1 ( TYPE_2 < List < TYPE_3 > > VAR_1 ) { return response - > { List < TYPE_3 > VAR_2 = response . stream ( ) . map ( this : : METHOD_2 ) <START> . filter ( this : : METHOD_3 ) <END> . METHOD_4 ( TYPE_4 . METHOD_5 ( TYPE_3 : : METHOD_6 , String . VAR_3 ) ) . collect ( Collectors . VAR_4 ( ) ) ; VAR_1 . METHOD_7 ( VAR_2 ) ; } ; } 
protected void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . TYPE_3 : : METHOD_4 ) ; VAR_1 . METHOD_5 ( ) . METHOD_3 ( TYPE_2 . TYPE_3 : : METHOD_4 ) ; VAR_1 . METHOD_6 ( ) . METHOD_3 ( TYPE_2 . TYPE_3 : : METHOD_4 ) ; VAR_2 . METHOD_7 ( ) ; <END> } 
<START> protected double METHOD_1 ( String VAR_1 ) { <END> TYPE_2 . TYPE_3 VAR_2 ; try { VAR_2 = TYPE_2 . TYPE_3 . valueOf ( VAR_1 ) ; } catch ( IllegalArgumentException e ) { VAR_2 = TYPE_2 . TYPE_3 . TYPE_6 ; } switch ( VAR_2 ) { case TYPE_5 : return INT_1 ; case TYPE_4 : return INT_2 ; default : return INT_3 ; } } 
private boolean METHOD_1 ( ) { return VAR_1 != null && VAR_1 . METHOD_2 ( ) != null && <START> VAR_1 . METHOD_2 ( ) . split ( STRING_1 ) . length > 1 ; <END> } 
protected static TYPE_1 METHOD_1 ( TYPE_2 source ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_3 VAR_2 = new TYPE_3 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; final List < TYPE_4 > VAR_3 = source . VAR_4 ( ) ; <START> List < TYPE_5 > VAR_5 = new ArrayList < > ( ) ; METHOD_3 ( VAR_5 , VAR_3 ) ; VAR_2 . METHOD_4 ( VAR_5 ) ; <END> return VAR_1 ; } 
protected static TYPE_1 METHOD_1 ( TYPE_2 source ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> if ( source != null ) { final TYPE_3 VAR_2 = source . VAR_3 ( ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( ) . forEach ( VAR_4 - > VAR_1 . METHOD_3 ( METHOD_2 ( VAR_4 ) ) ) ; } } <END> return VAR_1 ; } 
public void METHOD_1 ( TYPE_1 < List < TYPE_2 > > VAR_1 ) { List < TYPE_2 > VAR_2 = new ArrayList < > ( ) ; <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> } 
private String METHOD_1 ( final String value ) { <START> if ( value != null && value . VAR_1 ( STRING_1 ) > 1 ) { <END> return value . substring ( 0 , value . VAR_1 ( STRING_1 ) ) ; } else { return value ; } } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ; METHOD_3 ( VAR_1 , METHOD_4 ( 1 ) ) . METHOD_5 ( ) ; METHOD_3 ( VAR_1 , METHOD_4 ( 1 ) ) . METHOD_6 ( ) ; <START> METHOD_3 ( VAR_1 , METHOD_7 ( ) ) . METHOD_8 ( METHOD_9 ( true ) ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( true ) ; <START> VAR_1 . METHOD_3 ( false ) ; <END> VAR_2 . METHOD_4 ( ) ; VAR_2 . METHOD_5 ( ) ; VAR_3 . METHOD_6 ( ) ; METHOD_7 ( TYPE_1 . VAR_5 ) ; } 
protected void METHOD_1 ( ) { <START> String value = getValue ( ) ; <END> if ( ! value . startsWith ( VAR_1 ) ) { if ( value . startsWith ( VAR_2 ) ) { VAR_3 . METHOD_2 ( value . VAR_4 ( VAR_2 , VAR_1 ) ) ; } else if ( value . startsWith ( STRING_1 ) ) { VAR_3 . METHOD_2 ( value . VAR_4 ( STRING_1 , VAR_1 ) ) ; } else { VAR_3 . METHOD_2 ( VAR_1 + value ) ; } } } 
protected TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 type , TYPE_3 < String , TYPE_1 > VAR_2 , TYPE_1 . Type VAR_3 ) throws TYPE_4 { <START> return METHOD_2 ( ( TYPE_5 ) type ) ? METHOD_3 ( new HashMap < > ( ) , VAR_1 , type , VAR_2 , VAR_3 , new ArrayList < > ( ) ) : METHOD_4 ( new HashMap < > ( ) , VAR_1 , VAR_1 , type . getName ( ) , type , VAR_2 , VAR_3 , new ArrayList < > ( ) ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { if ( VAR_2 != null ) { VAR_3 . METHOD_2 ( view . VAR_4 ( ) . METHOD_3 ( ) ) ; switch ( TYPE_1 . Type . valueOf ( VAR_1 ) ) { case VAR_6 : METHOD_4 ( ) ; break ; case VAR_7 : METHOD_5 ( ) ; <START> break ; <END> } VAR_2 . execute ( ) ; } } 
<START> public void METHOD_1 ( final TYPE_1 < Path > VAR_1 ) { <END> final String VAR_2 = METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 ) ; } 
public void METHOD_1 ( ) { when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( Collections . VAR_2 ( ) ) ; <START> when ( VAR_1 . METHOD_4 ( ) ) . METHOD_3 ( TYPE_1 . create ( VAR_3 , VAR_4 ) ) ; <END> assertTrue ( VAR_5 . METHOD_5 ( VAR_6 ) ) ; } 
private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) != null && ! VAR_1 . METHOD_2 ( ) . trim ( ) . isEmpty ( ) ; <END> } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { return TYPE_2 . equals ( VAR_1 . METHOD_2 ( ) . getType ( ) ) || TYPE_3 . equals ( VAR_1 . METHOD_3 ( ) ) || <START> VAR_1 . METHOD_4 ( ) . size ( ) == 0 ; <END> } 
public void METHOD_1 ( int VAR_1 ) { METHOD_2 ( ) ; final TYPE_1 < ? > VAR_2 = METHOD_3 ( ) . get ( VAR_1 ) ; METHOD_1 ( VAR_2 ) ; VAR_3 . METHOD_4 ( VAR_1 ) ; <START> METHOD_5 ( ) ; <END> } 
public void METHOD_1 ( String VAR_1 ) { <START> TYPE_1 . log ( this . toString ( ) + STRING_1 + VAR_1 + STRING_2 ) ; <END> VAR_2 . METHOD_1 ( VAR_1 , METHOD_2 ( ) , METHOD_3 ( ) , context . getStatus ( ) . METHOD_4 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 event ) { context . getStatus ( ) . METHOD_2 ( String . valueOf ( new Date ( ) . METHOD_3 ( ) ) ) ; context . getStatus ( ) . METHOD_4 ( event . VAR_1 ( ) ) ; METHOD_5 ( context , new TYPE_2 ( ) ) ; <START> context . VAR_2 ( ) . METHOD_6 ( true ) ; <END> } 
public String getType ( final Optional < String > VAR_1 ) throws TYPE_1 { try { Logger . add ( STRING_1 ) ; if ( VAR_1 . isPresent ( ) ) { return VAR_2 . METHOD_1 ( ) ; } final String type = VAR_3 . getType ( VAR_2 , VAR_4 ) ; <START> Logger . add ( STRING_2 + type ) ; <END> return type ; } catch ( final Exception e ) { throw new TYPE_1 ( STRING_3 + TYPE_2 . toString ( VAR_2 ) + STRING_4 + VAR_4 , e ) ; } } 
<START> protected TYPE_1 METHOD_1 ( Class VAR_1 ) { <END> String key = VAR_1 . METHOD_2 ( ) ; Map < String , String > VAR_2 = new HashMap < > ( ) ; String VAR_3 = VAR_1 . METHOD_3 ( ) ; VAR_2 . put ( STRING_1 , VAR_3 ) ; String VAR_4 = VAR_3 . substring ( 0 , VAR_3 . METHOD_4 ( STRING_2 ) ) ; return new TYPE_1 ( key , VAR_4 , VAR_2 ) ; } 
public TYPE_1 build ( ) { List < TYPE_4 . TYPE_5 > VAR_1 = VAR_2 . build ( ) ; TYPE_3 VAR_3 = VAR_4 != null ? VAR_4 : new TYPE_3 ( ) ; TYPE_1 VAR_5 = new TYPE_1 ( VAR_1 , VAR_3 , VAR_6 , VAR_7 , VAR_8 , VAR_9 ) ; VAR_5 . METHOD_1 ( TYPE_4 . TYPE_6 . VAR_11 ) ; <START> VAR_5 . METHOD_2 ( VAR_6 ) ; <END> return VAR_5 ; } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> VAR_2 . remove ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( final Path path ) throws Exception { TYPE_2 VAR_1 = null ; try { VAR_1 = VAR_2 . METHOD_2 ( path , TYPE_4 . VAR_4 ) ; <START> final String VAR_5 = TYPE_3 . METHOD_3 ( VAR_1 , <END> null ) ; return METHOD_4 ( path , VAR_5 ) ; } finally { if ( VAR_1 != null ) { try { VAR_1 . close ( ) ; } catch ( IOException e ) { } } } } 
public TYPE_6 ( final TYPE_1 < TYPE_2 > VAR_2 , final TYPE_3 type , final TYPE_4 VAR_3 , final TYPE_5 VAR_4 ) { super ( ) ; <START> this . VAR_5 = METHOD_1 ( ) ; <END> this . VAR_2 = VAR_2 ; this . type = type ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
void METHOD_1 ( ) { view . VAR_1 ( VAR_2 . METHOD_2 ( ) ) ; <START> VAR_2 . METHOD_3 ( ) ; <END> VAR_3 = null ; } 
public TYPE_4 ( ) { super ( ) ; setText ( TYPE_2 . TYPE_3 . METHOD_1 ( ) ) ; METHOD_2 ( TYPE_2 . TYPE_3 . METHOD_3 ( ) ) ; METHOD_4 ( ( VAR_2 ) - > { <START> VAR_3 . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( STRING_1 , <END> STRING_2 ) ; VAR_3 . METHOD_8 ( ( VAR_4 ) - > VAR_5 . execute ( ) ) ; } ) ; } 
<START> public TYPE_1 METHOD_1 ( String [ ] VAR_1 , <END> TYPE_2 VAR_2 ) { return new TYPE_1 ( VAR_1 , VAR_2 ) ; } 
public static void METHOD_1 ( final String VAR_1 , final Set < TYPE_1 > result , final int VAR_2 ) { METHOD_2 ( STRING_1 + VAR_1 , result . stream ( ) . filter ( VAR_3 - > METHOD_3 ( VAR_3 , VAR_1 ) && METHOD_4 ( VAR_3 , <START> new HashSet < Integer > ( ) { { <END> add ( VAR_2 ) ; } } ) ) . count ( ) > 0 ) ; } 
public void METHOD_1 ( final TYPE_1 page ) { this . page = page ; clear ( ) ; <START> METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( ) { final String VAR_1 = METHOD_2 ( TYPE_2 . TYPE_1 ) ; VAR_4 . clear ( ) ; VAR_4 . METHOD_3 ( STRING_1 + VAR_1 + STRING_2 , "" ) ; <START> page . VAR_5 ( VAR_6 - > VAR_4 . METHOD_3 ( VAR_6 ) ) ; <END> VAR_4 . METHOD_4 ( METHOD_5 ( METHOD_6 ( ) , VAR_4 ) ) ; } 
public int METHOD_1 ( ) { int result = VAR_1 != null ? VAR_1 . METHOD_1 ( ) : 0 ; result = INT_1 * result + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) ; result = INT_1 * result + ( VAR_3 != null ? VAR_3 . METHOD_1 ( ) : 0 ) ; result = INT_1 * result + ( VAR_4 != null ? VAR_4 . METHOD_1 ( ) : 0 ) ; <START> return result ; <END> } 
public int METHOD_1 ( ) { int result = VAR_1 . METHOD_1 ( ) ; <START> result = INT_1 * result + name . VAR_2 ( ) ; <END> return result ; } 
protected String [ ] METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> return VAR_1 ; } 
public int METHOD_1 ( ) { <START> return INT_1 * VAR_1 . METHOD_1 ( ) + VAR_2 . METHOD_1 ( ) ; <END> } 
void METHOD_1 ( ) { VAR_1 . METHOD_2 ( new TYPE_1 ( VAR_2 , parent . VAR_3 ( ) . METHOD_3 ( ) , VAR_4 , new TYPE_1 . TYPE_4 ( ) { @Override public String METHOD_4 ( ) { return VAR_2 . METHOD_5 ( ) + STRING_1 + VAR_5 . METHOD_6 ( ) ; } } , new TYPE_3 ( ) { @Override public void run ( ) { } <START> } ) , <END> parent ) ; } 
private boolean METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> if ( VAR_1 [ 0 ] . METHOD_2 ( ) . getName ( ) . equals ( VAR_1 [ 0 ] . METHOD_3 ( ) . getName ( ) ) ) { <END> return true ; } else { return false ; } } 
private int METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < TYPE_1 > VAR_2 , int val ) { int VAR_3 ; <START> if ( VAR_2 == TYPE_3 . METHOD_2 ( ) ) { VAR_3 = TYPE_4 . METHOD_3 ( VAR_4 . METHOD_4 ( VAR_1 , val , true ) ) ; } else if ( VAR_2 == TYPE_3 . METHOD_5 ( ) ) { <END> VAR_3 = VAR_4 . METHOD_4 ( VAR_1 , val , true ) ; } else { throw new TYPE_5 ( STRING_1 + VAR_2 ) ; } return VAR_3 ; } 
public int METHOD_1 ( int VAR_1 ) { <START> if ( VAR_2 ) { <END> return TYPE_1 . METHOD_2 ( ) ; } return TYPE_1 . METHOD_3 ( ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { for ( int i = VAR_1 . METHOD_2 ( 0 ) ; i >= 0 ; i = VAR_1 . METHOD_2 ( i + 1 ) ) { <START> if ( VAR_2 . METHOD_3 ( i ) . size ( ) * VAR_2 . METHOD_4 ( i ) . size ( ) == 0 ) { <END> VAR_3 [ i ] = VAR_4 ; VAR_5 [ VAR_4 ++ ] = i ; VAR_1 . clear ( i ) ; } } } 
public static void METHOD_1 ( ByteBuffer buffer ) { try { if ( buffer . VAR_1 ( ) ) { METHOD_2 ( ( TYPE_1 ) buffer ) ; } } <START> catch ( Exception e ) { <END> throw TYPE_2 . METHOD_3 ( e ) ; } } 
<START> public static Boolean METHOD_1 ( String VAR_1 ) <END> { if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { return false ; } return VAR_1 . METHOD_3 ( VAR_2 ) ; } 
public static Boolean METHOD_1 ( String VAR_1 ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { return false ; } <START> return VAR_1 . METHOD_3 ( TYPE_2 ) && VAR_1 . length ( ) > TYPE_2 . length ( ) ; <END> } 
<START> private void METHOD_1 ( Collection < File > VAR_1 ) <END> { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return ; } long size = INT_1 ; for ( File file : VAR_1 ) { size += file . length ( ) ; } this . VAR_1 . addAll ( VAR_1 ) ; this . size += size ; } 
public static void METHOD_1 ( TYPE_1 is , File file ) throws IOException { TYPE_2 VAR_1 = null ; try { file . VAR_2 ( ) . METHOD_2 ( ) ; VAR_1 = new TYPE_3 ( new TYPE_4 ( file ) ) ; TYPE_5 . METHOD_3 ( is , VAR_1 ) ; } finally { TYPE_6 . close ( is ) ; <START> TYPE_6 . close ( VAR_1 ) ; <END> } } 
<START> public void METHOD_1 ( String VAR_1 ) throws TYPE_1 <END> { try { METHOD_1 ( VAR_2 . split ( VAR_1 ) ) ; } catch ( Exception e ) { TYPE_2 . METHOD_2 ( e , TYPE_1 . class ) ; throw new TYPE_1 . Builder ( ) . METHOD_3 ( TYPE_1 . TYPE_3 . VAR_4 ) . METHOD_4 ( e . getMessage ( ) ) . build ( ) ; } } 
<START> public Optional < Collection < TYPE_1 > > METHOD_1 ( TYPE_2 VAR_1 ) { <END> return VAR_2 . METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( boolean VAR_1 ) { if ( this . VAR_1 != VAR_1 ) { logger . info ( STRING_1 , VAR_1 ) ; this . VAR_1 = VAR_1 ; List < TYPE_1 < TYPE_2 > > VAR_2 = new ArrayList < TYPE_1 < TYPE_2 > > ( ) ; <START> VAR_2 . add ( TYPE_1 . of ( VAR_3 , TYPE_3 . METHOD_2 ( ) ) ) ; <END> VAR_4 . METHOD_3 ( VAR_2 ) ; } } 
public void METHOD_1 ( String id ) { try { METHOD_2 ( id ) ; VAR_1 . apply ( id ) ; } catch ( Exception e ) { <START> e . VAR_2 ( ) ; <END> } VAR_3 . METHOD_3 ( ) . METHOD_4 ( id ) ; String VAR_4 = VAR_5 . apply ( id ) ; VAR_6 . apply ( VAR_4 ) ; } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 , String name ) { <START> if ( VAR_2 != null ) { <END> TYPE_2 . METHOD_2 ( VAR_2 , VAR_1 , VAR_1 . getType ( ) , name ) ; } VAR_3 . put ( new TYPE_3 ( VAR_1 , name ) , VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { String VAR_2 = context . VAR_3 ( ) . METHOD_2 ( ) ; if ( VAR_2 != null ) { <START> VAR_1 = METHOD_3 ( VAR_2 ) ; <END> } else if ( context . getId ( ) != null ) { Map < TYPE_2 , TYPE_5 . TYPE_6 > VAR_4 = VAR_5 . METHOD_4 ( context . getId ( ) ) ; VAR_1 = TYPE_4 . METHOD_5 ( VAR_4 ) ; } } return VAR_1 ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return props ; } 
<START> public synchronized void METHOD_1 ( final String VAR_1 ) { <END> VAR_2 . METHOD_1 ( VAR_1 ) ; METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_1 ) ; } 
private void METHOD_1 ( String VAR_1 , boolean VAR_2 ) { String VAR_3 = VAR_4 ; if ( VAR_2 ) { VAR_3 = VAR_5 ; } String VAR_6 = VAR_1 + VAR_7 + VAR_3 ; <START> File VAR_8 = new File ( VAR_6 ) ; <END> try { if ( ! VAR_8 . METHOD_2 ( ) ) { logger . error ( Messages . getInstance ( ) . METHOD_3 ( STRING_1 ) ) ; } } catch ( IOException e ) { logger . error ( Messages . getInstance ( ) . METHOD_3 ( STRING_1 ) ) ; } } 
public boolean METHOD_1 ( TYPE_1 node ) { if ( METHOD_2 ( node , STRING_1 , STRING_2 , STRING_3 ) ) { final TYPE_2 b = this . ctx . VAR_1 ( ) ; <START> final TYPE_3 r = this . ctx . VAR_2 ( ) ; <END> node . VAR_3 ( new TYPE_4 ( this . ctx , node ) ) ; } return VAR_4 ; } 
public boolean METHOD_1 ( TYPE_1 node ) { <START> if ( TYPE_2 . METHOD_2 ( node . VAR_1 ( ) , VAR_2 ) ) { <END> return VAR_3 ; } return VAR_4 ; } 
public void METHOD_1 ( TYPE_1 db , long VAR_1 ) { TYPE_2 VAR_2 = db . query ( STRING_1 , new String [ ] { STRING_2 } , STRING_3 , new String [ ] { Long . toString ( VAR_1 ) } , null , null , null ) ; <START> VAR_2 . close ( ) ; <END> } 
public String METHOD_1 ( ) { String VAR_1 = STRING_1 + TYPE_1 . this + TYPE_1 . VAR_3 + this ; <START> String VAR_4 = TYPE_1 . VAR_3 + STRING_1 + this ; <END> return VAR_1 + VAR_4 ; } 
public Boolean METHOD_1 ( boolean VAR_1 ) { class TYPE_1 { Boolean b ; } TYPE_1 VAR_2 = new TYPE_1 ( ) ; Boolean VAR_3 = Boolean . VAR_4 ; <START> return VAR_1 ? VAR_2 . b : VAR_3 ; <END> } 
public static boolean METHOD_1 ( TYPE_1 node , String VAR_1 , <START> String VAR_2 , String ... VAR_3 ) { <END> if ( node == null ) { return false ; } final TYPE_2 VAR_4 = node . VAR_5 ( ) ; return METHOD_1 ( VAR_4 , VAR_1 , VAR_2 , VAR_3 ) ; } 
private void METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 ) { if ( position != null && ! position . VAR_2 . equals ( VAR_1 ) ) { <START> TYPE_2 VAR_3 = new TYPE_2 ( position . offset , position . VAR_4 , VAR_1 ) ; <END> METHOD_2 ( TYPE_5 . VAR_6 , ( ) - > { this . position = VAR_3 ; this . VAR_7 = null ; } ) ; } } 
private Map < TYPE_1 , Long > METHOD_1 ( ) { <START> if ( state ( ) == TYPE_2 . VAR_2 ) { <END> return Collections . VAR_3 ( ) ; } final Map < TYPE_1 , Long > VAR_4 = new HashMap < > ( VAR_5 . METHOD_2 ( ) ) ; for ( final Map . Entry < TYPE_1 , Long > entry : VAR_6 . entrySet ( ) ) { VAR_4 . METHOD_3 ( entry . getKey ( ) , entry . getValue ( ) ) ; } return VAR_4 ; } 
private Map < TYPE_1 , Long > METHOD_1 ( final Set < TYPE_1 > VAR_1 ) { final Map < TYPE_1 , Long > VAR_2 ; try { VAR_2 = METHOD_2 ( VAR_1 , VAR_3 ) ; } catch ( final TYPE_2 e ) { <START> if ( e . VAR_4 ( ) instanceof TYPE_3 ) { <END> return Collections . VAR_5 ( ) ; } else { throw e ; } } VAR_6 = time . VAR_7 ( ) ; return VAR_2 ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_3 . class ) ; TYPE_2 . METHOD_3 ( VAR_1 . METHOD_4 ( TYPE_2 . METHOD_5 ( ) ) ) . METHOD_6 ( new RuntimeException ( ) ) ; METHOD_7 ( VAR_1 ) ; <START> METHOD_8 ( TYPE_4 . class , ( ) - > METHOD_9 ( METHOD_10 ( ) , VAR_1 , INT_1 ) ) ; <END> METHOD_11 ( VAR_1 ) ; } 
TYPE_6 ( TYPE_1 < byte [ ] , byte [ ] > VAR_2 , TYPE_2 VAR_3 , TYPE_3 id , TYPE_4 VAR_4 ) { TYPE_5 . METHOD_1 ( VAR_2 ) ; TYPE_5 . METHOD_1 ( VAR_3 ) ; TYPE_5 . METHOD_1 ( id ) ; TYPE_5 . METHOD_1 ( VAR_4 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_5 = id ; this . VAR_4 = VAR_4 ; <START> this . VAR_6 = VAR_3 . METHOD_2 ( ) ; <END> } 
<START> public TYPE_6 ( TYPE_1 < byte [ ] , byte [ ] > VAR_2 , String VAR_3 , <END> int VAR_4 , TYPE_2 VAR_5 , Object key , TYPE_2 VAR_6 , Object value , long VAR_7 , Long VAR_8 , TYPE_3 VAR_9 , TYPE_4 < TYPE_5 > VAR_10 ) { super ( VAR_3 , VAR_4 , VAR_5 , key , VAR_6 , value , VAR_7 , VAR_8 , VAR_9 , VAR_10 ) ; this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( ) { <START> TYPE_1 < ? > VAR_1 = null ; <END> while ( ( VAR_1 = VAR_2 . METHOD_2 ( ) ) != null ) { try { VAR_1 . get ( ) ; } catch ( InterruptedException | TYPE_2 e ) { log . error ( STRING_1 ) ; throw new TYPE_3 ( e ) ; } } } 
public boolean METHOD_1 ( R record ) { <START> return record . key ( ) == null ; <END> } 
public TYPE_2 ( String VAR_2 ) { <START> TYPE_1 . METHOD_1 ( VAR_2 ) ; <END> this . VAR_2 = VAR_2 ; } 
public boolean equals ( Object VAR_1 ) { if ( this == VAR_1 ) { return true ; } <START> if ( VAR_1 == null || ! ( VAR_1 instanceof TYPE_1 ) ) { <END> return false ; } final TYPE_1 that = ( TYPE_1 ) VAR_1 ; return TYPE_2 . equals ( this . VAR_2 , that . VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { <START> if ( VAR_1 == VAR_2 ) { <END> return METHOD_2 ( ) ; } this . VAR_1 = VAR_1 ; return this ; } 
public TYPE_1 METHOD_1 ( short VAR_1 ) { <START> if ( VAR_1 == VAR_2 ) { <END> return METHOD_2 ( ) ; } this . VAR_1 = VAR_1 ; return this ; } 
private void METHOD_1 ( final List < TYPE_1 < TYPE_3 . TYPE_4 , TYPE_3 . TYPE_4 > > VAR_1 ) throws Exception { METHOD_2 ( <START> ( ) - > VAR_1 . get ( VAR_1 . size ( ) - 1 ) . equals ( new TYPE_1 < > ( TYPE_4 . VAR_3 , TYPE_4 . VAR_4 ) ) , <END> VAR_5 , ( ) - > STRING_1 + VAR_1 ) ; } 
protected void METHOD_1 ( TYPE_1 context ) { String VAR_1 = config . getString ( TYPE_2 . VAR_2 ) ; <START> log . debug ( STRING_1 + VAR_1 ) ; <END> String [ ] VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 ) ; Arrays . stream ( VAR_3 ) . forEach ( TYPE_2 : : METHOD_3 ) ; TYPE_4 VAR_4 = new TYPE_4 ( TYPE_5 . class ) ; VAR_4 . METHOD_4 ( STRING_2 , VAR_1 ) ; context . VAR_5 ( VAR_4 , STRING_3 , TYPE_6 . of ( TYPE_7 . VAR_7 ) ) ; } 
public TYPE_1 ( ) { <START> this . VAR_2 = Collections . VAR_3 ( ) ; ; <END> } 
public Map < String , String > METHOD_1 ( String VAR_1 ) { TYPE_1 < Map < String , String > > VAR_2 = new TYPE_1 < > ( ) ; VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; try { <START> Map < String , String > result = VAR_2 . get ( VAR_4 , TimeUnit . VAR_5 ) ; return new HashMap < > ( result ) ; <END> } catch ( InterruptedException | TYPE_2 | TYPE_3 e ) { throw new TYPE_4 ( String . format ( STRING_1 , VAR_1 ) , e ) ; } } 
public Map < String , String > VAR_1 ( String VAR_2 ) { TYPE_2 < Map < String , String > > VAR_4 = new TYPE_2 < > ( ) ; VAR_5 . VAR_1 ( VAR_2 , VAR_4 ) ; try { <START> return new HashMap < > ( VAR_4 . get ( VAR_6 , TimeUnit . VAR_7 ) ; ) ; <END> } catch ( InterruptedException | TYPE_1 | TYPE_3 e ) { throw new TYPE_4 ( String . format ( STRING_1 , VAR_2 ) , e ) ; } } 
public void METHOD_1 ( ) { props . VAR_1 ( TYPE_5 . VAR_3 , TYPE_1 . class . getName ( ) ) ; <START> final TYPE_2 VAR_4 = TYPE_2 . METHOD_2 ( ) ; <END> try { new TYPE_3 ( new TYPE_4 ( ) . build ( ) , props , VAR_5 , time ) ; } finally { TYPE_2 . METHOD_3 ( VAR_4 ) ; } assertThat ( VAR_4 . METHOD_4 ( ) , METHOD_5 ( STRING_1 + VAR_6 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 ) ) ; } 
void METHOD_1 ( final TYPE_1 client ) { if ( VAR_1 . contains ( client ) ) { VAR_2 . remove ( client ) ; } VAR_2 . METHOD_1 ( client ) ; <START> VAR_1 . add ( client ) ; <END> } 
public void close ( ) { <START> TYPE_1 e = new TYPE_1 ( STRING_1 ) ; for ( TYPE_2 VAR_1 : VAR_2 ) { try { VAR_1 . close ( ) ; } catch ( Throwable t ) { e . VAR_3 ( t ) ; } } if ( e . VAR_4 ( ) . length > 0 ) { throw e ; } <END> } 
static void METHOD_1 ( final String message , final TYPE_1 < RuntimeException > VAR_1 ) { if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { final RuntimeException VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> final RuntimeException VAR_3 = new RuntimeException ( message , VAR_2 ) ; <END> for ( final RuntimeException e : VAR_1 ) { VAR_3 . METHOD_3 ( e ) ; } throw VAR_3 ; } } 
static TYPE_1 < RuntimeException > METHOD_1 ( final TYPE_2 ... VAR_1 ) { <START> TYPE_1 < RuntimeException > VAR_2 = null ; <END> for ( final TYPE_2 action : VAR_1 ) { try { action . run ( ) ; } catch ( final RuntimeException exception ) { if ( VAR_2 == null ) { VAR_2 = new TYPE_1 < > ( ) ; } VAR_2 . add ( exception ) ; } } return VAR_2 ; } 
public void close ( ) { VAR_1 . METHOD_1 ( ) . METHOD_2 ( ) ; try { final TYPE_1 < RuntimeException > VAR_2 = METHOD_3 ( ( ) - > cache . VAR_3 ( VAR_4 ) , ( ) - > cache . close ( VAR_4 ) , METHOD_4 ( ) : : close ) ; <START> if ( VAR_2 != null && ! VAR_2 . isEmpty ( ) ) { <END> METHOD_5 ( STRING_1 + name ( ) , VAR_2 ) ; } } finally { VAR_1 . METHOD_1 ( ) . METHOD_6 ( ) ; } } 
private boolean METHOD_1 ( ) { if ( METHOD_2 ( ) ) { final int VAR_1 = <START> METHOD_3 ( VAR_2 . values ( ) , VAR_3 , TYPE_1 : : METHOD_4 ) ; <END> return VAR_1 <= VAR_4 . VAR_5 ; } else { return false ; } } 
public TYPE_7 ( final TYPE_1 < byte [ ] , byte [ ] > VAR_2 , final TYPE_5 . TYPE_6 VAR_3 , final TYPE_3 VAR_4 ) { this . VAR_2 = TYPE_4 . METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_3 = TYPE_4 . METHOD_1 ( VAR_3 , STRING_2 ) ; <START> this . VAR_5 = VAR_3 == VAR_6 || VAR_3 == VAR_7 ; <END> log = TYPE_4 . METHOD_1 ( VAR_4 , STRING_3 ) . logger ( getClass ( ) ) ; VAR_8 = VAR_4 . METHOD_2 ( ) . trim ( ) ; } 
public void METHOD_1 ( ) { if ( state != TYPE_1 . VAR_2 ) { log . debug ( STRING_1 , VAR_3 ) ; <START> METHOD_2 ( METHOD_3 ( ) ) ; <END> } state = TYPE_1 . VAR_2 ; } 
TYPE_3 ( final String VAR_2 ) { <START> VAR_3 = VAR_2 != null ? TYPE_1 . METHOD_1 ( VAR_2 ) : null ; <END> VAR_4 = new HashSet < > ( ) ; state = new TYPE_2 ( ) ; } 
<START> private Map < String , List < TYPE_1 > > METHOD_1 ( final List < TYPE_1 > VAR_1 , <END> final List < TYPE_1 > VAR_2 ) { return METHOD_2 ( METHOD_3 ( VAR_3 , VAR_1 ) , METHOD_3 ( VAR_4 , VAR_2 ) ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 key ) { try { <START> final byte [ ] VAR_1 = METHOD_2 ( ) . get ( METHOD_3 ( key ) ) ; return new TYPE_1 < TYPE_2 > ( VAR_1 , METHOD_4 ( ( ) - > METHOD_5 ( VAR_1 ) , time , VAR_2 ) ) ; <END> } catch ( final TYPE_4 e ) { final String message = String . format ( e . getMessage ( ) , key ) ; throw new TYPE_4 ( message , e ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 . get ( VAR_2 ) ) . METHOD_3 ( VAR_3 ) ; VAR_1 . put ( METHOD_4 ( VAR_2 ) , METHOD_5 ( VAR_3 ) ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; <START> VAR_4 . put ( key , VAR_5 ) ; <END> final TYPE_1 < String > VAR_6 = VAR_4 . METHOD_8 ( key ) ; assertEquals ( VAR_6 . value , VAR_5 ) ; assertEquals ( VAR_6 . VAR_7 , VAR_3 ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> METHOD_3 ( ) ; VAR_1 . put ( key , VAR_2 ) ; final TYPE_1 < String > VAR_3 = new TYPE_1 < > ( TYPE_2 . String ( ) ) ; final byte [ ] VAR_4 = VAR_3 . METHOD_4 ( ) . METHOD_5 ( STRING_1 , VAR_2 ) ; final TYPE_3 < String > VAR_5 = TYPE_3 . METHOD_6 ( STRING_2 , INT_1 ) ; METHOD_7 ( VAR_1 . METHOD_8 ( key , VAR_5 , VAR_4 ) ) ; METHOD_9 ( VAR_6 ) ; } 
public void METHOD_1 ( ) throws IOException { METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 ) ; METHOD_4 ( <START> STRING_1 , <END> STRING_2 , STRING_3 ) ; METHOD_5 ( VAR_3 ) ; VAR_4 . METHOD_6 ( METHOD_7 ( STRING_4 ) ) ; METHOD_8 ( VAR_3 ) ; assertThat ( VAR_4 . METHOD_9 ( ) , is ( METHOD_7 ( VAR_1 ) ) ) ; } 
private static void METHOD_1 ( final TYPE_1 < byte [ ] , byte [ ] > VAR_1 ) { final Set < TYPE_2 > VAR_2 = METHOD_2 ( new TYPE_2 ( STRING_1 , 0 ) ) ; METHOD_3 ( VAR_1 . METHOD_4 ( ) ) . METHOD_5 ( VAR_2 ) ; VAR_1 . METHOD_6 ( VAR_2 ) ; <START> METHOD_7 ( ) ; <END> } 
public TYPE_3 ( String VAR_2 , boolean VAR_3 , Optional < TYPE_1 > state ) { TYPE_2 . METHOD_1 ( state ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . state = state ; <END> } 
public void METHOD_1 ( ) { switch ( state ( ) ) { case VAR_1 : case VAR_2 : <START> VAR_3 = false ; <END> VAR_4 = false ; if ( VAR_5 ) { VAR_6 . METHOD_2 ( METHOD_3 ( ) ) ; } log . info ( STRING_1 ) ; break ; default : throw new IllegalStateException ( STRING_2 + state ( ) + STRING_3 + id ) ; } } 
private static String METHOD_1 ( final TYPE_1 config ) { <START> if ( config . containsKey ( TYPE_2 . VAR_2 ) ) { return config . getProperty ( TYPE_2 . VAR_2 ) ; } return VAR_3 ; <END> } 
public void METHOD_1 ( final Collection < TYPE_1 > VAR_1 ) { log . info ( STRING_1 + STRING_2 + STRING_3 , VAR_2 . state ( ) , VAR_1 , VAR_3 . METHOD_2 ( ) , VAR_3 . METHOD_3 ( ) ) ; final long start = time . VAR_4 ( ) ; try { VAR_3 . METHOD_4 ( ) ; <START> } catch ( final Exception e ) { <END> throw new TYPE_2 ( STRING_4 , e ) ; } finally { log . info ( STRING_5 , time . VAR_4 ( ) - start ) ; } } 
public void METHOD_1 ( ) throws InterruptedException , TYPE_1 { TYPE_2 client = new TYPE_3 ( ) ; assertTrue ( client . VAR_1 ( STRING_1 ) ) ; assertTrue ( client . VAR_1 ( STRING_2 ) ) ; assertTrue ( client . VAR_1 ( STRING_3 ) ) ; METHOD_2 ( client . VAR_1 ( STRING_4 ) ) ; METHOD_2 ( client . VAR_1 ( STRING_5 ) ) ; METHOD_2 ( client . VAR_1 ( STRING_6 ) ) ; METHOD_2 ( client . VAR_1 ( STRING_7 ) ) ; <START> client . close ( ) ; <END> } 
public void METHOD_1 ( ) { <START> synchronized ( this ) { <END> log . info ( STRING_1 , this ) ; VAR_1 = true ; METHOD_2 ( ) ; } } 
private void METHOD_1 ( final Set < TYPE_1 > VAR_1 ) { final Set < TYPE_1 > VAR_2 = new HashSet < > ( VAR_3 . METHOD_2 ( ) ) ; if ( VAR_2 . METHOD_3 ( VAR_1 ) ) { throw new IllegalStateException ( STRING_1 + VAR_3 . METHOD_2 ( ) + STRING_2 + STRING_3 + VAR_1 ) ; } VAR_2 . addAll ( VAR_1 ) ; VAR_3 . METHOD_4 ( VAR_2 ) ; <START> log . debug ( STRING_4 , VAR_1 , VAR_2 ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 , Set < String > VAR_2 ) throws InterruptedException { for ( String VAR_3 : VAR_2 ) { TYPE_2 . METHOD_2 ( ( ) - > METHOD_3 ( VAR_1 , VAR_3 , VAR_4 ) , STRING_1 + VAR_3 + STRING_2 ) ; } <START> <END> } 
void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { METHOD_2 ( ) ; if ( ! VAR_2 . isEmpty ( ) ) { METHOD_3 ( ) ; } for ( TYPE_1 VAR_3 : VAR_1 ) { VAR_2 . put ( VAR_3 . METHOD_4 ( ) . name ( ) , VAR_3 ) ; <START> } <END> METHOD_5 ( ) ; } 
<START> public TYPE_3 ( Map < String , TYPE_1 < TYPE_2 > > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( ) { this . VAR_1 = VAR_2 ; if ( VAR_3 != null ) { <START> VAR_3 . METHOD_2 ( true ) ; <END> } } 
private boolean METHOD_1 ( String VAR_1 ) { <START> return VAR_1 != null && ! VAR_1 . equals ( METHOD_2 ( ) . VAR_2 ) ; <END> } 
private TYPE_1 < TYPE_3 . TYPE_4 > METHOD_1 ( String node ) { TYPE_1 < TYPE_3 . TYPE_4 > VAR_1 = VAR_2 . get ( node ) ; if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { throw new IllegalStateException ( STRING_1 + node ) ; <START> } <END> return VAR_1 ; } 
public void METHOD_1 ( ) { METHOD_2 ( true ) ; <START> String VAR_1 = null ; <END> VAR_2 . METHOD_3 ( null , VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 error ) { return error == TYPE_1 . VAR_1 || error == TYPE_1 . VAR_2 || error == TYPE_1 . VAR_3 || error == TYPE_1 . VAR_4 ; <START> } <END> 
public boolean hasNext ( ) { <START> if ( this . VAR_1 != null ) { <END> return true ; } if ( ! this . iterator . hasNext ( ) ) { this . iterator = this . VAR_2 . iterator ( ) ; } return this . iterator . hasNext ( ) ; } 
public boolean hasNext ( ) { <START> if ( this . VAR_1 ) { <END> return true ; } if ( ! this . iterator . hasNext ( ) ) { this . iterator = this . VAR_2 . iterator ( ) ; } return true ; } 
public T next ( ) { <START> final T next = this . VAR_1 ; <END> this . VAR_1 = METHOD_1 ( ) ; return next ; } 
synchronized Set < String > METHOD_1 ( ) { <START> Set < String > VAR_1 = new HashSet < > ( VAR_2 ) ; <END> VAR_1 . addAll ( VAR_3 ) ; return VAR_1 ; } 
public Iterator < TYPE_1 > iterator ( ) { <START> return ( VAR_1 == null ) ? Collections . VAR_2 ( ) : <END> VAR_1 . iterator ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { Thread VAR_1 = TYPE_1 . METHOD_2 ( VAR_2 , true ) . METHOD_3 ( VAR_3 ) ; try { Assert . assertEquals ( VAR_1 . getName ( ) , VAR_2 ) ; Assert . assertTrue ( VAR_1 . METHOD_4 ( ) ) ; } finally { try { VAR_1 . METHOD_5 ( ) ; } catch ( InterruptedException e ) { <START> e . VAR_4 ( ) ; <END> } } } 
private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final List < TYPE_4 > VAR_3 , final boolean VAR_4 ) { return new TYPE_1 ( VAR_1 , new TYPE_5 ( ) , VAR_5 , VAR_3 , metadata , VAR_6 , VAR_2 , STRING_1 + VAR_7 , time , VAR_4 , VAR_8 , <START> false , <END> null ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . clear ( ) ; <END> } 
public void METHOD_1 ( ) throws InterruptedException { try { for ( TYPE_1 VAR_1 : this . VAR_2 . METHOD_2 ( ) ) { VAR_1 . VAR_3 . METHOD_3 ( ) ; <START> METHOD_4 ( VAR_1 ) ; <END> VAR_1 . METHOD_5 ( ) ; } } finally { this . VAR_4 . METHOD_6 ( ) ; } } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { if ( VAR_2 == null ) { VAR_2 = new ArrayList < > ( ) ; } <START> VAR_2 . add ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) { final String VAR_1 = STRING_1 ; final TYPE_1 e = METHOD_2 ( TYPE_1 . class , ( ) - > TYPE_2 . METHOD_3 ( VAR_1 ) ) ; <START> assert e . getMessage ( ) . equals ( STRING_2 + VAR_1 + <END> STRING_3 + STRING_4 ) ; } 
public void close ( ) { log . debug ( STRING_1 ) ; METHOD_1 ( ) ; if ( VAR_1 ) { try { VAR_2 . close ( ) ; } catch ( final TYPE_1 e ) { throw new TYPE_2 ( STRING_2 , e ) ; } <START> VAR_2 = null ; <END> } METHOD_2 ( ) ; } 
public TYPE_1 < TYPE_2 < TYPE_3 > , TYPE_4 > METHOD_1 ( final TYPE_5 < TYPE_4 > VAR_1 , final TYPE_6 < ? super TYPE_3 , TYPE_4 > VAR_2 ) { <START> return METHOD_1 ( VAR_1 , VAR_2 , TYPE_7 . METHOD_2 ( VAR_3 , null ) ) ; <END> } 
public TYPE_4 ( String name , String value , TYPE_1 source , boolean VAR_2 , boolean VAR_3 , <START> List < TYPE_2 > VAR_4 ) { <END> TYPE_3 . METHOD_1 ( name , STRING_1 ) ; this . name = name ; this . value = value ; this . source = source ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public < TYPE_1 extends TYPE_2 > TYPE_3 < TYPE_4 , TYPE_5 > METHOD_1 ( final TYPE_6 < TYPE_1 > VAR_1 ) { TYPE_7 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> return new TYPE_8 < > ( VAR_1 , <END> builder , VAR_2 , name , VAR_3 , null , VAR_4 , VAR_5 , VAR_6 ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> if ( this . VAR_1 != null ) { <END> VAR_2 . VAR_3 . METHOD_2 ( this . VAR_1 ) ; } this . VAR_1 = VAR_1 ; VAR_2 . VAR_3 . METHOD_3 ( VAR_1 ) ; } 
private void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) ; } catch ( final TYPE_1 e ) { <START> if ( e . VAR_2 ( ) instanceof TYPE_2 ) { <END> log . warn ( STRING_1 , e ) ; throw new TYPE_3 ( this , e ) ; } } VAR_1 . METHOD_3 ( Collections . VAR_3 ( ) ) ; } 
boolean METHOD_1 ( ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> VAR_2 . clear ( ) ; VAR_3 . clear ( ) ; } return ! VAR_1 . isEmpty ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 time = new TYPE_1 ( ) ; TYPE_2 metadata = new TYPE_2 ( VAR_1 , VAR_2 , new TYPE_3 ( ) , new TYPE_4 ( ) ) ; metadata . VAR_3 ( Collections . VAR_4 ( new TYPE_5 ( STRING_1 , INT_1 ) ) ) ; <START> metadata . VAR_5 ( ) ; <END> assertEquals ( 0 , metadata . VAR_6 ( time . VAR_7 ( ) ) ) ; assertEquals ( 0 , metadata . VAR_8 ( time . VAR_7 ( ) ) ) ; } 
public void METHOD_1 ( Map < String , ? > VAR_1 ) { synchronized ( VAR_2 ) { <START> this . VAR_3 = TYPE_1 . METHOD_2 ( VAR_4 , VAR_1 ) ; <END> VAR_5 . forEach ( ( name , VAR_6 ) - > { if ( VAR_3 . METHOD_3 ( name ) ) { METHOD_4 ( VAR_6 ) ; } else { METHOD_5 ( VAR_6 ) ; } } ) ; } } 
public void METHOD_1 ( ) { final String VAR_1 = STRING_1 ; final String VAR_2 = STRING_2 ; final String VAR_3 = STRING_3 ; if ( VAR_4 == TYPE_3 . VAR_6 ) { METHOD_2 ( VAR_1 , VAR_3 , VAR_2 , TYPE_2 . VAR_8 ) ; } else { METHOD_3 ( VAR_9 . METHOD_4 ( VAR_10 , VAR_11 , VAR_12 , VAR_1 , TYPE_2 . VAR_8 <START> ) ) . METHOD_5 ( VAR_13 ) ; <END> } METHOD_6 ( ( ) - > TYPE_1 . METHOD_7 ( VAR_10 , VAR_11 , VAR_12 , VAR_9 ) ) ; } 
<START> public TYPE_1 ( List < Integer > VAR_2 ) { <END> this . VAR_2 = Collections . VAR_3 ( new ArrayList < > ( VAR_2 ) ) ; } 
public static synchronized void METHOD_1 ( String VAR_1 , String id , TYPE_1 VAR_2 ) { TYPE_2 server = TYPE_3 . METHOD_2 ( ) ; try { <START> id = id == null ? "" : id ; <END> TYPE_4 name = new TYPE_4 ( VAR_1 + STRING_1 + TYPE_5 . METHOD_3 ( id ) ) ; if ( server . VAR_3 ( name ) ) server . VAR_4 ( name ) ; METHOD_4 ( VAR_2 ) ; } catch ( TYPE_6 e ) { log . warn ( STRING_2 , e ) ; } } 
public void add ( TYPE_1 VAR_1 , TYPE_2 data ) { <START> if ( VAR_2 . containsKey ( VAR_1 ) ) { <END> VAR_3 . add ( VAR_1 ) ; } else { VAR_4 . add ( VAR_1 ) ; } next . put ( VAR_1 , data ) ; VAR_2 . put ( VAR_1 , data ) ; } 
public void remove ( TYPE_1 VAR_1 ) { VAR_2 . add ( VAR_1 ) ; <START> next . remove ( VAR_1 ) ; <END> VAR_3 . remove ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( int VAR_1 , Throwable VAR_2 ) { TYPE_2 error = TYPE_2 . METHOD_2 ( VAR_2 ) ; TYPE_3 response = new TYPE_3 ( ) . METHOD_3 ( VAR_1 ) . METHOD_4 ( error . error ( ) . METHOD_5 ( ) ) . METHOD_6 ( error . message ( ) ) <START> . METHOD_7 ( Collections . VAR_3 ( ) ) ; <END> return new TYPE_4 ( response ) ; } 
public int METHOD_1 ( ) { if ( buffer == null ) return size . position ( ) ; <START> return METHOD_2 ( ) . position ( ) + size . position ( ) ; <END> } 
<START> @Override public TYPE_1 METHOD_1 ( String VAR_1 , byte [ ] data ) { <END> if ( data != null ) throw new IllegalArgumentException ( STRING_1 ) ; return null ; } 
public void close ( ) { <START> this . VAR_1 . close ( TYPE_1 . VAR_3 ) ; <END> } 
private TYPE_1 METHOD_1 ( final TYPE_2 < String , String > VAR_1 ) { return new TYPE_1 ( ) { @Override public void METHOD_2 ( Collection < TYPE_3 > VAR_2 ) { } @Override public void METHOD_3 ( Collection < TYPE_3 > VAR_2 ) { for ( TYPE_3 VAR_3 : VAR_2 ) VAR_1 . METHOD_4 ( VAR_3 , 0 ) ; } @Override public void METHOD_5 ( Collection < TYPE_3 > VAR_2 ) { <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> } } ; } 
<START> public TYPE_1 get ( String VAR_1 ) { <END> return VAR_2 . get ( VAR_1 ) ; } 
<START> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> TYPE_3 entry = VAR_2 . get ( VAR_1 ) ; if ( entry != null && entry . VAR_3 != TYPE_4 . VAR_5 ) return TYPE_1 . of ( entry . VAR_3 ) ; else return TYPE_1 . empty ( ) ; } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { <END> if ( this . METHOD_2 ( VAR_1 ) ) { return VAR_2 == this . VAR_3 . get ( VAR_1 ) ; } return false ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> final long VAR_1 = INT_1 ; TYPE_1 VAR_2 = METHOD_2 ( ) ; METHOD_3 ( VAR_2 ) ; METHOD_4 ( VAR_1 , TYPE_2 . NONE ) ; assertTrue ( VAR_2 . METHOD_5 ( ) ) ; assertEquals ( VAR_1 , VAR_2 . METHOD_6 ( ) . VAR_1 ) ; assertEquals ( ( short ) 0 , VAR_2 . METHOD_6 ( ) . VAR_4 ) ; } 
private int METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { if ( VAR_2 > METHOD_2 ( VAR_1 ) . METHOD_3 ( VAR_3 ) ) { VAR_4 . METHOD_4 ( VAR_1 ) . VAR_5 = VAR_2 ; return VAR_2 ; } <START> return VAR_3 ; <END> } 
private int METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { if ( VAR_2 > METHOD_2 ( VAR_1 ) . METHOD_3 ( VAR_3 ) ) { VAR_4 . METHOD_4 ( VAR_1 ) . VAR_5 = VAR_2 ; return VAR_2 ; } <START> return METHOD_2 ( VAR_1 ) . METHOD_3 ( VAR_3 ) ; <END> } 
int METHOD_1 ( ) { <START> if ( ! VAR_1 ) { <END> return VAR_2 . METHOD_2 ( ) ; } return - 1 ; } 
int METHOD_1 ( ) { <START> if ( VAR_1 ) { <END> return - 1 ; } final int VAR_2 = VAR_3 . commit ( ) ; return VAR_2 + VAR_4 . commit ( ) ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( ) . build ( ) , props , VAR_2 , time ) ; try { VAR_1 . METHOD_2 ( ) ; VAR_1 . start ( ) ; } finally { VAR_1 . close ( ) ; } <START> VAR_1 . METHOD_2 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( String name ) { if ( ! TYPE_2 . METHOD_2 ( name ) ) { return null ; } TYPE_3 < TYPE_4 < ? > , TYPE_5 > VAR_1 = VAR_2 . get ( name ) ; if ( VAR_1 == null ) { return null ; } TYPE_5 VAR_3 = VAR_1 . get ( VAR_1 . METHOD_3 ( ) ) ; <START> if ( ! ( VAR_3 instanceof TYPE_1 ) ) { <END> return null ; } return ( TYPE_1 ) VAR_3 ; } 
public TYPE_1 ( ) { <START> super ( STRING_1 + <END> STRING_2 + STRING_3 ) ; } 
<START> public TYPE_4 ( TYPE_1 < Map < TYPE_2 , TYPE_3 > > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
<START> public boolean METHOD_1 ( TYPE_1 error ) { <END> return error == TYPE_1 . VAR_1 || error == TYPE_1 . VAR_2 ; } 
<START> public TYPE_1 ( long offset , long VAR_2 , Optional < Integer > VAR_3 ) { <END> this . offset = offset ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_4 , TYPE_2 > METHOD_1 ( final TYPE_3 < TYPE_4 , TYPE_1 > VAR_1 , final TYPE_5 < ? super TYPE_6 , ? super TYPE_1 , ? extends TYPE_2 > VAR_2 , final TYPE_7 VAR_3 , final TYPE_8 < TYPE_4 , TYPE_6 , TYPE_1 > VAR_4 ) { return METHOD_2 ( <START> VAR_1 , <END> VAR_2 , VAR_3 , VAR_4 , new TYPE_9 ( this , false , false ) ) ; } 
<START> public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { <END> this . VAR_2 . METHOD_2 ( ) . forEach ( VAR_1 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { TYPE_5 . TYPE_6 position = new TYPE_5 . TYPE_6 ( VAR_3 . offset , VAR_3 . VAR_4 , metadata . VAR_5 ( VAR_1 ) ) ; VAR_3 . VAR_4 . METHOD_2 ( VAR_6 - > metadata . VAR_7 ( VAR_1 , VAR_6 ) ) ; <START> VAR_8 . METHOD_3 ( VAR_1 , position , VAR_2 ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 ) { Long VAR_3 = VAR_4 . get ( VAR_1 ) ; boolean result = VAR_3 != null && VAR_3 > VAR_2 ; <START> if ( ! result ) <END> VAR_4 . remove ( VAR_1 ) ; return result ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , long VAR_2 ) { Long VAR_3 = VAR_4 . get ( VAR_1 ) ; boolean VAR_5 = VAR_3 != null && VAR_2 >= VAR_3 ; if ( VAR_5 ) VAR_4 . remove ( VAR_1 ) ; <START> return VAR_5 ; <END> } 
<START> private TYPE_1 METHOD_1 ( ) { <END> final TYPE_2 properties = new TYPE_2 ( ) ; properties . put ( TYPE_4 . VAR_2 , TYPE_3 . METHOD_2 ( ) ) ; return TYPE_1 . create ( properties ) ; } 
public TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( final TYPE_4 < TYPE_2 , TYPE_3 > VAR_1 ) { <START> TYPE_5 . METHOD_2 ( VAR_1 , STRING_1 ) ; <END> return METHOD_3 ( VAR_1 , null ) ; } 
public boolean METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) return false ; if ( VAR_2 != null && ! VAR_2 . METHOD_3 ( VAR_3 ) ) { <START> METHOD_4 ( STRING_1 ) ; <END> return true ; } if ( VAR_4 != null && ! VAR_4 . equals ( VAR_1 . METHOD_5 ( ) ) ) { METHOD_4 ( STRING_2 ) ; return true ; } return super . METHOD_1 ( ) ; } 
public void close ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_1 ( ) < 0 ) throw new IllegalArgumentException ( STRING_1 ) ; METHOD_2 ( ) ; try { if ( ! VAR_2 ) { close ( VAR_1 . METHOD_1 ( ) , false ) ; <START> VAR_2 = true ; <END> } } finally { METHOD_3 ( ) ; } } 
private TYPE_1 METHOD_1 ( final String VAR_1 ) { <START> final TYPE_2 < TYPE_3 < String , String > > VAR_2 = TYPE_4 . METHOD_2 ( TYPE_4 . METHOD_3 ( VAR_1 ) , TYPE_5 . String ( ) , TYPE_5 . String ( ) ) ; <END> return VAR_3 . METHOD_4 ( STRING_1 , VAR_4 , VAR_4 , VAR_5 ) . METHOD_5 ( STRING_2 , METHOD_6 ( new TYPE_6 ( VAR_1 ) , Collections . VAR_6 ( VAR_2 ) ) , STRING_1 ) . METHOD_7 ( STRING_3 , VAR_7 , STRING_2 ) ; } 
<START> protected TYPE_2 ( int VAR_2 , <END> byte VAR_3 , long offset , long VAR_4 , int VAR_5 , ByteBuffer key , ByteBuffer value , TYPE_1 [ ] VAR_6 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . offset = offset ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . key = key ; this . value = value ; this . VAR_6 = VAR_6 ; } 
<START> private static byte METHOD_1 ( ByteBuffer buffer , TYPE_1 input , TYPE_2 VAR_1 ) throws IOException { <END> boolean VAR_2 = false ; while ( true ) { if ( VAR_2 ) { METHOD_2 ( buffer , input , VAR_1 ) ; VAR_2 = false ; } if ( buffer . VAR_3 ( ) < 1 && VAR_1 . value > 0 ) { VAR_2 = true ; } else { return buffer . get ( ) ; } } } 
public Object METHOD_1 ( Object VAR_1 ) { Map map = METHOD_2 ( 0 ) . METHOD_1 ( VAR_1 , Map . VAR_2 ) ; String key = METHOD_2 ( 1 ) . METHOD_1 ( VAR_1 , String . VAR_2 ) ; <START> if ( map . containsKey ( key ) ) { <END> return map . get ( key ) ; } return null ; } 
public boolean METHOD_1 ( int VAR_1 ) { switch ( VAR_1 ) { case TYPE_2 . VAR_3 : return VAR_4 != null ; case TYPE_2 . VAR_5 : return VAR_6 != null && ! VAR_6 . isEmpty ( ) ; case TYPE_2 . VAR_7 : return VAR_8 != null ; case TYPE_2 . VAR_9 : <START> return TYPE_1 == null ? VAR_10 != null : ! Arrays . equals ( TYPE_1 , VAR_10 ) ; <END> case TYPE_2 . VAR_11 : return VAR_12 != null ; } return super . METHOD_1 ( VAR_1 ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 query ) throws IOException { TYPE_3 f = query . VAR_1 ( ) ; <START> if ( f != null && f . equals ( TYPE_3 . VAR_2 ) ) { <END> try { return new TYPE_1 ( TYPE_4 . METHOD_2 ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) , VAR_4 ) ) ; } catch ( TYPE_5 e ) { throw new RuntimeException ( STRING_1 , e ) ; } } else { return null ; } } 
public boolean METHOD_1 ( ) { <START> return VAR_1 != null ; <END> } 
public void METHOD_1 ( Map < Integer , String > VAR_1 ) { <START> VAR_1 . put ( 4 , STRING_1 ) ; <END> VAR_1 . put ( TYPE_1 . VAR_3 , STRING_2 ) ; VAR_1 . put ( TYPE_1 . VAR_4 , STRING_3 ) ; VAR_1 . put ( TYPE_1 . VAR_5 , STRING_4 ) ; } 
private boolean METHOD_1 ( double VAR_1 , double VAR_2 , double VAR_3 , double VAR_4 ) { final int VAR_5 = ( int ) ( VAR_2 - VAR_1 ) ; final int VAR_6 = ( int ) ( VAR_4 - VAR_3 ) ; <START> if ( METHOD_2 ( VAR_5 ) == 0 || VAR_6 == 0 ) { <END> return false ; } return true ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( VAR_2 == null ) { return VAR_1 ; } TYPE_1 result ; if ( VAR_1 == null ) { result = new TYPE_1 ( ) ; } else { result = new TYPE_1 ( VAR_1 ) ; } <START> if ( VAR_3 ) METHOD_2 ( result , VAR_2 ) ; <END> return result ; } 
<START> private Object METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> return VAR_2 . METHOD_2 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws IOException { String [ ] VAR_1 = VAR_2 . METHOD_2 ( ) ; for ( String name : VAR_1 ) { <START> System . out . println ( name ) ; <END> System . out . println ( METHOD_3 ( name ) ) ; METHOD_4 ( STRING_1 , name . startsWith ( STRING_2 ) ) ; METHOD_4 ( STRING_3 , name . VAR_3 ( STRING_4 ) ) ; METHOD_4 ( STRING_5 , name . VAR_3 ( STRING_6 ) ) ; } } 
public Map < String , String > METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = new HashMap ( ) ; <END> VAR_2 . METHOD_2 ( VAR_1 ) ; } return VAR_1 ; } 
for ( TYPE_5 factory : TYPE_1 . VAR_3 ( TYPE_5 . VAR_4 ) ) { boolean VAR_5 = factory instanceof TYPE_4 || factory instanceof TYPE_3 || factory instanceof TYPE_2 ; if ( ! VAR_5 ) <START> cache . add ( factory ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) != null ) { String VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( ! VAR_2 . equals ( STRING_1 ) ) { throw new IllegalStateException ( STRING_2 ) ; } <START> } else { <END> VAR_1 . METHOD_3 ( STRING_1 , false ) ; ; } this . VAR_1 = VAR_1 ; } 
public List < String > METHOD_1 ( ) { String [ ] VAR_1 ; <START> if ( ! ( VAR_2 . get ( STRING_1 ) instanceof TYPE_1 ) ) { <END> VAR_1 = parse . VAR_3 ( String . VAR_4 , VAR_2 , STRING_1 , new String [ ] { STRING_2 , STRING_3 } ) ; return Arrays . asList ( VAR_1 ) ; } else { return null ; } } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . create ( METHOD_2 ( ) . METHOD_3 ( ) ) ; for ( TYPE_2 VAR_2 : list ) { <START> if ( VAR_2 == null ) <END> continue ; TYPE_1 VAR_3 = TYPE_1 . METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ; if ( VAR_3 == null || VAR_3 . isEmpty ( ) || VAR_3 . METHOD_6 ( ) ) continue ; VAR_1 . METHOD_7 ( VAR_3 ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; TYPE_2 < Double > VAR_3 = TYPE_2 . create ( FLOAT_1 , FLOAT_2 ) ; TYPE_3 VAR_4 = VAR_5 . METHOD_5 ( null , VAR_1 , VAR_3 ) ; assertNotNull ( VAR_4 ) ; TYPE_4 VAR_6 = ( TYPE_4 ) VAR_4 ; assertEquals ( FLOAT_3 , VAR_6 . METHOD_6 ( ) , FLOAT_3 ) ; <START> assertEquals ( FLOAT_4 , VAR_6 . METHOD_7 ( ) , FLOAT_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 . get ( STRING_1 ) != null ) { <END> return ( TYPE_1 ) VAR_1 . get ( STRING_2 ) ; } else { return FLOAT_1 ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; TYPE_1 VAR_2 = ( TYPE_1 ) VAR_3 . METHOD_2 ( ) ; TYPE_2 < TYPE_3 > VAR_4 = VAR_2 . METHOD_3 ( ) ; METHOD_4 ( VAR_2 . METHOD_5 ( ) , VAR_4 ) ; METHOD_6 ( VAR_2 . METHOD_7 ( ) , VAR_4 ) ; <START> METHOD_8 ( VAR_2 . METHOD_9 ( ) , TYPE_4 . VAR_6 , VAR_4 ) ; <END> VAR_2 . METHOD_10 ( TYPE_5 . VAR_8 ) ; } 
private TYPE_1 METHOD_1 ( final String VAR_1 ) throws IOException { METHOD_2 ( VAR_1 ) ; synchronized ( VAR_2 ) { if ( VAR_2 . containsKey ( VAR_1 ) ) { return VAR_2 . get ( VAR_1 ) ; } TYPE_1 source = VAR_3 . METHOD_3 ( new TYPE_2 ( VAR_1 ) , null , TYPE_4 . VAR_5 , null , null ) ; if ( source instanceof TYPE_3 ) { } <START> <END> VAR_2 . put ( VAR_1 , source ) ; return source ; } } 
private TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String [ ] VAR_3 ) { TYPE_2 VAR_4 = new TYPE_2 ( ) . METHOD_2 ( VAR_1 , VAR_5 ) . METHOD_3 ( VAR_2 ) ; for ( String VAR_6 : VAR_3 ) { VAR_4 . METHOD_4 ( VAR_6 , VAR_5 ) ; } TYPE_1 VAR_7 = VAR_4 . build ( ) ; <START> return VAR_7 ; <END> } 
public TYPE_1 next ( ) throws TYPE_2 { if ( next == null && this . hasNext ( ) == false ) { <START> throw new TYPE_2 ( ) ; <END> } TYPE_1 f = next ; next = null ; return f ; } 
<START> public static String METHOD_1 ( String path , boolean VAR_1 ) { <END> return VAR_2 != null ? METHOD_2 ( path , VAR_1 ) . METHOD_3 ( ) : null ; } 
<START> private static void METHOD_1 ( int [ ] VAR_1 , int size ) throws IOException { <END> int VAR_2 = 0 ; for ( int VAR_3 : VAR_1 ) { if ( VAR_3 == TYPE_1 . VAR_5 ) { return ; } else if ( VAR_3 == TYPE_1 . VAR_6 ) { throw new IOException ( STRING_1 ) ; } VAR_2 += VAR_3 ; } if ( VAR_2 != size ) { throw new IOException ( STRING_1 ) ; } } 
public TYPE_2 ( TYPE_1 VAR_2 ) { <START> METHOD_1 ( VAR_2 ) ; <END> } 
public boolean hasNext ( ) throws IOException { if ( VAR_1 == null ) { <START> throw new IOException ( STRING_1 ) ; <END> } if ( this . VAR_2 ) { return false ; } return iterator . hasNext ( ) ; } 
public StringBuilder METHOD_1 ( Date VAR_1 , StringBuilder output ) { <START> TYPE_1 VAR_2 ; <END> if ( VAR_1 . METHOD_2 ( ) % INT_1 == 0 ) { VAR_2 = new TYPE_2 ( STRING_1 ) ; } else { VAR_2 = new TYPE_2 ( STRING_2 ) ; } VAR_2 . METHOD_3 ( TYPE_3 . METHOD_4 ( STRING_3 ) ) ; String text = VAR_2 . format ( VAR_1 ) ; text = text . VAR_3 ( STRING_4 , "" ) ; output . append ( text ) ; return output ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 < ? , ? > job ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; for ( TYPE_3 VAR_2 : TYPE_3 . METHOD_2 ( ) ) { try { VAR_2 . METHOD_3 ( job , VAR_1 , TYPE_4 . VAR_4 ) ; <START> } catch ( Throwable t ) { <END> LOGGER . debug ( STRING_1 , VAR_2 . getClass ( ) , t . getMessage ( ) , t ) ; } } return VAR_1 ; } 
public static TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 < ? , ? > project ) { return new TYPE_1 < TYPE_2 > ( ) { @Override public boolean apply ( TYPE_2 VAR_1 ) { TYPE_4 . METHOD_2 ( VAR_1 ) ; <START> return VAR_1 . METHOD_3 ( project ) ; <END> } } ; } 
public void METHOD_1 ( TYPE_1 < ? , ? > job , Collection < TYPE_2 > result ) { <START> TYPE_6 . TYPE_7 p = ( TYPE_6 . TYPE_7 ) job ; <END> for ( TYPE_4 VAR_1 : TYPE_5 . filter ( p . VAR_2 ( ) . values ( ) , TYPE_4 . class ) ) { result . addAll ( VAR_1 . METHOD_2 ( ) ) ; } } 
public void METHOD_1 ( int line , TYPE_1 start ) { <START> VAR_1 = line ; <END> } 
public void METHOD_1 ( int VAR_1 , String VAR_2 , String name , String VAR_3 , boolean VAR_4 ) { switch ( VAR_1 ) { case TYPE_1 . VAR_6 : case TYPE_1 . VAR_7 : case TYPE_1 . VAR_8 : VAR_9 = name ; VAR_10 = VAR_2 ; VAR_11 = VAR_3 ; VAR_12 = VAR_1 ; break ; default : <START> LOGGER . debug ( STRING_1 ) ; <END> break ; } super . METHOD_1 ( VAR_1 , VAR_2 , name , VAR_3 , VAR_4 ) ; } 
protected TYPE_1 < ? extends T > run ( Context context ) { VAR_1 = System . currentTimeMillis ( ) ; <START> TYPE_2 < T > task = METHOD_1 ( 0 ) ; <END> context . run ( task ) ; return task ; } 
<START> public void METHOD_1 ( ) throws InterruptedException { <END> if ( VAR_1 != null ) { VAR_1 . close ( ) ; VAR_2 . METHOD_1 ( ) ; } } 
public void start ( ) { if ( VAR_1 != null ) { VAR_2 = new TYPE_1 ( VAR_1 ) ; } else { if ( VAR_3 == null ) { VAR_3 = METHOD_1 ( ) ; } } METHOD_2 ( ) ; if ( VAR_3 == null || METHOD_3 ( ) ) { VAR_3 = VAR_2 . METHOD_4 ( ) ; <START> synchronized ( VAR_3 ) { <END> for ( Class < ? > VAR_4 : VAR_5 ) { METHOD_5 ( VAR_3 , VAR_4 ) ; } } } TYPE_2 . getInstance ( ) . start ( ) ; } 
private void METHOD_1 ( TYPE_1 event ) { out . println ( ) ; try ( TYPE_2 VAR_1 = new TYPE_2 ( new TYPE_3 ( event . text ) ) ) { String line = VAR_1 . METHOD_2 ( ) ; while ( line != null ) { out . println ( VAR_2 + line ) ; line = VAR_1 . METHOD_2 ( ) ; } <START> } catch ( IOException e ) { <END> throw new TYPE_4 ( e ) ; } out . println ( ) ; } 
private String METHOD_1 ( ) { <START> return String . VAR_1 ( STRING_1 , this . VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; TYPE_2 VAR_2 = new TYPE_2 ( METHOD_2 ( ) , VAR_3 , VAR_1 ) ; TYPE_3 VAR_4 = TYPE_4 . METHOD_3 ( TYPE_3 . class ) ; VAR_2 . METHOD_4 ( VAR_4 ) ; <START> VAR_2 . METHOD_5 ( VAR_5 ) ; <END> METHOD_6 ( VAR_4 ) . METHOD_7 ( true ) ; } 
public byte METHOD_1 ( boolean VAR_1 ) { byte result = INT_1 ; <START> if ( ! VAR_2 . isEmpty ( ) || ( VAR_1 && ( ! VAR_3 . isEmpty ( ) || ! VAR_4 . isEmpty ( ) || ! VAR_5 . isEmpty ( ) ) ) ) { <END> result |= VAR_6 ; } return result ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 . METHOD_2 ( ) ) ; <START> if ( VAR_2 == null || METHOD_3 ( VAR_2 , VAR_1 ) ) { <END> VAR_3 . put ( VAR_1 . METHOD_2 ( ) , VAR_1 ) ; } else { throw new TYPE_2 ( VAR_2 , VAR_1 ) ; } } 
private void METHOD_1 ( TYPE_2 . TYPE_3 . TYPE_4 VAR_2 ) { <START> VAR_2 . METHOD_2 ( ) . METHOD_1 ( out ) ; <END> } 
public void VAR_1 ( ) { TYPE_4 VAR_3 = new TYPE_4 ( TYPE_3 < TYPE_1 > VAR_6 ( ) , STRING_1 , STRING_2 , 0 , null , null ) ; String VAR_7 = new TYPE_2 ( new TYPE_5 ( ) ) . VAR_10 ( VAR_3 ) ; String VAR_11 = "" + STRING_3 + <START> < < < < < < < VAR_12 <END> STRING_4 ; assertEquals ( VAR_11 , VAR_7 ) ; } 
private final boolean METHOD_1 ( TYPE_1 VAR_1 ) { boolean result = false ; <START> if ( ! VAR_1 . isEmpty ( ) ) { <END> TYPE_2 VAR_2 = VAR_1 . get ( 0 ) ; try { new TYPE_3 ( TYPE_5 . VAR_4 ) . parse ( VAR_2 . METHOD_2 ( STRING_1 ) ) ; } catch ( TYPE_4 ex ) { result = true ; } } return result ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 request = new TYPE_1 ( ) ; request . VAR_1 ( TYPE_6 . VAR_3 , VAR_4 ) ; TYPE_2 VAR_5 = new TYPE_2 ( ) ; <START> VAR_5 . METHOD_2 ( request ) ; <END> when ( VAR_6 . METHOD_3 ( METHOD_4 ( TYPE_3 . class ) ) ) . METHOD_5 ( VAR_7 ) ; TYPE_4 VAR_8 = VAR_9 . METHOD_6 ( VAR_5 ) ; assertThat ( VAR_8 , is ( METHOD_7 ( TYPE_5 . class ) ) ) ; } 
public void METHOD_1 ( ) throws Exception { request . VAR_1 ( TYPE_3 . VAR_3 , VAR_4 ) ; <START> VAR_5 . METHOD_2 ( request ) ; <END> TYPE_1 VAR_6 = VAR_7 . METHOD_3 ( VAR_5 ) ; assertThat ( VAR_6 , is ( METHOD_4 ( TYPE_2 . class ) ) ) ; } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = STRING_1 ; VAR_2 = new TYPE_1 . Builder ( ) . METHOD_2 ( VAR_1 ) . build ( ) ; <START> assertTrue ( VAR_2 . METHOD_3 ( ) <END> . equals ( VAR_1 ) ) ; METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ; METHOD_6 ( VAR_2 . METHOD_7 ( ) ) ; METHOD_4 ( VAR_2 . METHOD_8 ( ) ) ; METHOD_4 ( VAR_2 . METHOD_9 ( ) ) ; METHOD_4 ( VAR_2 . METHOD_10 ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 . Builder ( ) . METHOD_2 ( VAR_2 ) . build ( ) ; List < TYPE_2 > VAR_3 = VAR_4 . METHOD_3 ( VAR_1 ) ; assertThat ( VAR_3 . size ( ) , is ( 1 ) ) ; <START> for ( TYPE_2 VAR_5 : VAR_3 ) { <END> assertThat ( VAR_5 . METHOD_4 ( ) , is ( VAR_2 ) ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 format = new TYPE_2 ( STRING_1 ) ; Date VAR_1 = format . parse ( STRING_2 ) ; VAR_2 = new TYPE_3 . Builder ( ) . METHOD_2 ( VAR_1 ) . build ( ) ; <START> assertTrue ( VAR_2 . METHOD_3 ( ) <END> . equals ( VAR_1 ) ) ; METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ; METHOD_6 ( VAR_2 . METHOD_7 ( ) ) ; METHOD_4 ( VAR_2 . METHOD_8 ( ) ) ; METHOD_4 ( VAR_2 . METHOD_9 ( ) ) ; } 
private void METHOD_1 ( TYPE_1 description ) { description . VAR_1 ( STRING_1 ) ; description . VAR_1 ( STRING_2 , TYPE_2 . VAR_3 ) ; description . VAR_1 ( STRING_3 ) ; description . VAR_1 ( STRING_4 ) ; description . VAR_1 ( STRING_5 ) ; <START> description . VAR_1 ( STRING_6 , TYPE_2 . VAR_3 ) ; <END> description . VAR_1 ( STRING_7 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; assertNotNull ( VAR_1 ) ; assertThat ( VAR_1 . METHOD_3 ( ) , is ( STRING_1 ) ) ; <START> assertThat ( VAR_1 . METHOD_4 ( ) , is ( STRING_2 ) ) ; <END> } 
<START> public String METHOD_1 ( ) { <END> Path VAR_1 = TYPE_1 . get ( METHOD_2 ( TYPE_3 . VAR_3 , true ) ) ; if ( ! VAR_1 . METHOD_3 ( ) ) { VAR_1 = TYPE_1 . get ( TYPE_2 . METHOD_4 ( ) , VAR_1 . toString ( ) ) ; } if ( ! VAR_1 . METHOD_5 ( ) . exists ( ) ) { VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) ; } return VAR_1 . toString ( ) ; } 
public List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) { final TYPE_3 VAR_2 = METHOD_2 ( ) ; METHOD_3 ( VAR_2 , VAR_1 ) ; <START> List < TYPE_1 > result = ( List < TYPE_1 > ) VAR_2 . list ( ) ; <END> return result == null ? new ArrayList < TYPE_1 > ( ) : result ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_1 . instance ( ) . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) . METHOD_4 ( VAR_3 ) ; <START> TYPE_2 VAR_4 = null ; <END> VAR_5 . METHOD_5 ( IllegalArgumentException . VAR_6 ) ; VAR_5 . METHOD_6 ( STRING_1 ) ; VAR_7 . METHOD_7 ( VAR_4 , VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = null ; TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_4 ) ; VAR_5 . METHOD_3 ( IllegalArgumentException . VAR_6 ) ; VAR_5 . METHOD_4 ( STRING_1 ) ; <START> VAR_7 . METHOD_5 ( VAR_2 , VAR_1 ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) throw new IllegalArgumentException ( STRING_1 ) ; else if ( VAR_1 . METHOD_2 ( ) == null ) throw new IllegalArgumentException ( STRING_2 ) ; else { if ( this . VAR_2 == null ) <START> return STRING_3 + STRING_4 + VAR_1 . METHOD_2 ( ) ; <END> else return this . VAR_2 . METHOD_1 ( ) + STRING_4 + VAR_1 . METHOD_2 ( ) ; } } 
<START> TYPE_1 METHOD_1 ( ) throws Exception { <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( 1 ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { <START> try { <END> METHOD_2 ( ) ; } catch ( Exception e ) { } METHOD_3 ( ) ; } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> VAR_2 = VAR_1 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> Boolean VAR_2 = TYPE_2 . getInstance ( ) . METHOD_2 ( METHOD_3 ( ) ) ; <END> METHOD_4 ( true ) ; METHOD_5 ( TYPE_5 . VAR_4 , ( VAR_2 ? R . VAR_5 . TYPE_4 : R . VAR_5 . TYPE_3 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 , int VAR_3 ) { if ( VAR_1 == null ) { return ; } final Context context = TYPE_2 . getInstance ( ) . METHOD_2 ( ) ; final TYPE_3 VAR_4 = context . VAR_5 ( VAR_6 + VAR_1 . METHOD_3 ( ) , Context . VAR_7 ) ; final TYPE_4 e = VAR_4 . METHOD_4 ( ) ; e . VAR_8 ( VAR_9 , VAR_2 ) ; e . VAR_8 ( VAR_10 , VAR_3 ) ; <START> e . commit ( ) ; <END> } 
<START> public static synchronized String METHOD_1 ( String name ) { <END> return METHOD_1 ( name , INT_1 ) ; } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 = null ; <END> } 
private void METHOD_1 ( boolean VAR_1 ) { assert ! VAR_2 . METHOD_2 ( ) ; String VAR_3 = VAR_2 . METHOD_3 ( ) ; String url = VAR_3 ; if ( VAR_1 ) { url = METHOD_4 ( url , false ) ; } <START> TYPE_1 . i ( TAG , STRING_1 + VAR_3 ) ; <END> METHOD_5 ( url ) ; VAR_4 = true ; } 
<START> public static TYPE_1 getInstance ( ) { <END> if ( VAR_1 != null ) { TYPE_2 . getInstance ( ) . METHOD_1 ( VAR_2 ) ; return ( TYPE_1 ) VAR_1 ; } else { throw new RuntimeException ( STRING_1 ) ; } } 
private void METHOD_1 ( TYPE_1 args , TYPE_2 VAR_1 ) throws TYPE_3 { <START> List < String > VAR_2 = TYPE_4 . getInstance ( ) . METHOD_2 ( ) ; <END> for ( String VAR_3 : VAR_2 ) { TYPE_4 . getInstance ( ) . METHOD_3 ( VAR_3 ) ; } TYPE_5 VAR_4 = new TYPE_5 ( TYPE_5 . Status . VAR_5 , true ) ; VAR_1 . METHOD_4 ( VAR_4 ) ; } 
<START> public List < String > METHOD_1 ( ) throws TYPE_1 { <END> TYPE_2 VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; String VAR_2 = VAR_1 != null ? VAR_1 . METHOD_4 ( ) : null ; List < String > VAR_3 = TYPE_3 . METHOD_5 ( context , METHOD_2 ( ) . METHOD_3 ( ) , VAR_2 ) ; return VAR_3 ; } 
<START> public boolean METHOD_1 ( Context context ) { <END> try { METHOD_2 ( context ) ; } catch ( TYPE_1 VAR_1 ) { return METHOD_3 ( context , VAR_2 , METHOD_4 ( ) ) ; } catch ( Exception ex ) { Log . e ( TAG , STRING_1 , ex ) ; return false ; } return true ; } 
<START> public void METHOD_1 ( Context context ) throws TYPE_1 { <END> TYPE_2 . METHOD_1 ( context ) ; } 
<START> public boolean METHOD_1 ( File file ) { <END> return file . VAR_1 ( ) ; } 
<START> public String [ ] METHOD_1 ( ) { <END> if ( TYPE_1 . VAR_2 . VAR_3 >= TYPE_1 . VAR_4 . VAR_5 && TYPE_1 . VAR_6 . length > 0 ) { return TYPE_1 . VAR_6 ; } else { return new String [ ] { TYPE_1 . VAR_7 , TYPE_1 . VAR_8 } ; } } 
protected void METHOD_1 ( Context context ) { <START> new TYPE_1 ( ) . METHOD_2 ( context ) ; <END> } 
<START> protected TYPE_1 METHOD_1 ( TYPE_2 options ) throws Exception { <END> try { return TYPE_3 . METHOD_2 ( TYPE_5 . VAR_2 , new TYPE_4 ( options . VAR_3 ) , options . VAR_4 ) ; } catch ( Exception e ) { METHOD_3 ( STRING_1 , e . VAR_5 ( ) ) ; VAR_6 . METHOD_4 ( ) ; } return null ; } 
public TYPE_1 METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 , VAR_3 ) ; <END> return VAR_1 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , String VAR_3 ) throws IOException , TYPE_4 , TYPE_5 { TYPE_6 . Builder VAR_4 = new TYPE_6 . Builder ( ) . add ( VAR_5 , VAR_6 ) . add ( VAR_7 , VAR_3 ) ; TYPE_1 VAR_8 = METHOD_2 ( VAR_1 , VAR_2 , VAR_4 ) ; <START> return VAR_8 ; <END> } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 response = METHOD_2 ( ) ; <START> try ( TYPE_2 in = response . VAR_1 ( ) ) { <END> METHOD_3 ( in ) ; } catch ( IOException e ) { METHOD_4 ( STRING_1 ) ; } catch ( TYPE_3 e ) { METHOD_4 ( STRING_2 ) ; } finally { response . VAR_2 ( ) ; } } 
public void VAR_1 ( ) throws Exception { final TYPE_1 response = VAR_3 ( ) ; try { <START> TYPE_2 in = response . VAR_5 ( ) <END> VAR_6 ( in ) ; } catch ( IOException e ) { VAR_7 ( STRING_1 ) ; } final TYPE_1 VAR_8 = VAR_3 ( ) ; assertNotNull ( VAR_8 ) ; } 
public TYPE_1 METHOD_1 ( ) { final TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> return VAR_1 == null ? null : METHOD_3 ( VAR_1 ) ; <END> } 
public String toString ( ) { try { return METHOD_1 ( ) ; } catch ( Exception e ) { <START> Log . e ( STRING_1 , STRING_2 ) ; <END> return ( ( response == null ) ? "" : response . toString ( ) ) ; } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; METHOD_2 ( R . VAR_2 . VAR_3 ) ; <START> VAR_4 = TYPE_2 . getInstance ( ) <END> . METHOD_3 ( ) ; VAR_5 = ( TYPE_3 ) METHOD_4 ( R . id . VAR_6 ) ; VAR_7 = ( TYPE_4 ) METHOD_4 ( R . id . VAR_8 ) ; VAR_9 = ( TYPE_4 ) METHOD_4 ( R . id . VAR_10 ) ; VAR_11 = ( TYPE_5 ) METHOD_4 ( R . id . VAR_12 ) ; METHOD_5 ( VAR_5 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <START> return new TYPE_2 ( this . val - ( ( TYPE_2 ) VAR_1 ) . val ) ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) - 1 ) ; return METHOD_4 ( VAR_1 ) . METHOD_5 ( VAR_2 . METHOD_6 ( ) ) . METHOD_7 ( VAR_2 . METHOD_8 ( ) ) <START> . METHOD_9 ( VAR_2 . METHOD_10 ( ) ) ; <END> } 
public static void METHOD_1 ( Context ctx , TYPE_1 request ) { TYPE_2 i = TYPE_3 . METHOD_2 ( ctx , TYPE_4 . class ) ; i . VAR_1 ( TYPE_4 . VAR_2 , request . VAR_3 ( ) ) ; <START> i . VAR_1 ( TYPE_4 . VAR_4 , request . VAR_5 ( ) . toString ( ) ) ; <END> ctx . VAR_6 ( i ) ; TYPE_3 . METHOD_3 ( ( TYPE_5 ) ctx ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return ( TYPE_1 ) METHOD_2 ( ) . get ( STRING_1 ) ; <END> } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 f = new TYPE_1 ( ) ; TYPE_2 args = new TYPE_2 ( ) ; <START> args . VAR_2 ( Constants . VAR_3 , VAR_1 ) ; <END> f . VAR_4 ( args ) ; return f ; } 
<START> public void METHOD_1 ( boolean VAR_1 ) { <END> TYPE_1 VAR_2 = VAR_3 - > { VAR_4 = ( TYPE_2 ) VAR_3 ; METHOD_2 ( ) ; METHOD_3 ( ) ; if ( VAR_5 >= VAR_6 && VAR_5 <= VAR_7 ) { METHOD_4 ( ) . METHOD_5 ( VAR_5 ) ; VAR_5 = - 1 ; } METHOD_6 ( true ) ; METHOD_7 ( ) ; } ; TYPE_3 . METHOD_1 ( this , VAR_8 , VAR_9 , VAR_1 ) . METHOD_8 ( VAR_2 , e - > { } ) ; } 
<START> public void METHOD_1 ( ) { <END> METHOD_2 ( false ) ; Log . d ( STRING_1 , STRING_2 ) ; METHOD_3 ( true ) ; METHOD_4 ( true ) ; } 
public static TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 args = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( args ) ; <START> return VAR_1 ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; VAR_2 = VAR_1 . getString ( STRING_1 ) ; VAR_3 = VAR_1 . getString ( STRING_2 ) ; VAR_4 = VAR_1 . getInt ( STRING_3 ) ; VAR_5 = VAR_1 . METHOD_2 ( STRING_4 , - 1 ) ; VAR_6 = VAR_1 . getInt ( STRING_5 , - 1 ) ; VAR_1 . remove ( STRING_4 ) ; <START> VAR_1 . remove ( STRING_6 ) ; <END> } 
protected TYPE_1 METHOD_1 ( int position ) { final TYPE_2 f = TYPE_2 . METHOD_2 ( VAR_1 , VAR_2 , position == 1 ) ; <START> if ( position != 1 ) { <END> VAR_3 = f ; } return f ; } 
int read ( ) { <START> if ( this . hasNext ( ) == false ) { <END> throw new IllegalStateException ( STRING_1 ) ; } int value = this . VAR_1 [ VAR_2 ] ; this . VAR_2 ++ ; return value ; } 
<START> public void METHOD_1 ( ) { <END> TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 ) ; assertTrue ( VAR_1 . METHOD_3 ( TYPE_1 . METHOD_2 ( STRING_2 ) ) ) ; } 
public TYPE_2 ( String VAR_2 , boolean VAR_3 ) { <START> this ( VAR_2 , 1 , VAR_3 , TYPE_1 . getInstance ( ) . METHOD_1 ( VAR_2 ) ) ; <END> } 

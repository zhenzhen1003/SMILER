String isEmpty ( ) avaible JDK 1 6 please useif ( VAR_1 = = null || VAR_1 length ( ) = = 0 ) return ; compilable JDK 1 5
\s include zero - width - joiner stuff ? languages fun : D
log - throw other surprise exceptions
collapse new constructor function ( VAR_2 text null VAR_3 ) ;
need a toast bookmarking page ? s expensive operation especially
enclose ( other conditional ) bodies curly braces
read ? saving
I drop calculation Math VAR_4 ( ) call
block line 187 191 simplified toreturn VAR_4 ! = null && VAR_4 && cache VAR_3 ;
A defensive copy list safer IMO
instead VAR_2 output data ll parameters event line nicely formatted
log rethrow exception correct
s exceptions bubble a nice stack trace aids debugging
s exceptions bubble a stack trace aids debugging
works I m difference doc imply return true : returns true search launched false activity respond ( )
check size ( ) > 0 crashes results press keyboard
String instead TYPE_1 ? hive magic method simpler
done
done
yeah meh removing close ( )
page METHOD_4 ( )
private
METHOD_3 ( ) doesn t need done s done automatically TYPE_1 _CODE_ ( ) instead modify _CODE_ : 132 _CODE_ instead _CODE_
generally agree + good find method return false handled ( android view TYPE_1 )
simply return VAR_3 else case worry contents info ? prevent more crashes
I prefer move catch block METHOD_1 implementation called another place
inline VAR_1
inline variable VAR_5
_CODE_ networking _CODE_ instead
TYPE_6 ? VAR_2 length ( )
I don t short names aren t necessary full titles ? I m a need capitalizing unknown internal external fine ja ? s talk return a string _CODE_ enum declare some constants TYPE_3 eh
reverse order equals ( )
super minor conditional needed properties null - null
I m a TYPE_1 expert I want write unconditionally don t I constructor byte offsets wrong other values
add properties
I unsurprising behavior client returning false / null
minor : elses unnecessary
I don t * methods return null field isn t present ll throw exception s implementation VAR_3 ( ) ( reported android studio ) : public _CODE_ VAR_3 ( String ) throws TYPE_4 { Object object = ( ) ; ( object instanceof _CODE_ ) { return ( _CODE_ ) object ; } else { throw JSON _CODE_ ( object _CODE_ ) ; } }
IMHO : s need send exception I return false previous patch caller aware contract : a _CODE_ returns _CODE_ = = true stop
pass info message param super need a copy subclass
minor : introducing a method exit point extra line I recommend inverting logic moving VAR_3 invocation
I spotted earlier conditionals collapse : TYPE_2 VAR_3 = TYPE_3 METHOD_3 ( METHOD_4 ( ) VAR_1 ? R VAR_3 VAR_4 : R VAR_3 fade_out_to ) ; VAR_5 METHOD_5 ( VAR_3 ) ; VAR_2 = VAR_1 ;
( ! TYPE_1 METHOD_2 || VAR_1 = = _CODE_ )
s advantage adding _CODE_ instance variable
I write - args super constructors implied I figure read obvious php developers else
I want logical double ampersands ! VAR_1 isEmpty && ! VAR_2 isEmpty && ! VAR_3 isEmpty ( ) instead
remove callbacks case prevent accidental double posting
nice corner case handling block review : VAR_3 add ( Math min ( 0 VAR_3 size ( ) - 1 ) VAR_2 ) instead a conditional
calling _CODE_ ( ) instead ? remove cast VAR_6 division
call super
want add a null check METHOD_3 ( ) clients _CODE_ idea fragment lifecycles
safer pass application context constructor I m guaranteed fragment added callback
isn t content provider s responsibility call methods a reference database ? I m vague area codebase I want avoid unnecessary dependencies TYPE_2
call function instead
feedback function leverage METHOD_1 ( TYPE_1 int int ) instead repeating METHOD_2 ( ) getString ( )
more state = > more branches = > more bugs a strong reason default lazy initialization ? a stateless final nonnull initialize declaration want skip member variable altogether [ 0 ] switch joda time [ 1 ] [ 0 ]
need _CODE_ _CODE_ enough
remove version variable s equal constant
shouldn t return true ? I thought force meant unconditionally _CODE_
move METHOD_5 ( ) check top function ? I recall prevent a crash ( reproduced ) I d err side caution
intentional
! result isEmpty ( ) instead
call super _CODE_ ( ) call ( )
I don t needed method checks return VAR_1 METHOD_1 ( ) throws failure client doesn t need assert returning method success
need a rebase patch removing a / b test ( vice versa )
arguments length checked I need
code suspect accessing methods main thread ? tolerable omit synchronization initialize app _CODE_ ( )
line combined previous line
line combined previous line
s reasoning ? highlight tooltip shown time ( 1 - minute intervals )
hang patch curiosity lazy init _CODE_ ? operation expected slow
consider reverting s longer a WIP patch
I parameter meant flags passed VAR_1 METHOD_2 calls
TYPE_2 e ( VAR_1 )
great ! worth a TYPE_1 METHOD_3 ( ) variable arity overload
I unconditionally set VAR_1 ( conditionals hazardous ) note : information preserved database lost app restart
isEmpty ( )
VAR_2 derived page title considered calling new constructor ( row _CODE_ ( row title )
I wrote wrong earlier I want iterator remove ( ) avoid a _CODE_
a nice test ! s safe clients cache return results immediately
replacements unconditionally ? I m worried pages cached service other enabled
wouldn t calling base method _CODE_ setText ( ) bypassing overridden method _CODE_ ? ( appears testing )
good check METHOD_8 ( ) doesn t return null method appears complete asynchronously
METHOD_9 ( ) ! = null
code method misleading s implies
missed earlier call super _CODE_
fragment shouldn t force host internals changing dependency a toolbar clear VAR_1 pattern exposing toolbar allows fragment change s defer consider pushing METHOD_1 ( ) host allow hide / show toolbar
clear previously set listeners
throw new IOException ( e )
throw new IOException ( e )
reason package protected ? protected means subclasses override method doesn t supported class
feel free ignore : I handle null case feels special nonempty case generic : ( VAR_4 isEmpty ( ) ) { return null } METHOD_3 ( VAR_4 true ) ; return new TYPE_5 < > ( VAR_1 METHOD_4 ( TYPE_6 class ) VAR_1 METHOD_5 ( VAR_2 ) VAR_4 ) ;
VAR_4 read ( ) ? I m means VAR_2 TYPE_2 class current implementation write need updated VAR_2 write
set a reference copy null
type adapter needs support write
typing permissive I supposed a location provider GPS network
METHOD_7 ( ) METHOD_5 want invoked METHOD_7 argument
I return else case METHOD_3
s a billion TYPE_3 methods I TYPE_3 ( context ) circumstance
fragment obtain host calling _CODE_ _CODE_ ( ) I activity ratained a fragment instance ll a memory leak
calling METHOD_3 I forgot add screenshots patch
I guess consistent codebase method annotations line method signature line ( s ) s pick other stick a - class basis
context
unnecessary else : ]
i ? 0 previously s existing bug set purpose
doesn t ANNOTATION_1 _CODE_ requires method public _CODE_ requires package privacy
flip conditional = = instead negated logic
return a Map instead a HashMap implementation
I m I missed earlier null check VAR_2 int overload method suggests a similar null check necessary consider checking return METHOD_2 ( ) case s present adapter
I flagged a potential NPE android studio sense happen I recommend adding a VAR_3 ! = null conditional suppressing warning throwing IllegalStateException null show author considering case true warnings flagged android studio
needless else : ]
dates - move immutable
FWIW I observe ( notified respond ) changes airplane mode connectivity state ( basically system status bar connectivity icon ) track network successes failures existing interceptor _CODE_ switching rebroadcast OFFLINE / ONLINE events event bus global network health want avoid mingling responsibilities intercepting requests
good cover usage feed
client a single VAR_2 shared image s skip converting a List pass TYPE_5 straight call METHOD_1 request ( VAR_2 toString ( ) ) _CODE_ join ( TYPE_5 class overrides toString ( ) return namespace - prefixed VAR_2 string )
return null VAR_5 : )
I a bit cleaner calling super METHOD_1 ( ) exposing METHOD_3 ( ) proceed METHOD_5 VAR_2 ( remove default inflating VAR_2 super ( ) ) create abstract method asks resource - id VAR_2 METHOD_5
close ( ) a finally block - - resource
needs a line break consistency
call super ( ) implicit required
nitpick : I d throw IllegalArgumentException note _CODE_ catched toplevel parse function ( _CODE_ ) token location added
VAR_2 histogram isn t threadsafe synchronization needed
assert size > 0 rotate fail size 0
a big fan VAR_2 property VAR_3 similar weird technical differs
static import
A couple notes : - METHOD_3 ( ) returns actual getInstance ( ) call - METHOD_1 ( ) counter - intuitive s realm possibility a user press button leave app ( e g pressing home button ) _CODE_ ( )
bus events need anymore ? ( idea send events individual cards avoid rebuild view hierarchy _CODE_ )
METHOD_1 ( ) return type TYPE_6 TYPE_7 TYPE_9 < ? extends TYPE_7 TYPE_8 > ( minor simplification )
ideally call super ( ) cases put _CODE_ ( ) call init ( ) method called constructors
need METHOD_2 TYPE_1 ? a simple DTO
ImmutableList VAR_6 ( ) a bit redundant static import
want import static static methods
line need additional logic unsupporting languages I ve updated patch fix please rebase patch thanks
reason local METHOD_5 ( ) function
depend TYPE_1 ? moved constructor _CODE_ unmodifiable
tag relate action
I d store TYPE_4 factory instance a signature : VAR_5 = VAR_3 METHOD_1 ( source VAR_5 ) ; reused bitset stored place
guarantees VAR_2 empty ? empty skip ( calling ( input VAR_1 ( ) ) instead ( input VAR_1 ( ) )
a reason post ( ) ing instead executing
I reason METHOD_1 a string making a _CODE_ simpler ? ! : )
I don t warning system - defined prefixes s essentially informing user t change override schema : ( I crazy s leave possibility ) s point warning overwriting ignore setting
specific logic component need depend TYPE_1 METHOD_3 ( )
_CODE_ _CODE_ map ( empty string ) STRING_5 ( double quote ) original JSON _CODE_ = > quotes mapping _CODE_ = > ( map ) part mapping
need size VAR_4 output ? s logging
static import
done
a imbricated s ( minor enough feel free ignore ) : private TYPE_1 METHOD_1 ( TYPE_1 item TYPE_1 VAR_1 String VAR_2 ) { ( VAR_1 ! = null ) return VAR_1 ; ( VAR_2 equals ( item VAR_3 ( ) ) ) { return item ; } return null ; }
adding classes semantics s inspecting event some trim ( ) startsWith ( { )
wouldn t TYPE_4 file exists
need VAR_3 fair ? understanding a kafka VAR_3 transport VAR_3 isn t maintaining full order ( multiple partitions )
configuration injected read system properties constructor
hide bugs ? sense throw exception simply remove check ? 0x0 a valid code point return a bit ambiguous I d favor accessing array JVM throw error
public
s method ? public
validation step api throws exception necessary
please getters final
throw please
thrown others
avoid
set xml
final
final
const LOG
isn t needed method returns false default
TYPE_2 TYPE_1
return int
wrong tabbing function
check p null
I guess won t affect compatibility previous deployments ( reading / writing ZK ) nice confirm
wouldn t override METHOD_1 TYPE_5 class adding initialization code needed
needed
i e assertEquals
zamiast tego czysciej bedzie jak zrobiszthis ( STRING_1 ) ;
czy tworzenie nowej instancji zoomstyleparser a za kazdym razem ma sens ? moze lepiej przechowywac jako pole
nie pomyli ? e ? tu przypadkiem kierunków znaków ? ! teraz jest chyba ? e je ? li wykracza poza VAR_1 : D
I need super ( ) file
loop position VAR_1 parameters null
unsafe addition integer overflow long instead integer
redundant variable -
don t need super
don t need super
unnecessary call super ( )
a lot conditionals readable
unnecessary call super
aren t calling super class add super ( params )
method changed private
changed : VAR_2 = m ;
NPE risk
zawsze robi ? em / widzia ? em tak zrobione : int id = getId ( ) ; ( id = = R id VAR_1 )
optional : add uri a parameter turn intoreturn TYPE_7 METHOD_3 ( VAR_5 METHOD_5 ( ) ) other usages
good call whoops want check new VAR_1 object null possibly set true case null : )
revert useful tests running v2 gate : D
scala type java code
trailing curly brace missing && action ! = TYPE_2 VAR_6 && action ! = TYPE_2 VAR_7 ) {
return System getProperty ( STRING_1 ) ! = null ;
running v1 tests anymore v2 option
accept redirect I don t TYPE_5 needed TYPE_2 needed case want pop / push a vlan redirecting
infinite loop ! buf VAR_3 needed
I needed METHOD_2 check
shouldn t thrown
done more cleanly a stringformatter fine
problem je context koji se menja zato treba izbeci ovaj public void METHOD_1 ( Context context ) { ( ! VAR_1 ) { return ; } ( TYPE_1 isEmpty ( VAR_3 ) ) { VAR_3 = STRING_1 ; } ( VAR_2 ! = null && VAR_2 METHOD_3 ( ) ) { return ; } VAR_2 = TYPE_2 METHOD_2 ( context VAR_3 true ) ; }
( VAR_1 equals ( null ) )
braces
braces
braces
braces
bad
braces
braces
VAR_1 _CODE_ ( null ) instead done patch Set 2
METHOD_2 ( null ) instead done patch set 2
METHOD_5 ( null ) instead done patch set 2
METHOD_2 ( null ) instead done patch set 2
METHOD_5 ( null ) instead done patch set 2
consider promoting code _CODE_
file exists ( ) throw TYPE_1 check place ? won t file VAR_2 ( ) fail gracefully
remove debug printf submitting patches
VAR_2 = = null return
a big deal style other tests e g new TYPE_1 ( ) run ( ) ; a good idea similar s minor
synchronizing synchronizing lock
synchronizing synchronizing lock
message VAR_7 - > message VAR_7 ( )
return Boolean valueOf ( VAR_2 )
lets create a local variable : METHOD_3 ( VAR_2 VAR_5 ( ) ) ;
( args [ 0 ] args )
risky availability hard VAR_1 changed display rotates ( e g droid ) case software VAR_1 hidden fix implemented _CODE_ java
Throwable
others don t catch Throwable want fix fix
don t want _CODE_ instead ? I don t base class arbitrarily decide derived dialog behave hides root problem error message a SWT WRAP label making wrap properly needs a hack
method static static methods typically bottom class
method static comparisons form STRING_1 equals ( s ) preferred s equals ( STRING_1 ) s null won t throw a NPE I m aware rest file doesn t follow convention s reason fix new patches : )
more specific VAR_2 exception
I don t loop unrolling
I s escaping point message converted HTML rename message _CODE_
add protected modified other package protected methods match done _CODE_
assignment guarded VAR_2
please define resultcode int VAR_4 = VAR_1 ! = null ? VAR_1 METHOD_2 ( STRING_1 0 ) : 0 ;
METHOD_1 ( ) call super METHOD_1 ( ) ;
METHOD_1 ( ) call super METHOD_1 ( ) ; { VAR_1 METHOD_2 ( ) ; } finally { super METHOD_1 ( ) ; }
doesn t equals assymetrical a subclass o equals ( o ) true o equals ( ) false
! isEmpty
rationale changing return type File [ ] ? I s easier _CODE_ a List < File > _CODE_ ( ) return a List < File >
checking : doesn t create idea files a gradle - project s missing idea files ? _CODE_ project VCS project open action works
{ } finally { } rename VAR_4 _CODE_ clear restoring previous temporarily clearing
cache field
final
trivial : 1 space equals
tabs
another : - )
useful LV
A set 2 elements overkill check artifact 2 constants
similar _CODE_ share code
case startup ? = = - 1L instead
removing \n added ? add
fits a single line
incorrect ( fail new test disabled output null expected ( expect list a null ) I realize consistent abi / language version
pass 1 - 1 calculates size
List
isEmpty
! isEmpty CL
curious METHOD_4 direct parent METHOD_4 grandparent
return Arrays asList ( _CODE_ STRING_2 ) instead
s reason marking methods final ? don t want class subclassed mark class final instead
! isEmpty ( )
idem
spaces
please resources ( TYPE_2 VAR_3 = ) { }
instead breaking abstraction introduce isEmpty _CODE_
private
unnecessary { catch } test throw Exception write c VAR_1 advantage test runner give a full stack happened
INT_4
remove
remove _CODE_ ( VAR_1 ) sufficient application context anti - pattern
change null instead add VAR_2 ! = null check _CODE_ ( ) function return null VAR_2 null
prevent reordering METHOD_1 called lock I prevent reader side a problem synchronized
move line check logic ? calling METHOD_2 ( ) caused exception telephony
final
please remove return statement
I a copy - paste error removed
static
I guess rename VAR_9 VAR_13 write : VAR_13 | = ! VAR_10 equals ( VAR_12 ) ; check accurate
a static constant called ARBITRARY_BYTES s valuable pulled ( I I d inline personally )
remove
remove
don t pass args arg order ( writing VAR_1 )
definitively _CODE_ related CL I a question NUMBER_VALUE a _CODE_ ? I a good method return false
remove STA iface type set
Utils assertTrue
delete step closer edge
delete
removed
fixing root please change METHOD_2 ( ) call check null field accessing
printing System err s test failing code path
static works
instead checking action ! = null i d suggest simply change order equals e g return TYPE_1 equals ( action ) || TYPE_2 equals ( action ) ;
1 ? METHOD_3 0 N N exclusive
uh ? spot error
checks duplicate _CODE_ remove ? _CODE_ public don t need check
exception VAR_6 METHOD_6 exception thrown
needs a newline } section 4 1 3 style guide ( - line style harder blocks / allowed )
remove check ? throw _CODE_ s null happen
Optional : irrelevant test omit METHOD_2 ( ) 0
return
I write : ( TYPE_2 s = new TYPE_2 ( f ) ) { return s VAR_1 ( ) ; } ( similar _CODE_ )
tracker enabled change check call TYPE_2 METHOD_6 ( ) replaced _CODE_ I thik
common case useful information logging _CODE_ METHOD_4 ( ) doesn t match _CODE_ ? cases wouldn t want wrong uid
curiosity NPE ? VAR_1 null point
return ( context VAR_1 ( ) METHOD_3 ( ) VAR_2 & TYPE_2 VAR_4 ) = = TYPE_2 VAR_5
line
line shouldn t branch ( forgot mention )
I don t line rationale : VAR_7 _CODE_ VAR_3 VAR_5 VAR_8 masked result _CODE_ guaranteed VAR_8 masked line present remove
double & ? don t want VAR_3 & = VAR_2 ? I A & ( B & A ) = A & ( B | A ) = ( A & B ) | ( A & A ) = A & B I missing
I crash throwing IllegalArgumentException
meaning log message changes removing return statements
necessary ? generic _CODE_ ( ) I turn iris scanner ? leave authenticating state fingerprint send another signal high power mode complete authentication fingerprint
question
reduced a single line : return ( uri ! = null ? Integer parseInt ( uri VAR_1 ( ) ) : - 1 )
throw IOException throw a runtime exception general guidance a checked exception failures programmer s control unchecked exceptions programming errors doesn t need CL
needs return boolean success / failure
I don t need turning insignificant network updates ( e g cell tower info ) screen
happen a conditional basis avoid crash
added ? a separate CL
static move bottom s named helper method
equals ( )
technically booleans defined ! = 0
avoid method called more ? expected behavior shouldn t raise exception
add a log message
need var ? isn t method idempotent ? general avoid making object stateful
split blocks ? ( VAR_1 && ! VAR_2 ) { / / screen + wifi means device goreturn VAR_4 ; } else ( VAR_1 && VAR_3 ) { / / screen + charging means device a car homereturn VAR_4 ; } else { return VAR_5 ; }
VAR_1 sets _CODE_ true true / false suggestions / thoughts
reasons creating a local parameter instead method METHOD_3
defaults false key new missing older platforms METHOD_2 ( String boolean ) instead
package private ? ( _CODE_ ) / * synthetic access * /
call method
able : TYPE_3 info = VAR_2 METHOD_3 ( _CODE_ 0 ) ; return VAR_2 METHOD_1 ( info ) ;
return false
need METHOD_3 current VAR_1 ? wouldn t throwing TYPE_1 enough
enough
VAR_3 length
( VAR_1 = = VAR_5 ) { VAR_6 METHOD_3 ( VAR_7 TYPE_1 System VAR_4 STRING_1 ) ; } METHOD_4 ( VAR_8 ) ; METHOD_4 ( VAR_9 ) ; VAR_6 METHOD_3 ( VAR_7 TYPE_1 System VAR_4 VAR_1 = = VAR_5 ? STRING_2 : STRING_1 ) ;
done
I suggest simply VAR_4 [ VAR_2 add ( ) ] ; _CODE_ class defined return bounds s contractual
a host port 0 simply don t change previous ? sounds counter - intuitive honestly I simply readsynchronized ( VAR_2 ) { VAR_3 = VAR_1 ; }
remove
line long
fold _CODE_ method ? define a new method sets TYPE_6 reasoning wait idle _CODE_ ( ) method ll wait test slower
synchronize
close stream
I s expose a public method a default scaling switches doesn t change
I return a byte [ ] VAR_8 final
static
a lambda
need permission checks ? I assuming callback coming object system explicitly bound enough proof sender authorized perform action need need other callbacks
static
doesn t needs public
platform set _CODE_ default
inline s place s
s great rely knowing relies replace failing test s immediately obvious running sample test I bottom file
leave private modifying API JFYI s necessary I s worth making change
push synchronization block method
ditto I destination null
check empty list removed - loop clear call work empty list
remain private
a reason a list instead a TYPE_1 ? a usage perspective sense issue a single config
put test put setup ( ) method
suggest move a separate line s more readable
VAR_2
ANNOTATION_1
replaced METHOD_3 ( )
simplify ( ) - > METHOD_3 ( ) ? : : METHOD_3 ? I m interchangeability bound method references lambdas
need pass s
final
style : prefer write code a return - fast style ( VAR_2 containsKey ( target ) && TYPE_2 isEmpty ( VAR_1 ) ) return ; note case s clearer reversed check s a bizarre test want overwrite VAR_1 empty ?
METHOD_4 ( )
I need return empty list
encoding null
annotations line @Override
a noop please delete
I rid METHOD_2 ( ) calling METHOD_1 ( ) multiple times allowed camera released return a successful future
method auto - formatter making ? s fine code inconsistent
I private compiler generate a synthetic accessor other classes ( legal ) call
s new NETWORK_FACTORY permission paul building aosp / 1099096
protected
I stay protected - subclasses business calling
_CODE_ alreay METHOD_1 TYPE_2 need METHOD_1 ( ) METHOD_1 &sq = package : aosp - master&g = 0&l = 331
clearer R VAR_1 VAR_2 ( guards bugs METHOD_2 returning 0 )
boolean
tests new code _CODE_ ( ) supposed manage new property overwrite shouldn t instead a LP VAR_4 interface new property set some other interface cleared METHOD_5
need a transaction a single insert statement
single statements don t need a transaction
need a transaction
initialize _CODE_ ( )
VAR_4 METHOD_6 ( xxxx ) METHOD_8 ( xxxx ) METHOD_10 ( xxxx )
I don t fix show METHOD_2 incorrect I need file bug _CODE_ read true I suspect a letting unset _CODE_ return default 0 METHOD_2 wrong
kind tests VAR_1 METHOD_3 defined VAR_1 METHOD_2 ( ) - VAR_1 position ( ) assuming VAR_3 > 0 VAR_1 METHOD_3 ( ) > = VAR_3 implies VAR_1 position ( ) < VAR_1 METHOD_2 ( ) making test useless
want consider data stall VPN
shouldn t > = instead > ? VAR_1 VAR_3 length = = 4 index = = 3 VAR_1 _CODE_ length = = 3 code crash
guarded need synchronized
remove VAR_6 apps don t
METHOD_3 sets state
unused
_CODE_ addAll ( VAR_1 )
please separate lines
wifi omit function removed
avoid duplicate code call METHOD_1 ( listener listener VAR_6 )
patchset 10 visible ( annotated ) s fine contradicts answer – intended
reaching pretty deep implementation detail wrapper isn t METHOD_7 ( ) idempotent ? call
tethering inactive tethering restricted updated restrict ? logic correct ? another question tethering inactive show notification ? wired tethering restricted notification I enable tethering I understand correctly
don t need check VAR_1 - 1 0 VAR_3 length - 1
add exception param
I tend a boolean return consistency
! TYPE_2 equals (
suggest unindenting clarity : ( ! TYPE_2 equals ( VAR_2 VAR_1 METHOD_2 ) { return false ; } int i = ; ( i = = - 1 ) { return false ; } VAR_3 remove ( i ) ; return true ;
thread safe access VAR_1
super _CODE_ doesn t call super other ? ditto
return unused
current setup collecting rss processes running system case user supplied VAR_2 null dynamically query process PS - A inititlaize initialize garbage collection helper _CODE_ ( ) method query process names
shouldn t need order METHOD_4 ( ) I check I safely give READ_PRECISE_PHONE_STATE package
need check VAR_2 ? unrelated METHOD_1
suggest a local visibility int other places a ternary inline don t duplicate code
return METHOD_1 ( context VAR_1 false ) ; clearer 2 methods a potential difference default
happened code TYPE_1 METHOD_1 ? ( context _CODE_ ( android manifest permission CHANGE_NETWORK_STATE ) = = _CODE_ PERMISSION_GRANTED ) { return true ; } app CHANGE_NETWORK_STATE permission able call _CODE_ WRITE_SETTINGS
move a camera2 implementation leaking camera2 implementation details a thought a _CODE_ interface default flash mode _CODE_ device legacy provide implementation return precapture needed
null ? ll throwing exception doesn t matter else crash eventually ? binding a socket VAR_1
simplified : return VAR_5 ! = null && VAR_5 METHOD_3 ( )
s test case return true
remove local var needed realy line write STRING_2
write : return VAR_3
a repetition parameters field names worth extracting constants
don t need METHOD_2 ( ) METHOD_3 ( ) ! = null condition
assignment redundant
message warnning level error
remove initializing c tor done declaration statement : private TYPE_1 VAR_2 = TYPE_1 TYPE_3 ;
long System current time
lines code updates DB clear open a 2 transaction updates related I understand committed
put code line part condition scope ( VAR_3 ! = null ) adding error logs null values VAR_1 VAR_3 entity helpful
a lot places ugly class initialized passed some other place
run vm
true : run vm ! ! ! method fails
call inline TYPE_2 getInstance ( ) METHOD_2 ( ) remove ( )
change
I m logic correct TYPE_1 linked template fact a TYPE_1 instance don t _CODE_ anymore call removed duplicate field ( VAR_1 )
don t need a transaction
METHOD_8 TYPE_5 called automatically
rebase pass a new ArrayList ( ) _CODE_ need variable
check isEmpty ( )
please move tot init ( ) method
return check ? IIRC return true quota valid return true CDA
storage pool set quota object i don t a reason send separately apply update remove
i check needed don t factory create command null params decide check add error message
ain t super call redundant
TYPE_2 stateless worth singletonize
call VAR_3
copy & paste instead calling super remove ( images remove )
change public
need instantiate a variable a line override move instantiate else clause
shouldn t context
I don t a cluster removed host monitor cluster null
redundant
please wrap - else block brackets { }
wrap call a specific failure refresh fail
please omit TYPE_7 TYPE_8 prefix ArrayList imported ( lines )
perform update case vdsm call successes time _CODE_ ( ) change METHOD_4 ( ) update storage pool format type
static ? list expected change run need parse command
shouldn t braek VAR_1 false ? ( opinion ) i easier understand return false false : ( TYPE_2 VAR_2 : VAR_3 ) { ( ! VAR_2 METHOD_1 ( vds ) ) return false ; } return true ;
opinion : ) ( break logic correct )
minor : private method
minor : private method
shouldnt return ! ( _CODE_ )
permission vm storage
need check vm ! = null
add a check METHOD_2 exists ( null )
I VAR_2 variable passed VAR_3 method instead converting string
i gluster volume id set super constructor
consider testing ( ) ! = null test isn t completely dependent remove ( )
a single line
require permission disk calling super add requirement vm
I boolean removed add a default quota time create a DC flag time edit creation quota time _CODE_ = true
put call METHOD_5 ( vm ) method METHOD_4 ( ) s method - adds information want VAR_7 objects mapped
need check VAR_2 isEmpty ( )
nt getter _CODE_ field VAR_1
need explicit call toString METHOD_4 ( ) null safe
answer
compare VAR_1 id image id
disk identifier s ID I s compare _CODE_ anymore
break loop reached a failed VAR_3 METHOD_1 ( )
I consider rewriting : ( values = = null ) { values = new HashMap < String Object > ( ) ; VAR_2 put ( VAR_1 METHOD_2 ( ) values ) ; } values put ( VAR_1 METHOD_3 ( ) METHOD_4 ( VAR_1 ) ) ;
TYPE_1 ? unchekced
METHOD_3 ( ) ? solve generic
METHOD_3 ( ) ? solve generic
METHOD_2 ( ) ? solve generic
a matter taste tought : VAR_3 = Boolean VAR_2 ( VAR_1 ) ) ;
needed cal METHOD_6 ( ) guids ? i don t remember need /
VAR_3 initialized command storage type VAR_4
storage pool null ? ( LUN disk floating )
I don t idea put query constarctor _CODE_ unneeded query don t need a _CODE_ _CODE_ _CODE_ _CODE_ _CODE_ putting constractor wrong
a ( ! ) check i relevant
rebase VAR_1 needed more point
good enough some reason execution fail method called fail run error audit log failure
please remove alias setting ( encapsulated METHOD_3
please remove alias setting ( encapsulated METHOD_2
please remove alias setting ( encapsulated METHOD_3
please remove alias setting ( encapsulated METHOD_2
please remove alias setting ( encapsulated METHOD_2
please remove alias setting ( encapsulated METHOD_2
potential NPE VAR_1 METHOD_1 ( ) check _CODE_ ( )
replace brick order new brick brick parameter STRING_6 need passed SP
needed
common writing ! VAR_1 ( ) isEmpty ( )
i test failed suppose fail shouldn t NULL iirc GUI default display type host QXL desktop TYPE_5
simply call _CODE_ METHOD_3 ( Class < TYPE_1 > VAR_1 String ) ? ( instead TYPE_3 METHOD_3 ( VAR_4 VAR_6 VAR_1 ) wewill maintain localization places )
please remember ctor changed
a matter style written : return METHOD_2 ( ) METHOD_3 ( VAR_1 ) size ( ) > 0
please add a constructor spm_id
needed defined class
passing command a _CODE_
( ) instead toString ( ) overridden
set messages cluster supports gluster ? a generic move host command setting messages ( VAR_2 VAR_3 ) irrespective cluster supports gluster
I suppose intention overwrite _CODE_ set VAR_4 constructor ? code illogical
reason line lets : line update entry DB I need update object updated DB more ? example dead code dead code written
a member A function ( computed another member ) inline
( ) instead ( ) won t _CODE_ ( ) ( true places ( ) )
equalsIgnoreCase
check METHOD_2 _CODE_ skip validations
don t block s unreadable follwoing : ( _CODE_ isEmpty ) { VAR_1 = false ; METHOD_5 ( TYPE_2 VAR_4 ) ; } else { METHOD_4 ( VAR_2 ) ; }
equalsIgnoreCase more user friendly
needed ? don t trust other engine ? ; )
checking _CODE_ needed called _CODE_ method
please TYPE_3 TYPE_5 ( ) instead TYPE_3 TYPE_5 toString ( )
super METHOD_1 ( ) assuming cluster id set checking server need overcome thisalso please commands inheriting command base doesn t assume specially _CODE_ called METHOD_1 ( initiate params ctor )
flaged done suggestion previous patchset I don t change intentional
vm null locked
previously run vm = = null a situation d disks action vm = = null ? ( sounds odd need code worked )
protected
call super
message : connecting host < UNKOWN > storage server
conflicts commit message - uninitiazlied case commit message reflect isn t case check removed
METHOD_9 moved _CODE_ ( )
check vm null verified _CODE_ executed VM disks VM deleted I don t vm null
< T > needed
please return break
don t need call VAR_2 METHOD_7 ( ) _CODE_ VAR_5 ( ) invoke _CODE_ _CODE_ ( ) default
fail - initialize VAR_1
blank null default error
set
need creating new instance VAR_1 new - resource / subcollection reuse instance defined _CODE_ adding [ resource _CODE_ ( X ) ; ] _CODE_ inject ( ) - inject context ( backend ) - resource / subcollection
VAR_2 METHOD_4 ( ) null list include null element result a false positive comparison ( _CODE_ ) list filtered null elements
written 5 sec ( default ) i debug
I figured s bugging line logic semantics : ( ( Boolean ) VAR_1 METHOD_2 ( ) && VAR_2 ! = null ) { return VAR_2 ; } return METHOD_3 ( ) ; clearer case user affect volume type collapse selected user changed
_CODE_ : VAR_1 put ( TYPE_4 TYPE_6 ( ) METHOD_2 ( ) METHOD_5 ( ) ) ; VAR_1 put ( TYPE_4 storage ( ) METHOD_2 ( ) _CODE_ ( ) ) ; VAR_1 put ( TYPE_4 VDS ( ) METHOD_2 ( ) _CODE_ ( ) ) ; rely remove super METHOD_1 call redundant personally I prefer ( rid super )
fixing ? constructor sets vm getParameters ( ) METHOD_2 ( ) METHOD_2 set constructor parameters done ( redundant ) i don t understand need params
METHOD_2 sounds exception else ( )
mind adding a unit tests _CODE_
add getter TYPE_1 instead splitting fields
isn t private
s a i line ctor
need check shouldn t null
VAR_2 ! = null redundent - DAO ensures return empty list VAR_2
super
won t String format nicer
return element _CODE_ ( VAR_1 ) item ( 0 ) METHOD_2 ( ) item ( 0 ) METHOD_3 trim ( ) ; long standard text node extraction
true ? check METHOD_2 ( ) METHOD_4 ( )
s point catching exception throwing catch block ? need wrap a RuntimeException thrown METHOD_4 ( ) a RuntimeException
validation required expect VAR_4 returned glusterfs ( vdsm ) correct format
sharad I changed code a bit METHOD_3 - care refactor replace TYPE_2 getInstance ( ) METHOD_3 ( ) a METHOD_3 ( ) call
need string utils want I a _CODE_ method
please iterate entrySet
I don t user instanceof overload method recive TYPE_2 ? places function information
rebase please wrap return statement curly bracesand format lines ( i e a white - space missing )
return statement redundant
package protected work ? a commonly accepted practice writing unit tests
optional : consider _CODE_ ( VAR_1 VAR_2 isEmpty ( ) )
Optional : consider assertTrue ( VAR_1 VAR_2 isEmpty ( ) )
a bit a workaround - mockito s verify
purpose statement
addition moving init size - _CODE_ values ( ) size ( )
please add a message
inline return statement
inline return statement
I d call super ( message VAR_3 )
a scenario a _CODE_ ability cloned
remove
config file VAR_4 storage enabled 3 3 changed
please add a helper method performing ? code repeating patch edited classes
_CODE_ performed removed - else
i d create rpmversion dedicated test forcing other tests defining ( ! NULL check mapper trick )
( need define version )
return Arrays asList ( VAR_2 VAR_3 VAR_4 ) ;
missing space ( ) {
create TYPE_1
java conventions
/ s / METHOD_1 / _CODE_
wait worse previous version happened assertEquals ( )
wait worse previous version happened assertEquals ( )
wait worse previous version happened assertEquals ( ) ? [ supports primitives suggest ]
wait worse previous version happened assertEquals ( )
triggered success fail a host moved _CODE_ intention add a catch add failure reason failure _CODE_
remove code useless pass a vdsm
set attributes command
call : METHOD_1 ( VAR_1 Arrays _CODE_ ( VAR_2 ) ) ; btw read VAR_3 other method write VAR_3
equals instead ! =
done part VAR_2 logic fields added vm_interface_view need double query
I disagree place s hiding logic unrelated place I call needs done explicitly remove called ( case statistics )
I network exist able edit ( attach ) parameters permission network permission cluster
I agree moti changing order enough ( METHOD_2 ( ) equals ( VAR_2 getName ( ) ) instead VAR_2 getName ( ) equals ( METHOD_2 ( ) ) ) need check cluster network null t null
a new transaction needed
suggestion : I consider remove VAR_1 instead call METHOD_4 METHOD_7 ( CDA more shorter I more performance wise )
a member enum return upper case
iiuc propietary a string enum added TYPE_3 adding < pm_proxy > validating
please switch assert values expected / s / disk / storage type / s / /
final
need return super METHOD_1 ( )
please < operator > null convention
please < operator > null convention
please < operator > null convention
return null
_CODE_ ( ) instead mocking
return terminates - remove else
super METHOD_1 ( ) dao call
t vm = = null removed
t vm = = null removed
iterating keyset calling map line iterate entrySet instead
please check needed
I agree vered
relevant images hadnling a LUN VAR_1
return ; statement
remove code : ( ! ( return false ; } return true ; simply : return super METHOD_1 ( ) && METHOD_5 ( )
check VAR_1 count doesn t add ll execute query time VAR_1 invoking METHOD_5 ( ) query cases VAR_1 won t delete succeed work
forgot inline liner method moti suggested patch #1 : - ) other - good
TYPE_2 replaced loop return statement simplify reading reduce need creating new anonymous class
please policy tab hidden gluster mode
I guess need a null check
check result empty
i need pass SERVER_ID want update status
I meant : METHOD_5 ( ) METHOD_6 ( * VAR_2 getId ( ) * )
I m troubled line : _CODE_ configuration variable reloadable code won t serve case moved permissive restrictive mode : returning a MAC address VAR_1 address pool done longer VAR_2
I wouldn t a variable return spot method complicated need a variable track s return
+ TYPE_3 class METHOD_3 ( ) ? leave space missing dictionaries
vm unlocked super METHOD_1 ( ) ;
don t need call super method
a potential NPE VAR_2 initialized I d suggest changing : Map < String String > METHOD_1 ( ) { ( VAR_2 = = null ) { VAR_2 = super METHOD_1 ( ) ; ( VAR_1 ! = null ) { VAR_2 put ( TYPE_1 VAR_4 VAR_1 getName ( ) ) ; } } return VAR_2 ; }
code necessary s DAO responsibility return empty list VAR_1 de - facto contract system
assertEquals compare objects compare TYPE_2 objects : assertEquals ( TYPE_2 TYPE_3 VAR_1 METHOD_1 ( ) ) ; file
please replace METHOD_2 ( ) ( ) entire file i e ( VAR_1 METHOD_3 ( ) ) _CODE_ ( null ) ;
done
done
needed METHOD_2 method performs check doees a atomic synchronized modifier required
remove method _CODE_ performs synchronization synchronized modifier required
return statement line : return VAR_1 ( key ) ;
won t VAR_1 remove ( ) enough
action shouldn t fail : & _CODE_ ( ) _CODE_ = = _CODE_ ( ) _CODE_ ( )
StringUtils _CODE_ ( source )
related change isn t some enum instead hardcoded STRING_1
null check _CODE_ ( ) METHOD_1 ( )
please case - sensitive comparison
private static
1 error needed removed ( _CODE_ user ) _CODE_ query2 please remove exception _CODE_ ( ) youmake _CODE_ admin - wellthanks
easier read a positive check a negative
need else word s code more confusing opinion
METHOD_3 ( ) instead fetching disk
extra semicolon
please set a modifier - protected suitable
protected access modifier instead default ( - )
encapsulate METHOD_3 ( ) METHOD_2 ( ) METHOD_3 ( )
done METHOD_1 method ? logic other appended version parts
a reason static ? isn t declared private method
protected
VAR_1 ( ) defined List < TYPE_1 > I d initialize arraylist _CODE_ METHOD_2 ( ) size ( ) + VAR_2 METHOD_3 ( ) size ( ) add items s a matter taste
case don t need create instance - remove ( provided = true ) declaration remove VAR_3 = new TYPE_2 < TYPE_3 > ( ) ; completely TYPE_7 ui xml declare a new namespace : xmlns : l = urn : import : org ovirt engine ui common widget label replace < g : _CODE_ ui : field = VAR_3 < l : TYPE_2 ui : field = VAR_3
t NPE ? user case internal command
missing log debug ( builder toString ( ) ) ;
consider removing else clause
minor : please < operator > null convention
needed enum
convert some logic ( e g source null return emtpy list ) enough return source ; converter
I don t check calling method extracting method _CODE_ ( a similar method _CODE_ ( network ) extract a method _CODE_ ( String ) method )
super ref needed
NPE - VAR_6 null I VAR_6 null null passed method advanceddetails bricks fetched
sense ? - vm VAR_5 a _CODE_ ? I scenario blocked allowed arrive state
option move ctor other place ? execute ? a feels related ctor
calling super METHOD_1 i guess return true
throwing exception
METHOD_7 ( true ) enough update command
METHOD_1 ( ) execute additional queries complete entity whilewhat reside _CODE_
s true - - - > return entity getId ( ) equals ( id ) ; cut corners
bare mind external task injection feature eli introduce a map _CODE_ TYPE_2 addition TYPE_2 evicted ( due LFU - btw LFU LRU ? ) - restore context due cache miss ? please elaborate
instead iterating List < TYPE_2 > request Map < String TYPE_2 > - mapping VAR_3 getPath ( ) TYPE_2 instance avoid O ( n ) access due iteration favor O ( 1 ) access due map access regard TYPE_2 instance
excellent change ! + 1
new File ( VAR_2 VAR_4 ) remove / VAR_4
need call super
METHOD_2 ( ) checked METHOD_4 ( ) return null NPE
s checked vm / paused / line 45 reach vm locked
awesome add a method METHOD_2 ( ) return TYPE_3 getInstance ( ) METHOD_2 I promised explanation I provide ( mocking life easier a step dependency injection )
redundant _CODE_ ( ) _CODE_ ( false ) _CODE_
I d call variable _CODE_
please replace ^ log error ( )
produce a number constructor _CODE_ warning please Integer valueOf ( 0 )
Double valueOf ( 0 0 )
remove call ( ) ;
redundant
redundant cast
instead Boolean valueOf ( boolean ) toString ( ) String valueOf ( boolean )
instead Integer valueOf ( int ) toString ( ) String valueOf ( int )
instead Integer valueOf ( int ) toString ( ) String valueOf ( int )
nullity check : )
save null check : ! equals ( model VAR_1 ( ) )
extracted code notice line redundant done line 80 _CODE_ message line done line 80 consideration
need
empty string constructor redundant
consider a single line : VAR_1 append ( VAR_2 METHOD_2 ( ) append ( VAR_2 METHOD_3 ( ) append ( VAR_4 ) ;
empty string redundent
/ s / TYPE_2 getInstance ( ) METHOD_4 ( ) / METHOD_4
IMHO explicit Object constructor redundant
equals - guarantee s Guid instance
replacing ternary ?
remove VM place audit log removed
potential NPE host VAR_4 ( ) _CODE_ please remove Long valueOf ( ) host VAR_4 ( ) Long INT_2
need check - vds VAR_2 ( ) ! = null
done
please format code correctly enter { else
template null - - action checks fail command check template null _CODE_ ( ) case null return null won t build engine lock acquire
removed static
I ( want ) toString ( ) implicit formatting removed
please add sync protection _CODE_
removed static
fix initialization singleton device custom properties
user provides _CODE_ VAR_3 ? swap comparisons
move separate tests verify error message returned VAR_2
CDA messages extend won t displayed CDA phase
I prefer list VAR_4 ( new String [ list size ( ) ] ) - save instance : )
METHOD_4 ( ) code need
need addition ? isn t default
StringUtils isEmpty
solve NPE I suggest place null check TYPE_1 METHOD_5 method avoid similar omissions future sense METHOD_5 return VAR_2 _CODE_ unspecified
consider : ( TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 ) ) { VAR_2 write ( sb toString ( ) METHOD_2 ( ) ) ; } equivalent lines code : - )
please revert order conditions static validation validation requires fetching DB : private void METHOD_1 ( TYPE_1 VAR_1 ) { ( StringUtils VAR_3 ( VAR_1 METHOD_5 ( ) ) && ! TYPE_3 METHOD_3 ( VAR_1 METHOD_4 ( ) ) && ! TYPE_2 METHOD_2 ( vds VAR_2 ( ) ) ) { }
remove multiple distribution groups a single shot ? problem logic
point case sensitive check empty string StringUtils isEmpty ( connection getId ( ) )
i update null don t touch device setting ( leave don t create )
I d inline - TYPE_2 VAR_2 = METHOD_2 ( ) METHOD_3 ( STRING_1 VAR_1 ) ;
method static ? singleton access methods getInstance ( ) static
behalf michael pasternak : [ 1 ] i d consider synchronizing writes getInstance ( ) & getInstance ( final File VAR_1 ) creating actual instance instance var definition
prefix full package TYPE_3 TYPE_4 redundant
line lock released s
return id ;
I message VAR_8 changed _CODE_ instead server need add custom server other places - _CODE_ _CODE_
y private
meaning VAR_2 var local
reminder : remove TYPE_1 return null ( perform rollback previous task handler )
perform revert _CODE_ _CODE_ ( ) - image removed completely case ( DB ) i benefit additional logic _CODE_
changed > ! =
please move METHOD_5 METHOD_2 connect ( VAR_1 ! = null )
combination succedded force clear s discuss ; I API change
btw true _CODE_ ( ) triggers _CODE_ ( )
STRING_1 capital ? don t need a case insensitive compare
line pulled METHOD_1 ( ) method _CODE_ class repeats _CODE_ commands
yeah I didn t don t prefer add clause ( i check line 356 ) : METHOD_2 ( ) = = null || METHOD_2 ( ) METHOD_3 ( ) = = null ? s a matter style
please add brackets ifs
need check ? _CODE_ takes TYPE_1
i d create a dedicated mapper TYPE_5 ( [ 1 ] ) [ 1 ] TYPE_4 _CODE_ map ( VM vm _CODE_ template )
want remove null validation constructor added
practice followingif ( TYPE_2 TYPE_5 equals ( vds getStatus ( ) ) ) check
reason local var
I d avoid continue : ( vm ! = null ) { VAR_1 add ( vm ) ; }
part METHOD_5 ( )
I finally block case exception thrown previous methods
NPE
new Guid ( String ) - literal t null
new Guid ( String ) - literal t null
new Guid ( String ) - literal t null
new Guid ( String ) - literal t null
new Guid ( String ) - literal t null
new Guid ( String ) - literal t null
important i nicer VAR_2 getName ( )
{ line scope lets itconsider a report null passed
reason synced ? _CODE_ variable volatile visibility problem solved
please _CODE_ class versioning checking s standard constrain feature a specific version
a part METHOD_1 ( ) logic
split allow AD users context
called VAR_6 ( ) wouldn t want remove list _CODE_
inlined METHOD_3 ( new ArrayList )
equals instead = = method logic please remove duplication
mind reverting condition a positive form ? return TYPE_4 METHOD_3 ( vm VAR_3 ( ) ) ? TYPE_1 VAR_6 : new TYPE_1 ( TYPE_5 VAR_5 ) ;
checks squashed check - VAR_1 METHOD_2 ( ) ! = TYPE_2 TYPE_3 I prefer ! TYPE_2 TYPE_3 equals ( VAR_1 METHOD_2 ( ) ) check removed s s changed check method call replaced check : )
more a debug please remove log debug
redundant call ( VAR_2 VAR_3 VAR_4 VAR_5 ) handles
super
s defined upper case - need run METHOD_1
resource interface ( branding properties ) relay file
static please check
caching u
readability / consistency consider invoking TYPE_2 - > METHOD_1 ( ) instead
add a null check please
call _CODE_ ( ) setting return setting retunr statement
assertEquals
ummm a singleton simply instance method
please format uniformity i e argument line s a formatter s part git repository plug IDE job
please protected
constructors a bad place invoke DB operations - hard test command a simple lazy getter
simplified followsif ( VAR_1 ! = null ) { VAR_1 METHOD_2 ( ) ; }
problem _CODE_ cancelling timer previous _CODE_ request returned creating a new timer scheduling timer - ? create time constructor METHOD_3 triggered want
lines 578 - 581 removed Long valueOf handles null
redundant clause s else ( ! VAR_2 ) - means else called _CODE_ = = true need include 2nd clause
foreach style loop
0 ? a VAR_1 6 bricks 2 scenario loop executed 4 times 3 enough expected result
I context parameter
IIUC ! = TYPE_3 VAR_2
call METHOD_5
add a null check METHOD_2 ( )
METHOD_9 ( false ) return
need worry status host
t resolved editor ( avoid similar issues other widgets ) ? E g _CODE_ - > METHOD_1 ( ) - model _CODE_ ( values ) invokes _CODE_ clearing listeners
I prefer create TYPE_1 delegate method _CODE_ optional developer easier integration IDE
I I world temp vars : ) please ignore ! return VAR_2 equals ( ( ( TYPE_1 ) obj ) VAR_2 )
compare guid
based VAR_4
_CODE_ : : METHOD_1 enough
return Object ? need class
getParameters ( ) < Guid > METHOD_5 ( _CODE_ TYPE_3 ) : getParameters ( ) METHOD_5 ( _CODE_ TYPE_3 ) function object
a small I d doif ( VAR_2 isEmpty ( ) ) alternativelyif ( equals ( VAR_2 ) ) I guess s generated _CODE_ perspective
method stop rebalance ? I stop call
a null check VAR_4
add parameters TYPE_1 s constructor enforce parameters live migrate disk command image group id
StringBuilder ? ?
please remove printing stdout
work I understand correctly run gwt ? support File : : _CODE_ ( ) ? s I a more generic path replace ( / / STRING_1 ) conditional
remove line
thinking method protected final
I final
I final
I final
need public
METHOD_6 query failed
I don t a cache update pls fix java doc
model influenced searchbar remove patch
I need understand s discuss _CODE_ infrastructure I done automatically de - serialized
condition checked
i CPU visible cluster dialog
VAR_2 null NPE herei safe send null METHOD_5 method ? null check VAR_2 removed prevent NPE
check redundant
reason VAR_1 temp parameter : )
I pushed higher patch chain
I METHOD_2 returns int need assign Integer assign int type pass parameter creation code
please separate a method METHOD_4 ( ) _CODE_ ( )
vds lock acquired gluster hosts
don t count ArrayList - a List
VAR_1 empty ? builder length - 2 error
changing true useful solve unreported bug I
reference type List
prefix necessary
final ? please stick a single type ( List / ArrayList )
I don t point a METHOD_3 action a subtab
I don t getter needed publicly
METHOD_4 ( ) returns null ll NPE
guarantees getParameters ( ) METHOD_3 ( ) ) represents a real VAR_2
I thought subtab wasn t supposed visible VAR_1 wasn t external ? check inline METHOD_2 ( )
formatting
I reason setters public
initiate VAR_1 new TYPE_1 ( ) rid check
I METHOD_1 ( ) - op ; semantics a key picked case change a key picked ? boxes ( constrained free text ) hidden I hide originally extending _CODE_ ( ) method implement - op
I private
shouldn t TYPE_1
call id
consider ternary
migratable enough
VAR_3 METHOD_3 ( ) METHOD_4 ( ) null brick present DB
invert condition return false : ( ! METHOD_2 ( VAR_3 ) && ! VAR_3 equals ( VAR_1 [ i ] ) ) { return false ; } don t need else branch
want runtime exception signature constructor
VAR_1 optional parameter
don t need METHOD_4
please check METHOD_5 ( ) METHOD_3 ( ) nullity - iirc null case storage domain maintenance
please surround block { }
a local variable
shouldn t needed model randomly populated populate method enum types need special treatment booleans
I don t need else ? cases
I d add METHOD_1 ( ) method TYPE_1 enum return METHOD_2 METHOD_1 ( )
a special reason wrapped classes
minor : METHOD_3 overload type params
hm a - picky question : shouldn t _CODE_ _CODE_ < Integer > instead _CODE_ < String >
please check result break false values point continue false
a question a rule styles : public TYPE_2 ( String _CODE_ boolean VAR_3 TYPE_1 VAR_5 ) { _CODE_ = _CODE_ ; VAR_3 = VAR_3 ; VAR_5 = VAR_5 ; } public TYPE_2 ( String _CODE_ boolean VAR_3 String VAR_4 String ) { ( _CODE_ VAR_3 new TYPE_1 ( VAR_4 ) ) ; }
I alternate cleaner solution please separate parsing data
lun disks removal t fail execute part s a simple removal db i don t mind future case ll add ops fail
sending space
need warning caller infrastructure component
need config temp variable
I unsure need cache another instance map query repository iteration
I reuse File object returning example pass copy medhod instead string
transports private need a method wraps list add
please import TYPE_2 TYPE_3 instead explicitly writing
method accepts _CODE_
true = > false
true = > false
don t items null ArrayList ( List Collection ) isEmpty ( ) method
need getter public
wrong patch fix
valueOf support nulls - NPE code patch I m guessing meant : return ! = null ? valueOf ( VAR_1 ( ) ) : null ;
required
remove file = = VAR_2 entire tree effected
please _CODE_ _CODE_ ( )
hm reason add : VAR_2 METHOD_5 ( ) ; block analogous : VAR_2 start ( ) ; block
VAR_1 = ( = = null ) ? : ;
hmmm : ! ( equals && equals ) : )
need file = null null
simply catch Exception don t special handling exception class
call METHOD_1 ( VAR_1 parameters VAR_2 VAR_3 state false ) ;
I agree question change ( aggregate error messages default ) affect existing code method
integer int ? i dont return null
I expect false default return new TYPE_1 ( ) ; want lock : return new TYPE_1 METHOD_2 ( true ) ;
broken considered valid - btu note broken status removed
a bit weird getParameters ( ) METHOD_3 ( ) method argument VAR_1 other places ovirt - engine I suggest argument instead order comply standards commands infrastructure I suggest remove argument ( change _CODE_ ) solution fine
initialize _CODE_ empty map TYPE_2 instead null checks
order methods I prefer code : HashSet < TYPE_2 > entry = VAR_2 ( entity ) ; ( entry = = null ) { entry = new HashSet < TYPE_2 > ( ) ; VAR_2 put ( entity entry ) ; } entry add ( VAR_1 ) ;
done setup note - occurs test methods
need a boolean ? I don t mind needed
private static
private
I call
need extract variable
a nice change s unrelated patch a separate
need extract variable
a nice change s unrelated patch a separate
a nice change s unrelated patch a separate
put METHOD_1 ( ) place
10th time need soft limit METHOD_1 ? ! ? !
key session id
I don t understand key session id
feel free inline need String message temp variable
method please remove VAR_1 variable ? needed people add more logic method ll - complicated methods _CODE_ methods
switch order avoid race
please put record
reason combine method _CODE_
( VAR_2 _CODE_ false ) ;
reorder expected actual patch -
want check size list
remove else clause
I onlycatch ( IOException e ) { METHOD_7 ( e ) ; } other _CODE_ handle please apply other blocks
need convert case part ( ) implementation TYPE_2
please VAR_4
change true unrealted NFS mount options please publish a separate fix
omit Assert class notation
change i d expect : assertTrue ( VAR_1 isEmpty ( ) )
please omit class notation
won t sync METHOD_2
work put constructor _CODE_ ( ) shouldn t ? shouldn t invoked selection a main tab item
point putting application mode session ? read information t simply read configuration
simply constructor : public TYPE_1 ( String VAR_1 ) { ( ) ; _CODE_ = VAR_1 ; } code duplication shorter
else missing time perform METHOD_3 process request webapp happen long nego add else
session ? move condition
METHOD_1 - - > _CODE_ consistency
note enums = = prefer
move line ? basically METHOD_5 called result case error null expected NPE hide real error message vdsm
shouldn t executed VAR_2 METHOD_5 ( )
return valueshouldn t ( ! super equals ( obj ) ) { return false }
status message wrong ( check more statuses ) s put domain status
need extract variable
backend return null need a null check source
null search return
please move else a line
true VAR_1 QOS type
METHOD_2 returns string need new String ? new String byte array explicit encoding
return _CODE_
context null
equals instead s objects
s final
METHOD_4
guid update statement
iirc s initialized ctor check s empty
create map needed
NPE case VAR_2 null
please remove patch
thread local needed patch
please rebase arik removed lock a patch
1 null ? shouldn t choose default pool ? 2 part previous patch
case removing _CODE_ _CODE_ ( VAR_2 ) ; need override METHOD_1 ( ) method please : super ( new TYPE_1 < String > ( ) ) ;
variable removed
signature : METHOD_6 ( Collection < T > T _CODE_ )
rename tempvar
call VAR_3 s METHOD_1
package private
I ve moved VAR_2 VAR_3 > VAR_4
IMO VAR_1 check redundant I m point VAR_1 = false ( false - don t want return ? )
I encode query string result double encode
move ? - ( VAR_1 || VAR_2 > VAR_3 || VAR_4 ) { return ; } duplicating _CODE_ Response SC_NOT_FOUND
cast List
remove Assert ( s a static import )
remove Assert ( s a static import )
throw
private static
need a null check VAR_2 ?
want externalise constants a separate patch ? call GEOREP_ROOT_USER similar
getInstance ( ) getInstance ( )
remove internal ? internal other
static
I d flip comparison - ( VAR_1 = = null ) - more readable
null left side
ravi thread VAR_1 METHOD_2 ( ) returns null safe pass null METHOD_5
replace access TYPE_2 METHOD_1 a static import METHOD_1 consistent
I more readable written : ( VAR_2 ! = null ) { VAR_2 = Collections VAR_3 ( Arrays asList ( VAR_2 ) ) ; }
ll generics won t need cast
please remove
protected private
a model a UI infra object ( _CODE_ ) original code ( _CODE_ _CODE_ ) copy - pasted _CODE_ method refers _CODE_ I suggest remove line I don t effect
shouldn t _CODE_ = TYPE_4 filter ( VAR_4 VAR_5 ) ;
patterns : sync { VAR_1 = ( byte [ ] ) session VAR_2 ( VAR_3 ) ; ( VAR_1 = = null ) { session VAR_6 ( VAR_3 VAR_1 ) ; } } : sync { ( session VAR_2 ( VAR_3 ) = = null ) { session VAR_6 ( VAR_3 VAR_1 ) ; } } VAR_1 = ( byte [ ] ) session VAR_2 ( VAR_3 ) ;
user point view action failed restarting host s true implementing restart stop - wait - start - wait transparent user IMO log restart operation _CODE_ log _CODE_ IMO block remain change : TYPE_1 METHOD_1 ( ) { return METHOD_2 ( ) ? TYPE_1 VAR_1 : TYPE_1 VAR_4 ;
please change left side Collection
replace assertEquals
please change equals ( )
I appeared - move trenary logic insidecoco METHOD_2 ( guid )
wouldn t solution traverse values string comparisons ? private boolean METHOD_1 ( String VAR_1 ) { boolean exists = false ; { TYPE_1 valueOf ( VAR_1 ) ; exists = true ; } catch ( Exception ) { } return exists ; }
frontend ? shouldn t a concrete class List ? ( other place code ) GWT issues dynamic types / inheritance
public
please method protected
braces removed
_CODE_ ( null ) ; method
need surrounding brackets
replaced : return VAR_1 ! = null && VAR_1 METHOD_2 ( TYPE_1 VAR_3 ) ;
methods - static
1 _CODE_ prone 2 start significant part
call empty c tor redundant
1 shouldn t check assert ( = = null || instanceof String ) ? 2 please add some text explaining assertion case fails ( e g validation applied a String )
please trim ( ) isEmpty ( ) instead length check
METHOD_4 ( )
call super METHOD_1 ( ) ;
_CODE_ set constructor parameters
synchronized getters lists
vm null
good Map < String Object > remove suppressed warnings
s point asserting list isn t empty - check size line assert s null
a good idea perform steps client code ? implementations instance hand
I d achieve intended - Integer immutable VAR_3 + + replace passed effect function 0
VAR_3 passed I feel VAR_2 passed arg
lock georep session case else case lock cluster level expected behavior
set done line 115
meanconfig = ? : )
user_id is_filtered parameters required
add ( _CODE_ class ) class ll able declaration instead initialization a matter style wish
a parameter caching validator doesn t sense - API pass a TYPE_2 a validator practice ll validator param
replace code withreturn METHOD_2 ( METHOD_3 ( ) METHOD_1 ( ) )
please define row
drop toString ( )
instead manually invoking VAR_4 METHOD_6 ( ) _CODE_ implement _CODE_ interface implementation : * widget s DOM element set ID * execute code METHOD_6 ( need separate method ) manually invoking VAR_4 METHOD_6 ( ) wouldn t needed anymore _CODE_ _CODE_ ( ) called part METHOD_5 ( )
stack trace level message
please consider a method overloading case volume
s need result attribute : int METHOD_1 ( ) { return TYPE_1 METHOD_1 ( id ) ; }
repeated
remove TYPE_2 getInstance ( ) METHOD_2 return METHOD_3
shared ? ? need private
please remove METHOD_1
converter effect
please declaration boolean VAR_1 = true ;
View METHOD_1 ( model ) add new listeners model object responsibility presenter - example _CODE_ : void init ( final TYPE_1 model ) { super init ( model ) ; model VAR_3 ( ) METHOD_4 ( ) METHOD_5 ( ) ; } View METHOD_1 ( ) responsible populating UI model data potentially called multiple times model listener registration doesn t belong _CODE_ init ( model ) method override
please remove
VAR_2 parameter irrelevant test checks input valid prefix format
opinion test case useless - s verify valid a human eye
written - critical consider set ( ensure making a mistake adding UUID - i add copy )
final method
s / TYPE_3 VAR_4 / VAR_4 / : - )
please method private
mac domain ? changable
required checking null view
required ? bind automatically
1 error failure engine time stamp 2 failure touch base engine essentially subsequent commands fail s asking user intervention nature attempting proceed normal flow snapshot creation 3 1 2 I feel handling failure manually code atleast order close other previous window ( : snapshot create window ) opine
static modifier
vds getStatus ( ) = = TYPE_3 TYPE_4
instead METHOD_4 - ctor
assignment ? ? importance case sensitivity
private
/ s / METHOD_15 / _CODE_ ( ) i check reside METHOD_9 ( ) method
else redundant - unwrap ( project s style )
t completely remove VAR_1 ? unsued
I : 1 put a separate method 2 create a METHOD_2 network returned _CODE_ - doesn t reflect proper behavior ll return null a network shouldn t happen real - life scenarios 3 METHOD_2 _CODE_ ( a separate method ) - - sync functionality tested _CODE_ necessary test
consider explaining change commit message extract another patch
reverse order conditions importance ? { ( bridge host id ) { return bridge ; } _CODE_ = METHOD_3 ( ) ; return }
yikes new ArrayList < > ( METHOD_2 ( ) )
remove
VAR_1 considered object equality
apply default formatter
default standard curly braces
shouldn t _CODE_ set constructor
code style give formatting error line statement curly braces
prefix redundant
TYPE_3 enum - compared = =
prefix required getters
expected arg actual arg
s a matter styling written : return METHOD_2 ( ) ? TYPE_1 VAR_1 : TYPE_1 VAR_2 ;
method ( ) private
style - move @Override annotation a separate line
good check server side perform refresh specific provided
suggestion : return TYPE_1 ! VAR_2 - default return VAR_5 I s validator extended future adding additional validations easier modify
return VAR_1 ; - suffice
don t need listening role property changed event TYPE_1 METHOD_2 ( ) check isn t necessary set member ( case item wasn t form constructors _CODE_ )
I missed review - METHOD_1 ( ) called due ( ) ( other constructor ) calling METHOD_1 ( ) needed I guess
t VAR_2 hash starters
apply a formatting style eclipse
combination : METHOD_1 ( false ) ;
places call method check a duplicate key don t check
VAR_2
backported ? checkstyle complaining
please fix bracketing
variable left outuua
c tor implies entity immutable please assumption _CODE_ class introduce a c tor expect VAR_3 VAR_4 instead setters
shouldn t update VAR_1 member
a Boolean null ( don t load disk disk vm )
Boolean VAR_2 equals ( )
address assertion isn t related testing scsi reservation property
I d prefer implementation similar line 55
please call other constructor
io exception good enough ? please include exception rethrowing
done
please add static import
convention - move annotation a separate line
super called
VAR_3 null contract dao fetching collections please replace withif ( ! VAR_3 isEmpty ( ) )
TYPE_3 TYPE_1 ( ) worry some unexpected TYPE_3 toString ( ) future implementation
I feel alias pass cluster volume VAR_2 messages a string volume data { 0 } cluster { 1 } replicated volume a thought
editor bounded _CODE_ entity s visibility altered model TYPE_1 - > diskstoragetype_entitychanged ( )
I : return Arrays asList ( { TYPE_1 VAR_2 TYPE_1 VAR_3 TYPE_1 VAR_4 TYPE_1 VAR_5 } ) ; more concise doesn t create array lists
implicit
implicit
return TYPE_2 getInstance ( ) METHOD_2 ( VAR_1 ) ; host needed
synchronized
t concurrent hash map instead synchronized
isn t empty diamond ? Map < String TYPE_1 > map = new HashMap < > ( ) ;
won t args ? TYPE_3 METHOD_3 ( command = sso - token - validate String format ( sso_token = %s VAR_1 ) ; : TYPE_3 METHOD_3 ( req STRING_1 VAR_1 ) ;
IMO more readable : private boolean METHOD_1 ( String obj String VAR_1 boolean VAR_2 ) { ( VAR_2 ) { return VAR_3 containsKey ( obj + STRING_1 + VAR_1 ) ; } return false ; }
1 method public ? isn t class 2 guaranteed time method called context VAR_3 find some CDI equivalent spring order CDI bean dependent _CODE_
status TYPE_4 definition null - please remove redundant check
shouldn t return super METHOD_1 ( )
instead 3 lines ? return METHOD_2 ( TYPE_4 VAR_7 Arrays asList ( VAR_1 ) )
calling unlock done METHOD_2 ( ) METHOD_7 ( ) ;
please rename - host isn t neccessarily spm
don t care order remove operations - a HashSet
3 6 0 VAR_4 case METHOD_2 host
log doesn t add info log s unneeded s clear log TYPE_3 failed
thanks please replace order - METHOD_5 ( ) VAR_2 update call s a failure calls changes won t reverted
_CODE_ append ( final String final Map < > ) please replace append ( STRING_2 VAR_3 ) ;
method parameters generic messages means var - action - xandvar - type - yand called automatically _CODE_ need call againthe specific failure messages added _CODE_ _CODE_ : ( _CODE_ ) { result = _CODE_ ( msg ) ; } ( a note - quick - return _CODE_ means issue return method more readable ( need ti check result complicated - else a a short )
i d add assertNotNull ( entry ) ; a proper assumption prior validating entry data
I pretty convention @Override method declaration
needed
constructor work VAR_4
need TYPE_2 s a METHOD_3 ( String guid ) method ancestor class
init false I line 442 _CODE_ _CODE_ doesn t
_CODE_ message custom required
doesn t need public protected
please put @Override a separate line
please put @Override a separate line
assumption VAR_2 null replace entire : ( VAR_2 isEmpty ( ) ) { return null ; } else { return VAR_2 ( 0 ) ; }
1 I don t needed check VM null - locked remove it2 important status ? powering -
call METHOD_4 ( null ) whithout explicit reference outer
I don t change related elapsed - time change needed
needed ( null won t )
_CODE_ parameter custom variable required
assumes collections type safe side surround collection ( e g new ArrayList < > )
List < TYPE_1 >
please static import TYPE_2
need ? planning add column _CODE_
change protected
need final
problems ve other properties _CODE_ converstion Integer int _CODE_ resulting I s return type int return null please fix I ll merge
simply VAR_2 getValue ( ) METHOD_2 ( true )
s / / id
s / getValue / getId
please compare _CODE_ fields explicitly
part : new Guid ( getParameters ( ) METHOD_3 ( ) METHOD_5 ( ) toString ( ) ) replaced : getParameters ( ) METHOD_3 ( ) METHOD_5 ( )
return type TYPE_1 avoid casting method called
need variable return returned call METHOD_3
* shuoldn t call super ? * worth adding some log
I mark final safe - final methods ctor override foolish
compute time - stamp a lot more efficient System currentTimeMillis ( )
add method : public String _CODE_ ( ) audit log purposes
recursive
cleaner store string a simple - stupid POJO optional logic s
project s conventions I d drop
needs hidden
null check done line 274
I assignment VAR_3 base class ? doesn t
equals 1 ? editing multiple VAR_1 allowed
1 need changed a new master config added
won t return true null ? return object ? similar findbugs issue host patch
followup required
super ( ) spared
need compare true : ( VAR_1 && VAR_2 = = null ) ;
shouldnt _CODE_ _CODE_ ( )
need migrate _CODE_ host operational gluster ? worth call : _CODE_ ( _CODE_ _CODE_ )
more standard compare enums = = ! = equals - behaves
alternatively a bit shorter : ( VAR_1 ! = null ) { VAR_2 set ( 1 VAR_1 ) ; } VAR_4 = VAR_2 ( 1 ) ;
please add - NLS : - )
needed
String valueOf ( str )
exception attempt catch ? java doc exceptions method
TYPE_3 issues network connection please consider reconnect logic
create TYPE_3 time want fire event ? please instance variable class
need VAR_3 log error please call
Map static single instance _CODE_ pass call instance methods
lack consistency naming please fix
METHOD_3 ( METHOD_2 ( message id ) ) ;
errata : I beg pardon ; declarative programming phrase I meant imperative programming
albeit related patch - shouldn t called explicitly getter
I guess need thread safety wouldn t simpler eagerly set VAR_1 ? _CODE_ a singleton a
typically write annotations separate line
please static import
logger debug trace
debug / trace
debug / trace / remove
debug / trace / remove
debug / trace / remove
debug / trace / remove
I guessing VAR_4 else ? especially VAR_4 defined
debug / trace / remove
pass VAR_1 METHOD_2 ( ) called method handling null pool id please change rebase patch other good
_CODE_
VAR_1 null ? ( check line 112 implies )
consider rephrasing return ! ( condition ) return ( cond1 && cond2 && )
error line 179 shown simply replace line 221 - 226 return VAR_3 METHOD_4 ;
please consistent _CODE_ default case fallthrough TYPE_3
view display model data shouldn t logic showing data doesn t represent model values root problem resides - TYPE_1 public TYPE_1 ( network network ) - > ( network _CODE_ ( ) = = null ) - > _CODE_ ( ) _CODE_ ( new _CODE_ ( / * METHOD_2 * / ! network _CODE_ ( ) ) ) ; means case detached network required true default ( case internal network ) changed false ( matter network internal external )
empty return isn t needed
static - please fix rebase
assumes json helper parses values strings s play safe toString ( ) instead a cast
VAR_2 isEmpty instead
return METHOD_1 ( VAR_2 METHOD_4 ( VAR_1 ) ) && METHOD_1 ( VAR_2 METHOD_6 ( METHOD_7 ( ) ) ) ;
a bit clunk - call ( )
static fields TYPE_2 more related real scenario testing
chance approach
extract method primary address lines shorter
need check METHOD_5 null - done _CODE_
pls formatter
formatter
change modifier ? want change list _CODE_ isn t enough - _CODE_ ( ) _CODE_ ( _CODE_ )
a more defensive put call super ( ) call want treat _CODE_ ancestor ( )
code valid - protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { return VAR_1 getId ( ) = = null ; }
I d previous patch
METHOD_3 ( ) METHOD_4 ( ! METHOD_2 ( ) ) ;
METHOD_2 interrested host VAR_5 method static — s easy ugly CDI move method class please notice class requires VAR_5 s usage fake change simplify method heal TYPE_3 simplify class constructor descendants
need check METHOD_2 ( ) METHOD_3 ( )
please inline need VAR_6 variable
simply call other constructor : ( Integer VAR_2 Integer VAR_3 ) ;
line redundant call METHOD_13
consider syntax : return METHOD_2 ( ) = = null ? null : METHOD_2 ( ) METHOD_1 ( )
initialize VAR_4 status i e : Object VAR_4 = METHOD_3 ( ) ; check : ( VAR_4 = = TYPE_3 && VAR_3 ! = null ) { VAR_4 = VAR_3 ; } save else part BTW call METHOD_4 ( ) expensive want save validating METHOD_3 ( ) TYPE_3 : Object VAR_4 = METHOD_3 ( ) ; ( VAR_4 = = TYPE_3 ) { _CODE_ VAR_3 = _CODE_ ( ) ; ( VAR_3 ! = null ) { VAR_4 = VAR_3 ; } } _CODE_
METHOD_2 introduced java 8 - class compiled gwt supports 1 7 implement behavior
METHOD_3 invokes a chain queries final initiates class models add query chain ( ) query parallel chain chance chain finished query NPE models initialization assumes _CODE_ null
please inline ( I r e METHOD_2 ( ) )
reorder methods ? 1 harder review patch2 methods interesting _CODE_ interesting methods class _CODE_
sed s / = = VAR_1 ? true : false / = = VAR_1 / ( redundant inline )
public
please check usages method class please private
please fix
removal static patch fail compilation
done mapper don t need addition don t need support policy attribute adding scheduling policies changing policy a cluster
need method unit tests default ( package ) visibility instead public : boolean METHOD_1 ( ) { }
I find more readable : ( VAR_1 ! = null ) { return VAR_1 ; } ( VAR_2 ! = null ) { return VAR_2 ; } return VAR_3 ; please consider
METHOD_1 ( ) _CODE_ ( please notice a null check - getParameters ( ) METHOD_2 ( ) = = null please add )
mandatory ? names cached calling _CODE_ invoked _CODE_ s execute flow ( execute - > _CODE_ )
I guess forgot VAR_1 prefix
missing { }
good - s I add a field _CODE_ I ll need classes inherit add new field METHOD_1
please ( expected = TYPE_2 class ) instead { } catch { }
please rename vm
consider ternary instead
VAR_5 completely redundant
error prone : schedule start process line executed ll face NPE line 82 please METHOD_1 VAR_7 c tor declared ( line 52 )
shouldn t - ( index + 1 ) % VAR_4
TYPE_1 class implements correctly equals method : return TYPE_2 ( type getName ( ) ) ;
need temp variable ? TYPE_3 execute ( ( ) - > { METHOD_2 ( ) ; METHOD_3 ( VAR_2 ) ; } ) ;
shouldn t push previous ? I don t a point setting text empty string visible
TYPE_1 toString ( METHOD_1 ( ) ) TYPE_1 toString ( METHOD_2 ( ) ) behavior
I drop false default
VAR_1 isEmpty ( ) loop body run check redundant
please configure IDE brackets equals methods statements convention present
package private
i don t advantage initializing builder empty string affect default c tor instead
I d inline a single statement predicate
VAR_2 null - cluster ( happen ) 3 0 returned _CODE_ 124 - 126 redundant - removed
please add public prefix
members static methods - data doesn t change test executed read
related
please replace java8 stream filter forEach ( )
s need variable broad scope want define define variable
please _CODE_
TYPE_1 s custom compatibility version set cluster s compatibility version means don t need display warning changed TYPE_1
brackets left hand - > operator redundant ( frankly a bit confusing ) please remove
method return interfaces empty bond remove negation
pool open entire idea
refer VAR_2 please consistent
move METHOD_2 method cache method called chance falling null cache
I missed : - (
a transaction started calls METHOD_3 ( ) sense move transaction method ( unneeded avoid creating transaction ) callers doesn t repeat remember instead adding call
move line 439 - 441 line 435 - performance more clear case don t need cluster version
done
don t fallback default locale initialized constructor don t translation client locale ? wouldn t forced nasty split / VAR_5 code
hmm idea : wouldn t faster load messages existing locales startup ( IMO don t messages / locales memory issue ) calling synchronized method translated message user request
check null
reuse existing constructors ? public TYPE_2 ( TYPE_1 VAR_2 Guid VAR_3 ) { ( VAR_2 ) ; VAR_3 = VAR_3 ; }
VAR_5 = ( Map < String Object > ) VAR_3 ;
existing network attachments ( returned db ) id set
lines 25 - 29 simplified : return ! VAR_6 METHOD_4 ( VAR_1 TYPE_3 VAR_8 ) isEmpty ( ) ;
unneeded cast
unneeded cast
done
isn t METHOD_2 condition enough
need a method - fact plugin supported browser independent VAR_1 vdc_options VAR_1 work
please inline VAR_3
fail input isn t a list strings type properties String [ ]
tests I tests JSON checking result correct cursor positioned correctly
simply call METHOD_8 instead
need ? t access extension configuration TYPE_1 instance _CODE_ ( ) ( CONFIGURATION ) getProperty ( DEFAULT_PROFILE )
TYPE_1 s memory size 200MB buffer converted bytes
correct unusual please change : ( ! _CODE_ ) { VAR_1 = false ; }
I find similar ask null architecture - scenario #101 ? don t want prevent validate method instead throwing exception
need explicitly initialize null
a mistake
protected
java accepted check empty : ! VAR_2 METHOD_3 ( ) isEmpty ( )
hard read avoid ternary operator
return ( ! getParameters ( ) METHOD_7 ( ) || METHOD_5 ( VAR_2 METHOD_8 ( ) ) ) && ( METHOD_3 ( ) METHOD_4 ( ) || METHOD_5 ( VAR_2 METHOD_6 ( ) ) ) ;
null ( theory ) inited a callback please init handle - VAR_3 ( VAR_2 getId ( ) ) return null some rare cases please handle case
replacing switch - case statement
need
change METHOD_2 ( )
please switch positive
line unneeded
VAR_1 null
control clients call class I don t validation necessary check null validate client calls helper
care LOC metric care expressions side effect ideally test modify needed please update result variable proceed testing
case VAR_1 null NPE
please protected
please private
s positive branch
shouldn t part ( METHOD_3 ( ) METHOD_5 ( ) = = null && ! VAR_1 equals ( METHOD_3 ( ) METHOD_6 ( ) ) )
consider a switch statement
don t need null pretty
Arrays stream ( VAR_4 ) instead creating a list intermediate step
gonna rebase patch please consider dropping prefixes getters
I d a test I d fetch TYPE_1 a floating disk assert returns null
create 0 connections didn t <
create 4 connections 3 init index 1 <
command currently transactional ( transactional ? ) I guess set transactional compensation : 1 METHOD_7 need called actual change2 need add _CODE_ annotation3 need add empty constructor
a bit unusual init _CODE_ flow moving init method ? ( need check _CODE_ )
don t qualify TYPE_1 : return = = VAR_2 || = = VAR_3
changing isEmpty
NPE line 340 return null blow
done
private static ? good ? don t static ( utility methods Math class ) static factories
aboutreturn VAR_4 || ( VAR_2 && VAR_8 ) ;
I remember correctly call build isn t required options method accepts object a builder a builder call build method internally other calls build
return getParameters ( ) METHOD_2 ( ) ? new TYPE_2 ( ) : new TYPE_3 ( ) ;
I call super METHOD_1 click super class
making a bit more declarative : ( VAR_5 METHOD_7 ( ) METHOD_8 ( ) ) { METHOD_2 ( ) METHOD_6 ( ) forEach ( VAR_7 - > VAR_7 METHOD_9 ( VAR_7 METHOD_10 ( ) ) ) ; }
stream API ? cleaner
space
purpose naming new avoid remove
drop thenew ArrayList < > ( ) surroundings s sufficient return VAR_6
please add a space curly bracket
shouldn t fields covered autogenerated VAR_4 METHOD_1 ( ) method ? ( fields implement _CODE_ interface )
question : shouldn t VAR_1 METHOD_1 ( ) included generated VAR_2 METHOD_1 ( )
question
public ? planning class
public ? planning class
isn t protected master patch
I guess _CODE_ null s a failure reporting
private
I agree method called need remove controllers
_CODE_ id pass drop class
consider making OPTINAL a
String Object
id part equals
please remove
please prefered declarative approach - attribute * ui xml
? set tests changed I line removed
redundant - please remove
static
huh
inline - return METHOD_2 ( ) ? new : null ;
pls avoid magic numbers
won t pass replica count a parameter METHOD_1 remove stored procedure instead
s constructor private protected
= ;
please export check a method s long repeating times
merging condition line 505
please added method METHOD_4 ( )
rely _CODE_ toString
mind inverting condition simplify skip negation ? ( METHOD_2 ( ) ) { } else { }
needed statement handles DB care status changed instance
missing : ( = = obj ) { return true ; }
needed
instead TYPE_1 pls annotation intend TYPE_5 declare TYPE_1 ( TYPE_5 class ) ;
( feel free ignore ) scope patch please feel free ignore change : Boolean - > boolean
prefet return method ? line 134 - 135 : return METHOD_1 ( ) ;
VAR_2 null problems METHOD_5 handle correctly safer check ( case original code )
private able initialize class ? sense regular initialization injecting members
new allowed I default commands allowed remove
need part
missing space
don t want handle null VAR_1 ? ( VAR_1 ! = null ) { element VAR_2 ( VAR_1 ) ; } else { element VAR_2 ( ) ; }
tasks - - > disks need seal
check necessary
another override VAR_1 TYPE_2 - op ( allow rid instanceof check )
please wait s done I don t remove trycatch
please move check METHOD_5 ( ) validates domain exists ll need move METHOD_3 ( ) a separate patch
extract field ; need N creations lets sorting collection
I don t s place I options : 1 validate custom - compatibility version _CODE_ instead 2 validate point set incorrect rely validation te validate method I #2 - s point validating put another ( incorrect - I asked a VM CCV 5 7 I expect compatibility error s invalid )
consider change toreturn METHOD_4 ( VAR_4 METHOD_5 ( ) ) && METHOD_4 ( VAR_4 METHOD_6 ( ) )
protected
TYPE_1 enough docatch ( Exception ) { / / ignore } I TYPE_1
I d suggest explicit / else : ( VAR_2 ! = null ) { VAR_2 = VAR_2 ; } else { VAR_2 = new TYPE_1 ( ) ; VAR_2 METHOD_1 ( false ) ; }
needed ? redundant i91dbedee38d893302f1006c9ce1e58d146ce7cce
please management network highest number displayed
I agree I m leaving - patch stuff : 1 worth note a comment2 I formatter remove spaces case keyword ( switch ) please check
reduced a single boolean expression more more clear understand : return TYPE_4 METHOD_3 ( VAR_2 ) || METHOD_4 ( VAR_3 TYPE_6 TYPE_7 ( ) ) ;
hmm I locally s general _CODE_ ( null ) hide dialog ( bound model s window property ) dialog s model ( e g TYPE_1 ) anymore s cleaned ( a model cleaned handlers / listeners removed references shared objects nullified needed )
instead VAR_2 pass null
I remove removed line 87
ipv4 code - _CODE_ = = null ) ? _CODE_ : _CODE_ ; didn t adopted code
switch / case
pair Pair < Boolean Guid > don t need entire domain object
I underlying _CODE_ reader a VAR_4 method receives namespace attribute pass null attribute return attribute
I understand correctly purpose patch fix a specific problem - failure migration _CODE_ failure a lock enough a waiting lock _CODE_ calling refresh instead locking host migration period pass _CODE_ _CODE_ ( scope execution ) _CODE_ ( true ) _CODE_ parameters pass _CODE_ ( _CODE_ pass _CODE_ )
redundant - false explicitly set true
lambda lambda point view readable
unneeded brackets
^ lines aren t needed
moving previous line I solve tool - tip issue
a code smell path super instead call ( VAR_2 null )
2 2 2 rewritten : case STRING_1 : case STRING_2 : case STRING_3 : return 2 ; default : return - 1 ;
shouldn t = = null
method useless send a patch remove code needs uuid simply TYPE_1 class
replicates logic production code t create _CODE_ TYPE_1 symetrically
please note doesn t handle templates _CODE_ ( original bug opened handle templates ) - worth adding a remark BZ won t remove spicevmc channels templates
: METHOD_3
method reference
private
private
private
a good idea making TYPE_1 final I s worth small cleanup a separate patch
throw RuntimeException static block
protected ? subclass ? private else required more accessible future other harder
related
method invocation line more readable
move debug patch ( remove ) I INFO level
t avoid setting parent command / parent parameters ? preferred delete lines 34 - 35
new command allowed need line
I ve other list models _CODE_ ( null ) need
inline local variable
private
done
doesn t sense validation update case
wouldn t more readable TYPE_2 _CODE_ ( ) instead code
redundant mockito 2
redundant mockito 2
_CODE_ ? returning Boolean object attribute defined primitive boolean type
pick : need call super [ 1 ] s effectively a - op call simply skip line [ 1 ] _CODE_ ( View extended some other View override METHOD_1 method super called case )
don t raw types - new Pair < > ( vm VAR_4 )
equals TYPE_2 = = TYPE_3
calling super ? intentional don t call ? -
enable _CODE_
validation
need = = true
executor class s field instead passing part call object
I m work import storage domain process import done host calling _CODE_ done host
shouldn t verify mac null avoid NPE ? _CODE_ check
wouldn t a top - levelif ( VAR_2 ) guard condition instead checking loop
needed test emptiness s contained condition
pick : typecast inlined avoiding explicit VAR_2 variable declaration s needed
pick : _CODE_ java typecast inlined
I remove boolean put _CODE_ ( ) need call
huh
validation _CODE_ command move disks _CODE_ ( METHOD_12 verify ) _CODE_ command responsible move disks a running VM
appears change reverted
needs called properly done
I 2 _CODE_ takes tab takes TYPE_2 convert TYPE_2 a tab passing Object wrong
I change ( VAR_2 ! = null && VAR_2 METHOD_3 ( ) ! = null ) more explicit
need ( ) a single parameter VAR_4 METHOD_3 ( e - > METHOD_4 ( ) ) ; work
I d lose notation shouldn t annotated s serialized
I m alright case task running simultaneously threads
map
line
VAR_3 METHOD_2 ( VAR_5 - > METHOD_3 ( VAR_5 ) ) ;
add ctor please
move METHOD_3 return TYPE_1 I explained _CODE_ extend TYPE_1 simplify a bunch stuff
call METHOD_1 ( i e line 83 ) ? conflict
please rebase patch top ? null check redundant
I doesn t more sense default TYPE_4
pick : consistency please movethis xx = xx ; declarations top actual logic METHOD_1 ( ) call
need
METHOD_3 exposed TYPE_1 interface lose METHOD_2
don t need don t provided = true
VAR_4 consistency
need filtering
I drop else
need
return METHOD_2 ( VAR_1 METHOD_3 ( ) ) ;
please remove unnecessary brackets : String VAR_3 = ( VAR_2 ! = null ) ? VAR_2 getValue ( ) : TYPE_1 METHOD_2 ( ) getValue ( ) ;
please remove unneeded parenthesis : ( VAR_9 ! = null&& VAR_9 METHOD_5 ( ) equals ( VAR_4 getId ( ) ) ) {
unnecessary : - ) ( VAR_9 ! = null&& VAR_9 METHOD_5 ( ) equals ( VAR_4 getId ( ) ) ) {
openstack metadata supported ? I m concerned a scenario customers templates installed version cloud init doesn t support
shouldn t true ? I test passes I don t understand I miss ? didn t change code default route supported VAR_4 considered sync conditions
? ctor isn t called publicly ( ? ) inlined isn t scope * * * * patch s a separate please
protected
closing files please resources : private String _CODE_ ( String filename ) { String pid ; ( _CODE_ br = new _CODE_ ( new _CODE_ ( filename ) ) ) { pid = br _CODE_ ( ) ; } catch ( IOException ) { log error ( error reading file { } : { } filename getMessage ( ) ) ; log debug ( Exception ) ; pid = null ; } return pid ; }
public
A renderer return some meaningful text VAR_1 null return _CODE_ _CODE_ ( ) empty string depending UI expectations a class covers : _CODE_ _CODE_ extends _CODE_ { public _CODE_ ( ) { super ( TYPE_2 METHOD_2 ( ) ) ; } }
VAR_1 null case problem label null besides + 2
please Set instead concrete implementation
hoe METHOD_3 ( ) true command ended failure
UI plugin infra _CODE_ - specific need instanceof check true typecast prefer inject TYPE_1 instead _CODE_ interface
need part - _CODE_ supposed return empty map empty string METHOD_1 method won t write xml
check disk plugged
reached means ve executed VAR_1 ( VAR_4 ) times : - ) pls extract a local variable replace occurrences
check METHOD_3 case : VAR_1 isEmpty ( ) = = true METHOD_2 ( ) = = truewhich didn t safe mehow replacing - else statement : ( ) { return false ; } ( ) { return false ; }
redundant super ( ) called don t call other ctor explicitly
s / TYPE_2 /
call new ctr move initializations i e : public TYPE_1 ( Guid VAR_2 Guid VAR_3 Guid VAR_4 ) { ( VAR_2 VAR_3 VAR_4 null ) ; } public TYPE_1 ( Guid VAR_2 Guid VAR_3 Guid VAR_4 String VAR_5 ) { VAR_2 = VAR_2 ; VAR_3 = VAR_3 ; VAR_4 = VAR_4 ; VAR_5 = VAR_5 ; }
I process confusing VAR_4 context a solution METHOD_4 return boolean update succeeded done METHOD_6
reason t change TYPE_1 < Long > don t cast long int
appears incorporate logic _CODE_ _CODE_ ( ) finally block method : ( _CODE_ current ( ) = = null ) { { METHOD_4 ( ) METHOD_5 ( ) ; } catch ( RuntimeException e ) { _CODE_ ( e ) ; } } else { { ( ! _CODE_ && _CODE_ current ( ) getStatus ( ) = = Status STATUS_ACTIVE ) { METHOD_4 ( ) METHOD_5 ( ) ; } else { METHOD_6 ( ) ; } } catch ( _CODE_ e ) { _CODE_ ( e ) ; } }
please assertEquals
splitted lines : parameters = TYPE_2 METHOD_1 ( parameters )
comparison ! TYPE_1 equals ( VAR_2 )
removing lines ( 371 / 372 ) d work
I d print content input pass e ( exception ) a argument _CODE_ c tor call
forEach ( ) Arrays please remove stream ( )
omitted
field written read removed ( findbugs )
I removed : )
specific constructor instead invoking setter existing object ? TYPE_3 params = new TYPE_3 ( max TYPE_4 METHOD_4 ( TYPE_4 METHOD_3 ( VAR_2 VAR_4 ) ; ) ) ;
calculation wrong assign a = b b = a % b 0 a = b shouldn t : long c = b ; b = a % b ; a = c ;
making method final ? descendants override correct method ( METHOD_2 ( ) ) instead METHOD_1 ( )
change patch order execution : previously logged failure case thrown exception error triggered METHOD_2 ( vds VAR_1 ) ; patch another exception finally block exception logged d loose info origin exception thrown exception logged
don t reinvent wheel assertEquals instead
pass user_id is_filtered - example _CODE_
shouldn t max
personally I preferfor ( TYPE_6 type : TYPE_6 values ( ) ) { VAR_3 add ( type getId ( ) ) ; } I m existing loop a big deal
style : TYPE_1 : : VAR_7
required _CODE_ _CODE_
reason full class reference instead importing a class
need check null
shouldn t initialize
intended
custom compatibility level template set
entity
redundant
don t need special case
didn t plan clear entity
reverse order METHOD_7 TYPE_3 TYPE_1
METHOD_3 ( ) return null ? I : ) ( ) check METHOD_3 ( ) instead
previously didn t need
effectively limits action button priority integers want
TYPE_3 equals ( VAR_3 METHOD_2 ( ) )
coverity mad a NPE return null
VAR_1 METHOD_2 ( ) = = null ll fail NPE _CODE_
remove vm replaced : ( VAR_4 remove ( VAR_1 ) && log VAR_3 ( ) )
revert operands condition remove null check : return TYPE_2 TYPE_3 equals ( METHOD_2 ( ) ) && VAR_1 ( STRING_1 ) ;
s reason change method
_CODE_
please condition : ( METHOD_2 ( ) ! = null && METHOD_2 ( ) getStatus ( ) = = TYPE_1 TYPE_2 && METHOD_3 ( ) METHOD_4 ( ) )
I a proper place put line 63 part METHOD_7 METHOD_1 method clean
don t add VAR_1 TYPE_1
shorten a single line : return VAR_1 = = TYPE_1 VAR_3 || VAR_1 = = TYPE_1 METHOD_2 ( VAR_2 ) ; a big deal side
please merge lines
redundant
needed part constructor
please replace line #481 line #482
reason replace TYPE_1 values ( )
aren t changing behavior existing method ? I feel I m missing
casting int redundant
left int
METHOD_1 takes problematic network _CODE_ won t work METHOD_3 return a nework _CODE_ I don t a running env code a bug print network parts message isn t
need check VAR_2 null adding map
duplicating code a checking STRING_1 equals ( ) multiple times consecutive lines other cases additional method ( public boolean _CODE_ ( ) ) simply : boolean _CODE_ = VAR_2 METHOD_5 ( ) ! = null ; return _CODE_ ? false : ! STRING_1 equals ( VAR_4 ) || ( VAR_3 = = TYPE_4 VAR_6 && ) keeping track
please change 10
public
please add { } fails checkstyle validation
storage domain ID t VAR_3 ( VAR_1 ) exists
empty string
want correlate cinder managed block storage
please add { } fails checkstyle validation
needed please leave method empty
skip final
I understand empty string instead null null required mind
t remove variable completely
please upper case
inject dao s class nice nulls
variable required
private
private
cast needed ? I s casting type
static
s forEach don t call function time
shouldn t check METHOD_3 ( ) VAR_2 ( )
please change statement early return form s standard code s objection I currently fix I ll able merge code branching 4 3
similar _CODE_ void METHOD_1 ( ) { METHOD_6 ( STRING_1 backend _CODE_ ( ) _CODE_ ( _CODE_ ( ) _CODE_ ( ) ) ) ; VAR_7 log ( TYPE_2 VAR_9 ) ; }
compatible
simply return variable needed
_CODE_ NEXT_RUN configuration _CODE_ ( ) load disks network interfaces pass additional parameter flag load information
considerthis ( VAR_2 1 1 ) ; nicer
null : List < TYPE_1 > result = VAR_1 METHOD_2 ( null ) ;
I more easy read common code structure : switch ( METHOD_2 ( ) ) { case TYPE_2 : return METHOD_3 ( )
safe a reference comparison instead i e equals _CODE_
previously condition : METHOD_2 ( ) METHOD_3 ( ) = = TYPE_1 VAR_2 _CODE_ ( ) METHOD_3 ( ) = = METHOD_4 ( ) METHOD_3 ( )
needed
called init method needed
private
I else totally removing else more readable 1 indent
1 ) move - arg C tor C tor 2 ) nice call 3 - arg C tor : ( Guid TYPE_1 Guid TYPE_1 Guid TYPE_1 ) ;
I consider changing private
convert early return log a bit clearer
private
private
consider changing command getName ( ) equals ( STRING_1 ) fit else
I section : ! METHOD_6 ( VAR_1 )
remove ( API longer accesses configuration need mock ) instead please change _CODE_ ( ) similar tests expect new parameters - class added
move call calling method _CODE_ : : _CODE_ ? strange a method called calls callback floppy supported
default need set
done line 816 need
updating QCOW other parameters call
fail empty collection
doesn t condition arbiter volume version 4 1 ? case removing version check changes logic other versions arbiter volume removed completely
consider ? : syntax - return ? x : y
consider new java 11 List ( )
I safe java > 9 Map ( key1 value1 key2 value2 ) ;
line needed _CODE_ automatically replaced calling METHOD_3 ( )
please move call METHOD_12 ( ) method method multiple similar statements check VM state add audit log line
public required vdsbroker
public required
public required
s shorter : VAR_3 METHOD_2 ( VAR_2 getType = = || ) ;
please move validate method method handle size updating
suggest surround parsing - catch line a potential throw
please change incrementing index ( VAR_1 + + ) instead ( + + VAR_1 ) 3 lines ll need click tab field
METHOD_4 ( false ) raise error
I m wrong method return void other _CODE_ methods return
smells a bug equals
check VDS collection guidsprobably vds getId ( )
simplified : return ! VAR_5 getId ( ) equals ( VAR_6 getId ( ) ) || TYPE_2 VAR_8 = = VAR_6 METHOD_4 ( ) ;
replaced : return VAR_5 getId ( ) equals ( VAR_6 getId ( ) ) ? TYPE_2 VAR_8 = = VAR_6 METHOD_4 ( ) : true ; a a matter style
fail null pointer exception hide errors reading response log 2 errorsfor issue ( e g print stack trace reading fails return empty string failwhen parsing json ) lets code raise IOException handle caller - wrap callsin / catch block
client provide reliable persistent connection I instancein command create a new client request instead adding more state thecommand avoid need create client lazily
isn t implementing METHOD_1 _CODE_ interface ? s return type changed
case null
pls verify VAR_1 null
pls check VAR_1 isn t null
IMHO inserted METHOD_5 ( ) METHOD_7 ( TYPE_2 VAR_6 ) ; instead return false ; METHOD_6 ( TYPE_1 VAR_4 ) ; instead return true ;
s invalid isn t ? s meaning VAR_17 cluster set autodetect = = null concrete values allowed
? case VAR_6
removed
good other places set null I fix comparison
a URL ( e g file : / / / path / / image nbd : unix : / path / / socket : exportname = vda ) String url =
worth usage _CODE_ ( package ) remove public
static avoid avoid redundant object creation _CODE_
! VAR_1 isEmpty ( )
a List specific objects List
condition inverted wasn t
need ( ! METHOD_1 ( VAR_5 METHOD_5 ( ) ) { }
please handle VAR_3 null
existing rows null _CODE_
IIRC VAR_1 returns String [ 0 ] elements null
hmm caller invoking a full TYPE_3 object hand pass time database column initialize field assume null
style - : code shorter remove VAR_1 variable : VAR_2 put ( listener new TYPE_3 ( listener user ) ) ;
return null project suddenly disappear I guard testing null skipping rest method : ( VAR_2 = = null ) { return false ; }
protected exists JSON serialization library
constructor exists JSON encoding recursively process populate fields s need call ( ) accept default initialization false / null fields JSON decoder finish building object
drop - else block VAR_3 simplified val = Math max ( ) expression
need selection dynamically based current user batch jobs coming interface fetch degraded service ssh : / /
completeness invert / z
style - : spaces operators +
please don t hold database connection 12 hours METHOD_1 close run method time execute borrowed a small pool keeping tied hours isn t friendly other threads JVM
please don t initialize a local variable null instead leave uninitialized compiler prove correctly populated hiding a bug VAR_1 null database threw exception crash JSON encoder _CODE_ database fails return a default preference logging warning
update ( ) method ensuring save preferences invoked key binding enter setup constructor
I t reproduce failure update commit message explain condition don t a panel
doesn t public default package access thee cache impl package
doesn t public default package access thee cache impl package
remove TYPE_3 private hacked class
VAR_2 doesn t res result r
doesn t need public
doesn t need public
style - : put curly braces statement
doesn t need public
doesn t need public
style - : space I write code more cleanly : ( VAR_2 = = null || VAR_2 = = VAR_1 METHOD_3 ( ) ) { map put ( VAR_1 getId ( ) info ) ; }
compare TYPE_2 ids
getId ( ) instead
I confusing put instead METHOD_7 ( RPC call ) ends another trigger create ( keyboard ) missed duplicated
[ optional ] return project _CODE_
easier read : ( VAR_2 = = null ) VAR_2 = ;
need METHOD_4 ( ) ;
passing a null allowed a clear box
done line 247 avoiding need else
statement inlined
need initialize variable branch directions assign variable discard HashSet
VAR_2 clear ( )
pref : unneeded else
pref : eliminate return boolean evaluation
declare package access
I m accuracy necessary web UI side need user owner a local VAR_1 order edit
subclasses allowed override method
line unused
public
public
public
VAR_1 list - empty copy elements new VAR_1 list simply discard leak
VAR_1
wrong place : ) unordered retrieval line 216
style : brackets single statement ifs
I don t need ! VAR_1 METHOD_2 ( STRING_2 ) I a hack bug eclipse create change ids groupids aren t I fine hack ( wanna check shawn )
VAR_1 = VAR_1 * INT_1 + ( VAR_5 ? 1 : 0 )
autoboxed dont need call constructor explicitly
style - : wrap block curly braces
public package visible
future calls _CODE_ unexpectedly NPE handle _CODE_ fail harder static block a thrown runtime exception error prevent class initializing server running
need replacement STRING_1 STRING_2
simplify : TYPE_1 TYPE_3 VAR_5 = group VAR_4 ( ) drop _CODE_
2 TimeUnit HOURS more readable tied a listener sense expire default ? other caches don t expire days rely invalidation messages
new line appended VAR_3 empty VAR_1
consider making protected plugins subclass want
method isn t necessary super implementation
exception thrown constructor
need check VAR_2 instanceof TYPE_3
done
multimap returns empty collection key simplify code removing ! = null test
shorter inline variable scope : - )
VAR_1 = VAR_1 * INT_1 + ( VAR_4 ? 1 : 0 )
&& VAR_4 = = VAR_1 VAR_4
necessary remove
show problem user give calling code ( i e : _CODE_ ) a chance detect interrupted rethrowing returning a boolean success copying error _CODE_ option ? - - - - - - - - - - - - - : Double semi - colon
TYPE_3 TYPE_4 VAR_5 ( underscore ) line 47 VAR_8 ( underscore ) I a preference I d prefer stay consistent other
currying parameter unusual currying other parameters typically hints wrong parameter order other method sense reverse order parameters constructor line 43
reading a single field need METHOD_2
VAR_1 null ? checked _CODE_ ( TYPE_1 )
done
unnecessary TYPE_3 world start stop
package private access acceptable class private
done
done added new constructors public key password public key
need @Override METHOD_2
a branch deleted VAR_3 null case TYPE_2 METHOD_2 ( ) new _CODE_
unnecessary
a single item allowed reason annotations kind drop METHOD_1 drop method altogether
id toString ( ) valid : - )
inline loop avoid METHOD_4 ( ) I don t improves readability doesn t runtime performance
IIRC METHOD_1 include query parameters quote docs returns part request s URL protocol query string line HTTP request
shouldn t necessary write bytes VAR_2
new ArrayList < TYPE_1 > ( VAR_1 length )
shouldn t return 204 content return 200 a description member PUT / groups / { id } / members returns a description new members
variable : put inline METHOD_3 ( VAR_1 )
done temporary variable ( VAR_1 ! = null && VAR_1 ! = null ) { return VAR_1 ; } return VAR_2 ;
put a local variable ? inline
unnecessary delta
remove
a VAR_1 VAR_2 doesn t a vote I VAR_3 simply set method
type a variable pointless
NPE check _CODE_ ( ) supplied id ! = null
clearer returned false checked cancel failed call prevent reschedule I don t check cancelled success case anymore simplifying a bit potentially
wrong place perform parsing I belongs dispatcher change ( line 459 ) _CODE_ _CODE_ ( line 158 )
I false default false existing users defaulting true new users default consistent users
bad double checked locking idiom TYPE_1 VAR_1 = VAR_1 ; ( VAR_1 = = null ) { synchronized ( ) { VAR_1 = VAR_1 ; / / missedif ( VAR_1 = = null ) { VAR_1 = METHOD_2 ( ) ; VAR_1 = VAR_1 ; } } }
early return : ( VAR_3 equals ( ) { return - 1 ; } else ( ) { return 0 ; } return VAR_1 METHOD_2 ( ) ; a lines shorter matches other cases gerrit style works
TYPE_3 prefix unnecessary class
host especially extracted a TYPE_1 object a trailing slash
move constructor TYPE_1 reused _CODE_
TYPE_3 ? _CODE_ released r close ( ) I don t { } finally block needed
a loop : int count = VAR_1 METHOD_2 ( ) ; return count > 0 && VAR_1 METHOD_3 ( count - 1 ) = = ;
don t return null throw instead
write id equals ( STRING_1 )
enough coffee world convince delta necessary
sort binding _CODE_ line 244 current master
return method
leave checks switch assignment : path = path ! = null ? METHOD_2 ( path ) : null ;
( ! startsWith ( TYPE_1 VAR_2 ) )
id ( )
write close ( ) ;
static
method return void
whoops careless yeah I remove link s complicating a lot
add VAR_4 calling table VAR_3 ( )
straight : VAR_5 = Arrays asList ( config VAR_6 ( STRING_7 null STRING_8 ) ;
sense continue else branch TYPE_4 TYPE_5 equals ( VAR_1 ) VAR_2 false ? I code : } else ( TYPE_4 TYPE_5 equals ( VAR_1 ) ) { return VAR_2 ; } else {
VAR_2 ! = null VAR_3 = = null store VAR_2 VAR_3
bindings
check necessary
written a loop : ( ; VAR_1 ! = null ; VAR_1 = VAR_1 METHOD_3 ( ) ) { T t = VAR_1 METHOD_2 ( VAR_2 ) ; ( t ! = null ) { return t ; } } return null ;
e getMessage ( )
shorter line
UI widgets passed init ( ) set ( ) passing init ( ) matches pattern TYPE_2 init ( ) _CODE_ gain access additional _CODE_ set ( ) controls
return void result
check
protected
VAR_1
shouldn t true ? ; - )
return ! TYPE_2 METHOD_2 ( req VAR_1 ( ) &&req VAR_1 ( ) startsWith ( VAR_2 ) ;
/ METHOD_1 another API commonly called input
unnecessary cast
unnecessary cast
default access
return c ! = null && c VAR_3 ( ) ;
longer needs public _CODE_
space (
remove line TYPE_7 needed more deleted files _CODE_ java removed
I preferif ( o instanceof TYPE_1 ) { TYPE_1 VAR_1 = ( TYPE_1 ) o ; } return false ;
needed ? subclassing a TYPE_1 method body lines 30 - 32
unnecessary rewalking a previously walked graph
changing : VAR_1 METHOD_2 ( STRING_1 STRING_3 STRING_4 false ) ; tests fail
remove lines don t ned METHOD_4 ( ) method standard
? : foo METHOD_1 updated > foo
needed missed previous review
catch part innter block need nest blocks
I method called line 244 return checked return method return void
variable needed VAR_1 direct
I stops admins installing example / code / review / server
URL access web application unsafe hosed IIRC string gerrit config admin p0wn3d gerrit config other problems
reason TYPE_2 METHOD_1 handle null cases parameters I VAR_1 canno null : VAR_1 equals ( o VAR_1 ) good enough
I don t want return null METHOD_5 ( ) shouldn t hard modify TYPE_3 _CODE_ handle a null revision
apparently method returns false wait time exceeded implementation buggy completed future lied caller indexing done new implementation avoids caller potentially wait 2x VAR_1 METHOD_2 returns false method throw TYPE_2
METHOD_3 block method METHOD_1 called future concurrent set set gen future remove matter state future
redundant auto - boxing work fine IIRC _CODE_ don t warn auto - boxing gerrit
public ? gerrit conversion mark injected constructors package provided
useful error message fails
obvious argument s copy identity ? pass a _CODE_ instead
class TYPE_3 class : getClass ( ) METHOD_1 ( VAR_3 )
need variable inline return statement
s ll want event METHOD_2 pass e null
private
I tests similar call grant ( ) ? switch convenience method
wrap line
exhaust entropy local server login stalls general denial service enough entropy builds start another RNG create TYPE_1 server startup retain long term a singleton helps avoid depleting local high quality entropy login request early early days gerrit issues SSH users couldn t login hours days SSH server depleting entropy connection
METHOD_4 method
static ( )
I guess work queue listens METHOD_1 event cancels tasks verified
+ 1 clarify docs
eclipse warning argument r unused I guess changed r
temp var unneeded return direct
static order public methods
done
defensive copy instead
leave private
left diagnostic output
new ArrayList < > ( )
necessary
private _CODE_ static qualifier method order class wrong private methods expected public dave clarified order methods change [ 1 ] i place helper method methods line 146 ps [ 1 ]
METHOD_3 ( ) returns list : VAR_1 = VAR_2 METHOD_3 ( db METHOD_4 ( ) ) ;
removal slash effect dealt
private static
Optional : extract a var don t retrieve : line 90
need builder ( ) done
optional : inlined line
I don t final place anymore
happen ? care
needed
bug : format string %s needs argument 1 0 provided
VAR_3 + 1 depending side effect
_CODE_ < ? extends Set < String > >
event java7 : new HashSet < > ( ) ;
string retrieved VAR_2 #test1 #test2 remove VAR_1 VAR_1 check _CODE_ instead
public static _CODE_ public irrelevant visible class package access skip public keyword
done
aren t static strings held reused ? shouldn t charge weight merge strategy string actual memory entry pointer sized string length
unneeded change _CODE_ package
e = = null
inline method private
done
thrown
METHOD_1 ( VAR_2 )
optional s default java doesn t dumb treat leading 0s octal
return unexpected method doesn t render _CODE_ reason instantiate TYPE_1 return VAR_2
I prefer written : CHAR_8 < = VAR_1 && VAR_1 < = char_9as closer mathematical notation : CHAR_8 < = VAR_1 < = char_9looking codebase places pattern 2 lines
( ! ( req VAR_1 ( ) equals ( STRING_1 ) || req VAR_1 ( ) equals ( STRING_2 ) ) )
rename path consistent parameter METHOD_6
I wrap user code : ( VAR_1 ) { return VAR_3 ( ) } return Integer VAR_2 ;
toggling edit mode file table doesn t imply a change edit : post reviews
exceptions unsed Exception real code unit tests
_CODE_ returning a _CODE_ ? actions revision sounds a Map < String _CODE_ >
local variable necessary instead : return true ;
alphabetize
VAR_2 null NPE METHOD_4 method
method static
unnecessary lines perform a test null result
equals ( )
style - : don t call super arguments
VAR_4 redundant local variablesl necessary
more straightforward VAR_1 = = null ? ( isn t C )
style - : I I prefer defined : public TYPE_1 METHOD_1 ( String String VAR_1 ) { return METHOD_1 ( new TYPE_2 ( VAR_1 ) ) ; }
style - : don t put parens return : return new TYPE_1 ( ) ;
style : extra parentheses
style : extra parentheses
API null returned check
I willing bet a beer time meet person : ( ! VAR_1 METHOD_2 ( ) ) break ; faster a system call read directory contents operating system forbidden letting remove a directory long file / directory accomplish tasks system call METHOD_2 aborting soon doesn t work
throw IOException IllegalStateException _CODE_ ( ) ? throw type consistently
logic constructor I simplify method : public boolean METHOD_1 ( ) { return VAR_6 = = null ; }
style : braces single line
style : braces single line
style : braces single line
style : braces single line
performance - : pull VAR_1 [ VAR_2 ] a local variable evaluated
please don t move line constructor essential patch
I error statement : java lang IllegalStateException : repository _CODE_ new TYPE_3 ( repository repository ) instead ? created instance TYPE_1
style - : a static method
need call super close ( ) _CODE_ a - op method instead need close ( ) ;
a _CODE_ ( I convinced necessary scenario ) please set a description feels kind weird setting a title a dialog a method s meant creation buttons
s wrong : return message ;
style - : don t curly braces simple loops
NPE occur _CODE_ s constructors a code path VAR_3 field set null
style - : curly braces aren t necessary I m cherry - pick master a simple bug fix I don t want held DIRC version 3 code
done
prefer write : ( obj instanceof TYPE_1 ) { TYPE_1 other = ( TYPE_1 ) obj ; } return false ; null test type test time permits compare a subclass current semantics
I current state art : int hc = key VAR_1 ( ) ; hc * = 31 ; hc + = VAR_1 ( ) ; return hc ; attribute aren t multi - valued ? key s VAR_1 VAR_1 sufficient
simplified : Collections addAll ( _CODE_ VAR_1 ) ;
overflow computed int precedence + < < isn t widely prefer wrap ( ) order operations clear instead : size = ( ( long ) VAR_2 [ INT_4 ] ) + ( ( ( long ) VAR_2 [ 10 ] ) < < INT_5 ) ; FWIW else big endian ordering weird high INT_5 bits size occur array INT_5 bits
package visible
a long
style - : don t put { } a single statement
methods export HashSet exporting Set < String > instead case change internal representation else e g a _CODE_ a custom Set implementation a smaller storage easier construct fact iterate names path - order add HashSet < String > immediately follow a change fixes methods return Set < String > ( please reverse insert a new commit fixes existing methods return Set < String > change commit return Set < String > )
style - : static methods start class instance members
dropped _CODE_ call don t need local variable anymore instead return result split ( )
VAR_2 VAR_3 VAR_4 null TYPE_1 doesn t exist causing conflict NPE need similar _CODE_ : private static String ( TYPE_1 e ) { return e ! = null ? e ( ) : ; }
shouldn t public type returns isn t public
I don t need call anymore I understand code works temporary fanout VAR_1 isn t needed a tree shouldn t write
want field TYPE_1 rely toString ( )
s difference compared _CODE_ ( )
wouldn t return List < File >
need public client Iterator < note > blob attached note
style - : prefer import names short class instead
please remove brackets don t brackets single line statements
please remove brackets
adding
unused catch block
instead a null test a NO_REFS empty array constant initialize VAR_1 constructor don t need worry null _CODE_ ( )
style - : reason add final
style : don t curly braces single line blocks
style - : curly braces single statements
style : don t braces single line blocks
style : braces single line blocks
discards msg argument _CODE_ class needs a new constructor allows pass msg default text
shouldn t case code plain wrong a TYPE_5 VAR_2 leave original else block returns false
style - : brackets single - line blocks
I case list fallback cases ( I don t create a VAR_6 diff )
new HashSet < TYPE_3 > ( Arrays asList ( VAR_1 ) ) ;
style : don t braces single line blocks more occurrences patch
shouldn t put a finally block ? saves line code
style - : good reason local variable VAR_5
commit _CODE_ a
short method shorter : File file = new File ( METHOD_2 ( ) VAR_1 ) ; { byte [ ] VAR_2 = TYPE_1 METHOD_3 ( file ) ; return 0 < VAR_2 length ? VAR_2 : null ; } catch ( TYPE_2 VAR_3 ) { return null ; } tiny isn t worth hoist / catch
style : don t curly braces single line blocks
style : braces
constructor public ? permit copying a TYPE_2 ( application a snapshot ) instead support some sort copy constructor takes a TYPE_2 object a _CODE_ ( ) method returns a copied TYPE_2 object I package - private _CODE_ need construct a TYPE_2 object
curly brackets needed ; )
please remove curly brackets single line blocks
I HashSet faster _CODE_ ( ) call ( ) O ( n ) ArrayList O ( 1 ) HashSet
style : braces single line blocks
please retain ability clear VAR_2 calling null username VAR_1
curlies - needed
style : braces single line block
style : braces single line blocks
style : braces single line block
NPE METHOD_1 ( ) return null ( resource isn t project shared git )
code conventions : don t curly brackets single line blocks
reason TYPE_1 VAR_5 instead STRING_1
style - ; don t braces simple single stament constructs
style - ; don t braces simple single stament constructs
style : don t curly braces single line blocks
style : braces single line blocks
convoluted instead _CODE_ VAR_3 ; ( uri ! = null ) { VAR_2 METHOD_2 ( uri VAR_1 ) ; VAR_3 = uri toString ( ) ; } _CODE_ = STRING_1 ; / / $NON - TYPE_2 - 1$
curly brackets removed
don t resolve symbolic link reflog branch VAR_6 pointing instead I extra reflog maintained VAR_6 updates VAR_6 including branch switches case git reflog a branch _CODE_ = Constants _CODE_ _CODE_ = VAR_5 METHOD_4 ( ) getName ( ) ll difference select master difference branch selection dialog reflog view needs show VAR_6 selected explicitly
style - ; braces simple single - statement constrcuts
style : don t curly braces single line blocks
? I find easier read : ( VAR_2 hasNext ( ) ) { Object VAR_3 = VAR_2 ( ) ; }
style : don t curly braces single line blocks
style - : curly braces loop necessary
level high searching parent working tree find VAR_2 located working tree newly cloned VAR_1 run a long time parent directory bigalso text displayed progress monitor cloning instead searching VAR_2 auto - import
style - : remove curly brackets single line block
style : curly braces single line blocks
mark VAR_2 volatile method synchronized ensure caller sees correct version VAR_2 read ( ) call
bug
curly braces
curly braces
curly braces
curly braces
bug
curly braces
style : remove curly brackets
style - : don t curly brackets single line blocks
style : curlies
style : don t curly brackets single line blocks
style : curly brackets
braces single line block
style : curly braces single line blocks
style : braces single line blocks
count doesn t need explicitly initialized 0 default
style : braces single line blocks
nicer done
keyword needed
drop final qualifier r fit line
add empty set VAR_2 entry treated accessed I don t s correct
_CODE_
shouldn t condition entry parent VAR_2 isEmpty ( )
_CODE_ ( )
shouldn t temp file deleted
METHOD_1 ( Arrays asList ( cmd ) )
I drop parameter _CODE_ constant entire commit
move line 51
inline o
please remove isEmpty ( ) check null check removed comparisons null - proof
VAR_3 removal cleaned a vector
I don t useful organize tests regression category I d regular test VAR_1
please bring braces
please bring braces
please bring braces
please bring braces
please bring braces
please bring braces
please bring braces
please bring braces
new String [ VAR_1 size ( ) ]
restore spaces
I d prefer remove field feels a bit unclean a field valid execute method a local variable execute passed argument _CODE_
_CODE_ print ( VAR_3 ) ; loop deal part string < = 100
remove done plugin start ( ) method
changed wrong : ) loop METHOD_1 ( )
style : don t curly braces single line statements
Exception thrown developing a change required throws clause isn t need proposed patch I expected reviewed change proposing removed change
invoke object toString ( )
private
curly braces aren t required
sense ? I didn t bare repositories index VAR_1 METHOD_2 ( ) throw exception point VAR_1 _CODE_ ( ) throws exception bare repositories called TYPE_3 read
toString ( ) isn t necessary + call
alternatively : Arrays VAR_2 ( new Object [ ] { command VAR_3 } ) ;
include cmd message
unnecessary booleans default false
method overrides _CODE_ METHOD_1 ( ) don t super METHOD_1 ( ) METHOD_1 widgets classes added _CODE_
synchronized
VAR_2 + 1
pubsub handler matches ^ / * / logic needs
I _CODE_ NANOS _CODE_ ( System VAR_1 ( ) )
private
loading a chain classes potentially activating other bundles bundle startup problematic ll need find a initialize contributors lazily e g context activation
TYPE_2 actaully thrown method body
please don t catch Exception code compiles fine catch want replace catch _CODE_
done constructor allow changed a debug session other areas allow a dynamic change I m worried ll a conflict tracing initialized stuff constructor moved a smart flags instance class allowed change class created
remove chedk VAR_2 part TYPE_3
s TYPE_1 mentioned
s TYPE_1 mentioned
a local context instead
VAR_2 [ length ] = VAR_1 havesufficed
hmm I don t a getter shouldn t writing a add _CODE_ ( ) method
implementation transitive null elements ordered
constructor asserts
querying provider implemented _CODE_ invoking query ( ) method providers
I check places VAR_1 null ? final initialize constructor
I wondering check shouldn t caller side method
missing
I m thought : throw exception a conversion function i e normalize scale = 0 drop precision
spacing wrong ctrl + shift + F part
don t need check STRING_2 I doubt TYPE_4 - exlanatory enough investigate fix
data a _CODE_ s cast a Map s require
cast Map < String String >
style : don t braces single line blocks
style : don t braces single line blocks
check needed ? omit allow others create a packaging type - eclipse - target - definition example includes additional steps default lifecycle
don t need change method signature I leave method private
don t need change method signature I leave method private
style : braces single line blocks
invoke other constructor _CODE_ marked final
page update VAR_1 previously active
string don t need
leave protected avoid breaking people
alternate shouldn t repository s shallow file define alternate a shallow file null handle case _CODE_ ( ) VAR_3 = = null means empty set
necessary
necessary
necessary handled METHOD_4
catch Exception instead simplify code
style : braces
return properties ( ) containsKey ( ) call redundant
NPE catched btu case checked ( smth ! = null ) definetely don t want ignore NPE
done super METHOD_1 ( ) ;
METHOD_2 ( ) sufficient GNU extensions needed
change VAR_4 length 0 need change array length 0
Set < String > doesn t matter
call clear disposing readers
style : braces
instead delegating super class I instead override method subclass
please don t print stack trace
adhere coding style file multiple return statements
style : braces single line blocks
don t need pass instance s formatting characters string
Set table size 5 expect 4 entries 5 a good default size
parens condition
instead String + = _CODE_ s more efficient a StringBuilder append ( ) ( especially a loop ) return sb toString ( )
a tad simpler : ( List < TYPE_2 > list : VAR_1 values ( ) ) { count + = list size ( ) ; }
VAR_1 class member ask active
TYPE_3
! = 0 valid bit 1 bit set
put assert want assert ( p > m_loadmetertimerperiodmin ) ; warn designer wrong code recover production
I haveif ( c = = null || c length < INT_1 ) return ; else ll hav NPE
METHOD_1 ( ) s remove
s return Integer consistent
maybeif ( VAR_2 = = VAR_1 ) return ;
braces - else statement
return type Object toString ( ) function called converted a List else string doesn t _CODE_ good point getValue ( ) return type passed constructor pass a field [ ] reuse - fields attribute super class I easiest / cleanest override toString ( ) Arrays toString ( ) correctly print array
want leave asserts code ? checking throwing IllegalArgumentException similar
error handling confusing want throw exceptions TYPE_3 call catch block exception want catch generated METHOD_1
switch arguments expected assertEquals
sense swap VAR_10 VAR_12 VAR_9 common VAR_11
s sense move condition _CODE_ METHOD_1
call METHOD_1 constructor I prefer override _CODE_ { selected / unselected } concrete class
return getName + CHAR_1 + METHOD_1 ( getValue ( ) VAR_1 ) ; / / trailing spaceit nicer
StringBuilder ( null ) _CODE_ calling format a null VAR_1 ? formatting string null 5 a valid reference
minor lines combined
style : braces
test VAR_5 instanceof TYPE_2 null instanceof
add missing java - doc
selecting a directory a lot - directories method METHOD_3 ( ) takes long ( due _CODE_ _CODE_ ( ) ) blocks GUI good run a job show a progress bar possibility cancel
filename null interface ( want allow ? )
useless null check ( supposed null return null )
wonderful world _CODE_ ; ) _CODE_ ( expected = IllegalArgumentException class ) public void METHOD_1 ( ) { new TYPE_1 ( null ) ; }
I don t cast parameter case assign
a loop ( vice versa )
FYI i confirmed equation correct
change a single call arguments
simpler apply mask shift
s preferable sacrifice code reuse readability check VAR_1 < VAR_2 calling METHOD_1
_CODE_ needed _CODE_ initialize lazily needed
redundant call
add synchronized method
add synchronized method
add synchronized method
attach cases _CODE_ _CODE_ reverse a big deal I wondered a reason
H - happen ? ? project setting s save actions supposed add brackets clauses automatically
break find user
check celement null
IIRC carried new clone reader other implementation
_CODE_ ( ) doesn t put newly written data _CODE_ good d asking a lot block cache putting partial blocks I assuming _CODE_ meant fast shouldn t hurt
form instead : ( repo VAR_3 ( ) repo VAR_5 ( ) ( TYPE_3 VAR_7 ) ) ;
check VAR_1 deactivated
style : don t braces single line blocks more
style : braces
good call a separate method
method executed - UI thread receiving components thread access problems ( org eclipse swt _CODE_ : invalid thread access ) internal plug - problem timezone a request handling
prefer return statement
{ line
_CODE_ protected
VAR_1 protected
variables protected
variables protected
VAR_2 protected
issue auto - generated code don t want change I personally hate lack braces case need stick produced combination a ) generating code b ) running source format
arrays ( String : VAR_1 ) { ! METHOD_2 ( )
assertEquals instead - output don t match assertEquals ( STRING_1 VAR_1 METHOD_2 ( VAR_2 ) getName ( ) ) ;
change a java lang _CODE_ ( )
pull a static method pgm archive invoke a TYPE_1 don t need maintain list places
a small helper method setup registrations : private static final List < String > _CODE_ = Collections _CODE_ ( new ArrayList < String > ( ) ) ; private static final void register ( String format < ? > fmt ) { _CODE_ add ( ) ; TYPE_2 _CODE_ ( fmt ) ; } public void METHOD_1 ( TYPE_1 context ) throws Exception { ( String : _CODE_ ) { TYPE_2 METHOD_2 ( ) ; } _CODE_ clear ( ) ; }
typical case TYPE_4 wise code more readable filtering foreach loop : ( TYPE_1 VAR_4 : VAR_2 values ( ) ) { ( VAR_4 _CODE_ METHOD_3 ( ) ! = null ) { METHOD_4 ( VAR_4 false true ) ; } }
VAR_1 isEmpty ( ) necessary ? I foreach loop handle case
close view _CODE_ control disposed VAR_1 check VAR_2 METHOD_2
please write linesedit = ( VAR_2 ! = null ) ; ( VAR_3 ) more readable
code sense agree idea function addition called child tree setting enablement VAR_1 add a call VAR_3 VAR_5 ( false ) ; _CODE_ VAR_5 ( false ) ;
yeah systemtap code great shape improve bits touch
context passed
I exception s a switch a null : java lang _CODE_ org eclipse mylyn internal VAR_1 core remote _CODE_ METHOD_1 ( _CODE_ java : 338 ) org eclipse mylyn internal VAR_1 core client data _CODE_ < init > ( _CODE_ java : 51 ) org eclipse mylyn internal VAR_1 core _CODE_ _CODE_ ( _CODE_ java : 225 ) org eclipse mylyn internal VAR_1 core _CODE_ _CODE_ ( _CODE_ java : 114 ) org eclipse mylyn internal VAR_1 core _CODE_ _CODE_ ( _CODE_ java : 160 ) org eclipse mylyn internal tasks core sync _CODE_ _CODE_ ( _CODE_ java : 245 )
thread safe VAR_1 modified building subgraph I suggest lock reading writing instead synchronized blocks
s null ? log error
add newline
super METHOD_1 ( ) s change _CODE_ defines host ID VAR_1 - CTF traces follow
outer parentheses needed
instead VAR_1 potentially null couldn t check constructor parameter null ? ( throw IllegalArgumentException )
a good habit avoid public methods need public class internal matter safer put private avoid stuck new API leave case
fields set final ll } else { VAR_4 = null ; } VAR_4 = new ArrayList < > ( ) empty list
unsuccessful
moved paint method
I m want a request a fixed number events read lost events counted s checkpoint indexer
need clean buildroot rpmbuild handles internally
common code style linux tools { } statements please fix
public
I suspect bug point please investigate more
please return empty VAR_2 prevent _CODE_ users method easily check list empty instead null returning null collection expected considered a bad style
don t variable VAR_2 ? assigned false returned return false method assign VAR_2 BTW variable renamed _CODE_ _CODE_ VAR_2 proper english
unnecessary check ( ) return null
synchronizing methods object class s monitor synchronized keyword method signature ( public synchronized void ) avoids extra sync objects ( saves level indentation ! )
output added times need prevent
called multiple threads ? a concurrency issue VAR_3 needs handle thread safe class
add null VAR_1 allowed
done
assertions don t validate correctness returned result assert content
VAR_3 part interface TYPE_1 ? constant represents action provided _CODE_ implementation conjunction implementation interface defines a generic mechanism set retrieve state a command I VAR_3 belongs _CODE_ interface
reason needs public API ? oprofile class loaded s oprofile kernel module loaded
please curly braces statements
redundant condition
remove
private
VAR_1 method string replaced remove parameter rename _CODE_
impossible add called branch ids ? called id = 1 id = 2 branch ID intent
a catch _CODE_ ? VAR_1 checked verify a _CODE_
a catch _CODE_ ? VAR_1 checked verify a _CODE_
resource list change resolution additional resources loaded case a concurrent modification exception thrown I accept change fix bug replacing loop _CODE_ METHOD_3 ( VAR_3 ) ; handles room file problem
slightly : VAR_2 = = null || VAR_2 isEmpty ( ) ? null VAR_2 empty instead null projectless debugging ? changed
simplified : super ( VAR_2 _CODE_ ) ; project = project ;
strange check
good bad else good
unnecessarily flipped order statements diff unnecessarily larger
? claim a refactoring
omit explicit else - case return false instead
I don t need anymore ( able kill METHOD_5 ( String bla ) _CODE_
remove line variable configuration useless
delete file a new generated ? s nice behavior clean mess _CODE_ some tests file
style : braces
TYPE_2 s full path encoded created bug higher call stack handled instead tackle avoid slip cracks repeated
s combination a default null a silent catch ( relies earlier initialization set correct ) confusing : final TYPE_1 VAR_2 ; { VAR_2 = ; } catch ( IllegalStateException e ) { VAR_2 = null ; / / log error ? } clearer error occurs return null ( IMHO )
add brackets loop body ( required code conventions )
please remove
call super ( )
private
public synchronized
visibility missing synchronized static
protected more s meant - classes definition matter package minor
call METHOD_1 multiple times a trace a safe - guard ? curious
I filter part TYPE_3 please move
remove clear ( ) call ( left refactor )
default usage recording job problematic please remove model editing API handle editing domains
accesses volatile primitives guaranteed atomic ( long don t depend current ) synchronized block redundant good reference volatile keyword :
synchronized block needed
please add a TODO replace logging throwing NPE
symmetry s sake d load ( _CODE_ ( ) ) a method
changed return type Double act returning double example Double METHOD_3 ( ) instead returning object cast Double
I don t need call toString ( ) objects passed String format - method internally
style : braces single line block
isn t enough guarantee equality key implement VAR_1 ( ) = = 1 broken key equals ( obj key )
guy missed question patch ? I ll copied : METHOD_3 ? I m familiar code I don t called CDT code path parameter os separators ? sounds host dependent I m thinking a case host windows toolchain works remotely linux
line long
style : braces
don t braces ( { } ) simple - line statements please remove
a thrown exception
need constant ? isn t Collections _CODE_ ( ) sufficient
import need VAR_2 VAR_3 part
I assume don t want - box ? ; ) ( btw I learned cases s Integer valueOf ( int ) new Integer ( int ) valueOf cache - values new Integer ( ) create a new object time )
usethis = = VAR_1 valuehere VAR_1 classes save function call I guess
method marked synchronized ( ensure caller build array ) minor issue work d ; ) I guess ll fix _CODE_
VAR_1 ! = null && ! VAR_1 isEmpty ( )
method declared static
order arguments assert * ( ) counter - intuitive s ( expected actual ) technically result variables
give a _CODE_ METHOD_4 ( ) return null
pass null instead entry
check moved _CODE_ ( ) ( overridden version calls super _CODE_ ( ) ) METHOD_2 ( ) overridden class return a TYPE_3
instead usereturn ; avoid creating new objects everytime method called refer object ( string literals internalized ) a private static final String EMTPY_STRING = ; class instead a lot file
throw exception
substring ( # ) calculated TYPE_3
common code base I dislike size ( ) = = 0 - > isEmpty ( ) assume List operator implements size ( ) a huge cost ( linear constant time )
import import section
throw error
null check needed
valueof ? id a String
tmf core activator plugin depends tmf core loaded necessary call
VAR_1 static ? list modules XML modules ? case METHOD_1 ( ) method a static method ( interface method ) class ends a static class empty private constructor prevent instantiation method synchronized avoid risk threads calling time entering block
s needed anymore delete ; - )
I access VAR_1 synchronized
need protected couldn t private ? number background requests specific internal implementation ( notion foreground background s another story ; ) )
METHOD_1 another method init METHOD_2 stay METHOD_1
statements else branches curly braces branches
remove unnecessary surrounding parenthesis
protected
( a bunch statements return statement w / && )
need ? doesn t
instead making a singleton create VAR_1 _CODE_
return VAR_2 METHOD_1 ( )
return immutable collection
methods private
constructors calls METHOD_1 ( ) create a thread construction called fake traces ? I d safer lazy - METHOD_1 done previous version _CODE_ ( ) dispose ( ) synchronized ( synchronizes ) doesn t VAR_6
I handling fetches a server shallow commits more work ( v1 9 - rc0 3^2 17 upload - pack : deepening preserves shallow roots 2013 - 12 - 05 ) lines needed
private
_CODE_ instead ease maintenance
call other constructor giving diff builder instance parameter
isn t place modifying list VAR_1 I progammatically created VAR_1 added model survive
VAR_3 getter
a bunch templates I a list / set check template pref store
occur METHOD_3 ( input ) ;
shouldn t call parse ( )
need variable instead inline
introducing a local variable justified
isn t condition inverted ? juno kepler versions * * support dynamic tabbar
field removed
I s return null _CODE_ handling result
set false ? set true
needs done _CODE_ ( ) s _CODE_ ( ) instead
s remove
need casting
need casting
remove unnecessary cast
remove
remove
remove
slightly more efficient : TYPE_3 VAR_2 = VAR_2 ( new TYPE_3 ( ) VAR_1 ) ; VAR_2 VAR_4 = TYPE_5 trim ( VAR_4 ) ; ( int i = 0 ; i < VAR_2 VAR_4 length ; i + + ) { VAR_2 VAR_4 [ i ] = VAR_2 VAR_4 [ i ] VAR_2 ( VAR_1 ) ; } return VAR_2 ;
attribute null
List
change _CODE_ METHOD_1 ( ! VAR_1 || VAR_2 = = null || VAR_2 size ( ) = = 1 )
VAR_2 _CODE_ instead looping
please don t print stack trace log properly ignore information useless
needs synchronized VAR_1
needs synchronized VAR_2 / _CODE_ / initialize
consider moving assertions separate method
needed VAR_2 implies VAR_1 ( explicitly chosen _CODE_ ( false ) _CODE_ ( true ) )
add single space {
d METHOD_1 stuff call super METHOD_1 ( )
convention a monitor passed s param
return TYPE_1 METHOD_2 ( ) equals ( TYPE_1 VAR_1 )
making * * s null ? ; )
minor case a reference new TYPE_2 need a map lookup case
remote
remove
I guess WIP part
public modifier consistency
braces single line block
method
remove assertion reached
checking list ( ) remove ( ) s avoid double iterations
remove syserrs
3rd a weird condition : I add attribute 0 ( tid ) a subattribute 0 ( cpu ) throws exception asserts I noticed
a Set instead ArrayList
syserr
don t braces single line blocks
need levels / finally input closed TYPE_2 fails create
wrap / finally ensure streams closed case failure
order matter
I return a string
need qualify access TYPE_2 type
add a text show output means running benchmark I d need more verbose ; - )
style : early return avoid need else { } statements else case
part a commit
remove field create function _CODE_ method
I don t a catch block rethrow exception
call METHOD_2 logging pass monitor
null passed
consider file adding files ( STRING_1 ) result
static
call super METHOD_1 ( )
object _CODE_ provides a method allows add information dialog boundaries - > _CODE_ ( )
tests a instead ? I assume traces closed / disposed
want RAF ( s royal air force ) read events ? a separate local ( pass parameter METHOD_2 ) close opening real events
Type checked casting
a null check previous test classes ? null more others
needed ? ( int id ) ? answer : iterate dingus ! I ll return iterable instead expose underlying data structure ( allow change underlying implementation _CODE_ breaking API )
need a concurrent data structure a regular list a linkedlist variable local subject comodification
VAR_1 allowed null
more descriptive string put a constant
lists
list
( VAR_1 instanceof TYPE_1 )
t constructor field VAR_1 final
included _CODE_ ( )
returns early : ( VAR_2 getType ( ) = = TYPE_1 VAR_4 && METHOD_2 ( VAR_2 ) ) return true ;
line statement
I d catch org eclipse emf common util _CODE_ instead exceptions wouldn t sufficient
_CODE_ implementation takes care remove test
suggestion Throwable incorrect version patch set #2 simpler
nest
a constants static final array changes need - creating array time
API breakage returned collection modifiable more I m affected
method synchronized
move 1 line remove call _CODE_ METHOD_4
private remove tag
I prefer public s impossible clients correctly initialize class mark hide API
pass parameters instead null checks
VAR_2 null happen shouldn t bail point ? brackets needed
style : don t braces single line blocks
applying VAR_1 package time ? s command
instruction abstract class fields belong super ( set parent VAR_2 ) ;
public methods METHOD_2 ( ) required
public methods METHOD_2 ( ) required
implementation restructured : int METHOD_1 ( ) { ( VAR_3 = = 0 || ( state & VAR_1 ) ! = 0 ) return 0 ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; METHOD_2 ( VAR_3 VAR_2 ) ; return VAR_2 VAR_4 ; }
point testing method marked a compiler check instead a unit test check means remove test altogether
redundant
VAR_1 ! = null && VAR_1 METHOD_2 ! = nullif METHOD_1 called example proposition leads a NPE
I m convinced needed free file descriptors don t close _CODE_ memory safe s more simple / representative VAR_1 null
ANNOTATION_1 line
annotation a separate line
Boolean toString ( true )
style : don t braces single line blocks
increase give some space other visualizer 10
inline return ( need VAR_2 variable )
please stick java convention naming variables - letter case another case local variable needed return
don t put s a real warning atm rid ; )
method return instance time ( meaning ) store a field named VAR_6
s worth changing remove _CODE_ TYPE_3 _error_ ! * gasp *
need ? t pass offset context region
else
safer synchronize method ! other methods return a List < >
add braces else ? omit braces simple statements
extra blank line
TYPE_3 : (
( ? ! ) offset larger Long MAX_VALUE nanoseconds ( a scale ) overflow
unused variable
please install checkstyle environment ( ) forbid ternary operator EMF compare beif ( VAR_2 ) { return METHOD_2 ( VAR_1 ) ; } else { return METHOD_3 ( VAR_1 ) ; }
checkstyle allow I easier read : ( VAR_1 METHOD_3 ( ) = = TYPE_2 VAR_5 ) { return VAR_1 METHOD_2 ( ) = = TYPE_3 VAR_3 ; } else { return VAR_1 METHOD_2 ( ) = = _CODE_ VAR_6 ; }
VAR_2 write ( text )
need messages exceptions ( detail stack trace throw statements removed part review chain )
configure selected pattern user clic finish skeleton created default another remark : a dangerous cast : combo selection a _CODE_ enough time TYPE_1 expected friends
init command configuration page configure VAR_2 provider instantiate command demand
please add { } statement ( VAR_4 METHOD_2 ( ) = = TYPE_3 VAR_6 ) { _CODE_ cmd = VAR_1 METHOD_3 ( ) ; / / command execution ? } modifiy inheritance action add command execution
rewrite : int c = VAR_2 METHOD_1 ( VAR_1 VAR_2 ) ; ( c ! = 0 ) return c ; return VAR_3 METHOD_1 ( VAR_1 VAR_3 ) ;
METHOD_4 ( i )
VAR_2 = offset
put ( uri stream ) a _CODE_ avoids synchronized
instead null check don t METHOD_2 alwaysreturn - null ? I e return default provider mapping
Collections VAR_1 ( VAR_2 ) ; VAR_2 variable defined Collections VAR_1
( minor ) simply declare throws Exception remove clutter perfectly test methods other test methods class I guess
_CODE_ instead
fine move command refactor code method private
remain int
I apply a patch proposed bug report
protected
protected
return null version a valid OSGI version
consistency suggest replace return results =
line - - - METHOD_5 ( ) add ( VAR_4 ) ;
sense add a string constant TYPE_3 VAR_5
VAR_7 set base class return method
_CODE_ ( ) _CODE_ ( ) ? answer other external filters viewer _CODE_ _CODE_ ( ) method ; (
nitpick : instanceof check redundant
nitpick : instanceof check redundant
I needs check VAR_3 null
check empty VAR_1
reason t simply call METHOD_2 ( )
private ? ( outer class able access )
wow hard understand : PI assume sense don t want include experiments want real VAR_1 unpack experiments case unpacking write VAR_2 instead ? method remain a simple getter s exposed publicly collection synchronized immutable
I throws Exception removed
private
braces
I a NPE I don t traces downloaded other tests modified
reason t VAR_3 instead casting VAR_1
I isn t necessary METHOD_1 ( ) doesn t need configuration
careful return : returning - 1 means nullstate smaller other objects other objects greater nullstate explicitly other methods ( object instanceof TYPE_2 ) return 1 ; unit tests ways instance assertTrue ( val1 METHOD_1 ( val2 ) > 0 ) ; _CODE_ ( val2 METHOD_1 ( val1 ) > 0 ) ;
I safe synchronize iteration line set changes iterating
check method declared private
check method declared private
_CODE_ = new ArrayList < TYPE_1 > ( Arrays asList ( VAR_2 ) ) instead a TYPE_2 ? matters :
I setting defaults _CODE_ class
VAR_7 unecesary exception doesn t happen test VAR_7
VAR_6 unecesary exception doesn t happen test VAR_6
VAR_5 unecesary exception doesn t happen test VAR_5
VAR_4 unecesary exception doesn t happen test VAR_4
VAR_3 unecesary exception doesn t happen test VAR_3
double METHOD_3 ? drain instead
remove synchronized lazy loading map structure add values static map enum element construction
making a new List _CODE_ Iterator necessary I propose write : ( TYPE_1 _CODE_ : VAR_2 ) { _CODE_ close ( ) ; }
I tend remove / install code needed : org eclipse gef editparts _CODE_ METHOD_2 ( Object _CODE_ ) remove ( deactivate ) pre - existing policy role want install new
don t need public leave renaming * s a : )
unnecessary
bitwise operation intended
style : braces
I return VAR_2 keySet ( ) METHOD_2 ( new TYPE_1 [ 0 ] ) array passed large enough a new created proper type store Set s content size calculation isn t needed
log error
shouldn t < instead ? time range request time range updated _CODE_ signal handler
create a buffer store some content want throw ? output < null > don t initialize a writer call ( ) method writer initialized read lines
VAR_3 = VAR_3 ;
_CODE_ disconnect ( ) called ( previous code ) leads hanging executor thread _CODE_
put null check prefer instead METHOD_3 ( ) return check monitor s canceled state decide update viewer
I suppose _CODE_ ( STRING_1 ) method instead split performance a constant prefix int _CODE_ = uri substring ( BUNDLECLASS_PREFIX_LENGTH ) _CODE_ ( STRING_1 ) ; ( _CODE_ > 0 ) { return true ; }
good catch
a bug - - > VAR_3 = VAR_4 METHOD_1 ( VAR_3 VAR_2 ) ;
method prohibits 2 participants update TYPE_1 I METHOD_1 return TYPE_1 modification _CODE_ VAR_3 = VAR_1 ; ( TYPE_2 VAR_4 : VAR_5 ) { VAR_3 = VAR_4 METHOD_1 ( VAR_3 VAR_2 ) ; }
don t handle filter ? I dislike a special treatment stacktraces I add filter ( wildcards ) hard - coding wrong
class colors created disposed
I find call method change
loses information : _CODE_ ( true ) ; _CODE_ ( true ) ; METHOD_1 ( false ) ; METHOD_1 ( true ) ; _CODE_ ( ) ? I d delete lines treat orthogonal ( _CODE_ prevent deleting branches VAR_2 false )
sirius logger
move line TYPE_1 a = line empty line ll clearer parts test
argument order weird consider flipping : _CODE_ _CODE_ _CODE_ tests : STRING_4 STRING_2 string_3which easier read
METHOD_2 ( ) called a finally block ensure called exception occurs METHOD_1 ( ) ( call user - code control )
bloops
bleep
ni
poutine
code I wrote
current flows a check insure model null prudent check case s eventually called
VAR_1 null place ? please add guard
s a good idea run tests submitting gerrit
VAR_3 set pressing default reset color black
done TYPE_1
find a VAR_2
setting a variable a native engine register variable a map more a variable need check save names
extraneous space (
modification done commit reference bug 449167
case jerry - rig factory create object manually
protected reusable child classes
remove names
remove
_CODE_ a
check client
trigger initialization VAR_1 ( case cleanup )
push VAR_4 VAR_2 generator : VAR_8 = VAR_3 VAR_5 ! = null ? new TYPE_3 ( VAR_3 VAR_5 ) : null ;
! VAR_3 isEmpty ( )
introduces a nesting level / else blocks needed : ( ) { } else ( ) { } else { } instead ofif ( ) { } else { ( ) { } else { } }
whe a a want logging instead writing stderr
builder s _CODE_ true ? safer : ( builder instance TYPE_3 ) { ( ( TYPE_3 ) builder ) METHOD_2 ( VAR_1 ) ; } introduces a side effect builder parameter method s a problem
I put VAR_1 || VAR_2 ! = VAR_3
need trim input doesn t match input starts whitespace
trivial { } single statements
omit
omit
aren t selection index starts 0 ? main VAR_3 0th element need regular NPE protectionif ( VAR_2 = = null ) return ;
replace method / / supported anymore
I suggest false remove field
return false update _CODE_
s unnecessary declare method public s package visible test s package
s unnecessary declare method public s package visible test s package
trim string more ? ( i e INT_1 max ) ? adding STRING_1 INT_1 chars greater
method map expected < String String > < ? ? >
map generified
done
size result list properly : final List < Object > result = new ArrayList < Object > ( list size ( ) + 1 ) ;
I t reason throw TYPE_1
some time track returning false return true causing remote commands break escaped properly a separate problem ( a bug original implementation I ) attribute needs fixed
remove thises
+ = a Long object boxing time d VAR_2 a long return Long valueOf ( VAR_2 ) simply return a long method
s useless check null sincenull instanceof somethingalways returns false
brackets single statements ( I inconsitent goal )
private
private
consider moving null check write ( ) method guard other places
I instance check method meaning method exception object type
a new ( else lose logging test )
I d recommend parentheses elvis notations : VAR_7 = ( VAR_4 ! = SWT VAR_6 ? VAR_4 : VAR_3 ) ; don t read code _CODE_ = _CODE_ assigning _CODE_ s bad
don t need check
change removing org eclipse core runtime compatibility * bundles
instead METHOD_2 ( ) METHOD_3 ( ) methods METHOD_3 ( )
= = sufficient
equals ( ) usefull enum = = sufficient
exclude TYPE_3 TYPE_4 _CODE_ overrides method ? 3 override
join variable definition please
exception thrown code needed
put braces block please
I put not_touch position METHOD_3 TYPE_2 type filter
good multi - thread catch
editor control disposed null I add METHOD_3 ( ) ! = null && please && condition a new line readability fault readability
line number command separated failure message example : 50 : click : control disabled discuss ulyana ond olya
monitor parameter especially METHOD_2 ( ) longer time
useful monitor field pass METHOD_2 ( ) parameter useful refresh
check
strings equals ( ) compare = = ! =
pass _CODE_ method avoid method moved a place _CODE_ set
move line
remove protected prevent access package place method other gtk_widget methods class
project stuff _CODE_ ? base class
set fields null generally a good idea METHOD_1 ( ) fail called case ll NPE
VAR_1 disposed ? _CODE_ parent _CODE_
debugging leftover
variable declared bad scope
call copy 2nd time
want decorate TYPE_2 plugins workspace
A diamond operator suffice
Optional : presize 2 * VAR_1 length
rewrite - - resources : ( TYPE_7 reader = db VAR_2 ( ) ) { return METHOD_1 ( reader path VAR_1 ) ; }
method static
I _CODE_ singleton
field final ? method scope
other initialise VAR_3 field a setter
protected want allow call class
check null instead ! null logic new class _CODE_
need super
reveals a more impacting problem METHOD_1 called ? change hide consequence problem
wrong arg order
a reason set strength ? platform / UI JDT code
line dash / line attributes
style : add braces block
reverse order : assertEquals ( VAR_1 )
tests METHOD_1 preceding character content character content ( areas ve troubles )
set variable false close connection
return ( e VAR_2 ( ) isEmpty ( ) ? null : e VAR_2 ( ) ;
logic weird I change : ( VAR_6 ) { return }
return evaluation
need type
_CODE_ ( ) other ways set VAR_2 validated pull a dedicated _CODE_ method call VAR_2 determined
I effect consistent rest code class statement changed return METHOD_1 ( ) - wdyt ? I m fine don t want change decided ask
infinite loop
done ( copy - paste )
argument constructor argument constructor removed missing / / $NON - NLS - $
else redundant
replace platform TYPE_2
remove rounding 3rd strike ; )
/ upper constraint disabled case unrelated constraints element
needsynchronized ( TYPE_3 ) { block _CODE_ ( ) calls
inline
t return null
missing braces
shouldnt < = ? haven t pulled latest changes ? I changed < 2_12_0 < = 2_11_0 equivalent ( maintain VAR_3 )
method static
TYPE_3 METHOD_1 ( ) ;
A dangerous access array index checking validity
synchronized
avoid local variable store VAR_3 clause feel ( unnecessary )
merge s : ( VAR_1 = = 0 _CODE_ ( ) ! = null &&o VAR_3 ( ) ! = null ) { VAR_1 = } technically VAR_3 ( ) returns a mutable d safer extract a local variable change check METHOD_1 ( ) more condition I don t trace type ID supposed change s fine
braces I guess
wouldn t VAR_5 block caller
set null especially _CODE_ fields set null METHOD_4 ( ) call
call METHOD_4
done
I checkstyle disabled project ( ) EMF compare checkstyle config discourages ternary expressions I d replace a common statement
don t catch instead allow _CODE_ handle
( optional )
argh thanks noticing ! ; - )
evaluate VAR_2 lazily _CODE_ ( ) a call METHOD_1 ( ) avoided completely VAR_2 set manually METHOD_1 ( ) possibly slow hang bash configuration screwed
multi return forbidden
return VAR_1 METHOD_2 ( new TYPE_1 [ 0 ] ) ;
s / public / / type visible methods aren t visible declared public cases avoid public confusing
I = = don t want equivalent entries a gzipfile return inputstream file
means VAR_1 ( ) VAR_1 ( wonka ) VAR_1 ( wonka ) VAR_1 ( ) result VAR_1 wonka ? inconsistent needed
set coming
METHOD_1 empty
idem
idem
sollte false nicht default sein
else more obvious exclusive cases
shouldn t check top method ignore working copies time
multi returns avoid
multi return avoid
s odd METHOD_1 call METHOD_5 instead a method _CODE_ calls METHOD_1 METHOD_5
instanceof ? ? a thought
casting View checking instanceof highly suspicious
_CODE_ instead METHOD_4
final missing
null ! = preferably
null constant operations
return condition
I - factoring haven t changes function other refactoring I recommend submit a separate - factoring patch patch long ideally - separation widget a 2nd refactoring patch ( menu - item ideally ) touch line don t change identical line statement ( L 900 ) function a bit inconsistent
break equal sign
code simplified rely autounboxing
code simplified rely autoboxing
TYPE_1 element : c
code simplified rely autoboxing
TYPE_1 cache : _CODE_ values ( )
; work controlled models
METHOD_1
METHOD_1 caller runs push cert enabled client didn t send a push cert
a bug reported JDT ( 470535 )
assigning VAR_7 a new return VAR_7 - assign VAR_7 s s returned duplicate assignment strange code instead consider simply returning a new TYPE_1 object touching VAR_7 call leave assignment parent method
VAR_2 = VAR_1
simpler : return new ArrayList < > ( new HashSet < > ( VAR_1 ) ) ;
redundant else
redundant initialization
redundant else clause
checkif remove thatbecause a notification service VAR_1
avoid unrelated formatting changes
revert unrelated formatting change
removed
done
constant variable operator
cnn
I assume didn t expect commit : - D
logged instead ? removed needed
das gibt eine _CODE_ wenn format = null
parameter true
experiment parameter trace experiment handling _CODE_ signal traces experiment remove VAR_4
selected trace a kernel trace viewer data remains call METHOD_3 ( null )
controls disposed platform need call super METHOD_1 ( ) viewer a _CODE_
switch traces added times a listener
a listener _CODE_ METHOD_1
I m mistaken VAR_1 results stay memory long trace opened full copy results tree map store copy memory
TYPE_1 _CODE_ ( ) called preserve selection ( based index ) _CODE_ _CODE_ ( ) : 489 update element ( calls method ) * * a bounds check selection index I a bug _CODE_ a workaround clear selection changing input sense want preserve selected index unrelated input segment store
Set segment array null input a valid segment store
consider making method private package scope
please set instruction file getPath ( ) case errors instead file VAR_2 ( )
doesn t need public
please delete line replace adapterfactory ! = null statement don t want raise error tooltip t computed
VAR_5 prevent - entrant calls function I m normal table modified modified boolean flag avoids problem added ( VAR_3 length > index ) check needed number entries current intervals view reduced selecting a new timestamp viewer new limit
protected
protected
needs synchronized
purpose METHOD_1 method allow extenders overwrite implementation instead : ( VAR_1 = = null ) { VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ;
private
package visible
context sync obj
remove
want potential NPE ? checks VAR_1 ! = null a null VAR_1 caught catch I d argue VAR_2 = = null result VAR_3 cases VAR_1 null
don t VAR_3 needed VAR_4 artifact readable
METHOD_3 ( VAR_1 )
protected
weird
necessary ? _CODE_ ( ) overriden check a selected image checked
please remove redundant type information another follow commit
a pre - commit listener ( I agree more sense a post - commit listener ) I needs aggregate pre - commit listener meaning invoked commit top - transaction case nested transactions running a refactoring operation ( user interaction time ? ) nested transaction commits
returned
capitals enumeration constant code human - readable ( getName ( ) method )
I _CODE_ arrays boring I dangerous transforming a List : - METHOD_2 ( ) returns null a _CODE_ - turning a list iterate private method decided define a Collection parameter weel receive array parameter = > I recommend array check null case security
remove else branch
changed Arrays asList ( VAR_1 )
trace statements removed
necessary quality rule : MITRE CWE - 397 - declaration throws generic Exception
list empty change VAR_1 select ( erase current editor VAR_1 ) example diagram editor select diagram case
method declared private
add braces - block
replace withboolean VAR_4 = file ! = null ;
A conditionnal test added wizard container ( null ! = )
break - condition continue - condition
System removed
return a boolean
delete pass m
argument constructor
parameter constructor
unnecessary
throw ( don t catch ) exception test fails
import
/ / $NON - NLS - 0$
? pass monitor
move preference page dsf gdb ui change _CODE_ java
I forech loop
overridable createcontrol
lines 1051 - 1053 redundant
unnecessary cast
I instanceof check deleted done METHOD_2
min size MAX_NB avoid io check val = = - 1 return true ;
remove useless assert
remove useless assert
a TYPE_5 instead a HashSet ? VAR_7 usage scenario maintaining linked list TYPE_5 doesn t pay
buttons marked _CODE_ mind ; ) setting a default VAR_4 VAR_4 execute press ENTER prevents root path text _CODE_ execute selection listener a user manually type a path tree update typed - root path false
change VAR_2 METHOD_4 ( ) VAR_2 split ( )
worries VAR_2 left unprotected calls theory modified
reason a METHOD_3 ll user store integer internally ( s true representation ) a call Integer toString create representation
call super ? s a practice I missed memo
I a duplicate METHOD_3 call strictly necessary
assertTrue
empty VAR_3 handled ? condition simpler
I d prefer static imports TYPE_1 improved readability consistency
s reason instantiate TYPE_1 fact add a private constructor TYPE_1
( ) braces - line body
parseInt ( )
I suggest long type autoboxing work
callsuper METHOD_1 ( parent ) ; object a TYPE_3 ? I a bug
null operande
null operande
null check
related ignoring - accessibility / gitconfig
lose parent TYPE_2
list created instantiation a simple clear ( ) sufficient ( creating a new list time )
change ? change declaration TYPE_1 _CODE_ < ANNOTATION_2 ? extends TYPE_1 > METHOD_1 ( ) ; returned METHOD_1 ( ) fits required declaration more warning ( I noticed changed good ! )
redundant class
annotate base method _CODE_
super - method
don t annotate part
don t need variable : ( trace instanceof TYPE_4 ) { return ( ( TYPE_4 ) trace ) METHOD_2 ( ) ; } return TYPE_3 getInstance ( ) ;
long Long case ? s discussion making consistent code base change
VAR_1 VAR_2
debug print
simplify replacing ( x ) { result = true ; } result = x ;
initial null needed a ( ) loop : ) ( TYPE_3 VAR_1 ; ( VAR_1 = VAR_2 METHOD_1 ( ) ) ! = null ; ) { }
return ( sonar rule )
static import Assert * methods
need ? type s a - workspace typed element I d assume instances resources super - class type
need ? type s a - workspace typed element I d assume instances resources super - class type
package removed ; TYPE_4 imported
return null more explicit
change needed
incore merger works memory a working tree need attribute handling
revert
suggest replace : return SWT ;
2 ints ? I don t written header
return i ; break ; need continue loop
array list faster iteration
need
alternative phrase TYPE_2 unpeeled METHOD_3 return - null : TYPE_3 METHOD_3 ( ) { TYPE_3 id = super METHOD_3 ( ) ; assert id ! = null ; / / checked constructorreturn id ; }
T METHOD_6 necessary
doesn t throw TYPE_2 anymore
I suggest access VAR_2 a more direct involving TYPE_4 unnecessary
shouldn t wrap METHOD_5 call ( ) finally block ( e g case NPE )
time I code check method I ve understood : VAR_4 install D&D support METHOD_4 ( ) a guard installed * page * please add break ; method change loop snippet belowif ( ! VAR_1 isEmpty ( ) ) { Object VAR_5 = VAR_1 iterator ( ) ; }
protected
doesn t line produce a raw type warning
return url
visible
I don t constructors throwing exceptions I check _CODE_ ( ) constructor access changed private
invert = = 0
protected package protected private
remove package visible
shouldn t check
Boolean toString
remove call METHOD_5
synchronized
assertion needed anymore
assertion needed anymore
I ve set VAR_1 METHOD_1 constructor case pretty dead code
a static import TYPE_4 METHOD_4 class
a 2nd statusless execute function ? doesn t safety overridden execute ( )
optional : new ArrayList < > ( )
a check viewer ? shouldn t VAR_4 ? table
a check viewer ? shouldn t VAR_2 ? table
please remove System calls code
protected
please add a check simply return VAR_1 set current foreground VAR_1 ( VAR_3 )
default false existing behavior mars dialogs
needed
I ! ENTRY org eclipse ui 4 4 2016 - 01 - 11 20 : 56 : 17 129 ! MESSAGE create action delegate id : org eclipse egit ui actionpullwithoptions ! SUBENTRY 1 org eclipse equinox registry 4 1 2016 - 01 - 11 20 : 56 : 17 129 ! MESSAGE plug - org eclipse egit ui unable instantiate class org eclipse egit ui internal actions TYPE_2 ! STACK 0java lang _CODE_ : Class org eclipse core internal registry osgi _CODE_ access a member class org eclipse egit ui internal actions TYPE_2 modifiers protected public
adding megumi s : consider initializing true possibly collapsing methods argument
remove throws Exception
s / c / cmd /
VAR_1 ? list returned unprotected return unmodifiable list created setting
put VAR_2 METHOD_2 ( ) a local variable
instead ! = null a instanceof TYPE_2 shouldn t _CODE_ avoid error
call super ( )
return result
notion reopening apply threaded backend - open - threaded backend future insertions I d tempted super ( false ) run tests ( )
assertNotNull VAR_4
expected
purpose METHOD_1 ( TYPE_1 ) ? weird need filter _CODE_ METHOD_5 METHOD_3 other numerous _CODE_ extensions filter interested instead
want return set case s behavior List
root _CODE_ instead
check VAR_1 isEmpty ( ) continuing other checks eliminating need null checks
s create new API instead _CODE_ ( ) set a member variable store launch method private
VAR_1 METHOD_2 ( ) other extension points
I don t return null add external annotation
t remove call
call METHOD_6 ( ) instead
call method 4 5 : = = > return METHOD_1 ( file true ) ;
remove unnecessary checks
TYPE_1 _CODE_ ( s ) ( String ) instead text equality test catch _CODE_ iterate recursively children items
method added java 8 fail java 7 note compile gerrit compile java 8
VAR_1 t null
Long valueOf ( ) instead new Long ( ) - performance reasons
remove
need ANNOTATION_1
VAR_1 int Math VAR_4 unnecessary need overflow I d Math max ( 0 VAR_1 ) ;
A problem relies zoom thread implementation zoom list thread ( override _CODE_ ( ) return null ) s clear flag completed zoom empty entry list entries filtered work build thread done a iteration called refresh ( ) hasn t discovered entries
format names inconsistent remove duration
_CODE_ ( ) called ( user changes list returned METHOD_2 ( ) ) VAR_1 changed inconsistent
switch equals check ( a equals ( b ) - - > b equals ( a ) ) null - safe potentially faster
editing setter making collection dirty
d want return a read - view VAR_1
VAR_3 METHOD_2 returns null remove VAR_2 = new TYPE_2 ( )
VAR_3 METHOD_2 returns null remove VAR_2 = new TYPE_1 ( )
don t return a continue other VAR_2 add state systems children
false returned
assertTrue instead
written : return super METHOD_1 ( node ) ; consistency
wouldn t implementation apply cases ? a generic utility method defined a default a static method interface
toString ( ) ? output a String I ve pushed a new patch removes reformats some stuff
method external annotation
final
final
final
final
set class variable
artifact intentional ? s interface
synchronized
changes unnecessary builder a separate method setting span substitutions
touching add missing braces ? VAR_1 isEmpty ( )
style : missing braces
added external annotations instead
a guarantee statement a executed preempted statement [ 1 ] null - check VAR_2 s good practice extract a local variable general s a small method fine imo [ 1 ] I remember I a class a looong time I t find references online compiler agree s a bug I m crazy ? : O
add a package - info java file package
I don t VAR_2 returned ( previous entry ) critical path module needs remove line updating file
please interfaces
please interfaces
{ } block please
a real application order events _CODE_ _CODE_ _CODE_ send _CODE_ TYPE_5 _CODE_ requires _CODE_ event call METHOD_3 instead send mouse events TYPE_5
s assuming METHOD_5 cell s bound relative _CODE_ control
I want leave protected user call public METHOD_1 ( ) turn call
avoid assignation ( trace ! = null ) ? trace VAR_5 : _CODE_
I thinking 0 - argument version shouldn t create TYPE_2 d 0 - arg obtain TYPE_1 static methods _CODE_ I d suggest calling default constructor TYPE_4
unrelated patch a good change adds diff noise
block avoid conversions ( String - > int int - > String ) String returned VAR_2 METHOD_4 ( ) ? code ready handle new thread ids change
private
I throws Exception unnecessary
synchronize
_CODE_ case InterruptedException change ? test difference
databindingcontext super class
simply assign
a bit puzzling instanceof necessary
static _CODE_ ( )
redundant
return ( ( VAR_1 & 1 ) = = 0 ) ? VAR_2 : VAR_3 ;
need catch
loaded lazy
lambda
lucene works java7 Path _CODE_ eclipse needed VAR_3 declared string : TYPE_4 ( VAR_3 VAR_4 VAR_5 ) ( similar code a places )
( VAR_1 instanceof TYPE_3 ) { } state code safely today a class cast exception I t condone casting testing type
equals needed
a reason update VAR_2 changes
lambda
belong TYPE_2 create ( ) a shell visible _CODE_ set result _CODE_ ( ) pass values I intermittently a minimum height small height trim reason
unnecessary
NPE passed TYPE_1 part a resource
needed
unsafe VAR_2 protected set null contract return supplier null values rewritten check null
useful method _CODE_
useful method _CODE_
need public static ? method
need public static ? method
new call line unreachable
change : assertEquals ( item ( ) item VAR_3 ( ) req VAR_4 ( item VAR_5 ( ) ) ) ; case fails loop failed
String valueof ( String ) toString ( ) ; ? return string s final
redundant parentheses
please remove debug / log lines
TYPE_3 unwanted synchronization a performance problem I d suggest manually implementing copy - - write pattern a normal ArrayList a boolean list read ( copy omitted intervening read )
changing code instead String [ 0 ] String [ list size ( ) ]
bug 487713#c11 previous revision return path case IOException sense add return statement
false ? title displayed
default preferred size ? I move class implementation specific - 1 - 1 treated default
adding code pretty reverts attempts performance improvements method implies load basic informations detail a revision definitly part
don t need null - check METHOD_3 method
returning empty list default nicer IMHO need null check invoker side
a static reduced : System getProperty ( STRING_1 ) startsWith ( 3 ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ / / $NON - NLS - 3$
needs synchronized I a java util _CODE_ closing view opening a trace
general initialization field declaration lost adding another constructor
parentheses please ; ) return ( VAR_1 = = null ? null : Long valueOf ( VAR_1 METHOD_2 ( ) ) ) ;
empty string null preferable
elvis notation
ArrayList < >
VAR_1 equals ( VAR_3 METHOD_4 ( ) )
replaced List < TYPE_2 Entry > VAR_4 = TYPE_3 METHOD_2 ( VAR_2 iterator ( ) ) ;
result = VAR_1 * result + ( ( VAR_3 = = null ) ? 0 : ( VAR_3 METHOD_2 ( ) + 1 ) ) ;
toolbar menu initialization calls required ? especially actions commands
wrong VAR_1 > = 0 s impossible disable clean currently set 0 ( NO_CLEANUP ) METHOD_1 returns 1 / 10 VAR_3 instead 0 follow change ( ) adding test cases fix problem please squash change
please { } blocks
check null
sort tasks scheduled specific days week tasks scheduled week scheduled day week date
done super _CODE_ ( ) clean variables ( included VAR_1 set null )
creates a deprecated warning - deprecated API
return ! VAR_1 METHOD_1 ( id ) isEmpty ( ) ; _CODE_ java
return / break early match intended continue possibly find others ( return )
need ? _CODE_ fall config checking pull ff sufficient
sollte sich gleich verhalten wie _CODE_ ( f ) der macht gleich ein _CODE_ ( ) ist sonst wahrscheinlich etwas verwirrend wenn sich die beiden methoden der hinsicht unterschiedlich verhalten und noch ein punkt : muss die method tatsächlich auf dem interface sein ? könnte man sie nicht einfach intern der impl von METHOD_3 ( ) aufrufen ? oder gibt es fälle wo man METHOD_3 machen möchte aber die _CODE_ bewusst unangetastet lässt
private
replace true moment discussed genevieve
I d inline variable
implementation TYPE_2 METHOD_3 ( ) ( _CODE_ ) expensive sense cache result VAR_3 METHOD_3 ( ) a local variable deal symbolic VAR_1
due null test need retest null return statement
short return o - > o ;
ImmutableList VAR_1 ( ) constructor return list ensure constrcutor s caller modify list stored class
forEach a List : VAR_2 forEach ( VAR_1 - > VAR_1 METHOD_1 ( obj ) ) ; work difference functional syntax fit rest imo
annotate instead
unnecessary caller invokes empty set VAR_3 size ( ) < VAR_4 shouldn t need redundant check
equally convenient ! VAR_1 alas API change I more consistent caller responsible handling ( a followup change a method sets destination src unset more convenient )
method API doesn t exist SWT nebula _CODE_ public method toString
return element instanceof TYPE_4 && ( ( TYPE_4 ) element ) _CODE_ ( ) ;
check null case
lets reduce API private assert VAR_2 ! = null
remove 7 11 50 condition GDB 7 12
I ve added a check null case some extender replaced _CODE_ serviceand implement _CODE_
typical - case a single session / console disabled user button I confusing enable widget a single console ? display selected console doesn t shed more light situation appears select single session case : )
_CODE_ ( ) load ( ) method throw exception TYPE_5 a wrapper allows catching potential exceptions thrown load ( )
simplify dealing exceptional case : ( ! VAR_1 ) { / / reading push options a prior _CODE_ ( true ) / / call doesn t sense throw new IllegalStateException ( ) ; } ( VAR_2 = = null ) { / / push options receive ( ) called throw new TYPE_1 ( ) ; } ( VAR_3 = = null ) { / / client doesn t support push options return null distinguish / / case client declared support push / / options empty list return null ; } return Collections VAR_4 ( VAR_3 ) ;
null operande
VAR_2 doesn t
put line add exception message
please syntax casts done else project : return ( ( TYPE_2 ) object ) METHOD_1 ( ) ;
done
done
want enable customizing _CODE_ PS
please fields final
move 244 rid extra check
VAR_5 hard deleted ? I thought _CODE_ file _CODE_ true VAR_3 | VAR_5 METHOD_3 VAR_3
enums = = instead
necessary ? shouldn t join refines ? removing refines desired included test
url = _CODE_ + VAR_6 shouldn t full URL place API key
super _CODE_ executed test code
please add ( VAR_4 ! = null &&
_CODE_ invert operande
checks element METHOD_7 ( file table doesn t show folder s files ) doesn t UI I fixed TYPE_4 _CODE_ ( )
static
METHOD_4 takes _CODE_ need cast viewer need a local variable
super ( ) storing VAR_2 need store copy
cases evaluates false
shoudn t change active image instead disable action notice METHOD_1 button pressed icon currently disabled press button calling _CODE_ ( false ) actuallydisable action
I don t necessary
don t need ternary operator : parenthesized boolean expression result checked collaboration a < < protocol > > start
provide a method require caller pass null _CODE_
need check hint null
return case
please avoid unnecessarily nesting blocks method written : ( getName ( ) = = null ) { return METHOD_1 ( ) ; } else ( METHOD_1 ( ) = = null ) { return getName ( ) ; } else ( getName ( ) equals ( METHOD_1 ( ) ) ) { return getName ( ) ; } else { return getName ( ) + STRING_1 + METHOD_1 ( ) + STRING_2 ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ }
access thiss indicator disposed ? fail other branch
simply objects METHOD_1 ( VAR_2 )
done
done
point disallowing cheap ( _CODE_ - based ) inverse navigation ? checking switch case rely index navigate backards
a test spawn a separate VAR_4 VAR_5 ( a new window ? ) close VAR_2 VAR_3
creates a warning
removed
finally block needed calling monitor VAR_3 ( ) required
method doesn t advance monitor
isEmpty ( ) VAR_1 = = null return METHOD_2 code a null Object - intended behavior ? - getClass ( ) VAR_3 ( ) instead
assignment effect
return VAR_1
I result call change time improve code keeping TYPE_2 instance variable needed request everytime
hamcrest matchers
new HashSet < >
new TYPE_2 < >
modern loop
catch Exception
store String [ ] open ( ) _CODE_ ( ) return item array
I shouldn t finish writing history add _CODE_ VAR_2 ? couldn t new output writtento page _CODE_ TYPE_2 finished
triggers _CODE_ _CODE_ ( ) size image based constructors lead NPE descriptor - based data creates a _CODE_ object ( parent )
wrong CP error : ) check VAR_2
explain a bit more detailled s purpose loop ? I miss bigger context : I haven t idea cache intends care TYPE_3 refcount explained
VAR_1 null ? a null check call METHOD_2 ( ) order
closed
isn t enough declare Exception ? exception fail test specific type
write simpler ? ( = = null ) { return ; } ( VAR_1 _CODE_ ( key ) ) { ( ! TYPE_2 METHOD_2 ( VAR_2 ) ) {
method return null ? return statement
unused
inline variable
necessary IOException argument I e entire block replaced a single throw new IOException ( ) creating instance setting throwing example change I
a single return instead
I LOVE
final
write : TYPE_1 VAR_3 = VAR_2 METHOD_5 ( ) ; ( VAR_3 = = null ) { } return VAR_3 ;
please wrap long condition readable
I don t need TYPE_1
I line create overflows segments negative start times ( tree start )
shouldn t necessary anymore
Log messages generally english strings translation bundles Messages written log intended read eclipse developers user
unnecessary else blocks return
protected
especially long - > int - > long
VAR_3 METHOD_2 ( 1000 ) ;
TYPE_2 unnecessary
I propose a common pin implementation base class _CODE_ note existing implementation class inhibits changes coming external doesn t prevent VAR_1 call stack view broadcasting a new window range
remove ? true : false
return Integer parseInt ( TYPE_2 TYPE_3 getString ( STRING_1 ) ) ; / / $NON - NLS - 1$
_CODE_ x y coordinates scaled expected
change : return new TYPE_1 ( ) VAR_1 ( STRING_1 VAR_2 ) VAR_1 ( STRING_2 VAR_3 ) VAR_1 ( STRING_3 VAR_4 ) VAR_1 ( STRING_4 VAR_5 ) toString ( ) ;
shorter version ? TYPE_1 listener = TYPE_1 METHOD_2 ( event - > VAR_1 = true ) ;
final
final
need call session VAR_4 ( ) executor call executor
VAR_6 registered clearable
want protected
steps reversed
I sense check calling TYPE_2 TYPE_2 wouldn t constructor a place enforce ? 2D query patch genevieve suggested enforcing constructor METHOD_2 / max instead
missing braces
please declare method METHOD_8 ( List < ? extends TYPE_5 > ) remove cast ( TYPE_5 )
logic org eclipse sirius diagram ui tools api decoration _CODE_ _CODE_ ( _CODE_ ) expected
missing braces
missing braces
consider a null TYPE_1 a valid _CODE_ ? avoid null tests ( performed _CODE_ ( ) operation )
anti - pattern a StringBuilder instead comma instead |
other methods put id switch consistency
I s done plenty other places code base I prefer parameter assignment
recheck condition 0 < = VAR_1 && VAR_1 < METHOD_2 ( ) size ( )
java8 - isation [ forEach ]
return null VAR_3 a valid UML - RT VAR_3 ( missing _CODE_ stereotype application some reason )
VAR_7 log stack trace
private
TYPE_1 < Long >
&& input _CODE_ ( ) ! = null && VAR_1 equals ( input _CODE_ ( ) _CODE_ ( )
space long / * int * / critical replace task
res null expect VAR_3 null
illegal select index 0 > = 0
I remove events
move a default method actual interface thanks java 8
s a recommended practice enclose statement condition curly brackets
a file named pack - 1234idx directory a extension files deleted
consider saving group 1 group 2 matcher
null ! = VAR_3 checked outer
need public ? I caller package
expose API open level prevent crashes / deadlocks
minor check necessary anymore
more sense move VAR_6 check line ? commit ( ) call produce error guarded else condition matched needs check
return false ! super METHOD_1 ( )
return true super METHOD_1 ( parent section attribute editors e g bugzilla attribute section attribute editors a subsection called flags )
remore case
return null
a system validation
tick ( ) : tick ( 1 ) ; return super METHOD_3 ( ) ; TYPE_2 operations call tick VAR_6 a more resilient ( behavior change based number times METHOD_3 called ) TYPE_2 TYPE_4 ? repository db = new TYPE_3 ( VAR_1 ) ; VAR_2 = new TYPE_2 < > ( db new _CODE_ ( db ) VAR_6 ) ;
rename element
rename element
inline VAR_2 METHOD_2 ( )
inline VAR_2 METHOD_2 ( )
inline VAR_2 METHOD_3 ( )
inline VAR_5 METHOD_2 ( )
inline VAR_2 METHOD_2 ( )
unnecessary
rename child
rename child
rename child
inline
need METHOD_3 junit auto METHOD_3 test expected exception thrown
add generic
simpler : ArrayList < T > result = new ArrayList < > ( VAR_1 ) ;
remove
superclass implementation expect action null super implementation some logic context active I don t need plugin XML checking property
private
VAR_1 > 0 implies page - null
I pretty unchecked cast warning I pertinent add a check code more robust
inline return statement
instanceof test avoid calling more costly super : return VAR_1 instanceof TYPE_2 && super VAR_2 ( VAR_1 ) ;
METHOD_4 returns a list ? don t need add another list
necessary cast Class < ? >
remove put line
final
_CODE_ = some point _CODE_ = true
final
METHOD_2 overridable calls other code class control method prevent possibility other code calling object s invalid intermediate state
METHOD_5 check length
simpler : ( ! VAR_1 add ( ) )
Map code more readable e g Map < String String > map = new HashMap < > ( )
_CODE_ constructor instead
return Map instead HashMap
I a question : testing configuration a gerrit config don t break VAR_4 valuenot - init method null cases VAR_4 null
call super return call VAR_1 more VAR_1 null s necessary call super return unexecutable command case proxy null : return request VAR_2 ( ) METHOD_2 ( ) ? TYPE_3 VAR_4 : nullshould enough
point setting path null needed statement
order need reversed ? I don t XY charts test
obsolete accessing a class attribute thread - safe
instanceof check _CODE_
a strange handling cast explicit check VAR_3 instanceof TYPE_4 ? exception thrown catch
1 content size 1
superfluous VAR_2 ( ) side effects
remove s null won t equal VAR_3 s id t null
shouldn t public
attributes TYPE_1 ? a _CODE_ standard allow attributes [ gram stmt ] allows attribute - specifier - seq - block [ gram ] allow attribute - specifier - seq handler - seq handler a bug TYPE_1 a _CODE_ place
optional : imported statically ? I easier read
internal abstract class I assume other parts code bundle implement METHOD_3 ( ) method wouldn t implementations return EMPTY array constant instead catching ? I m concerned impls return null resulting NPE
a breaking change
API reliable notifier a priori _CODE_ type check whethernotification METHOD_6 ( ) = = TYPE_4 TYPE_3 port__is_conjugatedthe METHOD_2 API employed notifiers aren t objects resources _CODE_
super close ( ) closes VAR_3 ( _CODE_ ) idea TYPE_1 gain a boolean disable behavior
s reasoning making final
! * single * VAR_1 return null more element
need public
explicit toString ( ) unnecessary simply + METHOD_2 ( ) accomplish work METHOD_2 ( ) return null
top
wrong METHOD_3 * * dispatcher jobs jobs current dispatcher
VAR_1 null
assume VAR_1 posix ? test fail a windows machine
method private default API addition
set _adaterfactory null METHOD_2
externalize
return VAR_1 instanceof TYPE_5 ;
don t need condition ( null instance class )
doesn t METHOD_7 VAR_2
( true )
5 VAR_1 need query
unnecessary
please remove debugging sysout
required s annotated
I m base class actions case s necessary base class s TYPE_2
a null loaded version case update test
line returns isEmpty parse
shouldn t filter constructor
TYPE_5 filter ( TYPE_5 METHOD_2 ( bob ) _CODE_ ) ) iterables methods iterables
I link change VAR_2 equals feature issue remarks items
suggestion : reduce a 1 liner : return ( VAR_1 VAR_2 - VAR_2 ) < 0 ? VAR_1 VAR_2 : VAR_2 ;
_CODE_ ( ) collection VAR_2 updated method called don t anymore modules able recreate series need deleted series set _CODE_ delete id provided _CODE_
VAR_2 = VAR_1
base class _CODE_ sets trace _CODE_ ( ) - _CODE_ handles TYPE_7 VAR_2 shouldn t initialize trace ? - _CODE_ initializes trace shouldn t handle TYPE_7 ? - _CODE_ set initial trace changed a new trace selected doesn t matter viewers handle trace change
AIOOB exception doesn t work I clear more broadly viewer clear data
return VAR_1 _CODE_
VAR_3 ( Integer valueOf ( VAR_2 ) )
replace METHOD_1 ( TYPE_3 VAR_5 ) ;
query a single timestamp
length - 1
TYPE_5
invert condition doif ( A instanceof B ) { ( B ) A }
I decided strip trailing slashes caller don t care dir dir / native git behavior I decided _CODE_ more generic implications ignore rules I t overlook
remove sysout
METHOD_5 shouldn t necessary
avoid unnecessary conversion ( possibly rounding error ? ) VAR_1
invert null condition please s necessary call VAR_3 = = null
brackets single statements
return empty list instead null a case
repeated colors
need add list
need intermediate VAR_6 - query line needed
return TYPE_2 TYPE_3 equals ( VAR_1 )
write nullable line don t write
remove
protected
return TYPE_3 equals ( TYPE_2 METHOD_2 ( VAR_1 ) ) work
TYPE_1 VAR_1 ( ) annotated a potential null pointer error eclipse a false positive check null previous line factoring a variable fixes
worth return previous ? doesn t
ternary operator feeling fancy
please delegate other constructor usingthis ( false ) ; constructor body
follow code style braces please
need VAR_3 return VAR_2
practically theoretically handling 2b pixels wide more issues
syso
I size VAR_3 list matters more I d rid check lines 66 - 68 check VAR_3 empty return null size return single compose
I chart viewer responsible presentation provider tree viewer ask chart viewer a series appearance _CODE_ ? ( renamed _CODE_ )
order colors changed switching a trace
please reduce visibility existing fields part change reasons investigate separately reducing visibility
a suggestion want initialize new ArrayList < > ( ) ; avoid a NPE upstream
! ( parent instanceof TYPE_4 ) || parent VAR_3 ( ) = = VAR_1
please enclose / finally put autobuild restore code finally block
please remove
parameter METHOD_2 ( VAR_1 ) instead VAR_1 support dynamic EMF mode ( catching earlier )
need public
a filter applied _CODE_ listeners won t notified case _CODE_ sole owner listener list fire events _CODE_ fire events METHOD_1 ( ) _CODE_ ( ) called
string equals
VAR_1 METHOD_1 ( ) fast immutable tuples VAR_2 _CODE_ obj volatile jump straight METHOD_2 ( ) I matter a lot I guess comparisons happen VAR_1 immutable tuples
condition omitted point VAR_1 false ( condition 121 ) nitpicking code executed times I propose simply put VAR_1 = VAR_3
I d early return ( null ) a simple loop counter variable required : ( TYPE_2 l : VAR_1 ) {
IllegalStateException required ( check performed super call )
return currentmodel ! = null && model = = null
put
static
empty block redundant
instanceof / cast pair strange I d synchronize ( bytecode level synchronized version )
I cast removed
super class implementation working
private
done
introduce a block ( other ifs )
null returned view resolved new cases I more sense return view resolved unresolved callers handle
default need public
cast ( Object ) prevent a deprecation warning
consistent METHOD_1 ( key index )
10
return 0 oids aren t equal ? shouldn t return x case
reason interface specific TYPE_1 ? TYPE_6
true skipped
useful
loop iterates mutable array guarded lock loop guarded fix MT issue need guard inconsistent data array changed synchronized sort * methods entries VAR_2 elements multiple times sorting array easiest fix original issue METHOD_1 ( ) synchronized
final set start method _CODE_ store wrapper cached usage usages LS attempt retry works
ideall super constructor
don t need increment index avoid infinite looping ? avoid VAR_1 VAR_1 ( 0 )
isn t equivalent : _CODE_ = ; _CODE_ = TYPE_1 VAR_7
unfortunate compiler suffixes supposed change cloned cloning avoided passing compiler suffixes constructor a parameter
s clear : _CODE_ return null means _CODE_ doesn t require resolution METHOD_1 true implementation erroneous caused VAR_1 = = null 2 : future wasn t requested future requested null returned ( resolution required ) I need some more details another state variable class distinguish cases
completely useless
monitor avoid confusion parameter nameoptional : block a ternary : monitor = monitor ! = null ? monitor : TYPE_2 VAR_2 ;
disposing trace call
check code : _CODE_ = VAR_1 METHOD_3 ( ) - _CODE_ + 1 ; + 1 missing
docs supposed pass null clear message
METHOD_3 returns need fetch
move a separate commit
shouldn t final a 1st iteration - cases need override
need public ? useful call subclasses protected shouldn t final a 1st iteration - cases need override
rename smth _CODE_
removed field type
case handled nullname2 ! = null ? - 1 : 0
bugs worry file path calling shouldn t able call preload File METHOD_2
STRING_1 equals ( p getValue ( ) ) getValue ( ) yield null
I ll occasion mention kind variable extraction performance hinders readability please avoid ( cluttering performance patches ) simple getters highlighted profilers instrumentation
TYPE_2 equals safe
missing space shortened : VAR_1 = null && selected ;
need
METHOD_2 internally copy entire match set case hybrid matching perform expected
static
static
please { } block I code doesn t new code
move - catch TYPE_2 METHOD_3
append instead +
append instead +
doesn t executed case _CODE_ overrides METHOD_1 ( )
I prefer listener added _CODE_ _CODE_ ( ) listener package TYPE_7 need a _CODE_ ( ) _CODE_ ( ) method
public ? extender annotation I don t I need invoke I d expect underlying framework necssary optimizations
public ? couldn t package visible
VAR_1 equals ( VAR_3 - > VAR_3 getName ( ) )
return false : return trace instanceof TYPE_2 && super METHOD_1 ( trace ) ;
technically null check
unnecessary nested block
remove ternary
long
buffer getString ( )
null ; - ) note text compact assignment
a static method = = check
getName ( ) VAR_2 ( ) return null anonymous class
id
move test package org eclipse egit core op method doesn t need public
unnecessary final
variable entrySet unnecessary ? replaced VAR_3 entrySet ( ) loss efficiency clarity
please ! string isEmpty ( )
please ! string isEmpty ( )
a simple loop ? removing
refuse trimming trace - trimmable subset trimmable traces operation allowed trimmable ? ! _CODE_ ( ) isEmpty ( )
I good enough s active
move ? composite set config
4 ? I don t 25% early startup bundles eclipse expensive obtain front correct number ? undue effort
public final
missing braces
4 lines deleted
calculating character count iteration calculate required size advance
call new method null parameter
optional : I easier understand reversed _CODE_ more consistent _CODE_
I clear map some field null leads code NPE s sooner
please guard map concurrent access Iterator values ( ) call cry map changed ifrom another thread METHOD_4 ( called threads )
missing curly braces
put check config = = null METHOD_2 config = = null METHOD_2 return false
necessary ? I remove update line work
necessary ? I remove update line work
return boolean literal statements wrapped - - else simplified noncompliant code exampleif ( expression ) { return true ; } else { return false ; } compliant solutionreturn expression ;
turn ? I guess type check faster a METHOD_2
don t need check actionbar null
constructors private
need
public
protected
leaks _CODE_
a new issue worth fixing : leaks _CODE_
please remove redundant braces
null check late : METHOD_2 ( ) returns null call METHOD_3 ( ) previous line throw a _CODE_
private
call other constructor
done _CODE_ therefor needed
method add remove scheme method reflect
remove METHOD_5 call method
I avoid trace set altogether experiment opened traces collection
differ stays suspended testing shouldn t assertTrue
doesn t VAR_1 equals ( VAR_2 ) work
sufficient write : METHOD_2 ( VAR_2 ) ;
please add requested offset : throw new TYPE_3 ( Integer toString ( offset ) ) ;
I m distinguishing cases simpler a single function METHOD_1 ( ) checks
method belong _CODE_ global timestamp precision file
I return file caller handle close ( VAR_1 METHOD_2 ( ) toString ( ) METHOD_3 ( VAR_2 ) ) { return new TYPE_3 ( VAR_1 ) ; } return new TYPE_4 ( VAR_1 ) ;
remove ANNOTATION_1 annotation
please note ignores product default settings good
local variable results a warning
I d VAR_2 METHOD_2 ( event _CODE_ ( ) )
private reason expose helper more strictly necessary
version 3 I
sense move METHOD_6 call ? METHOD_6 throw properly unset
NPE TYPE_3 METHOD_4 ( ) returns null I reverse equals target VAR_2 equals ( VAR_3 METHOD_3 ( TYPE_3 class ) METHOD_4 ( ) ) scale large numbers bundles a hotspot code consider org osgi framework wiring _CODE_ _CODE_ ( requirement ) osgi identity namespace requirement I recall correctly virgo equinox regions hiding bundles a TYPE_2 perspective _CODE_ _CODE_ bypass equinox region hooks need aware
coding rule applies java code null lhs
missing braces
I VAR_2 null org eclipse ltk core refactoring TYPE_1 merge ( TYPE_1 )
s policy curly braces _CODE_ ? _CODE_ require
( VAR_1 = = null ) { VAR_1 = TYPE_3 VAR_6 METHOD_2 ( ) ; VAR_1 METHOD_3 ( TYPE_4 VAR_4 ) ; view VAR_9 ( ) add ( VAR_1 ) ; } VAR_1 METHOD_4 ( ) put ( TYPE_2 VAR_8 null ) ;
I call super METHOD_1
- set zero
VAR_3 isEmpty ( ) ? _CODE_ List < String > METHOD_3 ( ) returning Collections _CODE_ ( ) instead null test VAR_3 isEmpty ( )
lambda
aboutresults values ( ) stream ( ) METHOD_2 ( )
results keySet ( ) stream ( ) METHOD_2 ( )
need special case ? else case unconditionally ( calling METHOD_1 ( new String [ ] { } ) produce empty list )
A more cases discussed review : * a test METHOD_2 ( ) ? * ordering result ? s defined _CODE_ ? * overlapping prefixes
SWT requires 3 4 guard removed
modifying generated code risky extend _CODE_ ( a _CODE_ ) instantiate custom parts org eclipse papyrus uml diagram sequence providers _CODE_ _CODE_ modified
please seto true : true tests false users true default
I don t method return a context usage s clear a return
type
heck painting columns ? need draw column 1 graphical commit tree suggests a nice - liner fix : replace byevent index = = 1and
throws AIOOB exception called index = line count
static
methods protected move VAR_2 soly algorithmgroup class override methods
time decremented
spirit defensive programming I easiest METHOD_4 ( ) call METHOD_2 ( hard - - reproduce issues due a caller leaving some state VAR_6 )
ack
lets check java allows uppercase literals accept
need trace
I don t example valid
e getMessage ( )
e getMessage ( )
remove METHOD_2 external annotation Collections VAR_2 ( )
line untested happen ? result a stack overflow calls parameters
new TYPE_2 ( ) ; work
adds caps a time
shouldn t expression negated
needs negated
OOPS
equivalent
equivalent || &&
equivalent
equivalent
equivalent && ||
a left - char [ ] constant jdt core ? I suggest a regular String constant class
cast needed equals
shouldn t synchronized
I code cast ? result type long good I
idem
e getValue ( ) = = null
parameter replace hard coded texts
shouldn t set _CODE_ instead
action set _CODE_ depending VAR_1 : * VAR_1 remain a variable instead a field * condition useless return action
set number implementation 0 I suggest set _CODE_ ( ) result
I don t a SWT TYPE_6 event I click a - empty selection clicking clears selection
couldn t assertEquals ( ) instead reports case failur
I context finder list classloading order
I s unnecessary method synchronized
couldn t timeout check implmented TYPE_3 ( a parent ) instead ? allow easier reuse
merged line
please add curly braces { } single - line bodies I code doesn t new code require years add change don t change other ifs source
break ( applies _CODE_ )
exception
VAR_1 instead creating object
start 2
arguments order previous example L347 order correct ? s a cleanup others
assert invalid shouldn t passed encapsulate field dialog doesn t allow empty string shows error ( message properly referenced shows id instead message )
s modify classes method implement buffered writing
I NPE s
shouldn t : VAR_5 METHOD_2 ( true ) ;
nice add kind values expected
super ( ) returns null differ
I agree done TBP preserve compatibility compatibility desired move caller
aren t feeding _CODE_ callback methods remove line - - fetching event freeing reason : )
remove
consider Arrays asList ( xxx yyy zzz ) ;
variable reason include calling a - void method doesn t require catching return object typically satisfy findbugs : ( VAR_2 = = null ) { VAR_2 = session VAR_4 ( VAR_1 getId ( ) ) ; return VAR_3 METHOD_2 ( VAR_1 getId ( ) VAR_2 ) ; } return VAR_2 ;
String format takes arguments ? select picked actual class treated a string some reason
VAR_2 null call METHOD_3 ( )
null returns
combined line
VAR_3 unused
parent null need check setting parent switch _CODE_
I don t need invent AST node evaluation level add _CODE_ _CODE_ ( ) implementation : ( _CODE_ ( ) ! = null ) { return _CODE_ ( ) _CODE_ ( ) ; } ( _CODE_ ( ) = = TYPE_2 VAR_3 ) { return / * _CODE_ STRING_1 * / ; } return null ; _CODE_ ( ) instead _CODE_ ( ) _CODE_ ( ) creating function types
s VAR_2 result ( VAR_2 noexcept ) && ( arg1 noexcept ) && ( arg2 noexcept )
( VAR_4 noexcept ) && ( argument noexcept )
VAR_2 ( ) needs a null check
TYPE_2 ? ( s dependent case a _CODE_ ? )
else throw e
instead : ( VAR_2 = = null ) { VAR_2 = new ArrayList < > ( ) ; VAR_3 put ( VAR_1 VAR_2 ) ; } VAR_2 add ( method ) ;
I m unsure operator priority I guess people please wrap 2nd term && parenthesis remove form doubt
I _CODE_ delete project test file put test method
calling METHOD_2 ( ) ? a avoid
mentioned happen
VAR_3 METHOD_5 ( ) NPE line question t resolve bindings TYPE_1 METHOD_3 ( ) return null especially s plenty errors local METHOD_3 ( ) checks s fine VAR_3 METHOD_5 ( ) fail
implementing classes able override method stuff prepare workspace static
part move _CODE_ ( ) project deleted test created
inline instead
s - static - private s a function useful line
slightly shorter : ( info VAR_1 = = null ) { info VAR_1 = TYPE_2 VAR_1 ( info method ) ; } return info VAR_1 ;
case a resource ? weren t previously setting resource input change break existing clients _CODE_ class especially subclasses
static
loop
method need return a boolean type returns true
shouldn t pass _CODE_ DEFAULT_EXPERIMENT_TYPE instead
special code null ( comparing size size hash map )
else blocks unnecessary write result = VAR_1
new API I d prefer return java util Optional < T > instead null avoid potential _CODE_
simply result = VAR_1 changed _CODE_ ( ) mehtod manage null
simply set result null
I s move METHOD_2 method ? moment caller ( L360 ) future called else patch won t effective
necessary VAR_1 UI thread
TYPE_9 : : new remove local variable VAR_5 altogether
simplydefault : return null ; removing line 129 a bit shorter more regular
redundant instanceof check
answer question : I don t I legitimate reasons compare type - type template arguments thinking example tricky : template < typename T > void foo ( ) ; / / overload template parameter kind s valid template < int I > void foo ( ) ; template < typename T > auto bar ( ) - > decltype ( foo < T > ( ) ) ; / / declaration matching code need compare / / template argument lists < T > < T ( ) > determine / / a redeclaration overload template < typename T > auto bar ( ) - > decltype ( foo < T ( ) > ( ) ) ;
perform operation custom TYPE_3 METHOD_4 ( ) method instead
perform operation custom TYPE_3 METHOD_2 ( ) method instead
I thought s a TYPE_1 doesn t a row model ? a TYPE_1 ? cast TYPE_1
method a simple converter dependent frequency dependent clock offset return VAR_1 * clock _CODE_ ( ) VAR_1 clock null
other class d invert condition readability
style : tabs spaces inconsistent surrounding code
move statement
shouldn t METHOD_3 VAR_3 step
sense assertEquals actual failing case
pattern egit sources s code duplication I m a big fan implemented constructor constructor chaining call other constructor please
please invert conditional operator rid negation
exception
space catch
rename exception
{ } blocks
VAR_3 ( )
default
necessary ? tree collapse
I reason compiler error created : uninterned types _CODE_ _CODE_ compared = = / ! = operators discussion safe
rename url variable location simply variable url foreach loop
rename s string
lars cry TYPE_1 21 century ? ( I copy / paste )
I start selection wrong I problem caret position part bug fix implementation call METHOD_1 ( false )
rename conf / config
I guess ||
remove
remove
case null return empty array
lines 82 86 collapse : String VAR_4 = VAR_2 + VAR_1 METHOD_3 ( ) ;
proposed change : METHOD_4 ( VAR_1 = = null )
builders want external code create new entries content constructor private protected
a method reference
I don t need TYPE_3 injected _CODE_
extra parentheses
method static
add contructor ? List VAR_2 = new ArrayList ( Arrays asList ( VAR_5 METHOD_2 ( VAR_1 ) ) ) ;
bug
setting true initially won t effect codan builder added property changes _CODE_ I m impose a big change behavior
change neededit create 2 lists array - - list conversion needed
10 threads I reproduce bug
rename field
rename f
rename type
rename res
String valueOf ( VAR_5 ) equivalent _CODE_ remove a warning
instead casting t omit L
called UI I replace threadlocal a simple boolean
method ref
I suggest invoke ( VAR_2 wight 1 VAR_4 parent )
andrey s question clock sync NFS machine java code runs relevant
remove line : )
question : limitation TYPE_5 wanted nad / necessary ? a user other types projects open e g part a research prototype
legal : collections VAR_4 returns a - modifiable empty map ( empty map ) invoking put fail maps a single element Collections _CODE_ ( ) return a - modifiable map note highlighting trap java language API
active properties
enclosed ( VAR_2 ) method
happen ? check null stop
I suggest reset VAR_3 null
necessary
constructor action class
reason calling super ? I thought calling super METHOD_1 a common practice ( some other code METHOD_1 method requires some fields disposed a call )
foreach
unused
remove unthrown exception
change necessary ? breaking s functionality
itthis ( resource ) ; VAR_4 METHOD_3 ( VAR_2 ) ; improve factorization
don t need repeat lines 67 69 70 invoked ( resource ) : ( ) invokes other constructor need repeat s content
instead calling 2 setters invoking _CODE_ care fixing button enablement
please don t System production code ; )
static added doesn t rely instance class
don t want TYPE_9 TYPE_8 want able select version
missing type parameter causing warnings : TYPE_2 Builder < TYPE_1 > builder = new TYPE_2 Builder < > ( VAR_2 size ( ) ) ;
hm need a bit more exception handling report config invalid case VAR_1 null I TYPE_3 s message include file
METHOD_2 ( ) needed anymore need catch RuntimeException
I _CODE_ server cache instance static instances a interval cache instance _CODE_ instance new simpler methods _CODE_ ( ) _CODE_ ( ) _CODE_ separate class
propagate IOE TYPE_2 instead translating RuntimeException ? I m happy translation - - unclear effects propagate checked exceptions caller callers catch IOE TYPE_2 METHOD_3 ( )
true thoughtless inlining
put condition ? ( input instanceof TYPE_2 && ( ( TYPE_2 ) input ) METHOD_2 ( ) instanceof TYPE_1 )
change List < TYPE_1 > API fixed
VAR_4
? I METHOD_2 ( ) returns true a job scheduled
products ID workspace fallback instead empty string
call ? VAR_3 empty VAR_5 method running ? element added VAR_3 METHOD_2 called method ? I miss some case
A pedant check ereference - - containment root container check navigates model : - )
METHOD_2 ( ) return null ? case uncaught exception
lists initialised ? worthwhile put a null check
missing braces
missing braces
I ist enough close tracker heres triger _CODE_ line 198 remove listeners
remove unnecessary else clause
order VAR_10 order s successful
child
needed
child
child
child
remove exists variable justreturn ! TYPE_4 isEmpty ( ) ;
return false caseuse multi - catchcatch ( TYPE_5 | IOException e ) { return false ; }
necessary + operator a string operand ( prefix ) performs auto - stringification other operand
I intention clearer avoid VAR_2 variable write : VAR_3 METHOD_5 ( METHOD_2 ( ) ) ;
System jobs cancelled users I user job cancelled progress view
return new TYPE_3 ( VAR_1 ) ;
map entrySet ( ) iterator ( ) ( ) a bit more idiomatic a loop unconditional return
switch
code wrong shoulkd VAR_1 objects null check reliable ( wrong null check ) locking a new Object ( ) sense - VAR_1 * * current thread local object instance
null ? means locks throw NPE ? accessing object synchronized lock ? I don t strategy : object set null T SYNCHRONIZATION please null objects synchronization
I m worrying locks acquired acquire pending VAR_1 notify acquire VAR_1
I don t place set VAR_1 null access other places null check null job introduce checks remove check
I ve mentioned : highly unusual suoer METHOD_1 ( ) called * * child METHOD_1 surely change I sense cleanup
METHOD_2 ( ) need sync block ? acquire another lock holding VAR_3 lock danger
3 13 missing
necessary simply call _CODE_ ( true ) viewer
point _CODE_ bring added compared a volatile variable
don t need parens
return
I don t logic require special support tuples
missing stacktrace
missing stacktrace
instead pure declaration VAR_1 top returns body nicer imho
intention attempt modify info plist another app remove registration other app manually platform pref page provides a hint user
don t throw exception a lot exception stack traces printed screen stored log file easy user miss usage message printed I suggest find a exit application t call TYPE_2 getInstance ( ) parse ( TYPE_3 METHOD_1 ( ) ) ; application java exit needed ? I don t reason s done activator class
s confused eventually static method named other ? static run ( ) calls instance execute static execute ( ) calls instance run avoid confusion eventually 2 methods identically ? confuse compiler ? BTW : class I thought describing lambda idea
class private
combine lines - > TYPE_1 VAR_2 = VAR_1 METHOD_2 ( ) ;
remove
calling _CODE_ ( boolean fixed ) override _CODE_ ( ) ? a thought
returns a view transient state transient e g changes transient state visible user method I don t s ? _CODE_ * ( ) methods _CODE_ instead _CODE_
rename element
null = = VAR_1
rename VAR_3
loopvar
shell disposed teardown
loop var ; VAR_1 typed
loop var
loop var
loop var
rename key
rename entry
a repository converted reftable git / HEAD ? shouldn t deleted _CODE_ ( )
exception thrown compilation failure : org eclipse jgit test / tst / org / eclipse / jgit / internal / storage / file / _CODE_ java : [ 507 17333 ] declared exception IOException thrown method METHOD_1 ( ) type _CODE_
INT_1 ? a legitimate notification count fonts misread 01 ( zero ) instead return apublic static final long NOT_ATTACHED = - 1l ;
rename key
class doesn t exist
wouldn t break undo
add braces
List < Object >
null = = VAR_1
another nitpick : ) replaced return VAR_1 METHOD_2 ( ) > = TYPE_1 VAR_6
return VAR_1 METHOD_3 ( ) ; a reason skipping VAR_1 METHOD_2 ( ) = = TYPE_1 VAR_6 ? [ consider case called < 14 levels ]
nitpick : return < cond > sufficient
rename f
rename path
rename type
else removed
I 10 000 events call worked ( 1 ) 100 times
correct I suggest a index i starting 1 report 1 unit work _CODE_ > VAR_10 * i / factor incrementing i time factor VAR_10 clampled [ 1 VAR_12 ] case VAR_10 < VAR_12 0 factor TYPE_4 s number ticks
private
method reference
ANNOTATION_1 forces test a null check a unit test acceptable fail a _CODE_ expected
remove
more - 3
sort - unrelated change
subtask ! = task lines : TYPE_4 METHOD_3 ( monitor / title / 1 ) ; ( other cases marked ditto2 )
personally I findindex < 0simpler parse
move return null ; catch - block a bit clearer IMHO
deprecate
personal style part - constructor super ( ) - ( true false )
s benefit Optional instead returning null ? a caller s life easier ? I suspect instead simply checking null a caller Optional isPresent checks ( hidden _CODE_ a lambda thrown additional complexity )
TYPE_3 - clause
invoking null argument evil please provide another method arguments sense
invoking null argument evil please provide another method arguments sense
brackets
add braces modified line block follow formatting rules
wouldn t a call new constructor = null nicer ? ( VAR_2 _CODE_ METHOD_1 ( ) size ( ) - 1 null ) ;
algorithm command I calling new constructor values nice cool new logic new constructor
changes _CODE_ ( ) methods fact a property _CODE_ - public _CODE_ ( TYPE_1 t ) { VAR_4 = - > add modifier | =
incorrect - record instantiated
VAR_1 isEmpty ( )
decide other ? I d move throw default case
missing whitespace = = missing { } trailing whitespace
don t need access iterator : ( Long VAR_7 : VAR_4 METHOD_2 ( ) METHOD_3 ( TYPE_4 TYPE_5 VAR_1 VAR_2 getId ( ) ) { }
! VAR_1 isEmpty ( ) clearer
null ! = VAR_1
null ! = VAR_1
t change message ll apply calls error ( int Throwable ) instead error ( ) String arg
{ } ommited single statement
safer VAR_2 addAll class content externally modified
_CODE_ sublass IOException - > remove
misses synchronized block problem change fix
1 more natural
call equals constant
call constant
call equals constant
order operands
call equals constant
call equals constant
filtering applied received TYPE_2 a VAR_5
original code increased VAR_2 ? spaces
please add { }
needed a decouple more don t need pass o e VAR_3 class ? adapter resolver consumer
remove lambda
METHOD_4 method
break ; loop
_CODE_ done VAR_2 ! = null moved ( manger ! = null )
original version closed close
handle cocoa carbon remove carbon flymaybe change STRING_2 STRING_3 separate change ? carbon unsupported
reached ? a lambda declarator _CODE_ _CODE_ overrides METHOD_1 ( )
method doesn t return actual line VAR_5 more estimation s IMO want method expected return correct multiple places want deal average VAR_5 please introduce a new method s suitable
delegate new constructor
unnecessary
rearranging method more readable ? ( METHOD_2 ( VAR_1 ) ) { return ; } ( VAR_3 < = 1 ) { / / _CODE_ ( ) ; }
needed ? don t add other elements parent ( _CODE_ ) return null
replaced TYPE_1 : : new
VAR_1 argument
VAR_1 argument
case I deprecate constructor add _CODE_ boolean
background loading reason loading done constructor ( a separate thread ) ? I thought compared loading content view entries expensive measure time lost - time initialization
done background METHOD_1 - calls replaced simple _CODE_ ( ) calls
inline call
case readability improved imho - other case clear
model GEF VAR_1 null editpart created a null VAR_1 editpart creates figure - > tooltip figure
a METHOD_2 ( ) METHOD_3 ( ) other edits
_CODE_
a resource heretry ( TYPE_2 writer = new TYPE_3 ( new TYPE_4 ( file ) VAR_1 ) ; ) { writer write ( content ) ; }
haven t write lambda beginning starts another class lambda mass change
argument constructor called instead : ( true )
minor need call VAR_1 METHOD_2 ( ) clean method needs check file exists VAR_3
a new METHOD_2 ( ) method added calls METHOD_2 ( false ) default
simply return null VAR_1 set null a result variable declared
null check removed VAR_1 int
directory doesn t exist bak file won t exist statement removed replaced a check directory exist
a synchronized block METHOD_2 method refactored slightly returns key null
fields custom - role - mapper specific - related mapped - role - mapper subsystem
Arrays equals ( )
redundant - super ( ) called
exists assertEquals ( )
intended return empty TYPE_1 object exception occurs
[ minor ] _CODE_
[ minor ] _CODE_
move TYPE_1 constructor storage rackspace variables final
hmm allow files render correctly ? don t need preserve content types
bit a expression branches pull
[ style ] } catch { ? } finally { ? a big deal - leave prefer
loading background image time map size changes e g unfold operation
I identifier I expect equal null
case put default else part need negation
don t blindly cast - - check returned tile entity TYPE_1 ( change updated )
compare previous comparator level previous amount fluid
removing log fine don t dev
need enable disable ? theory call disable work ( provided direct GL11 calls )
TYPE_2 checks VAR_1 null pos don t need null check replace withjavapublic TYPE_1 METHOD_1 ( ) { return TYPE_2 METHOD_2 ( METHOD_3 ( ) VAR_1 ) ; } won t throw NPE
swapping breaks other GUI s
need { }
I lines a logical rubbish
terrible idea pass proper parameters
a reason t line ? genuinely asking
I likejavareturn new ArrayList < String > ( VAR_2 keySet ( ) ) ; enough
return a copy ? javareturn new ArrayList < TYPE_2 > ( VAR_1 values ( ) ) ;
I need reference evaluation context other functions / methods registered - XD context _CODE_ registered SI default I wanting base a directory based returned _CODE_ needs overloaded ctor XD context contribute standard / shared evaluation context
test methods more simply throws Exception
I variables mixed switched
pass values a string resource avoid formatting strings section
don t need call
I thought allow null args _CODE_ _CODE_ ? shouldn t able construct a _CODE_ _CODE_ null - - I throwing a RuntimeException ( ) statements instead changing
method chain throw exceptions stack bury ? intend handling exceptions handle METHOD_1 ( ) method calls cleaner
yeah I missed double check sparse vector please remove a performance penalty check times
call expensive sparse entries : javadouble = ( i j ) ; ( > max ) { max = ; }
correct I don t reason VAR_2 variable ? I prefer a loop ( equivalent loop clear ) : javafor ( int i = VAR_3 [ j ] ; i < VAR_3 [ j + 1 ] ; i + + ) { VAR_1 apply ( VAR_4 [ i ] j values [ i ] ) ; }
necessary check compressed vector zero guaranteed - zero values store means need rename METHOD_1 _CODE_ class please _CODE_ proper iteration method TIP : METHOD_1
missed space {
other cases line 34 37 necessary
package - private add _CODE_
refactoring good
I s : TYPE_1 VAR_1 = TYPE_4 METHOD_3 ( element TYPE_1 class ) ; return VAR_1 ! = null && VAR_1 METHOD_4 ( ) && METHOD_5 ( VAR_1 ) ? VAR_1 : null ; please lambdas give some gain readability
_CODE_ called element intellij psi _CODE_ doesn t sense invoke super visit *
? o _CODE_ checked checked _CODE_ disabled
super METHOD_1
ternary operator
need ( TYPE_9 class TYPE_10 class TYPE_11 class ) ? some optimization ? I isn t needed
1 ! = comparing2 _CODE_
length checking redundant
_CODE_ setting default values
einfacher : ( TYPE_1 t : VAR_1 ) {
testing METHOD_4 ( ) VAR_2 instance removed altogether
needed ? extractors enough situation
optional null a bit painful another constraint ? test payload business btw ( applying wrapper )
record benefit / catch approach compared _expectedexceptions_ _expectedexceptions_ test shorter harder debug a developer I example set a breakpoint catch clause inspect exception explicit explicit METHOD_3 ( ) additional information
I find METHOD_3 w / o / catch misleading IMO / catch _ _CODE_ _
please don t null pass _CODE_ concatenate
replace return ( ( TYPE_3 ) VAR_1 ) METHOD_3 ( TYPE_5 METHOD_4 ( VAR_2 ) ) ! = null ;
spacing code style
formatting
don t need check null
bad check null equals fields
plase add { } improve readability
missing curly braces ? ( some other places )
toString ( ) call redundant missing white - spaces
_CODE_
wrong
simplified betester METHOD_2 ( ) METHOD_3 ( response - > new TYPE_3 ( new TYPE_4 ( response ) ) ) ;
clear ( ) else clause
else
statement remains valid : ) VAR_2 METHOD_2 ( ) tested nullity
org apache wicket request resource _CODE_ ( java lang Class < ? > java lang String java util locale java lang String java lang String ) cares - null need check
migration easier I good more constructor : public TYPE_3 ( final String VAR_2 final TYPE_1 VAR_3 final _CODE_ < ? > model )
? a reference
please diamond operator ? thank
correct terms isolation objects call needed
changing behaviour previously add result VAR_3
change incur a performance penalty load testing phase
I d returning results instead a variable reassigning
intention place STRING_1 front null check unnecessary ( STRING_1 equalsIgnoreCase ( ) ) { } enough a null problematic set - check return early method null
please braces checkstyle pick
Optional ( represents notion RM ) turn [ lines ] ( ) _CODE_ ( conf ) map ( x - > _CODE_ ( x _CODE_ ) )
? _CODE_ VAR_6 = TYPE_6 METHOD_2 ( TYPE_7 METHOD_3 ( ) VAR_5 ) ;
( null ) { return }
METHOD_2 ? kinda sense I filter event users
METHOD_6 ( 1 ) necessary
sim ready ? METHOD_4 true _CODE_ false METHOD_1 false
nl return
hmm switch VAR_2 a set
iirc static import METHOD_3 other classes
i realised TYPE_2 verification mocking _CODE_ verify ( VAR_1 ) METHOD_5 ( R menu my_menu menu ) ; rid class boolean field another : times static import methods METHOD_2 verify
I assert needed checked other tests
s move initialisation declaration
other places static import METHOD_4 I consistent
checking needed VAR_1 check other test
move line _CODE_ test methods
I class _CODE_ s class risk conflict a _CODE_ weird
scopedobjects_ _CODE_ weird
concat + =
static
I don t throw NPE return null caller METHOD_1 ( )
isn t needed anymore don t virtual row key app prefixed put systems keyspace eventually ll move org - > keyspace lookup system
change code virtual keyspaces other scheme isn t valid longer
cast a string call _CODE_ shortened return ( String ) ( key ) ;
s instance ? shouldn t throw _CODE_ ? a create factory s instance type ? rarely I don t ll need worry cache efficiency
shouldn t throwing ? conditions throw exception fine ignoring
method necessary ? code called place
info noisy s debug
doesn t
I able call instanceof a null ( fail instanceof )
shouldn t 2nd parameter false don t force static initialization
don t swallow exception close
logger a private static final
set null create a default _CODE_
pass null TYPE_2 create a default _CODE_
pass null TYPE_1 create a default _CODE_
s lambda approach
suggestionmapper METHOD_2 ( TYPE_1 : : new ) METHOD_3 ( new TYPE_2 < Map < String String > > ( ) { } ) ;
suggestionreturn VAR_2 METHOD_2 ( TYPE_2 : : new ) METHOD_3 ( VAR_1 TYPE_1 class ) ;
suggestionpublic Optional < String > METHOD_1 ( ANNOTATION_1 String VAR_1 ANNOTATION_1 TYPE_2 VAR_2 ) {
trimming strategy applicable e g password more ( passwords substituted phase )
simplify : return TYPE_4 ( )
null happening ? s directory a stack ( ? ) context
wouldn t new HashSet < > ( ) Collections _CODE_ ( ) need google collections a dependency
code : I local variable VAR_1 unnecessary returned variable shouldn t pre - declared null
compatible existing implementation issues existing mpacks support feature I suggest a property predicate declaration deprecated write a message log encountered
ant : I d StringUtils equals clarity
return VAR_1
trim validate don t trim assigning variables trim trim
build ( ) method necessary I _CODE_ m
a static list
inlined
inlined
a reason protected
I don t need stub
I remove METHOD_2 ( ) doesn t show crowdin
declaring data block
inline : ( - - VAR_5 = = 0 )
logger
please static imports Assert methods
/ else statement instead 0 initial capacity
a note other reviewers ( key ) throw exception key null null check needed I m want more succinct asjavareturn ( key ) toString ( ) ; I m personally a fan local variables
consolidate catch ( InterruptedException | TYPE_3 e )
instead break points I core method wrapped statement combines checks easier read
don t slaves job determine a master a master
blast furnace removed isEmpty ( ) check
don t commit style changes
_CODE_ parameter needed
! TYPE_4 isEmpty ( VAR_2 )
crash VAR_4 size ( ) = = 0 disabled
add bronze instead middle
_CODE_ ( )
I suspect ask master
able avoid compiler warnings raw types phrasing : return type instanceof Class < ? > && ( ( Class < ? > ) type ) METHOD_2 ( ) ; straight - wildcard form a generic type instanceof casts issue
! I find final - izing local vars method parameters introduces noise code provides a benefit I don t find helpful ( assurance values question won t change ) coming another code base opts marking vars final I ll gladly oblige junit - quickcheck other personal projects I lean avoiding declarations I lean static analysis tools _CODE_ checkstyle warn potentially confusing constructs a local modified a lot
pathological case some issues consider a function defined 0 ( s author put constraint ) a generator returns 0 a shrink failure case shrinks useless
yeah I d prefer keeping scope indent long - line indent spaces thanks
convention instead \
I missed completely review a public class a package - private constructor slightly problematic API point view allows class I d suggest public class package - private I d need some more thinking I d public
a reason changing collection hashset
s point String valueOf ( STRING_1 ) ? STRING_1
adjacent VAR_3
StringBuilder
StringBuilder
method ? need a create JSON object add retrieve immediately ? purpose intermediate step
scope PR I don t METHOD_5 ( ) statements needed
Map : : return null key isn’t
methods private some other class call shouldn t
I slightly easier cleaner usefor ( TYPE_3 p : VAR_5 ) { p VAR_6 ( VAR_7 \ * VAR_8 ) ; VAR_1 METHOD_1 ( VAR_3 VAR_2 x VAR_2 y p ) ; }
start editing picture need pass original ? reason need offer option reset changes passing byte stream track date edited version
need a private instance variable future functionality grows TYPE_1 want < code > _CODE_ < / code > function
worth debugging QS
worth debugging QS
worth debugging QS
info
info
info
missing
VAR_1 null
line removed check content method implementation s
doesn t VAR_1 Integer default null s assumption zero a default setting
please remove println
Constants included : method send process variables task want VAR_3 section empty constant empty
please brackets body s a single line BTW install check style plugin IDE configure [ configuration file ] ( )
method scope class don t need a public setter private field
necessary
I remove event null : ve instantiate dit check else
yoshimoto annotations _CODE_ ( ) _CODE_ ( ) public method reduce boilerplate code tests cleanup enough rename METHOD_2 ( ) _CODE_ ( ) annotate
check user endpoints admin execute operation matter
I suggest a process a user task connector check variable updates connector execution
a process a user task allow check variable valued connector execution
please _CODE_ : assertThat ( VAR_2 ) METHOD_3 ( 1 )
assert necessary VAR_2 null s instantiated mockito
removed
yoshimoto endpoint return XML string I expect a client service don t need return a resource
s remove system outs
s remove system outs
assert VAR_2
METHOD_5 ( ) method ? start rid dead code
validated assertion
doesn t sense created instance
I throw IllegalArgumentException
correct alternative ? null
correct alternative ? null
path
TODO : write VAR_1
i minize changes code apparently lots files affected rename logger variable agree I prefer stay previous order minimize number files changed a new log4j2 API improve code readibility / performance parameterized log
kind concurrent access sync ? case prevent multiple invocations METHOD_1 concurrent ? _CODE_ scenario ? sync add / remove writing scenarios iterator protected concurrent modifcation shouldnt synchronize scenarios ? becuase subsequent invocation _CODE_ ? ? _CODE_ synced a concurrent Map
suggestionreturn create ( ) ;
+ / - 1 confusion : suggestionreturn new TYPE_1 Builder ( VAR_1 VAR_2 ) start ( VAR_2 ) ;
+ / - 1 confusion : suggestionthis VAR_1 = start ;
simplified : _CODE_ VAR_7 set ( VAR_6 ) ;
doesn t trigger byte short Long Integer
avoid single line s brackets applies s
i d prefer a blank entry null
wouldn t METHOD_4 ( ) more 0
equals ( TYPE_1 VAR_4 ) don t need bulky null check equals returns false null
forgive I m mistaken pre - populating positions optional s sparse ? store a Map < Integer float > _CODE_ method return float position null wrap optional s returned
shouldn t
= = a reference comparison checking objects point memory location don t compare paths equals ( ) shown example I put recording match TYPE_1 regex ( [ ^A - za - z0 - 9 - _ ] ) METHOD_1 ( ) method returns true comparing object other bugs shown pic a recording exists don t ! [ image ] ( )
### option _CODE_ setting VAR_4 new image set _texture_ new texture wanted fancy a binding bind texture VAR_1 ( index ) _CODE_ texture automatically update set
minor * technically * don t need check VAR_3 METHOD_2 ensures component don t need check null
_CODE_ module causing a compile error
removal public breaks _CODE_ module - generally TYPE_2 other IDE - lack module facade workspace
other similar change class API violations access lessened apparent usages apparent need change : - )
another access change API violation a needed lets change : - )
TYPE_1 added a desired state constructor rely fact enable wireframe don t need statement check presence notice case statement evaluate false creating a new TYPE_1 state change time
s remember remove check check instead result METHOD_3
typical case ? I thought chunks aren t null I d suggest flipping / else block
brackets ifs : D
shouldn t METHOD_3 POST_FBO_REGENERATION event
hmmm I d prefer : ( ! METHOD_1 ) < - - frequent caseif ( VAR_5 ) < - - - unfortunatelyelse / / a screenshot
shouldn t line swapped ELSE block
sketchboard io graph VR screen output nodes parallel dependent VAR_4 processed
I thought checkstyle inform spaces commas configure _CODE_
I m wondering change closes door _CODE_ id GPU - side impossible case terasology
line 103 check VAR_2 null check missing
instanceof ? generally METHOD_2 TYPE_1
- ressources statement
example changes kind track I appreciate don t want change a structuring - - PR point view a commit focused a goal note unnecessary changes a commit
hmmm METHOD_1 ( ) method lean calls a _CODE_ ( ) class default instance METHOD_1 method VAR_2 METHOD_2 ( ) ;
discussed please remind : update ( ) executed example user resize window avoid form memory allocation circumstances s admittedly small case
line VAR_2 variable assignment
s move line METHOD_3 line
move please
move please
s move please
need line ? VAR_9 update ( ) refetched
a minor nitpick a VAR_1 ! = null ; && data VAR_2 ( VAR_1 ) more efficient VAR_1 null programming languages handle ( short circuit logic )
s instantiate TYPE_2 METHOD_1 s _CODE_ initialize ( ) instead bind ( ) line
VAR_2 I presume - s
I wrote issue #2828
change
A ternary statement fine
1 instead assigning a VAR_2 constructor please return formatted string toString ( ) method want original VAR_2 purposes internal log output 2 String format ( ) VAR_2 part format string consistency - i e _CODE_ format ( %s ( %1$dx%2$dx%3$d ) VAR_2 / * * / ) ;
label text static set _CODE_ ui instead ( text : rebinding instead text : title )
I d remove message expand a bit ( i e refreshing info server X )
previous blocks : checks ? time METHOD_1 ( ) called t needed ? applies _CODE_ block
TYPE_3 METHOD_2 ( true true true ) ;
happened ? revert individual checks instead checking map ? case reverse handling block current true case happen
move line TYPE_2 METHOD_8
I m pretty remove necessary default state change task verify enabling / disabling outline works
I case VAR_2 default frame buffer s a minor issue s leave
I m block need ? store VAR_2 VAR_4 need
I reviewed rest PR issues I couldn t find other problem : smiley :
I d return VAR_1 time reasons time I d
I d TYPE_1 statements block disabled doesn t monitored
s boolean a private variable please
a valid spot package private level access instead public ? test package engine - tests ? t recall works
I don t need a line break 120ish chars
linear acceleration quadratic terms position ( i e interpolated ) I suggest a multiplicate VAR_2 instead avoid comparatively costly call Math VAR_1 ( )
method intentionally package - private
I find original version easier read case
I find original version easier read case
I find original version easier read case
I d original version I find easier read s called
I d original version I find easier read s called
METHOD_4 a long parameter ? avoid need downcast reason
brackets please - part code convention : - )
uh put ( ! isEmpty ( ) ) block ? I put TYPE_2 _CODE_ null
I argue empty contract loosened a
a bit odd check return format null return default case
doesn t !
need some braces : )
possibly check entire screen stack
I want set velocity zero
I admit I considered negative numbers min max integer suffer overflow I m matters
I recommend moving line a _CODE_ event handler ( unnecessary )
I suspect lifecycle events ( _CODE_ ) scanning entities _CODE_ frame
recommend method return output TYPE_1 easier
起動時にエラーが発生して _CODE_ が実行される前に METHOD_1 が呼び出されたりしないか ( しても大丈夫かどうか ) 気になりました。
diamond operator ? Map < String Map < String Integer > > VAR_1 = new HashMap < > ( ) ;
I diamond operator
I diamond operator
I diamond operator
check called
VAR_1 null wouldn t want throw exception point ? I noticed points code call function registrar wouldn t want return a null
similar
call function a single Type input instead
run - > status
import TYPE_1
I tend avoid trigraphs absolutely necessary s please ( ) condition || code correct - obvious parts [ precedence chart ( 13 14 ) ] ( ) LGTM
constructor - delegate form instead more concise need put checks need put place e g ( Type VAR_3 String valueOf ( ) )
I rid checks don t save a large amount work need check logging enabled s work function
I d prefer annotation : ( expected = TYPE_3 class )
I d love annotation remove METHOD_3 ( ) part throws exception METHOD_3
a introduce local variable
I suggest c VAR_3 ( ) ! = TYPE_1 VAR_5 instead ! ( c VAR_3 ( ) = = TYPE_1 VAR_5 )
case RECURSION_IN_PROGRESS ? I m need && VAR_1 VAR_5 = = TYPE_3 VAR_6 isn t simpler a bit : TYPE_3 VAR_4 = VAR_5 = = TYPE_3 VAR_6 ? VAR_1 _CODE_ ( ) : TYPE_3 VAR_7 ;
closing method instead caller
I line block guarantee input closed alternatively line order matter
TYPE_1 VAR_2 ( Class ) checks TYPE_1 VAR_4 ( Class ) returns null I suggest checking VAR_3 ! = null avoid double invocation
writer change I don t needs exposed longer
hey i create key _new TYPE_3 ( VAR_1 VAR_4 ) _ acquire lock key VAR_1 id
roll functionality TYPE_1 object start eliminate TYPE_6
isEmpty instead
JSON a JSON ? send json object METHOD_4
sufficient synchronize VAR_5 ? applies _CODE_ method
change
dont need result VAR_8 ( ) = = null condition
additional null check unnecessary return VAR_1 VAR_3 ( )
define VAR_1 public static final String CRED_DIR reused METHOD_1 _CODE_ ? thanks
please operator condition combine statements readability
don t need METHOD_3 called TYPE_5 ( String _CODE_ TYPE_2 table )
METHOD_6 part a finally statement
result implicitly type casted
other removed
required
miss attach _CODE_ class
suggestionedge METHOD_4 ( ) + failed write byte array ) ;
1 executes pieces simultaneously
a WARN instead ERROR
I d argue DEBUG instead ERROR
please change WARN instead ERROR
drop unnecessary
redundant parentheses
redundant parentheses
redundant parentheses
remove line
else redundant
a DEBUG
revert WARN
a WARN instead ERROR
a WARN instead ERROR
a WARN instead ERROR
logger statement reduced debug
toString ( ) left logger performance
simplified : > return VAR_1 ;
variables / members / methods phrase _CODE_ changed code easier follow
VAR_3 initialized 0 instead private member initialized other initialized constructor
doesn t affect result clearer simple bitwise operator ( | ) instead bitwise inclusive assignment operator ( | = )
a logger warn logger error reserved messages affect system stability
please logger instead e VAR_3 ( )
parameterized logging instead string concatenation
length ( )
line null
move null hand side
a foreach ? ( final TYPE_2 range : VAR_1 )
neko inline variable
neko aboutjavanew TYPE_4 ( true ) METHOD_3 ( new TYPE_1 TYPE_5 ( ) METHOD_2 ( ) ) ;
problem slash
? original code work anymore ? I a direct pass - underlying curves
need assign
Arrays stream instead
shortcircuit evaluation avoid - else block : return node VAR_1 ( ) stream ( ) METHOD_2 ( TYPE_2 : : METHOD_3 ) ||node VAR_1 ( ) stream ( ) filter ( child - > ! METHOD_4 ( child ) ) METHOD_2 ( TYPE_2 : : METHOD_1 ) ;
null check unnecessary yoda condition
unneeded null check
[ html spec ] ( ) child < table > element don t need recurse children ( update RSPEC rule )
similar figcaption allowed child
Boolean valueOf instead Boolean VAR_6
return true return false code ( VAR_2 = = null )
missing return true
don t need TYPE_1 METHOD_1
_CODE_ instance
s copies getter call instead simple ref ? normal code : return ref objects create METHOD_2 copy / create method ( ref METHOD_2 - - / )
trigger a multikicked VAR_2 needs trigger separately kick
needs removed
constructor TYPE_5 takes token argument tapped set true
VAR_7 + 1 enough don t need mutate VAR_7
check input ! = null
VAR_2 object instead retrieving
I suggest order consistent easier reading / comparison : * field declarations _CODE_ ( ) * setters / getters _CODE_ ( ) * default values ( lines 751 - 758 ) _CODE_ : : METHOD_1 * assertThat calls ( lines 27 - 33 ) _CODE_ : : should_support_jcasc_from_yaml * setter calls ( lines 40 - 47 ) _CODE_ : : should_support_jcasc_to_yaml
_CODE_ ( ) _CODE_ ( ) simply return VAR_1 ( other getters )
stashnotifier fails a _CODE_ access VAR_6 line 134 explanation I TYPE_1 getInstance ( ) returns null called construction time plugin I idea case s exception I TYPE_1 console _CODE_ : publisher org jenkinsci plugins _CODE_ TYPE_6 aborted due exceptionjava lang _CODE_ org jenkinsci plugins _CODE_ TYPE_6 perform ( TYPE_6 java : 134 ) hudson tasks _CODE_ perform ( _CODE_ java : 36 ) hudson model _CODE_ perform ( _CODE_ java : 810 ) hudson model _CODE_ _CODE_ ( _CODE_ java : 785 ) hudson maven _CODE_ post2 ( _CODE_ java : 946 ) hudson model _CODE_ post ( _CODE_ java : 732 ) hudson model run execute ( run java : 1582 ) hudson maven _CODE_ run ( _CODE_ java : 477 ) hudson model _CODE_ execute ( _CODE_ java : 88 ) hudson model executor run ( executor java : 236 ) finished : FAILURE
s a constant max column count configurable want a > = comparison safe case max changes smaller current number columns
simplify return VAR_2 equals ( VAR_1 VAR_2 )
addition member variable unnecessary - done I
don t need added VAR_2 member variable
testing _CODE_ objects equality a bunch weird edge cases I d recommend avoiding example object cloned clone won t match ll object debugger won t obvious don t match ! storing VAR_1 a HashMap command ID ( command getId ( ) ) column a key ? lookups faster identity more reliable ll need check existence map
want leave
touching lambda - fied braces newlines fit : VAR_1 METHOD_2 ( ( ) - > { METHOD_3 ( VAR_2 - > { METHOD_4 ( STRING_1 + VAR_2 + STRING_2 ) ; } ) ; } ( ) - > { } STRING_3 ) ;
reduce method : public TYPE_1 METHOD_1 ( final TYPE_1 VAR_1 ) { return ( ) - > METHOD_2 ( new ArrayList < > ( ) VAR_1 ) ; }
labmda : ( ) - > { }
lambda : ( ) - > { }
clear highlight error
skip VAR_1 true s requests stack
don t need return false ; line
risk called VAR_2 empty VAR_2 size ( ) - 1 negative ( I ) throwing exception ? worth a check chance happening
exit finding visible VAR_2 focused
A java constructor automatically a call - argument super ( ) isn t needed
FWIW call METHOD_3 ( ) ( a - op timer running )
class fields methods static
I _CODE_ added 1 11 x context 1 10 x compatibility
resource uuid parent case _CODE_ uuid property possibly return null
I zero
I m thinking return null don t need send data client nature resource framework sends status user case a success 500 case exception sufficient
curly braces
remove voided creatable
uuid creatable
running server t localhost
rid class adding business service layer API
shouldn t call Context _CODE_ ( ) METHOD_1 ( task ) others
fetch task
logic ? isn t care service layer ? don t Context VAR_1 ( ) METHOD_1
task wasn t shutdown shutdown command
_CODE_ ? instanceof
shouldn t return immediately save some unnecessary cycles ? break loop
isn t supposed create return a new ( database ) VAR_1
please returning plain Object returned VAR_1 _CODE_ ( ) converting TYPE_1
argument expected doesnt exist code another argument input argument check complain default
replace ( VAR_2 description Integer VAR_4 ) ;
want support boolean VAR_1
good
reference I accidentally _CODE_ classification created example variable _CODE_ ( case ) please fix PR super METHOD_1 ( event context )
constructor protected
instead testing assertThat ( d VAR_2 ( ) ( d run ( ) VAR_2 ( ) ) ) ; ( check VAR_2 ( ) alias run ( ) VAR_2 ( ) ) I test _CODE_ ( d VAR_2 ( ) ( List VAR_1 ( 0 INT_1 ) VAR_2 ( ) ) ) ; ( methods )
package private
package private
package private
final
final
nitpicking : new TYPE_3 < > (
return empty ( TYPE_6 VAR_4 TYPE_5 VAR_2 ) ;
sense return string assign instance variable result longer term need a bind method : TYPE_1 < A > _CODE_ ( TYPE_1 < A > io F < A TYPE_1 < B > > f ) binds returns a left argument another issue I check haskell doc exists
method reference METHOD_3 e g map ( TYPE_2 : : METHOD_3 ) I need types return METHOD_2 ( ) ? f f ( METHOD_3 ( ) ) map ( TYPE_2 : : METHOD_3 ) : List list ( TYPE_2 METHOD_4 ( e VAR_2 ( ) ( ) ) ) ;
curly brackets necessary returning a void
StringBuilder
put TYPE_2
good add sth calling getter
forgot potential issue
VAR_1 ( TYPE_2 ) thread - safe multi - thread addAll wrong protect
remain original code fetch - create - put action atomic thread replace others
return VAR_1 ( key ) ; method
listbox
METHOD_7 unnecessary
hard - coded add another format future
extra {
METHOD_2 ( VAR_6 STRING_3 METHOD_3 ( ) ) ; instead ? send additional data smooth false
a merge conflict #4244 please change file
I m 100% I other VAR_1 size ( ) expected problem present other tests a failing test showed a failed assertion shows actual expected misleading exchanged
please move TYPE_2 VAR_1 < 1090001 users skip _CODE_ versions checking equality skips migration coming 1080100 instead INT_1
I loaded filtering items fragment need preferences member variables watch updated
parsing html done feed java feed model represents actual feed display feed belong feed opinion
don t need a variable
I safer explicitly return empty string TYPE_1 isEmpty prevent crashes caller description null
need conditional anymore queue saves order time support sorting checking sorted
init called single time constructing VAR_1 done _CODE_ please add a space (
heavy lifting needs happen background ? VAR_1 METHOD_3 ( ) _CODE_ ( ) executed UI thread
codes ( spawning new thread synchronous version METHOD_4 ( ) ) a tad tricky A reduce complexity changing TYPE_3 METHOD_4 ( ) accept a runnable _CODE_ parameter that1 _CODE_ level simply calls : _CODE_ METHOD_4 ( METHOD_3 ( ) ( ) - > { TYPE_4 METHOD_5 ( false ) ; METHOD_6 ( params false ) ; / / _CODE_ = false } ) ; 2 underlying _CODE_ _CODE_ ( context feeds ) accept new parameter runnable _CODE_ invokes callback completion - _CODE_ TYPE_3 need expose synchronousversion feed updates
doesn t executor service a abstraction
opinion function belongs TYPE_3
I easier read don t nested s other method ( item = = null ) { return null ; } else ( item VAR_2 ( ) ! = null ) { return item VAR_2 ( ) ; } else ( item VAR_4 ( ) ! = null ) { return item VAR_4 ( ) VAR_2 ( ) ; } return null ;
return instead creating a String
return instead creating a String
guard clause ? ( VAR_2 ! = VAR_5 || VAR_3 = = null ) return ; TYPE_2 uri = ( VAR_1 = =
intellij warns INT_4 octal shouldn t a problem avoid warnings writing a single 0
I change ( url = = null ) { return null ; } indentation code a lot cleaner
change protected static ? order unconventional
shouldn t TYPE_1 override method support configuring button ? default implementation return I d imagine TYPE_1 a VAR_1 object others wouldn t
needs synchronized doesn t
call requires API level 11 ( 10 )
I false needs changed true some reason default preferences doesn t work shows checked doesn t work uncheck / check I m works : ( ( tested 5 0 0 5 1 )
simply call ? return build ( TYPE_2 VAR_2 ) ;
instead calling toString ( ) VAR_3 calling METHOD_3 ( ) instead else condition longer needed
hier bedoel je dan denk ik ( VAR_1 = = null )
dont declare RuntimeException ? functions throwing exceptions
wat als deze leeg ? kan je niet beter NULL teruggeven
setters null ( set ) empty
hoe kan hij hier komen als de input al een TYPE_1
waarom voeg je de index aan de naam toe ? de lijst toch op dezelfde volgorde als de index
zou een warning hier niet meer op z n plaats zijn
code System println ( ) please remove occurrences replace logging
warning
want a disable client checker a default set false want a enable - client - checker a default set true ? I work long term pov expect a long list incompatible user agents future
/ a final I m a lurker project I compatiblity shouldn t play a role bug fix fixing a wrong retuned change
I null
I more readable - catch part METHOD_3
I assert null s assert throwing NPE
save a lot duplication move { } finally { } _CODE_ printwriter s called
return VAR_2 METHOD_1 ( action result VAR_1 ) ;
protected
done class life cycle ( ctor )
revert private
final user t override method
view null contract enforced ctor check removed
naming _CODE_ ( ) enough
rm public
java 7 rocks : D
other s safer : TYPE_2 TYPE_3 equals ( VAR_1 )
rm public
readability multiple lines
rm public
_CODE_ ( TYPE_3 class a field _CODE_
needed anymore fixed bug localhost ga js
rm public
rm public
remove log
add false parameter entering app don t blocked app
proper bitmasking usage timestamp bytes more obvious
need final
need final
need final
check superfluous super METHOD_1 ( ) check safely remove block
VAR_2 shouldn t quoted
intentional add VAR_3 list toString output ? redundant count VAR_2 max fields
VAR_4 list added hash code _CODE_ I don t change result case reason isn t consistent
case equality gauge based config ? more sense default equals / _CODE_ gauge expect equality checks config
a detail : I created a private ( sense public ) METHOD_2 ( Type VAR_1 Object ) put logic a common method
missing
keeping VAR_2 = null ? won t null
method _CODE_ package - private ? testable reduces risk misuse
replace sysout METHOD_2 ( message )
stay warn
some thoughs shouldn t check VAR_1 a web VAR_1 instead excluding EJB modules
s sort weird getter int setter a boolean int including underlying variable ? consider making error count instead 1 / 0 provide additional information
unnecessary semicolon
I cleanup part _CODE_ ( other tests )
( line 48 - 57 ) a copy - paste _CODE_ please simplify pushing ( _CODE_ ) _CODE_ ? logic moved parent class VAR_3 field changed private final
hasn t parameter true ( _CODE_ ) forgotten
casting faster
equals throw enforce a singleton module policy unintuitive add normal duplicate binding config error
adding callback override _CODE_ methods update _CODE_ class add class SUBCLASSES_WITH_NO_CALLBACK map cleaner result code
curious class logging _CODE_ changed System err
want maintain behavior log ERROR guava logging SEVERE
people override method forget call super METHOD_1 ( ) derived longer want _CODE_ trick avoid happening
I METHOD_3 ( ) called METHOD_2 ( ) users call ( ) updated derived
cleaner push constructor
wasn t purpose VAR_2 call METHOD_2 ? VAR_2 a supported event ( _CODE_ )
extra newline
private
s guaranteed place local cluster 0th index position ? I mistaken
lets add public / private accessor private wrappers metadata type
private public
private
I remove downgrade trace log sending
need a new _CODE_ _CODE_ ? reset
throws InterruptedException
I return new TYPE_1 < > ( ) ; hit NPE
need check variables initialized avoid NPE
assume VAR_2 cluster manager valid ? I active cluster throw exception some debug logs
s motivation need update layout ? FD charge safe update layout
VAR_2 size ( ) number entries size
a 3 node cluster default don t need
log statement I relevant connection client a server established useful I leave INFO DEBUG
signaling condition exception a approach a globally unique instance signals a hole
I don t need check VAR_5 call method logdata belong stream filtered double check
ignore epoch / cluster id check
log line methods trace level master warning level
need call VAR_1 close ( ) returning prevent memory leak ( dispose deprecated close ( ) )
add access specifier
please replace ( ! VAR_1 isEmpty ( ) )
please curly
parse a long typecast integer ? Integer parseInt ( ) instead
intended follow backpointers implementation set true
! [ codacy ] ( ) issue : [ avoid unnecessary else statements returning booleans ] ( )
! [ codacy ] ( ) issue : [ explicit scoping instead default package private level ] ( )
type ( TYPE_5 ) instead METHOD_4
I s _CODE_ start ( )
s point wrapper method
orchestrator pass a connected client ( i e a VAR_2 ready ) creates a workflow needed
final int
! [ codacy ] ( ) issue : [ unsafe assignment a - final static field a constructor ] ( )
! [ codacy ] ( ) issue : [ explicit scoping instead default package private level ] ( )
! [ codacy ] ( ) issue : [ explicit scoping instead default package private level ] ( )
remove hasNext call METHOD_1
files paths instead a local file resource folder
please revert file bunch conflicts changes
isn t cleaner function append
english a bit strange change : retry
System println ( ) forbidden a logger output utility [ _CODE_ ]
return METHOD_1 ( VAR_1 null key )
declare final static
add a validation head tail chosen chosen epoch ? care inherent order setting head tail I safer put validation
review suggested log line I vote removing making distinction
VAR_1 ? reference codes I : javapublic int METHOD_1 ( long VAR_1 ) { return VAR_2 values ( ) stream ( ) map ( _CODE_ - > _CODE_ METHOD_1 ( VAR_1 ) ) METHOD_4 ( 0 ( a b ) - > a + b ) ; }
I don t need empyt doesn t key
METHOD_1 super class impl a overridden impl need change
checking compaction mark
check VAR_4 = = 0 line ? batch zero
List < Object > VAR_2 = new ArrayList < > ( VAR_3 METHOD_2 ( key ( TYPE_2 ) VAR_1 ) ) ;
consistent other
consistent _CODE_
VAR_3 volatile _CODE_
caching determine behavior METHOD_3 ? handle trimmed exception higher level overloaded semantics
behavior changed ? _CODE_ waits instead true
/ catch ? fail cast necessary
cleaner pass a type
please combine remove nested
VAR_6 = new HashMap < > ( ) ;
please long
token persisted new code doesn t epoch I suggest drop TYPE_5 usage instead transforming
trim mark doesn t change iterate cache
change s db _CODE_
change moved #1763
move VAR_4 acquisition VAR_4 ? consistent other places file VAR_4 acquired VAR_4
implementations METHOD_2 changes op
I METHOD_2 doesn t exists created need check null
synchronized
s point returning immutable copies class field immutable return
_CODE_ _CODE_
I suggest message change table created indexes opposed printing warning
a serious problem : checks failed thread finish exit expect block _CODE_ put more operations queue continue consuming ? I s a blocking queue
management server shuts shuts services i e orchestrator management service finally runtime shutting create a new instance management service hasn t shut
i wrapping scheduling level problem scheduler finicky
leave info helpful debugging
I unnecessary expensive need sort time resolve a new delta ? add a sanity check boundaries correct ( addresses [ 0 ] > addresses [ ind ] ) tail traversal backpointer decreasing
parse JSON clone object
a ImmutableList ( guava )
_CODE_ return status workflow s actions
shouldn t necessary error caught exception catch block
TYPE_2 a bunch final tweak TYPE_2 wanted run instead immutable data structure provide a fail - safe iterator copies slow effectively index a _CODE_ ( s failsafe iterator ) instead a HashMap need a copy collection speeds retrieval multifold
! VAR_3 isEmpty ( )
address NON_EXIST constant
Exception
need synchronized I remember datastore gave I wrong
change VAR_1 time cluster ID doesn t match ? permissive
I don t understand obtain VAR_3 boolean _CODE_ send _CODE_ METHOD_3 ( ) instances
I ll VAR_5 repeating
synchronized ? I message handlers synchronized instance enough thought class members arrive conclusion external facing methods synchronized
marked final
significance 5 wait ? METHOD_2
common rule ? I invertring boolean condition ? s smart question : ) I more readable ? ( VAR_1 isEmpty ( ) ) { return null ; } return METHOD_2 ( VAR_1 ) ; }
element toString ( ) instead ? want specific printing messager pass arguments toString debugging easier element toString ( )
_CODE_ ( ) instead
means t build interfaces builders
kick interfaces ? I don t need cases interfaces a form abstract type error message result type abstract class interface
needs represent implementation created method ? don t return _CODE_ ( ) || ! _CODE_ ( ) ? need else pick java 8 default methods I need consider java 8 default methods consider abstract methods
I m wondering create - types instead booleans
camelize s flowerly 🐫 👍
I reckon && needed
needed unboxing
require a resize underlying map default load factor 0 75 s new HashSet < Type > ( METHOD_2 ( ) METHOD_1 ( ) ) add ( VAR_2 )
add a CS rule code base original _CODE_ ( ) invoked ? IIRC provide a fail build specific methods invoked
need add annotation delegate ( i e actual VAR_1 implementation ) a decorator annotation
changes state instance calling _CODE_ illegal sense prevent ? API adding a check _CODE_
check n = = start ? n equals ( start ) equals - implementation TYPE_1 checks reference equality
kills ability vanilla extend TYPE_1
formatting cover ( VAR_2 ( VAR_4 ) { c VAR_3 ( VAR_4 ) ; } 1 bad VAR_1 prevent other components receiving ticks
scope more smaller private final Object _CODE_ = new Object ( ) ; public TYPE_1 ( ) { TYPE_1 VAR_1 ; synchronized ( _CODE_ ) { VAR_1 = ( TYPE_1 ) VAR_2 ( Thread VAR_3 ( ) ) ; } return VAR_1 ; }
I check description string change time I check description property exists ill merge changed
I m hugely keen aesthetics syntax I presume java - 8 syntax applying filter ? ( I m asking changes reassurances s done days I ve code pattern )
I d ve gotclass C { class { } code class C references class C C I m convinced expressed code s needed fact slipped suggests testing didn t pick
changing TYPE_8 getInstance ( ) TYPE_8 _CODE_ ( ) TYPE_8 ( ) long ( ) method situation - code getters good reasons I m claiming code good reasons s a possibility consider I d justification changes done a separate PR
unneeded
null suggestionreturn STRING_1 + + ( ! = null ? STRING_2 + : ) + ( ! = null ? STRING_3 + : ) ;
< String Object > needed
< String Object > needed
reduce METHOD_2 time ( a milliseconds enough )
removed
I METHOD_2 handles else
need conditional expression print true false isn’t enough priny USELOCALCACHE
line
need logging ? decrease logging level debug doesn t pollute logs tests run
I change ! = null && equalsIgnoreCase ( STRING_1 ) STRING_1 equalsIgnoreCase ( ) easier read
call missing method
I don t call METHOD_4 work item won t failed execute
a compilation issue new ArrayList < > ( ) new _CODE_ < string\ > ( )
wha implement JPA ? bit uncomfortable new methods type
method reused passing default VAR_2 avoiding code dup
want lazy - load manager instance [ lazy holder idiom ] ( ) ? I code a minor race condition
please - - general ( ) dispose cleanup operations warn warn operations prevent impair normal operation push - f ( force ) a fix pull request great ! thanks
don t reason streams simple ( int i = 0 ; i < 10 ; i + + ) enough
s variable
suggestionpublic TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { VAR_3 = VAR_1 METHOD_2 ( ) ;
line wrapping odd fill lines put arg line consistency
change debug
add protocols ( ) explicitly s a _CODE_ ( ) method TYPE_4 _CODE_ 2 I a cleaner solution subclass class create a _CODE_ holds logic initialize constructor class call method init block
I line incorrect removed
called finally instead ? TYPE_1 set _CODE_
default empty string ? change return empty string instead explicitly set STRING_1 tests need
shuffle logic method a bit I s clear code : javapublic String METHOD_1 ( Set < String > VAR_1 ) { String VAR_2 = METHOD_2 ( ) ; / / return launch activity specifiedif ( METHOD_3 ( ) ! = null ) { return VAR_2 ; } / / app version latest version apps store ( ! VAR_2 ( STRING_1 ) ) { return METHOD_4 ( VAR_1 VAR_2 ) ; } return VAR_1 ( VAR_2 ) ? VAR_2 : null ; }
simplified check absolute path ends apk
_CODE_ VAR_2 remove synchronized ( ) statements
s purpose assignment
I default constructor TYPE_1 don t pass constants
I m variable needed : javapublic static String METHOD_1 ( String string ) { ( string length ( ) > 0 ) { return string ; } return null ; } functions fail string = = null : javaif ( string = = null || string length ( ) > 0 ) { return null ; }
shouldn t VAR_1 METHOD_3 ( )
static import
s good idea TYPE_1 registered VAR_2 40k VAR_2 retrieved DB write a hql query retrieve a limited list VAR_2 group
need
package - private access constructor
retrieve bean ? I m performant operation spring
shouldn t finally
nested simplified : _CODE_ VAR_5 = VAR_2 METHOD_2 ( ) ; ( ! ( VAR_5 instanceof TYPE_4 ) ) return false ; List < Long > VAR_6 = ( ( TYPE_4 ) VAR_5 ) METHOD_3 ( ) ; ( TYPE_1 VAR_7 : VAR_1 ) { ( VAR_6 ( VAR_7 METHOD_4 ( ) ) ) { ( METHOD_1 ( VAR_7 VAR_3 VAR_4 ) ) return true ; } } return false ;
don t necessarily need constants plain fine
I put lines VAR_3 METHOD_4 ( )
duplicates METHOD_5
doesn t matter tests exceptions thrown s easier throws Exception
compare users equals method
don t need skip logic requires VAR_2 set s rely annotation rest
clear expect : - don t enable type filtering case pass null VAR_2 parameter - empty set passed IllegalArgumentException thrown doesn t sense filter
remove line need set
needed else
don t final
please wrap a - - resources stream closed some tools complain place a compiler warning
local supplied
need declare type RHS
rewrite asif ( obj _CODE_ _CODE_ ) { return } return obj = = ;
modifying array place method return void
call new METHOD_1 method
need add
pls add a annotation
cosmetic : extract Optional ( VAR_1 ) map ( a - > a VAR_3 ( ) ) METHOD_2 ( VAR_1 ) a private method ( i e private _CODE_ ( ) ? ) - _CODE_ avoid future issues logic needs changed ( i e forgetting apply change _CODE_ )
need guava ( import ) : ) suggestionreturn Collections VAR_1 ( Arrays asList ( STRING_1 ) ) ;
cosmetic : please align path parameter annotation
cosmetic : indentation : return VAR_1 ! = null _CODE_ getName ( ) ! = null _CODE_ METHOD_2 ( ) ! = null _CODE_ METHOD_3 ( ) ! = null _CODE_ METHOD_4 ( ) ! = null _CODE_ getType ( ) ! = null _CODE_ getId ( ) ! = null ;
loggers lowercase mind checking rest code aross pull request similar ? thanks ! : ) _CODE_ warn ( STRING_1 max ) ;
cosmetic : please change lowercase : suggestionlogger error ( STRING_1 r e ) ;
equalsIgnoreCase I force equals consistent
_CODE_ APPLICATION_JSON_VALUE instead String constant ? thanks
required
required
a bad result VAR_1 = = null METHOD_1 ( ) add ( configuration ) : return VAR_1 ! = null ? VAR_1 : VAR_1 = new TYPE_2 < > ( ) ;
please add throws IOException TYPE_5 _CODE_ _CODE_ ( ) foreach
throw new org VAR_2 VAR_3 VAR_4 TYPE_2 ( e ) ;
public METHOD_1 ( _CODE_ _CODE_ 0 ) method calls
previous implementation assumed return null reasons
uri toString ( ) instead uri getPath ( )
don t expect exceptions need catch
VAR_2 assert don t need more
please completely remove VAR_2 variable requested beforethanks : )
cosmetic : loggers codebase lowercase please change ? thanks ! : )
VAR_4 TYPE_4 conversion
move ( ! TYPE_1 exists ( path ) ) check
don t need called super method
shouldn t public
rolled
else clause adds error VAR_2 _CODE_ method don t overwrite null ( NPE )
curiousity protected
_CODE_ > delete identified < code > job < / code > scheduler - * < code > trigger < / code > s METHOD_4 unnecessary
I ve handled METHOD_4 ( ) properly _CODE_ METHOD_5 skipping
_CODE_ _CODE_ METHOD_1 repositories layout providers registered want _CODE_ ? situation happen branch assembly reposiitories couldn t initialized properly _CODE_ empty layout providers registered don t solution need some other
lost e
need check exceptions
strongbox leads thought strongbox instance names ( I ve raised #693 ) cosmetic : please method invocation line new instance ( - align rest chained methods ? I ve a places pull ) thanks
I return VAR_1 property wihtout extra logic
hey mind changing logger lowercase ? else great proceed - merging minor change request
please extract nested class a public
please braces - liners please change pull
I don t change file necessary additional throws declaration IllegalArgumentException unnecessary mind reverting file previous state won t noise pull request related file
please parameter line indent chopped parameters ( please fix pull ? ) logging operation blocks separate a line example : _CODE_ ( ) ; i + + ; logger debug ( ) ; logger debug ( ) ; _CODE_ ( ) ; : _CODE_ ( ) ; i + + ; logger debug ( ) ; logger debug ( ) ; _CODE_ ( ) ;
intended debugging purposes I sounds a reasonable suggestion
! [ CRITICAL ] ( ) null pointer dereference org carlspring strongbox io _CODE_ METHOD_1 ( TYPE_1 TYPE_1 ) due return called method [ ! [ rule ] ( ) ] ( )
please curly braces bodies statements - liners
I don t need
matching models routing key routing key expected identical property command method validated remove prepending routing key a method
_CODE_
replace : java ! VAR_3 METHOD_3 ( VAR_1 getMessage ( ) ) ? VAR_2 METHOD_4 ( ) : VAR_3 METHOD_1 ( VAR_1 getMessage ( ) target )
suggestionprotected TYPE_2 ( Builder builder ) {
provide entire target target class
argument _CODE_
creation a new aggregate * * return aggregate s METHOD_6 callee result return aggregate implementation returns annotated method decided overrule aggregate METHOD_6 return command handler return ? current point view : 1 return aggregate METHOD_6 a new aggregate created 2 return command handler s return aggregate existed
honest I d prefer a separate named test class null case ve uncovered - sg mind moving asserts METHOD_1 _CODE_ a method
constructor protected users easily a wrapper
I _CODE_ ( ) covers ( ) method benefit a number tokens test
I d constructor protected
consistency - : I static imports _any_ usage TYPE_3 other classes
invoke TYPE_6 ( TYPE_1 TYPE_3 supplier ) constructor
invoke private constructor
invoked primary private constructor
consistency I d suggest METHOD_1 ( ) call _CODE_
call a protected constructor
semantically correct return type TYPE_1 < ? extends TYPE_2 < ? > > s builder a compatible change changed some point
repository null
private protected
method return a List interceptors order
a small race condition containsKey ( ) returns false entry added remove immediately I s split separate statements remove ( Object Object ) s removed s exact entry expecting remove
sense _CODE_ ( ) functionality default _CODE_ ( spring config ) _CODE_ provided ? : thinking :
please construct default executor _CODE_ axon managed threads recognizable ( mandatory ) group _CODE_
don t semantically correct anymore lookup _CODE_ TYPE_4 done isn t a current TYPE_2 defined current TYPE_2 aggregate precedence
VAR_2 s class loader
sense constructor calls constructor line 63
return false client connected anymore
method doesn t need return completed connection considered closed
I d consider a _CODE_ case doesn t need return
need call VAR_1 run ( ) want set running false ( METHOD_1 ( ) )
I guess parameter VAR_1 METHOD_2 called VAR_2 parameter
preferrable changed state setting a parameter action check parameters some actions store a live reference parameter others resulting undesired behaviour I m aware some actions _CODE_ set behaviour
don t need catch print VAR_5 exception simply declare part method signature _CODE_ VAR_5 test exceptions thrown
constructor package visibility instead public
restore visibility fields methods class package level unit tests moved jaggr - core
restore visibility methods class package level unit tests moved jaggr - core
prefer initialization demand holder pattern cope singletons
wanted ? previous PR called METHOD_1 ( INT_1 )
findbugs redundant nullcheck parent instanceof TYPE_2 false parent null
making array start avoid a TYPE_2
t named arguments method VAR_1
TYPE_4 exception type ? / cc
space ( ( )
check function unary
change necessary ? I don t a reason VAR_8
I refactoring especially deduplication ! I suggest early return braces statements : _CODE_ input = t VAR_1 ( ) ; ( input = = null ) { return null ; } String VAR_2 = input VAR_3 ( ) ; ( VAR_2 ! = null ) { VAR_2 = TYPE_3 METHOD_2 ( VAR_2 ) ; } return VAR_2 ;
attribute type needs exact suggestionpublic < T > TYPE_1 < ? super T > METHOD_1 ( Class < T > VAR_1 ) {
bulb : code a / finally exception - safe closing TYPE_2 instance
bulb : slight _CODE_ f = new TYPE_2 ( VAR_2 ) ; { f format ( VAR_1 o ) ; return f toString ( ) ; } finally { f close ( ) ; }
a runnable needed ? work devices ? ( runnable UI work )
don t want a VAR_3
A simpler METHOD_2 ( state ( STRING_4 ) state filter clock changes want
jam moved deleted deleting remove lineups entered jam
a bit odd p VAR_3 ( ) ! = null && ! p VAR_3 ( ) isEmpty ( ) I cases empty valid
need locking A static initialiser simpler
synchronized
a batch a single call starts a batch _CODE_ similar
a reason synchronized ( ) file instead adding synchronized keyword method signature
brackets preceding order clear new code intended part loop
don t retry hcatclient blocking queue timeout
new TYPE_2
minor : a lot redundant references lying
shouldn t _need_ check null merge function called existing ( - null )
isn t constant shared producers ? t static
another behavioral change I don t want unrelated PR
hardcoded TYPE_2 a default serializer defaults yaml
check null
shouldn t static
brackets : wink :
I don t need println
shouldn t stream opening statements resources ? suggestiontry ( TYPE_1 = new TYPE_1 ( ) ; TYPE_2 = new TYPE_2 ( ) ) {
suggestionif ( s = = null ) throw new IOException ( STRING_1 VAR_2 ) ;
suggestionthrow new IOException ( VAR_3 ( Exception ) TYPE_3 apply ( TYPE_4 class ) ) ;
&& VAR_3 ! = - 1
append admins a chance identify fix
hmmm want depend channel monitor property access preferential properties monitor object
I m a big fan construct hide original OOM a new Logger listeners good other error types
substring ( 0 )
need lazily create variable instance ? I convention * instance ( ) methods create a new instance tests require instance multiple times hold a local copy
feedback
throw else clause
need explicit boolean primitive ? i VAR_2 ( ) trick
event type entity stored event queue
case print VAR_3 it’s supposed a valid test sheet assert VAR_3 empty enough isn’t empty I prints error map
case : VAR_1 null
set key _CODE_ ! = null
returning VAR_3 enough VAR_3 null
new HashMap < > ( ) explicit type longer necessary
move VAR_3 size ( ) = = 0 branch ( ! METHOD_1 ( ) ) meaning METHOD_1 ( ) function mixed checking list VAR_3 empty
s a good practice override a parameter create a local variable default VAR_1 null
want trim ( ) 2 parts avoid problems authorization header < key > : < signature >
METHOD_3 ( 0 ) omitted simplified TYPE_3 create ( VAR_2 METHOD_2 ( VAR_1 ) ) METHOD_4 ( ) ;
wouldn t test case simple handed factory METHOD_1 method ? _CODE_ METHOD_2 ( ) lookup DB guard ? a simple unit test _CODE_ METHOD_1 ( _CODE_ TYPE_2 ) wouldn t i
need METHOD_3 ( … ) ? I m a big fan essentially express : expect precondition fail don t want test fail
I change _CODE_ METHOD_1 ( ) method annotated I issue s I added check ignore issue
smarter
biggie StringUtils ( VAR_1 STRING_1 ) work
I suppose null check irrelevant METHOD_2 thrown exception a missing method
braces { } -
braces { } -
braces
limited TYPE_1 VAR_3 case
suggestionreturn null ; nitpick : returning null works slightly simpler
other parameters referred s style VAR_6
synchronization prevent people simultaneously database connection ? I s a case call ( ) persistences simultaneously ll time s goal synchronizing VAR_2 safer
I don t want new TYPE_1 ( STRING_1 ) load db s properties yaml need connection lazily instantiated
moved condition avoid unnecessary break
Object o suggestion
static imports
minor : static
I m put class final I don t people subclass TYPE_1 s immutable data class
add ( ) group && conditions clarity
style : prefer static import
static
done latest commit : 21f5677
mentioning explaining breaking change done changed assertions I s a bit work I necessary
minor : remove
nice catch runtime rethrow instead wrapping another runtime
replace Arrays asList org assertj core util lists list static import readability
code correct VAR_4 VAR_3
list place METHOD_4 a bit lighter read
test class deal Iterator VAR_2 Iterator TYPE_1
consistent _CODE_ METHOD_1 assertion pass VAR_2 VAR_1 null a implementation METHOD_3 return null null
startsWith String assertions job
static import METHOD_4
minor static import METHOD_2 readability
remove unnecessary parenthesis
format : javaif ( e instanceof List < ? > ) VAR_1 addAll ( 0 ( List < ? > ) e ) ; else result add ( e ) ;
changed protected
METHOD_4 deprecated else
METHOD_2 error message declared VAR_2 VAR_2
I shuffle order
I m wrong difference = 1 allowed margin 2 * 50% = 1 difference = = allowed margin < margin need move should_pass_if_difference_is_equal_to_given_percentage
add VAR_1 METHOD_2 ( METHOD_3 ( ) VAR_2 STRING_2 STRING_1 ) ; check order matter
VAR_4 VAR_3
s baseclass kommentar
a list access index
false default
parameter true need override _CODE_ remove true
set servlet path test pass
s please _CODE_ retrieve _CODE_ allow a _CODE_ removes some validation METHOD_2
delta VAR_1 ( ) VAR_2 instead reason needs build ( ) method
consistency rest code please prefix member variable references
order reduce overhead creating additional objects prefer null checks instead Optional VAR_8 more information gh - 7155
I method private a user wishes override behavior supply a custom VAR_6 similar _CODE_
explain _CODE_ METHOD_1 split ? sense combine a single method ? similar question _CODE_ _CODE_
a SAML attribute map multiple values type Map < String List < Object > >
I agree underlying list call VAR_3 ( ) ( tenant ) possibility adding road I m leaning more heavily renaming method _CODE_ I aligns nicely _CODE_ similar concept a method called _CODE_ ( )
please put @Override line consistent spring security code conventions ? _CODE_ boolean METHOD_1 ( ) {
I check instance TYPE_2 casting check pass a TYPE_1 done invoke TYPE_1 METHOD_1
move logic METHOD_4 ( )
making guarantees possibly null don t assertion
I want wrap exception IOException _CODE_ reason nimbus s _CODE_ react appropriately throw _CODE_ concern adding cache change exception callers a _CODE_ a _CODE_
needs
lines test necessary ? s remove unnecessary lines code
need expose ? I d prefer private don t need expose
create empty TYPE_3 ? byjavaif ( VAR_3 = = null || VAR_4 METHOD_2 ( VAR_5 ) ) { }
simplified : _CODE_ _CODE_ = _CODE_ _CODE_ ( request ) ; TYPE_3 < String String > params = TYPE_4 METHOD_3 ( request VAR_3 ( ) ) ; ( _CODE_ startsWith ( VAR_1 METHOD_5 ( ) ) _CODE_ METHOD_6 ( params ) ) { return true ; }
conform team standard please prefix field
private
getters private instance members
aligns rest codebase s remove final keyword
check necessary
conform other spring security code please remove final keyword front local variables
consistency project please remove final keyword
thanks simplifying please remove final keyword local variable
concern isn t VAR_3 null point VAR_1 null change _CODE_ s VAR_2 return null d want : suggestionif ( VAR_1 ! = null && ! VAR_3 METHOD_2 ( VAR_1 ) ) {
remove public modifier class package - private
throws clause redundant
reason aren t calling ( VAR_2 VAR_3 VAR_4 VAR_5 ) ? mind changing ? I realize s a minor point s track
please update VAR_5 VAR_5 - s common practice team prefix class members
implement _CODE_ clean hooks
line removed ensure METHOD_3 TYPE_2
change necessary PR ? I Collections VAR_2 test I d recommend bringing other tests conformance a PR ( example change tests refer member variables aren t isn t purpose PR )
a quick reminder sosuggestionthis VAR_1 forEach ( VAR_2 - > VAR_2 METHOD_1 ( request response ) ) ;
approach won t work changes inheritance behavior example I overridden VAR_1 I expecting _CODE_ call ( originally ) _CODE_ needs continue call VAR_1 order remain compatible
METHOD_1 ( true ) pushed 4 arg constructor
please add { follow spring security s code conventions
a need asserts ? reason I d prefer I don t want user error fix another _CODE_ implied VAR_4 give user error message repair problems
s remove protected s package - private instead
constructor invoke ( new TYPE_3 ( VAR_2 ) VAR_3 )
private
verify isn t break existing test assumptions ? shouldn t modify don t impact existing tests invalidate a test expectations scopes
Assert _CODE_
please move check null check bellow checking key = = null
I I misled previous review need additional configuration / / ( ) _CODE_ ( ) _CODE_ ( USER ) ( ) _CODE_ ( ) ( ) METHOD_2 ( ) METHOD_3 ( new TYPE_2 ( STRING_1 METHOD_4 ( ) ) ) ; / / :
check needed VAR_1 null based call path
rename variable VAR_2 _CODE_
a defensive copy VAR_2 a new instance Map
remove throws Exception s thrown
add 5 1
return type TYPE_1 < TYPE_2 >
return
+ 1 > 27 2015 21 : 15 rus notifications@github wrote : > > > - 51 6 + 52 7 public TYPE_5 ( TYPE_1 VAR_2 TYPE_2 uri TYPE_3 byte > > VAR_3 = VAR_3 ; > > VAR_4 = VAR_4 ; > > VAR_5 = VAR_3 buffer ( 0 0 ) ; > > - VAR_6 = false ; > > I time 1 0 want s advantage concerned compatibility : ) > > — > reply email view _CODE_
logic doesn t want support running a check a path token classes param path token token present render check matches
match case - sensitive case - insensitive
instead headers constructor
s currently a helper method class public address I line : return METHOD_2 ( ) toString ( ) + context VAR_2 ( ) METHOD_3 ( ) ;
isn t VAR_7 redundant
lieber ein Optional < TYPE_1 > zurueckgeben
I don t side - effect a static method ctor
delete
guy stateless ? a static instance ( ) method
s kind cool return null toString returning null omit query parameter URL altogether
couldn t written a simple loop ? I don t odd exit conditions
assignement useless ? VAR_3 = VAR_3 ;
upside STRING_1 override accepts tested
default a bit small 100 configurable System variable ? ideally nice runtime configurable example matching number cached feature types global settings I m guessing some complications possibly rebuilding cache thinking loud mind asking change implemented
&& VAR_2 < VAR_1 METHOD_2 ( ) short - circuit evaluation
a static constant some sort constant method readability a trip Path - - > File - - > resource - - > File ? hold method data sources access data TYPE_3 ( TYPE_2 working configuration information )
A miss
TYPE_3 METHOD_1 ( ) returns a list
need public protected enough
I m provide filter constructor need set
returned
adding logic intended paths supposed data directory rare case test cases need a file a resource [ files _CODE_ ( file ) ] ( ) method [ TYPE_1 METHOD_1 ( file file ) ] ( ) insert logic
set VAR_1 a null set null ? I guess wanted : ( VAR_1 = = null ) { VAR_1 = new ArrayList < > ( ) ; } VAR_1 = VAR_1 ;
leftover METHOD_5
misleading message
confused wait context loaded notifications happening a background thread ? time method run full initialization happened
sense a class states s modified
done _CODE_ ( ) return true a configuration restore ? I wrong s files s leaving method empty trick _CODE_ code fail file removed I don t a reason - create watcher
VAR_2 construtor injection dynamically runtime
set base test class cleaned test
_CODE_ OGC errors internal programming error instead ? moved check WMTS enabled a normal _CODE_ check anymore
Optional instance version call static methods
lambda conversion verbose ( VAR_1 VAR_2 ) - > compiler able infer argument types purpose reader
else
a single - - resources block resources a single statement body
- resources ; move logging body a slightly ordering need resources
- resources
- resources
discourage _CODE_ METHOD_4 ( TYPE_1 ) ( ) - _CODE_ introduced ? I tests flood console line removed
a resource leak ? needs a - - resource
- resources ? I need understand suppressed exceptions
justin spaces
- resources ? needs care METHOD_6
please convert tabs spaces converted a java 7 - - resources
consider moving enum a bit confused - id wicket communication - human readable ( case translatable )
strictly speaking API change IMHO s : )
code block repeated ( lookup METHOD_3 log ) a static method TYPE_2
nitpick : TYPE_2 METHOD_1 ( TYPE_1 class ) refactor safe avoids cast I ll a single TYPE_1 GS ( ? )
points respecting coding conventions ( space condition else line closing brace )
a ctor reference others ? * *
info newly introduced checks moved
I delete version check master logic simple clashes hard resolve event adding another field lifetime 7 x
delete line
please extra check test method
I wondering covariance return strings other types
print eclipse
write mode explicitly system default write mode decide introduce a client option set write mode a session overwritten system default METHOD_2 methods explicit write mode
checkstyle complain missing { }
deactivate rule globally I suggest disable rule specific code block :
I VAR_2 METHOD_2 ( o ) ; case buffered data case obtaining byte [ ] result
creating a new Long ? I a cast suffice
t return VAR_1
a cleaner builder pattern
longer null - safe ( ) - please swap equals comparison case
pass builder object
return VAR_1 ! = null && TYPE_5 TYPE_6 equals ( VAR_1 METHOD_2 ( ) )
private store s a mongo need protect writes a user shouldn t need care
TYPE_4 METHOD_8 ( [ field ] [ default ] ) t other Optional VAR_3 ( [ field ] ) METHOD_4 ( [ default ] ) ? I d pick stick
2 functions constants ? don t need create new instances time methods called
done method
null anymore
TYPE_1 equals ( METHOD_2 ( ) METHOD_4 ( ) )
suggestionthis VAR_2 = METHOD_1 ( VAR_2 ) ;
I other new getter methods removed favor package - private visibility field keeping field access simple creating new methods future code changes minimizing call stack follow understand I stay provides access a - final field others final package - private instead protected don t need access subclasses
suggestionvoid METHOD_1 ( TYPE_1 VAR_1 ) {
reduced : return TYPE_2 equals ( VAR_2 VAR_1 VAR_2 ) && TYPE_2 equals ( VAR_3 VAR_1 VAR_3 ) ; thought replacing _CODE_ time TYPE_2 hash ( VAR_2 VAR_3 ) ; - constraint equals _CODE_ consistent
a step : suggestionoptions forEach ( : : METHOD_2 ) ;
want normalize path returning normalized version Path
I yeah I print volumes helpful
more readable inline d assignment I m worked guava preconditions java METHOD_1 returns reference work example : javathis buffer = TYPE_1 METHOD_1 ( buf buf argument null ) ; stick minimal change merges master easiest
suggestionreturn TYPE_1 METHOD_2 ( VAR_1 input : : getName ) ;
places codebase constant statically import nice consistency other code
produce NPE matcher VAR_1 null want add a check : suggestionif ( VAR_1 = = null ) { return null ; } return TYPE_2 matcher ( VAR_1 ) METHOD_3 ( ) ? VAR_1 : null ;
VAR_5 time METHOD_4 ( ) called calling effect
count accessed lambdas running Map compute ( ) I needs atomic integer atomic integer force unneeded trips main memory lock held Map compute ensure consistency main memory sync block Map compute ( ) ensure mutually exclusive access
point code I expect VAR_1 = = I worth adding a sanity check javaprivate void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 METHOD_3 ( VAR_1 ) ; VAR_2 METHOD_2 ( VAR_1 VAR_3 ( key ) - > { TYPE_3 METHOD_4 ( = = VAR_1 ) ; TYPE_3 METHOD_4 ( count METHOD_5 ( ) > 0 ) ; final int VAR_4 = count METHOD_6 ( ) ; ￼ return ( VAR_4 > 0 ) ? : null ; } ) ; }
= = compare enums ( TYPE_1 ) equals ( ) accepts Object = = forces compiler check sides type s easier catch coding mistakes enums instances java JVM - wide singletons s typical risks = = comparing sameness instead equality enums equality implies sameness suggestion&& METHOD_2 ( key ) getType ( ) = = TYPE_1 VAR_3 ;
I tweaking pretty - print error prone affect values store minimized ( preference ; jq pretty print display ) store pretty - print modifications gson option change indent depth pretty - printer error prone replacing spaces beginning line I don t issues wrapped strings JSON
aren t equivalent StringUtils version checks null call
null I
TYPE_4 constructor takes String
behavior calls _CODE_ builder calling build modify map set VAR_4 null prevent future call Map _CODE_
asserts statement expected values argument please switch order arguments
completely I earlier call super METHOD_1 ( ) ; add a profile option
redundant VAR_1 tells ve done retries
I copied thrift unnecessary wrap RTE a new RTE
catch block removed
I m confused VAR_4 thrown
expected TYPE_1 METHOD_4 ( VAR_6 ) throw exception ? check return
drop VAR_1
want create a new object METHOD_1 ( ) methods called ? I thinking case user code passes _CODE_ calls METHOD_1 ( ) ( ) frequently create objects shouldn t create a single TYPE_2 object _CODE_ constructor
need set VAR_6 VAR_7 VAR_8 set method
VAR_2 a bit odd dropping VAR_2 VAR_3 ( VAR_4 ) METHOD_1 ( VAR_1 ) clean
function < _CODE_ T > build function type instead a custom interface method return VAR_1 apply ( ) ;
javathis VAR_1 = TYPE_3 METHOD_2 ( VAR_1 STRING_1 ) ;
VAR_1 values ( )
check isolated method I m benefit depenency party utility inline statement s place depend guava
code a race condition another thread creates a table exists ( ) create ( ) avoids race condition javatry { create ( VAR_1 VAR_2 ) ; ￼ return true ; } catch ( TYPE_4 e ) { return false }
_CODE_ = TYPE_2 METHOD_2 ( ) METHOD_3 ( ) ;
a bit cleaner TYPE_1 ( )
s a malformed TYPE_1 s illegal argument method illegal state
site configuration immutable represents state a configuration file typically put stuff a _CODE_ ( _CODE_ ? ) modify setter place
I need method I removed master branch useful rebase
mock deprecated changing code s phase isn t add complications
I refactoring nice method protected
double count some data
sum parent max
add @Override annotation other methods eclipse automatically
shouldn t closed
I don t methods need throw a checked TYPE_3 preferable throw IllegalArgumentException problem bad argument method a problem accumulo
guard NPE serialization shouldn t break ID null
implementation correct I unit test prevent regressions I testing boundary cases arrays length 1 2 3 sufficient cover cases ( i = = 0 i = = a len - 1 0 < i < a len - 1 )
assertTrue assertEquals
containsKey check ? map ( ) return null
avoid StringBuilder a single string return case s concatenated else method other change good thanks contribution
appears checking default hard - coded A check unit test TYPE_3 ensure don t a stupid mistake default I a validate method TYPE_3 java a quick verification a good a user sets process starts reads config time
call super write
store length
line declare variables remove default constructor doesn t match existing style
Integer toString ( )
return null
a private method need wrap exceptions handle caller ? converting _CODE_ converted _CODE_
I changed : java } catch ( IOException e ) { throw new _CODE_ ( e ) }
package - private
input stream doesn t change t computed offset read VAR_3 passed
method seek calling METHOD_1 : javasynchronized ( VAR_1 ) { VAR_1 seek ( VAR_3 ) ; int VAR_2 = VAR_1 METHOD_1 ( ) ; }
whats purpose double check ? optimization avoid sync ? I suspect majority cases called VAR_1 false double check result extra trip memory ( reading VAR_1 main memory ) majority cases slow majority case
remove throws IOException won t affect callers expecting IOException - - don t throw anymore s fine
Logger instance
intended a Set < Integer >
check a bit confusing reads VAR_1 metadata table root tablet root tablet s configuration metadata configuration some other setting user tables s more ? _CODE_ returns s metadata table root tablet || VAR_1 METHOD_3 ( ) redundant I refactoring _CODE_ more more clear checking
instantiation objects equals method broken condition ? s a lot a simple equality check easier follow impls instantiated earlier IMO
unnecessary SKVI < > parameterization
TYPE_1 ? public
instead similar METHOD_2 ( hide STRING_1 string reddeer )
lines 60 - 64 related setting settings xml preferences code useless please remove
need wait
INT_1 context
I d prefer VAR_5 printed stuff
include comparison ? VAR_1 enough
more initial delay doesn t clean immediately s important creation errors emitting failure means a failure triggering fast instead VAR_2 VAR_4 = TYPE_1 METHOD_1 ( VAR_2 VAR_2 TimeUnit VAR_5 ) ;
agree evan projection parameters _CODE_ _CODE_ a fix update _CODE_ ( ) method _CODE_ replace projection params masktree objects
I d suggest making private methods package - private need accessed a unit test making protected opens access implies intended inheritance relationship
remove TYPE_4
switch instead else
public
point consistency codecs protobuf codec assumes VAR_2 handles METHOD_4 code call explicitly consistent set expectation METHOD_3 VAR_2 handle flushing / closing VAR_1 codec s close METHOD_3 VAR_2
need setter exposed ? constructor handle automatically
need include VAR_5 argument s instance variable
space
don t track registered custom classes custom java ? I simpler
don t need / catch valid tests test VAR_2 exception occurs
sense ? order
writereturn VAR_1 ! = null ? VAR_1 METHOD_2 ( ) : null ; spare some lines : )
y ( expected )
nt useful
I a static method construction fit
return ! list isEmpty ( ) save branching : )
a constant instead null code easier read place pls
I don t ; need a handle optional imports ; a more general ; others more libs
remove commit
TYPE_2 closed call METHOD_4
public
public
want public
throws exception
backspace
isn t protected sufficient method
s length ( ) > VAR_1
wouldn t clearer condition ( ( n % 100 ) < 10 )
der fall bietet keinen mehrwert zu category oder ? test entfernen oder alternativ ( dann gibt es kein duplizieren ) : ( = [ { index } ] category = { 0 } ) ( strings = { category } )
hier wäre noch ein test schön wo nicht identify verwendet wird
das ist eigentlich ein bug schöner wäre wenn da eine _CODE_ mit passender meldung fliegt wenn sie wollen dürfen sie das SUT auch abändern
final für locals kann entfallen
das war mit gar nicht bewusst dass $$ durch $ ersetzt wird ( das ist ja auch ein feature der aufgerufenen methode jenkins core ) wäre es unserem fall nicht leichter zu verstehen wenn1 test bleib wie es ist2 $KEY durch $VALUE ersetzt wird $VALUE aber nicht weiter3 $KEY durch $VALUE ersetzt wird und dann $VALUE durch _CODE_ drei tests
für die branch interior Path coverage überprüft man i A 0 1 2 schleifendurchläufe
gute frage ob man toString testen sollte oder nicht aus meiner sicht würde reichten ( STRING_1 ) ( ist aber nicht falsch )
note clearer marked protected : class abstract constructor called subclass constructors
need pull a separate variable reference test
require srcs - empty don t require VAR_1 - empty line throw exception
isn t more simply : java map ( TYPE_1 : : valueOf )
returning TYPE_1 a bit cheeky method API
VAR_1 ( 0 ) _CODE_ VAR_1 iterator ( ) ( ) _CODE_ lets consistent VAR_1 a list lets ( 0 ) match code
null check necessary want pass null METHOD_5
branches / local clone determines calls remote repo I suspect jgit origin test needs ( ! params VAR_1 startsWith ( STRING_1 )
methods don t follow project s formatting style
I don t exception swallowed
? ( int i = VAR_4 ; i < index ; i + + ) { column = VAR_3 METHOD_4 ( ) ; column VAR_5 ( i ) ; }
return new TYPE_1 ( fine need store returned instance
protected work
aren t url s ? file : / / some / path / jar ! org / foo / _CODE_ ! java url s s zip ( s kind ) I agree false positives ( tony jarvis ) endswith false negatives ( jar ! org )
real need a return type : P
a pre - login handler a pre - register handler ? id site
I METHOD_4 handle materialized scenario means method simply invoke METHOD_4 ( VAR_2 VAR_1 ) ; internal code METHOD_4 check VAR_1 materialized relay METHOD_3 ( VAR_2 VAR_1 ) ; internally
simplified TYPE_2 TYPE_3 equals ( getStatus ( ) )
removing ? _CODE_ ( ) / / - classess override method CALL super METHOD_1 ( ) some point insider custom implementation removing existing explicit invocation a method a parent class uncaught errors please add solve new issue
line unnecessary : ( VAR_1 = = null ) {
href s case sensitive please VAR_3 METHOD_3 ( ) METHOD_4 ( ) equals ( VAR_1 ) )
TYPE_1 casting redundant
please remove line
leftover debug
indentation 2 space indentation curly brackets single statements
mezz braces ? ; P
smeltery runs INT_1 ticks VAR_1 = = 0
unneeded cast
I d reduce a simple ( TYPE_7 VAR_6 ! = null ) hard dependency pulse
minor : Long valueOf instead new Long
missing return
doesn t need synchronized
BTW style considered unnecessary else a compiler error / warning eclipse I other java compilers
I cleaner add a METHOD_1 ( stirng username String password ) method current call empty strings
: METHOD_7 callable
override toString append TYPE_1 org voltdb exception TYPE_1 : TYPE_1 : MESSAGE toString called stack trace printed
Pair ( VAR_2 VAR_3 )
creating a new random instance iteration loop ? shouldn t m_ prefix
suggested _CODE_ : suggestionpublic static TYPE_1 METHOD_1 ( final Context context ) { return ( cluster VAR_1 ) - > new TYPE_5 ( context cluster VAR_1 ) ; }
empty string works
correct ? s set null
BUG ? nt done startting VAR_5 polling
join type check consolidated logical phase
need ? ? belong _CODE_ ( )
I check equality add a runable needed avoid unneeded runs
directory defined a common place want move another location a single update
duplicated line ( global replace )
matters returned getValue unsigned int store int save 4bytes matters
I prefer exceptions swallowed instead _CODE_ nice log debug case wonders isn t working
putting annotation line method annotations line
constructor private
s VAR_2 ! =
VAR_2 equal METHOD_1 bother storing METHOD_1
consistent assertassert TYPE_6 TYPE_7 equals ( METHOD_1 ( ) ) ; vsassert VAR_2 ( TYPE_6 TYPE_7 ) ;
exception bubble METHOD_3 test test throw exception entire stack trace captured junit
refer L55 calcite / core / src / main / java / org / apache / calcite / rel / _CODE_ java VAR_1 method change instance ; returns a modified copy child discarded
revert
[ java - 8 - - resource ] ( ) : ( TYPE_2 VAR_3 = new TYPE_2 ( new TYPE_3 ( new TYPE_4 ( VAR_1 append ) ) ) ) { VAR_3 METHOD_2 ( ) ; }
necessary ? multiple threads _CODE_ object instance
return statement deleted
changing batch directory shouldn t changed filenames need changed
column index negative ? ? && a ||
VAR_1 defined TYPE_1 assertion cast needed
doesn t synchronized _CODE_ grabs _CODE_ lock calls METHOD_1 ( )
error handling enough ? risks
simplified toreturn VAR_2 METHOD_2 ( new TYPE_3 ( VAR_1 ) ) ;
necessary synchronize
I prefer VAR_3 isEmpty ( )
I prefer VAR_4 isEmpty ( )
method equivalent _CODE_
dont need keeping copy cluster VAR_1 good
change default
default s false remove
METHOD_2 present
case member variables set values immediately delete lines 440 - 441
hmm parameter _CODE_ adjacent statement ? concurrent planners case havoc result I TYPE_5 a normal ( - static ) member some object shared more thread _CODE_ fit description
_CODE_
VAR_9 initialized a tracker _CODE_ point adding some unit test failures unit tests construct _CODE_ a real _CODE_ case proper place set tracker unit tests follow starvation tracker initialization pattern _CODE_
include path failed canonicalize _CODE_ root = VAR_1 METHOD_3 ( ) ; String path = _CODE_ getPath ( ) ; { return root METHOD_4 ( ) ; } catch ( IOException e ) { throw new TYPE_2 ( failed canonicalize voltdbroot + path + reason : + e getMessage ( ) ) ; } similar recommendation other paths - command log snapshot dr / export overflow
great suggestion
add ( o = = ) return true ;
blocker : please put a space
throw IOException caller handle log
package visibility
TYPE_4 needed ? I don t s purpose watcher method await ( ) calls ( ) ZK data
cleanup
assert needed hit line 228 procedure a TYPE_3
s ? create SSL clients
need case ? case set VAR_1 false
A positive test clearer : ( METHOD_2 ( ) ) { return ; }
remove wrap : ( ! VAR_2 && METHOD_2 ( ) )
remove ELSE return STRING_1
_CODE_ 1 rack groups
merge declaration block - scoped initialization statement ( )
correct ? doesn t forget segments VAR_3 close closes _CODE_ VAR_3 files disk ? leaked
shouldn t more implemented [ _CODE_ ] ( ) strategy
tests SSL dont depend server
I thought ssl return bytebuffer
cleaners direct byte buffer allocations
a reuse buffer stored procedure
else required return
VAR_2 a typo ? keySet ? I missing ket
synchronized ? isn t thread - safe
dont TYPE_1 new cli
IllegalArgumentException
VAR_1 METHOD_2 ( ) ; means SPI receives duplicate counter DONE ? SPI
unintended changes debugging
don t want call METHOD_3 ( ) current item released
values ( ) instead keySet ( ) save a map lookup
functions confusing return null assumption pdb segment assert ( entry ! = null ) more readable
precondition checks null assert tests please
return VAR_1
shouldnt close cursors setting VAR_1 = true
error message longer accurate don t catch throw
need check VAR_3 = = Long VAR_6
METHOD_3 close done automagically resource block
flush close done automagically resource block
s passing IP / hostname
condition VAR_2 < = VAR_3
! = simpler
function cluttering test output serving a purpose ? modifed actual validation dump output a visual inspection practically speaking happen general I keeping PROVEN USEFUL visual diagnostic code quickly enabled wrong I DISABLED running expected a verbose successful run clearer identification actual problem diagnostics
catch exceptions VAR_1 METHOD_1 ( ) ensure TYPE_2 VAR_4 METHOD_1 ( ) invoked
automatically a CRUD proc called T1 insert create table I procedures unnecessary
X ? true : Y simplifies X || Y
javapublic static byte [ ] METHOD_1 ( String data ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( data length ( ) ) ; ( TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ) { VAR_2 write ( data VAR_3 ( TYPE_3 VAR_5 ) ) ; } catch ( IOException e ) { throw e ; } return VAR_1 METHOD_2 ( ) ; }
send empty TYPE_1 dont deal null
I a generic check lots places expressions easy miss some add a new field expression number levels tree computed a building expression time expression constructed new number levels max ( number_of_levels_in_nth_child_tree ) + 1 feasible
set true instead copying VAR_1
javaif ( TYPE_3 TYPE_4 equals ( VAR_1 METHOD_2 ( ) ) {
shouldnt executor lock
u leave STEBUG
please IllegalArgumentException
a matter default s a odd Long VAR_2 rest DR 0 a a _CODE_ UNSET_UNIQUE_ID
I forgot add parameter TYPE_4 METHOD_3 loose failure stacktrace please add
existing code statement reason changing order ? I METHOD_5 ( ) METHOD_6 ( false ) statement
nipick : follow java conventions beginning variable names a case ? don t typically prefix variables type information I guess s a big deal want leave
rid s o plns replace logger
please add { } a single line statement
specific reason String literal String VAR_1 ; instead creating String object
nt VAR_2 false ? remove variable
a bug need pass VAR_2 instead _CODE_ OOF I fix branch push
need METHOD_2 check happen clear cancel irrespective body avoid extra check
class instantiated a loop benchmark meaning logger initialization called loop iteration logger static avoid initialization cost loop iteration
METHOD_8 = VAR_3
return < String > type returning Object
options input
a code style perspective lines 255 - 257 260 a single line : final TYPE_4 VAR_3 = options = = null ? new TYPE_4 ( ) : options ;
save a variable declaration set passing string method call
a copy user - provided options
don t need mock anymore set string return
I a typo - > VAR_2 < VAR_2 - > - > VAR_2 < VAR_1 VAR_2 ?
simplified line javathis VAR_2 = TYPE_1 METHOD_1 ( VAR_2 STRING_1 ) ;
remove
import won t need fully qualified
don t need create a new ArrayList
suggestionthis VAR_3 = VAR_3 = = null ? null : Collections VAR_5 ( VAR_3 ) ;
return unmodifiable list create unmodifiable list ctor
VAR_1
link doesn t declared statement
float double properties I d lean double meant a generic class double store float vice - versa
System err println _CODE_
highlight usage fluent model var VAR_2 = new TYPE_3 ( ) METHOD_4 ( STRING_2 ) ;
simplify return VAR_1 || ( ! VAR_2 && METHOD_2 ( ) ) ;
a big deal I generally a positive perspective ( i e innocent proven guilty ; - ) METHOD_2 ( VAR_2 ! = null ? VAR_2 : METHOD_3 ( ) ) ;
I included fix test code cleanup #51
I don t METHOD_1 methods need synchronised
VAR_2 set a finally
inline
please replace empty string a proper error message
please replace empty string a proper error message
I some spider - sense tingles a user table claims checking METHOD_1 resize putting a > = some assert provide safety future devs
constructor delegate other constructor s a bit weird enums constructors I prefer live bottom class
I args length > 0 grab arg file ( absolute ) I ran print file ( absolute path ) s working starting delete file ? want restarts generations
swallowing exception don t need VAR_4
I harder read previously searched specific types fell return false default fall folded a more complicated expression
I meant VAR_1
don t need String format
check server ! = null tearing
METHOD_4 ( server VAR_2 ( ) VAR_3 ) extracted a - params method
I m wondering a default final method _CODE_ called foo checks VAR_3 true calls VAR_5 calls VAR_6
IllegalStateException code path a case expect happen ? IllegalStateException choice signals _we_ wrong user product
concern
don t need a String format %s
a log _CODE_ obfuscated
s open
VAR_3 VAR_4 evaluated _CODE_ send boolean parameters function instead evaluating agan
adds
previous semantic VAR_5 count METHOD_3 returns true
longer need methods synch
a - loop channel ! VAR_4 ( ) ? e g exhaust suitable idle VAR_2 return null creation a new
increased readability I prefer outer * * * * written x ? y : z notation
renaming VAR_1 _CODE_ user agnostic
= = assuming ? equals
result anymore call db ( ) execute ( STRING_2 ) ; storing result a variable
fast lets give a cpu some time VAR_3 : )
feels TYPE_5 values ( ) length rid VAR_2 altogether
encounter type group return
i equals 0
I don t improvement
unmodifiable constructor
I don t debug - catch
null check ? expecting VAR_7 null some real scenarios ? check allow tests pass null I pass a - op consumer instead rid condition ( similar places )
&& VAR_1 > = 0
_CODE_ equal another array instance TYPE_1 ? I assume row returns false
opportunity set index = null
check node cursor need spend more time _CODE_ s 3 4
please arraylist
mistakenly moved
t rely
setting RECORD_CURSOR_TRACES false increase overhead recording VAR_1 traces traces captured stored a cache shared threads cache evict put
I VAR_5 = = VAR_2 check VAR_10 introducing a new field a method _CODE_ method instead
final
TYPE_1 checks bounds propagated _CODE_ ( ) doesn t ? need specifically
I don t other method synchronisation avoid overlapping
checkstyle ; missing space
method pretty hot I optimistically combine VAR_1 VAR_2 METHOD_3 a single method call straight int - read loop rely METHOD_5 throw result a cross - page instead instead turn figure EOF
plans fellow
don t need extra TYPE_2 wrap
super close ( ) method close executor task queues empty workers terminated close writer close executor risk racing - work
Collections addAll
simplified return expression null - check avoided initialising filter field predicates _CODE_ filter constructor
i add additional check more 100 : )
stream needs closed
scheduler designed run task time effect currently running completed
package private
I missing shouldn t VAR_6 = = null
synchronize
a good handling exception ? able continue fails
additional_neo4j conf need ? correlate other tools behavior
I address TODO
switched order cores read replicas
java supports covariant return types method return TYPE_2 breaking type safety interface easier eye
I remember talking decoupling synchronization class I completely remove synchronization didn t solve regression benchmarks I ran i september I messed I love some benchmark result confirm fix
logic included enum overridden method
strange need a fully qualified
please update line ( TYPE_2 METHOD_2 ( VAR_1 [ 4 ] ) < < INT_1 ) + TYPE_2 METHOD_2 ( VAR_1 [ 5 ] )
more illegal argument
METHOD_1 ( ) needed
prefer expected exceptions added tests invoked throw
call id argument a vararg
empty loop
need final
constructor package private
( ! VAR_1 METHOD_1 ( obj ) ) { / / fall delegate poolpool METHOD_1 ( obj ) ; }
don t need VAR_2 field anymore
private
protected enough
A copy constructor TYPE_1 more a public getter method
I expect annotation overrule default smaller
stream#of ( ) convert single element stream
TYPE_1
TYPE_4 apply
VAR_4 null Optional < _CODE_ >
remove call METHOD_4 ( count )
need METHOD_4 test _CODE_ throw exception expected error thrown METHOD_4 test ( other tests )
need pass param VAR_2 passed
instead wrapping a resource iterator potentially unnecessary object instantiation couldn t usual check resource finally
formatting
want ( ( VAR_1 length + VAR_2 length ) % 2 = = 0 ) VAR_1 length ! = VAR_2 length + 1
rely side effects magic METHOD_4
pass - 1 a default
package private
package private constructor
expression wrapped METHOD_1 METHOD_2 ( index ) % VAR_1
don t need VAR_3
gonna delete label scan store a nice time gonna create new index part migration guys people forced wait startup expecting ready fly I proposed behaviour differs time complaints sounds a correct WDYT
doingtry { ( TYPE_1 ) VAR_1 ) } catch ( TYPE_4 e ) { return false } more slower easy read compared _CODE_ operator suggest _CODE_ TYPE_1 instead applies _CODE_ equals
instead ? File file = new File ( VAR_2 VAR_1 ) ; ( ! file exists ( ) ) { METHOD_3 ( STRING_1 + VAR_1 ) ; } return file ;
please separate lines
redundant
package - private other constructor removed
want releasing remaining resources failure ? I don t terminate transaction release noting observation
t fix magic 2 : )
a feel probability condition false
_CODE_ protects _CODE_ making methods synchronized class expose _CODE_ concurrency prepared handle
replace return = = VAR_1 ;
replace return = = VAR_1 ;
reuse METHOD_1 ( iterable VAR_1 )
checkstyle public modifier redundant
oops
need trim user provided string figure
need declare public
code resembles C doesn t adopt horrendous naming standards ; )
|| ! VAR_2 part covered VAR_4 = ! VAR_2 ;
isn t unexpected a flag index VAR_2 raised s
fit a single line
isn t copy paste another METHOD_1 method ? reused
need check ? surely enterprise edition supports constraints
method pretty inefficient _CODE_ ( ) a single - loop build arrays streams add overhead
method private
_CODE_ ( )
whaat
whaat 2
_CODE_
another
called general indexes unique index population synchronous
a reason want bitwise instead || want explicitly avoid short - circuiting
won t exception racing worker thread started removed future
a specific object property values i s super strange fall backing array propose VAR_3 size ( ) method instead
provide method single method helper class
keeping existing indexes working ? 👍
aha _this_ single - property indexes retain format good
cast long ? automatically coerce similarly _CODE_ a big issue
doesn t wrap nest arrays returns array recursion base case
conversion _CODE_ happen task helper class ( helper class unrelated context )
common stuff moved a utility class avoids repeated code
super
suggestionfor ( char i = VAR_1 ; i < = VAR_2 ; i + + ) { ? remove need casting VAR_1 VAR_2 chars
declared final
: part a PR ( I assume s safe rid helper version TYPE_2 class
a boolean reason strings
d delegate super METHOD_1 ( )
switch METHOD_3 ( STRING_1 STRING_2 ) appears problematic character space
explicit braces
odd state left ? - introduce
private
unnecessary extra level indentation
SDK - internal package access please
want package access other entity constructor
migrating _CODE_ please remove throws clauses method declarations UOE a runtime exception clauses necessary
mmm I guess need 3 checks : ( VAR_1 = = null || VAR_1 id ( ) = = null || VAR_1 id ( ) isEmpty ( ) )
add method
class listener
- resources
VAR_1 null read link ive wrote
а что потом происходит с { number }
_CODE_ enabled METHOD_1 TYPE_1 repeatedly call destroy operations
shouldn t comparator < means add new item VAR_3 s size exceed VAR_5
Boolean VAR_2 toString ( ) need ignore upcase
change ( ! = null && > 0 && VAR_1 = = null ) {
need trim
duplicate call VAR_1 ( key ) caller METHOD_1 ( ) called method key passed a normalized
judge null VAR_2 normal response called TYPE_2 remove
pls simplify return TYPE_1 class METHOD_2 ( VAR_1 ) ;
VAR_2 null means a config deleted line throw NPE : javajava lang _CODE_ java base / java util concurrent _CODE_ _CODE_ ( _CODE_ java : 1011 ) java base / java util concurrent _CODE_ put ( _CODE_ java : 1006 ) org apache dubbo configcenter support nacos _CODE_ METHOD_1 ( _CODE_ java : 229 ) alibaba nacos api config listener _CODE_ _CODE_ ( _CODE_ java : 37 ) alibaba nacos client config impl _CODE_ run ( _CODE_ java : 188 ) alibaba nacos client config impl _CODE_ _CODE_ ( _CODE_ java : 209 ) alibaba nacos client config impl _CODE_ _CODE_ ( _CODE_ java : 160 ) alibaba nacos client config impl _CODE_ run ( _CODE_ java : 505 ) java base / java util concurrent _CODE_ _CODE_ ( _CODE_ java : 1128 ) java base / java util concurrent _CODE_ run ( _CODE_ java : 628 ) java base / java lang Thread run ( Thread java : 834 ) order avoid necessary remove _CODE_ _CODE_
simplified new ArrayList < > ( Arrays asList ( new TYPE_1 ( VAR_1 ) ) )
token VAR_6 ( ) replaced _CODE_ ( )
check check empty null stringorg apache dubbo common utils Assert _CODE_ ( VAR_1 t null blank ) ;
2 0 x widely adopted 1 0 x compatible code unnecessary remove code cleaner
logic _CODE_ call TYPE_2 METHOD_2 ( VAR_1 instanceof TYPE_3 )
don t call METHOD_3 shutdown hook runs lead IllegalStateException remove hook javastatic synchronized void add ( Thread hook ) { ( hooks = = null ) throw new IllegalStateException ( shutdown progress ) ; ( hook _CODE_ ( ) ) throw new IllegalArgumentException ( hook running ) ; ( hooks containsKey ( hook ) ) throw new IllegalArgumentException ( hook previously registered ) ; hooks put ( hook hook ) ; }
need formation
builder append ( VAR_2 ) append ( ) need remove : build method
rewritten return ( VAR_1 = = null || VAR_1 length = = 0 ) ? null : new String ( VAR_1 VAR_3 ) ;
pls add / / ignore
! METHOD_2 ( ) METHOD_3 ( ) isEmpty ( )
* * * * null rest evaulation ! Constants VAR_2 equals ( ) && ! Constants VAR_3 equals ( ) evaluates * * true * * localhost chances condition true depends * * TYPE_2 matcher ( ) METHOD_4 ( ) * * understanding performance point view I change ( ! = null&& TYPE_2 matcher ( ) METHOD_4 ( ) && ! Constants VAR_2 equals ( ) && ! Constants VAR_3 equals ( ) ) ; yu
simplified withreturn ! = null ? : VAR_1
apply approach
format code pls
_CODE_ method isn t implemented
pls consider enhance _CODE_ _CODE_ _CODE_ _CODE_ instead introducing new test methods method naming more recommended pls stick
! [ code smell ] ( code smell ) code smell : METHOD_1 a static method ( [ squid : S2325 ] ( ) ) [ _CODE_ ] ( ) [ ISSUE_KEY ] : _CODE_
primitive long
pretty printing needed
please move line changelog action : action VAR_1 ( search a collection ) _CODE_ ( new change ( 7 1 new field scope added response ) _CODE_ ( new change ( 7 1 field scope added f parameter )
false ? scanner send SCM information DB data reused
minor : I call VAR_5 METHOD_4 METHOD_7 check fails uselessly a call DB
VAR_3 METHOD_2 called line 117 belong a method called METHOD_1 static
! [ MAJOR ] ( severity : MAJOR ) remove null - check Optional [ ! [ rule ] ( ) ] ( )
please remove METHOD_3 = > s more needed s error generated METHOD_2 moreoever METHOD_2 throw IllegalArgumentException instead adding error list error
AFAIK check DAO ( _CODE_ )
removing metrics ? s done _CODE_
shouldn t a Logger ( web log a test ? )
t foreach
public
public
private
! [ MAJOR ] ( severity : MAJOR ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
missing test property zero code put large max file
factory don t want INSTANCE creating a static member field
A UT added check changelog correctly loaded
done opening a db session - fail fast
equals support subclasses necessarily intent
! [ MINOR ] ( severity : MINOR ) remove ; deprecated [ ! [ rule ] ( ) ] ( )
won t fix
won t fix
🐜 I suggest case database ids lowercase
🐭 I a slight preference metadata keys defined more easily manage metadata index
🐭 : I d slightly prefer private
I more catch error class _CODE_ reasons : 1 able put / catch _CODE_ shutdown ( ) ( I method raising exception SQ s code ) 2 design import - wize _CODE_ deal hazelcast framework stay
! [ MAJOR ] ( severity : MAJOR ) call _CODE_ ( ) accessing [ ! [ rule ] ( ) ] ( )
I thought ll move WS
! [ MINOR ] ( severity : MINOR ) a TYPE_1 parameter instead [ ! [ rule ] ( ) ] ( )
! [ INFO ] ( severity : INFO ) forget remove deprecated code [ ! [ rule ] ( ) ] ( )
method index view
AFAIK s responsability DAO METHOD_3 VAR_1 a higher layer a _CODE_ WS
! [ MAJOR ] ( severity : MAJOR ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
inline line 58
I pattern a supplier compute error message org sonar server ws _CODE_ ( condition _CODE_ arguments )
create a new list immutable
reason moving call METHOD_4 configuring loggers SLF4J
STRING_1 allowed projet keys
replacing lines 221 222 a method _CODE_
need define variable early _CODE_ METHOD_9 ( VAR_1 ) ; VAR_2 commit ( ) ; rid ugly variable initialized nullclosing connection important correct code pass VAR_4 METHOD_9 ( wouldn t closed a single SQL session HTTP request )
suggestion : rename output
remark : I feedback call classes _CODE_ ws I don t a strong opinion this…
! [ MAJOR ] ( severity : MAJOR ) define throw a dedicated exception instead a generic [ ! [ rule ] ( ) ] ( )
more need instance TYPE_2 _CODE_ instances produced _CODE_
constant WORKER_UUIDS 1 a UT missing ( UT existed fail entry WORKER_UUIDS map current local endpoint isn t cleared ) 2 entry cleared another piece code useless
I d put starting CE worker processesthere need wait cleaning process broadcasting worker uuids soon important
else conditions dropped return decrease cognitive complexity
+ s changed append s
limit page size
strange call simply new TYPE_1 ( ) METHOD_2 ( key ) I miss
exception VAR_1 METHOD_5 VAR_1 configuration done METHOD_5 called
line builder method IMO s context sensitive
private welcome java world : )
! [ INFO ] ( severity : INFO ) forget remove deprecated code [ ! [ rule ] ( ) ] ( )
a temporary hack ? : I saving state View I model ( s called a service case ) i e _CODE_ _CODE_ ( VAR_2 ) compose _CODE_ _CODE_ / _CODE_
yeah a converter converts model domain objects _CODE_ hasn t done I ve understand domain stuff wrote : - ) / / edit atual
flip equals ? TYPE_2 equals ( VAR_2 getId ( ) ) ? _CODE_
_CODE_
doesn t VAR_1 add return
DAT
need super
cleaner export fields decoration class
purpose no_op ? listener called detached
wouldn t enough null
mind removing System
call super METHOD_1 ? avoid VAR_2 attribute declared protected
method parameterized
method parameterized
suggestionreturn ( node VAR_1 & TYPE_2 VAR_3 ) = = TYPE_2 VAR_3 ) ;
TYPE_2 METHOD_4 ? VAR_1 include file separators
Optional ( )
style line argument
junit s annotation link a github issue bumping compiler ? ( )
junit s annotation link a github issue bumping compiler ? ( )
METHOD_1 called METHOD_4
throwing exception instead logging error ? happen thread exception thrown ? server ? i m fine checking inputs received parties adding exceptions code dangerous knowing consequences i missing
need null check
add log error catch statement
error warn ? sending a 500 user
a matter preference return METHOD_2 ( VAR_1 ) > VAR_2
necessary ? I thought assignments atomic operations
public protected
want expose caller ? I e : allowing skip instrumentation ? I m thinking want protected ( test classes call )
_CODE_ want declare exception
_CODE_
I missed bounded type parameters : - ) I don t create separate versions METHOD_1 methods ? ? protected TYPE_4 TYPE_5 METHOD_1 ( Long VAR_1 TYPE_2 ) ; protected TYPE_4 TYPE_5 METHOD_1 ( Long VAR_1 String ) ; protected TYPE_4 TYPE_5 METHOD_1 ( Long VAR_1 Object ) ;
repeat ? calling ( ) correct don t call METHOD_2 ( ) subsequent constructor
happen
need method ? people call TYPE_1 METHOD_1 ( )
totally mess calling repeatedly shouldnt expose kinda methods want control VAR_2 set a separate constructor tests set zero dont want wait - static set constructor integer field
want abstract
METHOD_4 a finally block
need count ? VAR_1 size
delete boolean log statement ? I s variable
_CODE_ ( expected = TYPE_2 class ) I checking exit code equals - 1 important
( expected = )
simplify test method : void _CODE_ ( ) throws Exception { TYPE_1 config = TYPE_1 getInstance ( ) ; config VAR_1 ( TYPE_4 VAR_3 STRING_1 ) ; String [ ] args = new String [ 0 ] ; TYPE_3 METHOD_2 ( args ) ; }
need static
need static
wouldn t clearer iterate values foreach syntax : ( Long : VAR_2 values ( ) ) : VAR_1 + = ;
method useful public I need PR happened _CODE_ method ? I need I add
ve added multiple copies method put a utility class
code changes class throwing more exceptions other IOException change throws definition
a bit strange pass timer version serializing - timer rollups gauges counters overloaded methods named METHOD_3 accepting arguments i e ( Object Type ) - timer rollup types other _CODE_ argument called timer serializer
a static field class
static
add VAR_1 list VAR_3
method return a public static final set static initialization avoid map lookup object creation call
TYPE_1 _CODE_ ( ) ( base method class ) map more overrides
code
VAR_1 VAR_3 collection time greater update time ? allow uncontrolled update VAR_2 setting
unary prettier
I m correct VAR_2 millis ( System VAR_1 ( ) / INT_1 ) - VAR_2 ) more correct : 1 ) I m wrong nano stamps mark a file age shouldn t 2 ) concerned age file System currentTimeMillis ( ) good enough nanos needed multiple files millisecond nanos wouldn t give a good indication age - - millis - - epoch need part file
disregardable : method a job protect stupid programmers _CODE_ replaced start ( ) called
I obj = = null || ! ( obj instanceof TYPE_1 )
null check
args
throw new RuntimeException ( )
I method synchronized easier read
art : return VAR_2 = = null || VAR_2 length < 1
art : personally I lean a guard statement javaif ( entity = = null ) { return null }
I don t agree change I want list existing members don t want send messages
assignment removed
refactor 1 line
placeholder { } placeholder
warn insufficiently dire a violation a fundamental assumption groups system error ? I m returning effectively a random selection illegally multiple groups behavior I I d fail exception exception results entire portal falling dead exception fails specific group operation computed multiple groups alas
strange
opportunity JDK 7 multicatch catch ( IOException | TYPE_3 )
undetected error condition multiple VAR_1 match
undetected error condition multiple TYPE_1 s ? a failure - inducing error odd state affairs worth logging
undetected error condition VAR_3 multiple group definitions matching
delete throws Exception
I I throw exception instead silently accepting e g throw new RuntimeException ( unable transform e ) ;
intellij continuously recommending simplify code i hard understand
simplify _CODE_ = VAR_4 equals ( VAR_8 ) ;
I m I want line output ID prefixed spaces preference ID line prefixes output piped other processes parsing pretty printing basically [ plumbing porcelain ] ( ) distinction
logged error shouldn t logger warn
a filter return passing element event content handler ll unbalanced tree correct
s method unchanged modify interface catalog instead s add null checks method
break loop VAR_3
+ _CODE_ return type
+ _CODE_ return type
shouldn t VAR_3 = null
METHOD_5 ( ) VAR_3 remove METHOD_5 ( ) call
need null checks delegate a common method
need null checks METHOD_1 delegates a method call indirection avoided call new method
changed original METHOD_4 work ?
moved
_CODE_
necessary
unnecessary forgot other new constructors
2x = ? L64 & L66
needs VAR_1 = true
done checks class
redundant static factories public constructors public API especially s multiple overloads some other processors choose expose
square formatting
A small trick : TYPE_6 implement func0 < Map < TYPE_3 TYPE_4 > > assign map factory function - t ( ) constructor delegation assign final fields explicitly need extra class
s wrong calls unsubscribe _CODE_ / _CODE_ path unsubscribes child VAR_1 added VAR_3 instead VAR_3 added child constructor forwarding
_CODE_ implement TYPE_1 METHOD_3 METHOD_4
forgot commit class new TYPE_3 < T > ( VAR_1 ) a generic class
( 1 )
inline
reversing - else I PMD complains btw
nested s collapsed &&
iterate VAR_2 values ( ) avoid list allocation ? want array structure performance ? winning big iterating values ( ) constructor ArrayList
don t want give count capacity hint
need return
turn a < b ? - 1 : ( ( a > b ) ? 1 : 0 ) instead
setting variables default construction a - op semantically instructions executed construction object longer
child s requests hang child doesn t receive element requesting more I d instead write : _CODE_ < T > result = new subscribeer < T > ( ) { } child add ( result ) ; return result ;
don t override _CODE_ request VAR_4 subcsription - op removed intention request downstream requests I pre - start upstream meet
experimental
METHOD_4 ( ) ; redundant METHOD_5 call LGTM removing line
synchronized removed
field VAR_2 nulled free memory
eventually emit _CODE_ consciously wanting handle error individually instead composite
chain added won t set chain VAR_1 = true
doesn t clear VAR_3 copies pass Set replace null _CODE_ < TYPE_1 > VAR_1 = null ; synchronized ( ) { ( VAR_2 || VAR_3 = = null ) { return ; } VAR_1 = VAR_3 ; VAR_3 = null ; } METHOD_1 ( VAR_1 ) ;
I don t METHOD_1 a definition : semantics write guaranteed - ordered previous write reordered subsequent operations ( equivalently visible other threads ) some other volatile write synchronizing action occurs )
safe ? VAR_6 ( ) method want consistent reads
add type parameters constructor calls
a conventions exception VAR_3
shouldn t calling METHOD_2 ( STRING_1 + VAR_1 ) concise distro properties
I d println
static imports ( e g TYPE_3 METHOD_2 ) static imports ? mixed bunch e g _CODE_ * * * * imports plenty other cases * * * *
more static imports
more static import
static imports soon ; - )
another static
empty string METHOD_1 ( )
null check redundant refactor code belowif ( TYPE_1 equals ( VAR_1 ) && SAFARIBUNDLEIDENTIFER equals ( VAR_2 ) ) { return true ; } comparing a String constant a variable contents null check automatically care equals ( null ) false
_CODE_ return empty list null
need
avoid VAR_1 glance throw a TYPE_1 avoid changing base close method - need throw Exception ? doesn t need checked exception thrown - means won t need override extending classes
I guess blow
others need remember VAR_3
run thread call sever VAR_5 ( ) method blocking
a _CODE_
supposed atomic VAR_1 added ? example happen I 10 entires 4th exists
add { statement style guide
need a VAR_3
add braces else blocks maintain consistency rest code - style : )
place lines block
statement block
silly ifs collapsed empty VAR_1 a length < INT_1
needed simplify code
tiny mention ( I ve alot PR ) s sorta useless ( ) e getMessage ( ) pass a more specific error message throw new RuntimeException ( e ) ;
change call ? calls equal previous shorter I missing
a bit risky essentially fixing configuration test env METHOD_1 method change test env configuration remember change method some test run env configuration ( pre post )
please _CODE_ created
I don t need ll verify
a strange check a reason instead instaceof
trivial : missing break ;
I d encourage start minimal / basic unit tests waiting perfection ll I concerns UUID parsing fragile unit tests prove working a basic level helpful especially client REST API literally send * * a text / uri - list need ensure parsing works expect
please consider VAR_4 null METHOD_2 return null
I auth system remain method
I auth system remain method
I auth system remain method
original query cacheable I param false
kind beats purpose METHOD_2 method code force hibernate execute DB statements : insert update I move METHOD_2 _CODE_ : * create a new empty resource VAR_5 * copy values * pass filled resource VAR_5 _CODE_ create ( ) enable hibernate DEBUG logging hibernate cfg xml SQL statements executes
I m afraid spam logs I bad experiences logging developing _CODE_ please reduce log level debug
create a METHOD_2 ( table ) method class change unnecessary other method
set 1 increased manually add site return list
shouldn t log DEBUG level
I d suggest log / throw error attempt rename a VAR_1 group UI layer ( caller ) attempt receive error message return instead response
destroy VAR_1 ? ( line 58 )
great map generics
add a line break curly brackets else error - prone
debug = true log call recursively surely ( debug ) { Log d ( text ) ; }
array necessary ? item
needed
simplifying method TYPE_1 ( METHOD_4 ( ) ) ) keeping evaluation METHOD_4 ( )
suggestionreturn VAR_1 ! = null ; I wouldn t validity check place a _CODE_ constructed _CODE_ numeric values coming ES
I d prefer entity
entity
suggestionreturn new TYPE_3 < String > ( VAR_1 size ( ) TYPE_4 VAR_3 0 STRING_1 VAR_1 null ) ;
s method private asks s utility client callback
s method private asks
s stick T instead Optional < T > A huge number folks asked roll Optional change _CODE_ Optional isn t loved
public
s ensure VAR_1 element rid nullability _CODE_ ( )
s a constructor a _CODE_ align other modules
need final keyword local variables
javareturn VAR_2 = = null ? getProperty ( ) getName ( ) : VAR_2
hmm encoder s _CODE_ property string output events coupling separator output events regex split message string ideal I regex split message string separate separator string events
don t project open ATM a null check ? field view mode a populated readonly property set ( I don t currently V8 )
I generally dislike pattern : X var ; { X = ; } catch ( ) { } couldn t move METHOD_3
shouldn t [ TimeUnit ] ( ) instead plain strings interval definitions
want boolean VAR_5 = work
please extract a local variable : _CODE_ VAR_5 = new Date ( ) ; TYPE_2 status = new TYPE_2 ( VAR_1 VAR_5 VAR_2 VAR_3 ) ; VAR_6 METHOD_1 ( status ) ;
ah _CODE_ allows ? rewrite long more readable form : javaif ( result _CODE_ ) { return VAR_5 ; } return _CODE_ ( ) ;
s move methods don t benefits extracting : )
bug : open a security hole : a direct call / _CODE_ / hudson plugins sshslaves _CODE_ / _CODE_ a user TYPE_4 READ permission ( anonymous ) enumerate credentials I meantjavaif ( VAR_1 = = null || ! VAR_1 METHOD_2 ( TYPE_11 VAR_3 ) ) {
don t need METHOD_3 METHOD_4 anymore call METHOD_5 ( user VAR_2 )
please remove unnecessary super ? thanks
logic part METHOD_2 function
sysout
replace description else
falls binary compatibility
METHOD_2
I legacy event fired new event overwrite legacy result
I argue point punishing modders put method doc changing affect pick blocks
event fired time e g mods dynamically adjust other mods items burn times
called
INT_1
a method modders share recipe types ? enum system extender some form ( _CODE_ ) good
update custom sides supported
TYPE_1 METHOD_2 ( TYPE_2 : : METHOD_3 ) sufficient
welcome world limited packet sizes explode explode fast hijack vanilla packet
default config
suggestionprivate String [ ] METHOD_1 ( String String VAR_1 String [ ] VAR_2 String VAR_3 String [ ] VAR_4 String [ ] VAR_5 String VAR_6 )
Math max
4 spaces instead tabs
more clear supposed srg naming _CODE_ ? ( methods )
spaces TYPE_2 VAR_3
ANNOTATION_1 line patches size minimized
calculate registry id null a waste time memory
negating result function d avoid double - negation returning result
please follow formatting project braces a new line spaces parenthesis spaces comparison operators
missing override
formatting don t sqeeze line follow forge code style formatter :
ahem
a fan add - congruent VAR_3 inventory holes A add instead a indexed add
don t need change type
I private shouldn t overridden
formatting
javaif ( ! TYPE_4 VAR_5 ( VAR_3 ) ( VAR_6 ) )
shows don t optimization
event VAR_1 ( ) METHOD_3 ( ) = = TYPE_6 VAR_3 enough
javareturn VAR_1 > > 20 ;
PROPER solution METHOD_4 return null null _CODE_ valid anymore 1 11
javalooting = METHOD_1 ( ( TYPE_3 ) target VAR_2 VAR_3 ) ; code TYPE_5 class
dont duplicate code bounce new argument null more obvious remove deleting deprecated functions illustrates parameter null
I VAR_8 VAR_4 TYPE_8 fishy else open gui I null s a block side block clicked
I m versed _CODE_ required ? I thought _CODE_ - world making redundant
lists VAR_2 control dumb s trade list VAR_1 object
equals comparing strings java
shouldn t _CODE_ ( VAR_2 state ) :
javathis METHOD_1 ( METHOD_3 ( ) ) ;
minor a bit redundant
minor a bit redundant
deprecated removed 1 8 8 exists dont want fire _CODE_
needed ? other places added / removed casts / generics
raw type generic base
VAR_2 ! = null returns set_uncategorizedif VAR_2 = = null returns Collections < String > METHOD_2 ( ) ; case returns VAR_2 : P
moving fields breaks VAR_3 mods event
obnoxious buggy TYPE_4 determine permissions fake players
seriously dude don t reformat code reason
cases [ count ] ( ) 2 METHOD_4 ? I guess don t want exclude cases
nitpicking : I suppose new condition slightly more costly I put new condition
return loop var greater 2 rid set a switch : ( ) { switch ( c ) { case + : case * : case { : nb + + ; break ; } ( nb = = 2 ) return true ; } return false ;
personal preference ( suggestion account ) I : ( cond ) { return 1 ; } return 0 ;
method private
[ rfc ] ( ) code METHOD_2 ! !
private
t return parent
add assertThat ( METHOD_5 ( VAR_1 VAR_1 ) ) METHOD_6 ( ) ; assertThat ( METHOD_5 ( VAR_2 VAR_2 ) ) METHOD_6 ( ) ;
s alternative syntax 0 VAR_1
consistent usages ( )
need call stream ( )
I don t s moment feel free create note function names case insensitive : < ? phpecho count ( [ 42 43 ] ) \n ; echo _CODE_ ( [ 42 43 ] ) \n ; / / ! function greet ( $name ) { echo $name\n ; } greet ( john ) ; _CODE_ ( jack ) ; / / ! $a = 42 ; echo $A ; / / fails
return ( TYPE_1 ) METHOD_1 ( ) METHOD_2 ( VAR_2 ) instead
elena need check null VAR_2
IMHO s move call METHOD_3 METHOD_2
call check VAR_1 1 modifier private private combined smth else
casting TYPE_3 useless
elena method return null
! [ MAJOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
! [ MAJOR ] ( ) change instance - reference a static reference [ ! [ rule ] ( ) ] ( )
I a class comparison getClass ( ) instead instance check subclasses t considered equal e g a donor a donation id
shouldn t : VAR_5 METHOD_3 ( VAR_2 true ) ; including deleted donors
I _CODE_ want check lke : List < String > values = VAR_3 METHOD_4 ( VAR_1 ) ; return values isEmpty ( ) ? VAR_2 : values ( 0 ) ;
expecting exception invoke METHOD_4 ( ) call builder VAR_4 ( ) line 47
instead modifying method update converter field static call method class initialization ? instead requiring work ( allocation ! ) time a logger created s done application loads
VAR_3 set constructor
need declare exception types calling VAR_1
purpose explicitly stringifying VAR_1
I want result _CODE_ offer instead VAR_3 size ( ) > = VAR_4
这里有问题，如果设置需要加锁，那么获取就应该也有锁。然后如果是单个 boolean，完全可以考虑设计成原子变量，加锁毕竟太重了。
return index = = 0 ;
return ! VAR_1 equals ( TYPE_1 ) ;
return time > = VAR_1 ;
为什么这里赋值了两次？一次是 synchronized 一次还不是？
这变量不是 init 的时候初始化的吗？为什么会有 null 的可能性？
这个地方该用stringbuilder，性能更好，不需要考虑thread safe
necessary
I - work code need move code block
check ( VAR_1 METHOD_2 ( ) instanceof TYPE_3 )
don t create temporary VAR_5 array VAR_3 METHOD_3 ( VAR_2 ) instead
great METHOD_1
IllegalStateException
s change long instead casting
defaults field defaults
( conf ) behaviour : _CODE_ = conf _CODE_ ( ) ; constructor ( ) doesn t
TYPE_2 t - > TYPE_1 t = new TYPE_2
pedantic checking VAR_1 < 0 || VAR_1 > = VAR_2 )
Exception logged debugging purposes
shouldn t happen silently swallowing exception
5 ? I feel throw exception
lombok
doesn t strike reasonable add a field call set : D
reason noted training VAR_1
player state setter mag niet public - - > zie branch #145 ( clear DB als player gewonnen en _CODE_ als player verloren )
checked VAR_3 ( VAR_1 )
package access ? want mag alleen aangeroepen worden door de Builder klasse
caused problems tests A approach ( ultimately more user friendly ) variable length fractions example : adjustments tests consistently truncated ( H2 supports milliseconds tests comparing microseconds machine )
please System _CODE_ stream line 49 _CODE_ spaces instead tabs _CODE_ ( ) _CODE_ ( ) indentation weird _CODE_
s class exact floating point calculations I 0 0 allowed delta
ensure VAR_2 null
need null check
a single line enough : ( _CODE_ ) return VAR_1 substring ( ) else VAR_1
Arrays asList ( VAR_2 )
return VAR_4 ;
personal preference brackets line loops condition a blocker merging
return ; enough
TYPE_2 extends RuntimeException unnecessary overhead
write scratch
s extra handling TYPE_2 caught new code behaves : exception thrown VAR_1 ( page ) thrown ! - catch dispensable s leave code
infinite loop ? wanted pass a cast version VAR_1 _CODE_ instead
want allow < null > values primitive boolean instead java lang Boolean object
I don t references setter restore class ? class meant constructed values creation a properties file support serial settings : / romraider / src / main / java / / romraider / logger / external / apsx / plugin / _CODE_ java
👍really minor return avoid integer boxing TYPE_1 METHOD_2 _CODE_
I default implementation return - unchanged a overhead closer prior behavior introduction method easier reason happening
VAR_8 / _CODE_ instead _CODE_ variants couldn t write VAR_7 avoid boolean
btw TYPE_1 m restriction necessary E g implementation _CODE_ extra slow - caused TYPE_3
suggestionthis VAR_4 = VAR_3 VAR_4 ;
remove exception annotation parent class
instead METHOD_2
utilize autoclosable input stream ? ( TYPE_3 VAR_3 = METHOD_2 ( VAR_1 ) ) {
isn t a runtime check method validate assertions enabled
s worth changing I common cases TYPE_2 creation avoided ( types match undefined case precedence case )
required ? _CODE_
suggestionreturn VAR_1 METHOD_2 ( ) size ( ) > 1 || ( VAR_1 METHOD_2 ( ) size ( ) = = 1 && ! VAR_1 METHOD_2 ( ) ( 0 ) ( ) equals ( STRING_1 ) ) ; I don t null TYPE_1 entries
suggestion
suggestionreturn new TYPE_4 < > ( VAR_2 VAR_1 apply ( VAR_3 ) VAR_4 ) ; please care generic warnings don t ignore
suggestion
suggestion
return - 1 a wait ? moment return VAR_1 isolated I didn t s return METHOD_1
reasons platform aware return TYPE_2 buffer ( VAR_1 )
minor : ( Boolean ) instead avoid call
arguments wrong order
wrong arguments order
move brach created KILL
METHOD_2 ( ) helper method
METHOD_2 ( query VAR_1 ) VAR_1 _CODE_ ( )
redundant
VAR_4 a primitive int ? + + boxing ( values cached s a issue ) memory footprint increase due memory alignment I a short takes space int
redundant cast int
package private
package private
generally prefer assertThat ( ( ) ) error messages
aren t validations handled parser
VAR_2 ? ( adding a key ? )
I a manual ( ) ( null ) more efficient new ArrayList < > ( ) evaluated element
expected exception ocurs won t catch unexpected exceptions
copy necessary
_CODE_ ( ) ; shouldn t needed retrieve index mapping create table returns cluster state updated ( shard initialization async s required )
potentially partition boundary
I m wondering instead sense a unit test concrete _CODE_ ? cheaper execute more _CODE_ ve full integration tests filtering works integrated
I dont need introduce operation id generator concept plugin model operation builder plugin enrich operation model l direction approach dont engineer fine generate a operation id extensibility mechanism allows folks override wish
removed
check ( _params size ( ) > 0_ ) removed params null params ( ) fail cases params _CODE_ checks instead ( params size ( ) removed ) params _CODE_ checks ( current implementation size ( ) place ) replaced size ( ) ( )
curious approach a single line code
= = true
diamond operator
shouldn t operator instead
nice ! optionally / catch ( log ) IO exceptions method
want consider making VAR_2 line match params order
refactoring inheritance composition pattern extract _CODE_ _CODE_ methods e g abstract class don t implemented service
s VAR_5 anymore ; )
please add { }
move Math VAR_4 line index
reason access wrt property accessor function ? change getters / setters
call client METHOD_1 require a separate method retrieve _CODE_
call client METHOD_1 require a separate method retrieve _CODE_
choose a synchronized ( VAR_2 ) { } block label entire static method public static synchronized TYPE_1 METHOD_1 ( )
VAR_4 removed contents included VAR_2 ( device metadata )
variable unused
visibility method private
objects need closing
check client null ? shouldn t put a session queue / store client initialized
method simplified tojavaif ( TYPE_3 VAR_4 VAR_5 > = TYPE_3 VAR_6 VAR_7 ) { return TYPE_1 METHOD_2 ( ) ; } ( TYPE_3 VAR_4 VAR_5 > = TYPE_3 VAR_6 VAR_8 ) { return TYPE_2 METHOD_3 ( ) ; } return TYPE_3 VAR_3 ; worth wrapping TYPE_3 VAR_3 array output format consistent API level
import
Optional ? s absolutely redundant
I a prometheus user I want understand public appears / _CODE_ package
a valid change _CODE_ : > method called a transaction auto - commit mode changed transaction committed > METHOD_1 called auto - commit mode changed call a - op auto - commit started false user performed some SQL VAR_4 true user calls METHOD_1 ( false ) transaction a - op ( auto - commit _false_ ) means VAR_4 _still_ true change set false unconditionally
more expensive METHOD_1 ( ) called dozens hundreds times a single connection VAR_2 evaluated times close ( ) called connection checking VAR_2 flag ( currently ) more efficient
I prefer static import
a pull request _dev_ _dev_ java 7 / 8 please combine catch a multi - catch statement
I don t line adding t return VAR_1 aren t changing names mappings parameters
change ( VAR_1 = = null ) { VAR_1 = new HashMap } ; return VAR_1 ;
remove
import static please leave constant code
return List ( new TYPE_2 ( METHOD_2 ( ) METHOD_3 ( ) METHOD_4 ( ) ) )
check explicit METHOD_5 necessary
I called behavior METHOD_1 ( )
please static import TYPE_2 _CODE_
isn t ngrinder user dir
size 체크 없이 바로 addAll 해도 문제 없을 것 같아요
따로 result 변수없이 바로 return new TYPE_1 < > ( ) ; 가 좋을 것 같습니다
development runtime 모드를 판별하는 기준이 뭐죠 ? config에는 _CODE_ 라는 메소드가 있는데 이걸로 판별하는 편이 나을 듯
observation more cool return Collections _CODE_ ( ) ? option reduce null usage imho helps long run - I wrong
please leave - s intentionally referencing deprecated version
please execute method adding __AT session - needed
VAR_1
needs Class < ? >
static import METHOD_2
actual / equals flipped
I d equals clear don t care identity semantics ( readers won t verify set ) s fine _CODE_ equals ( request VAR_1 ( ) ( VAR_2 ) ) ;
private ?
ImmutableList ( )
package protected
( TYPE_2 ) needed
add message telling people builder
notjavareturn TYPE_1 matcher ( data ) METHOD_2 ( ) ||PUBLIC_KEY_PATTERN matcher ( data ) METHOD_2 ( ) ||PRIVATE_KEY_PATTERN matcher ( data ) METHOD_2 ( ) ;
public constructed _CODE_ ( bypasses security fine bad rely )
default constructor
default constructor
want check exists
e I thought needed VAR_4 prevent a warning apparently s a problem catch block empty
I don t need check log info logger check enabled enabled useful log line work
static import METHOD_2 match other file
static import
Set VAR_4 new byte [ 0 ] VAR_4 null a common trick consolidate checks size checks ( nulls ) careful add zero byte array outputs : )
add a version parent takes a normal module ? current _CODE_ confusing leads mistakes
double VAR_3
add : _CODE_ ( int _CODE_ int VAR_1 TYPE_2 VAR_2 ) METHOD_1 ( int _CODE_ int VAR_1 TYPE_2 VAR_2 duration _CODE_ )
field declaration
cast unnecessary VAR_5 a byte array s irrelevant negated mask promoted int I a case overly aggressive inspection
remove server impl
static import format
won t call METHOD_1 ( ) VAR_1 ( ) fails
static import format
implemented : METHOD_1 ( VAR_2 entry )
inline
return
thread safe _CODE_ a thread safe a _CODE_ external coordination ( e g synchronize lock ) change users _CODE_ de - duplicate read
I want reverse order
advantage compare 0 < = b && b < 256
else redundant remove ( original line remain unchanged )
move ( VAR_1 = = 0 ) check avoid extra comparison requested VAR_1 0
call _CODE_ length
don t block server finishes calling server join ( ) nice work cedric code kasper a lot cleaner & tested I impressed : )
return ( null ! = METHOD_2 ( VAR_1 ) METHOD_3 ( TYPE_1 class ) ) ;
final
_CODE_ _CODE_ ( _CODE_ class TYPE_2 class 0 )
call ( response status response VAR_1 ) checks throws IllegalStateException
warning : misses closing parenthesis ! ( TYPE_3 class _CODE_ ( getClass ( ) ) ) {
please remove
please rename function useful map sounds positions
input expected outcomes possibly move test cases ( reduce overhead )
unnecessary need variables compare result defined constants
[ 2019 - 10 - 01T07 : 16 : 01 665Z ] / home / catroid / jenkins_slave / workspace / catroid_pr - 3353 / catroid / src / main / java / org / catrobat / catroid / TYPE_1 java : 98 : error : find symbol [ 2019 - 10 - 01T07 : 16 : 01 665Z ] return VAR_1 ; [ 2019 - 10 - 01T07 : 16 : 01 665Z ] ^ [ 2019 - 10 - 01T07 : 16 : 01 665Z ] symbol : variable VAR_1 [ 2019 - 10 - 01T07 : 16 : 01 665Z ] location : class TYPE_1
private
don t need introduce extra local var assertTrue assign VAR_7 saves a line
please read correct usage _CODE_ ( ) returns a regular reference true save returned _CODE_ hold prevent garbage collector collecting context weak reference points introduce a new local var write result VAR_1 ( ) regular reference remainder method risk running a NPE
please move a function
please revert private
equals
setting object reference null saved XML _CODE_ saved project remaining
optimize a don t saving extra list VAR_3 added implemented a ticket resolve tickets understand creating a new list returning a property list ( pseudo code ) : iterate_over_lists : conflict_foundreturn true ; IFEND _CODE_ false ;
don t need a project Object becaus work lists project please change functionality work lists
skip VAR_4 VAR_6 false
please replace else construct
METHOD_2 ( ) ; enough return current instrumented applications contex
delete line add assert _CODE_ _CODE_ ( VAR_2 METHOD_3 ( VAR_3 ) VAR_4 METHOD_3 ( VAR_3 ) ) ; interpreting correct check cloned
_CODE_ point new _CODE_ ( ) execute ( VAR_2 ) ; consistent write new TYPE_2 ( ) execute ( VAR_2 ) ;
remove VAR_2 remove global / local test VAR_6
blows getValue ( ) returns _CODE_
instead adding removal procedure METHOD_1 id a cleanup project load
please remove
please throw original exception
create a new empty exception reuse
run a thread some VAR_1 provided stack
early return : return METHOD_2 ( ) && VAR_1 VAR_2 : java evaluates hand side condition null pointer exception occur
remove log altogether added debugging purposes I bad practice log debugging instead android studio s debugger breakpoints ftw ! : smile :
another log removed ( I s part commit please )
please VAR_3 = new File ( Constants VAR_4 VAR_1 + STRING_2 ) instead
please rename _CODE_ similar saving finishing activity
remove line please
please swap lines : laughing :
simply : return VAR_2 ( VAR_2 size ( ) - 1 ) equals ( VAR_1 ) besides remove VAR_3 unnecessary errorprone manually size list a seperate variable
necessary ? destroy activity
position necessary add order want : VAR_1 METHOD_3 ( new TYPE_3 ( ) ) ; VAR_1 METHOD_3 ( new TYPE_4 ( ) ) ;
please explain s negative zero please provide a code snippet result - 0 code
nice catch instead hiding bottom bar remove altogether backpack
need address element perform multiple checks operations series : METHOD_2 ( VAR_1 ) METHOD_3 ( R id VAR_2 ) METHOD_4 ( VAR_3 ) ; METHOD_5 ( VAR_3 ) ;
please call VAR_5 METHOD_4 ( ) give null ignores fragment position rules constructor
! thanks ! please move line top method logging error statement imo
don t need check null task triggers callback canceled problem exists crashlytics
( TYPE_3 VAR_4 : VAR_3 METHOD_3 ( ) ) { I ll a test asap
disabling notifications unsubscribe FCM ( immediately ) TYPE_2 METHOD_5 called
put commit ( ) TYPE_4 calls return TYPE_4 ; )
done check ? observer added METHOD_5 ( ) called
initialise member variable point declaration ( i e List < _CODE_ > VAR_1 = new ArrayList < > ( ) ; instead checking overwrite list other points save ( unnecessary ) check
s a static method anymore latest changes removed i
list exceptions
instead assigning variable update variable TYPE_2 METHOD_5 method
please undo calling METHOD_5 don t want METHOD_5 TYPE_2 odd
TYPE_2 METHOD_3 ( )
METHOD_4 ( TYPE_4 VAR_2 TYPE_3 METHOD_5 ( 1 ) ) METHOD_6 ( context ) ;
inline occurrences
please private put _CODE_ method > put private utilities called a public function public function stepdown rule helps program read a newspaper article - clean _CODE_ 10 : classes
obvuscating whats METHOD_5 called time create activity move _CODE_ _CODE_ else
please METHOD_4 return void - boolean return utilized - true line 93 reached METHOD_2 ( ) true
please remove condition ( content ( VAR_4 kill ) ) handling a problem don t VAR_4 kill process more details
initialization separate assignment ? ( line120 )
necessary ? _CODE_ ? please espresso METHOD_4 _CODE_ operations METHOD_1
please change : ( VAR_2 containsKey ( VAR_1 ) ) { VAR_2 ( VAR_1 ) clear ( ) ; } a lot easier read
please a local variable instead a member
keeping modified buttons necessary
methods block throw a TYPE_5
done creating ArrayList ( _CODE_ )
perfect ! : + 1 : a I m a picky : grimacing : need extends Object please Map declaration type javareturn new ArrayList < > ( VAR_3 values ( ) ) ; method a perfect text - book example tests : wink :
happen null returned current scene = null project = null ? a problem
_CODE_ instanceof check required casting
please inline remove
parser t needs preserve read xml introduce default values management model user put xml subsystem a default _CODE_ configure runtime services s stored management model reflect user provided configuration appears method called _CODE_ method I eliminating else block throws METHOD_7 fine
LGTM some minor points : remove throws TYPE_5 method catches exceptions return ; redundant final < class > VAR_4 combined assignment
I don t want call super implementation handling capability registration conditionally
a bit unnecessary avoid
super implementation a - op design
VAR_2 necessary
ll eliminate VAR_1 METHOD_1 method = ; statement
lines perfect job miss some statistics case anywaybecause s a race condition retrieving executor invoking
attribute allow expressions
doesn t belong method
doesn t apply isn t a map s a list strings strings opaque key / pair s WF management API typically handles maps
fail instead logging
I don t sense METHOD_3 expiration / passivation release access time isn t updated close ( ) METHOD_3 expiration / passivation
removed
a proposal - changing _CODE_ equals ( VAR_2 ) || TYPE_2 equals ( VAR_3 ) ? TYPE_2 : VAR_4 ; prevent some _CODE_
a resources a minimum d need close a finally block likepublic static boolean METHOD_1 ( String VAR_1 String VAR_2 ) throws Exception { boolean VAR_4 = false ; Path VAR_5 = TYPE_2 METHOD_2 ( VAR_1 ) ; ( TYPE_1 VAR_3 = TYPE_3 METHOD_3 ( VAR_5 ) ) { String line = ; ( ( line = VAR_3 METHOD_4 ( ) ) ! = null ) { ( line ( VAR_2 ) ) { VAR_4 = true ; break ; } } } return VAR_4 ; }
s reason wrap TYPE_2 add VAR_1 collection
order test runs successfully a debugger required some artifact test development
instead VAR_4 VAR_2
sense org jboss ee module class loader instead hoping
code push pop wrapped a block pop invoked finally
drop throws clause thrown _CODE_
a reason change info instead trace
null optional dependency functionally difference confusing reading code
stream closed
purpose ? pulled map key
lambda
I deleted reason export archive
return ( VAR_5 ! = null ) ? VAR_5 METHOD_3 ( builder ) : builder ; : )
normal - loop instead lambda
return VAR_1 METHOD_1 ( super build ( target ) ) ;
ArrayList constructed fixed capacity
lambda eliminated
lambda eliminated
ArrayList constructed fixed capacity
output VAR_3 ( VAR_1 iterator ( ) ( ) ) ;
remove useless debugging messsages
Throwable Exception ? failures reported WFLY - 8515 _CODE_ _CODE_ caught stand
TYPE_3 interface a _CODE_ ( ) method currently returns a _CODE_ ( ugh ) I ve opened rectify place ll need METHOD_1 ( ) methods return a _CODE_ decorator _CODE_ ( ) method returns instance
result variable removed ? currently METHOD_2 ( VAR_2 ) method called
simply ? ( VAR_2 - i > = 0 ) simpler : i < = _CODE_ a simple test ver
log tracef
log trace
allow TYPE_4
I avoid logging log debug CI servers don t a lot disk space logging unneeded data increase usage disk space
missing negation
need check TYPE_1 METHOD_1 ( ) assigning VAR_2
A check needed beginning method VAR_2 null
cruft _CODE_ respect header case adding props test shouldn t trigger reload - required s a bug
cruft _CODE_ respect header case removing props test shouldn t trigger reload - required s a bug
cruft _CODE_ respect header case updating props test shouldn t trigger reload - required s a bug
s a new _CODE_ based registering transformers - - implementations org jboss controller transform _CODE_
assertTrue
assertTrue
want add debug want debug whey backup validated ( special characters )
a warn necessary caused application due crons
I m church EAFP spread good word considered writing heavenly code ? ( directory mkdirs ( ) ) { files _CODE_ ( VAR_2 0700 ) ; } allow eliminate VAR_6 variable ll throw exception instead run iteration ( minute ) a single mkdir * syscall resource - intensive * I checked JVM _CODE_ a stat ( ) syscall instead
setting
needed ? t import class TYPE_1 avoid line 3
happen worried happen ? I m understand wrong type cache passed _CODE_ service
super METHOD_1 ( ) shouldn t
I don t called concurrently s called _CODE_ I don t mind leave
add config uploaded _CODE_ _CODE_ method
removed
generating identical streams key a good property a * VAR_1 * generator
shouldn t log
please put creation TYPE_2 else branch ( omit variable return new instance )
need override
redundant
StringBuilder please
check necessary File METHOD_4 doesn t attempt create VAR_2 exists
returning generic Map interface
a good fit - cycle
I closing resource scope allocated anti - pattern RG baselined java 7 - - resources instead please
a bug - call super remove super METHOD_1 fix ? I METHOD_3 called finally block
I starting reluctant catching Throwable rethrowing : change Exception embedded listeners
VAR_2 ! = null ? VAR_2 length + 1 : 1 more sense
double invocation performed purpose
I big returned plan more compare sizes assert ? I d recommend check returned store size
METHOD_3 ( ) implementation returns null TYPE_2 null
shouldn t throw _CODE_ ( ) case ? create interface support extend interface methods
s add : LOGGER debug ( e )
remove reference _CODE_ please functionality step - - step moved interface
s cov < _CODE_ || c cov > _CODE_
need METHOD_3 ( ) ? add confgure
check letters position I describing I meant information needed VAR_2 ( terms sending a msg ) a single letter TYPE_1 compare full kmer single letter
reason return int Integer shouldn t set 0 default call METHOD_1 ( ) initializing ll a NPE ( bug ! )
want benefit stringbuilder writesbuilder append ( VAR_2 toString ( ) ) append ( ) append ( VAR_3 toString ( ) ) string cat
s / else branch
minor point shouldn t testing accession number STRING_2
I silently ignore passing a null parameter other words i remove check assume VAR_1 null turns null caller automatically a _CODE_ chewing quietly
variable
VAR_3 unnecessary variable
unnecessary variable
a need variable
suggestionlog debug ( - task VAR_1 : + VAR_1 ) ;
change log
a unit test METHOD_1 exception obj null a instance TYPE_3
isn t dataset automatically executed
a constant ? allowed change
VAR_1 null
diffrent methods ? 1 new Date ( _CODE_ _CODE_ ( ) ) 2 ( Date ) VAR_1 METHOD_2 ( ) consistency code provide feedback select others
need assert size 4 I review : _CODE_ assertThat ( VAR_1 size ( ) ( 4 ) ) ;
pass null instead p
simply VAR_1 = VAR_1 enough
wrong method parameter VAR_1 false assigning true VAR_1 correct _
a good practice sysout logs instead
return false
leave change
I forgotten delete line
need line ? rid
I guess assert temporary result variable
required ? quiet superfluous add a throws clause a RuntimeException a matter fact unchecked Exception
reduced : javareturn _CODE_ ( ) map ( VAR_1 - > LIQUIBASE_SNAPSHOTS_FOLDER + File VAR_3 + VAR_1 + File VAR_3 + LIQUIBASE_CORE_DATA_FILENAME ) ; need change
log info log error
else clause redundant else clause returns return user
need assert null set null line simply inline temp variable _CODE_ METHOD_3 ( null )
intentionally ignore VAR_2 parameter
patient voided diagnoses test more solid
rid variable
unncessary
remove
_CODE_ s _CODE_ ( )
need putting class level
s pointless include throws clause TYPE_2 a runtime exception doesn t need caught
changed changing search methods
changed changing search methods
shouldn t DAO query
position create some tests class ? a examples :
test I suggest junit rule METHOD_2 throws IllegalArgumentException case clear case testing bind test exception message remove junit rule code replace _CODE_ ( expected = IllegalArgumentException VAR_2 )
assign a variable sake returning
intentionally ignore VAR_1 parameter
t simplify statement else
set VAR_1 creating another instance
please move METHOD_2 branch ensuring VAR_2 set due line numbers issue moved code changed
api shouldn t recursively fetch revisions api caller interested revision some reason s client code recursively
dont need local variable more VAR_2
dear changing method signature part ticket break compatibility users method please revert change
please openmrs generate test case plugin test style generator easily create scaffold new style : )
add a TODO item needs changed compare TYPE_1 objects instead ids finally remove deprecated methods ids
access set field hbm file don t need private setter
getter public setter private
validation handled _CODE_ doesn t exist need add
I imagine a new method takes patient object internally delegates wouldn t need changes
nice a sanity check cohort doesn t active membership patient
null memebership active depending passed _CODE_ I mentioned
incorrect _CODE_ VAR_3 ( VAR_1 METHOD_3 ( type ) ) ;
AOP retire methods i sets reason
correct _CODE_ _CODE_ need copied stay unchanged instead update order copy copy fields
_CODE_ _CODE_ need cloned undo change
needs undone
need undo
aren t superclass
I thought comparing strings ? i expect equals
forgot set VAR_2 VAR_1
I thought drug null a _CODE_ VAR_1 i setting
forgot set set VAR_2 VAR_1
don t need else clause redundant return null
methods override annotated @Override I t quickly correct
private
private
private
intended start method called line 189 : VAR_2 start ( ) please revert need annotate run method ( line 177 ) : ( squid : 3AS1217 ) / / intentionally start a new VAR_2 wrap run call a session
intended start method called please revert need annotate run method ( line 270 ) : ( squid : 3AS1217 ) / / intentionally start a new VAR_2 wrap run call a session
remove else wrong needs fixed test data invalid
line i e : return VAR_2 list ( ) > 0
don t set fields call save
provider prescribed order person discontinue don t copy field
don t copy orderer
I a set isn t convention supposed a set
avoid duplicating code call html ( ) fetch
DAO don t throw _CODE_ subclasses general remove
reason return null a void
fully qualified class
need build a string instruction ( other a + b + c ) a StringBuilder
( TYPE_5 )
great feedback thanks time prompted suggestion I concerned Class VAR_3 ( ) ; optimized aggressive optimizer result unused concerns unfounded throws checked VAR_11 a potential side - effect 🤷‍♂
reasoning making protected ? internal class subclassed
a change behavior driving ? careful making changes behavior issues migrating newer version mockito
exception message consistent handle exceptions a a reporter class typically throw exception derives _CODE_ message needs clean actionable user I suggest create a high level unit test demonstrates case standpoint user run test observe exception a newbie mockito understand exception message able resolve problem quickly
infocation → location
need add final
message more actionable ? user ? File a ticket
unfortunate fix #1232 improve API base PR change
spaces = =
return new ArrayList ( ) new _CODE_ ( ) ? a bit more compatible some edge cases ( adding stuff list returned capturing matcher )
fantastic coverage thank
I _CODE_ cleaner more DRY
a conflict current master : s choose another I fine specific preference
s safe content system properties properties mutable AFAIK / change / future versions java jvm / jdk vendor love PR : )
needed ? [ _CODE_ _CODE_ ( ) ] ( ) filters TYPE_2
instance check
instead casting I prefer return type
restrict enums appended a collection a list other types ( e g Collection integers strings ) filter removed allow types collections ( allow buffer append ( col1 ) line method run other types )
inlining VAR_2
a completely change ; please don t mix changes a pull request
picking other classes file referencing class ( class ) consistency i e return VAR_2 ;
please include unrelated changes a single pull request thanks
test wrong title states minutes range hour range ( INT_1 ) minute 0 checked
suggestionreturn isEmpty ( VAR_1 ) ? VAR_1 : VAR_1 + METHOD_2 ( VAR_2 ) ;
suggestionreturn METHOD_2 ( VAR_1 ) ? VAR_1 : VAR_1 + METHOD_3 ( VAR_2 ) ;
suggestionreturn isEmpty ( VAR_1 ) ? VAR_1 : METHOD_2 ( VAR_2 ) + VAR_1 ;
suggestionreturn METHOD_2 ( VAR_1 ) ? VAR_1 : METHOD_3 ( VAR_2 ) + VAR_1 ;
shouldn t return false ? empty array empty _CODE_ WDYT
don t need a - catch simply ( expected = TYPE_2 class )
don t need a - catch simply ( expected = TYPE_2 class )
result isEmpty ( ) instead avoid creating iterator instance
whoops removing ? : - )
debug
done
need print stacktrace passed _CODE_
core swap VAR_1 block ? core swapped optimize enabled
_CODE_ code leftover removed
throw IOException ( e ) instead else check
shouldn t able replace : javareturn VAR_1 METHOD_1 ( ) s unset s a bug
unchecked cast warning
/ catch removed
check RuntimeException TYPE_3
public please mentioned
introduce parameter
#701 asked lock removed I reading correctly
protected
hmmm a
System a places System err messages stderr I a examples other bindings
System instead System err
division prior casting int
package protected test buy a subclass wouldn t necessarily
shouldn t propogate exception
exception propogate method junit care logging details
errors caught else ? a reason exceptions printed instead thrown previously
import
static import
awkward indent spaced indented code left column
VAR_7 METHOD_1 intended public
another reason initialise declaring fields I guess don t repeat initialisation code
complete circle test check trigger added removedsuggestions VAR_2 ( new TYPE_2 ( STRING_2 ) ) ; assertEquals ( 1 s VAR_4 ( ) size ( ) ) ;
unnecessary handles
remove cast
propagate underlying error
VAR_3 default true set user ? a lot unintended screen events
needs a default false case VAR_1 METHOD_5 ( STRING_3 false ) ;
eliminate repetition - please check logic thingpublic String METHOD_1 ( final TYPE_1 VAR_1 ) { ( VAR_2 ! = null ) { final TYPE_2 VAR_3 = VAR_1 METHOD_2 ( VAR_2 getId ( ) ) ; ( VAR_3 ! = null && ! TYPE_3 isEmpty ( VAR_3 getName ( ) ) ) { return VAR_3 getName ( ) ; } } return ; }
secondary false
context designed cloned modified copied
public
passed constructor a set - method
lets change default GRACEFULLY
remove
remove
doesn t
doesn t
line redundant
store VAR_1 session avoid json des / serialisation
retrieve TYPE_2 object
METHOD_3 ( 0 ) necessary
won t change prevent TYPE_1 management interface inputting VAR_2 ? ( information other VAR_2 edited )
あ、ごめんなさい。 _CODE_ _CODE_ ( new TYPE_1 ( ) ) execute ( ) で問題ないです。もう一つの _CODE_ についても同じですね……
import static method remove Assert
condition VAR_5 METHOD_1 ( VAR_1 VAR_3 )
method throw a TYPE_2
please don t log starting load thread : )
general : necessary review origins code IMHO VAR_4 code commit
I d extract service method _CODE_ ( id )
properties please replace true
complicated
intended
don t need function constructor
need change class ? I find a reason
please avoid another setter setter
synchronized
I write return VAR_2 ( url )
bitwise &
I doubt VAR_3 needs initialisation s injected
expecting more entities TYPE_2 class ? more store ( ) private TYPE_1 VAR_2 ; currently variable accessed local scope METHOD_1
convert _CODE_ : VAR_7 a constant avoid hard coded strings
need extension ? I removed tested abnormally large bases work
unnecessary remove extension altogether TYPE_2 VAR_2 = VAR_1 METHOD_2 ( TYPE_3 class ) ;
initialized VAR_1 s change remove setting METHOD_1 ( ) final : private final Date VAR_1 = new Date ( ) ;
moving creation TYPE_3 METHOD_3
I line VAR_1 remove ( STRING_3 ) ( ) block
shouldn t key
VAR_2 getName ( ) serves purpose TYPE_2 METHOD_1 : throwing NPE VAR_2 null
TYPE_1 < Object > instead
version catch block more succinct : } catch ( TYPE_5 TYPE_6 | TYPE_3 ) { VAR_2 = true ; }
a single catch block
guava s ImmutableList ( ) save a typing cases
return e toString ( ) ? silent failures fun track
suggestionprivate static void METHOD_1 ( TYPE_1 VAR_1 List < TYPE_2 > VAR_2 TYPE_3 t ) throws IOException {
default bool int need clarify suggestion
_CODE_ ( VAR_1 INT_1 ) ;
more sense throw IllegalStateException instead _CODE_
static imports TYPE_3 methods
yous resolve bit _CODE_
_CODE_ ( 0 VAR_1 METHOD_3 ( ) size ( ) ) ; assertions ordered assertEquals ( expected actual )
suggestionthis VAR_5 = new TYPE_2 ( VAR_2 VAR_3 METHOD_1 ( ) null ) ;
hardcoded instead argument ? : )
a toString ( ) building a string
key null
single check ( ! VAR_1 && METHOD_2 ( ) ) interested single outcome
rubbish
return T
line 33 throws error line won t reached prior PR METHOD_4 executed a finally block
moved ( result ! = null ) { block sorting a - existing result sense throw exception TYPE_2
return a new node instead failing
static imports
update index point current iteration loop convert incident _CODE_ [ i ] = METHOD_2 ( VAR_1 [ i ] ) ;
suggestionthis VAR_2 = VAR_2 ;
shouldn t set object id
need add a null check safety layouts dynamic need able handle case disable a TYPE_2 doesn t exist I previous example wasn t a null check piece code optionsmenyoncreate call assert existence items summary disabling a VAR_1 item check null means
add a null check null add a VAR_1 item invalidate VAR_1 find some adding VAR_1 item view
null handling source intended
debug log hash query tracking
( other filters ) need type reason a _CODE_ a filter * a _CODE_ filter filter want METHOD_7 other regex filters omit VAR_3 equals METHOD_7 compiled versions filter field s parsed version puts a space front
replace byte metric i = 0 total iterations VAR_3 + 1 starting i = 1 fix
I isn t necessary VAR_1 wasn t set NPE thrown code attempts call METHOD_2 ( ) line removed
srs properties s oskari native srs s codebase
I wouldn t expect public boolean delete ( ) throw a RuntimeException case delete instead I d expect false returned Exception thrown case actual Exception ( DB connection unexpectedly error d )
set VAR_1 true
calling super METHOD_1 ( ) ; unnecessary _CODE_ implementation empty
true I guess return empty string instead null a filename ? i + 1 = = length ( ) _CODE_ ( ) clearer ? foo isn t i = 3 length ( ) - 1 = 3 check wouldn t work properly ? check morning s late thinking : D
file read METHOD_1 METHOD_2 ( ) METHOD_1 access point METHOD_2 ( )
I logged debug
String isEmpty ( ) other places oskari biggie - a heads
length ( ) = = 0 - > isEmpty ( ) I ll stop mentioning rest : )
add
0 a bad exception I versions easily 0 - based - 1
a finally block create TYPE_3 : TYPE_3 VAR_3 = { } finally { TYPE_5 METHOD_4 ( VAR_3 ) ; }
wait a user able pass a column s defined ? I _CODE_ returns _CODE_ s represent paths column families defined _CODE_ s s kind dynamic based _CODE_ some columns change creating simple table def ? - middle a update script ? I don t I deserves some clarification ( s unusual _CODE_ )
static I m blind
throw _CODE_ empty string passed VAR_2
biggie I guess practice ( Arrays asList ( VAR_2 ) ) ;
wouldn t a rethrow
I m missing some brackets comply normal code style
need cache VAR_1 superclass automatically cache VAR_1 _CODE_ called
please replace VAR_1 ^ ( VAR_1 > > INT_1 )
please replace change similar b ^ ( b > > INT_1 )
b ^ ( b > > INT_1 ) missed
b ^ ( b > > INT_1 ) missed
access attribute forbidden coding rules compiler : return x1 ; _CODE_ access field _CODE_ _CODE_ _CODE_ add prefix
javapublic boolean equals ( Object obj ) { return VAR_2 equals ( obj ) ; } class a delegation design pattern attributes VAR_2
javapublic int METHOD_1 ( ) { return VAR_3 METHOD_1 ( ) ; }
caution : VAR_1 parameter null
VAR_1 integer
VAR_1 integer
I suggest positive case more scenarios SDK > = INT_1
VAR_4 moved doesn t jar exists I guess
prefer multi statements stay separate readability
I find harder read
I don t explicit check needed
getPath return null
a usage path change isn t necessary
doesn t return null
protocol mandatory isn t necessary
Thread mandatory
packaging a default need
need
replaced Boolean _CODE_
getter / setter - located
unrelated task hand please refrain polishing code s class
tests property works ve added _CODE_ test left unchanged
return VAR_1 METHOD_1 ( ) ;
I don t ordering important
ordering matter ? providers a wins manner ordering important overlap providers
please put save - mode cron order properties aligned assertion
username password properties initialized empty string ( ) null ? A check isEmpty ( )
condition inverted RBAC username password empty call METHOD_3 method takes a bucket password I missed earlier
VAR_2 straightforward controls _CODE_
I don t need TYPE_3 toString ( url ) property a default localhost : 9091
a port clash else port INT_1 safer customizer didn t VAR_1
test passes assertion isn t TYPE_5 doesn t define a _CODE_ assertions needs written remove METHOD_3 ( TYPE_5 class ) test fail
declare TYPE_3 returned provide type information bean factory
extract a METHOD_5 ( ) method
org springframework boot test context _CODE_ _CODE_ ( Class < ? > ) overridden instead I method continue private I missed
a copy / paste call other constructor ve created TYPE_3 class
change appears unrelated
change appears unrelated
change appears unrelated
synchronized
hm migration feed sense archive _CODE_ methods - op
reading boolean expressions chained collection ands ors nots takes logical gate construction need a venn diagram grok extract some functions embody intent more readable
suggestionif ( ! METHOD_2 ( METHOD_3 ( R id VAR_1 ) ) ) { simplify ! METHOD_2 ( METHOD_3 ( R id VAR_1 ) ) METHOD_2 ( METHOD_3 ( R id VAR_1 ) ) = = false
suggestionif ( ! METHOD_2 ( METHOD_3 ( R id VAR_1 ) ) ) { simplify METHOD_2 ( METHOD_3 ( R id VAR_1 ) ) = = false ! METHOD_2 ( METHOD_3 ( R id VAR_1 ) )
apply ( ) instead commit ( ) save preference UI thread
suggestionprivate static TYPE_1 VAR_1 ( TYPE_2 url ) throws IOException {
suggestionprivate static TYPE_1 METHOD_1 ( String url ) throws IOException {
BTW convert lambda
I _CODE_ METHOD_3 ( ) equals ( TYPE_3 class getName ( ) )
I trim METHOD_4 method
I don t need tests combinations enough
please add TYPE_1 ( String message ) constructor TYPE_1 VAR_5 instead creating proxy Exception
related pull request I assume full STRING_2 - paths base path configurable
wrong
empty string null
super
please consistent other updating TK103 decoder
I agree trimming I don t understand need - case
case don t config
I sense some constant type names
refresh a performance issues
need line ? I removed
ternary operator code easier read case
declare generic exception
Exception included a separate parameter
remove null cases a default case
init group cache ? devices reference
replace tab spaces
traccar targets java 7 higher diamond operator hand side
throwing a RuntimeException lead unexpected behaviour a throw a checked exception deal explicitly case
I m wondering IOException sufficient catching Exception basically exception other IOException occurring kick situation fact caller follower _CODE_ ( ) catches Exception _CODE_ unexpected exception log warnings I part fix unexpected exception errors process wdyt
set variable null calling method result ugly _CODE_ abouttry { ( VAR_1 ! = null ) { VAR_1 close ( ) ; } } finally { VAR_1 = null ; }
clear properties _CODE_ _CODE_ void _CODE_ ( ) throws Exception { }
Long VAR_6
package - private
want add 2 more : - double check VAR_2 null - VAR_2 = null close prevent usage object GC collect
glance doesn t conflicts curator test curator locally I shouldn t include some curator test _CODE_ future - i e validate new changes don t break curator
resetting false a finally block test fails rest tests executed default
instanceof a code smell adding a METHOD_10 method base class ( _CODE_ ) a default return false
coding format change : ( VAR_2 ) { }
static
curious : checking METHOD_2 ? t call close multiple times
consider private s called
please add null check case _CODE_ ( ) fails early
need call TYPE_1 explicitly
casting int ? a long return a long handle overflow some
a private class tracking won t change super fields time changing variable need METHOD_2 time
don t need compare super I mentioned
changing line
doesn t difference nice condition consistent NIO implementation e g VAR_1 ! = - 1 similar
I action log fact happened
throw new RuntimeException ( e ) ; ( ) error more obvious test
reason static imports
boolean Boolean
boolean
public keyword needed interfaces public default
removed STRING_5 STRING_4 elements ? I VAR_2 list : String [ ] VAR_2 = { STRING_3 STRING_5 STRING_2 STRING_4 STRING_1 } ;
I don t check needed - sounds remove check a negative trigger illegal argument exception wrong upstream code s hard negative passed purpose accident
minor style : prefer return socket method assign VAR_3 caller
need check ? VAR_3 null reach
need check ? VAR_2 null reach
VAR_3
TYPE_2 supports - - resources code cleaner
static
don t throw TYPE_5 anymore
making public test purposes instead making methods public tests package don t need access modifiers inappropriately I inappropriately method shouldn t exposed applications public
mixture spaces tab line others enforce sort consistency formatting project ? I
java lang RuntimeException java lang error please include
write curly braces block instead 1 line
a _CODE_ VAR_2 simplify code ? example
please follow coding guidelines put code curly braces
please follow style guide mentioned CONTRIBUTING md braces / else statements
keyword methods member names
uri
List < String > instead ArrayList < String > declaration
nitpick : move VAR_6 front config fallback existing logic
need print VAR_1 toString ( ) ? VAR_1 getId ( )
add final keyword ? other places necessary
please follow style guide CONTRIBUTING md add field access turn > save action
calculating newest oldest data points CPU load ? s discuss more
returning a string instead a list
question
don t need introduce public ? package - access good enough
duplicate
super containsKey ( key VAR_1 ( ) ) ? _CODE_ provides containsKey
big overhead check log
List < byte [ ] >
warn relaxing kind exception error
access modifiers
mistake I mis - interpreted call shotdown method VAR_2 call _CODE_
change necessary
VAR_1 initialized body constructor
need care entry props ? test full control s props
i s put METHOD_1 ( VAR_2 METHOD_2 ( ) STRING_1 ) VAR_2 = VAR_2
METHOD_2 ( id ) ! = null simpler
safer assert exists assert doesn t delete
expect happen change assert
step necessary ? I thought affect reference method s scope
avoid scheduling flows ? please add a small note : else statement required
simply return VAR_1 ! = null || VAR_2 ! = null ; _CODE_ automatically suggests refactors
small - VAR_2 isEmpty ( ) shorter
constructor doesn t another initialize instance class w / o synchronization : private static TYPE_1 instance = new TYPE_1 ( ) ;
synchronized empty method
throw a NPE VAR_1 null want add a null check other methods
I easier read combined _CODE_ + = ( VAR_6 = = null ) ? : STRING_2 + _CODE_ VAR_4 instead VAR_6 I ll ps - ef output easier read put - dazkaban JVM params VAR_6
code removed key VAR_7 longer Integer a future < ? >
wondering line introduced 5dc4438fbdcc7ad6015a9d7574e00072b0534794 I some kind concurrency issue _CODE_ immutable I t cloning achieve
Assert required field final
common TYPE_2 e ( VAR_1 ) extracted bottom
need other METHOD_1 ( ) call ? sounds making scroll
logic sense VAR_2 ! = null logic happen creating object a redundant object
VAR_1 ! = null null check conditions necessary
break current logic showing added contribution
a user added suggested edits flow break current logic showing added
checks need performed
produce a NPE crash app VAR_3 VAR_2 null happen activity destroyed ( e g don t activities ) recreated coming editing
I code METHOD_3 work a problem means s incomplete understanding underlying issue ( )
fixed done
needs update VAR_2 setText ( ) R VAR_3 VAR_4 a %d
remove case STRING_1 a default case
please ternary operator
please ? ternary operator
please ? ternary operator
need
declared _CODE_ interface implementation flagged @Override
supposed ( VAR_1 ! = null ? VAR_1 toString ( ) + STRING_1 : ) + request VAR_3 ( ) METHOD_2 ( request VAR_4 ( ) VAR_2 ) toString ( ) ;
! VAR_1
return VAR_1 remove ( ) ! = null
_CODE_ void METHOD_1 ( ) throws Exception {
unrelated main purpose PR a breaking change branch jobs existing projects properties update changes method needed
slight performance enhancement _CODE_ = VAR_4 METHOD_2 ( new TYPE_1 [ VAR_4 size ( ) ] ) ;
defaulted _CODE_
glick - style annotations method returns ANNOTATION_1 ANNOTATION_1 line preceding access modifiers access modifiers return type
fire event monitor
ant : a good test style sense bug fixed catch unrelated problems set VAR_1 false initially set true calling METHOD_2 ( catch block )
mocks a custom project subclass overrides METHOD_4
style guide
code style
code style
middle : bug : code style
bug : code style
code style
return line sample app crashes ( wrong missing VAR_1 exception ) soon pause app
generally recommended = = enums comparison
need VAR_1 [ 0 ] = new TYPE_3 ( ) ;
Logger
a logger object
based understanding calling VAR_2 TYPE_3 _CODE_ guaranty return a TYPE_1 calling VAR_2 another type message throw _CODE_ consequence null check useless I missing
called VAR_1 possibly event loop threads shouldn t synchronized
change allows to1 Set correct VAR_2 exception message previously message include VAR_1 set conf wrong system property present 2 add stack trace exception enable logging
I m curious need initialize client need cassandra instance test class need JMX work
adding a new _CODE_ constructor param boolean METHOD_1 don t METHOD_1
feels weird ; I followingfilter ( verb ) pass ( ) ; filter ( verb ) drop ( ) ; ? drop skipped favor pass don t a test test calls VAR_1 reset ( ) ; adding filter pass / drop stuff exists PR I feel pass ( ) removed ( file jira )
personal preference ( aka call ) return new TYPE_2 ( ) ; dumby constructors TYPE_2
assign VAR_1 = return
shouldn t disable check
a method skip final
_CODE_
METHOD_2 replicas local s a dummy list ? 2nd predicate dummy list related
anymore
unnecessary braces single statement block ( bunch file )
redundant braces a single statement block
redundant braces
don t need typecast TYPE_1
VAR_1 null I VAR_1 METHOD_1 ( ) allocate a wrapper array varargs TYPE_1 METHOD_1 ( ) single arg version won t allocate
avoid creating extra intermediate list
a warning ? pretty asked
a finally block
ANNOTATION_1 _CODE_
a call logger System err ( class )
want set _CODE_ property _CODE_ ? _CODE_ internal feature - selenium webdrivers doesn t
TODO a _CODE_ I asking technically wrong some investigation good - multiple creations new instances TYPE_3 some performance impact another question TYPE_3 instance changed method _CODE_ called
I a clear reset values default - I : System VAR_1 ( System ) ;
instead dothis VAR_3 [ i ] | = VAR_2 ( i ) METHOD_2 ( state ) ;
don t need set objects explicitly null
VAR_4
VAR_4
general please avoid catching rethrowing unwrapped exceptions set _CODE_ ( ) catching
method IMO rewritten : javareturn ! VAR_1 exists ( ) && VAR_2 exists ( ) ? VAR_2 : VAR_1 ;
braces please
private
side effects please
public
I haven t tested code : 1 METHOD_1 ? 2 _CODE_ call VAR_1 METHOD_1
need release stopping
remove catch IllegalStateException
sadly class doesn t a serialization version id i m willing break pending jobs change please change doesn t break current serialization signature
s I merge changes _CODE_
don t need File VAR_3
override \n
call METHOD_2 security update broadcast create
result ANNOTATION_1
putting URI class kinda gross class METHOD_2 METHOD_2 base decisions s a STRING_4 character present I assume decoding won t work interpret unencoded + a space class shouldn t METHOD_2 caller responsible
crazy gross s explicit load time
return _CODE_ instead
want true
intuitively need a mastersecret a mastercipher other
else ternary
unnecessary
private s needed util
necessary
I enabled / disabled functionality typing slow some devices
want ll need explicitly set _CODE_ _CODE_
} else {
potentially strange VAR_3 type scheduling case VAR_3 needed
condition
depending stream type t rely return VAR_2 I ve learned hard follow commons - io s _CODE_ read instead
wouldn t grealy simplified primitive int s
o VAR_1 = TYPE_1 METHOD_1 ( VAR_1 TimeUnit VAR_3 ) dropped unnecessary
violates : natural ordering a class C consistent equals e1 METHOD_1 ( e2 ) = = 0 boolean e1 equals ( e2 ) e1 e2 class C note null instance class e METHOD_1 ( null ) throw a _CODE_ e equals ( null ) returns false
protected want
I m top head Double valueOf ( )
set empty string TYPE_2 gathering strings source code fail
empty constructor public modifier
strange getType ( null ) calls
VAR_1 instance _CODE_ obtain a _CODE_ METHOD_2 ( ) valid TYPE_2
Map element a service create another instance
useless cast
a TYPE_1 hidden behing a _CODE_
intermediate variable necessary
putting default : case switch ( switches default )
useless cast
cast necessary generics ; - )
cast useless Math VAR_2 returns a double
useless cast Math VAR_2 returns double
pls remove number regexp matching match a - input string
shouldn t log trace
invert statement - positive conditions easier understand
positive conditions fail fast approach improves code readability e g ( VAR_1 = = null ) { return null ; } return TYPE_2 METHOD_3 ( VAR_1 ) ;
logging pretty bad spam
comparing java sql Date java util Date
remove synchronization class
assumes VAR_1 null other parts code check prior
changing check VAR_4 0 changes fix issue savepoint released
close a finally block
need public
dedicated java time methods _CODE_ longer necessary
consider making static
TYPE_1 VAR_3 equals ( VAR_1 ) instead reference equality ? a difference write behavior a TYPE_1 a 23 : 59 : 59 999999999 TYPE_1 VAR_3 - equal
copy required
access needs synchronized
a _CODE_ method
unexpected consequence dfwe$ { } asdfa pattern a password property
want correct style please send another PR ? hard identify changes required unixsocket support
instead a boolean _CODE_ ( expected = TYPE_1 TYPE_3 class ) s a more universally accepted testing exception thrown
needed env variable wich set jobs
METHOD_3 done METHOD_1 ? shouldn t done start publish operation _CODE_ ? concern done publish buggy example : user changes sample war _CODE_ ( ) called _CODE_ ( ) called copy new changes sample war METHOD_3 overwriting changes ? correct current concern
_CODE_ _CODE_ implement _CODE_ odds _CODE_ ( TYPE_4 METHOD_2 ( ) METHOD_3 ( ) METHOD_4 ( TYPE_4 METHOD_2 ( ) METHOD_5 ( ) ) ) ; _CODE_ ( TYPE_4 METHOD_2 ( ) METHOD_5 ( ) ) ;
wouldn t simply return null VAR_2 null ? a 0 - length string effect visible
declare initialise empty string immediately overwritten system property
more expressive beif ( StringUtils isEmpty ( ) )
VAR_8 ? speaking variable imho
I don t understand rationale case don t save original annotation deployment config
I s - - resources fix sonar complaining I smth : javatry ( TYPE_3 repo = TYPE_4 METHOD_2 ( project ) ) { ( repo = = null ) { return null ; } return TYPE_4 METHOD_1 ( repo ) ; }
_CODE_ filter longer running - s rearrange performance currently filter work number pods
performed checked > = 2 elements VAR_2 potentially run _CODE_
VAR_1 instead VAR_3 _CODE_ ( ) left intentionally VAR_5 removed
keeping constructor more testable inject a mock TYPE_3
a niggle : i switch - case TYPE_8 default more readable
a niggle : s point full class ( including package )
definition VAR_9 VAR_7 type parameter casting needed
chance a race condition concurrent threads add entries ends replacing other
return new TYPE_1 ( )
VAR_2 = = null
set reference VAR_6 null ( consistent ) ? VAR_6 = null
void METHOD_1 ( String VAR_1 ) throws TYPE_1 { METHOD_2 ( VAR_2 true ) ; super METHOD_1 ( VAR_1 ) ; }
nope return true
I issues correcting other method signatures obvious diff happening code changed
t VAR_3 null point
line endless load linux a node zero children
new HashMap < > ( )
statements merged
related autopublish issue
NPE add assertion required STRING_1
( VAR_1 size ( ) ! = 1 )
yuck
array ? List < String > fine
cancel ( ) called thread adding line VAR_2 concurrent exception other thread calls _CODE_ ( ) works list _CODE_ ( ) return list I suggest wrap withsynchronized ( ) { ( ! METHOD_2 ( ) ) { VAR_2 add ( line ) ; } } call cancel ( ) command _CODE_ ( )
VAR_1 forEach ( b - > METHOD_2 ( b ) ) hate brackets
VAR_3 containsKey ( VAR_1 ) redundant
return type VAR_2 ( ) ( TYPE_2 ) ? doesn t add functionality hides methods user IDE auto - complete ( point empty interface )
visibility remain package - private
pumpkins easily duplicated
some other cases functionality item eaten similarily case ? baguettes edible
nitpick : class public method : _CODE_
weird caller enough pass VAR_2 wouldn t able call method VAR_2 false
generic method implementations error adaptationeverything method surrounded bytry { / / } catch ( _CODE_ e ) { throw _CODE_ adapt ( e ) ; }
replace catch : ( args = = null || args length = = 0 ) { throw new throw new TYPE_2 ( ) ; }
/ catch done generic methodsnot * raw
METHOD_1 ( ) throws IOException don t catch rethrow catch completely
didn t apply hint other methods / catch
/ catch TYPE_3 hit applied
odd DTO object represent exchanges response premature mapping data coping logic
METHOD_8 null server standard convention _CODE_ day
suggestion
_CODE_ < Integer > VAR_2 = new ArrayList < > ( ) ; ( Map < String Object > VAR_3 : METHOD_2 ( ) ) {
missing white space ) {
parameter task passed METHOD_1 ? _CODE_ ( Arrays asList ( task ) ) ;
batch service a class attribute
return null I suggest change function return type void remove return statement
suggestionif ( VAR_1 METHOD_3 ( ) instanceof viewinstanceof checks null
suggestionif ( VAR_2 METHOD_4 ( ) instanceof View ) { instanceof checks null
id smaller 0
error logger stack trace quiet wanted : suggestionlogger error ( e VAR_2 ( ) e ) ;
String filter = TYPE_4 METHOD_2 ( ) METHOD_3 ( VAR_5 ) ;
call method write
constructor needs private
wrong class ( TYPE_3 ? )
_CODE_ recursive recursive part
question put METHOD_1 field a map call other method ; )
need define throws IllegalArgumentException function extends RuntimeException public List < String > METHOD_1 ( String VAR_1 ) {
need define throws IllegalArgumentException function extends RuntimeException public List < String > _CODE_ ( String opac ) {
VAR_1 METHOD_1 discussed
public constructor _CODE_
public method _CODE_
don t assertions
lambda replaced method reference
lambda replaced method reference
edit process project ? ; - ) click METHOD_1 link wait redirect _CODE_ page
please remove debug helper ; )
add a lines call returning empty list ? I similar line removed
System println call needed ? remove call needed replace a logger call
missing _CODE_ public method move code class ride class usage
braces correct set double encode expression moved code fixed tojavaif ( VAR_1 getValue ( ) = = null || VAR_1 getValue ( ) equals ( ) ) { }
a NPE happen collection empty / null
change necessary ? new IOException logger
missing space offset Integer size
need test need a high timeout
TYPE_3 a closeable class created object closed a - - resources statement
TYPE_4 closeable a - - resources statement closing object a good idea
TYPE_4 closeable a - - resources statement closing object a good idea
please log error inform user
add a log message logged user information please move log call front TYPE_3 METHOD_4 ( ) call
please log error message / reason display user
assign empty list return
interface appended variable
TYPE_6 - exception
wrong formatting method please fix
modifier private redundant enum constructor - needs removed
modifier private redundant enum constructor - needs removed
wrong edit page projects returned ruleset editing
returning null avoided introduce unnecessary null pointer checks a empty object returned
return empty object instead null
error log call necessary warning call stack trace included
please [ - - resources ] ( ) statement instead handling manually
please [ - - resources ] ( ) statement instead handling manually
return null null pointer exceptions add a lot null checks
add braces
A VAR_1 exists a VAR_2 a VAR_2 VAR_1
add empty list check ( null check ) ? I necessary empty list statement
_CODE_ = TYPE_1 METHOD_3 ( STRING_1 Arrays asList ( new String [ ] { VAR_1 getName ( ) } ) ) ;
METHOD_1 work search process METHOD_1 data inserted 4th
simplified return METHOD_2 ( VAR_1 ) ; I miss
leave changes method ? method other changed methods
missing _CODE_ statement
_CODE_ IDEA tolds remove unnecessary boxing
_CODE_ style curly braces present opening brace line statement ( s ) line ( s ) closing brace line eclipse code style formatter
_CODE_ style
VAR_1 ( byte ) : thinking :
sketchy encompass ?
VAR_7 VAR_8 VAR_8 equal VAR_7
METHOD_2 return null add a null check
a bit shorter ; ) return STRING_2 equals ( VAR_3 ) remove profile param filter method ? ( _CODE_ ( STRING_3 ) )
duplicate private
method package protected allow jackson access
cases TYPE_1 - CH algos ? ( CH _CODE_ ? ) vehicle edge remove code #1835
I remove I additional constructor a meaningful addition user increase decrease precision ( other parsers )
return VAR_1 METHOD_2 ( VAR_2 ) ( other encoders )
necessary
moved new constructor
problem android compatibility [ TYPE_1 ] ( ) a java 8 class added API level 24 ( android 7 nougat )
I enable default need change tests
a test I remove ( VAR_3 > = Integer MAX_VALUE ) return Integer MAX_VALUE ; fine I fix refactoring
avoid creating function method call
wouldn t call ( METHOD_1 ( VAR_2 ) METHOD_2 ( VAR_2 VAR_3 ) ) ; case
early version gave a hint large graph longer necessary removed another issue ; )
nice hack : )
METHOD_1 instead ( ? )
boolean append necessary ? _CODE_ || VAR_3 ( ) > 0 more simple please check
( data = = null || ! ( data instanceof TYPE_2 ) ) { return false }
remove unnecessary final modifier local variables
remove unnecessary final modifier local variables modified classes
existing constructors : ( VAR_2 false ) ;
autowire _studygermplasmlistservice_ instead
soldevilla hibernate set id object transaction committed
s easiest initiate field I m s needed primitive false default
please add final
remove assignment local variable description
add final
boy scout cleanup : final TYPE_4 VAR_3 = new TYPE_4 ( METHOD_2 ( ) ) ; final TYPE_5 VAR_4 = new TYPE_6 ( METHOD_2 ( ) ) ; instead manual local creation service dependencies follow standard pattern _CODE_ TYPE_5 interface typed class member variables inject services spring auto wiring
_CODE_ VAR_6 ( ! ( STRING_1 equalsIgnoreCase ( i VAR_7 ) || STRING_2 equalsIgnoreCase ( i VAR_7 ) ) ) ;
super close throws exception VAR_4 closed
static valueOf methods
debug left -
curiosity / 10 ? yield control other a chance run 1 / 10th METHOD_1 time
VAR_4
Double ; - pick s harmelss ( some statements return break I ? )
shouldn t VAR_1 reference line changed key adding a potentially null key cache
need explicitly a TYPE_3 other : METHOD_11 ( VAR_1 ( ) - > assertTrue ( VAR_1 ( METHOD_8 ( STRING_2 ) ) ) ) ; tests shorter clearer
test server instances - memory datasets great speed places test server instances touch disk
written iterator VAR_1 ( ( ) - > { } ) ;
key constant
reasoning making a static method ? thread local semantically a static method
TYPE_2 VAR_2 = TYPE_3 METHOD_2 ( VAR_1 ( ) - > Assert assertTrue ( VAR_1 isEmpty ( ) ) ) ; a clearer
change potentially significant execution context change execution a new context derived current produced please L108 / L109
don t visit tokens _CODE_ I wouldn t stay consistent ( doesn t impact )
collide rules duplicate keys dictionary literals cases foo ( * * { a : 1 a : 1 } ) case consider replacing List < String > Set < String > return types helper methods collect keys
minor : I remove else returning body
minor nitpick I else needed return
nitpick : I simplify return VAR_2 ! = null && METHOD_3 ( )
I refactor code : javareturn VAR_2 equals ( TYPE_4 METHOD_4 ( VAR_5 TYPE_3 TYPE_5 VAR_6 TYPE_3 TYPE_5 VAR_7 ) )
need change
constants TYPE_2 METHOD_1 ( STRING_6 ) other types avoid reinstantiating times
I check VAR_5 instance TYPE_4
VAR_1 METHOD_2 ( ) needed
assigning field declaration
I drop ! VAR_1 && ! VAR_2 line
VAR_1 doesn t
good add a link language reference
I parenthesis VAR_7 necessary
inefficient a method access VAR_3 METHOD_4
instead equalsIgnoreCase
changing tree#is variadic ? ( TYPE_2 VAR_2 ) simplify call
I forgot remove
I change _CODE_ good usage linked list
F - strings ( a capital F )
linked list ? plain array list good
a bit convoluted imo : adding METHOD_2 VAR_2 list initialized empty remove Collections VAR_3 call
method static
I don t VAR_3 field declared TYPE_4 instead TYPE_2
s a small _CODE_ method static : )
I forgot remove line
factorize code a METHOD_4 method return null
I choose a loop implement a recursive call ( call stack grow big unecessarily call depending level nesting file ) I a loop more readable
unecessary parentheses
s need instantiate a new list a set interface
A set a good choice terms API : order guaranteed API user case AST order VAR_1 matters
forEach
7 lines duplicated 3 tests VAR_8 - squid factorize
code smells METHOD_1 _CODE_ static
ctx VAR_5 ( ctx VAR_4 ( ) STRING_1 )
return VAR_1 ! = null ? VAR_1 METHOD_5 ( ) : ;
java filter ( VAR_6 - > VAR_7 ( METHOD_4 ( VAR_6 ) ) ) forEach ( VAR_6 - > METHOD_5 ( VAR_6 VAR_8 ) ) ;
create a separate test method testing added syntax ? s more visible syntax new supported constructions
forget remove
imho module key parameter important unit tests WDYT dropping TYPE_3 ( squid module ) passing e g _CODE_ instead TYPE_3 VAR_4 ? p s TYPE_3 method
METHOD_1 ( ) 是否可以改成 static method
METHOD_1 ( ) 是否可以改成 static method
METHOD_1 ( ) 是否可以改成 static method
是否可直接 return VAR_3 toString
要改用 attach file dao _CODE_ 要拔掉
project
remove
I hate
_CODE_ ( _CODE_ )
remove VAR_8
need static
respect offset data length
array instead iterator
need synchronized
need casting a String
wrong METHOD_1 return uuid class return string version id
i uuid class instead children
VAR_1 ? more
another lesson learn need ask permission wait a review 😊
create a test dataset file edit existing
forget add ? super _CODE_ ( ) ;
i identifier type updatable
_CODE_ builder ( )
I missed beforesuggestionthis ( builder ( )
initialise getter dumb
a breaking change currently implemented works bot user credentials a bot user throws exception : org json _CODE_ : A TYPE_1 text { 1 [ character 2 line 1 ] org json _CODE_ _CODE_ ( _CODE_ java : 433 ) org json TYPE_1 < init > ( TYPE_1 java : 194 ) org json TYPE_1 < init > ( TYPE_1 java : 321 ) jenkins plugins slack workflow TYPE_2 < init > ( TYPE_2 java : 13 ) jenkins plugins slack workflow _CODE_ run ( _CODE_ java : 270 ) jenkins plugins slack workflow _CODE_ run ( _CODE_ java : 198 ) org jenkinsci plugins workflow steps _CODE_ call ( _CODE_ java : 47 ) hudson security ACL impersonate ( ACL java : 260 ) org jenkinsci plugins workflow steps _CODE_ run ( _CODE_ java : 44 ) java util concurrent _CODE_ call ( executors java : 511 ) java util concurrent _CODE_ run ( _CODE_ java : 266 ) java util concurrent _CODE_ _CODE_ ( _CODE_ java : 1149 ) java util concurrent _CODE_ run ( _CODE_ java : 624 ) java lang Thread run ( Thread java : 748 ) contents VAR_2 :
I don t change wanted 😉1 text returned bot users correctly null new test demonstrates2 case want doesn t work code invoked response emptymaybesuggestionif ( ! equals ( VAR_2 ) ) { / / _CODE_ respond
die folgenden methoden bitte im scope auf private stellen diese werden und sollen ja nur dieser test methode verwendet werden
ich weiss nicht ob ihr euch das später anschauen wolltet aber du kannst hier seit java8 auch lambdas verwenden siehe z B [ hier ] ( ) oder auch [ hier ] ( ) oder ähnliches im internet D h du kannst aus den zeilen 80 bis 87 ein lambda statt einer anonymen instanz ( objekt ) verwenden damit wird der code kompakter und lesbarer METHOD_2 ( VAR_1 - > { TYPE_3 VAR_2 = VAR_1 METHOD_4 ( 1 ) ; VAR_2 METHOD_5 ( STRING_1 STRING_2 ) ; return null ; } ) ( VAR_3 ) METHOD_6 ( METHOD_7 ( ) METHOD_7 ( ) ) ;
da keine exeption weiter nach aussen geworfen wird von METHOD_1 ( ) kannst du das throws Exception hier einsparen
auch dieser block kannst du als lambda ersetzen du kannst dir dazu auch mal das TYPE_1 interface anschauen und dieser stelle lambdas mit einem interface mit genau [ einer ] ( ) methode zu tun hat : )
hier ist die konstante statt dem argument verwendet worden und somit wird VAR_1 nicht gesetzt als ID der TYPE_1 hier einfach statt der VAR_3 VAR_1 verwenden
gerne auch diesen stellen welche sehr sprechend sind durch METHOD_6 ( ) einen statischen import verwenden dies macht den test lesbarer
auch solchen stellen ist die methode METHOD_4 ( ) sehr sprechen und ein statischer import würde die lesbarkeit erhöhen
wir sind auf java8 hat java8 isEmpty auf einem Optional
TYPE_2 METHOD_1 ( VAR_9 ) ;
warum erst aufsummieren ? man könnte doch direkt subtrahieren oder übersehe ich etwas
remove unneeded logging
suggestionpublic String [ ] METHOD_1 ( TYPE_1 uri ) throws TYPE_2 IllegalArgumentException {
duplicated remove
version explicit set body empty content - length null I d jclouds takes care setting content length payloads content case I more correct ( current implementation ) mark body empty content - length present
tests supposed parallel class ? I run _CODE_ METHOD_1 fails changes METHOD_3
remove public modifier
injected variables needed
caller resource management instead callee
consider propagating current exception
remove final add class fields
[ ] a static import other properties ( consider int other classes )
want immutable collections : javathis VAR_4 = VAR_4 = = null ? TYPE_1 ( ) : TYPE_1 METHOD_2 ( VAR_4 ) ;
wrong assertion ? : see_no_evil :
magical instead pass a flag _CODE_ controls call METHOD_1
I checked atmos azure _CODE_ AWS - S3 VAR_3 VAR_3 _CODE_ METHOD_1 consistency
call METHOD_1 ( container VAR_1 0 )
remove modifier constructor package private remove null check
private
constructor visible injector null check redundant ( injector checks nulls ) remove
override _CODE_ needed ? sleep unfortunate slows tests unnecessarily uncommon case eventual consistency
_CODE_ ( command ) instead METHOD_2 ( command )
change signature package private guice injector ( test classes ) instantiate class remove redundant null checks
I public package private
call _CODE_ ( group null ) _CODE_ function changed
I a distraction solve a tool error - prone divert wondering hmm a String ? instead focusing real code s a distraction I d note potential snafu : ( ps )
happy nice thanks I remove a follow - prefer
javareturn TYPE_2 METHOD_2 ( ) && TYPE_2 METHOD_2 ( state state ) ;
static import TYPE_4 VAR_8 follow style VAR_7
SGTM
[ minor ] create static helpers ? reduce private protected constructor static builderspublic static TYPE_4 _CODE_ ( TYPE_1 < TYPE_2 > node TYPE_1 < TYPE_3 > options ) { return new TYPE_4 ( node options ) ; } public static TYPE_4 _CODE_ ( TYPE_2 node TYPE_3 options ) { return _CODE_ ( atomics _CODE_ ( node ) atomics _CODE_ ( options ) ) ; / / return new TYPE_4 ( atomics _CODE_ ( node ) atomics _CODE_ ( options ) ) ; / / prefer }
please assertNotNull _CODE_ fix indents
log level I d warning hidden VAR_1 want _CODE_ INFO ? I d agree users want ( i e level > DEBUG ) s a _problem_ - wouldn t expect trigger alert based example ( i e level < WARN )
intended change functionality ? wouldn t default null s passed immediately NPE
[ minor ] formatting ? ( VAR_2 ! = null ) { options = options VAR_5 ( VAR_2 ) ; }
I m test I don t test sanity / composition toString else personal vote omit test previous test simply verify assertNotNull ( VAR_1 toString ( ) ) ; curious hear others
TYPE_1 equals ( String )
reason import change
returning immutable set VAR_1 a mutable some behavior ? I d remove line METHOD_3 VAR_1 set empty
A primitive int null remove check
remove null check primitives
( ! VAR_1 METHOD_2 ( ) isEmpty ( ) )
faster write throw new RuntimeException ( e ) ; : )
curious id +
[ minor ] _CODE_
METHOD_1 methods static ? protected overridden
call a helper method : javaprivate static void _CODE_ ( ) { ( System getProperty ( STRING_1 ) ( STRING_2 ) ) { throw new TYPE_1 ( STRING_3 ) ; } }
catch needed
NL - NH accurate amsterdam
places useif ( VAR_1 = = null ) { return null ; } return METHOD_1 ( VAR_1 ) ;
item getId ( ) _CODE_ ( METHOD_2 ( ) apply ( item ) ) ;
message [ ] ( ( boolean boolean java lang String ) )
combine return String valueOf ( METHOD_2 ( VAR_2 STRING_2 ) getId ( ) ) ; ? change place
move block
quick style question ( applies ) : feel making exceptional case ( VAR_1 = = null I m guessing ? ) bit handle clause e g ( VAR_1 = = null ) { return TYPE_4 ( ) ; / / handle special case } return METHOD_1 ( VAR_1 ) ;
VAR_4 null ( ! VAR_4 equals ( )
I m tending _CODE_ specific exceptions case instead reusing _CODE_ _CODE_ validations ? create a _CODE_
logger debug ( STRING_1 e getClass ( ) e ) ; print stacktrace handling exception _CODE_
tabs instead spaces
shouldn t started largest scope smallest
includes METHOD_4 ( ) view logging VAR_4 METHOD_6 ( )
leave METHOD_3 method checking behavior need repeat
throw exception key I guess change supports method return false key doesn t exist
assertThat ( VAR_4 empty ( ) )
assertThat ( result VAR_3 ( ) ( STRING_3 ) STRING_1 + user getName ( ) + STRING_2 ) assertThat inverted parameters another _CODE_ methods
I d write a simple test case ( ) sence startsWith
sadpanda :
_extract method_ avoid duplicated code METHOD_1 _CODE_ ( type = METHOD_2 ( type ) ) add 2 lines METHOD_3
I method called _CODE_ i ll create valued parameters _CODE_ sets TYPE_1 ( create weuse _CODE_ kind expensive ) a simple lazy strategy : javaif ( _CODE_ ! = null ) METHOD_2 ( VAR_1 ) ;
protected
change commit ( ) ;
change commit ( ) ;
s need check null locally pass null Utils method
field order statement order match constructor argument order
impossible prefer _CODE_ I leave - observable users
regular array bounds checking
line long please add { } wrapping
assert it’s empty ? split built factories test wrong
redundant ? s checked lines
+ static
need VAR_3 = VAR_3 VAR_6 ( )
lists addAll retain unmodifiable references
I delete ll happen s big a deal create a new instance
delete / catch assertThat don t add
remove private avoid need a synthetic accessor method generated
calling source ( ) throw need split lines variable initialization retrieving source–the block
removed
pattern ? weird create create
return
I hate ends docs
( VAR_1 hasNext ( ) ) symmetry other libraries
don t need format message object null
I don t reachable
@Override
NPE passes a list null ignore throw exception
pass VAR_3 size ( ) constructor
@Override line
@Override line
@Override line
@Override line
drop new String [ ]
I appreciate explicit - ness I d inlined method call want specific : _CODE_ ( false / * URL encode * / ) ;
drop line
replace VAR_2 VAR_3 isEmpty ( )
inline
method fail IOB_INSIDE_LABEL_PREFIX returning true METHOD_1 ( ) beginning entity problem IOB_INSIDE_LABEL_PREFIX = = VAR_3 = = I - method called IOB labels 100%
remove println please ; - )
linkin TYPE_3 a method called _CODE_ ( I m remember )
chain creates
VAR_1 parameter instead calling METHOD_3 ( ) method
call VAR_2 METHOD_2 ( VAR_1 update ) accomplish intended functionality especially don t want unregister event receiver s filtering events besides drone gps updates
reason size VAR_1 restricted 1 ? more results grab
skip check null VAR_2 null instanceof check fail
skip check null
check VAR_7 null
able call METHOD_3 ( null )
check VAR_1 null
s TYPE_2 args arguments added
don t need check validity position argument s based _CODE_ ( ) overrode
a bug activity call getString ( )
TYPE_4 enum event = = TYPE_4 VAR_2 instead equals ( ) method
done annotation specifies user collisions
- resources
VAR_6 ( ) call a synchronized block
= = 0 instead
happen throw IllegalArgumentException instead
I talked lazily
default true primitive remove statement
default false
null code 0 MAX
method { bracket line other methods other lines IDE - autoformatting checkstyle special I usages method class - private
s return a copy TYPE_1 instance class mutable
call other version METHOD_1 ( ) instead ? javapublic static byte [ ] METHOD_1 ( byte [ ] data ) throws TYPE_1 { return METHOD_1 ( data 0 data length ) ; }
written a previous PR : I expect VAR_6 moved TYPE_1
package private ? suggestionint METHOD_1 ( ) {
remove static variable instead
suggestionlog error ( asynchronous execution EDT interrupted - + VAR_1 e ) ;
NPE
private _CODE_ code inspection
private _CODE_ code inspection
nullcheck missing
return status = = Type VAR_1 || status = = Type VAR_2
job a METHOD_1 method free unmanaged resources / memory deregister stuff properly object garbage collected set references null / clear datastructures garbage collector boiler plate code benefits
behavior ? more specific need a charset ? producing a string
isn t coding convention : omit needed
METHOD_1 ( ( ) - > { VAR_1 run ( ) ; return null ; } ) ;
returned _CODE_ VAR_2 METHOD_2 ( String format ( STRING_1 VAR_1 METHOD_3 ( ) ) ) null ? case need a nullcheck returning implicit unboxing needed convert returned Boolean a boolean ( actual return type method ) throw a NPE null
simplify - else block _CODE_ ( path = = null ) { return VAR_1 path = = null ; } else { return path equals ( VAR_1 path ) ; }
minor - unnecessary type declarations initialization a lot class I m address individually
loop replaced passing collection CTOR : _CODE_ < String > VAR_1 = new ArrayList < > ( VAR_3 keySet ( ) ) ;
else branch needed
need synchronized stop method
remain remove toString method
a reason check selected user a saros server ( line 445 _CODE_ ) ? I misunderstanding checks ? check missing null - check result _CODE_ METHOD_3 ( )
suggestionif ( session VAR_1 ( ) && session VAR_2 ( ) isEmpty ( ) ) check host client disconnects a canceled outgoing negotiation
needed
check needed HashMap ( ) returns null mapping key present
ArrayList sufficient applies appearances patch set
called METHOD_1 transfer ( ) method ? basically order ( _CODE_ ( ) called instead ) big difference current implementation _CODE_ ( ) call located finally block meaning executed incoming project negotiation fails wrong behavior sense add shared resources session negotiation / resource sharing failed
a formatter ? I haven style eclipse formatter
keyword unnecessary
check actions needed ? execute content VAR_2 ( ) VAR_1 METHOD_3 ( ) length ( ) > 0 content VAR_3 ( )
attach class I highly suggest implement startable move handler application scope
change METHOD_4 ( System VAR_1 ( ) properties ) ; METHOD_4 ( properties ) ; _CODE_ a reference env
please rewrite continue harder track code
statement ? prevents VAR_1 element set false
throws
locking creating factory necessary ? iterator iterates backing _CODE_ ( a clone )
throws
throws consistency clarity
i guess close cleanup ( ) ? dunno preferable
close METHOD_5 - - resources
check previous line unnecessary
switch import org junit Assert METHOD_2 remove messages ? fails reason clear I don t forced provide a redundant message
braces body
protected fault API constructors private I fixed master branch API constructors protected extend API code want couldn t instantiate forcing singleton
static invoke _CODE_ METHOD_1 ( ) instead ( ( _CODE_ ) _CODE_ ( ) ) METHOD_1 ( )
I change order : need call VAR_3 VAR_4 : return VAR_1 = = null ? Collections VAR_4 ( ) : Collections VAR_3 ( VAR_1 ) ;
suppose sense convert case comparing
I suggest remove field need limit lifetime TYPE_3 work long takes
moved TYPE_2 METHOD_2 ( )
doesn t logger VAR_6 ( true ) set override
duplicate existing check
majority changes simply passing VAR_1 codebase
please braces
shouldn t allow empty VAR_1 distinct null I guess null means table fields empty VAR_1 columns selected query SELECT current_date ( ) FORM map
please constructor package - private tests need expose publicly
VAR_1 null
assertEquals ( TYPE_2 ( STRING_1 STRING_2 STRING_3 STRING_4 ) map ) ; check remove assertNotNull ( map ) ; METHOD_3 ( map ( STRING_6 ) ) ; assertions unnecessary assertEquals ( ) call covers conditions
Arrays asList ( ) accepts variable - length argument list write List < TYPE_2 > VAR_3 = Arrays asList ( new TYPE_3 ( ) new TYPE_4 ( ) ) ; drop VAR_2 variable please s a field instead a local variable
convert a ternary operator ? _CODE_ = _CODE_ ? new TYPE_2 ( ) : new TYPE_3 ( ) ; code verbose
check necessary covered VAR_1 METHOD_2 logic
I m please pull PR isn t related timing lets run some ad hoc examples don t run some nasty overflow / sign related problems
index < VAR_1 size ( )
private constructor
lines dangerous mutate object set earlier consider code : TYPE_1 config = new TYPE_1 ( ) ; TYPE_2 options = config1 _CODE_ ( ) ; / / config METHOD_1 ( < new options > ) ; / / options object changed _CODE_ overwrite object setter perform a lazy initialization getter other config classes ( e g TYPE_1 _CODE_ ( ) copies approach )
minor : symmetry _CODE_ : ( VAR_3 ! = TYPE_2 VAR_7 )
line unnecessary
write options unconditionally validate server - side consider a user submits _CODE_ { type = HASH _CODE_ = < null object > } invalid config real intention - create a hash index a bitmap index ? I read / write object throw exception invalid config ignoring invalid state silently
minor : assertThat ( VAR_1 ( empty ( ) ) )
leftover
case remapping raw attribute values long keys VAR_2 VAR_4 null don t reset VAR_3 0
IllegalArgumentException more
checks similar previous method avoid code duplication
TYPE_6 remove _CODE_ ? I assume removed client protocol changes care serialization permissions
single quotation marks needed line 145 escape class names strings problem appears other classes
catch log exceptions METHOD_2 method _CODE_ ? reasonings : 1 centralize place map operations some other map operations issue 2 catch exceptions listener basis minimize blast failure instance attached 100 listener map throwing exceptions failure shouldn t block event flow other listener
( ! METHOD_2 )
simplified return ( o instanceof TYPE_1 ) ;
read && instead ||
line removed don t want groups enabled
need _CODE_ response data
change meaning VAR_3 METHOD_6 accepts a backup parameter _CODE_ internally original meaning _CODE_ _CODE_ false other reasons passing a _CODE_ parameter object carrying index backup info ( need others ) more flexible extensible
record null explicitly check null adding _CODE_ _CODE_
return
expected create VAR_3 time ? cache
TYPE_3 internal class visible public API TYPE_1 part stay Set
caller invalidations returning a null result server hides actual issue ( unexpected serialization costs ) mind investigate _CODE_ apply logic _CODE_
repeated logic message tasks & member - side map proxy hidden TYPE_2 : TYPE_3 METHOD_3 ( String data _CODE_ data long VAR_3 long _CODE_ ) { ( VAR_3 = = VAR_4 ) { return new _CODE_ ( ) ; } else { return new _CODE_ ( ) ; } }
keystore types don t require a VAR_1 another channel ( e g WINDOWS - type )
minor : VAR_3 METHOD_1 ( VAR_1 )
minor : reason METHOD_3 int comparison ( )
object id = = null ? equal
close method created ? avoid problems adding new methods I some code paths close e g _CODE_ _CODE_ _CODE_
leftover debug statement ( test failures & large PR builder time )
debug leftover
minor : converted tonew Thread ( ( ) - > { METHOD_3 ( 5 ) ; METHOD_4 ( ) METHOD_5 ( response ) ; } ) start ( ) ;
require JDK8 remain JDK6 compatible types
remove diamond operator
missing types
need adapt behaviour _CODE_ ? another words happen _CODE_ returns 0 equals returns false
minor : access package - private ( support method s internal suffix : - ) ) _CODE_
isn t VAR_3 ! = null enough
TODO
I check - based type operation quorum - quorum needed current implementations free future implementations METHOD_2 ( ) methods logic waste some cycles unnecessarily operation quorum type e g _CODE_ VAR_3 quorum
! VAR_3 METHOD_2 ( ) &&
move picking eviction policy logic [ _CODE_ ] ( ) plain getter / setters ? : public _CODE_ _CODE_ ( ) { return VAR_2 ; } public _CODE_ _CODE_ ( _CODE_ VAR_2 ) { VAR_2 = _CODE_ ( VAR_2 VAR_2 null ) ; return ; } public TYPE_1 METHOD_1 ( ) { return VAR_1 ; } public _CODE_ _CODE_ ( TYPE_1 VAR_1 ) { VAR_1 = _CODE_ ( VAR_1 VAR_1 null ) ; return ; }
changing return types 3 x [ discussion ] ( )
left debugging
info instead METHOD_1
return _CODE_ DEFAULT_TTL ( - 1 - - > _CODE_ s default ) instead 0 ( - - > infinite max idle )
I declare local variable method more complex needs
nitpicking personal taste I find difficult follow boolean changes code more error prone removing multiple method - exit points ( return ) return VAR_2 METHOD_3 ( false ) add ( ) ;
redundant else blocks
redundant else block
_CODE_
ArrayList constructor called _CODE_
entry infinite ttl
check load factor smaller 1
VAR_2 clear ( ) missing loop
minor : collapse blocks _CODE_
private static
return empty array instance
return empty array instance
correct assume state graph VAR_2 change time ? capturing state VAR_2 point construction produce a misleading result calling toString ( ) future opposed moving line : 37 body toString ( ) method
a good idea add a generic exception limited throwing exceptions occur method consider handled method changing signature
package - private i e access modifier
Exception thrown throws removed
left drawer closer a null check VAR_1 need
shouldn t need METHOD_1 _CODE_ ? _CODE_ METHOD_1
I compilation problem _CODE_ question - safer wrap / catch block undeploy case test failure ( deployment pass ) remove
I assertEquals comparing Class VAR_1
I merge lines : VAR_2 set ( VAR_1 METHOD_2 ( TYPE_2 class ) METHOD_3 ( ) ) ; other interceptor ( _CODE_ ) preference I guess : )
a factory creates TYPE_4 objects ? needs passed factory factory
needs VAR_2 a message throw new TYPE_3 ( VAR_2 VAR_1 getId ( ) ) ;
isn t return null wrap METHOD_2
isn t return null wrap METHOD_2
isn t return null wrap METHOD_2
isEmpty ( ) instead empty string comparison
isEmpty ( ) instead empty string comparison
spacing
don t need METHOD_2 ( )
obvious thx
ой А нельзя метод public сделать
должен быть public
Arrays VAR_2 допускает null в качестве компаратора
наличие поля _CODE_ делает его не thread safe
закрывать System - плохо
объясни - таки зачем нужен synchronized здесь
должны поддерживаться все форматы для целых чисел например o 10x
всегда надо иметь возможность закрывать ресурс снаружи см интерфейс closeable
изменять данные некорректно надо использовать String CASE_INSENSITIVE_ORDER
метод можно сократить до return s length ( ) > 0 && TYPE_1 METHOD_2 ( s VAR_1 ( 0 ) ) ;
почему не boolean
можно упростить : return VAR_2 - VAR_3 = = 1
shell / bash работают не так они пишут сообщение об ошибке и можно продолжить работу мало ли - пользователь ошибся
dead code
catch Exception instead
_CODE_ METHOD_1 method
VAR_2 instead STRING_1
VAR_2 instead DEFAULT
need channel contract guarantees single subscription
discussion mark servers VAR_6 _CODE_ redirect traffic a ( possibly ) smaller set VAR_5 servers
I instead paranoid people METHOD_1 ( ) add checks _CODE_ ( ) I required
VAR_1 upper case invariant violated issue VAR_1 volatile hinting accessed multiple threads A safer implement function ( VAR_1 = = null ) result VAR_1 = null ; elseresult VAR_1 = VAR_1 METHOD_2 ( ) ; appears existing methods corrected
I don t a VAR_1 mandatory list packages command line
A defensive copy needed
> throw TYPE_3 METHOD_3 ( e ) ; remove throw statement
asta cred ca trebuie sa fie WARN
RuntimeException sufficient
I m wondering test wouldn t easier simply a single servlet test TYPE_3 output EXECUTED attribute a single servlet servlet output : query : number = _CODE_ : _CODE_ need adjust asserts check query : number = 42 instead number = 42
a ; missing
nice catch kamil btw couldn t done easier code ? ( TYPE_1 f : VAR_2 ) { ( f ( ) equals ( VAR_3 ( ) ) ) { return true ; } } return false ;
VAR_3 checks checks present call site TYPE_1 kinda breaks responsibility pattern
I needs tidying entry redundant VAR_1 renamed entry
I reformulated more efficient i e : javaif ( ! VAR_1 ) { VAR_2 forEach ( call - > call VAR_3 ( ) METHOD_2 ( null ) ) ; }
catch statement isn t needed
changing trie _CODE_ introduces entrySet eliminate lookup a loop javaprivate final _CODE_ < TYPE_1 > VAR_1 ; VAR_1 entrySet ( ) stream ( ) map ( Map Entry : : getValue ) METHOD_2 ( TYPE_1 [ ] : : new )
VAR_5 a boolean primitive avoid a condition block
I guess omit parentheses VAR_1 isPresent
declare VAR_3 Optional initialize - liner : _CODE_ VAR_2 ( options ( STRING_2 ) ) map ( File : : new )
I reduce constructor a call another constructor : javathis ( configuration null ) ;
reducing size method ternary operator returns ? : javaif ( configuration VAR_2 ( ) ) { return VAR_3 ! = null ? VAR_3 : TYPE_2 METHOD_2 ( ) ; } else { return new TYPE_3 ( ) ; }
surrounding statement - catch doesn t gain test METHOD_2 uncaught exception occurs
surrounding statement - catch doesn t gain test METHOD_5 uncaught exception occurs
change required default method interface
I avoid reference fields unit test conflicts
public
I m a false positive methods invoked class guaranteed _CODE_ I moved variable assignments method declaration
ditto super ( )
ditto super ( )
I don t printing VAR_5 VAR_4 useful
package private
I remove catch block exception propagate ( method declares throw Exception ) put VAR_2 METHOD_1 ( ) call finally block - finally statement
I symmetric implementation size short circuits necessary ? long#compare ( ) thing™
final
please move METHOD_3 set credentials provider VAR_5 null ? currently default behaviour apache TYPE_1 change future don t want _CODE_ a sudden : wink :
I more sense create immutable copy iterable TYPE_3 ( iterable < TYPE_2 > ) constructor instead
a small note : add ( ) method Set < T > returns false element exists set check superfluous code changed : ( ! VAR_1 add ( ) ) { LOGGER warn ( STRING_1 type ) ; }
ensure stream closed
METHOD_3 invoked METHOD_1
issue double delete user
action deserializer achieve : + 1 : nice approach models consistent
simplier : showing empty array null a big deal imo toString logger
reason public private ( package - private case )
please expand situation VAR_2 null point res ? VAR_2 null return TYPE_1 VAR_5 res I calls METHOD_1 ( int ) - including call pass VAR_4 cases VAR_2 null ? a _CODE_ _CODE_
nested METHOD_1 invocation unnecessary I missing
spec : JAX - RS 2 0 method deprecated returned method a JAX - RS runtime _CODE_ implementations advised return - 1 method
participant isn t registry throw a null pointer caught reported HTTP 404 status code
package private
list removed completely
I don t needed protected
remove package
VAR_3 unused variable ( remove )
changing a public interface deprecation rules apply
changing a public interface deprecation rules apply
a new line return
a String final String id = TYPE_1 ( VAR_1 ) ; don t need cast line
I don t another lock put conditional stat increment _CODE_ : : METHOD_6 synchronized
RMERR good - check spec
RMERR great - bad commit compatible
RMFAIL
RMFAIL
listeners : ) ( split a separate commit absolutely )
need scheduler address ? hadoop configuration
[ minor ] write asif ( id = = null ) { throw new TYPE_2 ( STRING_1 ) ; } ? thanks
package - access instead public - access ? callers _CODE_ builder correct
consider METHOD_3 ( INT_1 ) _CODE_ ( VAR_1 ) read ( ) instead
personally I prefer separate modules module work parser I d prefer remove line add TYPE_1 list default modules _CODE_
reuse result _CODE_ append instead buffer local variable
method static
private
useless string builder default constructor
( VAR_3 > VAR_2 && VAR_3 - VAR_2 > VAR_1 ) current check expires VAR_2 currentTimeMillis ( ) iterator assuming times synced perfectly server wrote a mutation iterator running scan / compaction
update profile timestamp ? isn t required fields ? redundant recalculated set syspurpose attributes change
creating a TYPE_2 object calling METHOD_2 needed 3 lines code condensed : VAR_1 add ( new TYPE_1 ( VAR_3 ) ) ;
doesn t work cases processing stream occurs connection backing CPQ close ll trigger exception instead returning result return TYPE_3 object normal set container type iterable yaml
function static
_CODE_ legacy code loooong s avoid carrying updated model
s intent ? generally want allow changed point requires update
lots other methods class synchronized method need
skip declaration query locked flag a simple boolean returned TYPE_1 object call optimized basically needing write cases ll want explicitly cache stuff locally dealing unboxing s a simple accessor more a data store a case
a local variable shares a a class instance variable explicit referencing VAR_2 ( similar ) instance variable set check succeed
good serves purpose input stream fetched VAR_3
change flip flag _CODE_ true VAR_1 line 59 : session = _CODE_ _CODE_ ( true ) ; s a reason I m need control I d interface wrapping change flags set independently
complexity constructing a constraint object good utilize _CODE_ class a similar _CODE_ class constructed a user constraints API I shouldn t worry implementation details TYPE_4 TYPE_5 TYPE_5 simply able METHOD_3 ( _CODE_ _CODE_ ( conf getInt ( _CODE_ ENTITLER_JOB_THROTTLE ) VAR_5 ) ) ;
original job extend _CODE_ implement _CODE_ / _CODE_ methods need constraints job
decouple inbound collection A simple VAR_1 = VAR_1 ! = null ? new HashSet < > ( VAR_1 ) : null ; work
VAR_3 unused ? isn t iteration
initialized line 97
put close ( ) a finally block attempt close session commit failure closing session fails s - - log move
put close ( ) a finally block attempt close session VAR_1 fails closing session fails s - - log move
isn t left accident change message a more informative
leftovers _CODE_ return input ; enough DTO primitives
else I missed I s important don t set type creating new objects more diamond operator new HashSet < >
line unnecessary - - resources syntax
s driving change increase visibility ? intended subclasses
METHOD_1 method new date
A bit more _CODE_ code s left a proper import fully qualify fly
work ? I don t a specific METHOD_3 ( ) method _CODE_ I m supposing METHOD_3 ( E entities ) superclass passing entities a - op
unnecessary encapsulation issue resolved
a map strings TYPE_2 calling equals replaced code gaining change
methods pull other bits data making extensible methods instead : return getId ( ) ! = null ? String format ( ) : null ; subclasses need override methods source ID change
checkstyle failure : need a space VAR_3 colon pull method declaration line
nice unnecessary - - TYPE_1 case original code replaced ( especially builder a prime ) leave -
minor mind switching tothis VAR_3 METHOD_4 ( Collections VAR_5 ( VAR_2 ) ) don t superfluous null hanging I functionality parameter method delegates parameter method provides null parameter
method protected ( private isolated tests )
method protected ( private isolated tests )
method protected ( private isolated tests )
don t need pass VAR_2 s false point
return query VAR_4 ( ) > 0
s VAR_1 null
private plans class
private plans class
unused collection VAR_6
shouldn t perform null check call clear ( )
needed compute VAR_1 compliance more ? a valid reason kick asynchronous VAR_1 compliance job #1073 ? _CODE_ remove entitlements a VAR_1 compliance check other explicit decision some point question
logback don t need types guards javalog debug ( queing event : { } event ) trick penalty performance
consolidate catch clauses ? TYPE_3 a RuntimeException
block required
a bit hairy deconstructing reconstructing a hashmap
reason return type Collection < TYPE_1 > return VAR_1 values ( )
I VAR_1 a solid toString more useful more : javareturn STRING_1 + getId ( ) + STRING_2 + VAR_1 + need VAR_1 : VAR_1 toString returnsjavareturn owner [ id : + getId ( ) + key : + getKey ( ) + STRING_7 ; null ( shouldn t happen else wrong safe allowing )
I wouldn t change line initializing empty string don t worry ve created a TYPE_5 VAR_9 java ( null string ) loaded VAR_9 database ( empty string ) logically shouldn t a difference scary
intended master temporary code
putting condition 3rd param avoid duplication
_CODE_ = METHOD_1 ( ) ;
need VAR_1
METHOD_3 shouldn t return null based python SDK functions return a VAR_2 object time case fact empty ( { factors : [ ] minimum_requirements : [ ] } ) return a VAR_2 minimum_factors set false 0
VAR_3 shouldn t return null based python SDK functions return a VAR_2 object time case fact empty ( { factors : [ ] minimum_requirements : [ ] } ) return a VAR_2 minimum_factors set false 0
a fan shorthand letter variable names prefer a descriptive var instead a single character
sake consistency ( OCD ) < code > VAR_3 = VAR_3 < / code > setter
sake consistency ( OCD ) < code > VAR_3 = VAR_3 < / code > setter
line needs a colon case VAR_6 : I note smooth brick check
change produce a compiler error - [ travis ] ( ) work : public void METHOD_1 ( final File VAR_1 ) { TYPE_1 input = null ; TYPE_2 output = null ; { input = METHOD_2 ( ) METHOD_3 ( ) ; output = new TYPE_3 ( VAR_1 ) ; TYPE_4 METHOD_4 ( input output ) ; } catch ( final IOException VAR_2 ) { throw new TYPE_5 ( VAR_2 ) ; } finally { TYPE_4 close ( input ) ; TYPE_4 close ( output ) ; } }
kill offset pass 0
return new StringBuilder ( ) append ( ) toString ( ) ;
useless toString ( ) s StringBuilder append ( Object ) ( i s protected NPE print null )
VAR_1 null needs a check
printing stdout
format assertions Assert _CODE_ ( EXPECTED ACTUAL ) change order
don t need exception thrown test automatically fail want test calling a method throw exception annotate method : ( expected = TYPE_2 class )
change needed
s a difference primitive type boolean class Boolean a primitive rest code boolean return type
a mock patient return null
read
I prefer assume fix necessary VAR_3 null ( empty ) code easier : final List < String > TYPE_1 = new TYPE_2 < > ( ) ; TYPE_1 add ( VAR_1 ) ; TYPE_1 addAll ( Arrays asList ( VAR_3 ) ) ; return Collections VAR_4 ( TYPE_1 ) ; IMO Optional VAR_2 null - checking instance unnecessary produce a bit overhead I prefer a conditional sentence instead ( null ! = ) { }
breaks _CODE_ theory _CODE_ line 224
VAR_1 METHOD_2 ( ) ; - -
= = method usage clear
matter = = equals
TYPE_2 enum = =
return VAR_2 = = 0 ? : METHOD_1 ( VAR_3 METHOD_2 ( x y VAR_1 VAR_2 ) ) ;
I m big fan [ yoda conditions ] ( ) I reduces readability significantly don t else code base I suggest condition reversed : ( authservice = = null ) { Optional store authservice access a property : private final Optional < authservice > authservice ; [ ] public authservice authservice ( ) { authservice isPresent ( ) ? return authservice ( ) : throw new IllegalStateException ( message ) ; }
public sake a test please revert change fix test
errors logged console / error view cleared feature I tested override _CODE_ leaves feature untouched case TYPE_1 change / catch block METHOD_1 isn t required anymore boolean _CODE_ ( ) { { number number = METHOD_2 ( ) ; return ( number ! = null ) ; } catch ( TYPE_1 e ) { return false ; } }
global definition defaults
I return TYPE_1 parse ( VAR_1 ) METHOD_2 ( ) ; enough
brackets needed
want _CODE_ rule reset sys props initial state test similarly logger easier ( ? ? ) _CODE_
I static helper methods static please
shouldn t method private
a condition determines a ( action - : method ) i ternary : int buffer = VAR_1 ? TYPE_1 VAR_5 : TYPE_1 VAR_6 ; VAR_3 METHOD_2 ( buffer ) ;
suggestion } catch ( TYPE_3 | TYPE_4 | TYPE_5 e ) { return ; }
I start - btw started _CODE_ ; - )
package - private
I copy current _CODE_ impl : return VAR_2 isEmpty ( ) ? VAR_1 : TYPE_1 ( ) ;
debugging ? remove
change package - private access
change package - private access
DEBUG a bit a weak signal don t fail
toString ( ) unnecessary
add getId ( ) mark id ( ) deprecated
needs a test obj instanceof TYPE_1 isnt return false
I m method refactor spell external correctly
private
variable real reason return a new TYPE_1 bottom return
call METHOD_1 method takes a string pass context getString ( VAR_1 ) string _CODE_
large libraries sorting call METHOD_1 introduce a lot latency a minimum I want move VAR_4 synchronized block short long term VAR_4 _CODE_ a infrequent action
METHOD_3 broadcast action receive lines broadcast a action collapse process broadcast action
hardcoded toast text : baby :
put brackets { }
instanceof needed
I understand correctly VAR_2 null test empty string instead
check needed throw IllegalArgumentException ( )
removed
realizing : a Set don t need check contained
VAR_1 METHOD_2 ( ) extracted local variable 3 times
I remember METHOD_2 doesn t useful removed pollute code please confirm refactor needed
property form ? line required
trocar VAR_2 para VAR_1 verificar a necessidade
verificar se é necessário usar o METHOD_2 ( todos ) momento
verificar essa troca de tipos será irá quebrar alguém
seria bom reutilizar o método paginate _CODE_
= = tests reference equality error - prone - - d equals ( ) method
fine equivalent METHOD_3 - _CODE_ s needed ( original code usual hacks work matrix - project )
check equality based toString
generate parsers kast needed including builtins
creating new contexts
I suggest instead a List < ? extends Map < ? extends _CODE_ ? extends TYPE_2 > > technically a safe cast
I checked JLS I wrong read m = VAR_1 null happen line written return VAR_1 I don t s a good idea assume guice absolutely thread - safe a simpler equally efficient solution
constructor ( )
( VAR_2 = = null ) {
necessary I
METHOD_4 method s signature _CODE_ longer a method needs exist
constructor feels wrong I a TYPE_1 a definition constructor calls _CODE_
code needs factored support fact eventually need compute grammar objects kompile serialize
true
extra parentheses
I s part diff isn t function static
please constructor inheritance
a big deal I final
final
final
final
I don t TYPE_1 TYPE_2 TYPE_1 constants
usejavaassert ( VAR_2 VAR_1 = = null ) : STRING_1 ; instead
calling constructor a couple places necessary construct more TYPE_4 object VAR_2
entires METHOD_1 ( map )
I a suggestion : METHOD_2 ( ) returns 0 set VAR_1 1
don t forget
Integer toString
METHOD_4
s a bug VAR_6 returned function zero I suspect fix bug ( line 160 ! operator ) find code longer works technically s safe currently hashing bucket
I don t TYPE_1 a _CODE_ field a Map < _CODE_ TYPE_1 > stops Map connecting _CODE_ a TYPE_1 a _CODE_ ? want maintain a bijection _CODE_ ids maintain bijection place a _CODE_ authoritative source ID information class implement _CODE_
weird a transformation a TYPE_4 return a TYPE_4 return element turned a TYPE_4 caller
anymore reverted change 1 comma
question a Exception class
question
I thinksyntax : : = $h besyntax : : = token { $h } a check compile
I meant VAR_2 METHOD_3 ( ) VAR_4 ( Optional VAR_3 ) length > 0 evaluated beginning method : ( VAR_2 METHOD_3 ( ) VAR_4 ( Optional VAR_3 ) length > 0 ) return true ; TYPE_2 field = METHOD_2 ( ) ; return field ! = null &&
s easier read reverse / else avoid
else I
exception ? VAR_2 s field
final I guess
StringBuilder more natural ? passing iterable iterator avoid some bugs ( iterator mutable caller forget a copy )
_CODE_ ( ) virtual instead final don t need precompute a field s completely derivable other fields
super ( String String TYPE_1 _CODE_ < Integer > ) super ( String String TYPE_1 int )
a logic error empty itemstack shadow inventory override existing shadowed
* CME ? * isn t remove ( ) ? removing equals ( )
fallthrough VAR_4 line 47 intended
VAR_3 = = null ? means called world object null I guess want _CODE_
duplicated code extract a private helper method called multiple places
matters shouldn t VAR_3 stopped ( doesn t move entries queue stopped ) ? shouldn t VAR_4 METHOD_3
hesitation copy don t a deep copy header extensions ( add references ) don t s a big deal i m fine _CODE_
please move braces new lines ( identation wrong )
source code duplication ! I move expected values a helper class a super class ( choice )
method previous line
check constructor instead ( a static factory method ) ll want careful calculate VAR_1 ll want throw t find a VAR_1 elements _CODE_ basically want find common base TYPE_1 loop _CODE_ : private static List < TYPE_2 > _CODE_ ( List < TYPE_2 > VAR_3 ) throws _CODE_ {
strictly necessary I read return index = = 0 other parameters null
remove change please necessary
s move METHOD_2 check TYPE_6 create ( ) visit method _CODE_ _CODE_ cases ll able coerce s allowed
basically a load a String CSV format a _CODE_ au bytecode opencsv _CODE_ ( open source CSV reader ) isn t crucial TODO
I logic super class b / c ll apply _CODE_
don t need - VAR_2 set other constructor set _CODE_ method
message - remove
replaced code :
need define else explicitly
VAR_3 = = 0
evaluate incorrectly
switch reduced : javacase 0 : case 1 : return TYPE_1 ; case 2 : case 3 : return TYPE_1 VAR_2 ; / /
issue
private
reduces ( VAR_6 ! = TYPE_4 VAR_7 ) return ;
throws required
don t braces case statements please don t break / return needed
call other constructor
missing case x3 labels cases
unknown type air
doesn t fit style guidelines parenthesis need removed
false
i body match expected content
assumes entry
StringBuilder cleaner more readable allows easier expansion editing
I ( METHOD_8 ) needs a synch _CODE_ updated
weird newline
{ } statements single - line
VAR_1 block
[ dependency inversion ] ( ) preferred approach want return Set Set lhs assignment
part 4 : usage avoided ( part 5 )
( glowing methods ) added day 1 1 9 builds check required
need STRING_1
mentioned docs need check grounded ? I revert gliding immediately
case combine 3 lines return new TYPE_10 ( VAR_4 METHOD_6 ( ) METHOD_7 ( ) target ) ;
NEED async
sense ? s a neat trick turn insufficient arguments a compiler error implement _CODE_ throw a _CODE_ children size ( ) < _CODE_ return null
private package protected
I m ways moment shouldn t code code worse achieve
need create a new everytime
shouldn t return anymore
check VAR_1
need else return previous
need check
I asked I forgot explanation METHOD_3 VAR_7 actions ( publish )
tracking event user taps button VAR_1 valid shouldn t call VAR_1 filled misinterpreted user filling VAR_1 input sense ? honest I m need event 🤔 s idea
METHOD_3 custom click action I don t love modifying element passing feels cleaner update METHOD_3 method handle scenarios
want consider calling new method don t duplicate _CODE_ ( VAR_1 new Date ( ) ) wdyt
a copy / paste typo
override s generally separate lines ( I don t styles set correctly check rest file )
I white line removed
METHOD_1 called _CODE_ when1 ) media exists remote selected2 ) a media doesn t exist remote _CODE_ 1 fine I m wondering case 2 want track want track actual click / selection media - matter upload ? wdyt
I shouldn t check preference show interstitial I t case shouldn t nudge new users create a new site
I annotation aztec method kotlin allow java side call method new extra parameter ) check [ answer ] ( )
shouldn t line else clause ? wdyt
move separate lines
I annotations separate lines
return true point return false method
s line List < String > VAR_3 = new ArrayList < String > ( METHOD_3 ( ) ) ; METHOD_3 ( ) returns Arrays asList ( ) a fixed - size list [ docs ] ( ( T ) ) line _CODE_ add ( key ) ; crash
I guessing work case necessary cleanup ( I missing review )
move other cases : java / / other cases ll upload post changing statuscase VAR_3 : case VAR_4 : case VAR_5 : METHOD_5 ( false ) ; break ;
I m wondering return true wdyt
I need a full package path import top file
hmm need compute VAR_3 METHOD_1 ( ) call s
shouldn t _CODE_ java API _CODE_ JSON files
need replace equivalent JSON mock
I setting cancelable false result infinite dialog _CODE_ event lost a configuration change I isn t handled places app I wanted mention want consider allowing user cancel dialog setting ( sticky = true ) handle appropriately wdyt
I remove VAR_3 hiding a good opportunity clean fragment a bit I ended making a bunch changes I I thought commit share some proposed changes : don t changes s totally feel free cherry - pick commit - commit branch
exiting early flatten multiple nested statements simplify a complex conditional statement case aren t nested statements early exit slightly more complicated ? _CODE_ void METHOD_1 ( boolean VAR_1 ) { ( VAR_2 METHOD_2 ( TYPE_1 METHOD_3 ( ) VAR_3 ) isEmpty ( ) ) { METHOD_4 ( ! VAR_1 ) ; } }
mmm needed I done TYPE_3
build failed : need throw IOException catch itpublic void close ( ) { { ( input ! = null ) input close ( ) } catch ( IOException e ) { / / } }
I tend leave static class definition read TYPE_1 VAR_1 = METHOD_2 ( ) ; thoughts
finals TYPE_1 TYPE_3
final
I simpler final else clause initialize null
consider approach : write a utility method wrap s instance TYPE_1 avoid allocation a new object s VAR_2
call VAR_4 ( ) : _CODE_ VAR_4 = VAR_4 ( ) ; int VAR_2 ; { VAR_2 = ( Integer ) TYPE_2 METHOD_2 ( VAR_3 VAR_4 TYPE_6 VAR_6 ) ; } ( VAR_2 > 0 ) ;
methods package - private class package - private ensures expose mistake some point
closing index based loop eliminate GC pressure
normal string concats
consider replacing a switch statement
explicit ? dont other handlers
Optional idea : a user adds a wildcard domain * netty io normalized netty io stored map cheaper line check s present string concatenation needed check substring I fast want
merge else else
IMHO don t need throw IllegalArgumentException TYPE_1 catch return null
possibility VAR_1 null write equals ( VAR_1 )
IllegalStateException
needed unit tests please private
null remove check
I pack entire branch a differet method
VAR_5 TYPE_2 a superclass
merge lines METHOD_1 return argument
merge lines METHOD_1 return argument
merge lines METHOD_1 return argument
merge lines METHOD_2 return argument
merge lines METHOD_1 return argument
merge lines METHOD_1 return argument
merge lines METHOD_2 return argument
merge lines METHOD_2 return argument
consider merging lines
lets move check ( assignment ) VAR_4 check ( )
move mull check null check VAR_1 ensure change behaviour
move null check action method change behaviour
move check method change behaviour null passed VAR_2 _CODE_ thread
move assignment check method change behaviour
merge lines formatting a bit strange
move assignment check method change behaviour
throw IllegalStateException wrap original Exception
remove check constructor fail fast
merge line METHOD_1 ( ) returns VAR_2
merge line METHOD_1 ( ) returns VAR_2
private
I don t check intentional ? VAR_1 = VAR_1 ; moved block
mastrangelo work
final
merge lines
merge lines
lines merged
static
resetting needed s set
please assert return
need VAR_1 METHOD_1
please more readable compact hard read
replace direct comparison VAR_1 differences VAR_3 METHOD_4 ( ) - VAR_1 > 0
imho easier read : javafor ( ; ; ) { TYPE_2 VAR_3 = METHOD_3 ( VAR_2 ) ; ( VAR_3 = = null ) { break ; } }
create static method return instance time
essentially eager - reading don t trigger read complete METHOD_9 ( ) ; ? avoid _CODE_ calls shouldn t care VAR_2 METHOD_8 ( ) point honestly strategy
ctx close ( ) ;
package private
4 spaces
4 spaces
remove private
put a finally block case
put a { } finally { buf release ( ) ; } block
check ! VAR_4 fetch volatile field ? : TYPE_1 VAR_1 ; ( ! VAR_4 || ( VAR_1 = TYPE_3 VAR_3 ) = = null ) { } else { }
reversed
merge 2 lines
merge lines
merge lines
mastrangelo shouldn t remove line
question
please style netty : ( ; ; ) { }
final field s computed values constants
I need call - - size ; please adjust unit test check
code a breaking change
explain
need method signature method protected changing signature a API breaking change
revert please
omit classname static * import
safe ? I scheduled repeating trimming task run arbitrary thread i e necessarily scheduled owns referenced _CODE_ instance scheduled task call _CODE_ _CODE_ ( )
I need add _CODE_ method :
TYPE_2 VAR_3 TYPE_1 VAR_3 bellow consistent
I set a finally block
VAR_1 false
METHOD_2 ? a memory leak
jut call super METHOD_1 ( ) ensure correct change super method content allow _CODE_ private
package - private
assert positive
assert positive
move METHOD_2 ( ) calls
VAR_1 executor
simplify conditional operator ? javareturn VAR_1 isEmpty ( ) ? null : VAR_1 ( 0 ) ;
simplify conditional operator
add some counter handler 100% compiler doesn t throw
final purpose ( compiling java < 8 )
possibly unnecessarily final
args set ? worth failing
effectively > = 0 a difference read slightly simpler inverted i e METHOD_5 block
I don t follow ( I m missing ) additional args passed purpose substitution message substitution done upfront message passed won t { } args
synchronized
I - factored : javawhile ( ! task METHOD_3 ( POISION_POLL ) { / / }
VAR_5 simplified : _CODE_ task ; ( ( task = VAR_3 METHOD_2 ( ) ) ! = VAR_6 ) { ( task ! = null ) { task run ( ) ; } }
remove ( )
static
static
picky : return StringUtils VAR_1 ( version ) && version ( STRING_1 ) ;
return StringUtils VAR_3 ( ) && equals ( STRING_2 ) ;
a private method doesn t need docs
null check redundant happen
bad return null return loader other return null didn t carry checks trust code
METHOD_6 fails catch update
unused < del > LOG_PATH instead LOG_HOME property ? < / del > mind I copied JIRA report sample input s active log path archives stored other path property test s remove
need STRING_1 ( dot ) ? files VAR_3
String format ( ) preferable
code fails parameter null
remove public s reformat ctor latest code style
argue done more compact extra variable allocation E g likejavaif ( VAR_4 ! = null && VAR_4 startsWith ( STRING_1 ) ) { VAR_5 = Arrays asList ( STRING_2 ) ; } else { VAR_5 = Arrays asList ( STRING_3 ) ; } leave code optimizer JVM : wink :
I understand urge code more robust changes done METHOD_1 possibly downstream changes code expecting error output null longer please revert change
log a higher level
return don t assign
please remove System METHOD_2 convert logger fine valuable debugging production
need a _CODE_
didn t change METHOD_2 call include return type
isn t default return type
cruft removed
METHOD_2 checks null changes pass empty string instead
leftover printlns addition assertions
a leftover I assume
I benefitial overloads ( _CODE_ jsonarray ) similar sdk
status INT_2 ? check status > = INT_2
test null VAR_1 ignore preferably interpret null VAR_1 ( empty String )
suggestionheader = null ; return null ; I need null VAR_2 cases input buffer doesn t enough readable bytes METHOD_1 full payload time super METHOD_1 called hits assertion _CODE_
Log debug
class a shell delegates operations a _CODE_ instance wouldn t a design include METHOD_1 ( ) _CODE_
missing braces
constructor protected ( I don t real issue public )
private
remove default _CODE_ DO_NOT_SET annotations null instead couldn t more effective null check
interesting decision point s fields initialized some - null default constructors conceptually I unset C * effectively null entity
nice i wondering work overloaded methods appears ( i e _CODE_ defined a previous _CODE_ exists
check fails converted easy read message ? I assuming client meaning ^ part code propagate exception message confused
please don t a constant METHOD_2 ( true ) perfectly clear s decide false idempotent point future
I #1208 : driver 4 0 don t specific exception codecs _CODE_ a codec serialize deserialize IllegalArgumentException I don t need introduce a special exception examples
driver 4 contribution guidelines mandate / / blocks enclosed braces line
METHOD_2 ( ) return empty connection treat _CODE_ ?
! VAR_1 METHOD_2 ( )
argument node ( inherited parent builder ) instead null
directory empty ? I suggest instead : runtime _CODE_ ( ) _CODE_ ( new Thread ( ( ) - > { ( stream < Path > walk = TYPE_1 walk ( VAR_1 ) ) { walk sorted ( comparator _CODE_ ( ) ) map ( Path : : METHOD_3 ) forEach ( File : : delete ) ; } catch ( IOException e ) { logger error ( walk + VAR_1 e ) ; } } ) ) ;
imo simplified f VAR_4 ( ) ; block start f null point
s a small overhead translate method reference call I m s significant avoid altogether passing TYPE_1 instead method mock test : _CODE_ random = mockito mock ( TYPE_1 class ) ; mockito ( random METHOD_3 ( mockito _CODE_ ( ) ) ) _CODE_ ( ( invocation ) - > { int i = invocation _CODE_ ( 0 ) ; return i - 2 ; } ) ;
simplified return ( VAR_1 && VAR_2 ! = null ) ;
preferable constructor reuse new ( i e ( VAR_2 VAR_3 false ) ) mark constructor deprecated existing updated new
shouldn t < ? super T >
a worse I constructor _CODE_ : _CODE_ pool = context _CODE_ ( ) _CODE_ ( ) ( node ) ;
noticed : check useless other TYPE_1 moment
trivial : chained METHOD_3 calls
I don t s fix issue returning correct TYPE_1 caller method leaving cached instance result metadata : javaprevious METHOD_3 ( ) VAR_10 = VAR_1 METHOD_3 ( ) VAR_10 ; return VAR_2 ;
VAR_2 set null future fails ? reason set VAR_3 fails want provide another opportunity set VAR_3
remove [ null ] altogether case message STRING_2
admittedly IllegalArgumentException isn t type mapper VAR_1 misuse IllegalStateException isn t : - IllegalArgumentException : _thrown a method passed illegal inappropriate argument_ - IllegalStateException : _signals a method invoked illegal inappropriate time_between I d IAE sake compatibility
moved loop
s a good point plan move TYPE_3 _CODE_ public theory allows users pass ( ) null _CODE_ ( METHOD_1 initially )
update build fail
shouldn t TYPE_2 class a suitable constructor initialize _CODE_ attribute ? public TYPE_2 ( boolean b ) { _CODE_ = b ; }
general a transient error means s temporary recoverable INT_1 _CODE_ recoverable
VAR_3 true doesn t s VAR_3 done VAR_3
t TYPE_3
shouldn t Log e
{ necessary
! VAR_6 METHOD_7 ( )
wrap curly braces ? ( listener ! = null ) { listener VAR_1 ( TYPE_3 TYPE_2 VAR_4 e ) ; }
omit null overload
needs method static
needs method static
Optional interfaces null internal
returning a Optional < String >
a NPE instead resolve optionals checking present ( )
null check unnecessary
add break statement
additional METHOD_2 needed
please extract constant
please StringBuilder
afaik xpn xwiki objects _CODE_ METHOD_3 ( String ) returns null
please move METHOD_3 loop
please change log remove
I d change initialize VAR_1 another reason ? : _CODE_ VAR_1 = TYPE_1 parse ( string VAR_2 ) ;
I d favour narrow exception thrown Exception generic inherits _CODE_
getter / setters plain tricks instead creating endpoint component set security provider endpoint correctly
shouldn t done need METHOD_2 VAR_4 sufficient a other components
primitive boolean compared null
saymessage VAR_5 ( xxx Boolean VAR_6 )
remove
reason throws Exception signature
context VAR_2 ( STRING_2 TYPE_2 class ) _CODE_ a bit nicer casting
added checked exception TYPE_2 method signature don t need catch - throw
fix ident json string
replace Collection addAll ? suggestionarguments addAll ( Arrays asList ( values ) ) ;
please run build sourcecheck profile
_CODE_ null check suggestionreturn TYPE_1 isEmpty ( field ) ;
a bit nitpicking camel started time message : - )
nitpickingsuggestion
method private
heal reconnect fix checkstyle issue
need create exception requires change default behavior please a standard - case
need create exception requires change default behavior please a standard - case
watch _CODE_ : : getId returning nullsuggestionif ( event instanceof TYPE_2 && ( ( TYPE_2 ) event ) METHOD_2 ( ) = = VAR_1 ) {
a log don t print standard please
avoided removing API break mentioned earlier
please create a constant put left side comparison thanks
VAR_4
3 implicit super ( ) calls removed
method return fact mvc endpoint return logging purpose
won t generate a _CODE_ VAR_1 null ? a 2 steps check Optional
want log error ? read s nominal case
_CODE_ instead
I _CODE_ : : _CODE_ replace synchronized containsKey
I VAR_3 unmodifiable
cache need loaded a _CODE_ _CODE_ a subset ache need
null default timezone instead current behavior
flip X ! = null style camel
run command line goal : mvn install - psourcecheck camel - flink directoryand fix checkstyle issues reports
reduce logging level debug trace
usage ctor ? don t wanna public
VAR_2 METHOD_3 reusing instance a gquery ( jquery ) good - practice performance reasons
return
System VAR_2 ( ) needed needed previous version : )
super ( ) removed
arg true
a ( ) class deprecated longer updated
please revert policy : > please refrain modifying classes org springframework asm org springframework cglib org springframework objenesis include repackaged forks - party libraries ASM CGLIB objenesis refactoring classes place upstream originating repository spring framework pick changes syncing official updates forked - party libraries
please revert policy : > please refrain modifying classes org springframework asm org springframework cglib org springframework objenesis include repackaged forks - party libraries ASM CGLIB objenesis refactoring classes place upstream originating repository spring framework pick changes syncing official updates forked - party libraries
good catch
proposed changed technically correct please revert sake readability
proposed changed technically correct please revert sake readability
need VAR_3 ( ) check effectively a constant string other words dynamic string concatenation converted a single string compiler suggestionlogger debug ( STRING_1 + STRING_2 ) ;
TYPE_4 String _CODE_ ( ) ? benefit reason create a TYPE_4 point class
please check [ guidelines ] ( ) source code style
I denying setter confusing scope PR change
Assert state more suitable VAR_2 results IllegalArgumentException
instead checking null pass TYPE_1 VAR_2 instead null constructors
I m comfortable a TYPE_4 called a METHOD_1 ( ) method a _CODE_ ( ) method exists ( a subclass )
want shouldn t expose raw mutable list means tests rewritten s discuss jira issue want thanks
operator required
making class final exception
conceptually _CODE_ ( ) querying length a read operation ( I realize practice won t matter due exists ( ) check code strange / wrong METHOD_1 ( ) )
reader ( )
please more compact - line syntax : javaif ( VAR_1 = = null ) return ; consistency other blocks code parts
a nitty picky pick : I find ! ( o instanceof TYPE_2 && o instanceof TYPE_3 ) slightly clearer
METHOD_2 ( STRING_1 String format ( STRING_2 VAR_2 VAR_1 ) ) ; 应该改为这个
a ( PR ) white space a ( indented tabs other spaces similar ) I d add curly - braces nested ifs ( consistency ) express ternary conditionals
VAR_2 null
please add { } - liners
else javaif ( content instanceof List ) { return ( ( List < String > ) content ) METHOD_2 ( String VAR_2 ) } return new String [ ] { ( String ) content } BTW VAR_1 a good values
required
class isn t public methods 🤔
delete function log tokens
throw IllegalArgumentException instead
aren t VAR_3 syncronized ? _CODE_
else [ ] ( start = 10 length = 4 ) else required _CODE_
ah ? token cache accessor needs auth request ? _CODE_
METHOD_4 ( ) [ ] ( start = 4 length = 11 ) METHOD_4 ? _CODE_
TYPE_2 VAR_2 [ ] ( start = 8 length = 21 ) line 94 line 111 : ) _CODE_
making private ? break ? _CODE_
aren t a warning collapsing 2 lines ? _CODE_
line 56 lien 58 difference ? s testing trim need _CODE_
I don t understand check outgage mode turned _CODE_ class iteself ? s turned checking extended expires
i don t check adding a reason prefer unassigned null
I currently - - - reply : [ 70552948 ] ( ) [ ] ( ancestors = 70552948 )
[ ] ( start = 8 length = 4 ) sense local variable class variable
run checkstyle complain access modifier order public final instead final public
[ ] ( start = 15 length = 4 ) remove ( needed )
[ ] ( start = 15 length = 4 ) remove _CODE_
> [ ] ( start = 5 length = 4 ) > trailing space
setting property ? _CODE_
don t need bracket
remove bracket
final
final
final
need bracket
Map
final
Map
Map
VAR_1 METHOD_3 checked null earlier add
I need check VAR_2 null empty
flip comparison VAR_1 = =
collapse 2 lines
I thought decided didn t need check a case a key key store a device OS INT_1
space
syncronized
java ? operator
change order
METHOD_1 adding time
_CODE_ need encoded
VAR_1 null empty a problem
VAR_2 case sensitive
calling METHOD_1 instead calling constructor
static import
static import
counterintuitive annotation outermost type it’s printed ? ( it’s incorrect wow feature weird )
remove / catch exception METHOD_3 test
field definition strange interchangeable
mind simplifying expression ? ( VAR_2 ! = TYPE_3 VAR_4 && VAR_2 ! = TYPE_3 VAR_5 ) {
ah
braces
pass
check empty pass null ? t add VAR_4 copied instance ( I m constructor figure assignment ! )
private
I builder approach build ( ) throw VAR_3 inappropriate VAR_3 private
_CODE_
don t need
shouldn t surround ( ! VAR_1 isEmpty ( ) ) simplicity
das darf hier nicht sein der controller räumt nur seine view auf und aendert nicht die vom parent
1 request VAR_1 = true request VAR_1 = false 2 i s loading request i block wowza thread long
add VAR_1 = null
new HashMap < String Object > ( )
u add var onlu u VAR_4 ( VAR_1 ) METHOD_2 ( ) ; line 515 instead line instead 515 - 516
splitting rows
s JEE s managed executerservice lookup JNDI create managed
wondering w / slf4j need custom format ( ) ? I hope / s done slf4j logging library
instead manually updating categories deleting couldn t change cascade
static
static
[ ] instead null order avoid NPE check
return VAR_2 ( ) ll check null call previous VAR_2 business code ( expect call new method )
static 3 methods
null check needed org testng xml _CODE_ returns empty list
TYPE_4 cast useless confirm
I dont throwing exceptions instead empty implementations
I dont throwing exceptions instead empty implementations
a detail s a personal taste I prefer business code root level _CODE_ VAR_1 = VAR_2 METHOD_2 ( METHOD_3 ( ) TYPE_1 class ) ; ( VAR_1 = = null ) { return new String [ 0 ] ; } return VAR_1 METHOD_1 ( ) ;
assertThat ( VAR_1 METHOD_5 ( ) ) isEmpty ( )
move line statement don t need execute VAR_2 null empty
mentioned listener required
reverse parameters order more _CODE_
values ( ) instead entrySet
justjavareturn VAR_1 ( getName ( ) ) ;
start STRING_1 return true
static
t more return null
need change values ? TYPE_3 3 = > HAS_SKIPPED + HAS_FAILURE INT_1 = > HAS_SKIPPED + HAS_FSP expected
5 means HAS_FAILURE HAS_FSP
VAR_2 null
typo : missing space
private static boolean METHOD_1 ( String [ ] VAR_1 Collection < String > VAR_2 Collection < String > _CODE_ ) instead 2 methods
public static sonar complain
size VAR_3 array
create ( VAR_1 )
METHOD_4 :
static missing
I synchronized ( ) a good practice case want a synchronization VAR_3
names constructor ( SKIP ( skip ) ) modifying toString ( ) accident won t break parsing
FYI future pull requests s remove kind syntactic changes send pull request distracting add noise pull requests 100% semantic changes reviewers review more easily move refactoring other changes don t modify meaning code separate pull requests
I prefer empty list instead null
s a personal taste I prefer : javaif ( VAR_1 > = VAR_2 length ) { throw new TYPE_1 ( ) ; } return VAR_2 [ VAR_1 + + ] ;
< test > node verbose VAR_1 - static
needed
max + min size I synchronized removed setter methods variables volatile instead
shouldn t temp file METHOD_3 close _CODE_
METHOD_2 METHOD_3
TYPE_4 checks null
put a wrappers start appearing lists IIRC
won t work correctly : FOO = $FOOBAR
} else
! [ MINOR ] ( ) line start column 9 [ ! [ rule ] ( ) ] ( )
I don t replacing bus dispatcher proxies a good idea references proxies held other classes proxy want METHOD_1 bus / dispatcher proxies close instances
glad test coverage test missing some assertions more robust call iterator#next ( ) verify returned a TYPE_3 sufficient reproduce issue I
replacing %s more message exceptions type String format ( ) part ( extra ) constructor exception
I don t a static VAR_3 I cleaner METHOD_4 METHOD_1 return boolean values indicating a tuning error create a new exception type _CODE_ thrown tuning - specific errors
return VAR_2 METHOD_3 ( new String [ VAR_2 size ( ) ] ) ; String array length preallocated
shortcut VAR_1 = = null need VAR_2 conditions
method throw exception caller decide exception necessary Logger
return a copy
parameter VAR_2 variable created
define constants builder ? final redundant static methods
minor : ternary operator
VAR_1 > = 0
move part conditional METHOD_2
inline
I idea AWS_PROFILE env var a user hasn t explicitly constructor change pretty close behavior edge case a user explicitly passed default constructor tweak code account case ? I don t d want AWS_PROFILE env var case a user pass explicit profile behavior handling AWS_PROFILE env var consistent other AWS _CODE_
s shift operators instead ofjavavalue + = ( int ) Math VAR_2 ( 2 0 ( double ) i ) ; s havejavavalue + = 1 < < i ; left - shift operator equivalent 2 n - power ( 2 ^ i = = 1 < < i ) advantage requiring conversions floating - point avoids expensive operations happen Math VAR_2 left - shift operator a single assembly instruction : )
suggestion } catch ( IOException | InterruptedException e ) {
suggestionif ( VAR_2 = = null || VAR_2 METHOD_2 ( ) METHOD_3 ( TYPE_2 VAR_4 ) < 0 )
cloned instead a reference external object
s buggy _CODE_
return object synchronization happen implicitly calls Set methods synchronize object explicitly setter
needed synchronized method method
true VAR_2 null a null point exception suggestionif ( VAR_2 ! = null && ! VAR_2 isEmpty ( ) ) {
redundant
bug setting description instead VAR_1
problem _CODE_ ( linked / ) served _CODE_ layout jelly calls METHOD_1 ( ) determine show a link footer change show exception stack trace log possibly page / manage users
? ( ) run
suggestionreturn Integer VAR_1 ( VAR_2 o VAR_2 ) ;
_CODE_ log ( VAR_4 ( ) - > Messages TYPE_3 ( job VAR_3 ( ) ) ) ;
main difference i _CODE_ PR leverages METHOD_2 ( ) returns a channel object a lines function channel object a readability standpoint pretty confusing a reader misinterpret METHOD_2 ( ) scenes actual fact doesn t
suggestionj VAR_1 METHOD_2 ( ) ;
suggestion METHOD_5 ( ( ) - > j VAR_3 METHOD_6 ( ) METHOD_7 ( task ) ) ;
more legible introduce a TYPE_6 ( )
👎 strongly restoring insanity currently need rely individual admin monitor authors shit negate
line
unrelated
_CODE_ ( 1 TYPE_1 VAR_2 ) ; I suggest existing pattern file calling assert ( ) methods new import wouldn t needed
I tend brackets
_CODE_ ( r VAR_4 METHOD_6 ( STRING_1 ) ) ;
private
I find easier read assuggestionreturn VAR_1 METHOD_4 ( METHOD_3 ( ) ) && VAR_1 METHOD_6 ( METHOD_5 ( ) ) ;
IllegalStateException
suggestionreturn ! TYPE_1 ( ) METHOD_2 ( ) ( id ) ;
add finally ? ZIP stream corrupted cf METHOD_5 ( ) METHOD_6 fail
join declaration assignment
suggestion
METHOD_1 follow format _CODE_ _CODE_ consistency
putting VAR_3
I don t a need synchronized anymore
problem originally address values frequently ? ? ? more common exact want > - 100 want reduce number times enter else need a Math max ( 0 VAR_1 ) METHOD_4 output nonsensical values TBH I line > = _finished waiting_ message rest jenkins broken
pulled _CODE_ _CODE_ —it specific job
TYPE_2 constructor needs encoding I junk
omitted : javaprotected TYPE_1 ( ) { }
parameterized _CODE_ log ( TYPE_3 VAR_3 ? Level VAR_4 : Level VAR_5 install state transitioning : { 0 } : { 1 } new Object [ ] { } ) ;
call METHOD_6 ? unnecessary
i e javaif ( Boolean VAR_4 equals ( request VAR_3 ( TYPE_5 class getName ( ) ) ) {
BTW trim unnecessary text _CODE_
ditto drop trim
reason exists jelly view
unrelated change
VAR_2 null I return ( property lost )
original constructor
false
( run VAR_2 null ) avoid code duplication
delete default ID
wrong needs a core version a plugin version ? I replaced new TYPE_1 ( p VAR_2 )
problem approach nested VAR_1 a search result _CODE_ view a user I expect higher priority worth checking _CODE_ VAR_1 I vote making a parameterizable method View METHOD_1 ( String boolean recursive ) changing API calls related search hard predict impact defaukt behavior change
return null
deserves a separate JIRA ticket important enough
behaviour
I a reason invoking listeners VAR_1 🐜
request null
remove redundant ; static analysis complain
a final class s extension point potentially some migrations custom implementations plugins 🐛
add _CODE_ 🐜
assertEquals
IOException s supported
great brackets new code
able private
need catch IOException rethrow avoid wrapping another IOException
catch IOException rethrow avoid wrapping IOException IOException
strange formatting glitches
work fix _CODE_ catch errors METHOD_1 implementations true _CODE_ : bug : fact needed suggests regressed logic _CODE_ METHOD_2 supposed interrupting _CODE_ test ( #1950 ) verifying
source 1 7 level diamond operator
a _CODE_ suggested
bug : binary compatibility
VAR_2 reset
clear - queue instead reload - configuration I guess copy - paste bitten #1942 ; - ) couldn t _CODE_ + strategy pattern introduced factorize common code
I changes special coding style
I LOGGER legitimate case related slave logs
new method implementation synchronized
gratuitous whitespace - changes avoided minimize work cherry - picking
error code usefull assertEquals ( STRING_7 + cmd + STRING_8 0 p VAR_5 ( ) ) ;
ant : follow convention file
restricted especially consider moving TYPE_1 installer plugin
commonly TYPE_2 another order parameters comparisons I m s defined code conventions
minor : _CODE_ assertions
helpful record date / time
trivial unittest
log messages _CODE_ _CODE_ log ( Level VAR_5 STRING_2 + VAR_1 e ) ; information ( more )
consider ( _CODE_ class ) I reason public API
package - private I expected caller _CODE_ point factoring a request class able add more parameters
IMO synchronized
compatible : existing shell steps report UNSTABLE instead SUCCESS
METHOD_4 nonsense simpler write : TYPE_1 = org VAR_1 VAR_2 VAR_3 TYPE_3 METHOD_2 ( file ) ; { return org VAR_1 VAR_2 VAR_3 TYPE_2 METHOD_3 ( ) ; } finally { close ( ) ; } - source 7 simplified totry ( TYPE_1 = org VAR_1 VAR_2 VAR_3 TYPE_3 METHOD_2 ( file ) ) { return org VAR_1 VAR_2 VAR_3 TYPE_2 METHOD_3 ( ) ; }
new constructor takes 4 bools passes 3 calls _CODE_ constructor leave ll eventually arrive new constructor
note simpler idiom ( converts more cleanly java 7 syntax ) _CODE_ VAR_1 = new TYPE_1 ( file ) ; { return TYPE_2 METHOD_1 ( VAR_1 ) ; } finally { VAR_1 close ( ) ; }
more consistent VAR_3
don t System VAR_6 throw a RuntimeException
wrap weird checked exceptions TYPE_5 unchecked _CODE_ means don t need modify a bunch unrelated classes throw
ticket s [ description ] ( ) false user doesn t exist
long enough ( case l )
inline variable
s declare method ( other methods class ) throwing Exception prescribed [ ] ( )
integer division instead subtracting remainder
I don t s a good idea public
line ? I didn t
brr doesn t a real implementation return * * world * *
I implementation render ( ) need a puzzle - copy line
wrong indentation forgot run build qulice profile enabled
pass entry ? parameter
method private visibility
don t public s done _CODE_
I s TYPE_8 VAR_2 ( getInt ( STRING_1 ) )
I don t Exception thrown method
I test fails container remain started port busy good practice enclose tested code block VAR_5 container finally
test checks METHOD_2 ( ) method return _CODE_ object s worth VAR_1 METHOD_2 ( STRING_1 ) ( ) check some attribute
A lot - time variables created please manual
point saving class variables
hm testing TYPE_2 instead TYPE_3 class : ) familiar TDD TYPE_2 _CODE_ ? explain logic test method
leave String a previous line ?
VAR_5 apply ( new TYPE_1 ( ) METHOD_2 ( METHOD_2 ( ) ) METHOD_3 ( STRING_1 Boolean toString ( true ) ) ) ; good huh
test test test a location cash points returns a - null list zero items
test expect exception pass empty string
这个分号？
这个没有必要变更private属性？
这里写错了，是 host STRING_2
_CODE_ + _CODE_
调用 key trim ( ) 干什么？另外，key length ( ) = 0 并不代表是非法的 key！
TYPE_1 VAR_2 是允许为空字符串的。
VAR_2 trim ( ) 是何意？
因为没有成员，这个可以声明为 static 了。
这一系列方法都是无状态的，考虑声明成static。
_CODE_
side note bringing dep installing module start a number pollers / db connections / zk connections / don t want
doesn t guy created
fat - finger switcheroo
a good idea accept calling class instead a log class trace logs ? ensure names pass locking aren t arbitrary useful tracing flow scheduler
safe VAR_2 ( ) METHOD_1 ( ) private allow rest scheduler interact _CODE_ ( )
instead passing Optional lists let’s default empty list constructor arg null other objects save a lot isPresent throw
sense create a method didn t parameter
a sentry other day exception bubble _CODE_ abort catch skip offer case else checked
Long
VAR_2 + 1 correct ? wouldn t VAR_2 + VAR_3
switch primitive boolean s instead ? removes potential _CODE_
stream closed ? add block case : ( TYPE_2 s = VAR_2 METHOD_3 ( m group ( STRING_1 ) m group ( STRING_2 ) ) ) {
s a matter taste I d prefer Boolean toString ( VAR_1 )
gotcha settings reloaded _CODE_ app needs flush file call _CODE_ _CODE_ ( VAR_3 METHOD_3 ( ) ) instead making user restart app isn t work connection - string idea
lines required ? I d expected d need _CODE_
curiosity TYPE_1 commit apply ? I scanned apply ( correctly I ) _CODE_ I apply fine reasons commit typically unnecessary slow I unnecessary slow testing I m learn TYPE_1 I read wrong
⚠️ parameter wrong
function potentially called simultaneously multiple threads lead a race condition synchronized
suggestionif ( TYPE_1 METHOD_2 ( TYPE_4 VAR_3 ) ) { METHOD_3 ( TYPE_2 parse ( METHOD_4 ( ) getString ( R string VAR_2 ) ) ) ; } else { TYPE_3 METHOD_5 ( TYPE_4 VAR_3 METHOD_4 ( ) getString ( R string VAR_4 ) + METHOD_4 ( ) getString ( R string VAR_2 ) false ) ;
checking VAR_2 = = null invoking comparison operator checking null crash NPE null ? a place extra careful translating python please double check s correct branches
unused s
sense catch Exception return null failure specific failures
A function called METHOD_1 ( ) set language more call METHOD_7 ( ) immediately function called putting function
a lot work private
methods private ? I unit test I deencapsulation feature testing framework ? interface a class changed accommodate a unit test
private
braces
please braces
please braces - line statements
METHOD_1 doesn t modify mod time s return s returning encoded json ( null ) long a 200 reply command succeeded
return
getClass ( ) places
missed edits METHOD_1 ( ) 9 lines 24 lines
uneeded String valueOf ( ) arguments String format ( )
DEBUG level final release
protected avoid introducing extra shadow _CODE_
extract local variable URL avoid noise sonar defer NPE calling method times
duplication s
changed mind decided setter ctor I doesn t a justification a final
new close ( ) t
method calls ? I guess moved existing setter class structure fix a change
prefix class properties
I care - _CODE_ client created client invalid moment METHOD_1 ( ) I missing
I opinion deprecated API call a new coverage need a change target logic a deprecated API won t affected meant removal eventually 😄
gary ctors final props AMQP specs protected extension ? I won t include extensions PR #3167 avoid conflicts fixes thanks
needed ? default
VAR_3 METHOD_3 ( VAR_2 METHOD_4 ( ) )
I don t solution don t need build send a message channel
leave super ( ) avoid empty block complaint sonar
t a VAR_1 initialized VAR_2 default ? I a logic ( VAR_1 ! = null ) don t return null method instead ? I a consistency current logic METHOD_1 ( ) inheritors
I VAR_3 conditional null explicit StringBuilder instead
a TYPE_3 TYPE_2 avoid wrapping ? i don t mind other branches master thanks
I don t rendering a byte [ ] a bunch ints useful omit ( include length )
a lot overhead a toString ( ) need _CODE_ event
copy / paste
please diamond a couple VAR_2 METHOD_5 ( new String [ VAR_2 size ( ) ] ) class I guess smells sonar great fix class thanks
please fix kind smells explicit array size thanks
exit early VAR_3 null need store local variable case
t - breaking change subclassed implemented METHOD_1 ( ) I suggest / / NOSONAR TODO : remove throws 5 2 removing subclasses
I don t need assert ; spring call a null result
happened method ? isn t a private anymore
variant simplify code : METHOD_1 ( String sql Class < T > _CODE_ Object args )
I rename _CODE_ ( ) yeah remove ( supplier ) altogether breaking change agreed choice I find explicit casting style more annoying removed method WDYT
I good 😄
don t need super - super - super class : public _CODE_ ( Object source ) { ( source = = null ) throw new IllegalArgumentException ( null source ) ; source = source ; }
test isn t full doesn t prove async applied I m test pass async = true please develop test - case reflect expectations
need getters public ? a component declared java config bunch method choose I agree protected public reason explained I assume setters supplied _CODE_
I finally block VAR_2 = ; race condition
thanks update s I want I null add null checks _CODE_ ( ) method implementor decide some other logic message store e g convert simple string representation ( s ) able override _CODE_ ( ) don t count VAR_2 / VAR_3 I nul checks minimize time actions _CODE_
VAR_3 METHOD_1 ( VAR_1 ) ; takes care assert don t need extra
checkstyle
curious : add method ? protected
need check null
I cleaner move test callers strange return null s bound key
( TYPE_2 METHOD_1 ( VAR_2 ) ) doesn t work ? _CODE_ please
jackson boon fail : > jackson - databind jar boon _CODE_ : else ( _CODE_ ) { return new _CODE_ ( ) ; } else { throw new IllegalStateException ( jackson - databind jar boon jar present classpath ) ; } approach _CODE_ doesn t work ? TYPE_6 _CODE_ ( ) ? TYPE_6 _CODE_ ( ) : null ; other words fallback boon present jackson
intend final
M - m - m I move assignments ctor super class case won t need variables protected sonar qube angry
VAR_2 updated I missing ? I update _CODE_ _CODE_ ( ) new VAR_2 argument
IDEA cast redundant : ! [ redundantcast ] ( )
I shouldn t strict async mode component doesn t return _CODE_ _CODE_ : ( async && reply instanceof _CODE_ < ? > ) { _CODE_ < ? > future = ( _CODE_ < ? > ) reply ; silently close eyes user configured _CODE_ async
logger doesn t reflect reality more file doesn t exist move exists condition
s a solution some kind package tangle case evaluate expression Object check type String _CODE_ customization _CODE_ - case common TYPE_1 doesn t provide some extra noise simpler create _CODE_ manually String _CODE_ result
counter contract requires _CODE_ pull METHOD_3 ( ) contract TYPE_1 ? yeah master point persistent odd logic WDYT ? complain I merge cherry - pick
missed transactional ( ) option convenience
typically I spec visible factory methods instantiate purpose created - user level
I return type method TYPE_2 don t access _CODE_ ( ) method target code
return void remove ( METHOD_1 log falling copy / delete _CODE_ ( ) logic _CODE_ ( ) deletes existing file removed tests throw s removed TYPE_1 METHOD_2 throw exception
multi - catch pursuit modern style : smile : : ( ) pay attention TYPE_3 cast redundant lambdas don t need final passed variables block simplified : private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_6 TYPE_7 TYPE_8 request = VAR_1 METHOD_2 ( VAR_3 ) ; { VAR_1 METHOD_3 ( request VAR_5 ( ) session - > request ) ; } catch ( TYPE_4 | TYPE_5 e ) { } }
I m unconditional logs tests mind removing polishing ? thanks
redundant modifier travis _CODE_ class private
( ! VAR_2 && VAR_1 ) { I don t reason override _CODE_ VAR_1 feature assertion commit message : > change aggregator a _CODE_ default > METHOD_1 ( true )
ha ! true decouple s correct word isn t poller responsibility fetch target system I agree great consult VAR_2 poll poll backpressure ? 😄
mock ? pretty simple lambda : channel VAR_1 ( m - > { } ) ; : smile :
logic _CODE_ instead
M - m - m t simplify life jackson client afterward return null properties empty ? I m add eventually more more some cases empty
? ? ? private final Map < String Object > properties = new HashMap < String Object > ( ) ; t null idea : return properties isEmpty ( ) ? null : properties ;
beans static ? overhead isn t critical mind
overdid : null return null : smile : other side t null ctor : Assert _CODE_ ( VAR_1 VAR_1 null ) ;
good weird placeholder ? I thought agreed TYPE_2 _CODE_ ( ) fixes problem don t null anymore
s time port _CODE_ DSL
override method public _CODE_ example ? smells a bit publish kind options _CODE_
redundant protected _CODE_ _CODE_ start ( )
I misunderstood ; point shouldn t block stop ( ) ; overriding METHOD_1 ( runnable callback ) return invoke callback listener stopped I noticed gateway invoking super METHOD_1 ( ) _CODE_ stopped problem _CODE_ ( )
_CODE_
I d understand reason extra _CODE_ creation object encoding
? ? ? _CODE_ ( ) serialization operation
unnecessary
_CODE_ ( serial ) need usenew TYPE_2 < String TYPE_3 > ( VAR_7 + 1 0 75f true ) { } enable LRU processing
true exec inter super remove ( ) successful
minor :
a bug ! requested VAR_1 list decrement true remove ( )
TYPE_1 ctor extra TYPE_2 variable redundant
I VAR_2 ( VAR_3 ) METHOD_2 hasn t affected collection
check collection matter
TYPE_2 takes care factory assert redundant ctor : ( new TYPE_2 ( factory ) VAR_2 ) ; s
redundant null check
wrong _CODE_ ( ) returns null
( new TYPE_1 ( ) ) ; minor live
( List < ? > ) ( 3 places )
I node t null
purpose publicate
entrySet ( )
t breaking changes a point release ( cherry - picks ) I choice add methods _CODE_ ( ) sense retain int versions users don t need long precision
scope variable needed anymore concurrent stuff _CODE_
a public goal getter ? I d prefer expose avoid undesired mutation I understand point expression comparison encapsulte equals logic recipient class I doesn t hurt extra GC _CODE_ ( String _CODE_ String VAR_1 ) other side check type TYPE_1 access _CODE_
I another bug - super METHOD_1 ( ) called _CODE_ = = null
whitespace ! =
s true : VAR_3 null empty string ( VAR_3 = = null ) { another ctor assert logic
I suggest start ( ) ( instead ) code relies fact connection manager invokes VAR_1 returning true future
needs finally - interrupted
more time : invoke close ( ) VAR_1 ( ) ? d letter ( similar tcp ) test class ? don t invoke close ( ) similar test tcp ? : smile :
need _CODE_ ( )
TYPE_1 < ? >
return empty TYPE_1 ( a static constant empty props don t create a new instance ) save a null check
( time - VAR_2 ( ) ) > VAR_1 ) > 0
VAR_3
VAR_3
instead please implements _CODE_
I m curious call needed added TYPE_1 : private volatile boolean VAR_3 = true ;
I guess else required block a return personally I d find easier read : TYPE_1 VAR_4 = METHOD_2 ( VAR_1 VAR_2 ) ; ( VAR_4 = = null ) { TYPE_2 VAR_4 = ( StringUtils VAR_5 ( VAR_2 ) ) ? new TYPE_2 ( VAR_1 VAR_2 ) : new TYPE_2 ( VAR_1 ) ; VAR_4 = METHOD_3 ( VAR_4 ) ; } return VAR_4 ; feel free ignore : )
set VAR_3 METHOD_2 returned true ? current impl I don t a difference VAR_5 checked prior VAR_7 / else order a fragile assumption
return ! METHOD_2 ( ) || VAR_1 ;
* * final * * _CODE_ general METHOD_4 implementation clear stiffly : _CODE_ delegates METHOD_1 check METHOD_3 ( ) redundant I don t more flexible solution : - ( a _CODE_ flag
question : _CODE_ field ends false _CODE_ produced METHOD_1 ( ) operations preserved a introduce true values
parameter overridden line 1284 a bug ? I wrong
don t pass intial hashcode location VAR_1 ( ) instead mix hash codes guava objects VAR_1 ( )
making allocations
creating a compressed key decompressing TYPE_1 METHOD_1 ( VAR_2 compressed ) constructor place
wouldn t forced call slow saving considerably ? need minimum calculation ? doesn t hurt pick a larger buffer
I d write < ! = s a bit clearer imho
shouldn t synchronized
s a bad idea catch NPE s other exception generated a common class bugs output VAR_6 ( ) return null ? case statement
missing { }
FYI ImmutableList ( VAR_1 ) more efficient s big deal s a note future reference
check null _CODE_ I guess need check
safe check _CODE_ METHOD_3 ( ) ! = null
( _CODE_ class )
tested works ? IIRC configuring trigger a new instance created UI pipeline script s instance stop start calls
StringUtils isEmpty ( )
removing synchronized means risk dirty write
VAR_3 ( ) null jobs triggered started care potential null entries safest omit source case some other caller isn t foreseeing
debug trace fix line 422 ; )
I guess list empty causing indexoutofbounds line 110 adding || VAR_1 isEmpty ( ) safer
VAR_2 parameter
лучше этот Exception выбрасывать на верхний уровень или обернуть в RuntimeException если не хочется его везде прописывать Т к его возникновение это признак нарушения целостности БД или программной ошибки
такая конструкция избыточна там помоему можно просто писать msgid tagid - работает varargs + auto boxing
pulling VAR_2 variable consistently code s need null check code thrown a NPE line 4483 VAR_1 null
isn t defined return a null Arrays asList ( null ) NPE thrown
VAR_1 Integer return doesn t unboxed reboxed int Integer
I don t need - List iterator supposed simple case JIT eliminate allocation
TYPE_2 return type
replaced containsKey ( ) ( ) remove METHOD_8 ( ) class ( ) takes a TYPE_4
VAR_1 ( ) toString ( )
println left
ditto more
add Throwable t exception
I kinda leaving set variable declared fine
boolean necessary ? delegate check diagnostics enabled diagnostics logger
prefer isEmpty ( )
I hesitate I catching exceptions sense s a system call include VAR_2 call line 149
new parameterized support m4
/ easier TYPE_1 created / added constructor set / ?
required ? shouldn t handled METHOD_1 ( )
index > Constants VAR_1 - 1 dealing index
I suggest improve readability changing ctx VAR_1 METHOD_2 ( ) size ( ) > = Constants VAR_2
else statement METHOD_1 ( ) method means script don t want script stuck methods return proper values
VAR_1 a class - wide variable populated script starts currently poll ( ) method possibility creating VAR_1 times a waste resources potentially slow script
don t need worry player logged ; script s start ( ) method invoked player VAR_1
introduce a local variable VAR_3 don t grab iteration
simplified a ton return c ! = null && ( ( key && ctx input METHOD_3 ( { VK_SPACE } ) ) || c VAR_1 ( ) ) line note didn t turn ; I meant METHOD_1 ( boolean key ) method
I null default won t generate empty property VAR_3 needed
throw Exception instead swallowing I d write : javapublic static String METHOD_1 ( File file ) throws Exception { return TYPE_1 METHOD_2 ( file VAR_2 ( ) ) METHOD_3 ( ) ; } new method deserve some unit test _CODE_
_CODE_ _CODE_ instead
moved _CODE_ VAR_7 > VAR_5 return false
surround parenthesis expressions left && more clear
need close a finally block
pass null allow downstream _CODE_ passed null avoid creating a TYPE_1 needed
print stacktrace
don t TYPE_2 translated other languages
instead string version order avoid creating a costly stack trace creation exception
VAR_1 read synchronized block
don t need work HTTP server domain sockets HTTP client s a simple test necessary
seize opportunity rename method confusing current method purpose provide a hook clustered event bus propagate TYPE_3
synchronize ( ) method synchronized
need check
I TYPE_5 TYPE_6 implement need remove list
data length ( )
synchronization issue instantiate set times
shouldn t return ! METHOD_2 ( ) ;
simpler VAR_2 stream ( ) map ( entry - > STRING_1 + entry ) forEach ( args : : add )
final
need new String [ ] others
static
called ( null null ) - method URI account
check TYPE_5 TYPE_6 equals ( ) checking instanceof METHOD_3
variable VAR_1
able VAR_8 METHOD_3 ( VAR_1 TYPE_5 VAR_5 ) I
I suggest removing / physical store new File ( VAR_3 _CODE_ _CODE_ ( ) ) storage path relative VAR_3 works a bit e g 9s / 3b / jasldjgenha / 9s / 3b / jasldjgenha case leading / confuse root disk
some concern security : output user / pass
need a list remote servers order handle clustering ? configured cluster
s copied init extract a private method instead
pass #init
! = null check necessary
shouldn t line moved line higher close brace
add _aclass METHOD_3 ( ) _ diff 1 line instead 7
nice java8 optionals easier read fashioned null checks
wondering mapper instance returned instead spring factory spring wire mapper magic : )
javareturn state getValue ( VAR_1 ) ? 1 : 0 ;
line a bit long math another line movement VAR_1
returning a localized expects a * * * key * * *
pretty supposed localization key
issue
expects a localization key
fully qualified class
VAR_5 isEmpty ( )
override equals override _CODE_
unecessary
remove ownpublic TYPE_2 ( TYPE_1 item int VAR_2 int meta ) { / / blah } NBT isn t set constructor a setter edit : final perfectly fine
plugin requires newer jenkins core version 2016 check required anymore
please brackets single - line cycles
please leave METHOD_1 ( VAR_1 VAR_2
compile
reason optional
suggestionprivate static String METHOD_1 ( final String VAR_1 ) {
[ TYPE_1 VAR_2 ] ( ) specifies return values - 1 0 1 < 0 ( zero ) > 0 ( greater zero ) clearer taste [ comparable VAR_2 ] ( ) specifies return values a negative integer zero a positive
conflict #722
AFAIR instances _CODE_ reused clear ( ) useless
wondering ? related ASM 6 ? I m asking some improvements some nasty regressions / missed cases exception handling
IMO addition indication regression METHOD_1 ( TYPE_1 String )
absolutely ! context agent class obvious classes instrumented
checking operands ? labels
( expected = IllegalStateException class )
don t set : don t log log : [ property ] [ VAR_2 ]
line removed
avoid lookup ? final Double VAR_1 = configuration ( entity ) ; return VAR_1 = = null ? VAR_2 : VAR_1 METHOD_2 ( ) ;
chance add a constructor takes metadatsource VAR_3
VAR_2 doesnt cast a TYPE_2 place fact VAR_2 introduced prevent need casts important i e J2EE environments TYPE_1 wrapped a proxy implement TYPE_2 VAR_2 throw a _CODE_ implementation requested type exception catch rethrow IllegalArgumentException a _CODE_
mutually exclusive ? a micro optimization
_CODE_ deprecated transformation done TYPE_1 ? _CODE_ _CODE_ = VAR_2 ( type _CODE_ ( ) ) ; ( _CODE_ _CODE_ ( ) ) { _CODE_ = _CODE_ + $ ; }
removed ? I new TYPE_2 ( ) apply ( ) s handled other constructor
I relaxing type parameter TYPE_2 type METHOD_2 constructor Class < ? extends TYPE_1 > helps a lot eliminate casts * * * *
templates _CODE_ necessary METHOD_2 CHAR_1 CHAR_2
mind _CODE_ stateful tests reflect
committed merge markers
return VAR_1 = = null || VAR_1 length = = 0
I noticed a bunch transitioned Throwable TYPE_2 Exception
doesn t a recoverable scenario - throwing ? some default / fallback TYPE_1 instantiation fails
multiple shutdowns shared executor ( ) want track a _CODE_ variable null _CODE_
shouldn t { }
calling more throw exception ? invalid state
support typed property _CODE_ ( TYPE_2 TYPE_3 VAR_5 ) ;
accidental box
s instead Optional
a surprising hack please change place instead doesn t sense a property manipulated scheduled expression accept seconds expression s
suggestionif ( VAR_1 ! = null ) {
I m wrong I thought don t sample client VAR_1 calls span reporter thread wouldn t sampled originate flush thread server requests check necessary
I _CODE_ Throwable _CODE_
code didn t throw I returned null
I m want add logging cases verbose bad requests
require ( length )
I wait 1 default arbitrary
static initialized ctor final static
set null empty
interesting surprised works I shouldn t
big deal don t put final variables explicit good reasons some folks conventions leaving line shorter focuses more attention test code ( risk shell - game references )
some nitpicking ( a change ! ) ; I pattern written : ( VAR_1 = = null ) { VAR_1 = METHOD_3 ( VAR_2 ) ; } return VAR_1 METHOD_2 ( ) ;
instead avoid unchecked cast : return VAR_2 ( new HashSet < > ( Arrays asList ( VAR_2 ) ) ) ;
a reason split logic ? I put _CODE_ ( TYPE_1 long )
field point null - s need additional work return Optional empty ( ) find resolved Optional ( ) : _CODE_ field = run ( TYPE_5 action ( VAR_1 VAR_2 ) ) ; ( field = = null ) { return Optional empty ( ) ; } else { String VAR_3 = VAR_4 getName ( new _CODE_ ( VAR_1 VAR_2 ) ) ; return Optional ( new TYPE_1 ( field VAR_3 ) ) ; }
@Override annotations line
t call VAR_1 ( Class < ? > _CODE_ TYPE_2 VAR_1 ) remove ( )
fixed
construct buys
minor s consistent order method parameters
annoying please a separate JIRA commit
t top ? s avoid cast
mentioned s move 3 super METHOD_1 ( ) method
avoid containsKey ( ) + ( ) cascade checking result null
didn t agree null check VAR_1 isn t needed ( sambe )
s reasoning initializing lazily instead constructor making field final ? btw VAR_1 ( ) null
null checks needed
a list type
missing new line
technically wouldn t Class < ? extends TYPE_1 >
assertions reached due ( expected ) exception
a java 8 construct left
s overridden private
checked _CODE_ sufficient a base class ? avoid conversion
question
I don t call super method needed
handle null properly
couldn t other methods invoked e g $ { _CODE_ _CODE_ ( 3 ) } ? I guess doesn t lots sense I legal WDYT
note reasons I chose annotation due fact don t extensions calling int version method annotation allows signature function runtime outright changing extension exists result a _CODE_ change published I recommend int version maintain compatibility
d nice change message takes numeric argument string export N selected projects
else case curly braces a single statement ( [ google java style guide ] ( ) )
shouldn t return x - parsing property
return y instead - parsing
I m thinking protected t inadvertently called subclass explicitly public provides simple annotations
_CODE_ types a specific view type add additional generic parameter _CODE_ view type addition dataset allow move view field superclass
qualifying necessary ? context TYPE_3
local variable declared List instead ArrayList worth caching
= = sufficient faster equals ( ) d testing identity component equality
add remove synchronized VAR_2 chance extension a separate thread introducing a race condition
need unregister line 94 calling unregister a VAR_2 object register call
consider switching List < Object > instead unspecified List type
s clear VAR_1 updated other set constructors subclasses I don t synchronizing method gains performance loss
potentially block UI thread long enough time ANR appears depending size file read
code style : curly braces else statements
code style : space
earlier notes code style statements
current version code result reported branch I recommend semantics consistent move call METHOD_3 branch
I thought pretty cool label updated I spoke I m a bit concerned apps programmed correctly logic METHOD_2 called multiple times call _CODE_ I conferred team consensus continue METHOD_2 add a new parameter called partial true call response METHOD_1 false called _CODE_ allow developers determine app user finished speaking
necessary ? semantics METHOD_3 supposed s called component removed screen companion app
moment results dialog showing unconditionally wrap a check VAR_1 code
don t need add VAR_2 METHOD_2 ( ) ( line ) virtue adding 0 1 encoding dimension information perfectly
don t need loop more call remove line 716 remove entry exists doesn t exist changes map result a _CODE_ written modifying loop iterating
kind missing a return
throw exception created args constructor
remove public
VAR_4 field
I behaviour replace
mutation
fair enough bad
return VAR_1 = = null || VAR_1 METHOD_2 ( )
s a good question I don t answer pattern commonly gwt widgets remove more ctor I case prune isn t
missing spaces format
returning TYPE_1 instead void ? I haven t
cases null VAR_1 ELEMENT case reporting _CODE_ instead / I simply create object null return null
need rework PR i a log instead throwing ISE
! [ MINOR ] ( severity : MINOR ) remove METHOD_3 ; deprecated [ ! [ rule ] ( ) ] ( )
method ? I understand
I don t works TYPE_6 doesn t extend interface ( e g sensor )
constructor moved package - scope able insert mocked TYPE_1 test - cases - - spy VAR_2 - calls _CODE_ _CODE_ ( ) instead _CODE_
speaking access modifiers package private called constructing key graph
java util Optional instead TYPE_1 TYPE_1 type results * * states : visible forbidden - existant deleted user present
constructor deprecated
iterator loop
please respect surrounding code style ( ( ) { )
I expect _CODE_ VAR_1 return - null case a unit
protected ( )
I d METHOD_3 ( TYPE_3 equals ( channel ( ) key ) ) { null checking TYPE_3 METHOD_2 useful a function required ( e g stream filter ) add extra method call jit decide inline ( compared obj ! = null )
lambda
inconsistent
private
check buffer null
condition I index < VAR_1 length
close ( ) ;
need check offset + length < = VAR_2 length
method check VAR_3 ? _CODE_ ( ) a method
explicit call _CODE_ necessary string#format invoked a primitive boolean
_CODE_
sense convert return METHOD_2 a boolean
please _CODE_ ( STRING_2 VAR_1 getValue ( ) ) ; version raise a _CODE_ failure case I consider TYPE_5 VAR_3 a bad idea - illusion object fact null want version needs : _CODE_ ( STRING_2 VAR_1 METHOD_4 ( ) = = TYPE_5 VAR_3 ) ;
please don t TYPE_2 VAR_3 - case TYPE_2 VAR_3 a type access level access level registry I 0 I invent a constant
artifact debugging I surprised I output place please remove
don t suppress warning need allocate _new String [ ] _ - _CODE_ List < String > METHOD_1 ( ) { return Arrays asList ( field1 field2 ) ; }
s generics java 1 5 +
declaring a METHOD_3 takes pointer work ? s JNA marshal appropriately I declare another version METHOD_3 takes a pointer wrapping TYPE_7
defaults aon windows I drop other - related instances
please convert tests assertions simply printing output general unit tests produce output assertions recommended message form assertion e g / / prefer _CODE_ ( number matches greater zero matches > 0 ) ; / / _CODE_ ( matches > 0 ) ;
extra space result
stick existing coding style omit Assert prefix
❗ correct
TYPE_3 s ctor calls _CODE_ ( ) METHOD_4 additional functionality providing ? i e ST4 wrong ? shoulda fixed ST4 : )
bulb : t getType ( ) replaced VAR_1 efficiency
bulb : considering ArrayList omits check I s safe
I condition sense update code match surrounding formatting ( hard tabs braces )
I more consistent other set methods mutating methods return instance generally chained calls ( StringBuilder append ) atomic updates ( _CODE_ _CODE_ ) apply
version check easier a method target class especially considering target implementation responsible loading template files
VAR_1 method
I suggest simplifying code method : ( METHOD_2 ( ) ) { return true ; } ( METHOD_3 ( ) ) { / / check a publish build info task _CODE_ < ? extends TYPE_2 > VAR_3 = VAR_1 METHOD_4 ( ) METHOD_5 ( ) ; ( TYPE_3 METHOD_6 ( VAR_3 ) ) { METHOD_7 ( ) ; return true ; } } return false ;
initialise instance declared
redundant parentheses ( config ! = null ) method identical _CODE_ method I suggest reusing code
need save a variable call METHOD_2
extra semicolon ? refactor code absolutely required
condition combined
move brace line function
remove unwanted log logical
unify conditions method clearer return true false
doesn t correct exception a TYPE_1 ignoring subclasses ( s more frequently )
static import
braces line blocks
lazy ? eventually called build called
a supplier creating instance create default supplier
_CODE_ ( 4 )
static import TYPE_5 METHOD_2 TYPE_6 METHOD_3
set true field declaration
_CODE_
move a method
check avoided polymorphism
delegate
I necessary happen autoamtically pipeline verify s case remove
inline
static import
static import
static import
create issue add a TODO review situation other components ( scatter - gather pop mind )
METHOD_5 elegant throw _CODE_ instead METHOD_4
isn t contradictory line
inline
static import
a WARN
remove
remove
set need add
static import
static importa
! [ code smell ] ( code smell ) code smell : remove unused VAR_1 local variable ( [ squid : S1481 ] ( ) ) [ _CODE_ ] ( ) [ ISSUE_KEY ] : _CODE_
please reuse function wrote
I easier / harder read pulling VAR_6 e g java&& ( VAR_6 || ( ! TYPE_2 METHOD_5 ( VAR_2 VAR_5 ) && ! TYPE_2 METHOD_5 ( VAR_1 VAR_5 ) ) )
TYPE_3 class
javaboolean result = false ; final TYPE_1 parent = VAR_1 METHOD_2 ( ) ; ( parent getType ( ) = = TYPE_2 LITERAL_CASE|| parent getType ( ) = = TYPE_2 VAR_4 ) { result = true ; } return result ; - - - - > javafinal TYPE_1 parent = VAR_1 METHOD_2 ( ) ; return parent getType ( ) = = TYPE_2 LITERAL_CASE|| parent getType ( ) = = TYPE_2 VAR_4 ;
expect new violations explain appeared deleted package class
please simplify boolean expressions VAR_7 VAR_9 VAR_2 VAR_5 initialization
@Override annotations needed test inputs
isn t a loop other method
inputs 2 more unique please add a parenthesis lambda parameter /
public
check instance TYPE_2 a cast TYPE_3 shouldn t class
please generate regression report _CODE_ = true VAR_6 = false
violation reported array item instead VAR_2
rename result fix spelling failure
please move line
please remove assert util method some job
VAR_1 METHOD_2 ( ) ; VAR_2 METHOD_2 ( ) ; lines duplicated times extract some method annotation
I check VAR_1 isEmpty ( ) other tests a family
please boolean VAR_1 = true ; test VAR_2 ! = null
code cleaner _CODE_ node = VAR_1 ; { node = node VAR_2 ( ) ; } ( node VAR_2 ( ) ! = null ) ;
VAR_1 = METHOD_2 ( event ) && METHOD_4 ( event ) ( METHOD_3 ( event ) || METHOD_5 ( event ) ) ;
bereturn VAR_2 ! = null&& VAR_2 getType ( ) = = TYPE_2 SLIST&& VAR_2 METHOD_3 ( ) getType ( ) ! = TYPE_2 VAR_4 ;
longer - ordered I assume resolved
reasons shouldn t default
create filter - accept called file unnecessary slowdown recreate instance please remove METHOD_2 move code _CODE_ assign a field
issue checking extends implements don t 2 lines more ? I content issue Class issue title doesn t agree _CODE_ extend defined class names
please order checks alphabetically
check null required pass null _CODE_
public ? instantiate class class public constructor public
please line term VAR_2 block lines
please refactor code a bit more : { String line = VAR_2 METHOD_2 ( ) ; ( line ! = null ) { VAR_3 add ( line ) ; } } ( line ! = null )
empty default mention
return type boolean return TYPE_2 METHOD_5
need synchonized
I set TYPE_2 application
tool methods static
add ? suggestionthrow new IllegalStateException ( e getMessage ( ) e ) ;
METHOD_2 ( ) METHOD_5 ( ) true time ? I move METHOD_5 ( ) condition check
wrong
TYPE_1 fullfills more purposes driver listing UI wouldn t more sense hide file based drivers UI
note enum returns toString ( ) treated a simple
sense propagate exception instead silently ignoring return information checked a caller result METHOD_1 correct internal error
write itreturn VAR_1 length > 1 && VAR_2 length = = 1 && VAR_2 [ 0 ] instanceof TYPE_1 ;
Optional : written a more compact : Map < String String > map = new HashMap < > ( ) ;
Optional more compact VAR_3 = new HashMap < > ( ) ; BTW creating attribute instead constructor
STRING_3 + TYPE_3 VAR_6 s 2 spaces
deregister
reducing code calling METHOD_3 instead
t reuse server instance collected _CODE_ ( )
doesn t belong don t a generic concatenation method foundation [ StringUtils join commons - lang ] ( ) [ joiner guava ] ( )
constants values a method return recompiled pick a change
initialize list size VAR_1 length
VAR_1 [ 0 ] = = null considered
protected method _CODE_ friendly
system please - tracing
more unnecesaary println
a bad merge assigning VAR_2 included
simplified : return VAR_1 ! = null
separate line
statement needed ? set null
FYI METHOD_3 ( ) generally needed need access VAR_2 a - VAR_2 context returns instance VAR_2 hood
field VAR_2 exist TYPE_4
shouldn t necessary fragment VAR_2 activity
need anylonger
i change log level warn ( info ) ( error reserved severe issues affect application health other hand a normal operation handling invalid user input - info sounds a fit imho )
farooq differentiate TYPE_3 initiated _CODE_ initiated timer idea implementation I sounds feasible investigate
considering actor state concurrency solved actor model intention TYPE_1 ?
required a new implementation _CODE_
VAR_4 = ( VAR_2 METHOD_2 ( ) ! = null ) ? true : false ;
please remove System calls
change overloaded variable VAR_1
quicker / else / else
locking buy ? locking add queue I matter
shouldn t method static ? ordinary utility function reasons manage a singleton instance class spring
don t need change decide want needs a separate commit
package private instead
needs package visible
context VAR_1 ( ) return null
return s ? method void applies
reason aren t initializing declaration time
initialize ArrayList VAR_2 instead calling addAll ? initializing result potentially array resizing
needs protected Exception needs public
needs protected TYPE_1 needs public
expectation built bugsnag _CODE_ remove public package protected enforce API usage easier maintain refactor future
change ? minimally depend table transactional ? call a - transactional table
fail METHOD_1 ( ) time size ( concurrent policies ) hit max 10 policies failover hit max criteria sink broken METHOD_1 ( ) fail required metric controlled failover
need methods public
case throwing exception a testcase : s throw plain Exception -
private
return VAR_2 exists ( new Path ( VAR_1 TYPE_3 VAR_5 ) ) ;
need change
isn t a need _CODE_ check _CODE_ ( observed ) reset clock bit
question : scenario lead a null VAR_1
enclosing ( ) file needed
need check
VAR_5 empty
null ? internally default hive _CODE_ ( ) ? safe column stats case
storing client instead returning ( consistent _CODE_ )
current time default time essentially values valid time window aggregate zeros wouldn t sense initialize zero mark entries window initially
concurrent closure statement
need change ? I don t constructor class
need check view type table VAR_3 ( ) suffice
required public ? exposing metastore client streaming connection API risky clients mess
some file systems path case sensitive
instead path separator create new path generic
access private close methods merge method
loop execute condition >
StringUtils VAR_5 lowercase necessary issue present _CODE_ ( introduced patch )
check blank string StringUtils isEmpty ( )
initialise METHOD_1 ( VAR_4 ) instead 2 statements
meaningful key ? error condition mask issues
constraint files listing 0th db done hasNext avoid duplicate code
noticed exceptions thrown method making changes code thought changes don t want changes part path s fine
shouldn t throwing exception
shutdown hook added part METHOD_1 method close clean create a separate function adding shutdown hook
I LOG warn more suited message don t expect happen
( minor suggestion ) I func _CODE_ combined more clear : private static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 List < String > _CODE_ String _CODE_ ) { } return null group fields included
switch ( type )
bad alignment
weird need METHOD_1 TYPE_4 ? move implementation _CODE_ translator remove TYPE_4
other nodes constructors call specific constructor avoid constructor spaghetti - call null example
im confused works VAR_1 METHOD_5 ( ) returns a list ? a list equal 1 ? shouldnt : VAR_1 METHOD_5 size ( )
yeah I thought subtle capitalization change misunderstanding ; - ) I s more expressive VAR_2 VAR_1 direct boolean Boolean argue subtle caps
Arrays asList prevents a stream / collect
hmmm messages a overkill
good change static configuration a test
wow
done other method
huh ? point a cast isn t necessary
empty I guess
other categories ( VAR_4 instead TYPE_2 TYPE_1 VAR_4 ) a space = =
replace StringBuilder
intellij tells public necessary
Arrays asList ( VAR_2 ) ? asList ( VAR_2 ) Arrays asList a static import
line more evident
A missing semicolon [ project fail compile ] ( )
change needed
suggestionbean METHOD_5 ( new ArrayList < > ( ) ) ;
remove log line call METHOD_1 instead a lambda avoid duplicate code
client - id undefined return immediately service registry
suggestion } LOGGER trace ( STRING_2 ) ; return VAR_2 METHOD_2 ( VAR_4 VAR_3 VAR_5 METHOD_4 ( ) ) ;
condition unnecessary event _CODE_ ( ) calls expensive
( ) throws Exception
val var
val
fine else clause redundant
belong ? I a home configures mfa VAR_1 general VAR_1 defn _pure_ interject a feature
don catch exception fail return
dont catch fail
technically I methods info access variables
normalize ( new TYPE_1 ( VAR_7 ) )
need protected concurrent accesses
protected concurrent accesses
concurrency issue
String valueOf
cast string removed
remove
needed
I unsure returning a live stream returning a closed stream
equals
i remember correctly METHOD_2 set case _CODE_ need anymore
isn t * * oga * *
CORS activated throws a NPE I recommend add assertNotNull statement
CORS activated throws a NPE I recommend add assertNotNull statement
macro a specific syntax s safer METHOD_2 ( ) getId ( ) getId ( )
written a single line : return parameters VAR_1 ( VAR_2 ) ! = null &&METADATA_CONTAINER_CLASS equals ( parameters VAR_1 ( VAR_2 ) getValue ( ) ) ;
default type String VAR_2 I
TYPE_1 designed extended replace ( ! ( object instanceof TYPE_1 ) ) I move ( object = = )
line long
need parenthesis ( produce a sonar issue )
javaif ( ! context VAR_1 ( ) METHOD_2 ( ) ) return context VAR_2 ( ) METHOD_1 ( context ) ; ( TYPE_2 class METHOD_3 ( context VAR_1 ( ) ) ) return new TYPE_3 < Object Object > ( ) ; return new HashMap < Object Object > ( ) ; reduce deeply nested statement prefer curly braces statement / else coding stye
coding style : { } catch ( TYPE_1 e ) { / / don t mind attempt class loader|
include
a clients change behavior VAR_3 null
idea defaulting true
shouldn t a StringBuilder
return empty string instead null others code pushing null pointer higher thoughts
hrmmm ? ! VAR_1 null a binary protocol
recommend checking VAR_2 instance _CODE_ warp
changing visibility caching
list applied building : _CODE_ build ( List < Class < ? > > VAR_1 ) additional VAR_1 loaded demand
ll notice other feign code infrequently private access modifiers bloat bytecode sharing packages isn t supported feign feel strongly hiding making type private default modifiers ctor symbols accomplishes
static
package private
build ( )
I d call new Response ( )
I d initialize builder METHOD_3 METHOD_4 clear some c&p
adding array support
VAR_2 mutating don t need save
hide expose factory method
please scrub printlns
minor : a method predicates _CODE_ ( ) exposes set I purpose mimic ranges _CODE_ ( range ) a static method allow ranges objects aren t comparable _CODE_ method a guava range requires a comparable type I m fine changing method more straight - I d predicates _CODE_ ( ) _CODE_ ( )
I m I m clear METHOD_2 generally a _CODE_ _CODE_ preserve order aren t I a bug fixed _CODE_ normalized needed avoid annoyance I s case I wanted
I don t changed implementation generally preserve order normalized produce a String normalization a peer toString ( schema ) _CODE_ ( schema )
s call super METHOD_1 ( )
work changes ? concatenate : javareturn new TYPE_1 ( VAR_3 ? VAR_4 : VAR_5 + STRING_1 + VAR_2 METHOD_1 ( options ) toString ( ) ) ;
TYPE_1 mutable safer return a new instance global mutable state a recipe hard - - diagnose bugs
VAR_1
instanceof TYPE_2 redundant - - a single instanceof _CODE_ check
TYPE_5 METHOD_3 deprecated guava 14 avoid call TYPE_5 close ( reader false ) IOException swallowed declare test method throw IOException fail test condition
allowing null null passed add a precondition check
_CODE_ instead TYPE_7 s unique easy debug
NPE I mistaken - - VAR_2
instantiating view I pass [ TYPE_4 constructor ] ( ) number places views instantiated a minimum want push late example support _CODE_ push job committed
reason needed catch Exception ? ( s added a cases - e g _CODE_ doesn t catch RuntimeException ) need a _CODE_ kite
please call new constructor passing dafault _CODE_ want clear
ABSOLUTE SHOW STOPPER
I return true fall return false instead creating a variable
I don t throwing exception based calling method I log a warning information calling method handle based return false
wouldn t method more reliable case some spacing beginning line
rely target server xml I able rely target VAR_1 directory I switch target don t need
replace 147 - 149 _CODE_ ( VAR_1 METHOD_3 key ) ;
need a member variable ? a static method a local variable _CODE_ ( )
reason 12%
check VAR_5 null calling VAR_5 METHOD_4 ( ) prevent potential _CODE_
realized change branch changed model a previous PR callback GPS fix branch rebased develop advantage new structure wait merge other PR scripting amazon classes debasing done step
s change ! METHOD_2 ( )
brackets statement else clause
VAR_3 METHOD_3 ( n ) picks a VAR_3 integer 0 ( inclusive ) n ( exclusive ) need a - 1 list length means VAR_3 METHOD_3 ( TYPE_3 length ) work fine
I d catch Exception
shouldn t block
force refreshes
need fixed I ll today TYPE_1 TYPE_4 a builder a new release today
explicitly mark run UI thread ? method called main thread
adding bind ( String VAR_1 String VAR_2 List < TYPE_2 > VAR_3 TYPE_3 < String String > props ) method
return empty Map callers need check
code style private constructor + static factory method
main question I reading _every_ string written remote charset ? nicer a property TYPE_5 converting call METHOD_4
need case default UTF_8
list initialized check unnecessary
immediately return target simplifying method code
s else method other synchronized block don t need local variable replace assignments VAR_1 return statements
class shouldn t a dependency specific implementation details handled existing _CODE_ I m s tread - safe generally good allow caller s thread access modify channel object ( s a barrier thread executor queue )
_CODE_ = METHOD_2 ( VAR_2 ) ; I don t cast necessary
suggestionif ( VAR_2 ! = null ) {
s exposed channel_name auth endpoint handlers example :
need - map accesses critical section ? some locks
I a short circuit exit top clearer wrapping entire effective body method log error level expected circumstances
TYPE_4 class redundant ( ( TYPE_3 ) VAR_1 METHOD_4 ( ) [ 0 ] ) run ( ) ; trick stick proper OO patterns create a _CODE_ takes lock object a constructor arg return a dummy type insist
synchronized block needs include read map : - Thread 1 reads VAR_3 null - Thread 2 reads VAR_3 null - Thread 1 enters critical section creates new HashSet listener 1 stores VAR_3 - Thread 2 enters critical section creates new HashSet listener 2 stores _CODE_ 1 lost
channels removed list ? leak memory
throw counts a failure / error
variable instead variable
convert a chapter id a chapter more performant
save game state I remove want store firebase
cache size loop ? ( int i = 0 size = VAR_1 METHOD_3 ( ) ; i < = size ; i + + )
I realized network call _CODE_ event detail page network request
m prefix a field don t
VAR_2 null doesn t VAR_3 effectively true
consider returning a File a String ? result context a file cleaner File point
sounds expected obtained values swapped
I don t understand
call other signature null credentials
oops : )
call METHOD_2 ( buffer ) remove signature METHOD_2 I don t
I new method private internal helper s I understand s clear need introduce _CODE_
I don t static ( sort issues including testing sets some states )
I m cast I write : _CODE_ VAR_8 = new TYPE_3 ( VAR_2 ) ;
I change a bit logic call TYPE_1 METHOD_1 check return null return String case
I put line previous instruction #xtree WDYT
I don t a fallback
s clear source target
feature _CODE_ arleady adding VAR_1 instead : )
method a duplicate #set ( ) reuse instead
compare x null a attachment map
don t equals VAR_1 instances
don t equals attachment instances
need pass a new new ArrayList METHOD_3 ( ) values ( ) a List call decorated ( ) crash
quick I doubt builds : ) a term performance Iterator call iterator#remove ( ) instead making search entry Map
I assertTrue VAR_1 isEmpty ( ) instead s want ( s equals some list )
I mixed other pull request a catch put
part ( METHOD_2 ( ) ! = null ) {
missing a annotations
build
means list change VAR_2 impact VAR_1 VAR_2
means create a listener listener match : ( ( TYPE_1 ) o ) METHOD_3 ( ) equals ( event ) ) I
change visibility _CODE_ a public class removing a method API build - pquality error
throw a _CODE_ TYPE_3 caught need choose - falling a default property type case TYPE_3 - TYPE_3 _CODE_ general main reasons catch exception : - provide a fall - throw a more domain - specific exception wraps caught exception
information : assertEquals ( 4 i )
API methods supposed simple wrappers protected classes s API method calls a method ( METHOD_1 doesn t call equivalent METHOD_1 METHOD_3 )
remove TYPE_2
add final
test start number null zero please create a test null
please add
remove TYPE_3
remove TYPE_3
avoid conversion sending uppercase constants response
simplify implementation s done TS
I DEBUG
I don t sense recover exception log fail sensor ( i e skip analysis )
! [ code smell ] ( code smell ) code smell : METHOD_1 a static method ( [ squid : S2325 ] ( ) ) [ _CODE_ ] ( ) [ ISSUE_KEY ] : awylrx4p0ts69roinji_
access private
elena
elena follow suggestion file uri ( ) ll update
need more tests s model METHOD_1 parameter clause
parameters nullable simplify method
I check a null VAR_1 return false passing VAR_8 method a nullable
minor : another possibility move tests _CODE_
return STRING_1 equals ( )
ss don t want deal IOException analyzers simply wrapping a subclass RuntimeException ? simplify a bit pull request
ss change METHOD_5 method defined class return a TYPE_6
I don t style : I a continue
remove check METHOD_2 return _CODE_
! [ MINOR ] ( ) replace - - else statement a single return statement [ ! [ rule ] ( ) ] ( )
don t else ? else reading implementation methods _CODE_ / _CODE_ cases covered hit 2 cases advantage : methods _CODE_ / _CODE_ removed
elena else clearer ( a picosecond faster )
elena constructor call
remove call super
elena copy - paste issue
VAR_2
elena good question : ? reach code
! [ MAJOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
METHOD_1 switch
minor : instantiate field declaration level cleared calling storage clear ( ) WDYT
null check required [ _CODE_ ( ) ] ( ) nullable null
compatible java 7 a resource
implement METHOD_1 scale
static Double _CODE_
sense VAR_8 ? tiles longer downloaded point add overhead run parallel
I sonar flag { } block tricky read logic coming a date
need check ? _CODE_ : _CODE_ method exception thrown directory created exists doesn t exist create move
personally I d prefer a couple asterisks want stick jarring code
I thought changing METHOD_1 put a big change current change doesn t break existing behavior good / safe nitpicking : a - else more straightforward
need ? I _CODE_ ( ) called activity restored settings reloaded I remove logic METHOD_1 ( ) _CODE_ ( ) ? I missing
dont a setter type function return
create a setter height changed
wrong
spaces brackets removed
hmm a weird default positive 0
unnecessary final
control drawing debug lines ? conditioned a global variable sets editor debug ( pass command line argument )
frames shouldn t null VAR_1
don t check VAR_1 METHOD_3 ( ) VAR_4 METHOD_4 ( ) METHOD_5 ( ) null I assume methods return null consistent VAR_3 METHOD_6 ( VAR_2 ) return null
needed
don t need VAR_2 METHOD_1 update method action ( method ) returns true action done action needs update execute ( case ) return true ( happen happened initialize )
single line
api v4 deprecate api v3
_CODE_ class I m missing initialization _CODE_ column
I love + 1 guarantee a letter visible a reason asterisks id VAR_5 length ? I find confusing VAR_1 test@example org te * * * * * * le org te * * * * * * * * le org
don t clear ( set null ) sets migration means time ll reopen IDE migration happen override values added user VAR_2 map
synchronize tasks ( server issue tracking local analysis completes ) share a _CODE_
! [ MAJOR ] ( ) line start column 7 [ ! [ rule ] ( ) ] ( )
String valueOf ( VAR_2 ) more straightforward
attempt create TYPE_3 VAR_1 VAR_2 provided
confused change signature keeping field Boolean _CODE_ boolean methods a null check body
consider leave constructor add new
suggestion a move change insto single class executed JSON created instead fix places invoked times report creation
I prefer compile time checking runtime _CODE_ class getName ( ) work
needed copy
可以简化一下，直接return System currentTimeMillis ( ) < VAR_1
key null check nullness key throw a _CODE_ A ( Constants VAR_2 equals ( key ) ) similarly reduce memory mb
StringUtils isEmpty ( VAR_2 ) instead VAR_2 = = null
minor : appears TYPE_3 singleton
I _CODE_ error ( log message VAR_4 ) ; 2 lines
constructor version : TYPE_3 ( String Throwable ) lose stack trace underlying IOException
_CODE_ reason method public I suppose call method
avoid duplicate code ( magically cover more lines tests ) - routing constructor 4 parameters
instead string + string pass message object getMessage method format operation format string %s sessionid [ %s ] userid [ %s ] requestid [ %s ] dont intend a - space padding - space padding 3 space padding format string
VAR_6 + +
put 2 a finally block don t acquire throw exception a runtime exception similarly other tests
chain likejavareturn ImmutableList < String > builder ( ) addAll ( VAR_1 ) addAll ( VAR_2 ) addAll ( VAR_3 ) build ( ) ;
VAR_1
yep revert I check works github
easier reason raised exception return null
path required
debug artefact
case zero
mind changing type Map < String Object >
explain contract a docstring ? arrays lengths equal content length smaller array
rename function _CODE_ function ? ( = METHOD_1 )
full path longer needed
charset
result a bad merge
I _CODE_ s share a single _CODE_ owned kiji instead shut isn t a clear explanation
new TYPE_3 ( ) lose stacktrace
getClass ( ) equals ( obj getClass ( ) ) ? : contract equals check obj null avoid NPE
method enforces TYPE_4 binding inject custom instance injecting custom implementation results duplicate binding exception
local var useless remove
statement necessary loop handle negative case
I personally prefer final
#1294 ( currently targeted 4 13 ) proposing updating class collect assumption VAR_1 counts I change
VAR_1 remove ( Integer valueOf ( 3 ) ) ;
I personally prefer existing error conditions early avoid - intentation : ( VAR_1 = = null ) { return false ; } { } catch ( Throwable e ) { return false ; }
I conform s suggestion I expect _CODE_ ( _CODE_ ) _CODE_ ( _CODE_ null ) behave
s final
Exception instead Throwable ( )
please add a cast Object [ ]
s put call a method named _CODE_ ( )
please put line block
t change signature published methods
shouldn t public ? need getter methods ( I don t ) put setter methods
method boils tojavareturn VAR_1 = = null || METHOD_2 ( VAR_1 ) ; orjavaif ( VAR_1 = = null ) return true ; return METHOD_2 ( VAR_1 ) ;
please add a static import METHOD_4
subclassing builder want subclass builder s protected
closer I : ( ! VAR_3 && ( instanceof Throwable ) ) { lead METHOD_1 ( ) called constructor a slight change behavior I wouldn t expect throw _CODE_ a : _CODE_ ( e _CODE_ ( woops ) ) ; _edit : _ A simpler solution call METHOD_1 ( ) TYPE_2 ( String VAR_2 Throwable e ) I didn t ; class complicated
VAR_2 null
please remove IllegalArgumentException throws clause
making changes code junit framework
change : return new TYPE_1 ( ) ; ( effective java 2nd edition )
changing code toif ( ! METHOD_2 ( VAR_4 VAR_1 VAR_2 ) ) { METHOD_3 ( VAR_4 VAR_3 ) ; }
note moving soon a builder TYPE_1 objects builder provide a test method test class independently description ( i e wouldn t a regex parse ) types test allow verify bug doesn t thanks
useless line executed VAR_2 null a _CODE_ thrown line
I personally prefer methods external API public outer class call private methods _CODE_ show public methods differently filter - public methods browsing
a I _personally_ prefer inverting statement : ( VAR_1 length ( ) < = VAR_2 ) { return VAR_1 ; } 1 ) simplest part code care front 2 ) indented line short line long line
return VAR_1 isEmpty ( )
IMHO variable naming local consistency arguably more important global consistency naming e a global change I prefer rename variables type Throwable e
isn t optimization ; Double valueOf ( double d ) calls new Double ( d ) s remove change class deprecated I want minimize changes
isn t optimization ; TYPE_1 valueOf ( float f ) calls new TYPE_1 ( f )
don t want pass VAR_1 instead VAR_2 ? passing outermost class doesn t solve #816
simplified TYPE_1 _CODE_ s worth
need some error handling
_CODE_ style braces statements
VAR_2 null toString ( ) include null intentional ? want allow class a null VAR_2 ( empty string )
VAR_2 t null simpler
space please change ( ! METHOD_3 ( child ) )
I strongly prefer : METHOD_2 ( message Long valueOf ( VAR_2 ) ) a lot methods class s clear reading line autoboxing happening I knowing autoboxing happening increases readability more clear check
similarly Double valueOf ( VAR_2 )
s returns a local
issue static
returned Map unmodifiable values modifiable lists please change : public List < TYPE_2 > _CODE_ ( Class < ? extends TYPE_1 > annotation ) { return Collections _CODE_ ( VAR_2 ( annotation ) ) ; } ( I prefer values VAR_2 unmodifiable lists )
put line call VAR_3 put ( TYPE_6 class null )
put line call VAR_4 add ( null )
please a static import assertEquals
I m missing METHOD_1 ( class ) = = _CODE_ ( class ) ( a test starts finishes starts ) method ( named _CODE_ )
pass e message
I I d explicitly pass a default construction TYPE_4
change VAR_3 vector passed please don t simplejavathis ( VAR_2 VAR_3 ) ; ( VAR_4 ) { VAR_3 METHOD_1 ( ) ; } suffice _CODE_
listener null i issue i tested music playback
change line 188 final boolean [ ] VAR_1 = { false } ; VAR_1 set line 194 VAR_1 [ 0 ] = true ; return VAR_1 [ 0 ] ; pattern similar situations leads allocation MOE smart enough optimize - METHOD_1 a slow operation doesn t matter
nitpick : wouldn t VAR_3 = - VAR_3 clearer ? ( check necessary ? )
change needed ( unwanted ) please undo
change builder VAR_2 ( attributes ) ; builder part ( id primitive renderable _CODE_ ) ; _CODE_ update VAR_3 part remove code ( ) method including need call update ( )
calling a protected method constructor base class a good idea ; )
calling iterator method resets need methods
bit strange time a font cache created
API change allowed
intend public
VAR_1 ( ) returns true METHOD_1 ( ) a noop ( * private * property VAR_1 removed )
es gibt ein isEmpty ( )
work : - - json false - - json falseetc I args add ( STRING_5 ) removing STRING_5 line 82 work
^ method longer throws IOException
set false declaration
specifically build - info project avoid guava due potential compatibility issues ( elaborate more )
reason need a constructor VAR_3 / VAR_4 access token ? reflected other constructors code
question - wouldn t a simple assignment sufficient ? - VAR_2 = VAR_2 ; need a clone TYPE_1 ? constructor TYPE_1 accepts another TYPE_1 redundant question * VAR_3 * * VAR_4 * method - aggregating VAR_3 VAR_4 ( addAll ) a time assignment
I letting method throw exception
I nicer VAR_2 extraction implicit i e magically call METHOD_5 need manually extract VAR_2 a call TYPE_1 VAR_3 simpler users remove a method public API require a reworking METHOD_3 implementation I find sequence a bit clunky unnecessary : String [ ] VAR_2 = parser VAR_3 ( VAR_1 ) ; METHOD_4 ( VAR_2 ) METHOD_3 able figure columns parser
remove unused variable declaration annotation needed
rows starting #
throw TYPE_4
don t need explicitly declare TYPE_4 RuntimeException
shouldn t a negation
TYPE_2 fully thread safe a single static variable transformer class ( configure differently method usage )
_CODE_ format
necessary convert String
necessary convert String
necessary convert String
Object VAR_1 null skip part VAR_1 null
skip part instanceof String
I empty VAR_1 t set perun needed
missing reference VAR_2 holder
_CODE_ return VAR_1 immediately
currently don t VAR_4 role assignable config specific credentials ( perun admin ) user related role check VAR_3 ( user passed user ) VAR_4 pass filter result separate - kuba ? need VAR_4 role accounts user perun ? I suppose safer account contact info
change shouldn t a part pull - request related _CODE_ purpose debugging
nagios restrictions probe broken
generate message process done prevent unexpected issues
I change return Utils _CODE_
return Utils _CODE_
setters Long param check null TYPE_1 METHOD_2 ( ) fail _CODE_ safely set null base object instead
cover case passed null candidate params _CODE_ / _CODE_ null empty
please info level
line code useless
warning
true
similar urn_perun_group_attribute_def_def_unixgid_namespace _CODE_ output : / / disallowed crosschecks modules peformance reason / / VAR_1 add ( TYPE_1 + STRING_1 ) ; / / VAR_1 add ( TYPE_2 + STRING_1 ) ; / / VAR_1 add ( a_r_unixgroupname_namespace + STRING_1 ) ;
please fix METHOD_2 ( sess ) implementation s 1 : 1 replacement removed code
don t check null objects business logic layer reason
please remove TYPE_9 _CODE_ member - resource group - resource VAR_2 modules ( api abstract ) passed entities mismatch s programmers fault want exceptions outer api ( api Entry s bl / _CODE_ ) please catch exceptions modules implementation wrap TYPE_5 result lowering exceptions usages normal methods _CODE_ normal managers
susceptible race condition
redmine 2630
variable VAR_2 null ( line 24 ) matcher match
TYPE_8 compiled please move method
1 row cyclus i prefer { } reading
please add VAR_3 holder exception parameters
covered line 524 isn t
ve added _CODE_ ( ) remove null check shouldn t null
a dead store variable
Logger please
logging statement warn
long instead Long
add more details log line
lets move _CODE_ ( ) method exceptions happen component start
disabled default
reformat code changes diff harder review revert formatting ? soon checkstyle happy
catching Exception time call METHOD_2 don t catch error METHOD_2 leave previous signature ? catch ( Exception ) a code smell need
I fine approach
isn t a behavior change
VAR_3 final possibility VAR_3 null methods called correct order add final modifier VAR_3 field
unrelated note current method definitionjavapublic static void close ( Logger log java io closeable closeables ) { java create new Object [ ] single closeable passed method ll benefit a variant takes parameter method more closeable
synchronized line 261 need
I logging doesn t belong method initialize method
problem
existing code construct hashmap VAR_2 line code reason split 2 lines
public private
reason TYPE_2 close called instead VAR_2 METHOD_2 ( ) close ( )
thanks calling issue address : )
shouldn t pass size list ? METHOD_2 assumes add 1 item I _CODE_ ( VAR_1 size ( ) )
close VAR_4
good object mutable whitebox tests
I default - 1 util benchmarks show INT_1 general good applications
default 0 default feature enabled
rethrow log
extreme situation happen s happen ignore
static
TYPE_5 VAR_9 plain _CODE_ I constructor other constructorthis ( conf TYPE_5 VAR_9 VAR_2 new TYPE_3 ( ) ) ;
put ( expected = IllegalArgumentException class ) checks
private
VAR_2 values ( ) forEach
remove protected method package private test class package
give a meaningful 0
simplified withreturn METHOD_1 ( ) ;
VAR_1 forEach ( TYPE_1 : : close ( ) ) ; VAR_1 clear ( ) ; VAR_1 = null ;
case null ? null
remove TYPE_2
remove
static
remove
public
need separate advbuilder ? cannt assume / implement logic advbuilder ledger id provided
line doesn t give useful information debugging isn t
omit case VAR_1 default
( TYPE_1 ) { }
( TYPE_2 ) { }
need @Override
VAR_2 leak need _CODE_ ( _CODE_ ) set true create VAR_2
info
key set modified _CODE_ ( ) create a new set current VAR_4 s key set
type specific getters call instead METHOD_2 supposed fail object instead returning null
class ideally immutable I convenience add\ * methods computing sizes package private order reduce class public interface immutable part
a _CODE_ i - s rx observable subscribe refresh - place subscribe worst case some object subscribes active widget
move _CODE_
wanted put result = VAR_1 ;
method returns primitive long need boxing other method
I overiding METHOD_1 _CODE_ a approach I kind I implemented
assertEquals ( VAR_3 VAR_2 METHOD_3 ( ) iterator ( ) ( ) METHOD_4 ( ) ) trick ? assertThat ( VAR_2 METHOD_3 ( ) matchers ( VAR_4 ) ) ? ( don t equals ( ) VAR_4 currently checks require instantiate manually instead mocking )
nitpick single statement enough : return METHOD_1 ( VAR_1 path ) ! = null
result _CODE_ ( ) executing calculating storage path storage path I need pass logical path ( getPath ( ) output )
another place a variant METHOD_1 ( ) need event metadata eventually
VAR_3 ( VAR_2 )
VAR_3 ( VAR_2 )
IMO return removed TYPE_1 s similar Map semantics people don t need return discard
null check METHOD_1 ( String _CODE_ String ) move method call a null VAR_4
want return empty entry array
Log e throw a _CODE_ happen
else { }
enabled default ? thoughts
A curious compile errors sneaking commits
removed
fix problem ? I don t _CODE_ parameter changed related please explain
I move validation / modification code another constructor other hand remove exception throwing annotate constructor < code > ( _CODE_ class ) < / code >
descriptor null throw exception
god kills a kitty time a developer writes braces
VAR_1 = = TYPE_1 VAR_3 || needs removed ( math functions treated - deterministic )
please revert @Override permitted - source 5 ( - source 6 updated parent POM )
package - private protected implies expect called overridden subclasses case
need public ? please introduce new public members
useful print memory address - toString method implemented TYPE_1 class
create a field variable ( instantiate a method )
I forEach called stream map call
please remove line METHOD_1 place example test methods ? a side effect unrelated meaning METHOD_1 method - I expect check response setting some method variable
please change log level debug
TYPE_2 initializer set HashMap
copy constructor readability result
code needs compatible java 8 List ( ) brought java 9 please refactor code java 8 compatible
standard exception preferred time especially unchecked exceptions purpose input validation IllegalArgumentException typically
method return states - boolean suitable DRL rule method called penalize - 1 task accept assigned user
a specific reason initialization attributes constructor other constants
String pwd = file getProperty ( id ) create instance TYPE_1 return new TYPE_1 ( id pwd ) ? don t need iterate file time
overwrite HashMap ? I put a new case VAR_4 = = null return true return false a bigger performance impact store password empty String sufficient a
I noticed concatenate 2 properties need ? VAR_1 enough distinguish server controller keys
potential timing issues counter 0
nitpicking change - isn t antipattern
s purpose ? resume migrations done ( service receive result ) crashed ? optimistic I d assume kie server didn t finish service I d want automatic check migration finished successfully
good consistent _CODE_ return deleted entity a response
I assert precise size VAR_6 collection
shouldn t a warning log else branch actual code - METHOD_4 ( VAR_2 ( ) ) ;
want prevent a NPE creating a new Set case passed a null I a good idea declare Set VAR_2 final
need covert list list
redundant call super ( ) ; s automatically inserted compiler class child Object
page VAR_3 needed info set query context
I d loaded new instance class initialized a chance multiple loads performed multi threaded environment - e g kie servers connects pretty time
synchronized ? read map
case need METHOD_1
prevent creating another class debugging
cleaning other thread VAR_1 other key
please code else block TYPE_1 format _CODE_
delete
с методов инит возвращать результат плохой тон если уж он возвращает результат то по названию метода следует что он возвращает true если все поля инициализированы и false наоборот А как посмотришь в метод он вообще не понятно что за результат возвращает
как на счет записи в одну _CODE_ METHOD_2 ( ! VAR_1 ) ;
_CODE_ METHOD_3 ( ) toString ( ) уже возвращает стринг
так ты ж в _CODE_ сделал проверку на VAR_1 METHOD_2 ( )
если эти колбеки в активити вызывать через _CODE_ тут уже никаких хендлеров не нужно будет
зачем public
public
там есть _CODE_ во фрагменте и метод METHOD_3 без привязки к активити И вообще метод лучше вынести из контекста METHOD_3 А там где нужно вызывать метод вставить его в METHOD_3
этого здесь точно не должно быть метод init отвечает за инициализацию сессии и подписки на нее а не что - то другое во вторых никаких манипуляций с _CODE_ на TYPE_2 не должно быть мы ж это обсуждали
логику METHOD_1 нужно _CODE_ ее вообще не нужно трогать
у _CODE_ есть метод принимающий id строки
mapped TYPE_1 VAR_11
a reason short circuit ? I I m - picking I feel slower due extra complexity preventing JVM optimisations
able skip ( _CODE_ ) _CODE_ stores a null object skip TYPE_2 s switches
new File ( VAR_2 METHOD_1 ( ) STRING_1 )
swap branches drop repeated return
prefer ImmutableList other METHOD_1
move - catch METHOD_3
I prefer return type ( type VAR_2 ( ) ) instead repetitive
! input startsWith align parser
build immutable set copy
a static method
redundant cast done automatically IDE please check avoid
thank pointing sense skipped tests count comparison account ignores difference - s fine
reason public others protected
[ TIP ] I : ! [ output ] ( )
_CODE_ METHOD_1 - public API avoid defensive copies - public API s a - - day - public - API avoid performance surprises reduce code size note array defensively copied constraint instances s watertight method part a public API I d argue
code style : space (
need handle _CODE_ ? VAR_4 ( _CODE_ TYPE_2 ) method deal wether TYPE_2 a TYPE_1 ? I original code change fails test problem method delegating method
nitpick : return Integer VAR_3 ( VAR_2 VAR_1 METHOD_2 ( ) ) ;
duplicating constructor wrapping unmodifiable List call ? constructor ? s worth costs performance wise 2 proposals : proposal A ) : constructor : Collections VAR_1 ( new ArrayList < > ( VAR_2 ) ) proposal B : constructor : Collections VAR_1 ( VAR_2 ) I suspect DRL CS - B proposal B bugfree duplication cost proposal A a perf loss CS - D duplicate giving constructor
I prefer shorter method names important information argument type - case LGTM
ow dangerous need bluejeans discuss
switch store check
possibly throw assigning
suggestion : want avoid align method parameters / call arguments multiline dilemma format : javaprotected TYPE_3 ( long VAR_2 TYPE_1 VAR_3 TYPE_2 VAR_4 ) { / / body } compatible align multiline s part KIE java conventions geoffrey s IDE settings ignoring KIE java conventions regard : wink : I don t aligning I chose follow KIE conventions I rule checked I format rule applying
I debug line needs
a simple setter ( notice _CODE_ doesn t side effect ) _CODE_ set default similar sets 400 late acceptance
bug : running phase ( reproducible ) forget s settings remove 2 lines
unused parameter - consistent confusing
variable unused a bug useless code
getter return null s null config classes s important distinguish null ( = filled ) default ( s null ) example impacts programmatic API reading a solver config XML file note solver config files written XML ( benchmark report )
concatening strings + s needed toString ( ) result : return VAR_1 + STRING_1 + VAR_2 ; avoids a nullpointerexception example VAR_2 null ( case )
variable declared line 80 method
mind removing matches rest planner code style
properties access checkstyle concern
flipped I exchange expected actual assertEquals source code : smile :
DITO
revise please project vulnerability
simplified : int index = 0 ; ( Object o : VAR_1 ) { Assert assertEquals ( index + + o ) ; }
mistake div operator precedence
_CODE_ won t work - NPE statement need a synchronized block a double null check
spec s t public ctors : access factory methods
List < String > VAR_4 redundant wrap array String
good catch
s a variant TYPE_4 METHOD_1 takes a length argument : javapublic static void METHOD_1 ( final _CODE_ final int max final TYPE_2 ds final TYPE_3 callback ) : max won t read more bytes stream
debug
I log longer
longer needed
call supposed loop
VAR_1 default false
shouldn t TYPE_2 messages SHR another SHR condition _CODE_
shouln t variable a potential null pointer Exception
logging standard output
logging standard output
need remove
need remove
t a string object
a bit weird calling toString method
protected method a - class wouldn t
instance equality sense credentials API key
hm wondering feels a bit weird call _outside_ endpoint shouldn t instead _CODE_ source truth ( other PR )
happen VAR_2 > = 0
braces please
а возвращать Integer зачем ? int же
может тогда protected раз он такой internal
быть может это более уместно в самом METHOD_2 ? чтоб он не возвращал никогда нуллов
лучше new String [ 0 ] по перформансу лучше будет как - то кто - то ( коля кажется ) скидывал статью про это суть - new String [ VAR_1 size ( ) ] - создат и проинитит массив с дефолтными значениями потом METHOD_2 поверх запишет новых значений а new String [ 0 ] выполнится в момент с минимумом инициализации а METHOD_2 умеет создавать массив сразу с нужными значениями
a null check passed VAR_1 required safety
ternary
sticking Optional _CODE_ ( … ) pattern ? staying java s names Optional idioms more flexibility s a bit more familiar users
inline VAR_4
public visibility modifier required
stay private
static
assigned field
Optional empty ( )
I involve controller code fix puthtml < #assign _CODE_ = true / > top article ftl instead ? won t create inconsistency main article body tab other article pages ? currently implemented I journal title : journal slogan - article pages article title main body tab journal title : article title other article pages
yep I poked a ve serialized a doi object apparently start model classes don t doi wrapper route a global gson adapter serializes doi a primitive _CODE_ ( object ) _CODE_ d some wired
need set _CODE_
TYPE_1 METHOD_3 ( ) returns METHOD_3 field String METHOD_3 ( ) collision - resistant meaning a small chance ( astronomically small SHA - 1 ) cache key collide another parent VAR_2 TYPE_2 provides a a collision - resistant key strings I _CODE_ VAR_3 = STRING_1 + TYPE_2 METHOD_2 ( VAR_2 VAR_1 getName ( ) ) ;
based values ( ) instead class METHOD_2 ( ) I cleaner
don t need METHOD_1 TYPE_3 METHOD_2 checks null arguments
I m 100% clear spring method need guard VAR_2 VAR_4 overlapping elements ? ( matter check constructor )
instead altering method signatures more readable overloaded method signature accepts a singular VAR_2
similarly static enum I subjectively enum constructors explicitly private s practical difference rationale change
style - conscious TYPE_1 METHOD_1 good VAR_3 move Optional _CODE_ line change constructor argument Optional < Integer > Integer
conditional necessary a performance point view meaning clearer put ( ) call conditional
I find body more readable size asserted Collection ordered ( 0 ) operation deterministic length
public
canonical performing check String isEmpty ( ) check equality empty string note reversing comparison elide null check : ! ( equals ( string ) )
VAR_1 - empty doesn t a CHAR_1 character
|| instead duplicating size logic
didn t some problems shortcutting TYPE_2 VAR_3
I part TYPE_1 METHOD_2 resets TYPE_1 pre - initialized state IMO includes static variables ( reset _CODE_ _CODE_ )
I prefer other ordering < = = = s easier read n greater equal 0 0 equal n
a - cautious a reason a double - wrapped PM
return inverse conditional : return VAR_1 < VAR_2 size ( ) ;
semantic change ! want duplicates
catch kind exception thin - throwing exception
I don t reason catch exception throw
moved VAR_3 METHOD_3 ( )
throw exception : throw e add root exception newly created : throw new TYPE_2 ( blah - blah e )
shouldn t kind messages VAR_3 _CODE_ ( )
new TYPE_2 ( ) subject body random
check TC ? METHOD_3 methods
package private
_CODE_ ( Collection ) copy constructor reuses underlying array collection another _CODE_ copy - - write benefit
constructor
TYPE_2 a forEach IIRC
nitpick : I a ternary nice reads a lot a guard block s a binary decision
more lenient comparison window rid OS detection ? intending test system clock OS - specific behavior avoided
t import short reference
I cost lowercasing outweighs cost duplicate entries previously I d operated assumption users casing wrong tend consistently wrong - case d redundant entries aren t extra cache entries cheaper repeatedly lowercasing part reason adding cache place avoid case sensitive operations I worry a performance regression common case
prefer a private field a mutex prevent code able hold lock : javaprivate final Object mutex = new Object ( ) ; public _CODE_ METHOD_1 ( String key Object ) { synchronized ( mutex ) { VAR_1 put ( key ) ; } return ; }
ditto mutex
please TYPE_1 METHOD_1 ( Type Type ) instead wrapping METHOD_2 result avoids extra traversal type structure faster details case care : calling TYPE_1 METHOD_1 ( _CODE_ _CODE_ ) VAR_1 generics expanded ( Class type parameters wrapped a _CODE_ ) calling TYPE_1 METHOD_1 ( Type Type ) done time Type wrapped _CODE_ traversal skipped
a copy constructor consistent other config classes ? a shame divert pattern refactor
duplicates _CODE_ METHOD_3 ( Optional < T > ) I d folding method class
package private
feels want annotations register immutables mappers e g ( = TYPE_2 class ) annotation impl builder method default attributes immutable * immutable * builder ( )
I m indirection t - > business buys
remove ( key ) = = null
some issues mixed tabs spaces ? please configure IDE project spaces
I don t foo exist opens a unique - memory db
single statements implicitly a transaction redundant
a memory leak remove
add suppressions unused methods called reflective code ? current state hand adds maintenance code changes other
max rows disagrees assertion test failing
I lambda expression passed TYPE_1 METHOD_3
I d introduce a separate factory interface default customizer similar #754 default handlers feels weird pass a null annotation case specifically _is_ annotation e g javainterface _CODE_ { _CODE_ METHOD_3 ( Class < ? > _CODE_ TYPE_2 method TYPE_3 param int index ) ; }
example a test difficult understand isolation critical data ( interval id = 5 ? ) _CODE_ instead a setup method a - test
splitting hairs METHOD_4 ( t config ) ( t instead type )
need reflective bullshit s a separate artifact
couldn t - > STRING_1
ditto : type getType ( )
assertions Optional < T > variant : assertThat ( context VAR_3 ( TYPE_5 class ) ) _CODE_ ( VAR_1 ) ;
assertion buying
redundant assertion
redundant assertion
absence a demonstrated problem other s simple solution enhance locales
I expect empty
considered a programming error - - assume null empty list instead a coding error
meh : TYPE_3 : : close instead a lambda semantically equivalent - - I method handles critical merge : )
meh : methods package private
redundant log statement
wrap e g _CODE_ other _CODE_ subclasses
I mirroring existing registries work I sense return a nullable type Optional < TYPE_1 < > > lookups done necessarily throwing exception a change done existing registries
? rid ( ! VAR_1 ) blocks work :
checking containsKey calling remove redundant removed
consistence statement higher : new HashMap < > ( ) ;
shot breaking a bit understand
variables ( VAR_2 VAR_4 ) tests run - some magic provide I aware ? I remove
I a 1 parameter version constructor instead passing null
METHOD_2 exact code
I modulo part strategy applied closer inspection I issue withif ( partition > = meta VAR_1 ) { partition = partition % meta VAR_1 ; } ( partition < 0 ) { partition = Math VAR_4 ( partition ) ; } = > partition - meta VAR_1 ? modulo applied VAR_4 ( ) IMHO
want ? boolean stopping actual _CODE_ 2nd boolean FALSE graceful jump : 1 ) boolean values reverse mention TODO this2 ) java version ( call close ) done - cancel call - a temporary workaround proper METHOD_1 ( false true ) work
rx / reactor brings main flow decisions weird leveraging VAR_5 _CODE_ wrong
browsing web interface moment I don t VAR_4 test
don t need else
don t need else bad java doesn t XOR : )
deploying modules longer target * * * * arriving container match containers repository a scheduled deployer performs redeployment operation a time targeting container I logic doesn t arriving container info anymore
reason NPE _CODE_ ( org springframework xd shell command _CODE_ ) : final String _CODE_ = configuration METHOD_1 ( _CODE_ _CODE_ ( ) _CODE_ ( ) ) ; _CODE_ _CODE_ null
include key s VAR_1 adding sequence VAR_1
Assert state ( ) ( IllegalStateException desired ) Assert VAR_3 ( ) ( instead throw IllegalArgumentException ) case 6 lines replaced 2 improves test coverage ( tests blocks )
pass a single arg METHOD_2 ( ) e g : METHOD_2 ( substring ( 0 VAR_3 ) ) ;
remove please line
intend leave VAR_8 ( )
I bother printing stack trace won t good
need modify TYPE_1 simply a Map constructor s simpler attribute values ( including user - provided OOTB ) represented resource representation
reasons I didn t create a PR ; answer explore ( possibly _CODE_ creating _CODE_ earlier ) earlier ( current master ) a static method called publish container started event a context ( static _CODE_ call ) needs change need a bean a managed lifecycle
handled _CODE_ case distributed case I correct ? launcher contexts a bit ugly I guess I expect more transparent ( listening some kind close event ? )
initialize VAR_1 instance s null ? ( synchronized method - level a synchronized block )
I assume meant removed
a String resource client responsible formatting
3 methods I don t need synchronized state appears method - scope
necessary wrap / catch ( propagate exception ) fails other close ( ) bypassed
code smell : clarify contract repository emptyness
I guess laundry list ; )
add ( )
happen file absolute
verify size resolved classes
omit public _CODE_ 5
part slightly simpler javaif ( VAR_3 && ! VAR_2 METHOD_1 ( VAR_1 ) ) { return VAR_2 METHOD_2 ( ) ;
changes broken a current behavior ignore exception statement close throw a TYPE_1
( VAR_2 ) - > ksuggestionreturn VAR_1 METHOD_2 ( key VAR_2 - > new TYPE_1 ( ) ) ;
check METHOD_1 ( ) checking VAR_1 error message more specific
A lot changes logic I m curious driver returns a null object type returns true VAR_1 METHOD_3 ( ) I ve happen primitive types object types
I needs null check
need call METHOD_6 ( ) call - finally
I prefer - - resources follow : javatry ( TYPE_1 VAR_1 = VAR_2 METHOD_2 ( ) ) { TYPE_2 VAR_3 = VAR_1 METHOD_3 ( TYPE_2 class ) ; TYPE_3 = new TYPE_3 ( ) ; VAR_4 ( STRING_1 ) ; VAR_5 ( STRING_2 ) ; int VAR_6 = VAR_3 METHOD_4 ( ) ; assertNotNull ( getId ( ) ) ; assertEquals ( 1 VAR_6 ) ; }
VAR_1 = new ArrayList < > ( ) ; ( VAR_2 checks )
sense refactor complete function : javathis VAR_1 = VAR_2 METHOD_2 ( ) ; ( VAR_1 ! = null ) { ( String : VAR_1 ) { builder VAR_4 ( TYPE_3 TYPE_2 VAR_7 ) ; } } return builder VAR_3 ( ) ;
I _CODE_ IDEA warning : loop replaced loop description _CODE_ loops initialization update components replaced simpler statements example : ( ; _CODE_ ( ) ; ) { process ( ) ; } loop replaced withwhile ( _CODE_ ( ) ) { process ( ) ; } A fix action other loops replace loop checkbox wish inspection ignore loops trivial - existent conditions
please remove empty block
necessary : context ( STRING_1 ) message underlying error
suggestionthrow new TYPE_1 (
Arrays asList
_CODE_ < ? ? > VAR_1 = Collections VAR_1 ( ) ;
please explain ? initially calculate required milliseconds creates TYPE_4 instance based converts TYPE_2 UTC timezone converts _CODE_ converts TYPE_4 converts milliseconds transformations required ? UDF shouldn t apply timezone values handle
isn t simpler formula VAR_1 - ( VAR_1 % VAR_4 )
please replace strings concatenation StringBuilder usage
a bit clearer : VAR_2 = Math max ( VAR_2 VAR_1 ) ;
_CODE_ Entry < ? ? > entry = ( Map Entry < ? ? > ) VAR_1 ;
I skip null check s assume caller pass null context
harm setting I choice avro ? avro a schema files follow schema evolution occurred ( new field added ) d want proper data type reading files column a long - standing limitation drill s pure schema - - read approach : creating reader wrong time guessing schema columns
multi - catch
suggestion
please replace blocks ImmutableList VAR_4 produces checks internally avoid copying
suggestionprivate TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) {
suggestionprivate void METHOD_1 ( TYPE_1 VAR_1 TYPE_2 VAR_2 TYPE_3 VAR_3
casting instance check safe
runtime exception ? I assume want ignore exceptions
rule preserve state a singleton i e reuse instance
final
method numerous code style issues : - { new lines - extra spaces ( ) - e VAR_2 ( ) ;
checked VAR_1 VAR_2 null
capture schema change exception unsupported exception thrown
remove final exceptions
suggestionthis VAR_3 = VAR_2 VAR_3 ( ) ;
type converters shouldn t support METHOD_1 sense mark method final
code wouldn t triggered return
group scans wildly complicate ( ) odd serialized JSON ( part logical plan ) means class jackson - serializable plugin takes config ( serializable ) find need plugin a hokey - pokey [ wiki ] ( ) more info
called _CODE_ ( ) returns 1 plugin allow sharding requests ? I m requesting a time range plugin split time ranges multiple small requests drill spread drillbits ? a complex topic I m sort
logic flow
I suspect 1 t read data 0 worker threads
isn t redundant _CODE_ class ? need ? review
debug reading logs need debug statements methods called needed
a copy / paste ? trouble throwing a TYPE_2 throw catch wrap another kind exception ( wrapped a TYPE_2 ) TYPE_2 thrown reverse polarity : ( containsKey ) { return } else { throw }
please log VAR_3 security guys ( ) don t
a reason TYPE_1 instead TYPE_6
method doesn t throw IOException please remove
more redundant cast
doesn t throw exception please remove throws clause
String necessary
consider nullification empty collections - assignement
suggestionprivate final Map < Class < ? extends TYPE_1 > TYPE_2 > VAR_1 = new TYPE_3 < > ( ) ;
return VAR_1 = = null ? VAR_2 : VAR_1
return VAR_1 = = null ? VAR_2 ? VAR_1 ;
happen ? EVF ensure order occurs : * open ( ) * ( ) ( false returned error ) * close ( ) ( open ( ) succeeds ) file null
analog method guava ? build - java methods suggestionreturn TYPE_2 METHOD_1 ( VAR_2 VAR_1 METHOD_2 ( ) ) ;
need pass config configuration ( config ) VAR_3 ( config ) ; properties ( config ) s usage field set line constructor
Collections _CODE_ ( )
please rewrite method body : javaswitch ( type ) { case VAR_1 : case VAR_3 : case VAR_2 : return false ; default : return true ; } I suspect UNION sortable need check
suggestionfor ( TYPE_1 VAR_2 : METHOD_3 ( ) ) {
checking exception message brittle I checking receive TYPE_1 enough
methods static
please drill code style - move @Override a separate line
javareturn Arrays asList ( new TYPE_1 < > ( VAR_1 METHOD_3 ( ) TYPE_3 VAR_4 ) new TYPE_1 < > ( Boolean VAR_5 TYPE_3 VAR_6 ) ) ;
critical s invert : VAR_1 = = null
table need offset please give example
necessary java guarantees initialize int fields variables 0
public
public
please methods public
ArrayList - > List
generics suggestionattributes = new HashMap < > ( ) ;
_CODE_ < Object > result = new ArrayList < > ( ) ;
need add stuff s covered _CODE_
! VAR_2 isEmpty ( ) check redundant
break existing logic ? a predicate $0 = $0 Set _CODE_ function return false
please revert change
please generics avoid warnings _CODE_ new ArrayList < > ( VAR_1 values ( ) ) ;
please remove line VAR_2 closed automatically resources
please move call statement connection closed need restore session options
_CODE_ < String > VAR_8 = new ArrayList < > ( ) ;
default false required explicit set
please remove catch block general exception a throws clause
[ TYPE_1 docs ] ( ) METHOD_2 ( ) [ ] method unnecessary treated deprecated instead HashMap constructor advantage new diamond syntax
_CODE_ close ( reader VAR_1 ) ;
pass VAR_1 instead 2
please set VAR_1 = 0 ; add reset ( ) method call
suggestionreturn VAR_1 > 0 ;
suggestionthis VAR_4 = VAR_3 ! = null && VAR_3 METHOD_2 ( STRING_4 ) ? new Integer ( VAR_3 ) : 0 ;
check null
new HashMap < >
need ? SHOW SCHEMAS hive % work DFS schema default
_CODE_ true
VAR_1 set TYPE_1 Builder default removed
intent previous question traits validation happening calcite functionality ideally belongs I suppose checked
update method _CODE_ sink anymore
catch InterruptedException handled caller ; handling : - upper code more logic deal interrupted exception - code erasing interrupted flag caller code doesn t
c mon - return VAR_1 size ( ) > 1 ; instead
remove return ; statement int tests
possibly logger info
correct place enable plugin config enable plugin creation config
factor TYPE_2 VAR_2 static field initialize METHOD_1 ( ) method
pass VAR_1 broadcast method instead extracting individual passing parameter
please include null check VAR_1 : ( VAR_1 = = null ) { return false ; }
consider moving _CODE_ ( ) new default methods introduced java 10 require special handling
I assume change reverted
necessary METHOD_3 \ a space trim
? operator
I need constructor public _CODE_ method copy ( ) instead constructor
calling new constructor ? a separate change
need create new objects : stream objects Iterator wrappers please update TYPE_3 class allow ranges ( VAR_1 ( aka offset ) METHOD_4 )
need create empty array null passed
TYPE_1 a method takes arguments please method
checking footer null prev test
need ? METHOD_3 ( ) parameter exists
add org VAR_2 VAR_3 VAR_4 VAR_5 config import statements
reason a TYPE_2 instead HashMap ? ( _CODE_ suffice )
return ( VAR_1 + ( ( = = null ) ? 0 : VAR_2 ( ) ) ;
shouldn t ( i ) ( 0 )
check NONE_AND_TWO works case ? JPPD applicable SV2 created
please change ( TYPE_1 METHOD_1 ( VAR_1 VAR_2 ) VAR_3 ) ;
VAR_1 remove VAR_4 field
I thinking _CODE_ VAR_3
Collection - > List ? order
ternary operator
TYPE_1 equals consider null equal case changes
return ( e instanceof TYPE_3 ) && TYPE_4 equals ( e getMessage ( ) )
necessary ? query id identifiable part1 part2 TYPE_2
readability lateral check independent others split a separate statement
need fail default other plugin s default create empty _CODE_
new HashSet < > ( )
remove super ( )
please remove super ( )
cleaner implementation : call method VAR_3 parameter
simplified ( VAR_5 ! = _CODE_ )
I added method _CODE_ necessary merged pass null create empty String
checking interrupts remove Thread _CODE_ ( ) _CODE_ ( ) METHOD_3 ( boolean VAR_2 ) method
method code simplified line
initializing null redundant
I line removed VAR_3 disabled tests
Exception required constructor private
please rename filter
set setup ( ) time wrong drill call close ( ) calling setup ( ) safety check null
pcapng files omit fields ? user asks dst_ip field exist row ? exists row ll slightly performance a required type column omits nullable bit column note _CODE_ need type METHOD_2 TYPE_8 defined TYPE_2 class some required others METHOD_2
int count = VAR_3
clear t return VAR_1
( index ) ; a missing format null empty
format
change required
return instead
1 VAR_2 volatile ? enough synchronization ? 2 check VAR_2 null synchronization ( DCL )
change necessary
prefer resource manager depend foreman ; unit testing impossible foreman depend class other
please log exception full stack trace
omit ; java default
want print csv ? I suggest produce output
true plenty good
a minor point : ( VAR_2 = = null && VAR_1 VAR_2 = = null ) { return true ; } ( VAR_2 = = null || VAR_1 VAR_2 = = null ) { return false ; } return VAR_2 equals ( VAR_1 VAR_2 ) ;
s point I guess ? verified exception
I personally prefer construct hamcrest assert useful reasons : - s error message ( hamcrest prints a nice error message based arguments ) - assert fails don t VAR_3 s
open VAR_1 I guess s responsibility close
VAR_1 = true happen call super close ( ) base class close throw exception
: ( VAR_1 = = null ) { return 0 ; } / / original code
_validatekeystore_ happen _initcontext_
removed initialized line
reading VAR_1 checking null change ( ! VAR_1 || ! VAR_1 METHOD_2 ( ) VAR_3 ) { return ; }
StringBuilder
TYPE_1 VAR_1 = new TYPE_1 ( ) ;
space
change necessary
scalar < = 1 0 ( 0 qualifies )
( VAR_4 ! = null ) { - > ( VAR_4 ! = null ) {
A handy trick avoid code duplication : public TYPE_5 ( TYPE_1 VAR_2 final TYPE_2 VAR_3 ) { ( VAR_2 VAR_3 null ) ; } bulk constructor code appears : - arg version
missing + VAR_2 METHOD_3 ( ) exception adds real : new IllegalStateException ( e ) ;
int VAR_3 = justreturn ( int )
hmmm need caller sets a session option setting a session option instead implementation METHOD_2 session option manager class fill TYPE_4 VAR_2
call add method TYPE_3 instead VAR_3 add ( field )
existing code ; code a block close finally ensure close occurs a write other error occurs
change assertion discussion
remove length check
noted opening file scanning 1000 files ll 1000 open file handles start fragment postpone opening files setup
TYPE_7 - - > _CODE_ a null pointer illegal state
return TYPE_1 valueOf ( VAR_2 ) ;
return a long
suppose _CODE_ small ( e g 100 rows ) batches calling _CODE_ ( ) multiple times small amounts shouldn t combine smaller number outgoing batches
temporary variable removed
refactor i - > count
picky : erase previous VAR_2 runtime exception
int Integer
I noticed error plugin configuration serialization method accessor public
? user responsible setting config
affect query operation long - running queries ? impact query profile ? updates enabled update query completion finalize profile ? writing profile automatically disabled status updates disabled ? timeout updates ? notice query updated kill query due timeouts
METHOD_2 calling _CODE_ ( config VAR_3 ) creating VAR_3 assign VAR_3 calling method VAR_3 creation takes config METHOD_2 method a side note I don t _CODE_ ( config VAR_3 ) VAR_3 config passing place
remove unused parameter
hold VAR_1 batch TYPE_1 please pass TYPE_1 constructor class passing ( irrelevant ) VAR_1 batch
query context general place store specific options VAR_9 operator / factory option manager stats options set operator definition ( _CODE_ ) fragments : selected creating plan behavior mimic set memory sort operators
change method _CODE_ ( ) ? internally create a new TYPE_1
work need reassign + = Integer toString ( VAR_3 ) ;
include error handling ? METHOD_3 fails close ( ) won t called METHOD_4 method
VAR_4 method accept a null storage strategy ? substitute PERSISTENT null ? save ! = null checks else method called
please guava preconditions _CODE_ ( cache containsKey ( VAR_1 ) error message ) ;
iteration map entry set more efficient key set : ( Map Entry < String byte [ ] > result : results entrySet ( ) ) { METHOD_2 ( result getKey ( ) result getValue ( ) ) ; }
normal facilities : public invalid ( String message ) { super ( message ) ; } e getMessage ( )
minor code flow suggestion : ( VAR_1 = = null ) { return VAR_1 ; } return VAR_3 ? TYPE_2 METHOD_2 ( ) METHOD_3 ( ) : TYPE_2 METHOD_2 ( ) METHOD_4 ( ) ;
required
semantics correct _CODE_ version seeks n bytes implementation seek data * * buffer * * ( ) skips discards n bytes data input stream _CODE_
exception handled
server doesn t require authentication shouldn t client wait
minor point version simply call client ? version takes a version require version ? a bit simpler
version number protected a read write VAR_1 need atomic long ? atomic long a ( VAR_1 protected ) long
change declaration : public static final _CODE_ TYPE_1 return options VAR_1 ( TYPE_1 ;
ImmutableList
please add docs
TYPE_1 instance tied some settings VAR_1 ? wouldn t a subsequent invocation function ignore passed VAR_1 values settings
I find method class intentional
s default constructor default builder reason force a builder properties
javareturn option VAR_1 ( TYPE_1 ) ;
VAR_4 null
constructor copy VAR_5 input VAR_1
_CODE_ close ( )
accessing profiles trigger starting VAR_1 started exception
loop equivalent ? { final long VAR_3 = VAR_4 ( ) ; ( VAR_4 METHOD_2 ( VAR_3 VAR_1 ) ) { / / able update peak finish return ; } } ( VAR_1 > VAR_3 ) feels more natural
reason allocator id other places ? harder follow logs don t id corresponds
explain necessary ? issue resolve related function issue function guarantees reader index a drillbuf ( fact remove exposed functions ) function positions reader else some other operation doesn t position reader ? apply fix
new ArrayList < > ( ) ;
asreturn VAR_1 METHOD_2 ( ) = = TYPE_2 VAR_3 ;
making more public isn t some verify loaded ? isn t protected enough
shouldn t call close I _CODE_
passed VAR_1 + 1 ? done _CODE_ java
call _CODE_ ( ) implementation case insensitive
reason added ? safe ignore runtime exceptions
forgot remove VAR_2 start ( )
need synchronized
cast redundant TYPE_1 ( ) expecting TYPE_3 object
add underlying exception ? new TYPE_10 ( e )
tend braces selenium codebase harder chaos accidentally : )
please alphabetise
nowadays tend follow a pattern : ( ! ( o instanceof TYPE_1 ) ) { return false ; } TYPE_1 = ( TYPE_1 ) o ; return TYPE_2 equals ( element element ) ;
please generics s obvious type Map < ? ? > prevents compiler warnings correct equally meaningless : )
generics please
@Override annotation _CODE_ busy freaking some java versions won t compile code
instead empty string check File exists ( line ) log a warning doesn t continue
X - netbout - alias : %s
declared static
need call super ( )
statics prependended class TYPE_6 VAR_2
s move final ) METHOD_4 ( ) line maintain correct indentation
variables single - variables inline ( i e test a single statement )
s inline
equals
thoughts returning a bool ? helpful item update updated ( signal developer need implement equals hashcode )
result variable needed—the block finally invoked a return
invoked
applying method METHOD_3 avoid duplication input sanitation applied ? cases VAR_1 trim ( ) desired calling METHOD_3
super reference removed METHOD_2 ( ) static
RuntimeException enough
need public ? a new public
don t adds anymode VAR_2 convertors creator I d kill log line
kill
Exception super generic anti - pattern reason change
} catch ( InterruptedException e ) { throw new IOException ( e ) ; } throwing exception answer s point setting thread METHOD_5 flag : a thread waiting sleeping occupied thread interrupted activity occasionally a method wish test current thread interrupted immediately throw exception code achieve effect : ( Thread interrupted ( ) ) / / clears interrupted status ! throw new InterruptedException ( ) ;
layers wrapping TYPE_7 done method
I meant _CODE_ I agree t avoid interface TYPE_7 t override _CODE_ _object_ ( VAR_4 case )
prefer : String = ; ( VAR_1 ! = null ) { List < Integer > VAR_2 = TYPE_3 METHOD_2 ( ) ; ( TYPE_4 f : VAR_1 METHOD_3 ( ) ) { VAR_2 add ( f VAR_3 ( ) ) ; } = TYPE_5 METHOD_4 ( STRING_1 ) METHOD_5 ( VAR_2 ) ; } conf set ( TYPE_6 VAR_5 ) ;
a debug log ? easy config affect pig creates multiple loaders lots log
import Constants fits line
a debug message
thanks ready btw skip map copy common case VAR_2 set
s difference blobs records ? 2 terms
moved _CODE_ ( ) need _CODE_ _CODE_ ( ) pig loaders
return ( TYPE_1 ) TYPE_3 METHOD_2 ( _CODE_ ) METHOD_3 ( ) ; METHOD_2 throws IOException
isn t bug headset wasn t working app minimized
separate statement return isEmpty ( VAR_1 ) || isEmpty ( VAR_2 ) || Arrays stream (
enclose { } ;
input a Collection a Set input consider a List internally instead array simpler
final
METHOD_2 return false input IP address fails a subsequent check e g 999 9 9 9 case subject checks ( fail code correct )
good min number references ? ( general I a checkstyle raise error unused imports )
fine call new HashMap < > ( ) need list types side ( I )
need null check - METHOD_3 ( ) takes care
missing space 1
touching lines s reformat add space = ! =
other places ve [ resources syntax ] ( )
METHOD_2 call present _CODE_ need
need System println
general convention { } braces / else statements
_CODE_ bringing some noise a discussion #211 removing : simplify changes
s thinking showing s ? a reason don t want show summary matching fails
returning iteration consequences
specific exception
dangerous 100% empty message call METHOD_3 ( 0 )
please check works quoted names
invert statement please
throws Throwable
entry length ( ) - VAR_2 length ( )
getter returns a Collection creates ArrayList
warning : static field _CODE_ logger accessed a static
method doesn t throw TYPE_3
VAR_1 > 0
don t differentiate compaction policy factory creating incrementing couter METHOD_4 policy
ctx METHOD_4 work ctx _CODE_ check write connection closed server a chance write
package - private
passed constructor
package private
remove timer
minor : remove initialize line 41
Math max ( VAR_2 VAR_6 ( VAR_1 ) METHOD_2 ( ) )
question account colo single replica
TYPE_1 IOException don t - else statement
_CODE_ failed read index intended
package private add java doc method please
finally
finally
I curious difference minor change
e = e = = null ? e : new RuntimeException ( e ) ;
change : ( key VAR_2 VAR_3 VAR_4 VAR_5 VAR_6 TYPE_5 TYPE_6 ( short ) 0 ) ; avoiding extra method call
please add java docs methods
simplify line ? readability eliminate local variable return
TYPE_3 hostname datacenter I VAR_5 _CODE_ ( ) generate instance
combine lines
null ? assume s other places
variable VAR_1 redundant
info redundant
I recommend removing throws IOException interface checked exception dealt calling VAR_1 _CODE_ ( null ) I helps unify failure handling paths caller needs deal
I a valid case supporting METHOD_3 ( ) method HTTP2 present _CODE_ blocking _CODE_ s instead _CODE_ s won t need HTTP2 instead METHOD_3 ( ) throw _CODE_
need implemented live - serving mode
combine lines
replace impl a call write ( TYPE_4 METHOD_1 ( VAR_1 ) VAR_2 )
method METHOD_4 ( String VAR_1 String _CODE_ boolean _CODE_ )
minor : a private method
minor : private
remove print line ? debugging test fails consider adding VAR_1 VAR_2 assert messages
INFO level
format code intellij
I d prefer TYPE_1 a pojo class move method a utility class prod test code call
supposed release buffer buffer field set null
method return null buffer created buffer VAR_1 error ? throw exception calling VAR_2 ( )
exceptions calling METHOD_4 _CODE_ ? I METHOD_1 called selector receive unboxed _CODE_ : _CODE_
clearer
fold line
case throw exception
trace happen
yeah I m needs extra sync
put { } statement
thought - 1 default ? I feel s more natural 0 default existing put / delete / _CODE_ _CODE_ 0 expected default 0 need introduce _CODE_ 0 auto compatible
VAR_2 ( ) return null element present
I METHOD_2 insert entry map computing call needed
remove hashcode check conflicts
minor : I warn
need options partition key need debug error values bring debugger set a breakpoint
TYPE_4 ( VAR_2 VAR_3 VAR_5 VAR_4 VAR_3 VAR_7 )
logger error
method private
removed
don t need cast accepting a TYPE_1
discussed offline VAR_3 metrics grouping consistent range requests
minor : move METHOD_3 ( ) line 144 remove return line 147
TYPE_3 thrown method
VAR_1
I < = ( allow equal case meet requirement ) a specific reason strict
singleton isn t threadsafe worried multiple threads calling method
TimeUnit VAR_7 METHOD_2 ( VAR_3 VAR_6 )
calling METHOD_2 ( ) port
throws TYPE_3 needed
correct I wrong METHOD_3 throws exception handled ? exception parameter null METHOD_7 ? question _CODE_
hashcode equal objects aren t - test METHOD_2 correct lead spurious failures
VAR_1 ! = null removed checked callers
need cases encrypted = true ( simple adaptive ) I don t useful -
curious returns new TYPE_1 previous test null returned
need remove
public
VAR_1 a constructor don t need check null
minor : some variables long some Long I long good ? ( null )
minor : don t need
Exception unnecessary remove
doesn t need public
isn t check done METHOD_2 ( )
minor : don t a function required
I don t TYPE_1 needs passed a _CODE_ instance property store path _CODE_ frontend refer wrong path config _CODE_
return VAR_1 = = Utils TYPE_1 ? Utils TYPE_1 : Math max ( 0 TimeUnit VAR_4 METHOD_2 ( VAR_1 - VAR_2 ) ) ;
return int instead Integer
change needed ? null won t work anymore
prefer VAR_2 ( VAR_1 )
pass exception
minor : don t need qualifiers
don t need Arrays toString ( VAR_1 METHOD_3 ( ) )
throws Exception
remove
differently notice method calls _CODE_ ( ) synchronized method set synchronization happen need method synchronizes object participate ( ) call
VAR_1 started I return true stop ( return true VAR_1 stopped don t stop )
function private
function private
ah I need synchronized other methods add keyword synchronized METHOD_1 ( ) _CODE_ ( ) _CODE_ ( )
shouldn t return boolean ? return error stop VAR_1 failed
minor : simplify byreturn VAR_2 = = null || VAR_2 METHOD_1 ( VAR_1 )
private boolean
fired job submission
minor : constructor
need extract METHOD_1 ? exploit ByteBuffer equals ( ) comparison
change safe ? shouldn t based versions
doesn t need
method a boolean allow tests executed order instead encryption staying enabled
result null
a debugging change hasn t reverted
some other class ? t private
check necessary ? sort invalidates assert
minor : set null
public
need public
t check size match VAR_3 empty avoids _CODE_ constructor
minor : required
( VAR_2 = = VAR_4 METHOD_3 ( ) )
ops ? adding removing doesn t sense
minor : parentheses denominator required
minor : parentheses VAR_3 required
step needed ? changing underlying map changed
return VAR_2 put ( key )
call variable _CODE_
missed iteration - _this_ static class variable ( unmodifiable collection )
minor : a lock _CODE_ _CODE_ ( )
move top
nuage require metrics update path
required
private functions
VAR_2 < = 0
need METHOD_3 a _CODE_ _CODE_
discussed s allocator
ignore
protected
changed a constructor
shouldn t VAR_5 METHOD_2 ( ) length
isn t return a byte
test cases remove a path STRING_1
auto generated
incase introduce a new version TYPE_1 future code some fields V2 V1 dummy values
I check unnecessary omitted id supposed - null construction TYPE_1 fail
fixed a ( preferred TimeUnit utilities ) part [ ] ( ) patch
justthis VAR_1 = VAR_1 || _CODE_ t METHOD_2 ( ) ( multithreading scenarios ) needed
setters
care ? essentially checking JVM started thread asked start isn t ? arbitrary check done tests _CODE_ _CODE_ ( )
shouldn t METHOD_4 schedulers METHOD_1 directory
minor : qualifiers required
a private function ? tested _CODE_ actual policy tests respective tests
wouldn t safely METHOD_1 actual stats job cancelling terminating middle ? pushed a central location cut data abruptly
VAR_3 request types
intent function call ? METHOD_2 ( ) reduce case tested previous function call
reason constructor ? null normal flow
public constructors
minor : exists _CODE_
minor : I don t increment time mimic actual flow METHOD_4 return _CODE_ line
omit check method called a chunk needs notification ( longer prefixed )
map needs sorted
ease test reason change main code
minor : required
replace string STRING_1 TYPE_2
/ constructor rid version_0 version_1 phased
1 general avoid expr ? true : false pattern simply substitute expr 2 ideally check = = ( byte ) 1 ( ! = 0 )
VAR_3 null
minor : need super qualifier
don t need 2nd param ( length ( ) ) _CODE_
minor : currently i don t concurrent map instance class required ( future allow injecting VAR_2 ) won t VAR_2 = VAR_2
VAR_1 null _CODE_
remove public
( VAR_1 > = count ) simpler
docs
METHOD_1 ( ) called increment decrement method
metadata chunk data chunk treated a single metric reports _CODE_ chunk types
I don t correct updating VAR_8 fill complete threshold wait fill complete t reuse TYPE_1 VAR_2 holds calculating wait time
a general rule thumb follow i log exception swallowed destination exception case exception set passed else log eventually log exception swallowed double logging pollution log
consider pros cons operation level / s - catch a higher level i e _CODE_ thread
a default case ? point updating metrics unknown datanode
decide throwing silently ignoring ( _CODE_ )
curiosity method called multiple threads
a handshake completes fast ready VAR_1 added METHOD_4
need public
orthogonal question ( other statement ) throw a RuntimeException catch behavior ? behavior
double count close ( ) removed operation
extra line
personal pref - i find tests _much_ more readable METHOD_3 ( ) arguments needed instead setting arguments class variables reasons I I want reuse function want knobs I _have_ read function arguments I simply read description arguments I need new arguments need added class variables more confusing
private
constructor test classes instantiated individual test
A VAR_4 ( )
don t rate metrics
methods private I guess
I hope plan work logging metrics a patch need lot trace logging general
dont want shuffle replicas put
public
assertEquals
argument TYPE_2 ? need TYPE_2 shouldn t class input turn atomic reference
return
more readable simply expected case loop loop run VAR_2 + 1
check VAR_1 belongs < host port > pair ? possibly error cases connections < host1 port1 > checked < host2 port2 >
plan embed _CODE_ testing purposes
braces needed
intend other change discussed a separate patch
write a function code repeated 3 places
skip check ? a package private class
Exception ? I _CODE_ constructor throws Exception I don t other IOException function
duplicating checks METHOD_4 ( ) check
ah I intend put number VAR_2 ? isn t information redundant
flip
s a build instead return null instead
( METHOD_2 ( ) )
ensure METHOD_2 sync METHOD_3 ( ) check ideally METHOD_3 ( ) check dropped
TYPE_2 generate numbers a seed ? example local random generating series a balanced scheduling
private
t u count instead index
constructor a weird ? a _CODE_ ( ) - need send VAR_3
ByteBuffer ( ) return 1 byte _CODE_
haven t VAR_1 method
ensure caller dont start thread w / o setting blob storage service
finally
javareturn METHOD_2 ( ) ? 0 : channel write ( buffer ) ; want more elegant
want check VAR_3 null VAR_4
empty function ? qualifier ( public private )
qualifier
careful casting long int - basically cast a long > Integer VAR_3 int casting early cast finding difference guaranteed Integer VAR_3 bereturn VAR_1 METHOD_2 ( ) - VAR_2 ( ) < Integer VAR_3 ? ( int ) ( VAR_1 METHOD_2 ( ) - VAR_2 ( ) ) : Integer VAR_3 ;
byte int safe t simply data = buffer ( )
related patch _CODE_ configurable hardcoded
need check ? argue statements other methods
formatting ? method
need check other fields ? objects equal
VAR_2 hascode datanode ssl ports
check required colo info context
default constructor sets false
change VAR_3 + i
StringBuilder faster compiler optimize string concatenation _CODE_ StringBuilder StringBuilder asynchronous runs faster
I meant
metric need
need move logic rely METHOD_1 alive
I meant need thread VAR_1 independent progress caught thread die
need a separate VAR_1 variable
good avoid converting node a JSON a String expensive define a toString defined log ( )
List < TYPE_1 >
= 0 sufficient initialize long VAR_8 ;
= 0 sufficient
calculate initialization clustermap change recalculating minute useful
lot more clear
a bug VAR_2 METHOD_1 returns serialized form size
I correct METHOD_1 instead new TYPE_2 missing _CODE_ = METHOD_1 ( VAR_2 + STRING_3 ) ; project ended inconsistent metrics names ( a - b mixed a_b ) watch code reviews metric _CODE_ = - I code reviews fine need vigilant soon a dashboard alert set metric permanent
spaces : length > 0
log rethrow exception
set code remove hardcode 0 a return set VAR_3 0 break loop line 348
null checks ? null - creating object lines
change debug warn error need include
_CODE_ _CODE_ _CODE_ _CODE_ return null default : CIENT_KEY_ALIAS
remove return
fix error message select event view labeled event screen service exception ? replace event label
don t catching exception constructor init method annotation
remove : declare - response useless - assign return object method - call
Optional : need throws Exception catch runtime Exception
question : check log
Optional : replace System LOG statements
need
dont catch generic exceptions narrow specific
need
I feel METHOD_2 ( ) check needed loop care case
! [ CRITICAL ] ( severity : CRITICAL ) log rethrow exception [ ! [ rule ] ( ) ] ( )
Optional : need StringUtils VAR_2 ( VAR_1 getType ( ) ) StringUtils equalsIgnoreCase handle null VAR_1 getType ( ) = null
put ( null ! = exchange ) reading more easier ? don t worry
remove method
need null - checked
return VAR_2 METHOD_2 ( ) ; instead assigned return
need password / hash _CODE_ / _CODE_
remove ? true : false unnecessary
please elaborate returning VAR_4 VAR_2 blank
removed line : 278 279 - done TYPE_1 METHOD_4
check - VAR_2 METHOD_5
assignment VAR_1
A method return statement instead a local variable result return local variable
! [ MINOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
inconsistent log level stick trace level method
need log warn ( msg { } VAR_5 ( ) ) ;
2 conditions log VAR_3 unnecessary rew3ord write log statement _CODE_ METHOD_1 method
unneeded local variable put constant method a couple lines
startsWith instead METHOD_3 METHOD_3 return position _CODE_ defined 67i8urn : oid
statement checking property allowing corrected times
inline method call
optional : buffer append ( msg ) append ( key ) append ( )
Optional : TYPE_3 equalsIgnoreCase ( VAR_2 getId ( ) ) prevent NPE operator null
prevent code duplication change body constructor ? ( ) ; builder = builder ;
suggestion readability - - chaining calls append : _CODE_ VAR_2 = new StringBuilder ( TYPE_1 VAR_4 ) append ( STRING_1 ) SNIPPED feeling crazy skip StringBuilder declaration function a single statement : javareturn new StringBuilder ( TYPE_1 VAR_4 ) append ( STRING_1 ) SNIPPED toString ( ) ;
! [ MAJOR ] ( ) move STRING_1 string literal left side string comparison [ ! [ rule ] ( ) ] ( ) ! [ MAJOR ] ( ) move STRING_2 string literal left side string comparison [ ! [ rule ] ( ) ] ( )
! [ MINOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
remove ! = null null instanceof TYPE_4 return false
consider warn trace doesn t sense log message
need static private method ? please update javac doc
importing classes top file
return ! = null ;
public
need define VAR_2 inline
need else block
call inline new TYPE_2 ( ) METHOD_1 ( VAR_1 VAR_2 ) ;
reduced a single line
checking null sufficient don t need check ! VAR_3 isEmpty ( ) clearing list
log statement isn t adding ( s a system call ) - - remove
need local variable session ? call METHOD_5 assigning
instead assign return return statement
touching code base remove logging statement beginning exiting method
remove TYPE_3 catch statement rewrite a null check
explain entity outbound requires _CODE_ _CODE_ service
unnecessary parens return
getValue ( ) tested emptiness due subsequent ( 0 )
VAR_1 null return a blank TYPE_1 null
unnecessary parens return
return redundant removed
function a single line ( inline return )
don t create immediately return return - line
log error JNDI lookup fails part METHOD_2 ( ) - - need else statement
unnecessary parentheses ( extra line break )
simplify line
line wrap a couple lines ; wrap line wrapped earlier
hmm don t throw exception don t a handling a fatal error
function simplified : METHOD_2 ( ) ; return token ;
message null checked point ? a guarantee VAR_3 length greater 0
need check VAR_4 null
VAR_2 lowercase
logging statements trace apply subsequent pr
a suggestion anytime a function return a Collection consider initializing empty instead null s a compelling reason - - allows callers run result enhanced loop ( similar ) requiring a null check
debug statements changed trace removed
remove return statement s redundant
break loop address
s
I add METHOD_4 means add else METHOD_4
não é um bom nome de variável acho oc erto aqui seria ou cep mesmo acha
não deveria ser null aqui
I assertEquals ( Arrays asList ( ) VAR_1 )
I understand rid explicit type parameters calls
I exclude objects resulting list
assert beginning method VAR_1 root call method I
I agree other changes case more optimal previous version
removed
( java lang String ) instead equals
recursive call METHOD_6 calls METHOD_1 calls METHOD_6 ? I checked deeper I understand sight
Set a subtype Collection part necessarysuggestionif ( Collection VAR_2 METHOD_2 ( VAR_1 ) ) {
thank easier longer condition
( metadata ! = null && metadata size ( ) > 0 ) WDYT
return new String ( VAR_2 start VAR_1 - start ) ;
want print _CODE_ ) _CODE_ ) call fill log warnings ? I vote A ) add VAR_1 = true
call clear method : simlified adding a null final addAll
change : - good explicit behavior - bad concise API ( delete parent intercession ) - break a lot client code ( breaks test code changes src / test ) I prefer revert remains fully compatible keeping other awesome advantages rest PR WDYT
I guess code work Set beginning assure VAR_2 2 sets iterated consistent pairs I works WDYT
I more problem call TYPE_1 _CODE_ ( ) inconsistency modules VAR_1 registered store modules List < TYPE_1 > _CODE_ search list add VAR_1 list sooner factory core ( ) _CODE_ ( ) call - time WDYT
mark METHOD_1 derived property ignore call METHOD_1 ? I guess case able set parent _CODE_
case VAR_1 belongs class VAR_2 belongs super class origin code
class substitute TYPE_5 scan ( ) usage purpose a miss
null check
_CODE_ / equals TYPE_1 correct ? I m tested
duplicate information environment model builder
remove change cf scan problem
false String API changes version java
update doc command line
METHOD_2
remove
StringBuilder faster
private static function
I swap order conjuncts equals ( VAR_1 ) expensive
usejavapackages addAll ( VAR_1 ) ;
shouldn’t TYPE_2 caught method — example lead ignoring new
A VAR_4 return true valid needs other : )
return data isEmpty ( ) ? - 1 : data ( 0 ) ;
I prefer a - liner a ternary operator
< = 1 clearer < 2 …
exact purpose return
I don t part public API need unit tests ? please package - private
( a ) return true else return false ? kidding ? : )
a reason replace method body withreturn VAR_1 ! = null ;
set null
mind whitespace please
reason plain IllegalArgumentException ? I types TYPE_2 ( VAR_1 ) present a freenet installation forcing user wrap code ( … ) catch ( … ) unnecessarily increase number lines consuming code
TYPE_1 METHOD_2 ( … ) compares TYPE_1 type TYPE_1 result ( * * * * wrong fixed AFAIK ) please compare hashes a insensitive timing attacks comparable METHOD_2 ( … ) guarantee property
INT_1 ? * =
some places separate boolean assert others put entire condition assert statement preferable consistently
writing ( ! VAR_1 && VAR_2 ! = 0 ) instead negated disjunction allows easier recognition condition holds
reduced return equals ( VAR_1 VAR_2 )
I m missing check element null I probability
I imagine ! functions _CODE_ ( ) hardcoded true
simply : ( ! VAR_3 METHOD_3 ( ) || TYPE_4 equalsIgnoreCase ( VAR_3 METHOD_4 ( ) ) ) {
field constructor parameters renamed
tests method throws Exception expect bo throwned
done field declarationexample : javaprivate Set < String > VAR_2 = new HashSet < > ( )
shouldn t need TYPE_3 extends TYPE_2
s strange delegate METHOD_1 result METHOD_1 timestamp METHOD_1 result return time METHOD_1 thread determine s METHOD_1 timestamp
leave * * TYPE_3 * * pass add method signature convert IOException TYPE_4 * * TYPE_3 * *
! = null
thingjavareturn container ! = null ? container VAR_3 ( VAR_1 ) : null ;
isn t related issue fix address a separate PR ? s versioning changelog thanks : )
compile
} else ( VAR_6 METHOD_2 ( ) ) {
please move VAR_1 arguments
calling METHOD_2 ( ) call VAR_1 METHOD_2 ( ) idea VAR_1 a member variable
please revert changes file
work ? add VAR_13
check 0 ? ( I a specific < = 0 ? constructor set VAR_8 INT_1 : don t hardcode magic numbers a DEFAULT_SHAPE_OUTLINE_WIDTH constant define INT_1
I add a check instance ! = null overwrite current instance null create a new instance getInstance methode instance = = null
want remove debug
call mandatory ? storing METHOD_3 computing line
s point 6 trailing zeros
inline
need url enough
METHOD_2 ( ) line
happened indentation ? TYPE_3 METHOD_3 ( ) indented 8 chars instead 4
set postgres ctor
testing completely separate features class : 1 ) closing environment 2 ) converting environment string separate test methods anti - pattern called test ( )
set final
I constructor doesn t need public
suggestion } catch ( final TYPE_3 | TYPE_4 e ) {
! [ codacy ] ( ) issue : [ local variable VAR_2 declared final ] ( )
constructor signature changed
passing VAR_2 attribute
don t need _CODE_ ( ) ? I thought keys saved lowercase keystore
please log VAR_2 ID
please log bundle ID data
put assignments order s clearer
I catch necessary lines } catch ( final Exception e ) { throw new TYPE_10 TYPE_11 VAR_2 TYPE_12 ( e ) ; }
a simple expression : METHOD_2 ( ) forEach ( group - > METHOD_1 ( VAR_1 group ) ) ;
replaced _CODE_ ( ) forEach ( group - > cache VAR_1 ( group ) ) ;
curly brackets line
usereturn _CODE_ map ( STRING_1 VAR_3 METHOD_2 ( ) STRING_2 VAR_3 METHOD_3 ( ) + ) ;
shouldn t test fail scenario ? I pass code
return ( VAR_1 startsWith ( STRING_1 ) ) ? VAR_1 METHOD_2 ( STRING_1 TYPE_1 VAR_4 ) : VAR_1 ; a style
I existing METHOD_3 call new METHOD_1
event fired a delete operation * * METHOD_3 * * method validating
need log
set final
builder a separated class asnew TYPE_9 ( ) _CODE_ ( page ) user ( user ) request ( request ) build ( )
set final
shouldn t removed TYPE_2 METHOD_2 ( ) ;
a constant
need null check ? I don t
! [ MINOR ] ( severity : MINOR ) reorder modifiers comply java language specification [ ! [ rule ] ( ) ] ( )
! [ MINOR ] ( severity : MINOR ) missing curly brace [ ! [ rule ] ( ) ] ( ) ! [ MINOR ] ( severity : MINOR ) statement allowed line 2 statements line [ ! [ rule ] ( ) ] ( )
! [ MAJOR ] ( severity : MAJOR ) assign magic number INT_1 a - named constant constant instead [ ! [ rule ] ( ) ] ( )
consider ImmutableList
logic a object concern separated
want constants constant left side assystem_folder equals ( METHOD_1 ( ) )
return defensive copy new Date ( VAR_1 _CODE_ ( ) ) immutable
! [ MINOR ] ( severity : MINOR ) immediately return expression instead assigning temporary variable key [ ! [ rule ] ( ) ] ( )
! [ BLOCKER ] ( severity : BLOCKER ) correct | || [ ! [ rule ] ( ) ] ( )
! [ MAJOR ] ( severity : MAJOR ) return empty collection instead null [ ! [ rule ] ( ) ] ( )
! [ MINOR ] ( severity : MINOR ) returns a string s need call toString ( ) [ ! [ rule ] ( ) ] ( )
! [ MINOR ] ( severity : MINOR ) replace lambda a method reference ( sonar java source set assuming 8 greater ) [ ! [ rule ] ( ) ] ( )
reduce ( null ! = VAR_2 ) ? VAR_9 METHOD_2 ( VAR_2 user false ) : null ;
throws Exception removed
change return request ! = null ? METHOD_1 ( request VAR_1 user ) : null ;
please instead a debug s change error register OSGI want noisy reason
want _CODE_ list ( TYPE_1 VAR_2 TYPE_2 VAR_2 ) ; a java util Set faster a java util List
I change areturn ( null ! = VAR_2 ) ? VAR_2 METHOD_3 ( VAR_1 session ) : true ;
METHOD_4 ! = null
shouldn t report exception
TYPE_6 a class attribute instead instance static
transform return null changed need unchange _CODE_ ( ) throw a TYPE_4 VAR_1 isn t present database transform METHOD_3 throw errors prevent method returning a valid rule
rm println
a raw string need String format
I assertNotNull ( ) please
odd mix calls METHOD_2 ( ) direct access VAR_2 method
simplified returning immediately null - save indent block
final
new Date ( ) METHOD_2 ( ) replaced System currentTimeMillis ( )
copied fix m_ references : )
revert
Optional return null Optional ( ) Optional empty ( ) instead
synchronized safely removed method stateless suggestionpublic static TYPE_1 METHOD_1 ( String VAR_1 String VAR_2 String VAR_3 ) {
shouldn t store result new TYPE_1 ( ) instead returning a new
nxos JTI check zero default
immutable allow manipulation _CODE_ class
consistency
unused
shouldn t new rules lowest position ( highest priority )
suggestionreturn getInstance ( ) ;
AFAICT initialization ? don t need variable
update METHOD_2 ( ) method includes objects _CODE_ ( ) check host I missed originally
switch single - arg constructor pass instance builder return new TYPE_1 ( )
m_
usage m_ weird I d omit
flip location id systems location a grouped jaeger UI
access properties method don t mix
need distinguish computed / enriched static properties return null _CODE_ getProperty ( _CODE_ VAR_2 )
put TYPE_2 METHOD_1 ( ) beginning method ? easier read
missing substitutions { } s _CODE_ error ( STRING_1 VAR_1 val ) ;
cleanup bundle destroyed a VAR_3 hook
m_ redundant
need call METHOD_2 ( )
simplified return VAR_1
line 147 148 redundant
class wrong instanceof comparison _CODE_ generated equals want _CODE_ boolean equals ( Object o ) { ( = = o ) return true ; ( o = = null || getClass ( ) ! = o getClass ( ) ) return false ; ( ! super equals ( o ) ) return false ; TYPE_2 = ( TYPE_2 ) o ; return TYPE_3 equals ( VAR_4 VAR_4 ) ; } suggestionif ( ! ( obj instanceof TYPE_2 ) ) { return false ; }
duplicate 3 lines code ? METHOD_1 ( TYPE_3 ) method instead
member variables class scoped unnecessarily a style preference pointing true a couple other classes PR
suggestionalarms forEach ( VAR_3 - > VAR_2 add ( new TYPE_2 ( VAR_3 ) ) ) ;
VAR_1 retrieved transaction i e : _CODE_ VAR_5 = new TYPE_2 ( VAR_3 VAR_6 VAR_2 ) ;
debug warn
eliminate line 236 move condition && line 235
I suspect locking code needed VAR_1 t change safe unconditionally return delete 108 113 replace : return VAR_1 ;
short version closure a liner { } needed
reason add prefixes ? redundant member variables prefixed m_
VAR_2 instance thread - safe declare a member variable instead recreating everytime
super constructor ? super ( VAR_2 VAR_3 )
redundant a variable prefixed m_
need VAR_3 5 seconds
a reason java util logging instead org slf4j logging ? usage String format combination logging odd
I condition
call METHOD_2 ( ) = = null returns true
a note METHOD_1 returns VAR_3 = TYPE_3 METHOD_1 ( context ) instead lines
System err - > LOG trace
stopping poller check poller null I d consistent check METHOD_2
a reason getClass ( ) instead instanceof instanceof restrictive choice
METHOD_1 ( ) collapse ( ) methods catch TYPE_2 ? addition METHOD_7 ( ) sense element clicked
pass VAR_3 map
shouldn t close TYPE_2 METHOD_3 ? pass File TYPE_4
pre - compute instead ? VAR_1 immutable set constructor
_CODE_ ( ) necessarily node s location
lets - throw a RuntimeException instead
shorter : filter ( item - > ! METHOD_3 ( item VAR_3 ( ) ) )
change TYPE_3 auto refresher logic _CODE_ instead
refactored VAR_1 = STRING_1 equalsIgnoreCase ( table )
s remove TYPE_1 ( String ) constructor
kinda a duplicate VAR_1 METHOD_3 ( ) method a reason VAR_1 another element
a String need String valueOf ( )
kinda a duplicate VAR_1 METHOD_5 ( ) method a reason VAR_1 another element
METHOD_1 returns object lines rewritten form : VAR_2 = TYPE_4 METHOD_1 ( VAR_2 ) ;
avoid TYPE_1 API byte [ ]
debug
improve readability return optional METHOD_2
List
NULL TYPE_3 ( ) equals ( ) objects equals ( TYPE_3 ( ) ) TYPE_1 valueOf ( )
VAR_3 variable instead recall METHOD_2 ( VAR_1 ) method
instead null c - > { } remove null checks ( VAR_3 ! = null )
don t pass empty TYPE_2 pass null legacy class a nanoseconds faster : )
boolean instead Boolean
error / warn log level
reason validation
don t need a null check STRING_1 equals ( VAR_1 ) enough true return VAR_1 toString ( ) continue METHOD_2 important case decide handle null values differently won t fix places
more specific ( IOException ? )
need call setText ? set a couple lines
strange parentheses ( VAR_3 ) a cast
need call super METHOD_1 ( )
Exception redundant
options t populated TYPE_1 _CODE_ ( true )
don t need slightly ? check data instance List call VAR_1 ( ) TYPE_1
reason covered previous Assert VAR_2 ( ) return boolean removal result
METHOD_2 ( )
travis doesn t : > task : spring - rabbit : _CODE_ [ ant : checkstyle ] [ ERROR ] / home / travis / build / spring - projects / spring - amqp / spring - rabbit / src / main / java / org / springframework / amqp / rabbit / core / _CODE_ java : 340 : 33 : reference instance variable logger needs [ _CODE_ ] chances fix merge ? thanks
error closing debug ? 🤷‍♂️
safe obtain a property container callback call earlier application lifecycle
Assert _CODE_ ( ) VAR_3
logic done delegating METHOD_2 ( ) isn t
asesrt VAR_6 ( ) doesn t work
guys replaced a single METHOD_3 ( TYPE_1 [ ] : : new ) map ( ) a method reference : map ( TYPE_1 : : new )
_CODE_ ( TYPE_1 advices )
I suggest making method synchronized
t cache result calculations method VAR_2
thank fast turnaround ! assertNotNull ( ) NPE a VAR_2 METHOD_2 ( ) please fix list update copyright current year - 2002 - 2017 merge
don t method calls ; previous code bad ; generally clean modifying code
I safety clear code instanceof TYPE_2
I revert change TYPE_2 base64 default
DITO
VAR_8 null I agree VAR_7 channel fully depends TYPE_1 VAR_7 VAR_8 s modify avoid a noise : ! [ potential_npe ] ( ) provide some message event downstream : consumer _CODE_ ( consumer + VAR_7 + canceled due + message ) ; _CODE_ ( _CODE_ true null ) ; minor : need TYPE_2 prefix VAR_7 channel
DITO Arrays asList ( )
I m replace method references e g : map ( : : METHOD_2 ) )
mind explaining code a bit ? I guess global appenders / loggers problems aren t some public API constant remember String literal
I overhead I a good testing I ll recheck test tasks IO merge
solution weak I understand classes part infrastructure called order filed null don t call _CODE_
declaration initialization splitted
I need synchronized double check
I understand _CODE_ issue removed target = null ;
isn t enough iterate ? METHOD_1 ( ) called - _CODE_ ( )
state A single null argument clears collection feels a bit weird clear list passing new TYPE_1 [ 0 ] ( TYPE_1 ) null disallow passing a straight null a utility method _clearadminsthatshoulddeclare ( ) _ due more complicated behavior varargs add some _CODE_ examples explaining reset list
great ! remove else { } stanza ; executed run thanks
put a finally
il reste sysou de trop
C est vraiment général comme catch est - ce y a moins de le rendre spécifique
_CODE_
_CODE_ METHOD_2 ( ) METHOD_3 ( ) throw Exception logging ? I changed _CODE_ print stack trace properly [ PR ] ( ) wouldn t necessary
entry null
I cleanerpublic long size ( ) { return VAR_1 ; }
unnecessary change
add constructor parameter TYPE_4 _CODE_ ( )
breaks contract HashMap allows key null StringUtils VAR_1 ( null ) throw NPE
some ideas other assertions 1 ) verify split evenly distributed i e 10 tasks 2 ( 20 ) 4 tasks 3 6 tasks 2 ( 24 )
suggestionprivate static void METHOD_1 (
I check VAR_3 = = null
log level error instead warn
add check _CODE_ ensure autoscalers duplicate category aren t provided fail ? a case user making error configuration
package _CODE_
I thought java guaranteed object arrays start null s
private
I want VAR_12
throw NPE _CODE_ true I t called a hot loop - wei deal I potential NPE other aggregators switch a primitive class getters simply cast local variable
I don t _CODE_ number requires running pass running failed test fail increasing _CODE_ test slower retrying intermittent failure I a PR fix issue trouble intermittent failure
format missing _CODE_
minor : uri getPath ( ) more return decoded version uri toString ( ) URI - encodes won t matter call site good form
unit test coverage missing method
supporting unsplittable firehose s future work
add a version TYPE_3 parse takes _CODE_ providing timestamp dimension specs common
_CODE_ complaining raw types herereturn new TYPE_2 < > ( iterator ( ) ) ;
original constructor delegate new i e : javapublic TYPE_2 ( Map < String Object > VAR_2 TYPE_1 VAR_3 ) { ( VAR_2 VAR_3 METHOD_1 ( ) ) ; }
ArrayList remove ( ) internally moves positions remaining elements happen row case expensive VAR_1 won t large general I suggest iterator list instead modifying list javapublic E remove ( int index ) { _CODE_ ( index ) ; _CODE_ + + ; E _CODE_ = _CODE_ ( index ) ; int _CODE_ = size - index - 1 ; ( _CODE_ > 0 ) System arraycopy ( _CODE_ index + 1 _CODE_ index _CODE_ ) ; _CODE_ [ - - size ] = null ; / / clear GC workreturn _CODE_ ; }
package - private s supposed general
LGTM a warning line :
I shouldn t cache key
simplified return VAR_2 + + ;
feels error log i
I avoid extra lookup map VAR_3 METHOD_2 ( VAR_1 VAR_4 - > new ArrayList < > ( ) ) add ( VAR_2 ) ;
please fix TYPE_1 METHOD_2 ( collect ( ) ) I ve opened #8241 fixing generically
s confusing method doesn t return false _CODE_ ( )
shutting executor explicitly set null more friendly GC
s TYPE_1 _CODE_ ( TYPE_4 : : METHOD_4 )
setting null
check args length 2 3
( _CODE_ ( ) ) don t strictly need public package - private ( remove modifier ) currently tests annotating a good practice
suggestionprivate static String METHOD_1 ( String VAR_1 )
a preconditions check constructor I a error message tells user intervals VAR_2 set current error message I don t accurate ( request payload invalid VAR_1 [ %s ] VAR_2 [ %s ] atmost valid provided ) check validity supplied values presence
don t need add cache key - - aggregation matter idea changes meaning effect operator part cache key other stuff VAR_5 some extra information _CODE_ job
private instead protected preferred
synchronization - parallel VAR_1 loading impossible
highly suggest isEmpty
nested ternaries = 😭 please consider normal s
I synchronization pattern change I m confused accomplish ? VAR_1 created threads initialize VAR_1 simultaneously doesn t strange
iteration VAR_2 values ( ) similar other places PR
prints VAR_1 entrySet ( ) iteration ( VAR_2 forEach ( ) call readability )
add annotation method
VAR_1 = true synchronized block ( case exception )
message consistent condition SQL planned precondition met place _CODE_ ( ) called a preceding call _CODE_ ( ) _CODE_ ( ) method call _CODE_ ( ) return earlier call _CODE_ ( ) done changes needed
_CODE_ instead _CODE_
code won t work timestamps epoch I s a bit clever stick working milliseconds timestamps ISO8601 strings
package - private
line longer 120 cols please - else
jvm / _CODE_ / bytes / VAR_3
bother locking size returned immediately invalid ? aka some other thread changed size
doesn t need synchronized
explicitness doesn t add a lot cast throw _CODE_ log wrong class current code
please replace boilerplate pattern a single method METHOD_3 ( String supplier < _CODE_ > ) thoughout code
VAR_2 _CODE_ ( ) result empty array ? currently a discrepancy METHOD_1 ( ) _CODE_ ( ) suspicious reading code
I guess task null _CODE_
don t need ( TYPE_2 e ) e sufficient
warn
safe assume _CODE_ string format TYPE_3 allows ? don t instead String
InterruptedException rethrow exception interrupt thread properly
please add exception log warn ( e STRING_1 + STRING_2 VAR_6 METHOD_4 ( ) ) ;
missing
I teamcity complaining Exception thrown
unnecessary cast
VAR_2 t null ( VAR_2 ! = VAR_2 )
VAR_2
assertEquals
worth considering adding additional constructor TYPE_3 annotation PR a bit lighter a footprint modify tests passing null
return ( o instanceof List )
( o instanceof Map ) || ( o instanceof TYPE_1 )
VAR_1 a null check constructor _CODE_ call needed
please don t change initialization order good aligned definition order
toString ( ) valueOf ( query VAR_1 ( ) ) a weird writing String valueOf ( query VAR_1 ( ) ) a strange java feature lets call static methods ( valueOf ) methods specific objects please replace
VAR_5 needs a field class rest removed ? case meant class JSON serde please add ANNOTATION_1 annotations fields create getter methods
_CODE_ skipping lineage check ? I thought more segment interval s running - incremental - publishing mode
else VAR_1 < 0
please add VAR_1 log
duplicate line
i mapping escalator type authenticator / type authenticator / type necessarily correlated ( I kerberos authenticator george I wanted ) s restriction authenticators type ( sense some hypothetical implementation running instances a namespace similar concept sense ) a mapping a specific escalator instance authenticator instance I suggest adding property
doesn t TYPE_3 METHOD_3 suppress exception a RuntimeException error I s reason throw specific error types suppress others I assume s a bug instead _CODE_ METHOD_3 ( VAR_1 ) ; throw new RuntimeException ( VAR_1 ) ; I unrelated patch s wrong nearby code fix
I a buffer leak ( code leak _CODE_ ) _CODE_ METHOD_3 interrupted s waiting more objects objects popped objects returned pool - lost
call METHOD_1 ( VAR_4 VAR_2 ) easier code maintenance
0 current implementation suggest throw exception s 0 remove VAR_9
conventionally include VAR_11 = constructors initializing fields doesn t matter correctness s conventional style codebase
simplified VAR_2 = TYPE_1 METHOD_1 ( VAR_2 STRING_4 ) ;
please break a line
return boolean expression
_CODE_ ( U capital )
I specific Double / Long
Double * variant class object = = null ? null
optimize perform row VAR_2 ( )
iterator supposed read array _CODE_ I checked token a TYPE_2 START_ARRAY
checked exception IOException propagated please don t catch types exceptions propagated
please change new RuntimeException ( e ) ( )
method private
private
recoverable info
STRING_2 equals ( config ( STRING_1 ) )
needed VAR_2 filtered
nullable
I suggest move logic place a static factory method TYPE_2 TYPE_2 s constructor private TYPE_3 class package - private Long float
I don t check needed METHOD_3 ( ) implemented = = null check line throw _CODE_ Assert check needed assertion check exception doesn t happen long / double
need check line 257
please review rest _CODE_
please align Double ( protected )
current methods implemented return false
message null add a guard check
shouldn t pass null ? overload
code METHOD_3 ( ) TYPE_4
breaks symmetry equals ( ) subject _CODE_
new TYPE_2 [ 0 ]
locks needed build merge aggregators alike
needed ? I s inject
VAR_4 included
please add VAR_3 exception
throws Exception reduced throws IOException
reduced throws IOException
reduced throws IOException
logging helpful
lead noisy logs debug
explain supports ? return result matter VAR_2
avoid clogging majority tests authorization result a parameter full overload ( provide a planner config context ) basic overload ( sql _CODE_ _CODE_ ) stay
return ( String ) VAR_2 ;
( VAR_1 length ( ) > 1 && VAR_1 METHOD_2 ( 0 ) = = CHAR_1 ) { eliminate other condition checking VAR_1 isEmpty ( )
original idea delaying checks actual usage disable _CODE_ want druid nodes able deserialize _CODE_ - based objects example _CODE_ aggregators ingest tasks disabling _CODE_ want able view completed tasks task table metadata store I s worth able create objects _CODE_ disabled _CODE_ compiled
left input ( sort rel ) _CODE_ returns 1 element calcite concerned replace VAR_3
pointless assignment
don t need public
don t need class qualifier
VAR_2 null
I s clearer add else { return true ; }
public final
suggest debug level
VAR_1 _CODE_ ( ) needed anymore
replace forEach
simply new RuntimeException ( e )
variable needed return statements else blocks
VAR_1 ( ) designed called indirectly e g a method constructor accepts Object args case I point instead StringUtils format ( )
change impl METHOD_1 ( job VAR_1 ( ) )
a I find inverted logic hard reading code I justif ( VAR_3 = = null ) { return false ; } return VAR_3 VAR_5 METHOD_2 ( VAR_2 METHOD_3 ( ) ) ! = null ;
TYPE_1 METHOD_1 method exists lambda direct obscure write = = null
null expected suggested check explicitly operate exception handling antipattern java
I don t understand I METHOD_5 ( bitset ) VAR_3 * VAR_4 ( records ) space
simple max ( TYPE_2 METHOD_3 ( TYPE_1 : : METHOD_4 ) )
Double VAR_2
TYPE_3 METHOD_2 ( VAR_1 ) - null TYPE_2 equals ( ) designed accepts nullable arguments s confusing TYPE_3 METHOD_2 ( VAR_1 ) equals ( TYPE_3 METHOD_2 ( VAR_2 ) ) + Double Long
similar suggested TYPE_3 METHOD_3 ( key ) METHOD_2 ( ) + Double Long
remove local var
divide double
please annotate
crash bad format string
crash bad format string
crash bad format string
crash bad format string
crash bad format string
want add IOBE
crash bad format string
crash bad format string
crash bad format string
crash bad format string
method private don t need return TYPE_1
? strings _are_ equal faster strings aren t slower I d guess comparisons strings equal code perform
change omits segments total replicants 0 I shouldn t change behavior
log warn returning null instead a code 403 ? code 403 more sense s don t return - switch return type Response - define a _CODE_ _CODE_ < _CODE_ > manner _CODE_ ; throw _CODE_
log warn ( getMessage ( ) )
don t create a new query object VAR_6 - null return
avoid warnings construction constructors called deserialization contexts useful another check task
VAR_1 = false ? simpler
s ? a _CODE_ instead ? s preferred temporary directories files needed tests
shouldn t happen construction firehose factories constructed semi - frequently ( anytime task objects deserialized ) doesn t necessarily hits disk network deferred firehose connected
a _CODE_ instead
equals check brittle I d a check a query context key alternatively _CODE_ _CODE_ modify query remove post - aggregators downstream _CODE_ outermost node ( typically broker ) ignore post - aggregators done overriding _CODE_ _CODE_
duplicates stream
method call check done TYPE_3 METHOD_2 ( )
need complicate control flow suggested return VAR_2 METHOD_2 ( 0 TYPE_3 VAR_6 ) ; ( )
stayed final
ImmutableList cheaper stores key a field
METHOD_2 ( ) > VAR_2 ? > = _CODE_ able proceed state check state some kind START_EXITED_ * fail succeeded
VAR_1 descending order class
check Collection
need close stream
catch block needs moved line
i implemented line return METHOD_2 ( ) || TYPE_1 METHOD_4 ( ) ; add VAR_3 METHOD_3 ( ) = = Integer VAR_4 check TYPE_1 METHOD_4 ( )
needed automatically zeroed _CODE_ ( ) needed
METHOD_2 null ? poll
suggested getClass ( ) METHOD_1 ( ) more random
return null callers deal null want default VAR_1 _all_ cases deserializing TYPE_1 unforeseen ideal behavior
move VAR_6 place file output stream created ? javafinal TYPE_2 VAR_5 = VAR_6 METHOD_2 ( new TYPE_2 ( VAR_3 ) ) ; work
intentionally omitted index check
s check negatives instead - 1
need call METHOD_1 queue synchronize start
suggest final
remove method simply _CODE_ METHOD_2 ( ) method called
don t need toString ( )
close ( ) throws IOException consume IOException VAR_1
throw METHOD_1 instead callable ? s a failure immediately
minor : pass time column selector field selector consistent buffered aggregator
instead super
parser parse ( ) marked nullable saner return _CODE_ ( ) remove check _CODE_
org junit rules _CODE_ ( expected = TYPE_8 class )
count parameterized
expect happen a problem indicating a bug ? s happen shouldn t log info noisy logs a bug please bump log warn
I move top instead
ll want VAR_3
VAR_2
private
_CODE_ _CODE_
formatting
formatting
original author numbers nice
return METHOD_1 ( key VAR_1 )
VAR_1 avoid extra local variable ? shorter confusing
container - null
decrease _CODE_ throw exception possibly _CODE_ sync actual allocated buffer
readability sake increments atomic method call
thread safe
method call
throw exception instead a TYPE_2 null
double ; ;
I don t TYPE_4 METHOD_3 needed input VAR_1 ; input shouldn t empty ( _CODE_ aren t passing empty strings predicate ) other callers _CODE_ don t
_CODE_
i don t needs propagated finding VAR_7 effort
need Set
add method signature
TYPE_1 instead creating a new class ? doesn t custom else / set region
debug msg valid anymore
simply _CODE_
package - private
need IOException
return storing VAR_4 local variable
private ? RTR doesn t subclasses I
I set conditions a bit hard read change : ( child ! = null && child VAR_1 ( ) = = TYPE_1 VAR_2 ) { return TYPE_1 VAR_2 ; } else { return VAR_3 VAR_1 ( ) ; }
extractionfn null
creating a set necessary a collection enough cases METHOD_1
util methods private
u change ( TYPE_1 ) VAR_3 METHOD_3 ( VAR_2 _CODE_ class ) ;
VAR_1 null
METHOD_4 ( VAR_1 VAR_2 false ) ;
format string - empty String format ( ) empty TYPE_1 METHOD_1 ( ) want instead ? String format ( format TYPE_1 METHOD_1 ( ) ) ;
check required ? point length greater 0 return null length 0 line 62 TYPE_1 METHOD_1 ( VAR_1 )
true index = = 0 allow optimizations case
put VAR_5
= = null a valid case
retry transient errors ? want a METHOD_2 able retry ( overwrite prior a partial success ) feasible
dothis VAR_2 = TYPE_2 METHOD_1 ( VAR_2 STRING_3 ) ; VAR_3 = TYPE_2 METHOD_1 ( VAR_3 STRING_4 ) ;
necessary new TYPE_3 ( )
size longer needed
METHOD_3 a finally block remove { } finally { } block
private static
s fixing a bug datasketches
storing config VAR_2 period enough - doesn t s a need store
typically done a _CODE_ implementation wires json config puller ( io druid storage azure _CODE_ a good example )
greater 0 else % operation interesting
key strings public static final String class
necessary create unique table _CODE_ create a unique database test
remove complicate life reason : )
I TYPE_4 existing constructor METHOD_1 ( id VAR_3 ) id _CODE_ adding a new ( id VAR_2 _CODE_ interval ) constructor fine
I wasn t
ANNOTATION_1 means ? thought default
thought return VAR_2 ! = VAR_2 || ! map equals ( map ) ; equivalent ! equals ( )
duplicated TYPE_4 METHOD_2 ( binder TYPE_5 class )
able thread dumps - terminating processes
required
instead putthis VAR_2 = ( VAR_2 = = null ) ? : VAR_2 ; constructor _CODE_ replace line#191 VAR_2 = super _CODE_ ( )
i throw NPE _CODE_ null
a rewrite strategy glance weird a hold required necessary some reason
unnecessary optimization
I removed null dimensions specs
I don t need check null precondition _CODE_ instances called a null query
some more information magic numbers
a requirement simply chain methods more _CODE_ METHOD_2 ( VAR_6 METHOD_3 ( VAR_1 ) ) METHOD_4 ( new TYPE_4 ( VAR_3 VAR_4 ) ) ;
I s a reason auto - box
I need a blob previous state E g modified a rule previous rule
I overkill memory allocation revert model 0 6 a thread safe data structure
null values treated empty string
I changes behavior empty filter return true returns false
s move return statement don t need extraneous check
i a validation query
need create a set
a list iterable
common place ( broker level ) add unioning query VAR_1
minor nitpick Arrays asList ( )
copy
configurable ? configurable
need a file
moving exception catching { } area intentional
isn t needed
formatting
squigglies ftw
safe clean exception thrown iterating complete iteration resources cleaned sequence interface provides ways ensuring closed _CODE_ process ( ) s a cleanup method guaranteed called
accessing fields generally frowned idiomatic java I s annoying extra couple keystrokes appears TYPE_1 object encapsulating state
s kinda weird pull configuration property s code needless s fix configuration
I d figure earlier add a _CODE_ ( Set < String > ) method _CODE_ verify fields wants recursively other _CODE_
I wrapper shouldn t a close ( ) method instead making people stored closed
multiple semi colons ; ;
purpose ( directory need VAR_2 ) I guess fine
I add
I don t need set VAR_4 VAR_5 ( VAR_2 id ( TYPE_3 ) null ) ;
testing console log works ? delete don t need
please remove info public API
VAR_1 thread safe
VAR_1 thread safe
need a synchronized set
synchronized ( VAR_2 ) synchronized required
spec
I return TYPE_2
I throw IllegalStateException instead TYPE_1 s inconsistent illegal state users shouldn t TYPE_1 LC thrown expected
TYPE_1 thrown method ? return void throw TYPE_1 instead
need METHOD_2 node system provider
VAR_1 null NPE d point VAR_3 happen a type allows null keys ( don t )
s PR issue metadata N ACS _CODE_
METHOD_3 accept optional return false s present
cast dangerous : optional stored
_CODE_
I opinion want ? throw exception returning null ? ( I haven t finished reading I answer rest diff : )
I don t sense optional TYPE_1 signature METHOD_2 method Optional working API I m wondering METHOD_2 belong TYPE_4 class instead TYPE_3 interface
new ArrayList < String > ( ) ;
I initialize objects I tend differently : initialization handled component initializable another ; initialization forgotten
want remove a link account allow set null remove TYPE_1 assertNotNull test
don t check VAR_1 checked _CODE_ method
check useless VAR_1 null
block repeated extract bit
simply turn ! isEmpty ( )
VAR_3 ? doesn t related resource changes
I idea remove ? s change a time account
I passing configuration sufficient couldn t ? mirror s done identity provider
$ a required convention s part regexp parameter METHOD_4 method String url1 = ( url1 METHOD_4 ( STRING_2 / ) ) ; output : works : String url1 = needed fix proposed fix : VAR_1 = VAR_2 METHOD_4 ( STRING_2 STRING_3 ) ; doesn t work generates : illegal group reference : group index missing
METHOD_1 initialization
VAR_2
code conventions I brackets else clauses
I condition ! = null list set null
lead more 1 client created create called concurrently simple method synchronized
lead a huge amount data memory ; readonly
duplicate VAR_2 ( )
smaller 1
commit good method misleading - doesn t set field belongs a probe
won t produce awful lot warnings method ? I thought log finest - disabled default option enable needed
need declare unchecked exception
need loop
discussion sake lets assume 10 instead 100 chances 80% read 20% put array : [ put put read read read read read read read read ] find operration a : int index = VAR_2 METHOD_2 ( array length ) ; return array [ index ]
personal flavour ; object initialized class constructor I normal constructor cleaner shorter especially some initialization logic normal constructor a good rid don t
aren t introducing calculation bug
metric match timeseries
IllegalArgumentException a runtime exception need declare
protected
static technically
throw exception s arg
I code function inlined METHOD_3
a magic side I d put RHS parens
case thrown exception double count a single VAR_3 exception thrown currently prometheus scrapes target fail due duplicate metrics I double counting preferable failing scrapes entire target
log t live
( List ) cast redundant
final
appears a useless check - null
statements folded : return ( id = = state id ) && ( count = = state count ) &&
log debug VAR_3 exception ignore
tabs
collapse statementsif ( VAR_1 && ! METHOD_2 ( ) ) {
method public
changes default behaviour lead results a consumer updates mp3agic future decision prefer id3v2 id3v1 consistent library another pull request signed
remove annotations leave remove METHOD_3
t method target type
won t work target a _CODE_ return File object _CODE_ ( ) METHOD_1 ( ) ( change signature )
remove line TYPE_1 reuses METHOD_2 super METHOD_1
file VAR_4 ( ) called block TYPE_1 won´t release lock
VAR_2 null ? s invert ( VAR_4 equals ( VAR_2 ) )
compatible
extension internal class good added archive appender removed
arg constructor instead
returned result addAll returned a bit more meaningful ( historic ) boolean API a bit weird
unclear circular dependencies objects toString methods ( problem ) safer print names
unrelated change finally block a crazy amount thread reset state
other signature ( exception ) ? doesn t TYPE_5 thrown ( remark )
change free definition VAR_2 private final List < TYPE_1 > VAR_2 ; avoid copy
TYPE_1 valueOf ( )
simplify ( = = )
add brackets : ( VAR_2 ! = null ) { return false ; }
I expected : called [ running payment operations ] ( ) _only_ want fetch deleted payment method operations shouldn t false
new flag VAR_3 passed ( ) _CODE_
new flag VAR_3 passed ( ) _CODE_
new flag VAR_4 passed ( ) _CODE_
new flag VAR_5 passed ( ) _CODE_
I prefer wayif ( VAR_4 hasNext ( ) ) { VAR_1 = VAR_4 ( ) ; } else { VAR_2 + + ; }
a performance difference original code
response VAR_1 ( ) forEach ( ( VAR_2 ) work ? remove METHOD_2 ( )
private static
avoid VAR_6 METHOD_1 case validation disabled
static import
static import
put _CODE_ METHOD_2 ( ) local memory limit errors thrown
check
parentheses ( obj = = null ) ( getClass ( ) ! = obj getClass ( ) ) needed
move VAR_5 = false ; align stack order
static import TYPE_3 TYPE_2 VAR_5
static import TYPE_1 TYPE_2
fail ideally TYPE_3 shouldn t hive types partition handle materialized exchange
TYPE_2 equals VAR_1
s suppress Exception docs : sufficient
work ? METHOD_8 ( )
checking callsites I need catch TYPE_3 _CODE_ method _CODE_ _CODE_ need catch TYPE_2 _CODE_ _CODE_
VAR_3 basically a stub example test write a file some fake key provider set unknown long reader key provider able read file making fake provider actual provider proto
method static
needed handles exception other method
reset ? standard GZIP compression supported ? hard simply support
static import VAR_5 ARRAY_LINES
return
throw some operations
a problem force TYPE_4 METHOD_1 ( Path path _CODE_ _CODE_ ) METHOD_2 files
remove else
change order : ( VAR_2 ) { return } return
purpose checking compatibility _CODE_ TYPE_1 TYPE_1 : : _CODE_ - purpose VAR_3 specific compression method TYPE_1 : : _CODE_ - I didn t understand existing hive compression - codec good enough
lets move assignment
s stripes ? feels initialized empty
instead keeping track VAR_1 _CODE_
passing positioned limited input stream ? ( VAR_4 METHOD_2 ( VAR_2 ) ; _CODE_ ) ? won t need class
change problematic lease doesn t VAR_2 VAR_2 create multiple leases
( VAR_2 = METHOD_1 ( ) ) ;
bug wasn t caught test I suggest improving test ( adding a unit test ) cover case
s / VAR_3 / VAR_3 / _CODE_ prefer reference variables
input null output null _CODE_ automatically annotation
remove returning null
debugging leftovers
return Optional < String > implementation decide present
debugging ? remove
a static map easier
drop
remove
replace map
super ( ( ) - > METHOD_1 ( TYPE_1 ( STRING_1 STRING_2 ) ) ) ;
combine assignmentthis VAR_2 = METHOD_1 ( type STRING_1 ) ;
VAR_1 isEmpty ( )
validated 3 times function
input a valid ipprefix don t need validate
2 test cases belong test method IP_PREFIX VARCHAR input 2 test cases testing behavior IP_SUBNET_MIN behavior casting VARCHAR IPPREFIX
remove
needed ; other readers
s weird increment row METHOD_1 class inheriting offset _CODE_
( position - offset < length && VAR_2 ! = - 1 ) {
put stack
static other helpers
static import VAR_5
a function derived _CODE_ language expose language implementation type
static
static import
static import
compile
private
VAR_5 = METHOD_1 ( VAR_3 STRING_3 ) METHOD_2 ( ) ;
dostream ( VAR_2 ) forEach ( VAR_4 - > VAR_3 METHOD_2 ( ) put ( VAR_4 builder VAR_5 ( VAR_4 ) ) ) ; I don t strong opinions codebase prefer stream API logic simple
I convention days fork TYPE_2 _CODE_ _CODE_ _CODE_ I agree case doesn t necessary ( HTTP covered other tests ) convention doesn t hurt : )
instead popping VAR_2 instead thrift interface async ? don t need handle future don t care result
check METHOD_2 true return VAR_4 ? I feel METHOD_2 a stronger predicate VAR_1
need
current geometries method work additional VAR_2 JTS supports remove ( bit lines 150 - 152
javaif ( VAR_2 METHOD_2 ( ) && METHOD_3 ( VAR_2 ) && METHOD_4 ( VAR_2 ) && ! METHOD_5 ( VAR_2 ) ) { return false ; }
return ( VAR_1 instanceof TYPE_3 ) && VAR_2 METHOD_2 (
static
VAR_2 && Double VAR_1 ( ) filter redundant ; _CODE_ checked - ditto _CODE_
i = 0 ; i < VAR_6
I understand ( _CODE_ = true ) change change
log warn ( e alter table failed ) ;
need create VAR_1 assign / assert code reach point
private
I don t understand change explain
defensive synchronized methods ? 😄
default partitioner default need
ImmutableList builder
don t final method ( a side note : don t final tmp variables )
private
don t a1 a2 variables names ; I d inline VAR_1 VAR_2 - static import _CODE_ void METHOD_1 ( ) { TYPE_1 VAR_3 = new TYPE_2 ( 1 Optional empty ( ) new long [ ] { INT_1 INT_2 } ) ; TYPE_1 VAR_4 = new TYPE_2 ( 1 Optional empty ( ) new long [ ] { INT_3 INT_2 } ) ; METHOD_2 ( METHOD_3 ( VAR_3 0 VAR_3 0 ) ) ; assertTrue ( METHOD_3 ( VAR_3 0 VAR_4 0 ) ) ; }
VAR_5 METHOD_4 returns a list need create empty list elements
order definition TYPE_1
default config
remove
remove
remove
s / / exception / g
remove merging
VAR_3 anymore remove
VAR_1 change I t access needs serialized other methods need synchronized
_CODE_ Builder < TYPE_1 > result = ImmutableList builder ( ) addAll ( VAR_2 METHOD_2 ( ) ) ;
static import
move change previous commit
private
avoid unchecked cast : * List < TYPE_1 > VAR_3 - > List < T > VAR_3 * METHOD_2 : < T extends TYPE_1 > List < TYPE_1 > - > < T extends TYPE_1 > List < T > _CODE_ ( ) ) - > < T > _CODE_ ( ) )
add
call VAR_4
Map < >
private
Map < TYPE_2 TYPE_3 > result = new TYPE_1 < > ( ) ;
ImmutableList ( )
cover : 1 ) function a rule translate ? 2 ) function signature ( example input types ) ? 3 ) function hidden 4 ) simple operators : + - >
private
ImmutableList ( )
change intentional ? means method matter input
private static
else redundant
private
public
VAR_5 t null
private
inline VAR_4 variable
I expect query fail ship_day_month_nulls column doesn t exist
change organized argument false true
I don t need log
I don t need create a table test call procedure fails
s put previous _CODE_ VAR_4 = METHOD_3 ( TYPE_2 ( ) METHOD_4 ( VAR_3 )
aboutjavanulls [ i ] = i % INT_1 = = 0
: METHOD_1
TYPE_5 issue
throws IOException needed other METHOD_1 s
method
apply added _CODE_ fail _CODE_ trouble analyze subquery ( example EXISTIS ( SELECT ) ) a long standing issue current solution desugar correlated subqueries replaced plan nodes issue worth dig scope PR
private
I d inline result variable : TYPE_4 METHOD_2 ( VAR_1 = = null ? Double TYPE_5 : VAR_1 METHOD_1 ( ) ) ;
combine assignmentthis VAR_1 = METHOD_2 ( VAR_1 STRING_1 ) ;
static import
don t aria code - _CODE_
arrange lines alphabetical order : VAR_1 METHOD_3 ( STRING_6 VAR_2 ) ; VAR_1 METHOD_3 ( STRING_4 VAR_2 ) ; VAR_1 METHOD_3 ( STRING_5 VAR_2 ) ; VAR_1 METHOD_3 ( STRING_1 VAR_2 ) ; VAR_1 METHOD_3 ( STRING_7 VAR_2 ) ; VAR_1 METHOD_3 ( STRING_8 VAR_2 ) ; VAR_1 METHOD_3 ( STRING_3 VAR_3 ) ; VAR_1 METHOD_3 ( STRING_2 VAR_2 ) ; VAR_1 METHOD_3 ( STRING_2 VAR_2 ) ;
VAR_1 - > VAR_3 length consistency loop
nitjavacloser METHOD_1 ( TYPE_2 : : close ) ; VAR_1 METHOD_1 ( TYPE_3 : : close ) ;
I expressed a switch statement
nits : static import
nits : static import
a necessary change
super ( TYPE_1 : : METHOD_1 ) ;
delegate call functions - a bit confusing _CODE_ provide suggestion
private
inline METHOD_1
mind a _CODE_ ? - - s basically a template parameter change
I guess want effectively sealed class java doesn t native support mimic reducing visibility constructor making child constructors private exposing factory creation
static
put previous line
I feel don t presto explicitly create a new object parameters
METHOD_2 ( VAR_2 VAR_1 )
index encoded error message denote wrong I assume toString ( ) purpose ? bejavaformat ( STRING_1 )
TYPE_3 stream ( VAR_1 ) collect ( METHOD_2 ( ) ) ; good enough ( assignment VAR_2 necessary )
a static method ? another similar methods _CODE_ put a util class
METHOD_1 ? - - doesn t perform optimization
I add some static imports : TYPE_2 VAR_3 = TYPE_2 METHOD_2 ( METHOD_3 ( VAR_5 ) ) ;
Optional empty ( )
original code style method : private TYPE_1 METHOD_1 ( Optional < TYPE_2 > VAR_1 ) { ( VAR_4 ) { return new TYPE_1 ( VAR_5 Optional ( new TYPE_5 ( ) ) Optional ( new TYPE_6 ( ) ) VAR_1 ) ; } return new TYPE_1 ( VAR_5 Optional empty ( ) Optional empty ( ) VAR_1 ) ; }
drop unnecessary else private TYPE_1 METHOD_1 ( ) { TYPE_1 key = key ; ( key = = null || key VAR_1 ( ) ) { throw new TYPE_2 ( VAR_2 STRING_1 ) ; } return key ; }
expecting destroy ( ) called concurrently method ? key visible threads key VAR_1 ( ) change check
private
check removed
METHOD_1 method needs marked private
move variable closer usage
call METHOD_1
move METHOD_1 statement
finished VAR_5 ? scheduling finished ungrouped execution execution finished grouped execution
line
METHOD_3 ( VAR_3 ) top accessed VAR_4 values ( )
static import
put tests _CODE_ java _CODE_ java class specific case I understand tests other helper methods _CODE_ java specific suit general purposed _CODE_ java a preferred approach refactoring methods a helper class _CODE_ ( )
put VAR_2 parameter a default overloaded METHOD_1
a telescoping constructor a prefix other ? TYPE_3 ( TYPE_1 config ) { ( config TYPE_2 METHOD_3 ( ) METHOD_4 ( ) ) ; }
need explicit null checks parameters marked engine apply default semantics null
ditto checks I don t need duplicate
move null check previous line ( readability )
declaration HashSet
I dojavaelse ( VAR_2 ) { return new TYPE_1 ( VAR_1 VAR_1 true VAR_6 ) ; } else { return new TYPE_1 ( VAR_1 VAR_1 false VAR_7 ) ; } 3 branches easier follow )
static import METHOD_2
I remove else return
I static import METHOD_1
don t Optional instead null
ditto adding _CODE_
need public
static import METHOD_2
static import METHOD_6
don t need check METHOD_3 ( ) guaranteed return a key a trailing slash URI guarantees paths normalized ( double slashes ) METHOD_3 ( ) strips trailing slash check confusing reader puzzle
redundant casting
add { }
unused variable
shorted VAR_1 = METHOD_2 ( VAR_1 STRING_1 ) ;
please remove field references aren t needed required assignments constructor ( consistent assignments required )
VAR_1 METHOD_2 ( TYPE_4 : : METHOD_3 ) ;
update method return Optional < TYPE_1 >
expression lambda L214 ( remove curly braces )
inline VAR_2
VAR_1 parameter I don t need check VAR_1 METHOD_2
reuse overloaded METHOD_1 method passing distribution type Optional empty ( )
VAR_4 confusing put null imply VAR_4 field set null Optional empty ( )
TYPE_5 entire operation ( method ) supported IllegalArgumentException _CODE_
static import
a split
statement redundant - - set VAR_2 true
+ + x > = y t presto code base I put size + + line 156
node VAR_3 ( ) = = TYPE_2 TYPE_5 VAR_5
return TYPE_2 ( VAR_2 ) ;
return VAR_1 stream ( ) map ( TYPE_1 : : getName ) collect ( Collectors VAR_3 ( STRING_1 ) ) ;
public constructor logically part public API class access controlled class level wanted class public wouldn t need change access constructor
remove METHOD_2 performed parent classes expected argument validate s passed generally leave ( duplicating validations )
TYPE_5 s a bug ( forgot call _CODE_ ) wrong JVM s catch METHOD_2 ( ) rethrow RuntimeException _CODE_ ( GENERIC_INTERNAL_ERROR )
hard read please move - null checks
else rendudant
I simplified tojavacatch ( TYPE_3 e ) { throw new TYPE_3 ( ) ; }
static import
create multiple TYPE_4 s method ( another created L299 )
unnecessary else
return else redundant ( return block )
TYPE_6 VAR_5 default warmup mode need
fields order toString equals ? VAR_3
VAR_6 add ( VAR_2 build ( ) ) ;
static import VAR_2
I recommend removing || VAR_1 isEmpty ( ) I more sense a semantic perspective logically VAR_1 populated set ( empty ) wouldn t hurt repopulating yield empty list s confusing arguably incorrect
formatting s hard read figure lines
VAR_4 METHOD_2 ( ) ; returns empty set
I m pretty setting local variable happen synchronized block location set happening ( state machine ) observe stale I d merge change commit creates classes
consider making change commit introduced TYPE_1
private
rid Optional ( _CODE_ )
workers
explain
private
I imagine leftover debugging
needed transaction rollbacked table dropped I ? _CODE_ created table fishy drops
need wrap a TYPE_5 ( call delegated _CODE_ )
I inline error
fail finish ( rename ) table leave a temp table i
JDBC connector INSERT support creating empty table useful I don t remember shorter answer needed
else redundant
( new TYPE_2 ( VAR_2 ) VAR_3 )
that’s simpler there’s benefit _CODE_ a dependency external code case alternative trivial
move catch METHOD_2 ( ) failure doesn t trigger METHOD_3 ( ) T t ; { t = VAR_1 ( ) ; } catch ( TYPE_2 e ) { VAR_2 METHOD_3 ( e ) ; throw e ; } VAR_2 METHOD_2 ( ) ; return t ;
( VAR_2 TYPE_3 ( METHOD_3 ( VAR_3 STRING_4 ) ) ) avoud copy pasting argument checks
inline
TYPE_2 empty ( )
remove
inline
inline variable
dotry ( TYPE_5 stream = VAR_1 create ( new Path ( STRING_4 ) ) ) { assertEquals ( TYPE_7 TYPE_6 VAR_2 METHOD_4 ( ) ) ; }
call VAR_1 METHOD_3 ( ) instead a final variable ? diff perf
I a bit easier read asjavareturn ( VAR_6 ( VAR_4 ) < = VAR_6 ( VAR_5 ) ) ? VAR_4 : VAR_5 ; assignment strange
consider making method return long instead
table ? - move build ( ) separate line
private
need Optional wouldn t code more readable NEEDS_MORE_DATA initial state ? ( i don t insist )
tough call I d don t need s add throw
write entry - >
inline
I write : _CODE_ VAR_2 = VAR_3 ( METHOD_1 ( ) ) ; TYPE_2 VAR_4 = VAR_5 ( METHOD_1 ( ) ) ; ( VAR_2 = = null ) { return ; } ( int i = 0 ; i < VAR_2 METHOD_2 ( ) ; i + + ) { VAR_1 METHOD_3 ( VAR_2 VAR_4 i ) ; } general global checks VAR_2 ! = null outsize loop instead check loop logic clear
return block rid else
VAR_2 METHOD_2 instead VAR_2 xxxx
move top constructor
_CODE_ : : _CODE_ TYPE_2 return nodes output symbols mapped ? wouldn t need map symbols
describe a potential data race s verify s a real issue race some logics jump line 44 line 48 time series : thread2 called _CODE_ _CODE_ = = 1thread1 metadata VAR_4 ( ) ; _CODE_ = = 1thread2 execute finish commit update _CODE_ = 2 exit _CODE_ threadxx called _CODE_ VAR_7 empty _CODE_ = = 2 _CODE_ = = 2thread1 called VAR_7 put ( VAR_6 VAR_5 ) ; enters a unsafe state _CODE_ 1 _CODE_ 2
delete instead setting end_commit_id 2 cases issues : 1 _CODE_ java line 105 _CODE_ called _CODE_ _CODE_ ( ) place presto chunks called a transaction good called fine 2 _CODE_ recover line 205 VAR_1 _CODE_ ( METHOD_4 ( VAR_3 ) VAR_2 ) ; filters end_commit_id rollback delete rollback chunks index index chunks
private
correct ? ensured _CODE_
I inline
IllegalArgumentException
IllegalArgumentException
instead exporting I simply replace future usages Optional _CODE_ ( VAR_1 ) map ( TYPE_1 : : METHOD_1 ) _CODE_ ( null )
static imported
style : drop redundant else s : ( VAR_1 = = null ) { return 0 ; } ( VAR_1 isEmpty ( ) ) { return } return VAR_1 METHOD_2 ( ) ; add a reference ESRI issue explain special handling empty geometries
style : static import TYPE_6 TYPE_5 TYPE_4 METHOD_1 TYPE_4 deserialize
s reason change ? VAR_5 VAR_3 _CODE_ change removes synchronization
necessary fail NPE line general s more important kinds checks holding code fail unrelated place
reverse ( originally ) : state = = TYPE_1 VAR_3 && - - cheaper
methods private
methods private
line logged a lot times a production system s3 select enabled ? ( I trace called _CODE_ _CODE_ ( ) )
ImmutableList ( ) instead VAR_1 additional benefit rid unchecked assignment warning
static import TYPE_4
import VAR_6
import TYPE_3
cast longer needed
import TYPE_3
static import METHOD_2 ( other stream readers )
TYPE_2 closed closing credentials providers ( a dependent resource ) add VAR_1
else redundant
needed constructor checks
create TYPE_1 return step javareturn new TYPE_1 ( VAR_2 VAR_3 VAR_4 VAR_5 ) ;
_CODE_ : javareturn new _CODE_ ( ) _CODE_ ( TYPE_1 class ) _CODE_ ( VAR_1 ) ;
I static
_CODE_ instead
unpack inequality operators i assume assumption higher bits zero ( ) i don t downcast byte needed
change METHOD_3 return TYPE_4 remove cast map ( : : METHOD_3 )
decide class a leaf _CODE_ node ? ( alternative returns ImmutableList ( block position )
static import assert methods line : METHOD_2 ( METHOD_3 ( TYPE_2 class ) METHOD_4 ( STRING_1 ) ) ;
need fully qualified import class
internally private
private
prefer put else return codebase
more explicit : function definition classes ( classes annotated ) define SQL functions - static java function function set classescan define SQL functions static java functions constructor function set classes define SQL functions
else redundant
want support partial streaming aggregations
don t need check aggregations isEmpty ( )
change other _CODE_ methods
need parens lambda parameter I replaced TYPE_6 : : new
a constant shared instances part retained size
consider extracting object building a method emphasize export METHOD_1 naming strategy
needs overridden subclass
static import
lets _CODE_ consistent _CODE_
long VAR_4 ; { VAR_4 = ( long ) VAR_2 METHOD_3 ( VAR_1 position ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable VAR_5 ) { throw new RuntimeException ( VAR_5 ) ; }
brackets extra
VAR_3 remain Optional < List < > >
please inline VAR_1
cast
a join empty VAR_3 operator waits build finishes hours i aware limitation ve discussing summer question - - a problem ? ideally good knowing side join bigger empty VAR_3 side hours - worth build side proud
function appears duplicate _CODE_ airlift _CODE_ instead
static import assertion methods
else redundant
earlier commits enhanced serialization avoid losing multi - types test simplified assertEquals ( VAR_1 METHOD_2 ( ) VAR_2 METHOD_2 ( ) ) ; cases
other switches IllegalArgumentException thrown I a fit
extract a method : stream ( ) filter ( _CODE_ ( VAR_1 ) ) collect
static import - VAR_2 error
&& VAR_1 METHOD_2 ( ) length ( ) > TYPE_2 length ( )
static import
return VAR_1 filter ( TYPE_1 : : _CODE_ ) ;
martin told a trick adding method validation logic ensures benchmark code stays valid benchmark run
static import VAR_4
current merged state - null
s / VAR_1 / result /
I favor lenient approach mask other ( run - time ) problems inability create table I recommend adding overrides relevant connectors cassandra case ( introduce ( a separate preparatory commit ) a _CODE_ method ( facebook presto tests _CODE_ ) )
don t need more
code unnecessary
need flag ? _CODE_ ( don t other methods need needed ? )
unnecessary else
switch instead s
switch instead s
some point switch decimal library represent longs
please squash commits - fix commit message optimize min max geospatial functions generic instead please describe changed resulted performance min max geospatial functions
static import METHOD_2
static import METHOD_2 METHOD_3
static import
private
0 a reasonable initial fields - 1 instead I imagine values stay 0 a long time VM start
queries covered _CODE_ remove
nice fix
I assert methods static
static
expected actual _CODE_ simpler METHOD_2 overload
? other ( e g : include engine / planner ) features
shortcut : TYPE_2 METHOD_2 ( ) METHOD_3 ( VAR_2 ) build ( )
TYPE_3 doesn t feature selection ( a constructor accepting feature selection needed ) superclass ( _CODE_ ) provide a constructor doesn t require passing feature selection
a _CODE_ currently a bug point parallel sort a merge
_CODE_ null
check VAR_2 METHOD_2 ( ) don t check check _CODE_
instead inspecting repeatedly lookup source empty leverage fact information doesn t change instead change ( instead introducing METHOD_2 method ) inspect _CODE_ _CODE_ set finishing flag LS empty
unrelated
existing code unnecessarily roundabout simplified absolute number turn delta _CODE_ METHOD_5 takes delta converts absolute
modify input paratemeter instead please return a copied list
testing point view explicit false ( ) i e tpch connector decides change default presto tests change behavior coverage
static
VAR_2 null
times page _CODE_ called
inline : javareturn VAR_2 METHOD_1 ( page ) ;
inline : javareturn ! VAR_2 && ( ! VAR_1 isPresent ( ) || METHOD_2 ( ) ) ;
VAR_2 length final VAR_2 final doesn t need VAR_1 adding a code analysis tool happy
public connectors extend base won t package
format : invalid offset : + offset
VAR_3 input remove variable : TYPE_2 input = VAR_4 METHOD_4 ( VAR_2 METHOD_3 ( ) ) ;
VAR_1 METHOD_1 ( : : close )
private
VAR_5 final synchronization
spare call ! result
remove synchronized
static import format
TYPE_5 METHOD_3 ( TYPE_3 : : )
query %s failed I m pretty log failures ? don t s a good reason
static import TYPE_4 TYPE_3
s good practice wrap relevant code throw / catch : TYPE_2 VAR_5 ; { VAR_5 = TYPE_2 METHOD_1 ( METHOD_2 ( VAR_4 METHOD_3 ( ) ) ) ; } catch ( IllegalArgumentException e ) { / / negative _CODE_ throw new TYPE_3 ( VAR_6 e ) ; } return METHOD_4 ( VAR_5 toString ( ) ) ;
static import METHOD_2
variable binder
turned lambda
a constructor METHOD_1 method private add a factory method call constructor METHOD_1 state tracking simple
timeout close limit
private ? a factory method
null values omit
i noted operator return TYPE_1 < TYPE_3 >
format categorize types overhead return VAR_1 + VAR_2 + VAR_3 * VAR_4 size ( ) + VAR_4 stream ( ) METHOD_2 ( List : : stream ) METHOD_3 ( TYPE_1 : : METHOD_4 ) METHOD_5 ( ) ;
else needed
else needed
wrong read blocks Type access VAR_1 types data representation a VAR_1
fix METHOD_3 error message
result - > results
( Long ) METHOD_3 ( field ) ; other methods
pass constructor
move config s constructor parameter
unnecessary parens VAR_1 ! = null
private
method good assumptions ( : toString ( ) produces good SQL literal ) private
shouldn t default ( true ) F C : new _CODE_ ( ) _CODE_ ( )
close called cleanup - - exceptional - condition situations job complain
I private package protected
don t need call METHOD_3
throws removed ( other benchmark method )
change order parameters ? airlift s ( e message )
inline assignments
I d initialize order parameters - service location
( VAR_1 ! = null )
add parens
a finally
argument TYPE_1 METHOD_1 ( ) more efficient
put static method instance methods
TYPE_1 constructor dumb put logic instead
parentheses instanceof check necessary
I don t METHOD_5 ( ) call needed I remember adding METHOD_5 ( ) reloading config deterministic update config tests
return = = null ; I don t TYPE_1 METHOD_1 = = null s 1 place presto code
inline
static import METHOD_2
explain local memory doesn t VAR_1 aggregate memory addition I vaguely remember intended add close method local memory context due address race issues
private
line - op
change getter don t need cast
need exception class instantiated
need break multiple lines
METHOD_2 call redundant TYPE_2 METHOD_3 ( new TYPE_3 ( x y ) null ) t return other point remove
static import METHOD_2
I execute VAR_6 set code currently written I m concerned repeated throws a tight loop
technically public s a public class _CODE_ execute ( apparently bypasses privilege checks reflection
static import
private
needed ? executed VAR_1
grouping issues ? I thought irrelevant
throws shouldn t necessary unchecked exception
aren t decrementing VAR_2 ? query queued ( _CODE_ called ) query start running ( _CODE_ called decrements ) query finish ( METHOD_1 called decrements )
I don t final functions code base
consult VAR_2 ? BTW false method called consulted finishing wouldn t good ( produce single - row pages page input )
consider ( TYPE_1 VAR_1 = ) TYPE_1 TYPE_1 instance handle section eliminating - finally ( mind order VAR_1 closes )
reorder hashing follow order equals helps verifying agree order fields s change _now_ safe side
TYPE_5 renamed
VAR_1
[ DONE ] public
needed else block other rewrites
static imports TYPE_2
public
accidentally included unrelated change
method rid Optional ? case Optional empty ( ) method added called
I thought more rewrites
unnecessary else previous returns
static import
static
VAR_4 named terribly wrong long means continue search _not_ modify
obvious correct : ( long ) x * y I rewrite y * ( long ) x x * ( long ) y
static import days
wrong isEmpty ( ) migrated count ( ) = = 1
add another overloaded method a worker count ( similar )
ditto s / i / VAR_2 /
body method facebook presto plugin jdbc _CODE_ a possibility retain reuse ? applies other methods need copy ( i hope don t ) separate copying enhancements separate commits I don t review
methods final t accidentally overridden
comparing a constant object need TYPE_2 equalsjavareturn ! TYPE_3 equals ( VAR_1 METHOD_2 ( node getId ( ) TYPE_3 ) ) ;
Arrays stream ( ) easier collect call a newline : javatry { return VAR_2 METHOD_3 ( new TYPE_2 ( Arrays stream ( VAR_1 split ( STRING_2 ) ) map ( TYPE_3 : : METHOD_5 ) collect ( METHOD_6 ( ) ) ) ) ; }
split multiple lines
s entry entrySet addition write Map Entry : : getValue
call other METHOD_1 method
add parentheses
static imort
don t need check null set constructor
I a bunch investigation a discussion decide VAR_6 return a number ( instead binary ) I m change please change I looked PHP java ( java util zip ) java ( guava ) C + + boost python ( binascii ) ruby ( zlib ) turns general consensus byte order representation result
static import
static import
static import
conditions combine
I m correct TYPE_1 a push a pull mode push mode _CODE_ METHOD_1 pull mode METHOD_5 I m confident METHOD_1 a pull mode want instead I suggest simply call METHOD_5 TYPE_1 modify METHOD_5 properly handle called a ! _CODE_ _CODE_ ( )
isn t METHOD_1 called reached VAR_4
want I m VAR_2 conditions satisfied simple replace original method : javareturn futures _CODE_ ( VAR_1 METHOD_2 ( ) VAR_1 METHOD_4 ( ) METHOD_5 ( ) ) ;
declare
wrong method called more
inline declaration
cast necessary ( others )
remove instanceof checks - doesn t add other implementations _CODE_
replace TYPE_2 METHOD_2 statically imported
a TYPE_3 argument
need { } return s a single expression
please order equals s obvious ( equals required ? )
needs METHOD_2 predicate
missing brackets
technically a test tests passing a false _CODE_ ( )
need declare method final
I don t multiple returning method declare Throwable result assign return
javaif ( VAR_2 METHOD_2 ( ) ! = null ) { VAR_2 METHOD_2 ( ) remove ( ) ; } VAR_2 METHOD_3 ( ) ;
understandable I don t confuse more I JS tests lots people struggling done some nitpicks fix
suggestionreturn METHOD_1 ( ( String ) null null ) ;
suggestionreturn METHOD_1 ( ( String ) null VAR_1 ) ;
catch block necessary necessary _CODE_ : METHOD_5 - required
ensure VAR_1 null prevent NPE
remove block ( l49 - 54 ) moved static initialization
need realize list memory collect obtain a stream iterator ( ) stream forEach ( )
VAR_1 won t null : VAR_2 = config getInt ( STRING_1 0 ) ;
account max - length string max VAR_2 long
final removed override subclass change reverted
final prevents overriding
I m a reviewer FYI TYPE_1 VAR_3 equals ( VAR_1 ) order t throw a null pointer exception constants equals accept null null don t equals function
realm overloaded method METHOD_1 ( ) calls METHOD_1 ( null null ) approach result extra query client counts list clients
_CODE_ write log
VAR_3 METHOD_2 ( ) toString ( ) evaluated redundant debug enabled ( logger _CODE_ ( ) ) { suggestionlogger VAR_7 ( STRING_2 VAR_3 METHOD_2 ( ) ) ; }
revert a Set List negatively impact performance
_CODE_ instead ArrayList
verifying signatures clients added _CODE_ instead a new _CODE_ introduced enable listing supported algorithms properly hard - coding lists
I understand correctly line 70 VAR_3 METHOD_5 ( ) executed system time increased time lines 66 - 70 executed TYPE_1 VAR_1 ( ) called VAR_3 METHOD_5 ( ) return 1 VAR_1 variable happen test fail IMO changed fragile ? instead 1 interval 10 seconds intervals
preserve query parameters original request intentional ? ( e g security related ) reason include query
Set VAR_4 _CODE_ don t
thou hast a typo : )
need catch TYPE_3 catching a general Exception undesired side effects error handling TYPE_3 t happen ( other a bug ) s valid catch ( exception ) log a warning throw
throws IOException
METHOD_1 ( g ) ? a recursive call function nicer solution
isn t present biojava
d throw exception s a problem download a stack trace printed junit won t failure file exception thrown junit report a lot clearer a naive user test understand wrong
throw exception exception reported a test failure junit junit reports errors failures : failures assertion work errors some unexpected exception occurred ( )
TYPE_1 parameterised compiler warnings other occurrences
missing type ArrayList
missing type
TYPE_3 intended cases a symbol a sequence ( nucleotide aminoacid ) recognised a exception case ? people
pr caught eye money objects meant immutable java strings change private money _CODE_ ( ) relevant places instead
nice ! 👍 static I guess
remove
need remove closing bracket STRING_2 _CODE_
close _CODE_ relying finalizers finicky
I a good idea throw exception VAR_1 doesn t match ( add assert )
I remove METHOD_1 shouldn t costly OLTP queries add s hot path
- resources ensure resultsets closed : ( TYPE_1 VAR_4 = VAR_5 METHOD_2 ( VAR_1 ) ) { assertEquals ( STRING_6 + VAR_1 + STRING_6 VAR_3 TYPE_2 TYPE_3 TYPE_4 toString ( VAR_4 ) ) ; }
VAR_6 = VAR_6 missing
I return null timeout I a null TYPE_1 supported occurs ( customizations )
please add _CODE_ util method
call TYPE_2 METHOD_2 VAR_3 null a VAR_3 ? i e put block
invoking blocking code plugin activation wasting instance
update generator remove modifier constructor stays package - private level
stripe totally random need duplicate collection classes ? ( autogen realizing I haven t asked a )
I don t understand VAR_3 clarify
add a variant METHOD_1 takes a _CODE_ list ? thanks
hm I m crazy adding a couple new global helpers place feels - template ( transfer reversals example ) convert - stripe
implemented method : < pre > public static TYPE_1 METHOD_1 ( String id Map < String Object > params TYPE_2 options ) ; < / pre >
called resource
a bother mind giving a generic variable
IMO call other methods shouldn t request s path a call request
I notice other models method don t static mind making instance method consistency ? change private visibility ? I don t s reason leak interface package
I s safe remove
IRL I meant _CODE_ fine unrelated
I realize wasn t smart enough ideally method return null METHOD_2 ( ) METHOD_4 ( ) return null
suspicious package visibility need
static
return more generic List return a concrete ArrayList
I struggled semantics observed - remove - - obvious user _means_ add shipped operation a remove erlang client decided sending _all_ recorded operations surprising solution caveat VAR_2 applied VAR_1
VAR_2 ( ) operation kill cluster production needs trough keys a check health
style points case class existing code a style
a leftover debugging purpose
want creates METHOD_4 object need wrap supplier move METHOD_2 invocation METHOD_5
_CODE_ need add METHOD_4 support TYPE_4 class properly unmerge _CODE_
METHOD_3 need extra runtime check
quick fix processor I figure quick fixes completion proposals ( quick fixes ) strings _CODE_ ( new changes adding test path build path )
need - null filter ? Class METHOD_3 filter null values
private people static method
data null
javareturn ( VAR_1 METHOD_2 ( ) & ( TYPE_1 VAR_2 | TYPE_1 VAR_3 ) ) ! = 0 ;
shouldn t VAR_7 VAR_7 loader load resource ? example VAR_6 url = VAR_3 VAR_8 ( ) VAR_9 ( path ) ; ? VAR_6 url = VAR_3 VAR_9 ( VAR_3 _CODE_ ( ) + STRING_1 ) ; VAR_7 file resource package VAR_7
want trims string case input leading trailing whitespace
written assertThat ( VAR_1 ) METHOD_2 ( ) ;
instead adding a filter operation - null check METHOD_5 test ? java METHOD_5 ( VAR_4 - > ( VAR_4 VAR_5 ! = null ) && ! TYPE_3 METHOD_6 ( VAR_4 VAR_6 ) && VAR_4 VAR_7 equals ( VAR_1 ) ) ;
clean properly please place Builder a - - resource blockjavatry ( Builder b = new Builder ( ) ) { / / test }
VAR_2 toString ( )
javaprivate void METHOD_1 ( String VAR_1 String VAR_2 TYPE_1 VAR_3 String type ) throws Exception { METHOD_1 ( VAR_1 VAR_4 - > VAR_2 VAR_3 type ) ; } private void METHOD_1 ( String VAR_1 function < String String > VAR_2 TYPE_1 VAR_3 String type ) throws Exception {
_CODE_ METHOD_2 ( new TYPE_2 ( constants _CODE_ ( VAR_3 ) ) ) ;
logic correct ? disable ST project
want refresh grid deselectall executed
METHOD_2 more efficient I suggest a plain _foreach_ behaviour more consistent
I default filter attribute filter continue _loadsavedfilters_ set default filter automatically
VAR_5
more I change List raw type List < button > move lines _CODE_ methods
shouldn t executed callback _gettaskevents_
suggestion map ( VAR_4 - > METHOD_5 ( VAR_4 METHOD_4 ( ) true ) )
I guess _getdatasetqueryhelper_ duplicated
need pass values VAR_2
expected parameter _assertequals_
I general avoid remote callback error suppress other errors handle spec management call testing container started
I gave a thought test class I mocking bit needs tested create a new test class _CODE_ mock VAR_4 verify called
lambda style : )
private
I mentioned a potential _nullpointerexception_ gap _else if_ expression expanded : else ( VAR_1 METHOD_2 ( ) ! = null && VAR_1 METHOD_2 ( ) getMessage ( ) ! = null )
tribalyte I class dependend domain ( task process ) simply delegate presenter paramters add place request _TASK_INSTANCE_ATTRIBUTE_ _PROCESS_INSTANCE_ATTRIBUTE_ generic _data - jbpm - id_
tribalyte I moved presenter call _openerrorview_ presenter
swap order numbers
list
static import
easier read collapsed
a default middle arguments ( c tor A B C D E other A B D E ) strange
put other aroundjavaif ( configuration VAR_1 ( ) isEmpty ( ) ) { VAR_3 = TYPE_2 METHOD_3 ( ) ; } avoid double negation - I find a lot easier read
suggestionreturn VAR_1 substring ( STRING_1 length ( ) ) ; a more clear magic numbe INT_1
_CODE_ resource = VAR_2 METHOD_3 ( VAR_4 + VAR_1 ) ; ( resource ! = null ) { return resource ;
LGTM - want double check url a valid param TYPE_1 create ( ) ? I d isnt IllegalArgumentException thrown param s original
instead METHOD_2 line 42 combine line another map call METHOD_2 ( null ) return statement
shouldn t method simply call public void METHOD_1 ( TYPE_1 type String VAR_1 ) converting collection array ( vice versa ) ? codeclimate gonna complain
method final missing @Override annotation AFAICT
trace
trace
null checking requesting locations ? I s request new locations didn t a location GPS provider
I don t need warning level log s change a Log d debugging
branch I VAR_1 final class I planning merge I don t understand setting location manager null a reason ? I apologize slow reviews I haven t week stumbler need update fix need figure users reporting stumbler pausing starting
I generally singletons synchronized TYPE_1 instantiated place s single threaded more a
sense change getInstance ( Context c ) merge _CODE_
remove super ( ) call
instead : return obj instanceof TYPE_1 && VAR_1 equals ( obj ) ;
creating a stream sole purpose retrieving a single element a List a bit excessive I suggest instead : return VAR_2 ! = null ? VAR_2 : VAR_1 isEmpty ( ) ? null : VAR_1 ( 0 ) ;
System strictly forbidden line deleted
ternary operator result nicer code : return VAR_2 ! = null ? TYPE_2 format ( VAR_2 TYPE_3 VAR_4 ) : null
change scope issue
a StringBuilder ( other usages + = strings PR )
shouldn t constants removed source code
change visibility METHOD_1 case
a semicolon
replace withreturn ! ( startsWith ( STRING_1 ) || startsWith ( STRING_2 ) ) add java docs class
calling METHOD_2 ( ) method a good practice ? s a test doesn t need METHOD_2 mocks
want synchronize method
method return map values collection values set
please return a Map a HashMap
return result VAR_2 METHOD_4 instead a variable immediately returning variable necessary I codacy wil complain
write a quick test worked properly ? I wrong I m accumulation results work correctly
instead adding added entry handlers bean _CODE_ other added ( adding activator 19ext module a bit a hack )
removed add handler _CODE_
VAR_3 won t null set Optional
worth returning Optional method instead returning null issues line
check null required ( element instance TYPE_3 ) returns false null element
wizard instance created early cached created requesting VAR_2 _CODE_ ( ) implementation _CODE_ ( ) needed - check VAR_4 TYPE_1 needs method _CODE_ ( ) implementations called _CODE_ ( ) create VAR_4 VAR_4 created TYPE_1 answer created creating
justversion = ( TYPE_4 ) ( ( TYPE_3 ) command ) METHOD_2 ( ) METHOD_3 ( ) METHOD_4 ( ) METHOD_5 ( ) ; check instance _CODE_ initialized other version TYPE_4 error failure done _CODE_ METHOD_1
StringBuilder instead
remove System println please
want method thread safe ( VAR_1 = = null ) VAR_1 = synchronized block
forgot remove println
want swap VAR_3 < = METHOD_2 ( ) VAR_1 < = METHOD_3 ( )
type cache _CODE_ unnecessary complicated
shouldn t new TYPE_5 ( t _CODE_ ( ) INT_1 ) instead new TYPE_5 ( 1 INT_1 )
shouldn t new TYPE_5 ( t _CODE_ ( ) INT_1 ) instead new TYPE_5 ( 1 INT_1 )
shouldn t new TYPE_5 ( t _CODE_ ( ) INT_1 ) instead new TYPE_5 ( 1 INT_1 )
t iterator ( )
I suggest return type TYPE_4 < Pair < TYPE_1 TYPE_2 > > TYPE_4 < ? extends Pair < TYPE_1 TYPE_2 > > strong need _exactly_ TYPE_3 < TYPE_1 TYPE_2 > I imagine want add other variants implementing
method doesn t depend internal state static : javapublic static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { don t need create a new instance _CODE_ order method call ll : _CODE_ METHOD_1 ( ) : javanew _CODE_ ( ) METHOD_1 ( )
finally case
static import assertThat
METHOD_2 superfluous
ugh nevermind * * immutable * * _CODE_
method static
I I - arg constructor i e javathis ( TYPE_2 METHOD_2 ( TYPE_3 class getClass ( ) METHOD_3 ( ) ) ) ;
VAR_1 null VAR_2 null
I don t need new String
VAR_1 final instead attribute VAR_2 call List clear ( ) method
don t want optional
I TYPE_2 ( VAR_1 empty _CODE_ list enable discovery ) I need : - new TYPE_2 ( ImmutableList ( ) true VAR_2 ) behave effectively new TYPE_3 ( VAR_2 null ) - performance similar _CODE_ a good goal means underlying implementation won t switched want - nest
I don t TYPE_2 wrapping creating a parser parsing
log4j print stack trace exception s VAR_5 ( ) method
I suggest VAR_3 comparison a null - safe
query parameters dates need format strings ? I parameter replacement handle dates - long java sql Date java sql timestamp type
greatly simplify code Arrays asList ( ) instead
return StringUtils equals ( ) result ; making a ternary ? true : false redundant
ve implemented reporting functionality log statement removed
TYPE_2 s converted a String instead a float avoid risk losing data ? need convert a primitive I suggest converting a double instead equivalent _CODE_ method
need call VAR_3 ( ) ? line code implicitly convert primitive int Integer
logged instead printed
exact suppression called VAR_1 - building methods class perform suppression a _CODE_ annotated method ? necessary METHOD_2 METHOD_3 call
VAR_16 list hashed I suggest building METHOD_1
method TYPE_2 METHOD_2 ( ) returning a TYPE_1 extracting Date - wrapping a new TYPE_1 redundant
another potential redundant - wrap a TYPE_3
test case empty string instead a null string updated a null string test method removed altogether
diamond operator missing statement
_CODE_ method accepts a Boolean object don t need unbox Boolean VAR_8
another area Boolean unboxing needed
stream ( ) needed METHOD_4 ( ) returns a List
needed
I return object needs updated return new VAR_1
appended StringBuilder constructing initial text replaced a plain String instead
arg call set empty string
shorten return new org VAR_1 VAR_2 VAR_3 VAR_4 TYPE_1 ( ) line
import Class method cleaner
another spot equalsIgnoreCase instead VAR_3
a boolean result check adding a ternary operation ? true : false redundant
operator changed a bitwise a logical
I StringUtils
return ! VAR_1 METHOD_2 ( )
need set object id
simplify a method reference toString call
missing generics HashMap
need check nulls VAR_1 VAR_1 METHOD_3 ( )
line updated call new - arg METHOD_2 ( ) method logs errors correct - object code
based new method signature arg object code fourth - object code
else results need reversed original - object code - personal - expense situations
return boolean expression
function presuming method caller verifying messages null prior called changes happening private method class future pose issue
missing generics ArrayList adding empty < > allow compiler derive correct generic type provided METHOD_3 ( ) method signature enough information
define lamba functions a variables understanding
lines combined need a declaration a separate line
I comparison METHOD_3 needed TYPE_2 equals _CODE_ methods test ( equals calling _CODE_ )
I necessarily error log info level
return condtional
I consider eliminating intermediate variable VAR_2 returning result METHOD_2 ( ) call
concrete classes return types don t need downcast picked collection injections concrete classes lets recognized easier conditionals
job request added parameters automatically list VAR_1
FYI I don t putting method contents effect proxy intercept evaluate
didn t leave
increase scope creep ll want rid service soon inclined flip _CODE_ I wouldn t object
? unnecessary
observer null bother ? doesn t change null constructor modifier short circuit other logic return
I d prefer set VAR_1 0 socket bind ephemeral VAR_1 s chance collision
s late I m tired I totally I feel done a single pass save conversions checks iterate array write item a resultant array encounter double dash return result array
I find METHOD_5 a bit confusing
add e trickles properly
a conscious decision throw unchecked
combine return line
a reason didn t [ ] ( )
I thought switch _CODE_ temp directories
don t a retry template a bean ? isn t passed constructor
call method statement need save a local variable
instead calling toString call constant class created
TYPE_2 removed
TYPE_2 removed
TYPE_3 TYPE_4 removed
TYPE_3 TYPE_4 removed
don t need TYPE_2 TYPE_3
don t need TYPE_3 TYPE_4
don t need TYPE_2
null ( I guess doesn t matter )
instead null
instead null
synchronization needed a race condition current count updating count ( line 296 line297 ) VAR_4 clear ( ) ; VAR_4 put ( node VAR_3 ) ;
synchronized put VAR_2 METHOD_2 ( VAR_3 ) ; block doesn t need a _CODE_ reduce synchronization mechanisms
+ doesn t necessary
overly complicated _CODE_ < String > set = new HashSet < > ( ) ; map values ( ) forEach ( ( s ) - > set addAll ( s ) ) ; return set ;
don t need key files meta_ < key > data_ < key > operation blob check meta_ < key > blob deleted throws TYPE_3 exists don t need continue check data_ < key > simply assume data_ < key > exists meta_ < key > exists data_ < key > doesn t RuntimeException client download access blob reduce hdfs operation
consider adding default defaults yaml instead s obvious users default
reason declare assign line
change public boolean remove ( TYPE_1 VAR_1 _CODE_ _CODE_ ) call remove ( VAR_1 null )
want change METHOD_1 ( String _CODE_ ) count errors rebalance command
hit I vote making info
TYPE_3 TYPE_4 I belongs file
return method switched METHOD_2 return previous true VAR_3 false * true update recorded false VAR_1 _CODE_ control server sends messages client VAR_3 happen frequently enough beginning frequently
VAR_2 length ! = 0 removed condition condition else statement VAR_2 = = null || VAR_2 length = = 0 TYPE_1 ( List ( ) ) else statement TYPE_1 ( null ) instead element
I super ( VAR_2 ! = null ? VAR_2 length : 1 ) ; ( VAR_2 = = null ) add null length 1
please change a bit ? stopping timer important closing resource stopping timer throws kind exception stop resource more { super close ( ) ; } finally { METHOD_1 ( ) close ( ) ; } guarantee close resource exception thrown cases resource exception takes precedent newer versions java other exception show a suppressed exception
0 INT_1 setting INT_2
Exception instead a Throwable ? errors want recover
a reason separate statement instead ( ! VAR_1 )
VAR_1 toString ( ) needed logging a warn log called matter
want multiple iterations ( 2 more ) loop instead nested conditionals
I don t works set latest emitted offset offset emitted I want highest offset emitted
need a separate consumer metric ? need consumers create factory prevent stubbing / spying consumer
I belongs METHOD_2
want push log statement METHOD_5 method
storm provides debug log messages config _CODE_ ( true ) don t add types logging
error level
s a corner case : 1 - - resource option provided method called 2 yaml file include statement sets resource false 3 _CODE_ called doesn t handle VAR_3 resource needs more fine - grained approach dealing VAR_3 understanding read don t modify properties file loading create properties instance pass instead passing properties file sense
spacing
I missed translation I more likeif ( VAR_1 containsKey ( VAR_3 ) ) { Double VAR_5 = _CODE_ _CODE_ ( VAR_2 ( VAR_3 ) null ) ; ( VAR_5 ! = null ) { VAR_1 put ( VAR_3 VAR_5 ) ; }
I don t null
doesn t null
minor : call ( VAR_2 VAR_3 VAR_4 null ) ; remove duplicate codes
return null
I checkstyle complain due missing braces ( T ) instead
initial delay slightly VAR_2 subsequent scheduling happen period VAR_1 earlier expected
consider replacing Collections VAR_1 ( ) L107
o close ( ) ; [ ] ( start = 16 length = 10 ) needed
code handles case _CODE_ species payload - need support - need wait 0 12 _CODE_ pr details :
missing else } {
I don t agree user set VAR_4 kafka default silently set VAR_5 unrelated I agree VAR_4 exceed VAR_5
don t change master targeting java 8 lambdas option kind : )
time spout deactivated / activated starts reading file beginning desirable
I don t works topology serialized
doesn t belong automatic subscriptions ? s necessary manual partition assignment
pick VAR_1 intended
need guarantee calling client shutdown ( )
I don t hurts I don t necessary storm call _CODE_ repeatedly emitted
Integer cast unnecessary
nitpick : methods declared class put method modifiers order public static standard recommended [ JLS ] ( ) I code a bit easier read
need check debug logs
debug
debug
call METHOD_1 ( conf id String valueOf ( VAR_1 ) ) vice versa
don t need explicitly assign a null
a test occasionally fail time points resolve seconds
thinking validation moved _CODE_ validate don t impose ordering builder
doesn t need called super
moved / copied apply function
minor : bereturn ( VAR_1 - VAR_2 METHOD_2 ( ) ) > Utils getInt ( conf ( TYPE_2 VAR_4 ) ) ;
minor : static implies final functions / methods don t need final
s move code static block beginning METHOD_1 suggests stack trace confusing javaif ( VAR_1 = = null ) { synchronized ( client class ) { ( VAR_1 = = null ) { VAR_1 = new timer ( netty - _CODE_ - timer true ) ; } } }
original code didn t check null needed ? extra checks fix nervous broke work
original code didn t check null throw NPE passed a null
original code throw NPE null case I a minor I prefer code
original code VAR_1 null return null
null check original code a minor
null check original code
null check original code
null check didn t exist original code
clear add atomic race small I _CODE_ < Map < Long TYPE_1 > > instead a _CODE_
operation atomic I VAR_1 _CODE_ < Map < String Map < String Object > > >
original code a static final const big a deal nice
argument
connector removed a TYPE_3
don t want VAR_4 exception fail test need
lets put a finally stop simulating time Assert VAR_1 ( TYPE_1 METHOD_2 ( ) ) ; TYPE_1 METHOD_3 ( ) ; { Assert assertTrue ( TYPE_1 METHOD_2 ( ) ) ; } finally { TYPE_1 METHOD_4 ( ) ; }
public private original code
please remove debug
don t need Integer toString + handle
I want preserve type return passed type wrong a String
_CODE_ don t need declare thrown
a string ? call place
ArrayList pre allocate number arguments command ? minor
shouldn t log exception METHOD_1 didn t happened properly
enums compared = = ? clearer read split line &&
line function instead
METHOD_2 reading file system METHOD_2 called consider caching
utility methods
TYPE_1 valueOf ( VAR_1 ) exact
mind I code
lets eat exception wrap rethrow preferably update interface allow throw
string STRING_2 actual null _CODE_
catching exception log rethrow typically good practice remove catch / rethrow ? I confused a mkdir original code a good translation file a JIRA clean ? creating directories feel _CODE_
Double parens
minor : need calling methods
useful INFO level ? a lot text log
slf4j instead System
VAR_3 set true
a StringBuilder instead ? StringBuilder VAR_1 = new StringBuilder ( ) ; VAR_1 append ( STRING_1 ) ; ( TYPE_1 VAR_2 : METHOD_1 ( ) ) { VAR_1 append ( VAR_2 ) append ( \n ) ; } return VAR_1 toString ( ) ; ( minor )
don t need toString
snippet code clear entry s key learn a String put VAR_2 map a key I other style looping : ( String _CODE_ : VAR_1 keySet ( ) ) { String _CODE_ : VAR_1 ( _CODE_ ) ; / / key
named a setter method set status map VAR_1 overrides entries present suggest rename change replace current map
want throw exceptions ? unclear means default set need a default add validators configs error earlier
revert
return VAR_1 consistency
more a debug statement
else LOG debug ( validate acl : { } VAR_1 ) ; current code run aren t logging DEBUG level
IllegalArgumentException
count + + a post - increment operator write count s caller increment throw want count + 1 instead
StringUtils isEmpty apache - commons - lang
StringBuilder s a local param
return METHOD_2 ( VAR_1 ) || METHOD_3 ( VAR_1 ) || METHOD_4 ( VAR_1 VAR_2 ) ;
StringBuilder
minor : braces
( int ) cast needed
variable created code easier read simplified METHOD_1 ( VAR_2 entry getKey ( ) entry getValue ( ) ) ;
variable created code easier read simplified to_batchids put ( new TYPE_1 ( VAR_1 entry getKey ( ) ) entry getValue ( ) ) ;
don t need = = true
ignoring exception
I don t need log message
need a log message ? add
put < > characters TYPE_5
don t need a synchronized block won t other threads modify _CODE_
required ? a topic selector state factory ( i don t need constant TYPE_3 anymore )
I m needed close supposed block data HDFS necessarily disk
want logging
i a else dont METHOD_2 cwd user enabled VAR_2 option
throw exceptions ? catch give nice consise error messages a TYPE_3 ? runtime exception mentioning redundant declared _CODE_
please reconsider log message VAR_1 error ( String format ( STRING_1 path METHOD_3 ( ) METHOD_4 ( ) e toString ( ) ) ) especially %s%n part logging exception string newline semms want I a stack trace a message
info debug
set _CODE_ constructor
_CODE_ remove VM ? return true
a null check enough removed items returned _CODE_ : : METHOD_3 ( )
missed ; line 269
need implemente METHOD_1 METHOD_2 ? explain a bit
remove condition
extra new line removed other places
passing exception new thrown
don t pass I false continue normal restart instead blue - green deployment
a default a primitive a default false ? need logics a POJO method
I don t objects representing date created a string include microseconds i compared string representations
log message a bit deceiving I + + return statement moved text deceiving ; connection method other hand method change _CODE_ ( )
a cosmetic returning array ? instead assigning a variable ? test cases ? I starts method expected behavior returning { STRING_1 STRING_2 STRING_3 } some other person changes return { STRING_2 STRING_3 } affect people method
* 1 0 needed devided ? I a cast case
removed _CODE_ method problematic test ( expected = ) instead unusual construction
need throws Exception ? o required method calls
please consider adding overridden version TYPE_1 ( String int ) constructor accepts duration encapsulate type conversion
please consider adding overridden version TYPE_1 ( String int Logger ) constructor accepts duration encapsulate type conversion
please consider adding overridden version TYPE_1 ( String int Logger ) constructor accepts duration encapsulate type conversion
please consider adding overridden version TYPE_1 ( String int Logger ) constructor accepts duration encapsulate type conversion
please consider adding overridden version TYPE_1 ( String int Logger ) constructor accepts duration encapsulate type conversion
please consider adding overridden version TYPE_1 ( String int Logger ) constructor accepts duration encapsulate type conversion
import org VAR_1 VAR_2 VAR_3 package avoid some clutter
necessary fetch nic DB
coding standards please wrap blocks curly braces
else block unnecessary block returns please remove
return VAR_3 METHOD_4 ( VAR_2 getPath ( ) ) ; save 1 line code ; )
a ; missing : (
block VAR_2 construct unnecessary changing ( expected = TYPE_1 class ) accomplishes
default TYPE_1 METHOD_3 METHOD_4 ( 1 ) ; need inform
more a question philosophy assertEquals : assertEquals ( expected actual ) coded wrong normal ( I )
add preconditions _CODE_ checks verify passed buffer null VAR_1 greater zero
new Boolean skips constant pool - - placing unnecessary pressure garbage collector please Boolean valueOf instead
add curly braces coding conventions reduce a ternary
remove METHOD_2 METHOD_3 _CODE_ ; create a single class leve TYPE_1 _CODE_ methods simply call METHOD_4 method call assert
I solved removing assert run tests asserts enabled ? ( : - 1 : intended ! )
? a strange
performing string append operations a StringBuilder defeats purpose class please change avoid unnecessary string - allocation : VAR_1 append ( STRING_2 ) append ( VAR_2 getKey ( ) ) append ( STRING_3 ) append ( VAR_2 getValue ( ) ) append ( STRING_4 ) ;
please catch more specific / explicit exceptions case original exception passed embedded totally lost
VAR_4 ( ) emits stdout result stack trace lost due redirection Log exception instead a message explaining operation performed exception swallowed IllegalStateException thrown
I - final
command toString ( ) implementation I reason final I open a thread dev@ determine a good reason I change update command classes more detailed information state
equals implementation include attributes _CODE_ super class
user class able instantiate ? constructor private
doesn t
move top method consider google common base _CODE_ check argument
A public ( instance ) constructor writes a static variable I constructor private assign static getInstance ( ) check null assign needed return existing object public static TYPE_1 getInstance ( Map < String String > configs ) { ( VAR_2 = = null ) { VAR_2 = new TYPE_1 ( ) ; / / private called heres_instance init ( configs ) ; } return VAR_2 ; }
final missing other
javaif ( val instanceof Double && Math VAR_1 ( ( Double ) val ) < = 1 0e - 131 ) { return VAR_2 ; } return val ;
a - - resources drop _stmt close ( ) ; _
VAR_1 final a blank lines method don t improve legibility
null check needed instanceof return false left operand null
avoid blocks braces
change needed ? deprecated method call
formatting issues
skip String format
VAR_2 values ( ) forEach ( : : METHOD_1 )
put VAR_2 METHOD_2 ( ) ( 3 times ) a local variable
missing @Override
I wondering add author text toString method case log a sensitive data I person : )
put STRING_9 calling TYPE_1 ? METHOD_3 serialize object JSON ( other ) giving a String thought : writing a string string return input string s case final test understand fail want control / catch
wrong log message stating geronimo removed PR
METHOD_3 call
returning result VAR_1 stream ( ) METHOD_2 ( VAR_2 - > VAR_3 ( ) startsWith ( VAR_2 ) )
needed
list#sort usage
imported statically
assertEquals everytime compare numbers fit a long
don t private accessor
_CODE_ - > VAR_2
i wondering cast instead check ( return ( String ) getProperty ( TYPE_2 VAR_2 ) ) type a string i find ourself a consistent data code returns null _CODE_ insertion correctly
need password don t
useless blank line
useless blank line
useless blank line
suggestionreturn ! ( TYPE_3 ( event getName ( ) ) && TYPE_4 ( VAR_3 ) ) ;
final
lined lines wanted
I duplicates a lot code I extra argument edit : filtering new mails others reuse code run _CODE_ : mail filtering dropped subscription done needed
s List cleanup / format commit
I I prefer a static method TYPE_3 writing header a writer VAR_2 _CODE_ VAR_4 ( ctx VAR_1 ) ;
a test argument pass ( null ) ( VAR_1 isEmpty ( ) ) enough
suggestionreturn VAR_3 isEmpty ( ) ? TYPE_2 : VAR_3 ;
replaced List
need add a cast
METHOD_4 a protected method ? doesn t need follow public method contract
s passing VAR_4 instead true consistent VCS
case VAR_1 = = null isn t simplified
Map method build map
need change
call method TYPE_2
simple concatenation : _CODE_ file = TYPE_1 METHOD_2 ( VAR_3 STRING_1 + VAR_4 ) METHOD_4 ( ) ;
a list
cases happen
useless TYPE_1
static
METHOD_5 ( )
specific cases log throw caught exception case throwing exception message put log enough
need add details base exception message problematic class throw new TYPE_3 ( e )
don t need null check VAR_4 method accepts a null issue
need null check
assertEquals ( 0 VAR_2 length )
getClass ( )
injecting TYPE_1
I m need boolean variable enough : _CODE_ ( VAR_2 METHOD_2 ( VAR_3 METHOD_3 ( VAR_4 ) ) ) ;
suggestionreturn new TYPE_1 ( VAR_1 VAR_2 true ) ;
don t need condition s a loop VAR_1 empty
debug don t want pollute test output
TYPE_2 METHOD_3 ( TYPE_1 class ) ;
suggestionreturn TYPE_1 METHOD_3 ( TYPE_2 class ) METHOD_4 ( ) ;
check VAR_1 METHOD_2 ( VAR_4 list ) ? I level code conversion automatically expected type
remove line done VAR_1 METHOD_2 ( )
bad needed : )
please don t introduce extra indentation early exit : ( ! VAR_1 ) { return true ; } / / original code _CODE_ diff easier read
I don t setting timeouts required test especially default 60 seconds
note VAR_4 returns a boolean a Boolean Boolean _CODE_ ( syspropname ) instead System getProperty + Boolean VAR_4
exception observed ? please don t catch exceptions don t
super ( VAR_3 ) similarly other constructors
remove extra parentheses
private methods protected
METHOD_3 VAR_1
shouldn t VAR_3 ! = null consistency
shouldn t protected method tests + shouldn t editable
line doesn t need throw IOException
c : : getId
e : : getKey
new byte [ ] { } - > new byte [ 0 ]
reverse condition ? clarity
personally I read && ! ( VAR_1 METHOD_3 ( ) && VAR_4 )
I d prefer debug reserve trace logging - level expensive stuff traffic / a database huge outputs
missing protected keyword
long
intended ? hide problems current runner won t stopped
valueOf - > parseInt
VAR_5 static import
limit scope a METHOD_2 block auditability I line needs privileged block
import static Assert static methods
give 0 size new array s faster java
general call super METHOD_1 other cleanups
super METHOD_1 call
hm I thought params reconstructed scratch automation framework s reason case
don t need set timer VAR_2 empty
a logger
stream api a return line
please don t store time needed don t want store service - derived information long - running components
clearer call variable VAR_7 I a long / else logic VAR_1 addAll ( VAR_2 VAR_5 ) else I understand building a list allowed class names
forEach map
remove extra parentheses
remove braces
private - > protected
map ( String : : valueOf ) sur NPE
protected
making METHOD_2 generic move cast
close stream
remove error message log message give logger exception
change VAR_1 equals ( VAR_2 getName ( ) ) VAR_1 null
WDYT returning a 404 a - existing client s done providers ? a 5xx s a server issue
please s declarative allows services top test class
I guess ( finally / close ) simplified - - resources
private - > protected
{ } statements
private - > protected
add INFO log bundle wasn t install
don t add extra empty lines
remove extra empty line
else throw error invalid class
I don t need anymore ( import )
reassign offset don t forbid assignment method parameters case s more readable
remove catch ( Exception e ) { METHOD_2 ( ) ; } ll give a clearer error failing
throws InterruptedException needed
method return void don t want nuxeo - java - client class
map ( VAR_2 - > run ( VAR_2 ) )
import static TYPE_3 VAR_2 more concise code
VAR_2 size ( ) > 0 - > ! VAR_2 isEmpty ( )
return ( < TYPE_1 > ) VAR_1 ; I guess
edited line remove extra parenthesis please
please close input stream ( - - resources statement ) javatry ( TYPE_2 VAR_1 = new TYPE_2 ( stream ) ) { }
needed VAR_1 field volatile s checked modified invalidated threads
s part original code s clean remove lines Exception thrown ll give clearer test error messages s a failure
missing
a - catch block handle closable resources
fix VAR_2 = VAR_2 =
check isEmpty ( ) ? I guess empty index names eliminated
retrieving default descriptor
correct keyword order
correct keyword order
correct keyword order
don t catch Exception more specific
need INT_1 0 enough
need stack trace consider calling super ( message null false false ) avoid some overhead
protected public
Integer parseInt
VAR_3 VAR_4 TYPE_2 - > TYPE_2
remove System println
needed
don t VAR_2 doesn t user input config file VAR_3 ! = null
a TYPE_3 a complex property check VAR_2 METHOD_6 ( ) local tests I a _CODE_ access a member a null object : mime - type write a blob property treated a complex
check TYPE_2 METHOD_1 ( ) ! = null case
put return else statement
put return else block symmetry
List < Throwable > list = new ArrayList < > ( ) ;
Double assignment VAR_3 bad style toString implicit concatenating a String : _CODE_ _CODE_ = request VAR_3 ( ) ; String VAR_3 = _CODE_ = = null ? null : STRING_1 + _CODE_ ;
don t double assignment need return method case VAR_1 length = = 0 dealt String VAR_3 : return VAR_1 = = null ? : String VAR_3 ( STRING_1 VAR_1 ) ;
remove extra parentheses
9 _CODE_ put ( key System VAR_4 ( key VAR_1 ) ) ;
want log METHOD_3
A / finally
public
stated VAR_2 parameter description forces session saved VAR_3 parameter set false
VAR_1 - > VAR_3
changed logic previously test ran VCS _CODE_ ignore s VCS _CODE_ s
put cast line
inject feature
needed s a String
format
shouldn t METHOD_1 ( VAR_2 VAR_1 session ) ? d need symmetrical METHOD_1 ( List < String > _CODE_ String _CODE_ TYPE_1 session ) method reference interface
I prefer model = = null ? null : METHOD_3 ( model ) avoid negations please a space left :
VAR_3 - > METHOD_3 ( VAR_3 ) - > : : METHOD_3
protected instead package protected
protected instead package protected
protected instead package protected
VAR_1 isEmpty ( )
protected allow subclassing
don t put logic descriptor pure data caller
VAR_1
put field default _CODE_ _CODE_
need return a new time ? fluent style doesn t necessarily imply faster I d modify existing place
surprising I d remove
Map < String Map < String String > > properties = VAR_1 METHOD_2 ( ) ? VAR_3 : VAR_2
import static org nuxeo ecm platform mimetype interfaces TYPE_5 VAR_6 type constant
don t repeat code call new constructor passing null argument VAR_5
TYPE_2 utilities toString * * * * close stream closed ( a - - resources block )
please put ANNOTATION_1 line line
put STRING_1 equals ( VAR_2 ) && s cheaper evaluate
early exit move else part unindented
map ( TYPE_2 : : METHOD_4 ) map ( : : instance ) METHOD_3 ( null ) ;
shouldn t need previous check VAR_2 METHOD_2 ( ) check s null
space / ! = prefer early - exit idiom : ( VAR_2 = = null ) { return false ; } return VAR_2 await
( ! VAR_4 isEmpty ( ) )
VAR_1 isEmpty ( )
return VAR_2 isEmpty ( ) ? null : VAR_2 ( VAR_2 size ( ) - 1 )
isEmpty
IMPORTANT res = VAR_2 METHOD_1 ( VAR_1 ) && res fails complete boolean expression short - circuit other waits won t executed
want a WARN spam logs server admin t I d DEBUG
Map < String String >
resource
List < TYPE_1 > ( check other method signatures )
needed remove
formatthere s a space (
return
guess return type void
keySet ( ) key
ternary operator VAR_1 startsWith ( STRING_1 ) ? new TYPE_3 ( VAR_1 ) : new TYPE_4 ( VAR_1 )
small method ( file ) extra blank lines doesn t bring
String valueOf ( i )
rework METHOD_2 a simple iterative method don t need copy
return
shouldn t key equals ( ) ; ? I confused checking equality immutable objects
debug output deleted
some conflicts put VAR_2 upgraded VAR_1 = VAR_2 ( stated )
relevant maybbe rewrite status / 100 = = 2 trick
need test redirects _CODE_ finding TYPE_5 HTML
trim ( ) ? < p > hello\nthere < / p > wouldn t I want < p > html node
other forms ? VAR_3 = VAR_1 = VAR_3 htt - equiv contenttype ? s code _CODE_ able reuse
validating setter nicer I guess means default values 0 replace actual defaults build requires hoops horrible inconceivable = entry separator keyvalue separator
I happen error business logic client side processing closure request succeeded warrant marking span error
I m clear closure server side handled framework error response failed ideally interceptor a location possibility exception a grpc - java bug
_CODE_ java 8 means prefer / resources case
I a doubletake s extra line readersjavaif ( VAR_1 ! = null ) return VAR_1 ; ( request = = null ) return null ; return request VAR_2 ( ) ;
return VAR_1 collection null I m don t expect JVM optimize stringbuilder pattern
I d set VAR_3 = t _CODE_ need validate values a built object
s compatible source compilation TYPE_1 m pretty s ABI incompatible meaning libraries target brave method _CODE_
revert public note : please format files changed I notice some missing spaces diff notice
I personally haven t METHOD_1 ( ) copying other array new ArrayList < TYPE_1 > ( builder VAR_2 )
I loop duplicates check doesn t speed 0 case
don t want early return remove data map ( want data removed VAR_2 case a VAR_3 started tracing component set VAR_2 status )
save some overhead declaring VAR_4 a field reusing VAR_4 = VAR_2 METHOD_3 ( ) VAR_4 ( VAR_4 )
throws exception propagate wrap
iirc TYPE_1 doesn t declared exceptions wrap runtime exceptions another runtime exception
worth moving reporting synchronized block ( I wouldn t expect convention VAR_1 )
synchronizing VAR_1
s wasteful calling METHOD_2 ( ) methods consider original request storing a field mutable result _CODE_ ( )
remove leave false
code style : curly brackets space
code style : curly brackets space
please handle nullity constructor
need check VAR_1 null
unneeded changes code style PR removing needed adds unnecessary noise PR move another PR
VAR_1 a field need instantiate a new message
I disagree job client _CODE_ print stuff sense cases a logger
delegate closing VAR_3
extract VAR_5 high _CODE_ share connections keeping a single thread VAR_5 fine case ( enough servers trouble saturate single thread VAR_5 want apply some pressure connection pool tune future need ) allow a _CODE_ test slightly simpler
damn autoboxing A _CODE_ ( ) findbugs happy cleaner VAR_9 a Boolean object true ( Boolean TRUE case )
catching Exception rethrowing - equivalent catching implementation method target VAR_1 ( ) ; exception management ( simpler ! )
boolean ( a small b )
boolean small b
fun I d fid more readable a static import TYPE_1 METHOD_2 ( ) ( a complete detail feel free ignore )
useless remove exact behaviour
remove = )
won´t work u meant : VAR_1 = ! VAR_1
return VAR_1 ;
removed moved a path : )
please add _CODE_ check
rather1 ) inline statement2 ) split significant statements ( index VAR_3 VAR_1 METHOD_3 )
_CODE_ addAll ( VAR_1 ) ; instead iterating collection
resources input stream closed automatically
< TYPE_1 extends TYPE_2 < T > >
please handle exception rethrow handle other
close stream I missing
VAR_1 null ? I rewrite [ 1 ] ? point nesting expression catch exception thrown [ 1 ] javaif ( TYPE_1 METHOD_2 ( VAR_1 ) ) { return new HashMap ( ) ; } else ( TYPE_2 ( VAR_1 ) ) { return null ; } else { { return VAR_3 METHOD_3 ( VAR_1 ) METHOD_4 ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 e ) ; } }
I m surprised didn t report ! d more consistent TYPE_2 equals ( ) checks
happen
I a generated code please include curly braces ifs code misinterpreted more easily
please add curly bracers please check other places I more other places IDEA formatting highlights
variable normalized set ( ) method necessary normalize ( )
please change debug
fix proposed address some issue address issue I drools - scorecards ; some tests periodically fail I applied fixes PR local machine I intermittent errors _CODE_ please latest notes results testing
caching result application a regular expression a String ? good reason demonstrate a benchmark a bad idea
please don t general Exception type throwing exceptions handling exceptions hard type exception hidden IllegalArgumentException - exception specific - illegal VAR_2 argument provided minor edit : please reformat throw line 4 spaces
please reformat - catch
please don t catch general Exception class catch exceptions don t want catched E g _CODE_
wrap classloader creation a method
I breaking compatibility register persisted change I additional cunstructor won t break existing sessions
possibly check values ( I guess equals ( ) method broken screwed ! )
new ArrayList < > ( VAR_2 ) additional benefit properly sizing list
a loop
VAR_1 diff null VAR_1 equals VAR_2 VAR_1 null return VAR_2 _diff than_ null ? I part wrong
new Double ( ) redundant
new Double redundant
TYPE_2 a - static class a reference necessary pass
a nicer - liner java 8 streams / _CODE_
override previous line
VAR_4 METHOD_5 call purpose
definition happen I check empty collection
VAR_2 false VAR_3 need resorted
instead making new ArrayList class body move new ArrayList constructor = VAR_2 = new ArrayList < > ( VAR_2 ) size time
? iterate set fine - need copy arraylist
method happily returns null time time kaboom ? yeah I binding active selection time hurt add a explicitif ( _CODE_ _CODE_ ( ) = = - 1 ) return ; method protect
rarely construct implementation OEM _CODE_ needs ? A solution query real plain _CODE_ = TYPE_1 ( TYPE_2 class _CODE_ TYPE_3 METHOD_1 ( ) ) ; VAR_3 = TYPE_1 ( TYPE_2 class TYPE_2 TYPE_3 METHOD_1 ( ) ) ;
suggestionprivate static String METHOD_1 ( TYPE_2 TYPE_3 VAR_1 ) {
pass operator ( upper ) ? boolean operator previous
final variable level
don final local variables
! _CODE_ a bit code some cleanup welcome
methods commands datadog - agent ( stuff datadog - agent jmxfetch list - matching ) expected print stdout s a debugging command LOGGER debug changes I m missing subject log level potentially breaking agent commands info warning - preferable print stdout 🤔
variable
VAR_1 alias names defined user configurations I don t want / need format
a bit odd passing empty args a
s a setter printstream s interesting shows a design flaw set printstream override quiet option knowing
want initialize java defaults
I find a bit strange calculate initialize table compressor instead leaving private details raw compressor code strange a min table size defined compressor logic
needs synchronised threads updated VAR_1
final please
I remove check
need FQDN TYPE_2 imported
run METHOD_1 ( ) _CODE_ _CODE_ ( ) thread VAR_5 ?
package protected instead public
I some doubts change case attempt alter current TYPE_1 instance ( I agree s a practice ) creating a new instance setting singleton reference TYPE_1 altering test I suspect spotted travis CI test running due exclusions RESTEASY - 1935
i18n log
shouldn t synchronized
need a Set internally relying a Map ? t simply ArrayList ? I don t care duplicates ( s internal abstraction ) ? basically I d affecting memory footprint considering object created invocation
line ( VAR_3 = VAR_1 ; ) a bug fix stores a reference VAR_1 resource allowing close ( ) method nice catch
missing ; ; - )
permissionnew TYPE_8 ( STRING_4 ) ) required test pass
a major problem rid System ? : - )
please
I ve a minor ( performance ) concern TYPE_3 code case xml escape ends done a 5 chars replacement ( double - quote ampersand - greater - xml apostrophe ) entity string scanned linearly _CODE_ slash replacement builds a pattern matches replaces manually create pattern provide a regexp matching 6 chars perform replacement ? alternatively linear string scan code replace 6 chars pass
call super ( text ) applies constructor matchers empty
please add method METHOD_1 ( TYPE_5 _CODE_ ) TYPE_5 VAR_3 enough cases
difference VAR_1 ! = null VAR_1 ! = null ? true : false IMHO simply call SWT API returns null active VAR_1 a find VAR_1 active
I wouldnt regex matcher a VAR_3 a special char matched properly
0 default other requirement choose positive range ( executed sooner ) negative range ( executed ) comparison default implementation
logger
braces condition line
roll changes handler check a VAR_1 disposed handler methods
I pass - existing VAR_1 I some meaningful exception content assistant + VAR_1 + exist another case VAR_1 disabled - content assistant + VAR_1 + disabled
METHOD_5
waiting UI thread done fix
call METHOD_1 ( text 0 ) instead TYPE_1
expression Math VAR_4 ( ( double ) VAR_1 \ * factor ) VAR_4 method return Integer VAR_2 input greater Integer VAR_2 s input parameter VAR_4 method evaluated float returns integer instead long
call constructors other please : TYPE_5 ( TYPE_1 type int count ) call ( type count new TYPE_3 [ ] { } ) logic VAR_4 field
catch please instead ( ! startsWith ( STRING_1 )
I able find case File - > save menu enabled im wondering s ? line 37 calling shell menu File - > properties clicking needless operation
METHOD_2 можно вынести из ifи можно написать VAR_2 METHOD_4 ( VAR_1 ) и по аналогии для других
я вообще думал что выстрел будет делаться такgun METHOD_1 ( ) ; т е VAR_2 METHOD_2 ( ) METHOD_3 ( ) METHOD_5 ( VAR_1 METHOD_6 ( ) VAR_1 METHOD_7 ( ) ) ; выполнять в методе класса TYPE_1
часто повторяется лучше сделать метод METHOD_4 в классе _CODE_ или events
remove explicit initialization
please dont remove explicit initialization
please dont remove explicit initialization
please dont remove explicit initialization
please dont remove explicit initialization
please dont remove explicit initialization
some config attributes express conf overload set usernamepublic TYPE_1 < TYPE_2 > METHOD_1 ( String VAR_2 ) { return new TYPE_2 ( config _CODE_ ( ) VAR_2 VAR_3 ) ; }
I doesnt matter nitpicking : local vars - initialized good practice initialize a defined doesnt matter code
checking env map null more ( initialize empty map )
simpler don t ? return ( VAR_1 ! = null ) && VAR_1 METHOD_4 ( ) ;
instead switch 2 options 👍
private
protected needed android studio warns ! [ screenshot 2019 - 03 - 13 17 28 17 ] ( )
need check
isn t a STRING_1 instead a hardcoded string
move else }
instead declaring VAR_9 global declare initialize pass TYPE_5 ( ) answer ( url )
I add a NULL check VAR_2 condition
I simplify toreturn ( VAR_5 ! = null && VAR_5 METHOD_3 ( ) ) _CODE_ variable declared assigned easier condition
difference depending API level ? curious
general TYPE_3 s shouldn t cached - input block tested prevent occurs
VAR_3 set a single line real need VAR_3 variable _CODE_ parameter pass METHOD_5
method written a single line ; check reference _CODE_ returns null key doesn t ( java lang Object )
early return
I methods private
didn t check mplementation sense null check result result VAR_4 ( ) result _CODE_ ( ) ( 0 ) null safe design
code fragment line 325ff
variable ; please remove line
variable ; please remove line
attributie needed ; please remove
I d change line a mistake solving conflicts
VAR_3 METHOD_4 ( ) pass
I d METHOD_2 ( ) applied substring ( )
please don t reload text METHOD_1 ( ) _CODE_ ( ) _CODE_ ( ) ; _CODE_ ( ) METHOD_1 ( ) called other windows partially hide fragment ( menu showing apps open file _CODE_ ) stays visible
check user clicks item ( info ) highlighted others a good behaviour
call super METHOD_1 ( ) ;
reason asserted
reason changed default ? please revert
support offset length arguments
method designed read $HOME / td / td conf print warning case file
method private
modifier private ? set modifiers _CODE_ _CODE_ methods
need VAR_4 variable ? shouldn t assign result METHOD_3 VAR_3
longer need define pass a backend call start ( ) METHOD_2 ( STRING_1 VAR_3 )
I don t need VAR_2 close ( ) ( ) effectively close bridge s ( impossible ? ) a failure occurs assignment VAR_4 assignment VAR_2 clarify : remove VAR_4 a local variable instead remove line
leave burden capturing exception user
search analyzers analyzers return true I tests reflect ? fact solve easily keeping search VAR_3 class VAR_3 a default search VAR_3 null
couldn t TYPE_1 METHOD_2 ( VAR_1 ( ) ) ? spare instanceof
a reason METHOD_1 mapper level METHOD_4 engine / backend level
I d ( String ) VAR_2 VAR_2 toString ( ) else a String fail wrong more point org hibernate search backend lucene types sort impl _CODE_ return TYPE_2 _CODE_ method converts TYPE_2 a String METHOD_1 converts a TYPE_2 I METHOD_1 call _CODE_ happen VAR_2 null _CODE_ MISSING_FIRST _CODE_ MISSING_LAST
I m parameter VAR_2 method body
I I mentioned : a new test validation attribute _CODE_ I missed isn t
missing < > a raw type
I don t introduced mutability ? local variables worked want please setters package - private
I noticed displaying VAR_1 error message wanted VAR_1 parsing sense changed work : )
s critical need expose method instead exposing : _CODE_ ( VAR_1 _CODE_ _CODE_ )
wrong METHOD_1 ( VAR_1 Object VAR_2 ) tests fail missing a test
a negative
INT_1 I suppose s s prime number 31 multiplying 100 trick s worth hard
yeah other I don t a good idea repository service code
move method _CODE_ ? class a bit hard read due methods extra care related methods I shouldn t : /
I avoid lambda
pass VAR_1 type Object instead VAR_1 toString ( ) _CODE_ logger call toString ( ) automatically some reason VAR_1 null throw NPE code
minor nitpicking s weird order parameters reversed 2 lines
wouldn t happen projects empty list projections ? granted doesn t useful happen especially number results a safer approach a _CODE_ default
discussed _CODE_ s drop support index - sensitive projections restore ( )
method public consistency _CODE_
variable line removed
I understand correctly commit wrappers remain cache stopped I suppose purpose
remove super ( ) ;
a hardcoded constant ( STRING_1 ) simply I won t change practice s case people copy / paste code
TYPE_3 TYPE_4 impl types packages accessed
else ? s private ( I suppose purpose dropping _CODE_ )
need a elasticsearch
simply delete toString formatter invoke s needed avoid creating String log level disabled s WARN case shouldn t matter pointing a toString ( ) suspicious
locking thingy I d / else class done esp plug another type ? single user method raises exception case type supported a bit odd I don t work
log a constant making clear shortcut logging error handler
I a tricky race condition : fail METHOD_3 consumer thread consumer park ( check queue empty )
I need _CODE_ thread safe I perfectly fine isn t thread safe
lines redundant lines 291 - 293
add a close a finally block
implications breaking binary compatibility ? class users affect ? existing public constructors deprecated removed
I don t point making db lazily created s expensive operation
don t allow comparison s confusing
binary compat break
need wrap a TYPE_3 a _CODE_ a subclass TYPE_3
ANNOTATION_1 annotation implies argument null correct fix ANNOTATION_1 annotation : return VAR_2 ! = null ? VAR_2 METHOD_3 ( ) : null ;
case redundant default
JSON lines opening [ isn t necessary anymore
possibly TYPE_1 find ( ) instead TYPE_1 METHOD_1 ( ) : - patterns shorter : \ jpg$ instead * \ jpg ( * \ jpg$ ) - ( more important ) syntax urlfilter - regex rules
s reason invoke jackson mapping ? shouldn t a plain toString ( ) sufficient
worth replacing new lines * * sides ? ( sounds useless I missing )
METHOD_2 ( ) METHOD_3 ( ) enough
I d prefer condition check VAR_2 METHOD_4 ( ) s a big deal
I d qualify class a context
METHOD_2 ( ) more understandable remember 0 means wait
theoretically accessed multiple threads ? want a singleton revise
i new Object ( ) synchronize object
necessary METHOD_3 VAR_1 iso standard
IDEA METHOD_2 ( new String [ collection size ( ) ] ) performance improvement METHOD_2 ( new String [ 0 ] ) call encouraged
return path ? url toString ( ) differ path
simplify return
TYPE_3 shared runs tests I noticed a reversion original settings — e g VAR_2 METHOD_3 ( _CODE_ ) I tests passing done correctness
potential NPE VAR_1 null doesn t
VAR_1 consistent _CODE_ ( )
lockpick factory : - D
property definition
I purpose substring operations removed
pls method signature a wrapper calls adjusted null argument
synchronized present
work 2 threads racing code val null read val null create new instance 1 count lost update map possibly synchronized cases needed
change container type finally changed List Set ( _CODE_ ) ultra speedup lookup ultra I significant single project container size app 700 I m event done times request
supertype Set
supertype Set
doesn t size method return number mappings ? I s necessary keySet
[ ] ( ) cast necessary
TYPE_1 a subclass IOException
possibly shorter writejavaenv METHOD_2 ( METHOD_1 ( STRING_1 ) ) ;
system VAR_3 a main program throw exception return a boolean check main program
project ! = null check avoid substring operation
knowledge : impact ? multiple time tag list
avoid logic class inconsistent other collection fields t update field set null a tree set
avoid logic class
remove ( VAR_6 )
timeout google recommends ? I apache HTTP a internal default 3 minutes timeout overridden apache s newer package version
missing brace
I understand key point TYPE_1 METHOD_4 method calling execptoin occurs assume date valid more specific exception type catched assumption - sense assuming generic exception occurs due date valid ( : leap days ) ? other Exception subtype catch block instead ? brainstorming asking : )
inlined a single return line
small suggestion investigate avoid a generic exception hard inspect happen METHOD_3 throw exception _CODE_ METHOD_4 throw some exception ( bcs skipped )
I understood condition read great ! ! thanks a lot small I important long term easier maintan : + 1 :
private ? package protected access
private ? package protected access
method public doesn t sense arguments flush ( _CODE_ String ) method session ( editor ) a TYPE_1 instance set METHOD_1 please change package protected access ( access modifier set ) ? work / sense
private ( package protected ) ? s class
fact need ! ? s class test test constructs instance
appply KIE style formatting
VAR_1 METHOD_3 ( ) returns null
don t need METHOD_2 ( ) ve ed
streams result more readable
suggestionif ( VAR_1 ! = VAR_1 ) {
I fine want javafor ( final TYPE_3 element : VAR_2 ) { TYPE_2 METHOD_3 ( element + + VAR_3 ) ; }
formatting
please assertj assertion case fail error message explaining list sizes current implementation print assertion error expected true false reference list size
I understand need method please clarify
t Collections _CODE_ ( ) asking knwo troubles return - modifiable list
TYPE_1 class managed exclusively class possibility override behavior I suggest put private visibility method choice
throws Exception necessary
throws Exception necessary
suggestionfinal boolean VAR_1 = false ;
variable misleading VAR_2 ! TYPE_1 equals ( VAR_1 VAR_3 )
javaif ( o instanceof TYPE_1 ) { TYPE_1 = ( TYPE_1 ) o ; return TYPE_2 equals ( ) ; } return false ; instanceof operator check null
acquire _lock_ icon editor title project explorer ? personally I d prefer _behaviour_ presenter ( dumb ) View delete consumer METHOD_2 event close ( IIRC _consumer_ a View physical delete firing event place WDYT
assertEquals express expected
VAR_1 METHOD_1 ( ) ;
optional present check access
method reference instead o getId ( )
I a null returned question affect callers method a null es returned callers method fail returning a NPE exception thrown expected variable XXX
final
_CODE_ ( VAR_5 METHOD_8 ( ) VAR_9 VAR_10 VAR_9 ) ;
_CODE_ ( VAR_5 METHOD_8 ( ) VAR_10 VAR_9 ) ;
suggestionempty_value ) ;
a VAR_3 ( o - > METHOD_3 ( VAR_1 ) ) ;
Exception thrown
Exception thrown please more descriptive test method
Exception thrown
Exception thrown
Exception thrown
Exception thrown
Exception thrown
Exception thrown
I message _CODE_ ? general method logging I t
consistency please final boolean VAR_3
consistency please final boolean VAR_2
suggestionempty_value ) ;
_CODE_ ( VAR_5 METHOD_9 ( ) VAR_7 VAR_8 VAR_7 ) ;
_CODE_ ( VAR_5 METHOD_8 ( ) VAR_7 VAR_8 VAR_7 ) ;
missing assertNotNull _CODE_
consistency need keyword getter _CODE_
reading [ ] ( ) I map instead METHOD_2 I miss
VAR_2 empty ? asked chat assume
please restore original formatting
condition _CODE_ overriding method specific subprocesses sense
returning Optional < TYPE_1 >
don t need set TYPE_1 s done setup ( ) method ( harm test clearer ! )
check pointless NPE thrown L#120
I method private : suggestionprivate void METHOD_1 ( ) {
typo resource - > true ( VAR_5 )
I _CODE_ METHOD_1 public main feature class I miss
public rest private
I m fine server side classes case _CODE_ core - common module s correct class visible GWT compiler I emulate METHOD_2 method JRE s reason I remember comparison classname method emulated compare js strings feel free test guys I m wrong lemme I m agree change
please add TYPE_4 TYPE_5 Date imports declare variable final Date VAR_3 = TYPE_2 parse ( VAR_2 ) ;
methods need static
I s a format issue : suggestionpublic void METHOD_1 ( ) {
unnecessary * * ; * *
need METHOD_2 case
I package - private : suggestionvoid METHOD_1 ( ) {
change setup method : _CODE_ void setup ( ) { view = spy ( new TYPE_1 ( _CODE_ _CODE_ _CODE_ _CODE_ ) ) ; } simplify method : _CODE_ void METHOD_1 ( ) { view METHOD_4 ( VAR_2 ) ; METHOD_6 ( view ) METHOD_7 ( ) ; }
_CODE_ ( _CODE_ class ) public class _CODE_ { private static final String VAR_7 = _CODE_ ; private static final String VAR_9 = 1 2 3 ; private static final TYPE_1 key = new TYPE_1 ( TYPE_2 TYPE_4 VAR_3 METHOD_2 ( ) TYPE_3 VAR_5 TYPE_2 TYPE_4 VAR_3 METHOD_3 ( ) ) ; org kie dmn model api _CODE_ VAR_6 ; Map < TYPE_1 String > VAR_8 ; void METHOD_1 ( ) { ( VAR_6 getId ( ) ) METHOD_4 ( VAR_7 ) ; ( VAR_6 METHOD_5 ( ) ) METHOD_4 ( VAR_8 ) ; ( VAR_6 METHOD_6 ( ) ) METHOD_4 ( VAR_9 ) ; } void _CODE_ ( ) { _CODE_ ( TYPE_3 ENUMERATION ) ; } void _CODE_ ( ) { _CODE_ ( TYPE_3 EXPRESSION ) ; } void _CODE_ ( ) { _CODE_ ( TYPE_3 RANGE ) ; } private void _CODE_ ( final TYPE_3 _CODE_ ) { ( VAR_8 METHOD_7 ( key ) ) METHOD_4 ( _CODE_ ( ) _CODE_ ( ) ) ; final _CODE_ _CODE_ = _CODE_ _CODE_ ( VAR_6 ) ; assertEquals ( _CODE_ _CODE_ ( ) _CODE_ ) ; assertEquals ( _CODE_ getId ( ) getValue ( ) VAR_7 ) ; assertEquals ( _CODE_ METHOD_6 ( ) getValue ( ) VAR_9 ) ; } }
shorten condition : java ( StringUtils _CODE_ ( ) && VAR_1 = = null ) FQN StringUtils org kie workbench common stunner core util StringUtils
I add a final : suggestionfinal TYPE_2 VAR_2 = TYPE_2 METHOD_2 ( VAR_1 ) ;
useless semicolon
return method
return method
Exception thrown method
method private
method private
I m wondering need method METHOD_3 additional check && METHOD_3 ( VAR_1 ) s similar check filter ( VAR_3 - > VAR_3 equals ( VAR_1 METHOD_5 ( ) ) ) happen 2 _CODE_ equal don t identifier ? I remove newly added private METHOD_3 remove && check behave
method doesn t throw exception
explicit type argument TYPE_2 replaced < >
dtto
don t need a call super ( )
IMO s values e g 0 1 example delegated method simply parameter
please field instead f consistent line
I simplify method : javaprivate Optional < String > METHOD_1 ( ) { ( TYPE_2 METHOD_3 ( METHOD_2 ( ) ) || TYPE_2 METHOD_3 ( METHOD_4 ( ) ) ) { return Optional empty ( ) ; } return Optional ( METHOD_4 ( ) METHOD_5 ( ) ) ; } feel free : - )
replaced I prefer matter taste needs revert
missing verify VAR_8 fire tests _CODE_ mock event
I method private
I method private
ordering data types TYPE_2 : : getName a TYPE_2 : : getType function default data types I correctly ordered
static
I guess return ( TYPE_1 ) node VAR_2 ( ) METHOD_4 ( ) ; more clear
METHOD_1 ( ) internally I rewrite : javapublic Collection < TYPE_1 > METHOD_1 ( ) { return VAR_1 values ( ) ; }
private other classes
VAR_3 left
_setup_
please - - resources
constructor calling more featureful constructor consistency avoid duplication : ( VAR_2 VAR_3 VAR_4 Collections VAR_6 ( ) Collections VAR_6 ( ) VAR_5 ) ;
more unnecessary save restore system property please remove consistent entire test suite _CODE_
please remove else code more readable
please remove else code more readable ; follow KIE code style
doesn t change needed
useless comma
hide remove doesn t inverted
else redundand please replace return VAR_2 ; VAR_2 added loop VAR_2 empty ; ) method
please replace size ( ) ) METHOD_4 ( _CODE_ ( 16x PR : ctrl + f size ( ) ) METHOD_4 (
lists shouldn t copied copy ; javathis VAR_5 = new ArrayList < > ( VAR_5 ) ; holds access parameter list modify
getClass ( ) instead getClass ( ) getName ( ) ? applies bellow
Optional nitpick : VAR_1 isEmpty ( )
shorten return Optional ( new TYPE_1 ( ) ) ;
shorten line return Optional ( new Context ( ) ) ;
shortened line more question performance : javareturn Optional _CODE_ ( VAR_3 ( VAR_1 ) ) _CODE_ ( Collections VAR_4 ( ) ) ;
consumer simplified lambda leaving decision _CODE_ - > METHOD_6 ( )
parameter private method false
nice provide some feedback check fails file BLABLA doesn t exist directory provided please
don t worry changing FYI a constructor File takes a parent child path concatenates s nice don t worry File VAR_2 concatenating path
interest TYPE_1 values ( )
interest TYPE_1 values ( )
redundant line
_CODE_ I line omitted
private method
Arrays asList ( VAR_1 split ( STRING_1 ) ) stream ( ) replaced Arrays stream ( VAR_1 split ( STRING_1 ) )
method private
Arrays asList ( ) stream ( ) replaced Arrays stream ( )
I d necessary simplified : METHOD_4 ( 0 0 VAR_2 100 ) ;
local variable values debugging purposes ? shorten statement : javareturn VAR_5 METHOD_2 ( ) stream ( ) map ( row - > row VAR_6 ( ) ( VAR_2 ) ) collect ( Collectors VAR_7 ( ) ) ; WDYT
version more readable wanted ask noticed update : javafinal Optional < TYPE_1 > VAR_1 = METHOD_2 ( ) ; METHOD_2 declared : javaprivate Optional < TYPE_1 > METHOD_2 ( )
I guess null check nice _CODE_ ( a null ) ; b VAR_1 ( null ) ; METHOD_2 ( a b ) ; METHOD_2 ( b a ) ;
ll able return block reducing size method a
initialize fields declaration site ? opinion doesn t add ( sense constructors threw exceptions )
catch some Exception - type ? I some _CODE_
passing METHOD_2 ( ) ( introducing local variable offset ) argument METHOD_4 ( ) improve readability
please add access modifier private
inject
inject
( final )
STRING_1 ? s
personal preference I return VAR_3 list METHOD_2 append argument I don t expect passed values change ( java )
method assertion : METHOD_4 ( VAR_3 METHOD_5 ( METHOD_6 ( TYPE_2 class ) ) ) ; shouldn t ? METHOD_4 ( VAR_3 METHOD_5 ( VAR_2 ) ) ;
need set text bounds setting fill gradient ? good reason [ ] ( ) potential public methods sets text bounds
A test checks VAR_3 invocked appreciated please
s avoid raw types please
statements erased parse returns true WDYT
VAR_1 type TYPE_2 map strings missed VAR_1 ( )
chianelli s a problem I m forgetting change reason splitting lines code
I a problem error - user doesn t expected type ( added other task )
package private intentionally ? method test
I line VAR_1 getId ( ) ; code line 112 useless
floating semicolon
case sense
I don t internals case STRING_1 returned reached i18n appreciable other case
_CODE_ ( java lang Object ) method
consider Optional
heh I m picky occasion Optional required ? execution a command * * * * result a - null result
floating ;
need FQCN
ve Optional class ; Optional nice
expect a CCE ? smells a hack fix a problem
null TYPE_1 ? ( filter list validation nulls )
condition covered tests I don t need condition
lamda
method lead _CODE_ : javathis VAR_2 = null ; [ ] VAR_2 METHOD_1 ( ) ;
nicer terms METHOD_4 METHOD_1 METHOD_4 I d expect METHOD_1
( optional feel changing ) test _CODE_ ( ) remarkably similar removal duplicated code a shared method single _CODE_ boolean parameter remove duplication
s a missing assert
start java8 VAR_1 forEach
mention lamdas : - )
future move uberfire
I m a lover passing nulls methods constructors another constructor _CODE_
I m a lover passing nulls methods constructors another constructor _CODE_
_CODE_ safeにした方がよさそうです
called VAR_3 assigned
order previously ? 1 notify ad click 2 launch click target
s issue I s put checks a single line ( ( ! VAR_1 exists ( ) && ! VAR_1 METHOD_2 ( ) ) )
I log messages related extensions part METHOD_1
a mechanic extraction s enough pass VAR_1
need change I feel s refactoring action
simpler wrap lines : ( VAR_1 > 0 ) { }
VAR_1 null
I : javaif ( input = = null || input size ( ) = = 0 ) return null ;
test empty filename I expecting METHOD_2 ( )
I wondering sense include loop insteadi e ( TYPE_2 equals ( ) ) { } other issue want version included VAR_4 property a tag
I guess reached
ha ! a new construct I thought id a private field
a good practice leave brackets line else adds another line produce a bug
missing brackets
missing brackets
method left blank—will called a block - scoped step returning start _CODE_ start
boolean
BTW class cast TYPE_3 required
please save previous constructor change affects binary compatibility previous versions
I don t needs changed ? shouldn t need add null / isEmpty checks TYPE_4 METHOD_6
extract variable
< > ( VAR_1 isEmpty ( ) ) return false ;
page variable
some side effects connectors ( sources compile )
Boolean valueOf avoid object instanciation
return VAR_2 ! = null && ( VAR_2 ( STRING_2 ) || VAR_2 ( STRING_3 ) ) ;
shouldn t synchronized ? ( _CODE_ )
2 columns
I button enabled form defined - > new _CODE_ form defined - > open form
linebreak place choice
empty string argument
return VAR_1 METHOD_2 ( ) instanceof TYPE_2 ;
left operand useless
a clear separation call METHOD_2 ( ) creation a log
doesn t
new String ( ) redundant
I results VAR_2 ( ) a finally block want release connection
I loading a TYPE_1 primary key session ( Class serializable ) return item
s move bundle stuff METHOD_3 ( ) method : METHOD_3 ( String VAR_8 ) { TYPE_1 args = new TYPE_1 ( ) ; args VAR_6 ( ) } logic contained fragment
casting ensure VAR_1 a TYPE_1 defined
breaks public API _CODE_ case break API returned able represent query parameter content specification I d recommend wit a Map < String Collection < String > > guava stuff internal java standard conform interface outer world
sense overwrite VAR_2 ( i e check list overwrite allowing multiple VAR_2 )
remove public
clean public
spaces empty line
url I guess inline i e VAR_1 METHOD_7 ( ) ( )
please add curly braces
nice create integer constant assign INT_1 E g public static int WINDOW_HEIGHT = INT_1 d more explicit another person ( magic numbers )
FYI I s a method _CODE_ ( )
! [ MAJOR ] ( severity : MAJOR ) remove unused private METHOD_1 method [ ! [ rule ] ( ) ] ( )
I wrote don t need create instance TYPE_4 METHOD_5 ( ) a static method invoke : TYPE_4 METHOD_5 ( VAR_3 )
shouldn t a part logic _CODE_ ? reuse SLOT_TRIGGERS _CODE_ scroll slot s pretty implemented : (
outer optional shouldnt needed
necessary
doesn t method return a null
I code style suggests annotations methods
nitpick : else more
equals
! [ MAJOR ] ( severity : MAJOR ) remove unused private METHOD_1 method [ ! [ rule ] ( ) ] ( )
universal operation checked sth similar performed repo
result comparison returned
create a ticket improve sonar rules
static import assertTrue
I pass parameters a lot TYPE_4 VAR_4 TYPE_4 VAR_5 extract method hardcode parameters
interface
interface return signature
nitpick : missing spaces pipe I d suggest naming exception variables
final List < TYPE_2 > VAR_1 = METHOD_2 ( ) ; ( position < VAR_1 size ( ) ) { return new TYPE_1 ( VAR_1 ( position ) ) ; } else { return null ; }
purpose line
remove pre - defined variable ? private TYPE_1 METHOD_1 ( ) { List < TYPE_1 > VAR_2 = VAR_3 METHOD_2 ( TYPE_2 METHOD_3 ( STRING_1 ) ) ; ( VAR_2 isEmpty ( ) ) { / / allow selenium throw exceptionreturn VAR_3 METHOD_4 ( TYPE_2 METHOD_3 ( STRING_2 ) ) ; } else ( 1 < VAR_2 size ( ) ) { / / modal VAR_1 visiblethrow new IllegalStateException ( STRING_3 ) ; } else { return VAR_2 ( 0 ) ; }
move METHOD_5 method METHOD_4 ? I understood previous discussion explicit wait necessary case a post request includes tests
List interface instead specific implementation
clickable
millis shoud enought
I VAR_3 passed param doc : assertEquals ( Object actual Object expected String message )
add more descriptive instead element ? _CODE_ input field
navigate page / parameter line
VAR_1 declared class field
new line needed
asserting
s fixed ? : D ( line 56 )
isn t VAR_1 METHOD_2 checks element displayed ? return true instead running VAR_2 METHOD_3 ( )
please ( _CODE_ = true ) insted METHOD_1 ( ) test body
line : TYPE_2 VAR_1 = ( TYPE_2 ) VAR_2 ; needed VAR_2 object inheriting TYPE_2 class : VAR_2 METHOD_4 ( VAR_6 ) toString ( ) ; : )
push content opening wiki activity
moving assertion test test more readable - reading assertion idea _what expected behaviour ? _ hiding assertion a bad pattern I s a lot legacy code I wouldn t new tests ; )
please edit article test openning a page
please method don t need store variable
don t VAR_1 spinner instead method invocation call new _CODE_ ( driver ) _CODE_ ( ) ; test case class
VAR_1 cast
( ! STRING_1 equals ( TYPE_1 METHOD_2 ( ) ) && TYPE_1 METHOD_3 ( ) ! = null ) { VAR_1 METHOD_4 ( ) METHOD_5 ( ) METHOD_6 ( TYPE_1 METHOD_3 ( ) ) ; } else { VAR_1 METHOD_4 ( ) METHOD_5 ( ) METHOD_7 ( ) ; }
java { STRING_1 STRING_2 STRING_3 STRING_4 }
need css selector _CODE_ ? I move a test level a static var
move TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ;
add _CODE_
method states check button visibility doesn t mention checking module visibility please diversion more precise
please replace withreturn METHOD_2 ( VAR_1 ) + VAR_2
VAR_1 please access
assertion test page objects keeping page state asserting correct
declare values
2 lines merged
METHOD_2 ( ) return null handle
redundant
String object String comparison please : VAR_3 equals ( STRING_1 )
VAR_4 ? highly discouraged wait element instead
VAR_4 ? highly discouraged wait element instead
need String valueOf
parent constructor _CODE_ : : _CODE_ ( )
consider removing magic numbers source div want
A ternary operator replaced more visibility please
please replace regular / else
put config file : disable - flash : truethis wont work - t cast boolean String A solution : String valueOf ( config ( STRING_1 ) )
logged query METHOD_2 ( )
global event listener log METHOD_4 don t need
methods similar consider
global listener catch METHOD_3 don t need log
logging logged METHOD_6
double wait
double wait
check necessary VAR_2 ( index ) called prior
check necessary VAR_2 ( index ) called prior
private ? show slot public
need declare a avriable VAR_4 justnew _CODE_ ( VAR_2 5 ) METHOD_4 ( ) job
suggest another _CODE_ 004 005 break dependency 001 002 successful
suggest another _CODE_ 004 005 break dependency 001 002 successful
suggest another _CODE_ 006 007 break dependency 001 002 successful
suggest another _CODE_ 006 007 break dependency 001 002 successful
assigning - 1 VAR_1 assigning line
method : METHOD_2 ( ) ; { ( VAR_3 isEmpty ( ) ) { return 0 ; } else { return VAR_3 size ( ) ; } } finally { TYPE_1 log ( STRING_1 STRING_2 + VAR_3 size ( ) true ) ; METHOD_4 ( ) ; } decide more readable
catch exception
necessary log ? assertion put logging file I s another logging method
s necessary log ? assertion put logging file I s another logging method
variable necessary line
action object necessary ? isn t enough clicking desired elements METHOD_3 methods
please move TYPE_3 METHOD_5 ( STRING_1 ) top class TYPE_3
reason wait element clicking ? please remove method : )
I combine lines return STRING_2 + VAR_1 + STRING_3 ;
remove console printout system println
remove system print
return VAR_3 METHOD_3 ( STRING_1 ) ; line VAR_2 else
I other method parameter log consider adding VAR_1 log
log error stack instead
Integer needed instead int
VAR_6 METHOD_6 ( ) ; remove variable
return line
return line
instead printing stack trace console throw RuntimeException ? doesn t declared wrong notified - don t need logs
ll fit line
please remove line needed
remove VAR_2 parameter log ( ) methodwith VAR_2 parameter screenshot test execute longer possibly omit screnshoots increases execution tmie
remove VAR_2 parameter log ( ) method
change private
remove line
remove line
reverted private
remove else add pair curly brackets
assertion necessary
don t wait
remove VAR_2 need capture screenshot sending keys
element load ajax ? don t wait element
change VAR_1 isPresent
remove line
break statement process loop element VAR_3 considered
wrong formatting hard read
I line please remove VAR_2 parameter parameter needed screenshot needed verification methods
_CODE_ ( ) method instead _CODE_ ( VAR_3 ) ; VAR_3 METHOD_5 ( text ) ;
pass TYPE_3 VAR_5 argument / need create additional string
TYPE_1 log ( STRING_1 + STRING_2 + VAR_1 true VAR_5 ) ; remember spaces + String put trailing ) seperate _CODE_ VAR_5 TYPE_1 ( need screenshot )
remove VAR_2 TYPE_2 ( need screenshot )
remove VAR_3
method another method encapsulation
VAR_2
I argument constructor ( default visibility ) provide a factory method creates TYPE_2 production executor service
class constructor getter / setter
inline
please rewrite constructor project style guide
making method public necessary ? need expose method public _CODE_ ? t package private
smotrakov please _CODE_ _CODE_ parameter alternatively want - case sensitive regex matching
a more more direct doesn t METHOD_2 example fail clojure VAR_4
please empty cell hack
warning conditional
needs dates strings
a reason accessors ? enclosing class read members needed move class file
need synchronize ( a TYPE_1 ) immutable
TYPE_1 mutable synchronize
ANNOTATION_1 après tu fais assert ! = null
METHOD_8 ( 1 )
pourquoi utiliser une valeur invalid plutot null
il semble qu au début de la session s était dit les usages de essayait de les limiter au assignations dans le constructeur
C est quoi l avantage d utiliser METHOD_6 ajouter l exception à la signature le test va échouer
la meilleure façon de savoir si est dans le champ est le jour ou aura besoin d injecter des services dans les modèles ahah
thanks time review
remove line ? printing sysout please
username password part API base ? understanding constant ( case ) parameters appended dynamically username password appended _CODE_ ( ) method
work CRLF delimited strings ? s LF need call method normalized string stop caring CR clearer return start + 1 ; instead breaking iteration
a solution wrt visibility move _CODE_ _CODE_ package _CODE_ change 7 0 ( method ) _CODE_ experimental remove new API freely 7 0
please call other constructor ( VAR_2 VAR_3 VAR_4 - 1 - 1 ) don t need duplicate logic
internalize * _CODE_ impls master
add constructors TYPE_9 ? * TYPE_9 ( ) - default constructor compatibility * TYPE_9 ( _CODE_ ) - new _CODE_ resource loader a property VAR_6 factory a method argument parsing VAR_6 element theory reuse TYPE_9 instance parsing rules ruleset ( don t currently )
please call other constructor : ( new TYPE_1 ( ) VAR_2 VAR_3 ) ; need duplicated code
Collections _CODE_ instead a new TYPE_2
unrelated rest PR related original report
build behavior TYPE_3 METHOD_4
need a boxed primitive
need a boxed primitive
image attribute supposed text node I d separate ( previous attribute fine ) A practical reason future other languages a text node case wouldn t fetched METHOD_1 compatibility a METHOD_2 method _CODE_ #1728 * * deprecate put METHOD_1 soon 7 0 contract super loose
please remove System
a public test method consider turning METHOD_2 package - private accessible test ( package ) invisible world
I m optional… I throw ( equivalent enum valueOf ) … PR simply calls ( ) optional throw called illegally…
METHOD_1 package private ? public
constructors package private
implementation bogus simply call return VAR_1 ( VAR_2 false ) ;
I d move line 83 ( visit ( TYPE_1 node Object data ) ) ignore overridden methods setters
digging sorting I java io File implements comparable VAR_4 files correctly depending operating system Collections VAR_4 ( VAR_3 ) ; change method METHOD_2 instead sorting : _CODE_ [ ] candidates = VAR_1 _CODE_ ( filter ) ; ( candidates = = null ) { return ; } Arrays VAR_4 ( candidates ) ; File instead String advantage don t need create new File instances
constructor doesn t rule chain a call ( ) ; missing
PMD specific I guess fail time PMD wouldn t subclass _CODE_ ( _CODE_ test a single rule )
useless parenthesis STRING_1
Collectors VAR_5 ( File VAR_3 )
don t _CODE_ add VAR_2
callers return method ? needed
? shouldn t return null / empty string
a METHOD_4
return Arrays asList ( STRING_1 )
a raw type please a parameterized type ( Collection < String > )
care
return true cleaner I missing point rule
check moved call - sites ( l 100 ) btw case l 145
a ternary expression
inline variable
arbitrary limit ? able basenode VAR_1 guaranteed a descendant
reason instance field a static final
package - private intended visibility ? missed access modifier
package - private
package - private
theory cell factories set fxml : < ? import net sourceforge pmd util fxdesigner util controls TYPE_3 ? > < ? import net sourceforge pmd util fxdesigner util controls TYPE_4 ? > < _CODE_ fx : id = VAR_2 _CODE_ = secondary - panel _CODE_ alignment = CENTER > < _CODE_ > < TYPE_3 / > < / _CODE_ > < / _CODE_ > < _CODE_ fx : id = VAR_4 _CODE_ = secondary - panel _CODE_ alignment = CENTER > < _CODE_ > < TYPE_4 / > < / _CODE_ > < / _CODE_ >
loop safely start VAR_1 previous indexes affected
harmful null check done
I VAR_1 size ( ) ! = 1 isn t
unit test failures ( wouldn t ) : VAR_1 METHOD_3 ( VAR_3 ) ( getClass ( ) ) - parent nodes matched ( class a class )
derive Class < TYPE_1 > label choices provided ? immutable a real - world case empty enumerations eludes
public Object [ ] METHOD_1 ( ) {
unnecessary annotation won t null catch api syntax error return caller
rewrite VAR_3 = new HashSet < > ( ) ; space constructor
conventions please spaces brackets method parameters brackets new lines checkstyle plugin crash build run mvn install - P run - ? long time complete build cca hour
nice protected - arg constructor _CODE_ purposes null variables File _CODE_ necessary create new objects unused
please introduce a new constructor public TYPE_2 ( String source String String message ) call instead TYPE_2 METHOD_2 ? call constructor TYPE_2 METHOD_2 ? thx
id optional _CODE_
harmless call null _CODE_ IIUC
scm api rules placement annotations methods
annotations wrong line
= = Class es
impl package ? SCM implementation wish return others
I meant implement methods
I don t difference _CODE_ ? speed reading isn t snuff
style guide
isn t TYPE_1 empty immutable
_CODE_ check values null empty
extract priority a constant don t change 2 places
poorly chose object created a phone a clipping _CODE_ content clipping relevant test
UI
bad code remove - catch
wrong code ( id ! = null && ( id startsWith ( VAR_1 ) )
clear VAR_3
VAR_13
ArrayList - > List
1 0 system time
return VAR_3 ;
VAR_1 ? ? run lookup VAR_1 app _CODE_ ( ) METHOD_1 ( ) ;
opacity unknown
VAR_4 METHOD_7 ( )
point - return null
check top method
static
upgrade drop existing markers
codestyle
return ( VAR_1 < = VAR_2 && VAR_1 > = VAR_3 ) ;
s throw exception caller catch
handle exception
return empty string instead null
please brackets : ( ! METHOD_1 ( VAR_1 VAR_2 ) ) { return false ; }
brackets ( { } )
missing a bracket
defined changed line
error
change error
change debug
usuń _CODE_ : D
chyba już niepotrzebne
note put line : = METHOD_1 ( ) ; improve readability arguments ( helps spot unchecked arguments )
java lets drop throws arguments implemented methods implemented method doesn t throw exception drop throws want compile
! [ CRITICAL ] ( ) result integer multiplication cast long org sonatype sisu litmus testsupport concurrent _CODE_ METHOD_1 ( List ) [ ! [ rule ] ( ) ] ( )
more readable mark relevant methods synchronized arbitrary member locking
due nature run ( ) potentially duplicate health check runs scheduled
thread - safe
don t need check s started anymore a TYPE_1 rid previous lines
explode parameter null
starting control I idea add plugin I understand a follow pr I created [ JENKINS - 49367 ] ( )
intention ? globals longer involved stream creation VAR_3 base axioms unused
message METHOD_2 ( entity entity )
I generally ( t = = null ) throw e some full stacktrace exception unexpected
don t modify VAR_1 object retrieved config instead copy modify default VAR_2 inherited config shared multiple instances
Integer toString ( METHOD_3 ( ) METHOD_4 ( ) ) automagic coercion String addition
call _CODE_ ( ) METHOD_1 ( ) moving code TYPE_1 mentioned
_isn t_ ANNOTATION_1 remove annotation add a guard returns false
input ANNOTATION_1 remove annotation add null check
input ANNOTATION_1 remove annotation add null check
prefer token VAR_1
add a METHOD_2 ( ) override returns a cast super METHOD_2 ( ) neater
eliminate duplication attempting VAR_1 METHOD_1 ( ) : VAR_1 METHOD_1 ( ) ; / / don t care succeeds failsif ( VAR_1 METHOD_2 ( ) ) return VAR_1 ; throw
simply return 0 relying SSH arguably necessary restrict integration tests ve weeded - SSH
a good idea - - sets a thread local interfere other tests I suspect TYPE_2 queue ( _CODE_ ) won t run _CODE_ _CODE_ t submitted executor ( another reason _CODE_ fail gracefully outwith a TQC _CODE_ )
reset a finally block
prevent null place ; i e fail early _CODE_ : import static google common base preconditions _CODE_ ; VAR_5 add ( _CODE_ ( listener listener ) ) ;
I don t want propagate exception thread want return throwable wasn t thread error
done 3 lines
delete - debugging
I d : VAR_2 = METHOD_2 ( VAR_1 STRING_1 ) ; note I static imports others static imports clear enough ( Assert assertTrue tests )
cast ? I missing ? strong feelings
line isn t required a temporary hack disable kafka - zookeeper jmx
implement closeable interest
I d assertEquals ( b a ) rely a impl assertEquals _CODE_ equals ( _CODE_ ) case
I METHOD_1 ( true ) a jboss7 entity I logging : 2014 - 01 - 28 22 : 18 : 47 089 WARN brooklyn management internal _CODE_ call stop management unknown entity ( unmanaged ? ) _CODE_ { id = _CODE_ } ; skipping _CODE_ TYPE_5 METHOD_4 METHOD_6 want - else VAR_2 METHOD_5 ( ) METHOD_6 ( entity ) else block
I d : return ImmutableList ( STRING_1 STRING_2 STRING_3 VAR_1 STRING_4 STRING_5 )
suggesting giving more info ( e g connect ) stderr helpful
feel wrong : )
I d private part a public API want called other moved utility place ( renamed clearer return null positive )
yikes I didn t master ? ! shouldn t unwrap TYPE_2 exception happened thread other thread example other thread interrupted TYPE_2 METHOD_2 ( ) return InterruptedException rethrowing _this_ thread interrupted ( interrupt handled incorrectly caught wrapped marking thread Thread interrupt ( )
shouldn t
needs a _CODE_ synchronization ( getters )
want _CODE_ generate id null passed ? hide some programming errors want overload constructor a version id parameter
pass true dryrun calling parse
initial size VAR_2 size ( ) + VAR_1 size ( ) create copy return Collections VAR_4 ( maps _CODE_ ( VAR_2 ) )
I want pass null instead a super constructor takes class calls other constructor a null entity instance fail fast
cast ( List < ? extends TYPE_1 > ) needed ? method signature
treating singleton ( static INSTANCE field ) constructor private
METHOD_4 return null
strange a TYPE_2 a predicate matching a criteria
don t synchronized a volatile read covers need synchronized imply METHOD_2 other calls METHOD_2 ( ) need synchronized ?
return boolean id ( similar semantics Set remove )
I delegate VAR_1 a field initialized constructor avoids creating time call METHOD_1 sense
checked construction time don t create object inconsistent state
ditch debugging : )
remove line doesn t sense a primitive s happening primitive boolean auto - boxed a Boolean
change casts wide a net method called methods implementing extended JSON methods implementing shell mode e g _CODE_ s correct shell : { _id : _CODE_ ( 5aaff8caa33024673db4cddf ) } s called read values some places keys address I need leave current method add a new method read extended JSON keys e g _CODE_
A method starting set more parameter define a property thrown exception
parameters I want final configured checkstyle I don t a big benefit I don t I ve accidentally modified exception reference a catch clause
local variable : final needed IDE configured differently checkstyle
I guess _will_ allow variable null planning a placeholder some kind
simulation decision phase build panel
I bed_quantiles [ 1 ] - ( VAR_2 [ 2 ] - VAR_2 [ 1 ] ) ;
i´d ´this ´ usages necessary consistent style rest library code
called concurrently ? consider java util concurrent atomic _CODE_
aye ; I missed I changed a _b_ oolean
skip empty strings
METHOD_3 returns generic type _CODE_ ( C implementation ) necessary include cast TYPE_7 ? doesn t clean edit - I looked figured issue poor generics change class definition _CODE_ remove need castold : javapublic abstract class _CODE_ < T extends _CODE_ Builder < ? > > extends _CODE_ < T _CODE_ > { new : javapublic abstract class _CODE_ < T extends _CODE_ Builder < ? > extends _CODE_ > extends _CODE_ < T > {
need path - conf
need throw exception I thought null signal failed create
supposed shell
reason want _CODE_
METHOD_1 sequential count set 0
guaranteed positioned correctly
if1 stream random read mode VAR_1 = 02 _CODE_ METHOD_1 ( VAR_2 - 1 ) 3 calling METHOD_1 _CODE_ undesired ? instead refactor creating auxiliary method _CODE_ = VAR_3 > sequential_read_limitif ( position < VAR_1 || position - VAR_1 > VAR_2 ) { VAR_3 = 0 ; } ( _CODE_ ( ) ) { ( ( TYPE_1 ) ) METHOD_1 ( position ) ;
VAR_1
LRU evictor : void _CODE_ ( long _CODE_ long VAR_1 _CODE_ location ) { / / temp block committed update evictor new added _CODE_ put ( VAR_1 UNUSED_MAP_VALUE ) ; } doesn t newly created blocks added tail LRU cache ( )
add synchronization
lines
h optional I num args stay 1 please build alluxio give a manual test
want - null issue METHOD_1 ? basically set null finally
I confused supposed
t VAR_2 values ( ) add _CODE_ entries
explain logic
valid hit EOS return - 1
needs public reflection work
I want null instead empty arrays
switch statement
super constructor ? ( VAR_5 final )
calling super constructor
I thread safe a lock protect changes cached client a RW lock read client write update
protected a lock
finally block
a change behavior - give some time server threads finish RPC calls METHOD_4
s reason copy _CODE_ a new list
( ) - static remove
shorten intervals cluster shorten ? line wait ? line
new TYPE_1 ( VAR_1 ) conf / VAR_4 creation constructor
catch throwable instead
previous log message removed trivial logic
heartbeat need stopped
method needs return true journal entry handled
I feel output isn t helpful reprinting user - options
I remove check checks alluxio scheme authority
return
e getMessage ( ) message ? want full stack trace exception want message
synchronized block redundant ? remove method synchronization
redundant synchronization
necessary
useful a member method TYPE_1 a util method ( stays I static method )
options sorted alphabetically
dangerous hide some issues future change implementation need unboxing
a bug ? happen
don t need assert VAR_1 a part alluxio logic : )
move line - catch avoid error due calling METHOD_4 closed call
STRING_1 equals ( VAR_1 METHOD_2 ( ) ) ? check s3 risk uri scheme s3a s3
getValue ( ) instead accessing private member
instance TYPE_3 a bool ? other types channels ( TYPE_3 ) ? checking abstracted
byte [ ] attribute values ? want store encoded values byte [ ] more compact platform agnostic
expensive ( CPU mem ) create repeatedly especially xattrs example maps a default size ( 16 ) add consider creating map unused
inline booleans
empty string instead
set
alphabetical order ? : )
remove parentheses VAR_4 METHOD_2 ( VAR_3 0 ) - longer _CODE_ put ( VAR_3 VAR_4 METHOD_2 ( VAR_3 0 ) + VAR_2 ) ;
safer create a copy a _CODE_ RPC read returned map map updated another RPC
susceptible concurrent modification exceptions return a copy instead
xxx METHOD_3 ( xxx ) add ( xxx ) reason ( VAR_4 ) line
necessary previous hashmap put override
unnecessary final
instead construct TYPE_3 doesn t removed keys
call TYPE_1 don t empty constructor TYPE_1 call command executing I simplifies code VAR_2 isn t else
inline operations similar _CODE_ call
_CODE_ need supply defaults
prefer _CODE_ Assert _CODE_
need check VAR_2 ! = null
doesn t throw ? METHOD_2 a file close channel
private s meant class protected s meant subclasses
VAR_4 - > _CODE_
debugging output
VAR_1 null
client shutdown need release
method throw IOException
sense include TYPE_3 _CODE_ inquire client ( find alluxio master ) pretty central client I feel TYPE_1 needs 1 constructor takes a _CODE_
modify input conf
add worker host log message
stopped super METHOD_1 ( )
import
currentTimeMillis ( ) some ordering sense dir names
private
zk@a : 0 b : 0 c : 1 change VAR_1
I METHOD_1 calls _CODE_ series methods unnecessary ( key ) call METHOD_1 METHOD_1
case I s log a warning recommended write alluxio uri picks authority configuration
put a finally
push reference counting close implementation TYPE_1 ? reads METHOD_4 ( ) / METHOD_2 ( )
throw
need METHOD_2 ( ) method ? instanceof a similar clearer safe cast VAR_3 subclass
prefer original VAR_1 METHOD_2 ( ) < 0
good perform expensive / blocking operations constructor - call run ( ) instead
need throws IOException signature
( VAR_1 )
VAR_3 null
limit scope
METHOD_2 expensive ? ( new array copying entries )
add a precondition constructor VAR_1 - null s final don t need check more point worth inlining METHOD_1 calls
initialize - 1 haven t logged a report
METHOD_2 designed chained VAR_1 = TYPE_2 METHOD_2 ( host STRING_1 )
static _CODE_
determine ID a process users able map ID a process metrics abnormal
nested retries ( METHOD_2 _CODE_ ) unneeded complexity
logic METHOD_2 able handle empty set
safe VAR_1 set multiple times
VAR_3 ? based current implementation context object metrics heartbeat gauge based context
synchronized required
moved _CODE_
VAR_6 type Long
protected
cast necessary ? I thought metrics longs
a simpler approach code reuse ? javafor ( _CODE_ key : _CODE_ _CODE_ ( ) ) { map add ( key getName ( key ) ) ; } return map ;
instead exception return some default
assertEquals similar instead mockito
s reasoning helper initializing constructor initializing declaration
java 8 lambda function simplify
java 8 lambda function
sort
I sort lines subcommands
wire types basic objects store retrieve data simple getters setters shouldn t - trivial code need filter negative capacities done class a defensive copy new HashMap < > ( VAR_1 )
sort member var names ? future adding a new member a deterministic location
class member variable null default typically don t init null
simplify code a minor optimization ( avoid creating unused HashSet instance ) : _CODE_ < TYPE_6 TYPE_7 TYPE_2 > VAR_2 = null ; ( VAR_1 ! = null ) { VAR_2 = new HashSet < > ( ) ; ( TYPE_2 field : VAR_1 ) { } }
isn t arg summary
wrap System another TYPE_4
null check enough convince checker framework object - null point
wasn t alphabetized nice
return correct ? another thread brings safe mode safe mode
method defined interface more sense _CODE_ class call method skip task instead task
immediately calling _CODE_ serve ( ) METHOD_9
guaranteed IOException path existing
configuration call expensive ? I suggest lookup open call values else
a good idea kill thread arbitrarily
move _CODE_
! entry VAR_3 ( )
sort
ditto others
sort
( ) shorter version VAR_1 METHOD_1 ( VAR_2 VAR_3 true ) ;
state VAR_2 instead other member variables
want METHOD_5 METHOD_3 VAR_1 returns failure
var
thread started s set null
throw IOException
throw TYPE_3 test fails detect error
VAR_5 a string input add bash - c place call
include error message
synchronizes entire method ? define method : public synchronized void METHOD_1 ( )
extra space
put conditions
need guard
remove empty line
work ? tail command show INT_2 byte I bejavabyte [ ] VAR_5 = TYPE_2 METHOD_3 ( INT_1 - INT_2 INT_2 ) ;
VAR_1 add ( TYPE_1 class VAR_4 ) ; register implementations based type ( interface )
check VAR_3 null
need ? TYPE_3 a subclass IOException
need convert TYPE_3 IOException ? a subclass IOException
debug level remove
warn e getMessage ( ) logged
longer throws IOException
IOException ( e ) original preserved
inconsistent _CODE_ requires METHOD_1 close called _CODE_ requires close called required PR
optional : package private
explicitly check VAR_4 ( ) add a else block error handling
consider putting init constructor ? block guaranteed reader successfully created
sense push logic utility method ? I expect pattern true caller point sense encapsulate
messages duplicates
I replace hadoop - 1 checking _CODE_ static void _CODE_ ( ) { assume _CODE_ ( TYPE_1 METHOD_2 ( ) ) ; }
logging necessary I handling _CODE_ ( work unit tests )
previous error level log stopping VAR_1
VAR_2 total number objects pool acquired A method decrease
- resource pattern
I prefer some large instead introducing - 1 adds complexity unnecessarily consistent _CODE_ ( simpler ) METHOD_1 ( 100 TimeUnit DAYS )
argument Math VAR_5 ( VAR_2 - VAR_1 VAR_6 )
property keys equal formatted templates
TYPE_1 VAR_1 = new TYPE_1 ( _CODE_ _CODE_ ( ) ) ;
finally block executed
TYPE_4 TYPE_3 separate concepts shouldn t obtained METHOD_1 call
return a TYPE_5 instead a TYPE_1
work including System getProperty ( STRING_1 )
options sorted alphabetically
order matters more sense return a List
TYPE_1 closable - - resource safety
catch
values creating _CODE_
a static method
please fix
sort fileds alphabetically
remove
factory constructors private ? unclear other
factory
5 seconds weather interference other builds
equals instead METHOD_1
I guess TYPE_2 VAR_4 private completely internal state
die methode muss nicht public sein oder
want a path path rest json adds noise data network transfer
original path values item null included json content network transfer smaller
throwing UOE ? UOE a runtime exception need a throws clause fact need a throws clauses means catching undetermined replace a normal exception throwing exception
parts function tested I codecov bails checks needed ? specifically check class equality problems case subclasses TYPE_1 ? statements written asreturn equals ( ) ; avoid a branch need tested
space {
nice : + 1 : - - resource idiom
needed
remember revert file VAR_1 class
need public s private
important exception lost please pass e TYPE_2 constructor
close needed - - resource ? s wring _CODE_ method ? I feel clearer
close needed - - resource ? s wring _CODE_ method ? I feel clearer
- resources please
I feel liner hurt readability please previous syntax clarity
qualify
line 89 _CODE_ METHOD_2 ( VAR_1 STRING_2 ) ;
VAR_5 set request
VAR_1 entrySet ( )
/ / nitpick - mode - _CODE_ change ctx ctx ? / / nitpick - mode -
instantiated L47
stylistic nitpick : case I d invert conditional top return empty immediately top function wrapping bulk real code conditional block ( idomatic java style ? )
d worth logging invalid silently ignoring input
I don t needs / catch block — shouldn t unrelated HTTP helper
constructors a lot duplicated code reduced call other
TYPE_1 VAR_5 applies
I believed codacy flagged I replaced VAR_2 && = VAR_1 METHOD_1 ( )
method private
method build warning
s remove call thanks
public constructor private class package level constructor
wrong substitution VAR_3 null
a public setter necessary ? abstraction _CODE_ instance primitive
public constructor - public class
node t a file parent key
public methods package access classes a strange
throws exception file writer closed consider a resources
wrap a TYPE_2 ? query run case database client need catch a TYPE_3 order interact TYPE_1
logical imager cancellation shouldn t VAR_4 PR
necessary ? saving VAR_2 general
need public - public class
need public - public class
I don t report progress Logger status update : add logs call site message logging message report module sufficient
public - public class public removed
_CODE_ level classes propagate exceptions handling top level classes E g server _CODE_ needs context a menu selection UI a user ? exceptions propagate public METHOD_1 method propagate errors chain exceptions wrapped other exceptions needed
_CODE_ a private class point debatable codacy suggests accessor methods _CODE_ private
variable named VAR_2 exist prevents pr building
hitting ESC doesn t
necessary null VAR_1 ? won t garbage collected enclosing _CODE_ garbage collected
passing event id super class constructor making a field a confusing personally I prefer approach _CODE_ id object obtained _CODE_ long id = ( Long ) super _CODE_ ( ) extra field required thoughts
I d put booleans parentheses easier reading
I protected package access
multithreading issues ? threads accessing root archive object
constructor call 5 parameter instead assigning values
I don t throws exception rid entire throws part allow remove exception handling _CODE_ possibly rid new exception class isn t else
leftover debug line - edit leftover s logger suggested saving error string display creating exception a lines
delete frequently fails ( worked a times failing consistantly ) delete case dir _CODE_ causing test fail
don t need
fix making a local copy reference VAR_2 checking local reference null finally returning local reference prevent another thread closing case a bit risk returning null violating contract method dealing possibility current case closed other objects a reference a bigger problem another story
line extra : TYPE_2 METHOD_5 ( ) ;
Map ( key ) returns null key contained map
s pass unknown args method I a tad simpler
System properties shouldn t reset test tears ? don t want unexpected side effects other tests run
braces generally considered a practice situation required language
odd test serialization : load object toString object assert fields TYPE_3 object ? a glance string processing s a date object middle
stdouts irrelevant s remove
hey - vlasov - picky extra set brackets
s imports
? s format properly annotations method definitions lines
I remove exception fails test s reported hide
removed exception thrown _CODE_ VAR_3 expecting
wouldn t infinite loop ? risky infinitely I d recommend : javalock VAR_1 ( ) ; { return map put ( STRING_1 + key STRING_2 + key ) ; } finally { VAR_1 METHOD_3 ( ) ; } _CODE_ recommends return result map put don t need extra return null ; bottom
typically put array designators [ ] type variable
switch order arguments assertEquals ( expected actual ) assertEquals ( 1 VAR_3 getId ( ) ) ; assertEquals ( STRING_2 VAR_3 METHOD_4 ( ) ) ; assertEquals ( STRING_3 VAR_3 METHOD_5 ( ) ) ;
_CODE_ ( INT_1 result ) ;
@Override line function
avoid calls System a proper logger
couldn t a typed Iterator don t casting loop
couldn t import TYPE_5 TYPE_6 Map don t fully qualify
needlessly complex a boolean supplier assertTrue call METHOD_2 ( )
need VAR_3 temp variable ? call fluently ( )
I change
idea checking keys map null ? applies tests
instead creating a File object another TYPE_2 constructor accepts file
need create VAR_3 variable
need create a variable s
skip storing VAR_2 a variable call return new TYPE_5 ( ) METHOD_3 ( ) METHOD_4 ( VAR_1 new TYPE_6 ( ) ) ;
needed log information ? opinion s useful information log info level
clear passing SSL context constructor * ( test pass environment odd )
_CODE_ ( VAR_3 < VAR_5 ) ;
throwing runtime exception map null isn t throw _CODE_
don t s a need add a constructor final _CODE_ _CODE_ final _CODE_ _CODE_ final _CODE_ _CODE_
won t required constructor
I accident revert explain change necessary
return null set user
AFAIK pattern doesn t need restricted STRING_1 keys hashtag slot condition scan redis cluster
s consistent match ( ) count ( ) I s change return type Integer ( users null ) return null s presented user
parameter sequence swapped : max VAR_1 correct
parameter sequence swapped : max VAR_1 correct
parameter sequence swapped : max VAR_1 correct
guys weren t marked I problem delete _CODE_ marked : + 1 :
remove unused local variables VAR_1 VAR_3
I don t new TYPE_1 repetition I don t alternative some lambda
calling METHOD_2 ( null ) leads _CODE_ due null / length check dispatch command arbitrary cluster node a dedicated slot required operation
VAR_1 key call METHOD_2 VAR_1 confused naming I VAR_1 changed key
redis cluster specification > redis cluster support multiple databases stand version redis database 0 SELECT allowed VAR_5 method compatible redis cluster exception separate interface cluster commands finally remove method ( String version ) ( binary ) _CODE_ more proper
I run ( key ) more faster TYPE_1 run ( String byte [ ] )
I run ( key ) more faster TYPE_1 run ( String byte [ ] )
I run ( key ) more faster TYPE_1 run ( String byte [ ] )
hmm s a bit odd METHOD_1 byte [ ] VAR_2 a string - decode byte [ ] result simply versions fields
add a & finally block return resource case a RuntimeException
trailing white space lines
simpler : _CODE_ METHOD_3 ( VAR_3 - > TYPE_4 METHOD_4 ( getName ( ) ) ) ) ;
I want clarify I m a java programmer I sense a common practice java t set a default parameter public void METHOD_1 ( boolean _CODE_ = false )
repository _CODE_ - - resources - VAR_1 close fails initial error swallowed code : - ( ( surely move parent 1 625 ? )
multi - catch - ( surely move parent 1 625 ? )
throw IllegalArgumentException
infinite invocation
I m I interface—it wordy a cumbersome user prospect TYPE_2 class else I ll work a simplifying
I move a finally block method
logic excluding VAR_3 correct done method call instead done VAR_1 list VAR_1 loaded
block METHOD_2 ( ) call
default case longs binaries other _CODE_ s
exception left bubble fail test ? METHOD_1 fails means repository shutdown properly
another option change TYPE_3 METHOD_8 check unordered unordered collections allow SNS logic repeated
strictly speaking else 230 completely unnecessary line 229 a return statement line 228 add a VAR_1 = null ; a new line
need synchronized ? threads ( txn ) hit time ? isn t completion state entered number threads participating txn
lines : ( VAR_8 METHOD_4 ( VAR_7 ) ) VAR_9 add ( VAR_7 ) ; case t METHOD_4 VAR_7 ( reason )
good VAR_1 METHOD_1 ( session ) call other cleanup ? IMO place
I m picky returning block need else block ? ( context ! = null && context VAR_1 ( ) ! = null ) { / / want context - sensitive behavior VAR_1 ve precomputed SNS indexreturn super iterator ( context ) ; } return iterator ( ) ;
benefit waking other consumers GC consumer closes ? I understand GC consumer null entries sleeping consumer shouldn t benefit waking
I m curious change VAR_3 thread safe METHOD_2 needed update VAR_6
need change ( VAR_2 ! = null ) VAR_2 METHOD_2 ( true ) ; VAR_1 true creating a VAR_2 failed watch service supported current OS line 282 result NPE
strange equals _CODE_ check _both_ VAR_1 ( process - specific ) content s UUID ( universal _CODE_ ) comparing TYPE_1 instances separate machines duplicates ? ( ? )
happen ? won t METHOD_2 ( cache ) throw a _CODE_ a reference
null ? add assertion
return path VAR_2 ( )
woa I m I public
need public
protected public changes change access modifiers modified methods limited
public I d suggest protected remove - helpful _CODE_
I d recommend initializing VAR_3 Collections _CODE_ ( TYPE_1 METHOD_1 ( VAR_2 ) ) resulting list immutable efficient implementation
explain check ? a read - session able effective VAR_2
VAR_1 field removed change method toreturn cache VAR_1 ( ) ;
need synchronized block
code correct implemented a more succinct manner a bit easier read : public boolean equals ( Object VAR_1 ) { ( VAR_1 = = ) return true ; ( VAR_1 instanceof TYPE_1 ) return = = VAR_1 ; return false ; }
oops please remove System println call
a bitwise shouldn t a boolean ( || )
set VAR_1 null a finally block ? I m checks null ( line 177 )
method synchronized multiple concurrent calls stomp other
I don t method public provides a backdoor state management operations _CODE_ I understand changing visibility required move _CODE_ implementations org modeshape jcr factories package I a cleaner API more important separate package
issue change visibility method _CODE_ start ( )
VAR_2 param doesn t ctr ( source cache container )
wrong AFAIR projectnaming strategy set core plugins shouldn t manual assignment
slow logging
new situation line duplicated
TYPE_1 VAR_2 ( ) return a boolean instead Boolean _CODE_ states active required
test data shows encoding issues possibly build ( true ) helps ( side effects )
sonar reports error line : - remove useless assignment local variable VAR_2
_CODE_ tells private 🤔
new ArrayList < > ( ) ;
autovalue generates immutable classes ImmutableList _CODE_ prevent manipulation lists / maps getters I suspect mutating class need a normal POJO instead a immutable class
throw redundancy warnings _CODE_
_CODE_ ( VAR_3 METHOD_5 ( STRING_1 ) ) ;
java 8 String VAR_2 instead a party library
I : - a separate PR _CODE_ issue - needs a unit test
! [ MAJOR ] ( severity : MAJOR ) define throw a dedicated exception instead a generic [ ! [ rule ] ( ) ] ( )
add curly braces
occurs CGD resource expected attributes wrong case
happen ANNOTATION_2 required default remove check
fix imports
null VAR_1 evaluates true errored exception evaluates false I I d throw
WARN FAIR INFO other unknown entities
s a deep stub I need
overriding quiet hard method private ; - )
simplified tojavareturn VAR_1 = = null || TYPE_2 ( VAR_2 VAR_1 ) ;
METHOD_1
rid METHOD_1 ? move METHOD_2 factory class
shouldnt VAR_4 = = null
variable
call VAR_1 ( true ) consistency
debug logging accidentally left
IIRC wrong a couple plugins want rewrite VAR_1 ( maven - shade - plugin flatten - maven - plugin ) VAR_1 target directory cleaned basedir stay
METHOD_3 lambda method reference s reason TYPE_2 METHOD_3 introduced java 1 8 simple ! = null
wrong construct a URI please : _CODE_ ( ) _CODE_ ( ) _CODE_ ( )
compare null necessary null instanceof TYPE_1 false
please remove whitespace
necessay ? called 20ms ! sufficient set top
UTF - 8 version supported ? version charset
I wasn t more clear need oshi prevent conflicting other properties files class path define string final instead changing
a part original method anymore more sense unwrap original exception order lose trace leading executor thread METHOD_1 method I original attempt stack trace shorter potential reducing clarity improving ( other words I a stupid originally )
returning boxed Double
public private
unnecessary s default initialization
line ( VAR_3 startsWith ( VAR_3 ) ) correct ? aren t checking VAR_2
touch positive engine
extra ( ) s superfluous
need hide methods tests reusing code more difficult discovery features _CODE_ CTRL - space method names
petrov more detail I create a protected method called _CODE_ returns Arrays asList ( TYPE_2 VAR_5 TYPE_2 VAR_6 ) clear defaults possibility easy override subclassing gary
needed ? removed efficiency reasons ( I don t method )
needed ? removed efficiency reasons ( I don t method )
catch exception
( VAR_2 VAR_3 VAR_4 VAR_5 false ) ; ? ?
please a switch statement
revert VAR_1 - null AFAICS
more sense
swap method parametrr orders
minor nitpicking I ve removing unnecessary helpers : null reason TYPE_1 ( ( String ) ) isEmpty ( )
upper limit corrected error message VAR_2 - 1
great space chars consistently existing coding format asif ( VAR_2 ! = null && VAR_2 length = = 1 && VAR_2 [ 0 ] = = null )
condition : ( ! METHOD_2 ( ) )
condition : ( ! METHOD_1 ( ) )
condition : ( ! METHOD_2 ( ) )
condition : ( ! METHOD_1 ( ) )
process removing other logger calls s add more
process removing other logger calls s add more
I don t need VAR_3 ( ) clear ( ) considering init specific test method I moved test method remove METHOD_1 ( ) altogether
I don t needed
want a other METHOD_1 ( ) method calls METHOD_2 executing code a bug ? a dumb suggestion couldn t move code caller ( s ) METHOD_1 ( ) ? type benefit code types extending _CODE_ I s simple remove need type implementations refer TYPE_2 SPI type
final Set < TYPE_2 > VAR_3 = VAR_4 remove ( VAR_1 ) ; remove ( ) call ? need access map change behavior slightly METHOD_2 throws exception VAR_4 s a good idea
instance entity loader TYPE_3 please move line line line 4118 reuse instance
common practice hibernate = = compare enum values equality follow practice
case returning array type
changing ? generally done avoid expensive resolution message log case fact doesn t perform worse ? IIUC simply forces 2 debug enabled checks
accessors final
oops I meant accessors abstract chat message class overridden undo abstract class
confusing people params considered equal ? ? some part code wants treat params equal long equal names comparison logic close area a local comparator class data object allow reusability class future
I assume list null
identity comparison equal ( sense equals ( ) ) integers = = ( ! = ) please equals provide proper null - handling code
need null check s a matter personal preference
wrong
2 - space indent I dispense else statements write : ( ) { return ; } ( ) { return ; }
able write ( expected = TYPE_1 class ) body test line exception
= VAR_5 ! = 0
trivial return
isn t changed ; INT_1 ? return INT_1
I method work set ( ) complement VAR_2 & =
update VAR_2 field mutually exclusive
please protected
other locations code interprets null * * - s maintain convention ( fix other code - _CODE_ ) javadefault T VAR_1 ( TYPE_1 VAR_3 ) throws IOException { return ( duration = = null ) ? VAR_1 ( ) : VAR_1 ( VAR_3 VAR_4 ( ) ) ; }
other locations code interprets null * * - s maintain convention ( fix other code - _CODE_ )
protected please - allow users override behavior
protected please - allow users override behavior
s _protected_ allow users override want
simpler code : javatry { TYPE_2 VAR_2 = TYPE_3 METHOD_2 ( path options } return ( VAR_2 ! = null ) ? VAR_2 getName ( ) : null ; } catch ( TYPE_4 e ) { return null ; / / ignore }
VAR_4 a convention a constant variable I suggest move method add private static match java convention
null check needed class METHOD_4 ( ) call method returns false passing a null argument
JLS order public final boolean consistency other methods
wrap + 4
logic reversedjavaif ( ! nf isEmpty ( ) ) { throw ; } return ;
annotations line method declaration
generic type avoid warnings : TYPE_1 < TYPE_2 > a couple test class
I m a bit confused test _CODE_ test especially part : _CODE_ < TYPE_2 > VAR_1 = new TYPE_1 < > ( output VAR_2 TYPE_2 class ) ; VAR_1 METHOD_2 ( false ) ; I provide a schema I set _CODE_ false ? reader read TYPE_2 s avro file a schema providing a schema able write TYPE_2 s avro file embedding schema case schema mandatory ? specific a mandatory schema option embed confusing
a reason package private ? a fluent builder feels odd
shouldn t calling responsibility container s injected
a minimum return _CODE_ TYPE_3 implement _CODE_ components I recommend returning concrete type spring interfaces implemented
missing generic return
move assert build sits invalid writer ( invalid default ) : new _CODE_ ( ) build ( ) ; A test case condition added
I ve asserts build method prevent duplication ( null check ) user passes null s long don t call build call else
want people able override
VAR_2 ! = null Assert VAR_3 clearer
revert ( declaration )
remove checks VAR_2 flag checks don t add
public
private
private
I m pretty IllegalArgumentException else
inline return line
want List < ? super TYPE_1 > TYPE_1 objects casting
methods need public I integer passed downloader means
ugly suppressing warning a _CODE_ ( STRING_1 ) / / public API
null explicit choice user reject exception
package scoped public
_CODE_ instead ? happen
don t need wrap ArrayList
cache instance a field ? called
I a bit early support loading places other internet
IllegalStateException
inline method body line
else
chain previous line s assertion
isn t descriptive : _CODE_ TYPE_4 options = null ; ( VAR_3 || VAR_1 ) { options = new }
VAR_1 null
add { }
I overflow s coerced a long cast arguments a long ensure long multiplication performed
need change method names more descriptive
s suppression ? call VAR_5
I don t false remove
drop fit line
( = = null ) return ; instead
inline VAR_1 return BH _CODE_ ( ) METHOD_2 ( )
sketchy hash codes aren t unique
substring ( 1 ) don t allocate a new String instance
substring ( 1 ) don t allocate a new String instance
? trace ( ) methods signatures change String Object : _CODE_ _CODE_ _CODE_ Object Throwable
I hooks delagate transformer bypassing _CODE_ ( )
I pt logging s implicitly converted a byte int
static ? missing docs
static versions METHOD_2 METHOD_3
please remove VAR_2 ? testing jitsi - meet abs - send - time configured id = 3 test
private
private
private
private
return ( VAR_2 = = VAR_1 || VAR_3 = = VAR_1 )
a null reaches point
rid checks VAR_1 _CODE_
please move static method top file sanity check length
I m a moot point I admit isn t easier read initialize VAR_4 s final doesn t initialized a constructor argument
please inline VAR_3
please remove assert don t
throw RuntimeException ? throw IllegalArgumentException remove _CODE_
pass variable
need public
I d add a METHOD_1 builder field a Boolean sets field instead defaulting false
equiv
cast feels a bit place I don t a suggestion - autowired add a separate bean a return type TYPE_3 returns object normal _CODE_ bean
style : put line method declarations parameters line long list parameters line linee g public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 VAR_1 Set < ? extends TYPE_2 > VAR_2 TYPE_3 VAR_3 ) {
style : stick bottom class neatness don t forget move line
TYPE_1 objects VAR_1 field ? e g aliases
added container part METHOD_2
doesn t ll a single reporter life worker ( a single reporter means a single task I ? ) I thought talked a new task hour similar
I d personally a _CODE_ method don t need + 1 time s nitpicking
shouldn t necessary people aren t watching logs carefully enough ingest stage realising
URI a trailing / similar cruft
bother - wrapping returned s passed method Optional present
objects equals JIC null safety required
wouldn t false false
streamed
METHOD_1
convert private constructor a static create method
convert private constructor a static create method
convert private constructor a static create method
I d write some explicit tests ID list instead adding id s uri tests s quick a lot clearer testing decoding string representation ID a long variable tests a lot clearer show ID matches
classes part atlas repo s change static factory methods code style
passed
needs a static import
code style static factory methods builders classes constructors private
unused member left
return boolean
simplify { return VAR_4 METHOD_4 ( VAR_2 ) ;
need guard
eliminate : return ! TYPE_4 METHOD_5 ( VAR_3 VAR_5 ) isEmpty ( ) ;
s a primitive
double semi - colon
METHOD_3
static import
isn t _CODE_
minor broken lines
( [ boolean condition ] ) return boolean ? other news doreturn ! TYPE_2 METHOD_2 ( VAR_1 METHOD_3 ( ) ) ;
another instance returning boolean result a boolean check BAD
VAR_2
remove
recursive call pass false a field result
duplicates initialization location other constructor s called previous line
declare abstract a default implementation override subclasses _CODE_ a resource ; _CODE_ depending s type ; _CODE_ a resource
private don t want resource attribute set externally
technically bind free variables VAR_2 part VAR_3 VAR_4 else
definition bound VAR_2 - - - level core IL recursive calls form mymethod ( ) mymethod ( ) [ a sugar work source level translation core ]
instead check String values equal
VAR_1 isEmpty ( ) instead checking size < = 0
shouldnt System println / System err println _CODE_ java _CODE_ java indication a serious problem throw exception : )
I d default false - I more sense false
dont need METHOD_1 ed
I copy / pasted : innocent :
creates a TYPE_6 table copy n paste ? ; - )
don t METHOD_2 instead test expected outcome _CODE_ ( new TYPE_1 ( TYPE_3 VAR_2 true new TYPE_2 ( ) ) ( ) ( new TYPE_2 ( ) ( ) | TYPE_3 VAR_2 ) ) ; assertThat ( new TYPE_1 ( TYPE_3 VAR_2 false new TYPE_2 ( ) ) ( ) ( new TYPE_2 ( ) ( ) ) ) ;
accidental copy & paste error
VAR_2 isEmpty ( )
reading mutable fields synchronization trim put mutation : - VAR_6 - VAR_7 - _CODE_ result totaly wrong negative
I s dereference channel a finally block case METHOD_1 failed close
another method instances TYPE_1 ? I dropwizard a metrics VAR_2 created framework I instance default proposed : _CODE_ add ( default bootstrap _CODE_ ( ) ) ; _CODE_ METHOD_1 ( default ) ; overloaded METHOD_1 method _CODE_ METHOD_1 ( default bootstrap _CODE_ ( ) ) ;
IMO
build fails TYPE_6 java : [ 72 21 ] call statement constructor fix : javathis ( VAR_3 filter VAR_5 VAR_6 TYPE_4 VAR_10 ( new TYPE_2 ( + CHAR_1 + VAR_12 VAR_13 ( ) ) ) ) ;
final VAR_1 dealing creating a list capacity
final
final
( VAR_3 getClass ( ) )
I cleaner TYPE_3 TYPE_2 VAR_4 defined factory constructor _CODE_ TYPE_1 map underlying type making a shortcut responsibility os class _CODE_ else
public feels problematic classes need call don t live io realm
intended calling multiple times trigger multiple remote operations ? I a bit confused _collection / iterable_ terms
annotate METHOD_2 call a static _CODE_ user = TYPE_4 METHOD_2 ( VAR_1 ) ;
closing _CODE_
public
public ? call JNI s private
null code _CODE_
support java 8 examples feel free lamdas
closed TYPE_2 thrown
minor suggestion / subjective : rid nesting : javaif ( VAR_1 ! = null ) { return VAR_1 ; } ( = = null ) { return VAR_2 ; } ( version = = null ) { return ; } return + STRING_1 + version ;
treat CHAR_1 a string need add a && VAR_1 length ( ) > 1
transaction mandatory kind error show case a transaction present ? s clear enough improve a separate issue
critical I find counter intuitive lookup method clear move start method
critical I find counter intuitive lookup method clear move start method
class integration tests module server a file system position
wondering fix test s a good example done tests s worth fixing
I t a difference 2 codes
remember remove
s add instead beginning s common other operations
remove useless super ( )
returned
remove System ? unecessary
builder VAR_1 ( ) invoked TYPE_2 ( ) I don t need
JSON ? I missing I d sense transaction semantics write rows association
handling specific implementation _entitymanagerimpl class_ METHOD_2 ( ) implementation TYPE_1 work METHOD_2 ( ) able cast _entitymanager_ ( interface ) works actual implementation _entitymanagerimpl_ shouldn t cast explicitly
strange indentation method parameters happend ? : )
I m wondering triggered schema initializer couldn t done dialect construction ? schema initializer create / update persistent structures datastore avoid need _CODE_ ( ) method
a test passing wrong type creating a typed query
I List < TYPE_1 >
s a interesting debate TYPE_3 mutually exclusive startable ? sense lose call super manageable startable TYPE_3 don t sense simply call super super METHOD_1
thrown generates exception
shouldn t return null ? I don t API return Object a meaning : )
want else ? ( I ll reading )
I suggest sibling _CODE_ final
careful throw a _CODE_ getString a _CODE_ calling METHOD_1 result VAR_3 I d inclined wrap : { … } catch ( Exception e ) { throw new IllegalArgumentException ( … ) ; / / rethrow } a suitable bad JSON input beats a random NPE a missing version
inline VAR_1
please key SEPARATOR STRING_1
_CODE_ I don t want please leave _CODE_ unchanged
want match a specific _CODE_ eq ( ) : suggestioneq ( TYPE_6 TYPE_7 VAR_5 ) ) ) METHOD_7 s need call getClass ( ) instance write : suggestionany ( TYPE_6 TYPE_7 class ) ) )
wouldn t assertEquals ( VAR_1 METHOD_3 ( result ) ) communicate expectation ? ( I realize input needs changed )
folder abstraction _CODE_ opaque strings _CODE_ numbers implementation detail _CODE_ replace interface more flexible s interface clean ( e g emptying trash folder ) unconstrained EXPUNGE sense I d original method add a new describes suggestion : javapublic void _CODE_ ( List < String > uids ) throws TYPE_3
combine return statements I code easier read / understand
necessary
boilerplate : \ easier [ _CODE_ ] ( )
import class fully - qualifying
please introduce a new method adding a new argument - obvious
doesn t belong
METHOD_2
variable _CODE_
doreturn STRING_1 METHOD_1 ( ) ; nice approach _CODE_ good push ve tidied
removes recipients - adds fixing symptom underlying problem ? more logic _CODE_ class
code style - add a space a new line { } s
stick K9 LOG_TAG change logging more useful ll need rebase code timber sooner
pass exception TYPE_2 s need print stack trace
TYPE_2 exceptions argument format string arguments
calling METHOD_2 ( ) intermediate values shouldn t necessary
didn t custom action bar need
unnecessary
METHOD_3 ( ) return null
arrange act assert _CODE_ _CODE_ = TYPE_2 METHOD_6 ( VAR_1 ) ; METHOD_5 ( _CODE_ ) ;
( _CODE_ = TYPE_3 class )
METHOD_10 ( VAR_1 METHOD_5 ( 1 null ) )
a bit double _CODE_ tif ( VAR_1 ) { TYPE_1 } else { return false ; } more readable
want exit - early pattern invert condition please else statement
ugly potentially a source future _CODE_
instead VAR_5 I tests easier read message retrieve a reference desired child part a helper method addressing parts easier e g _CODE_ _CODE_ = _CODE_ ( message 1 1 ) ; application / pgp - signature _CODE_ message = _CODE_ ( METHOD_1 ( mixed bodypart ( text / plain ) METHOD_1 ( signed bodypart ( text / plain ) bodypart ( application / pgp - signature ) ) ) ) ; ( need a reference signed part a example )
code style issue : spaces missing expression ; VAR_4 + 1
please don t add more utility methods message instead create a method _CODE_ _CODE_ ( message ) header message
other constructors call VAR_4 final
curly brackets avoid goto fail : - )
assertEquals param order expected actual ( other assertions ) written _CODE_ ( STRING_2 info ) ;
possibly addif ( = = o ) { return true ; }
add _CODE_
add _CODE_
remove added logic logic handled getter
remove added logic logic handled getter
I need streams
I m allow set null bean class remove toString ( ) method throw NPE resulting string
! getType ( ) equals ( Object VAR_3 ) fine
I extract STRING_1 a constant TYPE_3
noticed minor - referencing another test Utils VAR_1
please remove invocation test pass _CODE_ modification remove invocation test fail modification good
hm don t move message - logged event a TYPE_1 observer blocks
assertion fails running - container arquillian tests _CODE_ extract final exception message ( ) I leave assertion completely I replace deployer API jboss arquillian container test api _CODE_
swap method arguments I guess testng order _CODE_ other assertEquals mehtods
a reason static ? I remove
I move log message catch block line 139
altough logical throw exception I d throw TYPE_1 _CODE_ ( ) reason performance - _CODE_ sucessfully skip classes ( annotation _CODE_ _CODE_ ( ) )
I - immutable set cached a private static final field
VAR_1 addAll ( VAR_1 )
restrictive remove throws Exception clause
reduntant METHOD_4 ( ) call
ACE a subclass TYPE_4
necessary control suppress
necessary control suppress
necessary control suppress warning instead
VAR_1 - related methods static
hmm achieve keeping void interface
TYPE_1 changes state creates a new instance
a female dog generally good style include exception throw
VAR_3 a histogram records ids VAR_2 a time time someones calls lock ( ) s a counter statement effectively means lock - 1 ids
don t love extracts interface implemented astyanax driver protobuf ? : D
pointless s equivalent passing entity VAR_3 ( )
avoid negative conditions s reasonable positive assertions a bit easier reason ! easily missed flip
* * * * * * * * happen log error warning
private
removed
closed
rest
I recommend else avoid comparing a string unnecessarily
catch Throwable ? I strange gut feelings TYPE_4
remove error thrown startup _CODE_
synchronize ? VAR_2 zero VAR_6 run task VAR_5 set
suggestionreturn VAR_1 METHOD_3 ( VAR_5 - > METHOD_1 ( ) ) ;
need
calling VAR_8 ? I worry prevent StringBuilder optimization + s
suggestionif ( VAR_2 isEmpty ( ) ) {
I Map VAR_1 equals ( type ) a remnant a previous implementation removed
forgot update VAR_3
need VAR_4
remove warning _CODE_ / / noinspection uncheckedreturn ( TYPE_2 < T TYPE_1 > ) ;
_CODE_ type parameters needed
I updated
line remove brackets
wrong indent previous line wrapped
cache injected components request media type = = storage media type conversion isn t necessary edit : convert request media type I conversion explicit instead converting key
I need move VAR_2 _CODE_
VAR_4 isn t
nitpick : ( _CODE_ && VAR_1 ! = null )
conditional wrong METHOD_1 ( index ! = null && index ! = TYPE_2 ) ;
Class constructor package - private internally
I don t needed originator : _CODE_ _CODE_ private command wired _CODE_ idempotent s cheap _CODE_ _CODE_ VAR_1 - commands target nodes need add _CODE_
return false avoid variable
some parentheses improve readability please
I don t need set flag cache reaper a removes expired entry won t remove entry shared store possibly
init parameters VAR_10
/ / TODO
1 VAR_4 JMX
protected package - private
need ( _CODE_ = true ) run _CODE_ : ( VAR_1 ! = null )
ouch default MAX_RETRIES 30 ? ? ? 2 excessive a test : )
t need METHOD_3 interface sufficient : javaif ( ! VAR_2 METHOD_2 ( VAR_3 ) ( ) ) table VAR_4 ( ) add builder _CODE_ ( false ) ; _CODE_ constructor
need a Collections VAR_7 ( cmd )
remove VAR_1
return Set : )
I personally preferred else block I fine
guessing wanted argument int ? valueOf unneeded
shouldn t necessary point I wrong
set global jmx VAR_2 cache s VAR_2 JMX disabled globally
unneeded change
TYPE_3 TYPE_1 shouldn t updated
getClass ( ) METHOD_1 ( ) leaving null default TCCL
suggestionif ( VAR_2 < = 0 || ( VAR_2 & VAR_3 ) ! = 0 ) {
oops good catch
needed
return previous line
return previous line
allow removing TYPE_7 list Object VAR_2 isn t serializable
meh means a new allocation operation : - / I mess storing channel _CODE_
d logging
private
version protected I don t need access accessor
< > missing
VAR_3 ( ) enough _CODE_
need add error cancel handles time ? done create VAR_3
I d _CODE_ objects immutable a lot places
caller collection METHOD_2 field final METHOD_2 doesn t I needs a custom _CODE_
I m surprised server doesn t
thinking verify 10 active iterations stopping client reaper timeout
doesn t
field read
reduced tojavaif ( ! new File ( path ) METHOD_2 ( ) && VAR_1 ! = null ) { return new File ( new File ( VAR_1 ) path ) METHOD_3 ( ) ; } return path ;
technically another lambda scope PR imo
isn t performance - sensitive
IMO caller check fact callers
response status ( ) METHOD_1 ( )
return values = = null ? null : values iterator ( ) ( ) ;
METHOD_1 ( ) declare exact class need wildcards
shouldn t index initialized MAX_INT order trigger 1st call
don t eager cache anymore
I m I checks staying moved codec28 checks done HR protocol 2 8 ( HR protocol version ) leave carry checking protocol 2 9 wasteful server send
change order ? METHOD_2 order creation create embedded cache manager server METHOD_2 server cache manager
METHOD_3 doesn t I d : private static void METHOD_1 ( TYPE_1 VAR_1 int VAR_2 ) throws Exception { { VAR_1 run ( ) ; METHOD_2 ( ) ; } catch ( TYPE_3 e ) { assertEquals ( VAR_2 e VAR_2 ) ; } } I d move helper methods tests
VAR_5 = VAR_1 VAR_5 ( ) ;
unnecessary cast avoid unchecked warning declaring entry VAR_3 generic parameters < String String >
VAR_1 + 1 ? other ( ) methods constructor parameter range
unnecessary null check
change _CODE_ return a - > 0 partitioner local invalidation caches instead
VAR_1 removed ( cache getName ( ) )
1 IMO commands write / read segment
symmetry qualify field remove others : smile :
proper dependency graphs avoid conjured numbers
method
removing union CH doesn t work I conflict CH reading set _CODE_ change TYPE_3 VAR_5
returning VAR_2 values ( )
I prefer initialize inline field declaration constructor I nitpicking
_CODE_ necessary
putting VAR_4 = = VAR_4 comparison fail faster : )
buffer VAR_1 ( size )
unnecessary boxing
minute code utilises _CODE_ ( null ) _CODE_ new TYPE_2 ( ) called builder a bit description I missing intend TYPE_2 constructor
METHOD_2 ( cache : : METHOD_1 )
curly else branch ? : )
VAR_1 field ? I set don t
declaration initialization command done line
don t want create a factory ? injected : )
enum implemented TYPE_2 find configured VAR_2 = = VAR_1
checks work _CODE_ validate ( ) logging warnings merge policy I m METHOD_6 > 1 check needed
interpreting _CODE_ [ [ 0 1 2 ] [ 3 ] ] failed test results kind tough I d give partition scenarios a instead TBH I started thinking I some factory ( ) implementations I realized I idea new int [ ] { 0 1 2 } new int [ ] { 3 } changes test compared new int [ ] { 0 1 } new int [ ] { 2 }
I m afraid equivalent VAR_1 ! = null doesn t return false VAR_1 = = I suggest ( VAR_1 = = ) return false ; else return VAR_1 ! = null
I METHOD_1 ( ) called _CODE_ ( ) I d replace condition a null check VAR_3
luck VAR_6 null wouldn t able read command
VAR_3 null
TYPE_3 thrown removed
persistent problem deleting counter persistent storage
doesn t VAR_6 METHOD_1 ( ) include size LRU pointers
want a message create
I don t VAR_5 null
METHOD_4 METHOD_5 log remove log essage
prepare commands 0 VAR_4 common
I 0 - length arrays rare ( tests data segment )
void
void
leftover debugging
assertTrue ( METHOD_2 ( VAR_1 [ 0 ] ) || METHOD_2 ( VAR_1 [ 1 ] ) ) ;
I purpose PR test unnecessary depends _CODE_ instead _CODE_
d decorate cache constructor
FYI logic part avoid creating new instances requested encoding place
need public ? I package private
wiring
point async store necessary * function * serializable resulting entry check belong holds compute commands
works line : )
don t need cast
need
hmm call ctor null VAR_4 ( besides reflection ) ? don t new TYPE_4 [ 0 ] set null param null flag
offtopic : doesn t related PR compete radim longest PR ? : )
cast needed
IMO trace message METHOD_4 ( )
implementing correct pattern dealing VAR_1 commit / rollback [ code ] ( ) shows correct pattern
assign VAR_5 VAR_6 constructor null instead variable null
trace message sticks a bit thinking remove add logs rest some point
hrmm needed ? I a sign else wrong
I d throw TYPE_5 VAR_1 target nodes missing owner threw internal exception I d wrap exception return caller I d add a METHOD_4 ( ) method match TYPE_4 thinking more I m a point a separate TYPE_5 _CODE_ partition check TYPE_4 s I performance impact minimal
needed
DRY : ( VAR_2 VAR_3 null ) instead
please proper [ formatter ] ( )
unnecessary cast
shouldn t Class < ? >
ve managed add handler returning false
case 3 redundant
transformations happening id METHOD_1 void
reduced a single line lambda
shouldn t VAR_1 > n
shouldn t values VAR_1 null ? ( GC )
System
redundant
move label VAR_7 properties
returning stream ; terminal operation called stream s progress isn t
VAR_1 variable redundant
VAR_2 initialized constructor initialize VAR_1
I return a Class < ? extends Map >
unneeded cast : )
unneeded cast
boolean work
VAR_3 written / read _CODE_ need write / read
methods _CODE_ package - private - public API - t remove parameter altogether
related changes field anymore
return VAR_1 METHOD_3 ( VAR_3 ) ;
isn t SPI I m s worth putting implementation interface
VAR_1 METHOD_1 ( ) ; ) TL ; _CODE_ turning [ SSL debug ] ( ) turned server challenges client certificate ( client keystore ) suggested client cert file wrong server challenge wrong I lucky : )
hrmm return 0 o = = ? o METHOD_1 ( ) ensure symmetry
log a debug ? error sounds important : )
able pass r : : VAR_2
Constants a generic a a class : ) leave constants public
t VAR_2 METHOD_1 ( )
don t need server ( ) METHOD_1 ( )
I simpler store router a separate field
shouldn t a finally block
private
move ctx VAR_1 ( ) avoid invoking ctx VAR_5 ( )
return ! VAR_1 isEmpty ( ) ;
forget METHOD_1 VAR_1
METHOD_2 writes attribute
generics missing
I m a concern wouldn t cache string
null commands super ( null ) _CODE_ constructor
line throws IllegalArgumentException ? need TYPE_3
replace { return new HashSet < > ( ) ; } new HashSet < > ( )
move method a separate _CODE_ class
Optional _CODE_ ( ) _CODE_ ( ) _CODE_ constructs
I TYPE_1 obtained injected runner construction a cache optional paramater _CODE_ rely presence a current limitation _CODE_ a distexec a distributed cache adding a new implementation changes
instead invoking lambda I d doif ( System VAR_3 ( ) = = null ) { return String VAR_4 METHOD_4 ( METHOD_2 ( instance method TYPE_3 VAR_2 ) ) ; } else { / / priv action }
remove TYPE_1 prefix import
extra space
duplicated condition
I key escaped
factor code ? s repeated a places
I don t mixing Optional - style nullable parameters I d null ( Optional )
condition true
wrong method
I ll change
I problem addressed metadata implementation negative time values converted TimeUnit null result exception
nitpick parens aren t required VAR_3
+ 1 : a lot nicer
change unneeded want change declared type VAR_6 ? I possibly passing wrong set impl
VAR_1 isEmpty
I loop good enough - s allocation 0 < size 1 < size comparisons
weird shouldn t listener receive actual state
VAR_2 straight VAR_5
aggregation a filtered query ? conceptually similar SELECT person startsWith ( a ) GROUP work ? test
I a long double
I prefer _CODE_ TYPE_1 aren t adding / removing elements middle
+ 1 : I surprised didn t _CODE_ returning size WDYT
I making more explicit cleaner METHOD_1 method declaration changed return a Response null considered continue running null return response ? WDYT
line wrap a bit weird
method I talking concurrent writes key notify more 1 caller time I notify 1 VAR_2 return
shouldn t declare throws Exception
aren t inconsistent cache hits / misses writes put methods don t increment counters correct ? some sort unit test VAR_2 counters ? I worry overlap class explicit increments _CODE_ class I class handle VAR_2 else I missing
VAR_2 METHOD_3 ( VAR_1 ) ; enough need wrap _CODE_ needing access methods exposed JPA API
change needed
I removed _CODE_ completely passed key
marshallable check happen _CODE_ enabled command replicated another node TBH I m serialization happen user thread cases ( async marshalling disabled )
VAR_3 null
race condition
a null check return remove ? else isn t atomic
method invoked more 1 thread more 1 cluster stats collection happening time synchronize ? care issue variables read volatile partial updates due memory model reordering operations
exception IMO throw InterruptedException instead ignoring
@Override missing
parameter needs 1 backup model node level cache
useful mark methods final
I m guessing clear command deletes cache
reverse operands avoid negation ? nicer
insufficient synchronization return a copy internal list
I prefer METHOD_3 consistency - public API
simplified call super METHOD_1 invoke VAR_3 METHOD_3 ( )
nitpicking : declare Exception
log VAR_1 empty
instead checking time t wrap start ( ) _CODE_ TYPE_2 delegate new method
don t need METHOD_1 case VAR_5 = = 0
I instead planning _CODE_ method TYPE_1 list method betry ( _CODE_ < Map Entry < Object Object > > _CODE_ = cache _CODE_ ( ) _CODE_ ( filter ) converter ( filter ) ) { ( Map Entry < Object Object > entry : _CODE_ ) { } } catch ( IOException e ) { / / exception }
fluent
shouldn t happen shut VAR_2 bound
remove instead doesn t need called 2 lines
I familiar serialization process hotrod couldn t pass string ? error case null
I I nice constraints based command type : )
a small nitpick equals ( 1 based conditional ) thinking give spread VAR_1 multiplied INT_1 VAR_2 multiplied
redundant parenthesis isn t calling Arrays toString
String valueOf ( ) avoid checking null code : P
I bundles referenced d check OSGI expert a singleton instance class references bundle instances problematic
I don t cache defined created default configuration
missing < TYPE_2 TYPE_3 >
I originally set 2 intermediate values split test happen INT_1
INT_1 128
return String valueOf ( properties ( key ) ) ? protect null
VAR_9 null
smaller : return = = ? VAR_8 : VAR_7
bad IMO offset > > > VAR_1 offset VAR_2 overflow int ( return a negative int instead a positive ) Long valueOf ( offset ) METHOD_1 ( VAR_1 offset ) another suggestion swap order check offset size offset size
check VAR_1 ! = null
I don t problem prohibiting x - site backup / a VAR_5 cache I m familiar x - site configuration I don t s validation
I - optimizing a bit _CODE_ * * * * rare a simple return new Object [ ] { VAR_1 VAR_5 } fine
guard null
lines don t configure mock needed TYPE_6 a proper component
Set addAll method instead
interleaving events t happen entries put ( ) implicitly synchronizes entries _CODE_ I I problem : allocate ( ) moved processing entry loop METHOD_1 variable initialized entry METHOD_1 list locked METHOD_1 entry bigger
System caller btw isnt s logging preferred System tests
returned ? put cluster registry IGNORE_RETURN_VALUES
don t need variable inline
a reason class lazy initialization instead a _CODE_ / _CODE_ other classes
I don t wanna noisy full class methods class
public ? else I d leave private
I enough check _CODE_ empty originator owner invalidation done requestors a key happen owners sounds a bit expensive couldn t _CODE_ approach - tx caches invalidate primary owner instead
I sense METHOD_3 ( ) VAR_3 METHOD_3 ( ) invoked state changes tasks unblocked ( case receive ( increase ) topology id ) total order commands change state
s normal methods package protected instead public ? METHOD_1 _CODE_ ( others )
I guard METHOD_6 invocation ( _CODE_ ( ) )
cast result a bit faster : - ) TYPE_1 VAR_1 = ( TYPE_1 ) o ;
needed
nicer a method TYPE_1 _CODE_ ( ) : : TYPE_1 care drop - - nice instanceof
I true instead false
s / location / VAR_1 /
I don t handle correctly scenario passivation disabled case entries memory a subset entries disk I store instead memory operations
I don t helps
order expected actual values wrong
data container check ? call cache ( )
AFAICT queue unlimited shouldn t need throw a TYPE_2
line removed
I don t matters strictly speaking passing a explicitly I _CODE_ parameter false
arguments passed - ( string concatenation ) nice consequence formatters don t need ( log VAR_3 ) s issue FYI code more readable
missing VAR_3 METHOD_2 ( )
method return true throw exception return false A boolean return required
usage collection ineffective plan modify flight Collections _CODE_ ( ) instead code
( ) invocation constructor
need catch - throw exception
catch blocks body java 7 s user multi - catch syntax : } catch ( _CODE_ e {
s multi - catch
reason named CB d short statically referenced - - biggie
I m sorting _CODE_ reason METHOD_1 ( ) returns a List a Set original call site notready command fed a utility method stringifies a List s laziness more : PI more sense sorting caller site else reduces blast radius pull request changes collected signs / rendering code
I don t necessary
final
final
catch exception ? pass ? I a thin chance happen case a default data VAR_2 ( ) UTF - 8 fails TYPE_3
please add braces surrounding loop block confusing read
refactor else condition ? javaif ( ! VAR_1 || ( VAR_1 && METHOD_3 ( ) < = 0 ) ) { VAR_1 = METHOD_2 ( ) ; }
histogram based natural breaks quantiles percentage calculation require counting portions VAR_2 a set ranges necessarily match VAR_2 limits methods compute results
check explicitly zero ? opaque optimize a division
need a null check done default returned field isn t set ( i e null ) _CODE_ example default return : )
/ private ( remove ( _CODE_ class ) )
protected static ? doesn t sense t override static methods
error
a bit harsh I m guessing TIFF reader a single byte read call
instead string concatenation a StringBuilder
add curly brackets statement ? good practice don t weird bugs future
don t * * user = null * * null class instantianciated line redundant
_CODE_ iterating Map Entry < String TYPE_3 >
class final private
private
instead VAR_3
static imports
static imports
static imports
METHOD_1 check disconnect
s update METHOD_2 ( ) return TYPE_1 type need typecast
public t removed class a public class a breaking change
@Override line method annotations PR line
statement statement doesn t
a reason changing order chained constructor ? add new parameter list
changed true trigger METHOD_3
( TYPE_6 equals ( VAR_2 METHOD_5 ( ) VAR_7 ) ) { return VAR_6 ; } _CODE_
throw IOException
ll build versions match tag names v0 2 190 create a stable version release STRING_2 pointing current develop branch safest return STRING_2 won t a broken link release
I m s safe change fake - fake sequences I m trouble working mind
parameter false ( _CODE_ isn t nullable )
3 methods private useful controller a utilities class
ve changes similar a places compiler complaining want update java version I previously a version a similar bug
add a check item position removing ? ( I selected a column a blank VAR_2 clicked discard selected returned internal server error : item VAR_3 position I closed dialog page didn t refresh looked happened I manually refreshed page turned selected items discarded )
add STRING_1 STRING_2 STANDARD_ALIASES list top class added criteria _CODE_
creator isn t modifiable doesn t need loaded database update ( ll fully loaded managed VAR_4 [ ] ( ) )
protected knowledge link text belongs page model classes A page class expose _CODE_ ( ) method METHOD_1 ( add )
_CODE_ throw _CODE_ element doesn t exist null _CODE_ element null more sense remove null check allow _CODE_ _CODE_ _CODE_
sense support usual search TYPE_3 parse I m indifferent
I changing UNSAVED_ID constants primitive change getters Long object field a primitive ? necessitates a lot boxing / unboxing
methods protected public accessed subclasses
necessary scheduler hard - coded scan 15 minutes ? greater instead
please remove checks VAR_3 ! = null ? lack cruft favourite parts services
sacre bleu thees ? earth mees a sweet succulent _CODE_
/ VAR_1 / { id }
ideal clear repopulate TYPE_1 table V9000 test data migration s easier test exact controlled number _CODE_ making tests more lenient _CODE_
missed
METHOD_2 called path
a reason targeted sequencing set id isn t ? exception thrown
a field _CODE_ table purpose = concentration hard - coding exist DB temporarily
remove cast
remove line
s shouldn t comparing VAR_1 s ID TYPE_2 s
s deletable s saved
compilation errors
consider making relationship unidirectional instead _CODE_ useful ( edit sequencer page I d )
rethrow IllegalArgumentException
potential NPE won t useful ID set ( migration ) append _CODE_ object base _CODE_ s METHOD_1 VAR_1 ( a unique key )
method updating other objects dependencies project DAO doesn t belong _CODE_ method sets VAR_5 VAR_2 VAR_4
shouldn t need ID anymore
return TYPE_1 METHOD_3 ( VAR_1 ) ; instead lookup
consider adding a wildcard front string searching KGMT match KGMT_0015 searching 0015 query string escaped s currently SQL wildcards queries ( a general user ) searching %0015 match KGMT_0015
wrong place done _CODE_ method originally
int
easier read : ( int i = 0 ; i < VAR_2 size ( ) ; + + i ) { ( i > 0 ) { VAR_3 append ( STRING_2 ) ; } VAR_3 append ( VAR_2 METHOD_3 ( i ) ) ; }
set method lines
VAR_6 needs added _CODE_
setting dates handled METHOD_9 method required
/ finally
superfluous instanceof false null a null bypasses instanceof checks returns null method
return List < TYPE_1 >
transformed statement
rid condition ( null - initialization VAR_3 ) a - loop
s VAR_1 + + ; I mind proposed reference field
proposal early returns easier understand : return ( ) executed line please change tojavaif ( VAR_1 = = null ) { return null ; } return new TYPE_1 ( new TYPE_3 ( VAR_1 ) ) ;
final TYPE_1 VAR_1 = …
please add empty line methods
- fix string %d instead %s - implicit toString ( ) jobrather calling String valueOf explicitly
purpose method change
I Log e ( ) return null ;
please avoid boxed primitives
list set null ? soon _CODE_ ( ) called _CODE_ called a _CODE_ loop _CODE_ ( ) called singleton ? case null instead singleton ? I m I follow logic
final
public
line replaced single linejavareturn cache ! = null ? new TYPE_1 ( cache ) : null ;
please create useless variables more readable : javareturn TYPE_6 METHOD_1 ( cache VAR_1 VAR_2 log ) ;
shorterjavareturn response ! = null ? METHOD_2 ( response false ) : null ;
else transformed a simple assignment
method written asjavapublic static void METHOD_1 ( String [ ] VAR_1 ) { METHOD_2 ( Arrays asList ( VAR_1 ) 0 ) ; }
I m confused fields ( geocodes error _CODE_ ) copied new TYPE_1 ( VAR_2 ) constructor wouldn t
read easier others splitting check guards style : ( METHOD_2 METHOD_3 ( ) ) { return false ; } ( TYPE_1 METHOD_4 ( ) = = null ) { return false ; } return true ; want ask : isn t original code more compact optimized ? compiler create basically binary code versions besides differences binary don t matter code optimized readability understandability severe problem software development
bejavareturn VAR_1 = = null ; I wrote semantics questionable…
synchronized ? IMHO stopped times wish
I removed empty constructor ( 0|0 ) doesn t sense possibilities : - set valid coordinates ( preferred ) - set VAR_8 null check
unnecessary parenthesis
a handle exception a more _CODE_ - y example : update I ll merge straightaway : code great thanks ; )
shouldn t normalized _CODE_ constructor
s unclear invalid 0 valid s a string I d recommend a bit more specific potentially tests invalid clear expectations
t more specific METHOD_4 METHOD_5 ( TYPE_3 TYPE_4 VAR_7 )
return VAR_2 ( url ) need create a local var
repeat question I test code set VAR_6 0
suggestion / * package * / TYPE_1 METHOD_1 ( TYPE_2 uri ) {
want check a timed event return 0 case 👍
stackoverflow post 4 people suggesting TYPE_7 TYPE_13 equals ( STRING_2 ) library : worth include
I a fan null a meaningful change behavior / flow product instance VAR_1 empty TYPE_1 VAR_1 VAR_4 device empty VAR_1
VAR_11 null
TYPE_1 e
I m worried rethrow crash app TYPE_3 shouldn t a runtime error
great
METHOD_2 ( ) _CODE_ ( ) ? I current logic call necessary register listeners
I _CODE_ shared tokens multiple tokens overwrite token ll writing device ids wrong project please check
annotation public removed
configuration files small stream sufficiently large warrant bufferred reading approach simply reading stream ? eventually reading stream memory _CODE_ similar
I don t throws checked exceptions drop throws Exception
nice avoid creating key object class access private VAR_1 add stuff VAR_1 VAR_3 VAR_1 values alternatively create a private method private void add ( long timestamp ) { } call method I private method a cleaner
_CODE_ suggesting method reference : : METHOD_3 ( ) - > METHOD_3 ( )
: _CODE_
private
methods class need public package local
public part API ? I thinking methods implementation part API support
return VAR_1 substring ( VAR_2 ) trim ( ) remove trailing whitespace
creating a separate put method environment parameter avoid null
synchronizing object changes sync blocks good
thinking some more zknode deleted ( state set VAR_3 ) lock held detected ? retry ? alternative retrying increment allocating counter block decrement sync block code deletes node allocating counter > 0 another alternative a read - write lock
nicemaybe finally
sense modify usage cache transactors timed exist transactions _CODE_ timeout newer transactions timeout needs occur timeout cache updated a newer time prevent rollbacks continuing occur transactors slow started function correctly
unrelated issue VAR_2 method synchronized
want bucket doesn t start upper case character s naming restrictions mentioned [ ] ( )
I raw enum simpler
iterator
s good handle 0 case TYPE_3 s easier maintainer check VAR_3 = = null || VAR_3 = = 0 ( fact isn t null means unboxing safe )
( guava actual formal annotation )
declared scope loop
check generated range instead checking s limit values : assertTrue ( new TYPE_2 ( STRING_3 ) METHOD_3 ( VAR_2 ) > = 1 ) ; assertTrue ( new TYPE_2 ( STRING_4 ) METHOD_3 ( VAR_2 ) < = INT_1 ) ;
put METHOD_2 line
a syntax error
TYPE_1 METHOD_2 ( TYPE_3 VAR_3 TYPE_3 VAR_2 ) ; I pass parameters
inverted
needs discussed clarified point case semantic missing happen removed check rules I remove ( test )
test condition leads FP bad resolving VAR_2 symbol I prefer replace METHOD_2 _CODE_ : wink :
string TYPE_2 ( )
rely _CODE_ ( ) method a type change implementation class debugging purpose ? VAR_1 ( ) instead
break group methods working tokens i e _CODE_
IMO VAR_3 VAR_1 = = VAR_2 METHOD_2 ( VAR_1 )
please a method compile
annotate parameter don t need handle null argument don t need VAR_2
need variable
I m need classes methods _CODE_ registering VAR_1 iterate members ( trees ) ? 2 cases handle : * s a _CODE_ s necessarily a field declaration cases absolutely don t need rely _CODE_ ( ) method * s a _CODE_ s a method need check parameters * s else ( class instance )
unecessray anymatch
discussed rely keySet VAR_1 map other set
check crash code a call _CODE_ method empty string _CODE_ _CODE_ ( ) ;
new TYPE_1 instead
final don t want classes extending override s driving analysis
private
VAR_1 necessarily a TYPE_1 s good kind drop
need parenthesis
need recheck equality VAR_3 true
string overload TYPE_2 exact match
safer a VAR_1 ! = null
hm want change API ? accept full names
switching order short circuit
considering cases literals ? I consider cases wrong considering _CODE_ ( ) _CODE_ ( / admin / * * _CODE_ / admin / login ) ; / / _CODE_ I simply skip null values
I throwing METHOD_1 message calling line 123 / 127
s method overloading
line useless _CODE_ checks won t work semantic won t change coverage
change explicit show s a VAR_1 assert
int METHOD_2 ( int n ) ;
duplicates METHOD_1 _CODE_ - move _CODE_ similar
easier read negations return ( TYPE_4 METHOD_4 ( VAR_2 ) || TYPE_5 METHOD_4 ( VAR_2 ) ) { ( ! TYPE_6 METHOD_5 ( VAR_3 ) ) { / / } }
useless empty lines
clear set METHOD_2 references _CODE_ scanning process I I d prefer avoid a set altogether parent retrieve else keyword ( i e parent a _CODE_ current else statement parent )
minor : need else returns
matter style choices I tend part && implemented a filter stream parameters stream
I realized generate _CODE_ lines : javatarget = + num ; check token sharing line
METHOD_3 null a method VAR_1
a lambda a subtype _CODE_ I don t need elements condition ( other words part true false uncoverable unit METHOD_4 useless ) : && safely removed I ( please prove wrong I ; ) )
VAR_2 = = TYPE_5 TYPE_6 VAR_3
starting METHOD_2 ( ) VAR_1 ? strart parameter parent
g - sonar early return improve readability
don t need VAR_3 extract equivalent symbol VAR_2 method METHOD_5
I - complicating simple logical read introducing variable need minimizing number validation need case simply nest 2 statements put definition VAR_4 variable body remove VAR_4 ! = null test
unecessary parentheses
TYPE_3 TYPE_1 instead remove import
remove useless parentheses need 2 lines
I factorize condition previous
I understand usage method don t Optional : method return null
change implies parsing semantic computation test class some overhead
wondering a static import TYPE_3 method
more interesting false correctly jumping catch
_CODE_ : provide suffix prefix args Collectors VAR_1 avoid adding brackets +
please fix
micro optimisation : need visit
match returns true stream empty need previous
! [ MAJOR ] ( severity : MAJOR ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
VAR_1 VAR_2 ( ) count ( ) = = 1
simply VAR_1 instanceof TYPE_2 ? null return false
need
remarks equals I doubt interest symbols account _CODE_ symbol part
compile important
worth removing call TYPE_3 equals ( ) child parent null
happen semantic present ( VAR_2 method annotated returning null ) test semantic present raise issue case
I start method byif ( ! METHOD_3 ( VAR_1 VAR_2 ) ) { return false ; } operation requires knowing method variable
I don t returned I prefer a dedicated object errors related semantic model ( ? time ? ) classes
rewritten change key depending VAR_2
inline VAR_2 ( metadata ) variable
smart cautious operand replaced METHOD_1 ( ( TYPE_3 ) VAR_2 ) METHOD_3 ( ) ) tested : _CODE_ write ( s output ( ( String ) ( null ) ) ) ;
call toString ? I a bit confused fact rely + operator strings implicit toString calls
I m pretty super simple identifier [ JLS - 11 11 2 ] ( ) impacts fix code compile s bothering a bit
extended visibility reimplemented
I set private class externalized point
unrelated commit
I spot unit test especially check reacts edgecases ( null empty string existing class )
please don t assignement comparison expression avoid break testing nullness kind condition assignement body
I rely _CODE_ : allow declare _CODE_ local variable
I don t change test case behavior handling fields changed changes class TYPE_3 imported s unknown method call changes meaning test
METHOD_2 static static
static
don t need fill body method need lambda
replace exception Exception test contained
substring ( 2 ) ? INFO I ll _CODE_
need ||
need
I remove else return
! [ MAJOR ] ( ) change comparison equals method [ ! [ rule ] ( ) ] ( )
visible testing : visible set instantiators check class ( platform ) public annotation
( f ) = = null
I negate condition
method static methods calls
method doesn t match behavior VAR_2 = = null doesn t dimension array zero means initializer defines size
s a matter style I reverse conditions nest 3 statements
typo r
need else
a single return statement
METHOD_3 method _CODE_ METHOD_2
put message call VAR_8 need a dedicated variable
extract part _CODE_ method start method checking type VAR_2 Optional
wondering wouldn t test volatileness SV prior adding VAR_4
assertThat part static import need fully qualified ( line 40 )
protected
! [ MAJOR ] ( ) merge statement enclosing [ ! [ rule ] ( ) ] ( )
! [ MAJOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
addAll
! [ MAJOR ] ( ) reduce number conditional operators ( 4 ) expression ( maximum allowed 3 ) [ ! [ rule ] ( ) ] ( )
place annotation related return type method modifiers instance :
! [ MAJOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
! [ MAJOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
remove final modifier
add remove protected modifier
need substring search index suffix starting index prefix
! [ MAJOR ] ( ) branch s code block block branch line 293 [ ! [ rule ] ( ) ] ( )
checking semantic done checking type VAR_1 semantic parameter type method
public other protected
s a method METHOD_2 VAR_2 testing ? cover case unknown METHOD_2 ? s case I prefer test ! VAR_3 _CODE_ ( ) case covered test cases remarks apply VAR_4
private
private
deserve a
special need final please interface need implementation I recommend _CODE_ guava safety
test case overcomplicated necessary removed : ( generics catch )
false parameter avoid initial call new method METHOD_1
initialize VAR_1 1 rid else
copy done getter - analysis
false - negative
g - sonar ( TYPE_2 ) cast needed
! [ MAJOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
! [ MAJOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( )
I created ticket fixed :
matter taste i - - instead i - = 1
matter taste rely autoboxing
throwing exception closed state TYPE_3 ? ( remark unlocked state _CODE_ )
useless test marking VAR_2 marked note VAR_2 pass _CODE_ test equivalent
check rely semantic ! !
I doubting call super : : return new foo ( ) { / / some stuff closing } ; new _CODE_ checked override _CODE_ ( call super ) _CODE_ METHOD_3 return statement
I don t done level I tend constructing a TYPE_5 _CODE_ return unknown type altogether unknown TYPE_5 ( IMO ) lead confusion
allow reuse I split a method a TYPE_3
a static member ? class A extends B { public static String _CODE_ ; }
equals instead = =
check overriding uncessary
uncessary call super need visit
default impl disputable invocation method result new pool caller responsible shutdown I throw unsupported operation exception
enforce immutable list cases
assertTrue ( VAR_1 METHOD_5 ( new TYPE_3 < TYPE_2 > ( ) {
TYPE_1 values ( )
TYPE_1 values ( )
negate condition failing correct
remove private modifier properly test
verify sending page size parameter
add annotation remove public modifier constructor package private ( [ background ] ( ) )
throw NPE check null
remove public modifier
remove public modifier
assertNotNull ( VAR_1 ) avoid unexpected NPE
properties nullable need check deserialization fail
change : VAR_4 = injector getInstance ( key ( String class tenant class ) ) ;
unused args
verify returns a - null URI
call super
protected
care ! VAR_1 ( ) toString ( ) passing Optional object
need bind bound context users able METHOD_1 property creating s remove line
remove public modifier a - practice guice injection constructors visible default scope
don t public visible testing remove public modifier leave default scope
return a mock supplier test : suppliers _CODE_ ( 6ac1e746 - b1ea - 4da5 - a24e - caf1a978789d / ) don t need overhead starting a mock server creating context
redundant check allow passing empty list
remove redundant null checks
remove redundant null checks
remove public modifier null checks injector enforces
throw IllegalArgumentException
need null checks injection constructors
remove redundant check protected modifier constructor
remove public modifier constructor remove null check
iso codes region id
avoid conditionals ( condition ) return true else return false return condition
check calling
Assert calling
verify returns element
verify element returned
don t java logging jclouds provides a logging abstraction allows users configure preferred logging framework order log declare class variable type org jclouds logging Logger : _CODE_ Logger logger = Logger NULL ; configure a null logger default configured users providing a logging module creating jclouds context
redundant
fail container exist ( [ ] ( ) ) catch exception leave / finally method fail container t deleted
remove InterruptedException signature
remove InterruptedException signature
remove properties
return METHOD_2 ( id STRING_1 ) split ( STRING_2 ) ;
I don t need trim
move constructor
redundant
remove redundant assertion similar
a smarter
remove redundant assertions
rid
return server state ( ) = = TYPE_3 TYPE_4 VAR_5 ? apply other similar conditionals
package private visibility [ preferred ] ( ) injection constructors change : _CODE_ ( ANNOTATION_1 TYPE_1 < TYPE_2 > VAR_2 ) {
remove system outs
METHOD_7 ( TYPE_1 class ) ;
reference _existing_ providers accessed account
remove property
setting VAR_2
_CODE_ implementation please remove
avoid intermediate variable assign VAR_2
shouldn t deleted _after_ VAR_4 directory deleted VAR_3 call
injection constructors package private remove public modifier
remove public modifier null checks
return
necessary ? isn t base class method working
redundant check fail expected VAR_2 null
needed
package private
API return null lists remove executed creating load balancer
remove
[ ] more concise : _CODE_ ( ! ( VAR_1 = = null ^ VAR_2 = = null ) STRING_1 ) ;
a _good_ property ? api work users don t override ? passed credential
constructor package protected guice injector enforce parameters present remove METHOD_1 check
method private
weird indent class inconsistent safe copies auto generate builders won t safe copies ensure calling safe copies
[ minor ] ( CS VAR_1 : response )
[ minor ] new implementations remove METHOD_2 intentionally left ?
guice practices : constructor visible package level
injected constructor package private
created guice injector constructor protected
constructor called guice injector package private removing public modifier
catching IllegalArgumentException
checking boot order _greater_ zero means a boot device
need local variable return detected os family
property ( jclouds prefix )
payload closeable close payload avoid deprecation warning
save check : ( instanceof TYPE_3 ) { } else ( instanceof TYPE_4 ) { } else { throw new }
a static variable asList ( TYPE_1 values ( )
catch removed a guard provider properly implemented error / retry handlers
formatting : move previous line
function called marker present practice input parameter won t null remove ANNOTATION_1 annotation ( apply parser classes )
constructor package protected
avoid statements simply declaring TYPE_1 instance builder modifying : public Builder { private final TYPE_1 options = new TYPE_1 ( ) ; public Builder page ( int page ) { options VAR_2 put ( STRING_2 String valueOf ( page ) ) ; return ; } public TYPE_1 build ( ) { return METHOD_1 ( options ) ; } }
remove
add exception parameter ? won t able error happened message
omit
remember / forgets shouldn t
( ) stringify enum
else
list alphabetized ( order events _CODE_ class listing )
s null check
unneeded tern ( s a creeper s reading line )
unneeded instanceof check reason
unneeded check
remove bit^
mixed tabs spaces alsoreturn VAR_2 ! = null && STRING_1 equals ( VAR_2 ) ; : P
riittäisikö tässäkin käyttää event VAR_3 ( ) ja event VAR_4 ( ) sen sijaan että haetaan VAR_1 ja käytetään sen default identifieriä
move a util class s marked - public api
line removed
sake consistency getId ( ) instead METHOD_3 ( ) other lowercase calls
hmm IMAGE_JP2000 boxc3 VAR_2 update _CODE_ js request datastreams jp2 ( I s current VAR_2 ) kind funny METHOD_1 default VAR_2 behavior actual controller methods require VAR_2 path
method private
need determination deposit staff i d suggest checking line 54 TYPE_2 model = _CODE_ ( ) ; early return staff alternatively remove check check ( ) happen _CODE_
skip a variable immediately return true false ( fine return catch block ) return type doesn t need a Boolean case primative boolean fine
test assign instance passing VAR_1
constructor protected access ? other processors public constructors
thinking some I don t METHOD_1 needs providing a model changing properties pretty refreshing need replace properties a point other ways
wondering called VAR_2 METHOD_3 ( ) reflect updated MODS ? I don t caching
t lines 149 - 150 combined
I d suggest calling METHOD_1 method context file instead
change new ArrayList < > ( ) ;
method ends line clearer remove rest method
pass event type METHOD_5 instead VAR_4 shouldn t event type EVENT_NS
returned ? isn t supposed throw exception invalid member type
return VAR_5
I d suggest renaming variable VAR_1 implies source metadata context resource current _CODE_
I t run test moment I don t line test VAR_3 METHOD_2 VAR_5 METHOD_5 VAR_3 create methods called TYPE_1 class _CODE_ _CODE_ methods _CODE_ I m clear need I m left TYPE_1
curiosity return type setter void
TYPE_5 _CODE_
doesn t a reason hold VAR_4 VAR_3 instance variables TYPE_3 class don t need live long enough call METHOD_1 pass parameters
I drop METHOD_4 method calling constructor TYPE_1 actual file creation
move line loop
reason return staging location
enforce immutability lists ImmutableList _CODE_ list null
full package names necessary TYPE_1 suffice previous 2 lines
curious reason fully - qualified
don t need METHOD_1 ( ) ? ; - )
optimization ? METHOD_2 expensive s put
assertions wrong
assertions wrong
don t need assertion
instead catch METHOD_7 ( expected = TYPE_4 )
constructor logic metadata = metadata
null a valid input
else ? reason System
fact combine check : VAR_1 X Y ( inclusive ) Z
injectable _CODE_ function
binding redundant _CODE_ adds remove
throw _CODE_
extract a constant
I s store reference future enhancements instead copying content I love idea a configuration object : + 1 :
a builder pattern combination fluent interface some kind immutable class pattern immutable class more complicated class grows setter a big constructor call necessary
able diamond operator i e new ArrayList < > ( )
case alter table new version VAR_2 = = 3 && VAR_1 < = 2
[ x ] unnecessary VAR_3 size zero METHOD_7 ( VAR_3 ( STRING_1 ) ) ; METHOD_7 ( VAR_3 ( STRING_2 ) ) ; - - - removed 059df0362e3fc35b1ec81490950162cfbd065425
I logs chatty messages important startup change LOGGER info ( )
reduce logging debug favor cleaner output _CODE_
remove throws clause
remove final method static
a thought push expression parse logic class I TYPE_3 public static methods : * public static TYPE_3 _CODE_ ( final String _CODE_ ) ; * public static TYPE_3 _CODE_ ( final String field final String VAR_2 final String object ) ; * public static TYPE_3 _CODE_ ( final TYPE_1 field final TYPE_2 VAR_2 final String object ) ; lines
doesn t feel required
I placement a problem a number call sites call METHOD_1 ( int boolean ) essentially bypass resolution I edit main METHOD_1 method capturing return statement else wrap method a method substitution ( reduce maximum stack VAR_3 achieved )
please dont Optional VAR_2 ? isnt user some leftovers target removed dmn files project
uniform code approaches
I remember a similar ( ? ) code else I wrong
shouldn t handle case single enum ? javaprivate boolean METHOD_1 ( ) { ( VAR_1 ! = null && VAR_1 METHOD_2 ( ) ! = null ) { ( VAR_1 METHOD_2 ( ) split ( STRING_1 ) length > 1 ) { return true ; } else { return VAR_1 METHOD_2 ( ) trim ( ) length ( ) > 0 ; } } else { return false ; } }
METHOD_3 private move VAR_5 variable METHOD_3 currently check METHOD_3 VAR_5 null
variant a bit shorter readable ? javaif ( source ! = null && source VAR_3 ( ) ! = null ) { final TYPE_3 VAR_2 = source VAR_3 ( ) ; VAR_2 METHOD_2 ( ) forEach ( VAR_4 - > VAR_1 METHOD_3 ( METHOD_2 ( VAR_4 ) ) ) ; }
t VAR_1 METHOD_2 ( Collections _CODE_ ( ) )
I > 0 a list item 1 = work
removed I
please enable run button background tab
final
cast set _basedmntypeimpl_ type instead _dmntype_
a small suggestion add a default new _CODE_ case add some new scenario type
changed _public_ ? understand
cell
org drools core util StringUtils implementation
sake short codebase size ( ) = = 0 replaced isEmpty ( )
s removed METHOD_5 put current columns widht factmappings decided happen * * * * user saves scenario - rely status implementation manage
log necessary
preventing move context VAR_2 ( ) METHOD_6 ( true ) ; METHOD_5
want logging class asking log type resolved operator cell
util method * * delegation * * instead * * inheritance * * inheritance testeability
defaults TYPE_1 set TYPE_1 constructor
I prefer move methods simulation ( create methods change package private ) remove existing related _CODE_ scenario s remove header easy forget cleanup scenario s inconsistent data
worth resources : javatry ( final TYPE_2 VAR_1 = VAR_2 METHOD_2 ( path TYPE_4 VAR_4 ) ) { final String VAR_5 = TYPE_3 METHOD_3 ( VAR_1 null ) ; return METHOD_4 ( path VAR_5 ) ; }
super ( VAR_5 ) provide view base set view class don t need cast actual view
correct method ! ? I ( code ) show a popup restore file current version other editors VAR_2 _CODE_ ( path ) ; save success callbacks want check XLS score card editor upload file editor similar problems I ll compile PR _see_ s ; case code review misguided
I don t s easy : - ( IMO abuse _CODE_ tweaking s visual appearance class ( adding a _CODE_ ( boolean ) acceptable ) brings
want ideally package protected
Collections _CODE_ ( VAR_2 )
considered a strange implementation MVP ; P calling METHOD_1 ( ) calls METHOD_2 ( ) calls P call METHOD_2 some UI elements P call perform complete METHOD_2 call P call complete METHOD_2 ? I miss
a unwinding I code
GWT client side METHOD_1 tend trouble workaround
I m scared stupid result = result VAR_2 implementations happy ll scratching head _if_ _CODE_ start rolling V&V crazy a
I missed time d remove type logging ( I assume added debug tests )
find analysis panel starts a bit loopy ( IIRC ) want check METHOD_1 implementations - result = result type construct I dig original email
parameters TYPE_1 constructor lambda expressions statement shorter
replace : return VAR_1 [ 0 ] METHOD_2 ( ) getName ( ) equals ( VAR_1 [ 0 ] METHOD_3 ( ) getName ( ) ) ( s need / else )
method equals ( ) instead = =
remove VAR_2 attribute
I suggest : ( VAR_2 METHOD_3 ( i ) size ( ) = = 0 || VAR_2 METHOD_4 ( i ) size ( ) = = 0 ) {
catch needed
Boolean boolean
logic zip
private _CODE_ public
resources
TYPE_1 a runtime exception don t need declare
want avoid returning optional collection return empty collection
_CODE_ instead ? list necessary instead set
d a logger ignore exception propagate exception throwables propagate
[ curiosity ] expected beans registered VAR_2 set
slight perf cost resource bundles resolve languages calls METHOD_1 ( ) I m case done _CODE_ ( ) properly resolves label
access modifier method visible package subclasses classes package want
definition class session based ( _CODE_ ) change synchronizing entire _CODE_ instance removing a domain user session ends blocking another user another session storing domain removing model I don t understand done level synchronization required I don t suspect s specifically multi - threaded testing methods synchronized solves
File object construct VAR_8 file : new File ( VAR_1 VAR_7 + etx ) ;
please remove unused b r
please change TYPE_2 methods fields static imports
apparently bad practice : * I worried a I _CODE_ i e a / finally block
I disagree changes VAR_3 section please revert highlight fact VAR_3 code missing check _CODE_ ( _CODE_ ) isEmpty ( )
please change code match replaced I wanted exception thrown
please move METHOD_1 ( TYPE_1 ) METHOD_1 ( TYPE_2 ) helps reading code top ( clean code book uncle bob ) diff
VAR_3 created lazy
return VAR_3 SUSPENDED
a step wrap a TYPE_2 immediately unwrap
pass MAX_VALUE avoid introducing test flakyness
trim ? suggestionthis VAR_6 = VAR_3 VAR_6 ( ) trim ( ) ;
s protected suggestionprotected TYPE_6 ( TYPE_1 < byte [ ] byte [ ] > VAR_2 String VAR_3
initialization required
I want check instead key ? suggestionreturn record ( ) = = null ;
throw exception replace null empty string
don t need check VAR_1 = = null condition check covers
check replicate a bit s happening _CODE_ pass validations
question
fail VAR_1 empty ? simplify ? interested VAR_4 state ? need check previous state
line necessary ? isn t property logged INFO level worker starts TYPE_2 ( _CODE_ _CODE_ ) constructor
extra semi - colon
suggestionreturn new HashMap < > ( VAR_2 ( VAR_4 TimeUnit VAR_5 ) ; ) ;
bad suggestion inserted a typo I I start build suggestionreturn new HashMap < > ( VAR_4 ( VAR_6 TimeUnit VAR_7 ) ) ;
VAR_4 scoped class logs message want capture
prop : I add client contained set
s a nice blog : exception costs
exception
final return empty list ? avoid null
check ( isEmpty ( ) sense ) I avoid null
Q : consider stateful tasks METHOD_3 ( )
passing VAR_3 potentially check a helper function : private boolean0 VAR_5 ( ) { VAR_3 = = VAR_6 || VAR_3 = = VAR_7 ; }
move line 290
I feel internalize VAR_3 creation including null check : VAR_3 = TYPE_1 METHOD_1 ( VAR_2 ) ;
utility methods static
ah missed time perform METHOD_2 ( ) lambda time perform included latency
mocked VAR_1 store shouldn t need a put
suggestion
prop : I VAR_1 toString ( ) testing VAR_1 toString ( ) method assumption folder a equal result VAR_1 toString ( ) 0_1
prop : remove line need METHOD_7 ( ) need some expectation settings a call returns void e g METHOD_7 ( ) times ( 3 )
write state = METHOD_1 ( state ) ;
introduced PR : thinking I realized VAR_2 state need rely VAR_5 METHOD_2 fact METHOD_2 VAR_2
req : please need method suggestionreturn config getProperty ( TYPE_2 VAR_2 VAR_3 ) ;
hmm want capture exceptions TYPE_2 ? I s capture _CODE_ TYPE_2 thrown
calling close doesn t avoid warnings ? warnings coming
endup locking method s reason a block synchronized method applies similar method
consumer log METHOD_4 ( )
unneeded newline
assuming VAR_1 - empty
making protected instead mock a - class ? _CODE_ part public API want public ( a public API change ? )
I don t need delay adding store _CODE_ ( )
change generation VAR_2 VAR_1
s remove brace changes please
ensure testing state machine expected provide a valid VAR_1 similarly
wait ? I thought agreed fatal producer ? I a separate branch similar handling GROUP_AUTHORIZATION_FAILED
change logic answer true
simply return true ? written adjusting internal state isolate state manipulation places
need constructor
borderline overkill I m considering avoid copy logic : ( ! VAR_2 isEmpty ( ) ) return VAR_2 ; elsereturn VAR_3 ; basically relying group VAR_3 a superset local VAR_3 defined
parens unnecessary
want return a clone VAR_1 ? declare fields final update create a new TYPE_1 object I safely return cached object
don t need print stack trace ignore
pass false
I m wondering care concurrent modification list
cleaner move METHOD_4 logic a TYPE_1 METHOD_3 method performs METHOD_3 VAR_3 child batches
synchronized
java assert statement proper unit testing asserts assertThat ( e getMessage ( ) _CODE_ ( ) ) ;
req : unnecessary
VAR_3 set null constructor I wondering pass null ? ( similar question _CODE_ )
a public API s change need a TYPE_4 VAR_4 test create a static method _CODE_ change confined test code
move VAR_1 line
exists check s equal new information wanted register skip METHOD_2 metric + METHOD_3 metric dance
argument _CODE_ apply - - _CODE_ don t write read TYPE_2 happen
a bit awkward a _CODE_ call side effects I understand motivation I guess revisit a subsequent refactoring / follow - PR
VAR_3 ( ) mandate update ? need call VAR_5
I missing cases want regular expressions ? need mess predicate functions
VAR_13 a mock ? I feel state METHOD_3 called returning
need public ? making private forces method I good
hmm move check _CODE_ s catch block close
I able put VAR_4 TYPE_2 VAR_2 front capture returned put return previous previous null add VAR_4 null add VAR_3 save additional containsKey check
partitions ? assumption _CODE_ VAR_2 ( especially locking ) VAR_3
necessary
odd buffer a couple lines METHOD_2 ( ) refer
put @Override line
default implementation close ( ) wait s reasoning TYPE_1 VAR_3
outdated debug statement ? add a similar line METHOD_2 ( )
wrong unsynchronized access a map more stale inconsistent data null pointer exceptions other issues access synchronization
functions private intention accessed other classes
simplified : METHOD_2 ( VAR_1 ) && VAR_2 = = VAR_3 ( VAR_1 )
exception longer thrown
doesn t VAR_5 ( VAR_1 ) exist
put a variable
ternary operator easier
long separate tags VAR_4 primary tasks commit I don t metrics messed
s ? finally block
return VAR_3 instanceof TYPE_1 ? ( TYPE_1 ) VAR_3 : null ; wdyt ? instanceof closer cast s concise
extend _CODE_
default access constructors result types similarly _CODE_
method static depend local state _CODE_
default access
METHOD_2 ( VAR_1 ( new line )
synchronized
mentioned offline a behavioral change previously didn t validate offset reset case I offset returned _CODE_ request VAR_6 I simple Optional empty ( ) defining position
VAR_3 ! = null && VAR_3 < = VAR_2
I inverted
method static
null checks a single place METHOD_3 ( ) - - other methods < _CODE_ > t null ( please remove parameter consistency )
typo : moreq - > more
motivation change
line long
default access good enough consistent _CODE_
I simplify functions : javaprivate static byte METHOD_1 ( ByteBuffer buffer TYPE_1 input TYPE_2 VAR_1 ) throws IOException { ( buffer VAR_3 ( ) < 1 ) METHOD_2 ( buffer input VAR_1 ) ; return buffer ( ) ; } private static long _CODE_ ( ByteBuffer buffer TYPE_1 input TYPE_2 VAR_1 ) throws IOException { ( buffer VAR_3 ( ) < 10 && VAR_1 > 0 ) METHOD_2 ( buffer input VAR_1 ) ; return _CODE_ _CODE_ ( buffer ) ; } private static int _CODE_ ( ByteBuffer buffer TYPE_1 input TYPE_2 VAR_1 ) throws IOException { ( buffer VAR_3 ( ) < 10 && VAR_1 > 0 ) METHOD_2 ( buffer input VAR_1 ) ; return _CODE_ _CODE_ ( buffer ) ; } I shouldn t need more call METHOD_2
NPE prone check map null need check map simply call : suggestionif ( map ! = null ) { return map ( key ) ; }
I error prone _CODE_ guidance error prone require some configuration ignore autogenerated folders
suggestionif ( f = = null || f equals ( TYPE_3 VAR_2 ) ) {
A question : omitting map isEmpty ( ) check intended ? overrided default method check a null check done
please TYPE_1 INTEGER instead 4
simpler return : return METHOD_2 ( VAR_5 ) > 0 && METHOD_2 ( VAR_6 ) = = 0
beginning VAR_2 = = null || ! _CODE_
works a bit weird return Object returning a TYPE_1 ( s VAR_2 tranfsorm method ) a critical issue fix
system outs tests please ( some leftovers )
generics new HashMap < > ( ) ;
thanks a clear describe cache condition tend braces single line statements
formatting } else { I won t repeat occurrences please check diffs changes ( ) respect coding conventions
bit a nitpick - else : ( VAR_2 ( STRING_1 ) instanceof TYPE_1 ) { return null } else { } a bit clearer
tend braces placing a statement a seperate line check developers guide sun - java - conventions + 100 cols
covered need _CODE_
underscore a dash
s s confusing TYPE_4 referenced TYPE_1 constant pull request
block
VAR_7 variable need simply : return VAR_4 build ( ) ;
minor suggestions : please check formatting ( need some whitespaces ) I personally ! hasNext ( ) instead explicit check false ( = = null && ! hasNext ( ) ) {
public ? method else
static class
shouldn t call empty constructor ? empty constructor useless code
done a QA run ensure closed writers return hasNext ( ) : false ( thrown IOException ) lets stick consistency ( principle surprise )
add a final ensure set : final TYPE_1 VAR_2
discussions other _CODE_ agreed approach good suppresses kinds system < code > error < / code > s supposed system failures
write METHOD_2 ( VAR_1 ) METHOD_3 ( project ) ; ( other places static imports )
a type - check
a safety precaution assignment grab line number case generated synthetic lambda method more line numbers
TODO + logger level DEBUG
nope I missed
return promise symmetric start ( )
a synchronization step a lines TYPE_1 clarity synchronize operations start method
canonical write avoids repetition METHOD_2 a bit error prone String line ; ( ( line = VAR_1 METHOD_2 ( ) ) ! = null ) { println ( VAR_2 + line ) ; } : good ! don t forget indent code properly
exception constructors - static classes setters key word isn t needed
suggestion
[ _CODE_ ] ( ) I VAR_5 treated VAR_2 return a zero exit status
a matter taste I : ( VAR_2 = = null ) { VAR_3 put ( VAR_1 METHOD_2 ( ) VAR_1 ) ; } else ( ! METHOD_3 ( VAR_2 VAR_1 ) ) { throw new TYPE_2 ( VAR_2 VAR_1 ) ; } a method named METHOD_1 ( VAR_2 = = null || METHOD_3 ( VAR_2 VAR_1 ) ) triggered a add VAR_1 cases put overwrites VAR_2 step definition new
don t ask remove METHOD_2 ( ) add a TYPE_4 METHOD_1 ( ) method instead
keft
turn a positive check / guard clause sojavaif ( VAR_1 isEmpty ( ) ) { return false ; } removes level nesting easier read reader s immediately VAR_1 empty return
move boilerplate _CODE_ request ; TYPE_2 VAR_5 ; class fields andjavarequest = new TYPE_1 ( ) ; VAR_5 METHOD_2 ( request ) ; _CODE_ method tests cleaner diferences request VAR_1 ( )
done _CODE_
assertThat ( ( ) )
loop ? size 1
assertThat ( ( ) )
_CODE_ _CODE_ order object
remove assertion title identifier
return a java File ? ensure exists VAR_3 writable return java file user method doesnt deal some
final
inline null
inline null
shouldnt hardcoding URL
need throws Exception
catch block redundant exceptions caught logged METHOD_2 method
method synchronized
lowercase boolean - primitive type
< table data - meta = generated_by_salesforcesdk > < tbody > < tr > < td > : warning : < / td > < td width = 100% data - sticky = false > < span < code > apply ( ) < / code > instead ; < code > commit < / code > writes data persistent storage immediately < code > apply < / code > handle background < / td > < / tr > < / tbody > < / table >
remove synchronized keyword method move method
don t need a super METHOD_1 ( ) call
minor : change log line url correctly reflect URL loaded
app compiled smartstore / smartsync TYPE_1 instead set flag _CODE_ java getInstance
a METHOD_1 method TYPE_4 _CODE_
call method _CODE_ ( ) instead
static
static
static
static
static call s need instantiate util class time
remove throws Exception catching triggering METHOD_3
I don t muck part
return
I don t enforce java 7 a minimum java 6 syntax
missing semi - colon compilation error ? ; - )
don t need METHOD_3 ( ) a null check
log exception : Log e ( STRING_1 STRING_2 e ) ;
want move call _CODE_ ( ) reason fast user switching account switch occurs activity ll stuck a handle _CODE_ ( variable VAR_4 won t updated )
reason instanceof check add METHOD_1
a hard time return METHOD_4 ( VAR_1 METHOD_2 ( VAR_1 METHOD_3 ( ) - 1 ) ? I m dense I t understand reason _CODE_ / _CODE_ / METHOD_5 code
pass enum work
change _CODE_ ( STRING_1 ) rid casting stuff
extra file
_CODE_ put 3 load methods proximity other
private
change isn t needed
oops
( position = = 0 ) expresses
( ! hasNext ( ) )
I modified test ensure METHOD_3 symmetrical test failed NPE : void METHOD_1 ( ) { _CODE_ ( STRING_1 STRING_2 true ) ; } private void _CODE_ ( String wkt String _CODE_ boolean METHOD_3 ) { assertEquals ( TYPE_1 METHOD_2 ( wkt ) METHOD_3 ( TYPE_1 METHOD_2 ( _CODE_ ) ) METHOD_3 ) ; assertEquals ( TYPE_1 METHOD_2 ( _CODE_ ) METHOD_3 ( TYPE_1 METHOD_2 ( wkt ) ) METHOD_3 ) ; } failure : java lang _CODE_ esri core geometry _CODE_ relate ( _CODE_ java : 45 ) esri core geometry _CODE_ execute ( _CODE_ java : 31 ) esri core geometry _CODE_ disjoint ( _CODE_ java : 376 ) esri core geometry ogc TYPE_1 disjoint ( TYPE_1 java : 275 ) esri core geometry ogc TYPE_1 METHOD_3 ( TYPE_1 java : 280 ) esri core geometry _CODE_ _CODE_ ( _CODE_ java : 1007 ) esri core geometry _CODE_ METHOD_1 ( _CODE_ java : 1001 )
es este 1

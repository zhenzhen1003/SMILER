public void METHOD_1 ( ) { String VAR_1 = TYPE_1 . getInstance ( ) . getString ( STRING_1 , null ) ; <START> VAR_2 = TYPE_2 . METHOD_2 ( STRING_2 , VAR_1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { <END> METHOD_3 ( ) ; } return VAR_2 . METHOD_1 ( ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { Collection < TYPE_4 > VAR_3 = METHOD_2 ( null , null , VAR_2 . METHOD_3 ( ) , null , <START> ( VAR_2 . METHOD_3 ( ) != null ? TYPE_5 . METHOD_4 ( VAR_2 . METHOD_3 ( ) ) : "" ) , <END> null ) ; return METHOD_5 ( TYPE_1 . VAR_4 . VAR_5 , VAR_1 , VAR_3 ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , boolean VAR_3 , TYPE_2 < TYPE_3 > VAR_4 ) { super ( VAR_2 , VAR_3 ) ; if ( VAR_3 && ! ( VAR_4 instanceof TYPE_4 ) ) { throw new IllegalStateException ( STRING_1 + VAR_4 + STRING_2 + TYPE_4 . class . METHOD_1 ( ) + STRING_3 ) ; <START> } <END> this . VAR_4 = VAR_4 ; } 
public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 outputStream ) throws IOException { if ( VAR_1 == null || outputStream == null ) { if ( outputStream != null ) { TYPE_3 . METHOD_2 ( outputStream ) ; } return ; } try { TYPE_3 . METHOD_3 ( VAR_1 , outputStream ) ; } finally { TYPE_3 . METHOD_2 ( outputStream ) ; <START> return ; <END> } } 
protected void METHOD_1 ( ) throws Throwable { <START> if ( session == null ) { <END> throw new IllegalStateException ( STRING_1 ) ; } session . execute ( String . format ( STRING_2 + STRING_3 , VAR_1 ) ) ; session . execute ( String . format ( STRING_4 , VAR_1 ) ) ; } 
private void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( ( ) - > { METHOD_4 ( ) . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; <START> VAR_1 . METHOD_7 ( TYPE_4 . VAR_3 ) ; <END> TYPE_3 . METHOD_8 ( VAR_1 . METHOD_9 ( ) , TYPE_4 . VAR_3 ) ; METHOD_4 ( ) . METHOD_10 ( ) ; return null ; } ) ; } 
public synchronized void close ( ) { try { TYPE_1 VAR_1 = TYPE_1 . create ( ) ; if ( VAR_2 != null ) { VAR_1 . METHOD_1 ( VAR_2 ) ; } VAR_1 . METHOD_1 ( VAR_3 ) ; VAR_1 . close ( ) ; } catch ( IOException e ) { <START> LOG . warn ( STRING_1 , e . getMessage ( ) ) ; <END> } VAR_4 = true ; } 
public void METHOD_1 ( ) { <START> Logger logger = Logger . VAR_1 ( TYPE_1 . class . getName ( ) ) ; <END> Level VAR_2 = logger . VAR_3 ( ) ; logger . VAR_4 ( Level . VAR_5 ) ; new TYPE_2 ( ) . METHOD_2 ( ) ; logger . VAR_4 ( VAR_2 ) ; } 
public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( STRING_1 ) ; int VAR_2 = VAR_3 . METHOD_3 ( ) ; assertEquals ( STRING_2 , 2 , VAR_2 ) ; VAR_3 . METHOD_2 ( STRING_3 ) ; VAR_2 = VAR_3 . METHOD_3 ( ) ; assertEquals ( STRING_2 , 2 , VAR_2 ) ; VAR_3 . METHOD_2 ( STRING_4 ) ; VAR_2 = VAR_3 . METHOD_3 ( ) ; assertEquals ( STRING_5 , 0 , VAR_2 ) ; <START> <END> } 
public TYPE_2 ( TYPE_1 server ) { <START> this ( server , new HashMap < String , Object > ( ) ) ; <END> } 
public TYPE_1 < TYPE_2 > execute ( final TYPE_3 context ) { final TYPE_1 < TYPE_2 > results = METHOD_1 ( context ) ; if ( ! results . getType ( ) . equals ( TYPE_1 . Type . VAR_1 ) ) { <START> final org . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . VAR_7 . TYPE_4 VAR_7 = METHOD_2 ( context ) ; <END> VAR_7 . METHOD_3 ( VAR_9 ) ; METHOD_4 ( context ) . METHOD_3 ( VAR_9 ) ; } return results ; } 
<START> private static void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> throw new TYPE_2 ( VAR_1 , STRING_1 ) ; } 
public static < T > TYPE_1 < T > METHOD_1 ( TYPE_2 < T > message ) { Assert . VAR_1 ( message , STRING_1 ) ; if ( message instanceof TYPE_3 ) { logger . warn ( STRING_2 + STRING_3 ) ; <START> } <END> return new TYPE_1 < T > ( message ) ; } 
public TYPE_1 METHOD_1 ( Object element , int VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) element ; switch ( VAR_1 ) { case 0 : return METHOD_2 ( ) ; case 1 : try { <START> return METHOD_3 ( Integer . parseInt ( VAR_2 . METHOD_4 ( ) ) ) ; <END> } catch ( Exception e ) { break ; } case 2 : try { return METHOD_5 ( Integer . parseInt ( VAR_2 . METHOD_6 ( ) ) ) ; } catch ( Exception e ) { break ; } } return null ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public static TYPE_1 METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { <START> return VAR_1 . contains ( TYPE_1 . VAR_2 ) ? TYPE_1 . VAR_2 : VAR_1 . iterator ( ) . next ( ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( Collection < TYPE_3 > VAR_1 , long VAR_2 ) { if ( VAR_3 != null ) { TYPE_4 VAR_4 = VAR_5 . METHOD_2 ( VAR_2 ) ; TYPE_1 < TYPE_2 > VAR_6 = METHOD_3 ( VAR_1 , VAR_4 ) ; <START> return VAR_6 . METHOD_4 ( ( ) - > METHOD_5 ( VAR_2 ) ) ; <END> } else { METHOD_5 ( VAR_2 ) ; return TYPE_5 . METHOD_6 ( ) ; } } 
public TYPE_1 apply ( List < TYPE_2 > args , TYPE_2 . TYPE_5 VAR_1 ) { if ( args . size ( ) >= 1 ) { throw new TYPE_4 ( STRING_1 , name ( ) ) ; } <START> return TYPE_1 . of ( Math . VAR_2 ) ; <END> } 
public static List < TYPE_1 > METHOD_1 ( TYPE_2 project ) throws TYPE_3 { ArrayList < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; for ( TYPE_4 <START> VAR_2 : <END> project . VAR_3 ( ) ) { VAR_1 . add ( TYPE_1 . METHOD_2 ( VAR_2 , project ) ) ; } return VAR_1 ; } 
public final List < TYPE_1 > METHOD_1 ( final TYPE_2 < TYPE_1 > VAR_1 , final List < TYPE_1 > VAR_2 ) { return this . METHOD_2 ( METHOD_3 ( TYPE_4 . VAR_4 . METHOD_4 ( ) , VAR_2 . METHOD_5 ( TYPE_3 < TYPE_1 , TYPE_1 , Boolean > METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ) ) ) ; <START> } <END> 
public Builder METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; <START> this . VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> return this ; } 
public Integer METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( TYPE_2 . METHOD_3 ( VAR_1 ) ) { return VAR_1 . METHOD_4 ( ) ; } <START> return super . METHOD_1 ( ) ; <END> } 
TYPE_4 ( TYPE_1 config , TYPE_2 < TYPE_3 > VAR_2 ) { METHOD_1 ( config , STRING_1 ) ; METHOD_1 ( VAR_2 , STRING_2 ) ; <START> METHOD_2 ( config . VAR_3 ( ) . METHOD_3 ( ) >= 10 , STRING_3 ) ; <END> METHOD_2 ( config . VAR_4 ( ) . METHOD_3 ( ) >= 10 , STRING_4 ) ; VAR_5 = METHOD_4 ( config , VAR_2 ) ; } 
public void METHOD_1 ( ) { <START> if ( VAR_1 ) { METHOD_2 ( ) ; } <END> VAR_2 = null ; VAR_3 = null ; VAR_4 = null ; VAR_5 = null ; VAR_6 = null ; METHOD_3 ( ) ; super . METHOD_1 ( ) ; } 
public void METHOD_1 ( Throwable error ) { if ( error == null ) { throw new TYPE_1 ( STRING_1 ) ; } if ( error instanceof TYPE_2 ) { TYPE_3 e = new TYPE_3 ( error . getMessage ( ) ) ; e . VAR_1 ( error ) ; <START> error = e ; <END> } VAR_2 . add ( error ) ; } 
protected void METHOD_1 ( ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> return ; } super . METHOD_1 ( ) ; } 
public String get ( String key ) { <START> Map < String , String > Map = VAR_1 . get ( ) ; <END> if ( ( Map != null ) && ( key != null ) ) { return Map . get ( key ) ; } else { return null ; } } 
public void METHOD_1 ( Class < ? > from , Class < ? > to ) { METHOD_2 ( ) ; boolean VAR_1 = false ; for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_3 ( ) . equals ( from ) && VAR_2 . METHOD_4 ( ) . equals ( to ) ) { VAR_1 = true ; break ; } } if ( ! VAR_1 ) { <START> METHOD_5 ( String . format ( TYPE_2 . METHOD_6 ( ) , STRING_1 , VAR_3 , from , to ) ) ; <END> } } 
public synchronized void METHOD_1 ( long VAR_1 ) { VAR_2 . put ( Long . VAR_3 , VAR_4 , VAR_5 , VAR_1 ) ; <START> VAR_6 . METHOD_2 ( VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { try { <START> Thread . VAR_2 ( TimeUnit . VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) ; <END> } catch ( InterruptedException e ) { } } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> if ( ! ( VAR_1 instanceof TYPE_2 ) ) { throw new IllegalStateException ( STRING_1 ) ; } TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 ; try { VAR_1 . METHOD_3 ( null ) ; } catch ( TYPE_3 VAR_4 ) { LOG . VAR_5 ( VAR_4 ) ; } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_2 . contains ( new Integer ( VAR_1 . METHOD_2 ( ) ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 ) <END> return VAR_2 ; return super . METHOD_1 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 < String , TYPE_3 > VAR_1 , String VAR_2 ) { logger . debug ( STRING_1 , VAR_2 ) ; try { TYPE_4 config = METHOD_2 ( VAR_1 ) ; if ( config != null ) { return METHOD_3 ( config , VAR_3 - > StringUtils . equals ( VAR_2 , VAR_3 . getString ( VAR_4 ) ) ) ; } } catch ( TYPE_5 e ) { <START> logger . error ( STRING_2 , e ) ; <END> } return null ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ; <END> } 
public TYPE_1 METHOD_1 ( final TYPE_2 args ) { TYPE_1 VAR_1 = new TYPE_1 ( null , null , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 ) ; <START> VAR_1 . METHOD_2 ( VAR_9 ) ; <END> return VAR_1 ; } 
public String toString ( ) { <START> return STRING_1 + VAR_1 . METHOD_1 ( ) + STRING_2 ; <END> } 
<START> TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 < T > > VAR_2 ) { <END> return METHOD_1 ( VAR_1 , VAR_2 , true ) ; } 
private static synchronized TYPE_1 session ( ) { final TYPE_2 properties = new TYPE_2 ( ) ; <START> final TYPE_3 conf = TYPE_4 . METHOD_1 ( ) ; <END> properties . put ( STRING_1 , conf . VAR_1 ( ) ) ; properties . put ( STRING_2 , conf . VAR_2 ( ) ) ; properties . put ( STRING_3 , conf . VAR_3 ( ) ) ; properties . put ( STRING_4 , conf . VAR_4 ( ) ) ; VAR_5 = TYPE_1 . METHOD_2 ( properties , null ) ; return VAR_5 ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 < String > VAR_1 = new TYPE_1 < String > ( 1 ) ; VAR_1 . add ( METHOD_2 ( TYPE_2 . class ) ) ; TYPE_3 t = new TYPE_3 ( ) { @Override public void METHOD_3 ( ) throws Throwable { <START> VAR_1 . add ( METHOD_2 ( TYPE_2 . class ) ) ; <END> } } ; t . start ( ) ; t . VAR_2 ( ) ; t . VAR_3 ( InterruptedException . VAR_4 ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { METHOD_2 ( ) ; super . METHOD_1 ( VAR_1 ) ; METHOD_3 ( null ) ; if ( VAR_1 != null ) { <START> VAR_2 . remove ( VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ) ; <END> } } 
private String METHOD_1 ( int line ) { TYPE_1 VAR_1 = <START> db . VAR_2 ( ) . map ( VAR_3 . METHOD_2 ( line ) ) ; <END> if ( VAR_1 == null ) return "" ; String name = VAR_4 ? VAR_1 . METHOD_3 ( ) : VAR_1 . getName ( ) ; return name != null ? name : "" ; } 
<START> public void METHOD_1 ( ) { <END> View view = METHOD_2 ( ) ; if ( view == null ) { return ; } METHOD_3 ( ) . METHOD_4 ( view , this ) ; if ( VAR_1 == null ) { return ; } for ( TYPE_1 VAR_2 : VAR_1 . METHOD_5 ( ) ) { METHOD_3 ( ) . METHOD_4 ( VAR_2 , this ) ; } METHOD_3 ( ) . METHOD_4 ( VAR_1 , this ) ; VAR_1 = null ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , boolean VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_5 = new TYPE_3 < > ( ) ; VAR_5 <START> . add ( ( event , VAR_6 ) - > METHOD_1 ( this , event , VAR_6 . METHOD_2 ( ) , VAR_7 ) ) ; <END> } 
public void METHOD_1 ( ) throws IOException { <START> METHOD_2 ( TYPE_2 . VAR_2 , STRING_1 ) ; <END> METHOD_2 ( TYPE_2 . VAR_3 , STRING_2 ) ; METHOD_2 ( TYPE_2 . VAR_3 , TYPE_1 . VAR_5 ) ; METHOD_2 ( TYPE_2 . VAR_6 , STRING_3 ) ; } 
public TYPE_1 METHOD_1 ( Map < String , String > VAR_1 ) { for ( Map . Entry < String , String > entry : METHOD_2 ( VAR_1 , STRING_1 ) . entrySet ( ) ) { METHOD_2 ( entry . getKey ( ) , STRING_2 ) ; METHOD_2 ( entry . getValue ( ) , STRING_3 ) ; <START> } <END> this . VAR_1 = TYPE_3 < Map < String , String > > of ( TYPE_2 . METHOD_3 ( VAR_1 ) ) ; return this ; } 
private String METHOD_1 ( TYPE_1 method ) { <START> if ( METHOD_2 ( method ) ) { <END> return STRING_1 ; } else if ( method . VAR_1 ( ) . METHOD_3 ( ) != null ) { TYPE_2 VAR_2 = method . VAR_1 ( ) . METHOD_3 ( ) ; return STRING_2 + VAR_2 . METHOD_4 ( ) + STRING_3 ; } return STRING_2 + method . VAR_1 ( ) . METHOD_5 ( ) + STRING_3 ; } 
protected TYPE_1 METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( METHOD_3 ( ) ) ; <END> } 
private boolean METHOD_1 ( String value , String VAR_1 ) { boolean VAR_2 = true ; <START> if ( value != null && StringUtils . VAR_3 ( value ) ) { <END> VAR_2 = value . VAR_4 ( VAR_1 ) ; } return VAR_2 ; } 
public void METHOD_1 ( int VAR_1 , String VAR_2 ) { <START> if ( super . getStatus ( ) == VAR_3 ) { <END> super . METHOD_1 ( VAR_1 , VAR_2 ) ; } status = VAR_1 ; } 
public final TYPE_1 METHOD_1 ( ) { final int [ ] buffer = this . buffer ; for ( int start = 0 , VAR_1 = size ( ) - 1 ; start < VAR_1 ; start ++ , VAR_1 -- ) { <START> int VAR_2 = buffer [ start ] ; <END> buffer [ start ] = buffer [ VAR_1 ] ; buffer [ VAR_1 ] = VAR_2 ; } return this ; } 
public Collection < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { final Collection < TYPE_6 . TYPE_7 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , false ) ; <START> final Set < TYPE_1 > VAR_4 = new TYPE_4 < TYPE_1 > ( VAR_2 . size ( ) ) ; <END> for ( TYPE_6 . TYPE_7 VAR_5 : VAR_2 ) { final TYPE_5 VAR_6 = VAR_5 . METHOD_3 ( ) ; if ( VAR_6 instanceof TYPE_1 ) { VAR_4 . add ( ( TYPE_1 ) VAR_6 ) ; } } return VAR_4 ; } 
public int METHOD_1 ( String name ) { <START> if ( value == null ) { <END> return TYPE_1 . METHOD_2 ( name ) ? 0 : - 1 ; } else { return value . equals ( name ) ? 0 : - 1 ; } } 
<START> public String METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( TYPE_6 . VAR_4 ) ; TYPE_3 VAR_5 = VAR_2 . METHOD_3 ( VAR_1 ) ; File file = null ; try { file = new File ( TYPE_4 . METHOD_4 ( VAR_5 ) . METHOD_5 ( ) ) ; } catch ( TYPE_5 | IOException e ) { e . VAR_6 ( ) ; } return file . VAR_7 ( ) ; } 
<START> private void METHOD_1 ( TYPE_2 . TYPE_3 . Type type , String VAR_1 ) { <END> switch ( type ) { case TYPE_5 : case TYPE_4 : VAR_4 . remove ( VAR_1 ) ; break ; case TYPE_6 : default : VAR_4 . add ( VAR_1 ) ; } VAR_6 = true ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( null ) ; <END> } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; <START> client . close ( ) ; <END> } 
private View METHOD_1 ( int VAR_1 , int VAR_2 ) { View view = new View ( METHOD_2 ( ) ) ; view . VAR_3 ( new TYPE_3 . TYPE_4 ( VAR_1 , VAR_2 ) ) ; view . VAR_4 ( true ) ; view . VAR_5 ( new View . TYPE_5 ( ) { @Override public boolean METHOD_3 ( View v , TYPE_2 event ) { if ( event . VAR_7 ( ) == TYPE_2 . VAR_8 ) { METHOD_4 ( ) ; } <START> return false ; <END> } } ) ; return view ; } 
public boolean METHOD_1 ( ) { if ( VAR_1 != null ) { boolean VAR_2 = METHOD_2 ( ) ; VAR_3 . METHOD_3 ( ) ; <START> if ( ! VAR_2 ) { return false ; } <END> } return ! VAR_4 ; } 
public void METHOD_1 ( ) { <START> offset = VAR_1 . VAR_2 . METHOD_2 ( 10 ) ; <END> } 
protected TYPE_1 < ? > METHOD_1 ( String VAR_1 ) { <START> List < TYPE_1 < ? > > VAR_2 = VAR_3 . query ( METHOD_2 ( TYPE_2 . VAR_5 ) , new Object [ ] { VAR_1 , VAR_6 , VAR_1 } , VAR_7 ) ; <END> Assert . VAR_8 ( VAR_2 . size ( ) == 0 || VAR_2 . size ( ) == 1 ) ; if ( VAR_2 . size ( ) > 0 ) { return VAR_2 . get ( 0 ) ; } return null ; } 
public static boolean METHOD_1 ( long VAR_1 , TimeUnit VAR_2 ) throws InterruptedException { Thread VAR_3 = TYPE_2 . VAR_3 ; if ( VAR_3 != null ) { VAR_3 . METHOD_2 ( <START> TYPE_1 . METHOD_3 ( VAR_2 , STRING_1 ) . METHOD_4 ( VAR_1 ) ) ; <END> return ! VAR_3 . METHOD_5 ( ) ; } else { return true ; } } 
public Builder METHOD_1 ( ) { Builder builder = new Builder ( type ) ; builder . VAR_1 . METHOD_2 ( VAR_1 ) ; <START> for ( Map . Entry < String , List < TYPE_1 > > entry : builder . VAR_1 . entrySet ( ) ) { <END> entry . VAR_2 ( new ArrayList < > ( entry . getValue ( ) ) ) ; } return builder ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . METHOD_2 ( new TYPE_2 ( null , null , null ) , VAR_1 ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 ) throws IOException { return METHOD_1 ( VAR_1 . METHOD_2 ( ) , <START> TYPE_5 . VAR_3 ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! VAR_2 . METHOD_2 ( ) . contains ( VAR_1 ) ) { <END> final TYPE_2 VAR_3 = METHOD_3 ( ) . METHOD_4 ( ) ; log . warn ( STRING_1 ) ; ( ( TYPE_3 ) VAR_3 ) . METHOD_5 ( TYPE_4 . VAR_5 ) ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 result = VAR_1 . METHOD_2 ( ) ; if ( result != TYPE_1 . VAR_2 ) { return result ; } <START> result = TYPE_2 . METHOD_3 ( repo , project ) ; <END> return TYPE_1 . VAR_2 ; } 
private int METHOD_1 ( final TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) == null || VAR_1 . METHOD_2 ( ) . trim ( ) . isEmpty ( ) ) { <END> return 1 ; } else { return VAR_1 . METHOD_3 ( ) . size ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( new TYPE_2 ( METHOD_4 ( VAR_1 ) , VAR_1 . METHOD_5 ( ) . getName ( ) ) . METHOD_6 ( METHOD_7 ( VAR_1 ) ) . METHOD_8 ( TYPE_3 . METHOD_9 ( STRING_1 ) , <START> TYPE_3 . METHOD_10 ( METHOD_7 ( VAR_1 ) ) <END> ) ) ; } 
public boolean METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> if ( super . METHOD_1 ( VAR_1 ) ) return true ; <END> for ( TYPE_1 VAR_2 : VAR_1 ) { if ( ! METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ) return false ; } return true ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 VAR_2 = null ; try { boolean VAR_3 = false ; VAR_2 = new TYPE_2 ( new TYPE_3 ( VAR_1 ) ) ; <START> for ( TYPE_4 entry ; ( entry = VAR_2 . METHOD_2 ( ) ) != null ; ) { <END> if ( TYPE_5 . equals ( entry . getName ( ) ) && entry . VAR_4 ( ) ) { VAR_3 = true ; break ; } } return VAR_3 ; } finally { TYPE_6 . close ( VAR_2 ) ; } } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; } 
public Object METHOD_1 ( ) { <START> return true ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , Boolean VAR_2 ) throws IOException , <START> TYPE_3 { <END> TYPE_4 description = METHOD_2 ( new TYPE_5 ( VAR_1 ) , VAR_2 ) ; TYPE_6 content = METHOD_3 ( description ) ; return new TYPE_1 ( content , description . getType ( ) ) ; } 
private void METHOD_1 ( ) { TYPE_1 < Integer > VAR_1 = METHOD_2 ( TYPE_1 . class ) ; map = new TYPE_2 < String , Integer > ( INT_1 , true , VAR_1 ) ; <START> when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( null ) ; <END> } 
protected TYPE_1 METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return VAR_2 ; } String VAR_3 = VAR_1 . substring ( VAR_1 . length ( ) - 1 ) ; switch ( VAR_3 ) { case VAR_4 : <START> return TYPE_2 . VAR_6 ; <END> case VAR_7 : return VAR_8 ; case VAR_9 : return VAR_10 ; case VAR_11 : return VAR_2 ; default : throw new IllegalArgumentException ( STRING_1 + VAR_3 ) ; } } 
void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { METHOD_2 ( VAR_1 , VAR_2 ) ; VAR_3 . get ( 0 ) . METHOD_3 ( VAR_4 , VAR_5 ) ; <START> for ( int i = 0 , s = VAR_3 . size ( ) ; s > i ; i ++ ) { <END> VAR_3 . get ( i ) . METHOD_1 ( VAR_4 , VAR_5 ) ; } } 
<START> void METHOD_1 ( double VAR_1 , double max ) <END> { this . VAR_1 = VAR_1 ; this . max = max ; } 
private void METHOD_1 ( TYPE_1 TYPE_2 ) { if ( VAR_1 . values ( ) . stream ( ) . map ( TYPE_3 : : METHOD_2 ) . METHOD_3 ( TYPE_2 : : equals ) ) { throw new TYPE_4 ( VAR_2 , format ( STRING_1 , TYPE_2 . toString ( ) ) ) ; } <START> if ( VAR_3 . keySet ( ) . stream ( ) <END> . METHOD_3 ( TYPE_2 : : equals ) ) { throw new TYPE_4 ( VAR_2 , format ( STRING_2 , TYPE_2 . toString ( ) ) ) ; } } 
<START> private static void METHOD_1 ( Collection < Pair < Object , String > > result , String element ) { <END> if ( element . length ( ) > 0 ) { List < String > list = Arrays . asList ( element . split ( STRING_1 ) ) ; list . forEach ( VAR_1 - > { String value = TYPE_1 . VAR_3 + VAR_1 . split ( STRING_2 ) [ 0 ] ; result . add ( new Pair < > ( value , value ) ) ; } ) ; } } 
public TYPE_1 METHOD_1 ( final String message ) { TYPE_2 . METHOD_2 ( ) ; METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( TYPE_3 . VAR_2 ) ) ; <START> METHOD_6 ( METHOD_7 ( TYPE_4 ) , <END> METHOD_7 ( TYPE_5 ) , TYPE_6 . VAR_6 ) ; return this ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 entity ) { TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 , entity . VAR_3 ( ) , <START> new TYPE_4 < TYPE_5 , TYPE_1 > ( ) { <END> @Override public TYPE_1 apply ( TYPE_5 VAR_4 ) { return VAR_5 . METHOD_3 ( new TYPE_6 ( ) , VAR_4 ) ; } } ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 node , Set < TYPE_3 < ? > > VAR_2 ) { TYPE_4 res = new TYPE_4 ( ) ; <START> node . forEach ( child - > { <END> res . VAR_3 ( false , METHOD_2 ( VAR_1 , child , VAR_2 ) ) ; } ) ; return res . get ( ) ; } 
<START> public HashMap < String , TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 < Integer > VAR_1 = new TYPE_1 < Integer > ( 1 , 5 , null ) ; <END> } 
public View METHOD_1 ( final TYPE_1 VAR_1 , ANNOTATION_1 final TYPE_2 container , ANNOTATION_1 final TYPE_3 VAR_2 ) { <START> View VAR_3 = VAR_1 . METHOD_2 ( R . VAR_4 . VAR_5 , null ) ; <END> return VAR_3 ; } 
<START> public Map < String , Integer > METHOD_1 ( ) throws IOException { <END> return VAR_1 . METHOD_2 ( ) . to ( METHOD_3 ( STRING_1 ) , HashMap . VAR_2 ) ; } 
public static TYPE_1 METHOD_1 ( final int VAR_1 ) { <START> if ( VAR_1 < 0 || VAR_1 > INT_1 ) { <END> throw new IllegalArgumentException ( String . format ( STRING_1 , VAR_1 ) ) ; } for ( TYPE_1 VAR_2 : TYPE_1 . values ( ) ) { if ( VAR_2 . VAR_1 == VAR_1 ) { return VAR_2 ; } } throw new IllegalArgumentException ( String . format ( STRING_1 , VAR_1 ) ) ; } 
public < R > R execute ( TYPE_1 < R > VAR_1 ) { <START> if ( VAR_2 . isEmpty ( ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } try { return VAR_1 . METHOD_1 ( ( ) - > METHOD_2 ( ) . VAR_3 , METHOD_3 ( ) ) ; } catch ( TYPE_2 e ) { throw new TYPE_3 ( STRING_2 , e , METHOD_3 ( ) ) ; } } 
private void METHOD_1 ( ) { if ( VAR_1 ) { out . VAR_2 ( STRING_1 ) ; } else if ( VAR_3 == TYPE_1 . VAR_5 ) { out . VAR_2 ( VAR_6 [ VAR_7 ] ) ; <START> VAR_8 = ( VAR_8 + 1 ) % VAR_6 . length ; <END> } else { out . VAR_9 ( STRING_2 , VAR_10 / VAR_3 ) ; } out . VAR_2 ( task ) ; if ( VAR_11 != null ) { out . VAR_9 ( STRING_3 , VAR_11 ) ; } out . VAR_2 ( CHAR_1 ) ; } 
default TYPE_2 < TYPE_3 < VAR_3 > > VAR_4 ( TYPE_1 < TYPE_4 > VAR_7 , Boolean VAR_8 ) { <START> throw new TYPE_5 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_1 path , TYPE_2 model ) { model = METHOD_2 ( path , model , <START> Arrays . asList ( TYPE_3 . TYPE_5 , TYPE_4 . Object ) ) ; <END> return METHOD_3 ( path , model ) ; } 
public final String METHOD_1 ( ) throws IOException { int VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == VAR_2 ) { return null ; } <START> METHOD_3 ( VAR_3 , VAR_1 ) ; <END> String result = new String ( data , VAR_3 , VAR_1 , VAR_4 ) ; VAR_3 += VAR_1 ; return result ; } 
private TYPE_1 METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) { throw new TYPE_2 ( STRING_1 ) ; } TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) ; TYPE_4 type = VAR_2 . getType ( ) ; <START> if ( ! type . equals ( TYPE_4 . VAR_3 ) ) { <END> throw new TYPE_2 ( STRING_2 + VAR_1 . METHOD_4 ( ) + STRING_3 + TYPE_4 . VAR_3 ) ; } return new TYPE_1 ( VAR_2 . METHOD_5 ( ) , VAR_2 . METHOD_6 ( ) , VAR_2 . METHOD_7 ( ) ) ; } 
private static void METHOD_1 ( ) { new TYPE_1 ( new TYPE_2 ( STRING_1 ) , TYPE_7 . VAR_2 ) ; TYPE_3 VAR_3 = new TYPE_3 ( STRING_1 ) ; String VAR_4 = VAR_3 . METHOD_2 ( ) ; new TYPE_4 ( STRING_2 ) . METHOD_3 ( ) ; <START> new TYPE_5 ( new TYPE_6 ( VAR_4 ) , TYPE_7 . VAR_2 ) ; <END> } 
public void METHOD_1 ( ) <START> throws Exception { <END> TYPE_1 . METHOD_2 ( ) ; } 
public void METHOD_1 ( TYPE_1 [ ] VAR_1 , String VAR_2 , TYPE_2 VAR_3 ) throws TYPE_3 { if ( VAR_4 instanceof TYPE_4 ) { <START> ( ( TYPE_4 ) VAR_4 ) . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <END> } else { throw new TYPE_5 ( ) ; } VAR_5 . METHOD_3 ( VAR_1 ) ; } 
private boolean METHOD_1 ( String VAR_1 ) { <START> TYPE_1 VAR_2 = TYPE_1 . getInstance ( ) ; <END> return VAR_2 . METHOD_2 ( VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 key ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( key ) . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ) ; try { METHOD_5 ( ) ; long VAR_3 = VAR_4 . METHOD_6 ( key ) ; if ( VAR_3 != 0 ) { TYPE_3 < TYPE_1 , TYPE_1 > VAR_5 = METHOD_7 ( VAR_3 , key ) ; <START> VAR_6 . METHOD_8 ( VAR_5 ) ; <END> METHOD_9 ( VAR_3 , key ) ; } } finally { VAR_1 . METHOD_10 ( ) ; } } 
<START> public static TYPE_1 METHOD_1 ( int VAR_1 , byte [ ] VAR_2 ) { <END> TYPE_1 VAR_3 = new TYPE_1 ( VAR_2 ) ; byte [ ] VAR_4 = null ; VAR_4 = TYPE_2 . METHOD_2 ( Integer . toString ( VAR_1 ) ) ; byte [ ] VAR_5 = TYPE_2 . METHOD_2 ( TYPE_3 . VAR_7 . toString ( ) . METHOD_3 ( ) ) ; VAR_3 . add ( Constants . VAR_8 , VAR_5 , VAR_4 ) ; return VAR_3 ; } 
<START> public Map < String , Object > METHOD_1 ( ) { <END> return this . metadata ; } 
protected TYPE_1 [ ] METHOD_1 ( TYPE_2 t ) { TYPE_1 [ ] node = new TYPE_1 [ 1 ] ; <START> if ( t . VAR_1 ( ) ) { <END> return node ; } else { node [ 0 ] = new TYPE_3 ( new TYPE_4 ( t , false ) , TYPE_5 . METHOD_2 ( ) . METHOD_3 ( ) ) ; return node ; } } 
public ByteBuffer METHOD_1 ( byte [ ] b , int offset , int length ) { <START> return b == null || b . length == 0 || length == 0 ? TYPE_1 . VAR_1 : new TYPE_1 ( b , offset , length ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( String VAR_1 ) { List < TYPE_1 > results = new ArrayList < > ( ) ; for ( TYPE_2 entry : VAR_2 . values ( ) ) { <START> if ( entry . VAR_3 <END> && entry . VAR_4 . METHOD_2 ( ) . < List > get ( TYPE_4 . TYPE_3 . VAR_7 ) . contains ( VAR_1 ) ) { results . add ( entry . VAR_4 ) ; } } return results ; } 
private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } final String VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . TYPE_4 . VAR_5 ) ; if ( ! TYPE_2 . METHOD_3 ( VAR_2 ) <START> && TYPE_3 . TYPE_4 . VAR_6 . equalsIgnoreCase ( VAR_2 ) ) { <END> return true ; } return false ; } 
public TYPE_1 METHOD_1 ( String name ) { if ( TYPE_2 . METHOD_2 ( name ) ) { TYPE_3 < TYPE_4 < ? > , TYPE_5 > VAR_1 = VAR_2 . get ( name ) ; if ( VAR_1 != null ) { TYPE_5 VAR_3 = VAR_1 . get ( VAR_1 . METHOD_3 ( ) ) ; <START> if ( VAR_3 instanceof TYPE_1 ) { <END> return ( TYPE_1 ) VAR_3 ; } } } return null ; } 
private TYPE_1 ( ) { name = "" ; VAR_2 = Type . VAR_3 ; <START> } <END> 
public void METHOD_1 ( Object instance ) { <START> VAR_1 . put ( instance . getClass ( ) . getName ( ) , new TYPE_1 < > ( ) ) ; <END> } 
protected String METHOD_1 ( String VAR_1 ) { StringBuilder sb = new StringBuilder ( ) ; <START> TYPE_1 VAR_2 = new TYPE_1 ( sb , TYPE_2 . VAR_4 ) ; <END> VAR_2 . format ( STRING_1 , VAR_1 , System . currentTimeMillis ( ) ) ; return sb . toString ( ) ; } 
TYPE_1 ( ) { <START> VAR_2 = VAR_3 . METHOD_1 ( ) . METHOD_2 ( new String [ VAR_3 . METHOD_1 ( ) . size ( ) ] ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( this . VAR_2 == null ) { <START> this . VAR_2 = new ArrayList < > ( ) ; <END> } this . VAR_2 . add ( VAR_1 ) ; return this ; } 
public TYPE_1 ( String VAR_2 , String name , double VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . name = name ; this . VAR_3 = VAR_3 ; } 
public boolean METHOD_1 ( Collection < ? > c ) { boolean VAR_1 = false ; <START> for ( Object VAR_2 : c ) { <END> VAR_1 |= remove ( VAR_2 ) ; } return VAR_1 ; } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> return VAR_1 != null ? VAR_1 . equals ( that . VAR_1 ) : that . VAR_1 == null ; <END> } 
<START> private TYPE_1 METHOD_1 ( ) { <END> final TYPE_1 VAR_1 = ( TYPE_1 ) this . VAR_2 . get ( ) . METHOD_2 ( ) ; final TYPE_2 factory = VAR_1 . METHOD_3 ( ) ; return factory . VAR_3 ( ) ; } 
Pair < TYPE_1 , List < TYPE_2 > > METHOD_1 ( final List < TYPE_2 > VAR_1 ) { if ( VAR_2 . size ( ) > VAR_3 ) { throw new IllegalStateException ( <START> STRING_1 ) ; <END> } Pair < TYPE_1 , List < TYPE_2 > > VAR_4 = METHOD_2 ( ) ; VAR_2 . add ( VAR_1 ) ; return VAR_4 ; } 
<START> public Optional < Guid > <END> METHOD_1 ( ) { return METHOD_2 ( ) ? Optional . empty ( ) : Optional . VAR_1 ( METHOD_3 ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; TYPE_3 VAR_3 = null ; for ( TYPE_3 VAR_4 : METHOD_2 ( ) ) { <START> if ( VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) . equalsIgnoreCase ( VAR_1 . METHOD_4 ( ) ) ) { <END> VAR_3 = VAR_4 ; break ; } } if ( VAR_3 != null ) { VAR_3 . METHOD_5 ( ) ; } else { throw new IllegalStateException ( STRING_2 ) ; } return this ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 <START> VAR_2 : <END> VAR_3 ) { if ( ! METHOD_2 ( VAR_2 . getType ( ) , VAR_1 ) ) { return false ; } } return true ; } 
public TYPE_1 METHOD_1 ( ) throws IOException { if ( VAR_1 . METHOD_2 ( ) ) { String VAR_2 = VAR_1 . METHOD_3 ( ) ; <START> VAR_3 . METHOD_4 ( VAR_2 ) ; <END> TYPE_2 VAR_4 = VAR_5 . METHOD_5 ( VAR_3 ) ; if ( VAR_4 != null ) { return new TYPE_3 ( VAR_3 , VAR_4 ) ; } } return null ; } 
public boolean equals ( final Object o ) { if ( this == o ) { return true ; } <START> if ( o == null || getClass ( ) != o . getClass ( ) ) { <END> return false ; } final TYPE_1 that = ( TYPE_1 ) o ; return VAR_1 . equals ( that . VAR_1 ) ; } 
public void METHOD_1 ( ) { final TYPE_1 < Boolean > VAR_1 = METHOD_2 ( VAR_2 . VAR_3 ) ; final TYPE_2 p = METHOD_3 ( VAR_1 , VAR_1 , ( VAR_4 , VAR_5 ) - > METHOD_4 ( VAR_4 . equals ( VAR_5 ) ) <START> . METHOD_5 ( new TYPE_3 ( VAR_4 ) . METHOD_6 ( ) == new TYPE_3 ( VAR_5 ) . METHOD_6 ( ) ) ) ; <END> TYPE_4 . METHOD_7 ( p ) ; } 
private void update ( ) { if ( VAR_1 . METHOD_1 ( false , true ) ) { try { TYPE_1 response = reader . call ( ) ; if ( response . VAR_2 ( ) ) { VAR_3 = response . VAR_4 ( ) ; METHOD_2 ( this ) ; } } catch ( Exception e ) { try { METHOD_3 ( e , this ) ; } catch ( Exception VAR_5 ) { <START> LOG . warn ( STRING_1 ) ; <END> } } finally { VAR_1 . set ( false ) ; } } } 
<START> public TYPE_4 . TYPE_5 . VAR_1 . VAR_2 . Response METHOD_1 ( TYPE_2 e ) { <END> TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_3 . METHOD_2 ( STRING_1 ) ; VAR_3 . METHOD_3 ( e . getMessage ( ) ) ; return Response . status ( Response . Status . VAR_4 ) . entity ( VAR_3 ) . build ( ) ; } 
static long METHOD_1 ( final File VAR_1 ) throws IOException { final Path path = TYPE_1 . get ( VAR_1 . getPath ( ) , TYPE_5 . VAR_3 ) ; if ( ! TYPE_2 . exists ( path ) ) { final long VAR_4 = TYPE_3 . METHOD_2 ( VAR_1 ) ; TYPE_4 . METHOD_3 ( path , VAR_4 ) ; } <START> return TYPE_4 . METHOD_4 ( path ) ; <END> } 
public void METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) throws IOException { <START> int VAR_3 = TYPE_2 . METHOD_2 ( VAR_2 ) ; <END> VAR_4 = new TYPE_3 ( VAR_3 , VAR_2 ) ; } 
@Override public boolean METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( new TYPE_1 . Builder ( METHOD_3 ( ) ) . build ( ) ) ; <END> return true ; } 
public long METHOD_1 ( ANNOTATION_1 TimeUnit VAR_1 ) { <START> return TimeUnit . VAR_2 . METHOD_2 ( this . METHOD_1 ( ) , VAR_1 ) ; <END> } 
public TYPE_2 ( Map < Class < ? > , TYPE_1 > VAR_2 , TYPE_1 VAR_3 ) { Assert . VAR_4 ( VAR_3 , STRING_1 ) ; this . VAR_3 = VAR_3 ; <START> this . VAR_2 = VAR_2 ; <END> } 
<START> public T get ( ) { <END> return METHOD_1 ( VAR_1 ) ; } 
private void METHOD_1 ( List < TYPE_1 > VAR_1 ) { VAR_2 . clear ( ) ; Collections . VAR_3 ( VAR_1 ) ; List < TYPE_2 > VAR_4 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_5 : VAR_1 ) { VAR_4 . add ( new TYPE_2 ( VAR_5 , VAR_6 , VAR_7 ) ) ; } VAR_2 . addAll ( VAR_4 , ! VAR_8 ) ; <START> VAR_9 = VAR_4 ; <END> } 
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 options = ( TYPE_1 ) o ; if ( VAR_1 != options . VAR_1 ) return false ; if ( VAR_2 != options . VAR_2 ) return false ; <START> return VAR_3 == options . VAR_3 ; <END> } 
<START> protected abstract TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <END> throws IOException ; protected final TYPE_3 METHOD_2 ( TYPE_2 VAR_1 , TYPE_1 VAR_2 ) throws IOException { if ( VAR_2 == null || VAR_2 instanceof TYPE_3 ) { return ( TYPE_3 ) VAR_2 ; } String path = TYPE_4 . METHOD_3 ( VAR_1 ) ; return TYPE_3 . of ( VAR_1 . METHOD_4 ( ) , path , VAR_2 ) . METHOD_5 ( this ) ; } 
public TYPE_2 ( String VAR_2 , String VAR_3 ) { super ( STRING_1 ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = TYPE_1 . METHOD_1 ( VAR_3 , VAR_4 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { if ( VAR_1 != null ) VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null ) TYPE_1 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <START> if ( VAR_3 != null ) TYPE_1 . METHOD_3 ( VAR_3 . METHOD_5 ( ) . METHOD_4 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 info ) { TYPE_2 group = info . VAR_1 ( ) ; if ( group != null ) { METHOD_2 ( group ) ; } Object [ ] VAR_2 = VAR_3 . METHOD_3 ( ) ; <START> for ( Object element : VAR_2 ) { <END> TYPE_3 listener = ( TYPE_3 ) element ; if ( ! METHOD_4 ( info . VAR_4 ( ) , listener . VAR_5 ( ) ) ) { listener . VAR_6 ( info ) ; } } } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , <END> Class < ? extends TYPE_2 > VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = false ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( VAR_1 , 4 , TYPE_2 . TYPE_3 . name ( ) , 1 ) ; <START> METHOD_4 ( METHOD_2 ( ) , VAR_1 , TYPE_4 . VAR_3 , INT_1 * INT_2 * INT_3 , STRING_1 ) ; <END> METHOD_4 ( METHOD_2 ( ) , VAR_1 , TYPE_4 . VAR_4 , INT_1 * INT_2 * INT_3 , STRING_1 ) ; } 
public void run ( ) { try { log . info ( STRING_1 + getClass ( ) . METHOD_1 ( ) ) ; <START> VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> METHOD_4 ( ) ; log . info ( STRING_2 + getClass ( ) . METHOD_1 ( ) ) ; } catch ( Exception e ) { log . error ( STRING_3 + getClass ( ) , e ) ; } } 
public static final boolean METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( ) == TYPE_1 . TYPE_3 ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 entity ) { <START> return METHOD_2 ( entity . getName ( ) , entity ) ; <END> } 
private void METHOD_1 ( ) { bind ( TYPE_1 . class ) . in ( TYPE_2 . class ) ; METHOD_2 ( TYPE_1 . TYPE_9 . class ) ; <START> METHOD_2 ( TYPE_4 . class ) ; <END> bind ( TYPE_5 . class ) . in ( TYPE_2 . class ) ; bind ( TYPE_6 . class ) . in ( TYPE_2 . class ) ; bind ( TYPE_7 . class ) . to ( TYPE_8 . class ) . in ( TYPE_2 . class ) ; } 
public TYPE_1 < TYPE_2 < ? extends T > > call ( final TYPE_1 < ? super T > child ) { TYPE_3 < T > VAR_1 = new TYPE_3 < T > ( child , VAR_2 , VAR_3 ) ; TYPE_4 < T > VAR_4 = new TYPE_4 < T > ( VAR_1 ) ; VAR_1 . VAR_4 = VAR_4 ; <START> VAR_4 . METHOD_1 ( 0 ) ; <END> child . add ( VAR_1 ) ; child . VAR_5 ( VAR_4 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; TYPE_2 VAR_4 = <START> new TYPE_2 . Builder ( ) . METHOD_3 ( VAR_1 ) <END> . METHOD_4 ( TYPE_4 . VAR_6 ) . build ( ) ; List < TYPE_3 > VAR_7 = VAR_8 . METHOD_5 ( VAR_4 ) ; assertThat ( VAR_7 . size ( ) , is ( 2 ) ) ; for ( TYPE_3 VAR_9 : VAR_7 ) { assertThat ( VAR_9 . METHOD_6 ( ) , is ( TYPE_4 . VAR_6 ) ) ; } } 
static TYPE_1 METHOD_1 ( TYPE_2 request , Response VAR_1 , IOException VAR_2 ) { return new TYPE_1 ( <START> format ( STRING_1 , VAR_2 . getMessage ( ) , request . VAR_3 ( ) . name ( ) , request . url ( ) ) , <END> VAR_2 ) ; } 
protected TYPE_3 ( TYPE_1 buf ) { TYPE_2 . METHOD_1 ( buf , STRING_1 ) ; <START> this . buf = buf ; <END> } 
public boolean METHOD_1 ( ) { <START> return VAR_1 . size ( ) == VAR_1 . get ( 0 ) . METHOD_2 ( ) . METHOD_3 ( ) ; <END> } 
<START> public String <END> METHOD_1 ( ) { return "" + state + VAR_1 ; } 
public int METHOD_1 ( String VAR_1 ) { <START> int index = TYPE_1 . METHOD_2 ( METHOD_3 ( ) , VAR_1 ) ; <END> if ( index == TYPE_1 . VAR_2 ) { return METHOD_1 ( VAR_3 ) ; } return index ; } 
public void METHOD_1 ( ) { final double [ ] [ ] VAR_1 = { { FLOAT_1 , FLOAT_2 } , { FLOAT_3 , FLOAT_4 } , { FLOAT_5 , FLOAT_6 } , { FLOAT_7 , FLOAT_8 } } ; double [ ] VAR_2 = { FLOAT_9 , FLOAT_10 } ; double [ ] VAR_3 = { FLOAT_11 , FLOAT_12 } ; <START> assert ( TYPE_1 . contains ( VAR_1 , VAR_2 ) ) ; <END> assert ( ! TYPE_1 . contains ( VAR_1 , VAR_3 ) ) ; } 
public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( this ) ; <START> VAR_2 . METHOD_3 ( TYPE_3 . TYPE_2 . VAR_5 , client . VAR_6 ( ) ) ; <END> } catch ( TYPE_1 e ) { LOG . error ( STRING_1 , e ) ; } } 
public static void METHOD_1 ( StringBuilder buffer , int position ) { StringBuilder VAR_1 = new StringBuilder ( INT_1 ) ; VAR_1 . append ( STRING_1 ) ; buffer . append ( STRING_2 ) ; METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <START> buffer . append ( STRING_3 ) ; <END> buffer . VAR_4 ( position , VAR_1 . toString ( ) ) ; } 
private void METHOD_1 ( final List < TYPE_1 > VAR_1 ) throws TYPE_2 , TYPE_3 { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; final TYPE_4 VAR_3 = new TYPE_4 ( VAR_2 , null ) ; <START> TYPE_5 VAR_4 = new TYPE_5 ( Collections . VAR_5 ( VAR_3 ) ) ; <END> VAR_4 . METHOD_3 ( false ) ; final TYPE_6 VAR_6 = TYPE_7 . getInstance ( STRING_1 ) . METHOD_4 ( VAR_1 ) ; final TYPE_8 VAR_7 = TYPE_8 . getInstance ( STRING_2 ) ; VAR_7 . METHOD_5 ( VAR_6 , VAR_4 ) ; } 
public Set < Class < ? > > METHOD_1 ( ) { final Set < Class < ? > > VAR_1 = new HashSet < > ( ) ; VAR_1 . add ( TYPE_1 . class ) ; VAR_1 . add ( TYPE_2 . class ) ; <START> VAR_1 . add ( TYPE_3 . class ) ; <END> VAR_1 . add ( TYPE_4 . class ) ; return VAR_1 ; } 
<START> private void METHOD_1 ( final String message ) throws TYPE_1 { try { METHOD_2 ( ) ; } catch ( final Exception e ) { throw new TYPE_1 ( message , e ) ; } } <END> 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { return new TYPE_3 ( name , VAR_1 . METHOD_2 ( VAR_2 ) , <START> VAR_1 . METHOD_2 ( TYPE_4 . VAR_4 ) <END> ) ; } 
protected void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> if ( METHOD_2 ( METHOD_3 ( ) . message ) ) { return ; } TYPE_1 VAR_1 = new TYPE_1 ( vds . getId ( ) ) ; VAR_1 . METHOD_4 ( vds ) ; VAR_1 . METHOD_5 ( STRING_1 , METHOD_3 ( ) . message ) ; VAR_2 . log ( VAR_1 , TYPE_2 . VAR_4 ) ; } 
<START> protected String METHOD_1 ( TYPE_1 VAR_1 ) { <END> String VAR_2 = STRING_1 + ( int ) ( VAR_1 . VAR_3 * INT_1 ) + STRING_2 + ( int ) ( VAR_1 . VAR_4 * INT_1 ) + STRING_2 + ( int ) ( VAR_1 . VAR_5 * INT_1 ) + STRING_2 + ( int ) ( VAR_1 . VAR_6 * INT_1 ) + STRING_3 ; return VAR_2 ; } 
public TYPE_1 METHOD_1 ( File f , TYPE_3 . TYPE_4 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) <END> return TYPE_1 . VAR_2 ; else if ( VAR_1 . METHOD_3 ( ) ) { if ( new File ( f , Constants . VAR_3 ) . exists ( ) ) return TYPE_1 . VAR_4 ; else return TYPE_1 . VAR_5 ; } else if ( VAR_1 . METHOD_4 ( ) ) return TYPE_1 . VAR_6 ; else return TYPE_1 . VAR_7 ; } 
public Map < String , Set < TYPE_1 > > METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , TYPE_3 : : METHOD_4 ) ; <END> } 
<START> public void METHOD_1 ( TYPE_1 location , TYPE_2 VAR_1 ) throws TYPE_3 { <END> METHOD_2 ( location , VAR_1 , TYPE_4 . VAR_3 ) ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 ) { this . VAR_3 = VAR_3 ; this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> this . VAR_6 = new String [ 1 ] ; <END> } 
public static int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( ) ; <START> } <END> 
private void METHOD_1 ( String VAR_1 ) { try { if ( VAR_1 == null ) { <START> this . VAR_2 = TYPE_1 . METHOD_2 ( ) ; <END> } else { this . VAR_2 = TYPE_1 . METHOD_3 ( VAR_1 ) ; } logger . debug ( STRING_1 , this . VAR_3 , VAR_1 ) ; } catch ( TYPE_2 e ) { logger . error ( STRING_2 , this . VAR_3 , VAR_1 ) ; } } 
void METHOD_1 ( final String type , final String VAR_1 , final TYPE_1 VAR_2 ) { METHOD_2 ( ) . METHOD_3 ( type ) ; <START> if ( ! isEmpty ( VAR_1 ) ) { <END> METHOD_2 ( ) . METHOD_4 ( VAR_2 ) ; } else { METHOD_2 ( ) . METHOD_5 ( ) ; } } 
<START> public boolean METHOD_1 ( ) { <END> } 
public String METHOD_1 ( ) { <START> return Context . VAR_1 ( ) . getMessage ( STRING_1 ) ; <END> } 
public static String METHOD_1 ( Object context , String path ) { TYPE_1 . METHOD_2 ( path , STRING_1 ) ; <START> if ( path == null || path . startsWith ( STRING_2 ) || TYPE_2 . METHOD_3 ( path ) ) return path ; <END> TYPE_1 . METHOD_2 ( context , STRING_3 ) ; return METHOD_4 ( context ) + path ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( ) ; <END> TYPE_3 cmd = VAR_4 . METHOD_3 ( VAR_5 , VAR_1 ) ; try { VAR_3 . METHOD_4 ( source , cmd , TYPE_4 . NONE ) ; } catch ( Exception e ) { log . VAR_7 ( STRING_1 , source , VAR_1 ) ; } } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> METHOD_3 ( ) ; } 
private final void METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( VAR_1 == 0 ) { <START> if ( ! VAR_3 . METHOD_3 ( ) & VAR_4 ) <END> { VAR_5 . METHOD_4 ( ) . VAR_6 . VAR_7 . METHOD_5 ( ) ; } else { VAR_5 . METHOD_4 ( ) . VAR_6 . VAR_8 . METHOD_6 ( System . VAR_9 ( ) - VAR_10 ) ; } } } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 sess , List < TYPE_3 > VAR_1 , TYPE_4 resource , TYPE_5 group , boolean VAR_2 ) throws TYPE_6 { this . METHOD_2 ( sess , group , resource ) ; List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; <START> VAR_3 . addAll ( METHOD_3 ( ) . METHOD_1 ( sess , VAR_1 , resource , group ) ) ; <END> if ( VAR_2 ) { VAR_3 . addAll ( METHOD_3 ( ) . METHOD_1 ( sess , VAR_1 , group ) ) ; } return VAR_3 ; } 
private boolean METHOD_1 ( TYPE_1 < ? > message ) { <START> if ( message . VAR_1 ( ) . containsKey ( TYPE_2 . VAR_3 ) ) { <END> return this . VAR_4 . getValue ( this . VAR_5 , message , Boolean . VAR_6 ) ; } return false ; } 
public void METHOD_1 ( ) { <START> int VAR_1 = 1 ; <END> TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; assertEquals ( STRING_1 , VAR_2 . METHOD_3 ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { METHOD_2 ( ! VAR_2 , STRING_1 ) ; TYPE_3 VAR_3 = VAR_1 . METHOD_3 ( VAR_4 , VAR_5 , TYPE_4 . class . METHOD_4 ( ) ) ; <START> return new TYPE_5 ( VAR_3 , METHOD_5 ( ) , VAR_6 , VAR_7 , VAR_8 , VAR_9 . METHOD_6 ( ) , VAR_10 ) ; <END> } 
private TYPE_1 METHOD_1 ( final TYPE_2 job , TYPE_1 VAR_1 , String VAR_2 ) { <START> if ( VAR_1 != null ) { <END> job . VAR_3 ( ) . remove ( VAR_1 ) ; } TYPE_1 VAR_4 = new TYPE_1 ( ) ; VAR_4 . METHOD_2 ( Collections . VAR_5 ( new TYPE_3 ( VAR_2 , new TYPE_4 ( ) ) ) ) ; job . VAR_3 ( ) . add ( VAR_4 ) ; return VAR_4 ; } 
public boolean METHOD_1 ( TYPE_1 user ) { if ( user == null || user . VAR_1 ( ) == null ) { return false ; } <START> return new TYPE_2 ( ) . METHOD_1 ( user ) || ( user . VAR_1 ( ) . METHOD_2 ( ) != null && user . VAR_1 ( ) <END> . METHOD_2 ( ) . METHOD_3 ( ) ) ; } 
public TYPE_1 < ? > METHOD_1 ( ) { if ( METHOD_2 ( ) ) { return VAR_1 ; } <START> return VAR_2 . METHOD_3 ( ) ; <END> } 
public Map < String , TYPE_1 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { model . VAR_2 ( ) ; TYPE_1 entry ; for ( TYPE_1 <START> VAR_3 : <END> VAR_1 ) { entry = VAR_3 ; switch ( entry . VAR_4 ( ) ) { case TYPE_1 . VAR_5 : model . VAR_6 ( TYPE_2 . VAR_8 , entry ) ; break ; default : model . VAR_6 ( TYPE_2 . VAR_9 , entry ) ; break ; } } METHOD_2 ( ) ; } 
public static String METHOD_1 ( File VAR_1 ) throws IOException { <START> TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ; try { return VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . getValue ( STRING_1 ) ; } finally { VAR_2 . close ( ) ; } <END> } 
protected String METHOD_1 ( String name ) { boolean VAR_1 = VAR_2 != null && VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <START> if ( VAR_1 != null && VAR_1 ) { <END> return VAR_3 + STRING_1 + ( name != null ? name : VAR_4 ) ; } else { return name != null ? name : VAR_4 ; } } 
public boolean METHOD_1 ( Object element ) { if ( VAR_1 . containsKey ( element ) ) { return VAR_1 . get ( element ) ; } <START> return VAR_2 . METHOD_1 ( element ) ; <END> } 
<START> private void METHOD_1 ( String VAR_1 ) throws TYPE_1 , TYPE_2 { List < TYPE_3 > VAR_2 = VAR_3 . apply ( VAR_4 ) ; for ( TYPE_3 e : VAR_2 ) { if ( e . VAR_1 . equals ( VAR_1 ) ) { VAR_5 . apply ( new TYPE_5 . TYPE_6 ( user , VAR_1 ) , null ) ; } } } <END> 
private void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> for ( TYPE_1 job : VAR_1 ) { <END> job . VAR_2 ( ) ; } } 
<START> static private long METHOD_1 ( String VAR_1 ) { <END> if ( VAR_1 . contains ( STRING_1 ) ) { float value = TYPE_1 . METHOD_2 ( VAR_1 ) ; float VAR_2 = value % 1 ; return TYPE_2 . METHOD_1 ( ( long ) value ) + ( long ) ( VAR_2 * INT_1 ) ; } else { return TYPE_2 . METHOD_1 ( Long . VAR_3 ( VAR_1 ) ) ; } } 
public synchronized void METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( TYPE_1 request : VAR_1 ) { if ( VAR_2 . size ( ) >= VAR_3 ) { <START> VAR_2 . remove ( 0 ) ; <END> } VAR_2 . add ( new TYPE_2 ( request , METHOD_2 ( ) . METHOD_3 ( ) ) ) ; } VAR_4 . execute ( VAR_5 ) ; } 
static boolean METHOD_1 ( TYPE_1 parser , boolean VAR_1 ) throws IOException { try { TYPE_2 VAR_2 = parser . VAR_2 ( ) ; if ( VAR_2 == null ) VAR_2 = parser . VAR_3 ( ) ; if ( VAR_2 == TYPE_2 . VAR_4 ) return true ; if ( VAR_1 ) { throw new IllegalArgumentException ( STRING_1 + VAR_2 ) ; } return false ; <START> } catch ( TYPE_3 e ) { <END> if ( VAR_1 ) throw e ; return false ; } } 
public TYPE_4 ( TYPE_1 parameters , boolean VAR_2 ) { super ( parameters ) ; if ( ! VAR_2 ) { <START> VAR_3 = TYPE_2 . get ( TYPE_3 . class ) . METHOD_1 ( parameters . VAR_4 ( ) ) ; <END> } } 
public TYPE_2 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 ) { super ( VAR_2 , VAR_3 ) ; <START> VAR_2 . METHOD_1 ( ) . get ( STRING_1 ) . METHOD_2 ( ) ; <END> } 
<START> public List < ANNOTATION_1 Integer > METHOD_1 ( int VAR_1 , boolean VAR_2 ) <END> throws TYPE_1 { return METHOD_2 ( ) . METHOD_1 ( VAR_1 , VAR_2 ) ; } 
private String METHOD_1 ( ) throws Exception { if <START> ( VAR_1 != <END> null ) { return VAR_1 ; } long VAR_2 = System . currentTimeMillis ( ) ; VAR_1 = VAR_3 . execute ( VAR_4 , VAR_5 ) ; long VAR_6 = System . currentTimeMillis ( ) ; System . out . println ( STRING_1 + ( VAR_6 - VAR_2 ) ) ; return VAR_1 ; } 
public static String METHOD_1 ( Map conf ) throws IOException { String VAR_1 = METHOD_2 ( conf ) + VAR_2 + STRING_1 ; try { TYPE_1 . METHOD_3 ( new File ( VAR_1 ) ) ; } catch ( IOException e ) { LOG . error ( STRING_2 + VAR_1 , e ) ; <START> throw e ; <END> } return VAR_1 ; } 
<START> public TYPE_2 ( String VAR_2 , long VAR_3 , String VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_5 = METHOD_1 ( TYPE_1 . class ) ; when ( VAR_5 . toString ( ) ) . METHOD_2 ( VAR_2 ) ; } 
public static void METHOD_1 ( String [ ] args ) { LOG . info ( STRING_1 ) ; try { TYPE_1 . METHOD_2 ( ) ; LOG . info ( STRING_2 ) ; } catch ( IllegalStateException e ) { <START> LOG . warn ( STRING_3 , e . getMessage ( ) ) ; <END> System . VAR_1 ( - 1 ) ; } System . VAR_1 ( 0 ) ; } 
<START> private boolean METHOD_1 ( TYPE_1 filter , TYPE_2 [ ] VAR_1 ) <END> { return Arrays . stream ( filter . VAR_2 ( ) ) . METHOD_2 ( channel - > VAR_1 [ channel ] != null ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_2 . class ) <END> . METHOD_4 ( null ) ) ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) ; <END> } 
public boolean METHOD_1 ( Class < ? extends TYPE_1 > VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( TYPE_2 . class ) || VAR_1 . METHOD_2 ( TYPE_3 . class ) ) { <END> return true ; } else { return false ; } } 
public void METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( VAR_4 ) ; VAR_3 . METHOD_2 ( VAR_5 . METHOD_3 ( VAR_1 ) ) ; TYPE_2 VAR_6 = VAR_3 . METHOD_4 ( ) ; VAR_6 . METHOD_5 ( config . VAR_7 ( ) ) ; <START> VAR_6 . METHOD_6 ( ) ; <END> TYPE_3 . METHOD_7 ( VAR_5 . METHOD_3 ( VAR_2 ) , VAR_4 . METHOD_8 ( ) ) ; } 
public void execute ( TYPE_1 VAR_1 ) throws IOException { <START> if ( ! METHOD_1 ( ) ) throw new IllegalArgumentException ( STRING_1 ) ; <END> TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( ( double ) VAR_4 . METHOD_2 ( ) ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ; assertThat ( TYPE_1 . METHOD_3 ( new File ( STRING_1 ) ) ) . METHOD_4 ( ) ; assertThat ( VAR_1 . METHOD_5 ( TYPE_2 . VAR_4 ) ) . contains ( STRING_2 ) ; <START> System . out . println ( VAR_1 . METHOD_5 ( TYPE_2 . VAR_3 ) ) ; <END> assertThat ( VAR_1 . METHOD_5 ( TYPE_2 . VAR_3 ) ) . METHOD_6 ( 1 ) . METHOD_7 ( s - > s . startsWith ( STRING_3 ) ) ; } 
boolean METHOD_1 ( ) { try { return TYPE_1 . getInstance ( ) . METHOD_2 ( TYPE_3 . VAR_2 , TYPE_3 . VAR_3 ) ; } catch ( final TYPE_2 ex ) { <START> LOG . warn ( ex . VAR_4 ( ) ) ; <END> LOG . trace ( STRING_1 , ex . VAR_4 ( ) , ex ) ; } return false ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 , STRING_2 , VAR_2 , VAR_3 ) ; TYPE_1 VAR_4 = TYPE_2 . METHOD_2 ( STRING_3 , STRING_3 , VAR_2 , VAR_3 ) ; <START> VAR_4 . METHOD_3 ( VAR_1 . VAR_5 , TYPE_3 . METHOD_4 ( ) ) . get ( ) ; <END> List < TYPE_4 > VAR_6 = VAR_1 . METHOD_5 ( ) . get ( ) ; assertTrue ( STRING_4 , VAR_6 . size ( ) > 0 ) ; } 
public void METHOD_1 ( TYPE_1 request , TYPE_2 response , TYPE_3 VAR_1 ) throws IOException , TYPE_4 { METHOD_2 ( VAR_2 , STRING_1 ) ; try { VAR_2 . METHOD_3 ( METHOD_4 ( request ) , METHOD_5 ( request ) ) ; VAR_1 . METHOD_1 ( request , response ) ; <START> } catch ( IllegalArgumentException e ) { <END> ( ( TYPE_5 ) response ) . METHOD_6 ( TYPE_5 . VAR_3 ) ; } finally { VAR_2 . clear ( ) ; } } 
public TYPE_1 getPath ( ) { try { return new TYPE_2 ( ) . METHOD_1 ( this , METHOD_2 ( TYPE_6 . TYPE_7 . class ) ) ; } catch ( TYPE_4 e ) { <START> throw new TYPE_5 ( ) ; <END> } } 
public void METHOD_1 ( final TYPE_1 input , final TYPE_2 output , final String name ) throws IOException { <START> final byte [ ] VAR_1 ; <END> try { VAR_1 = TYPE_3 . METHOD_2 ( input ) ; } catch ( final IOException e ) { throw METHOD_3 ( name , e ) ; } output . write ( METHOD_1 ( VAR_1 , name ) ) ; } 
public TYPE_2 . TYPE_3 METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> return VAR_1 ; } 
protected void METHOD_1 ( ) { boolean VAR_1 = METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <START> assertTrue ( VAR_1 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 node = METHOD_2 ( TYPE_2 . VAR_2 , STRING_1 ) ; <START> METHOD_3 ( "" , node . get ( STRING_2 ) . get ( STRING_3 ) ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 resource , TYPE_3 monitor ) { <START> VAR_2 . METHOD_2 ( ) ; <END> try { VAR_3 . execute ( new TYPE_4 ( VAR_1 , resource , monitor ) ) ; } finally { VAR_2 . METHOD_3 ( ) ; } } 
private void METHOD_1 ( ) throws TYPE_1 { int VAR_1 = 0 ; for ( TYPE_2 VAR_2 : VAR_3 ) { VAR_1 += VAR_2 . METHOD_2 ( ) ; } <START> if ( VAR_1 > VAR_4 ) { <END> throw new TYPE_1 ( STRING_1 ) ; } } 
<START> public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < TYPE_1 > VAR_2 ) <END> { List < TYPE_1 > VAR_3 = METHOD_2 ( VAR_1 ) . stream ( ) . filter ( VAR_2 ) . collect ( METHOD_3 ( ) ) ; return METHOD_4 ( VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 parent ) { String name = METHOD_2 ( ) . METHOD_3 ( ) ; if ( name != null ) { name = TYPE_2 . METHOD_4 ( name ) ; } if ( name != null ) { VAR_1 . METHOD_5 ( name ) ; } VAR_2 = new TYPE_3 ( name ) ; <START> TYPE_4 VAR_3 = METHOD_6 ( ) ; <END> VAR_3 . METHOD_7 ( ) . METHOD_8 ( VAR_3 . METHOD_9 ( ) . METHOD_10 ( ) ) ; super . METHOD_1 ( parent ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; } 
public TYPE_1 METHOD_1 ( int i ) { <START> return METHOD_1 ( i , this . factory ) ; <END> } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 ) ; METHOD_3 ( STRING_8 , STRING_9 ) ; METHOD_3 ( STRING_8 , STRING_10 ) ; METHOD_3 ( STRING_8 , STRING_11 ) ; <START> METHOD_3 ( STRING_8 , STRING_12 ) ; <END> METHOD_4 ( ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 . VAR_2 ) ; TYPE_1 VAR_3 = METHOD_3 ( TYPE_1 . class ) ; TYPE_2 VAR_4 = METHOD_3 ( TYPE_2 . class ) ; TYPE_3 VAR_5 = METHOD_3 ( TYPE_3 . class ) ; <START> VAR_1 . METHOD_4 ( VAR_3 , VAR_4 , VAR_5 ) ; <END> METHOD_2 ( VAR_1 . VAR_2 ) ; VAR_1 . METHOD_5 ( ) ; assertTrue ( VAR_1 . VAR_2 ) ; } 
private static String METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) { <START> StringBuilder VAR_3 = new StringBuilder ( VAR_2 . length ( ) + INT_1 ) ; <END> VAR_3 . append ( STRING_1 ) ; if ( ! VAR_2 . isEmpty ( ) && ! VAR_2 . startsWith ( STRING_2 ) ) { VAR_3 . append ( CHAR_1 ) ; } VAR_3 . append ( VAR_2 ) ; return VAR_3 . toString ( ) ; } else { return VAR_2 ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> TYPE_2 VAR_2 = METHOD_2 ( ) ; <END> VAR_1 . put ( VAR_3 , VAR_2 . METHOD_3 ( ) + STRING_1 + VAR_2 . METHOD_4 ( ) ) ; VAR_1 . put ( VAR_4 , METHOD_5 ( ) . METHOD_6 ( ) ) ; VAR_1 . put ( VAR_5 , METHOD_7 ( ) ) ; VAR_1 . put ( VAR_6 , METHOD_8 ( ) ) ; return VAR_1 ; } 
protected String METHOD_1 ( String value ) throws IOException { File VAR_1 = File . VAR_2 ( STRING_1 , STRING_2 ) ; String VAR_3 = VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( true , true ) ; VAR_1 . METHOD_4 ( true , true ) ; <START> VAR_1 . METHOD_5 ( false ) ; <END> TYPE_1 out = new TYPE_1 ( new TYPE_2 ( VAR_1 ) ) ; out . write ( value ) ; out . close ( ) ; return VAR_3 ; } 
public void METHOD_1 ( ) throws Exception { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( 1 ) ; <END> Assert . VAR_3 ( VAR_2 . METHOD_2 ( 1 ) . METHOD_3 ( ) ) ; VAR_2 . METHOD_4 ( VAR_1 , STRING_1 ) ; Assert . assertTrue ( VAR_2 . METHOD_2 ( 1 ) . METHOD_3 ( ) ) ; } 
public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final TYPE_1 < T > VAR_1 = ( TYPE_1 < T > ) obj ; <START> return TYPE_2 . equals ( this . VAR_2 , VAR_1 . VAR_2 ) && <END> this . VAR_3 == VAR_1 . VAR_3 && TYPE_2 . equals ( this . VAR_4 , VAR_1 . VAR_4 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 session , TYPE_1 VAR_1 , TYPE_3 VAR_2 ) { Map < TYPE_4 < TYPE_1 > , Type > VAR_3 = METHOD_2 ( session , VAR_1 , VAR_2 ) ; TYPE_5 VAR_4 = TYPE_5 . METHOD_3 ( VAR_1 , metadata , session , VAR_3 ) ; Object value = VAR_4 . METHOD_4 ( TYPE_6 . VAR_6 ) ; <START> if ( value instanceof TYPE_1 ) { <END> return ( TYPE_1 ) value ; } if ( value == null ) { value = false ; } return VAR_7 . METHOD_5 ( value , VAR_8 ) ; } 
public boolean METHOD_1 ( String VAR_1 , Object data ) { TYPE_1 event = METHOD_2 ( VAR_1 , data ) ; TYPE_2 VAR_2 = TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) ; if ( VAR_2 == null && logger != null ) { logger . error ( TYPE_4 . bind ( TYPE_5 . VAR_4 , event . toString ( ) ) ) ; <START> return false ; <END> } VAR_2 . METHOD_5 ( event ) ; return true ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( true ) ; VAR_1 . METHOD_4 ( STRING_1 ) ; VAR_1 . METHOD_5 ( ) ; assertEquals ( STRING_2 , VAR_1 . METHOD_6 ( ) . METHOD_7 ( new TYPE_2 < TYPE_3 > ( ) { @Override public boolean METHOD_8 ( final TYPE_3 element ) { return element . VAR_2 ( ) . METHOD_9 ( ) . equals ( STRING_3 ) ; } <START> } ) . size ( ) , 1 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_2 ( Arrays . asList ( new TYPE_2 [ ] { METHOD_3 ( ) , METHOD_4 ( ) } ) ) ; <END> VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ; return VAR_1 ; } 
<START> protected List < TYPE_1 > METHOD_1 ( TYPE_2 . Type type , List < TYPE_1 . TYPE_4 > VAR_1 ) { <END> TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , type , VAR_4 , VAR_1 ) ; List < TYPE_1 > VAR_5 = new ArrayList < TYPE_1 > ( 1 ) ; VAR_5 . add ( VAR_2 ) ; return VAR_5 ; } 
<START> private TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( STRING_1 ) ; VAR_1 . METHOD_3 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_4 ( new Guid ( ) ) ; VAR_1 . METHOD_5 ( STRING_2 ) ; VAR_1 . METHOD_6 ( INT_1 ) ; return VAR_1 ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 == null ) { return null ; } int VAR_3 = VAR_1 . getType ( ) ; <START> if ( VAR_3 == TYPE_4 . VAR_5 || VAR_3 == TYPE_4 . VAR_6 ) { <END> return METHOD_1 ( VAR_2 ) ; } return VAR_2 . METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 . get ( STRING_1 ) != null ) { <END> return ( TYPE_1 ) VAR_1 . get ( STRING_2 ) ; } else { return 2 ; } } 
public void start ( ) { if ( VAR_1 . METHOD_1 ( false , true ) ) { METHOD_2 ( ) ; VAR_2 = Utils . VAR_3 ( 1 , false ) ; VAR_2 . METHOD_3 ( new TYPE_1 ( ) , 0 , config . VAR_4 , TimeUnit . VAR_5 ) ; <START> logger . trace ( STRING_1 ) ; <END> } } 
public String METHOD_1 ( ANNOTATION_1 ( STRING_1 ) final String id , final TYPE_1 request ) { String VAR_1 ; try { VAR_1 = TYPE_2 . METHOD_2 ( id , STRING_2 ) ; } catch ( TYPE_3 e ) { log . warn ( STRING_3 , id , e ) ; <START> VAR_1 = id ; <END> } final String path = STRING_4 + VAR_1 + STRING_5 + TYPE_4 . METHOD_3 ( request ) ; return STRING_6 + path ; } 
private Integer METHOD_1 ( Map < String , Object > entry , String VAR_1 , int VAR_2 ) { Map < String , Double > parameters = ( Map < String , Double > ) entry . get ( VAR_1 ) ; if ( parameters == null ) { return null ; } Double VAR_3 = parameters . get ( TYPE_1 . VAR_5 ) ; <START> return ( VAR_3 == null ) ? null : ( int ) ( VAR_3 / VAR_2 ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 < TYPE_2 > listener ) { VAR_1 . METHOD_2 ( ( value , VAR_2 ) - > { <START> if ( VAR_2 == null ) { <END> listener . VAR_3 ( this ) ; } else { listener . VAR_3 ( this ) ; } } ) ; return this ; } 
public TYPE_1 < T > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , List < TYPE_1 < T > > VAR_3 ) { if ( ! METHOD_2 ( VAR_1 ) ) { return METHOD_3 ( VAR_2 ) ; } try { return new TYPE_1 < > ( Optional . of ( ( T ) VAR_4 . get ( VAR_1 ) . METHOD_4 ( VAR_3 ) ) , VAR_2 , VAR_3 ) ; } <START> catch ( Throwable t ) { <END> return METHOD_3 ( VAR_2 ) ; } } 
public void METHOD_1 ( ) { Guid VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == null ) { METHOD_1 ( false , false , null ) ; } else { TYPE_1 . getInstance ( ) . METHOD_3 ( new TYPE_2 < > ( cluster - > { if ( cluster != null ) { <START> METHOD_1 ( true , cluster . VAR_2 ( ) , VAR_1 ) ; <END> } } ) , VAR_1 ) ; } } 
public TYPE_3 ( final String name , final TYPE_1 VAR_2 ) { METHOD_1 ( name , STRING_1 ) ; <START> METHOD_1 ( name , STRING_2 ) ; <END> this . VAR_3 = new TYPE_2 ( name , VAR_2 ) ; } 
private void METHOD_1 ( TYPE_1 request ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( METHOD_3 ( ) ) ; TYPE_4 VAR_2 = TYPE_4 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_1 . getKey ( ) ) ; <START> if ( ! VAR_2 . METHOD_6 ( ) ) { <END> throw TYPE_5 . METHOD_7 ( ) ; } TYPE_6 . METHOD_8 ( request , VAR_2 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , String url , long VAR_2 ) { TYPE_2 VAR_3 = VAR_4 . VAR_3 ; TYPE_3 . Log log = VAR_4 . log ; if ( VAR_3 . log ( ) ) { log . log ( String . format ( STRING_1 , VAR_1 . VAR_5 , url , VAR_2 ) ) ; if ( VAR_3 . METHOD_2 ( ) >= TYPE_2 . TYPE_5 . METHOD_2 ( ) ) { <START> log . log ( VAR_1 . VAR_6 + "" ) ; <END> log . log ( STRING_2 ) ; } } } 
public void METHOD_1 ( final TYPE_1 context ) { if ( context . VAR_1 ( ) ) { return ; } TYPE_2 . METHOD_2 ( ) . METHOD_3 ( new TYPE_3 ( ) { @Override public void run ( ) { <START> synchronized ( context . VAR_2 ( ) ) { <END> if ( ! context . VAR_1 ( ) ) { context . VAR_3 ( ) ; context . VAR_4 ( ) . METHOD_4 ( ) ; context . VAR_5 ( ) ; } } } } ) ; } 
private void METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { if ( ! VAR_1 . METHOD_2 ( ) ) { time . VAR_2 ( VAR_3 ) ; metadata . VAR_4 ( ) ; } <START> VAR_5 . METHOD_3 ( VAR_1 ) ; <END> VAR_5 . METHOD_4 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 client = new TYPE_1 ( VAR_1 . location ( ) ) ; assertNotNull ( client . VAR_2 ( ) ) ; METHOD_2 ( client . VAR_2 ( ) . METHOD_3 ( ) ) ; TYPE_2 version = client . VAR_3 ( new TYPE_3 ( ) ) ; assertTrue ( STRING_1 + VAR_1 . METHOD_4 ( ) + STRING_2 + version . toString ( ) , <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( version . toString ( ) ) == 0 ) ; <END> } 
private String METHOD_1 ( String VAR_1 ) { <START> String [ ] VAR_2 = { STRING_1 , STRING_2 , STRING_3 } ; <END> for ( String VAR_3 : VAR_2 ) { if ( new File ( VAR_3 + VAR_1 ) . exists ( ) ) { return VAR_3 + VAR_1 ; } } return null ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , String path , TYPE_2 VAR_2 ) throws IOException { List < TYPE_3 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_6 . TYPE_7 . VAR_4 . TYPE_3 entry : VAR_2 . METHOD_2 ( ) ) { TYPE_3 VAR_6 = METHOD_3 ( entry ) ; VAR_3 . add ( VAR_6 ) ; } try { VAR_1 . METHOD_1 ( new Path ( path ) , VAR_3 ) ; } catch ( TYPE_5 e ) { <START> LOG . warn ( STRING_1 ) ; <END> } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; METHOD_2 ( VAR_2 ) ; <START> Log . i ( STRING_1 , STRING_2 ) ; <END> } 
private int METHOD_1 ( ) { <START> if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) VAR_1 = TYPE_1 . VAR_2 + 1 ; <END> return VAR_1 ++ ; } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = METHOD_2 ( ) . message ( of ( STRING_1 ) ) . build ( ) ; TYPE_2 VAR_2 = METHOD_2 ( ) . message ( of ( STRING_2 ) ) . build ( ) ; assertThat ( STRING_3 , VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) , <START> METHOD_5 ( TYPE_3 . is ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ) ) ; <END> } 
private void METHOD_1 ( final TYPE_1 state ) { if ( state != null ) { <START> if ( ! VAR_1 ) { <END> METHOD_2 ( state . VAR_2 ( VAR_3 , false ) ) ; } } } 
public TYPE_1 getParameters ( TYPE_2 VAR_1 , TYPE_3 entity ) { TYPE_4 VAR_2 = METHOD_1 ( VAR_3 , TYPE_4 . class ) . map ( VAR_1 , entity . VAR_4 ( ) ) ; <START> TYPE_5 VAR_5 = new TYPE_5 ( VAR_2 , STRING_1 , "" , false ) ; <END> if ( VAR_1 . METHOD_2 ( ) ) { VAR_5 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; } return VAR_5 ; } 
<START> private boolean METHOD_1 ( String a , String b ) { <END> int VAR_1 = a . VAR_2 ( CHAR_1 ) ; int VAR_3 = b . VAR_2 ( CHAR_1 ) ; return a . substring ( 0 , VAR_1 + 1 ) . equals ( b . substring ( 0 , VAR_3 + 1 ) ) ; } 
public void METHOD_1 ( TYPE_1 context ) throws InterruptedException { super . METHOD_1 ( context ) ; <START> VAR_1 = new TYPE_2 ( ) ; <END> } 
<START> public synchronized void METHOD_1 ( ) { <END> if ( this . VAR_1 == null ) { this . VAR_1 = TYPE_1 . METHOD_2 ( METHOD_3 ( ) , this . VAR_2 ) ; if ( this . VAR_1 == null ) { throw new TYPE_2 ( STRING_1 ) ; } try { METHOD_3 ( ) . METHOD_4 ( this . VAR_1 , true , false ) ; } catch ( Exception e ) { throw new TYPE_2 ( e ) ; } } } 
public void METHOD_1 ( ) throws InterruptedException { METHOD_2 ( ) . METHOD_3 ( VAR_1 . id ( ) ) ; <START> Thread . VAR_2 ( INT_1 ) ; <END> METHOD_4 ( VAR_3 ) ; METHOD_5 ( VAR_3 . id ( ) ) ; } 
public Object next ( ) { if ( position >= VAR_1 ) { throw new TYPE_1 ( ) ; } Object result = TYPE_2 . get ( VAR_2 , position ) ; position ++ ; <START> return result ; <END> } 
protected int METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( INT_1 , TimeUnit . VAR_2 ) ; <START> int VAR_3 = 0 ; <END> try { VAR_3 = VAR_4 . METHOD_3 ( VAR_1 ) . size ( ) ; } catch ( Exception ex ) { VAR_3 = 0 ; } finally { METHOD_4 ( ) ; } return VAR_3 ; } 
public void set ( String field , final String value ) { <START> if ( ! "" . equals ( field ) ) { <END> if ( METHOD_1 ( field ) ) { VAR_1 . put ( field , value ) ; String VAR_2 = METHOD_2 ( field ) ; if ( VAR_2 != null ) { VAR_3 . add ( new TYPE_1 ( VAR_2 ) ) ; } field = VAR_2 ; } if ( field != null ) { values . put ( field , value ) ; } } } 
public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 ) { TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; TYPE_2 . METHOD_1 ( VAR_3 , STRING_2 ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 ; <END> } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_3 ; boolean VAR_4 = ( VAR_2 != null && VAR_2 . METHOD_2 ( ) != TYPE_3 . VAR_6 ) ; <START> VAR_1 . METHOD_3 ( VAR_7 ) . METHOD_4 ( ! VAR_4 ) ; <END> VAR_1 . METHOD_3 ( VAR_8 ) . METHOD_5 ( VAR_2 != null ) ; return super . METHOD_1 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { <START> page . VAR_1 ( VAR_2 , VAR_3 ) ; <END> } 
<START> protected static String METHOD_1 ( String VAR_1 , int VAR_2 ) { <END> if ( StringUtils . length ( VAR_1 ) <= VAR_2 ) { return VAR_1 ; } else { return VAR_1 . substring ( 0 , VAR_2 ) ; } } 
private void METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> METHOD_2 ( ) ; } } 
private static TYPE_1 METHOD_1 ( TYPE_2 id ) { TYPE_1 VAR_1 = null ; <START> if ( id != null && id . getValue ( ) != null && id . getValue ( ) . size ( ) > 0 ) { <END> VAR_1 = id . getValue ( ) . get ( 0 ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { if ( this . VAR_1 && this . VAR_2 != null ) { return this . VAR_2 ; } else { String value = METHOD_2 ( VAR_3 ) ; TYPE_1 VAR_4 = ( StringUtils . VAR_5 ( value ) ? TYPE_1 . METHOD_3 ( value ) : null ) ; if ( this . VAR_1 ) { this . VAR_2 = VAR_4 ; } return VAR_4 ; <START> } <END> } 
protected String [ ] METHOD_1 ( ) { <START> ArrayList < String > <END> list = new ArrayList < > ( ) ; for ( TYPE_1 VAR_1 : TYPE_2 . getInstance ( ) . METHOD_2 ( ) ) { list . add ( VAR_1 . getName ( ) ) ; } return list . VAR_2 ( new String [ 0 ] ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , String VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_5 = VAR_2 != null ? VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) : false ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; } 
public static TYPE_1 METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> if ( VAR_2 == null ) { TYPE_1 c = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; if ( c != null ) { VAR_2 = c ; } else { VAR_2 = new TYPE_3 ( ) ; } } return VAR_2 ; } } 
public TYPE_1 METHOD_1 ( String VAR_1 , Collection < TYPE_2 > VAR_2 ) { <START> METHOD_1 ( VAR_1 , <END> VAR_2 , METHOD_2 ( ) , METHOD_2 ( ) , null , null ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> try { TYPE_2 VAR_1 = new TYPE_2 ( 1 ) ; VAR_1 . add ( INT_1 ) ; VAR_1 . add ( INT_2 ) ; } catch ( TYPE_1 e ) { METHOD_2 ( STRING_1 ) ; } <END> } 
public Double METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( VAR_1 ) ) { return VAR_2 . get ( VAR_1 ) . get ( TYPE_2 . VAR_4 ) ; } <START> LOG . warn ( STRING_1 , VAR_1 ) ; <END> return null ; } 
public static void METHOD_1 ( final TYPE_1 in , final TYPE_2 VAR_1 ) throws IOException { TYPE_3 out = null ; try { out = new TYPE_3 ( VAR_1 . out ( ) ) ; TYPE_4 . METHOD_2 ( in , out ) ; out . VAR_2 ( ) ; } finally { <START> out . close ( ) ; <END> } } 
private void METHOD_1 ( TYPE_1 vm ) { if ( TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( vm . getId ( ) ) . size ( ) > 0 ) { <START> log . VAR_1 ( STRING_1 , vm . getId ( ) ) ; <END> TYPE_3 . getInstance ( ) . METHOD_4 ( TYPE_7 . TYPE_6 , new TYPE_4 ( vm . getId ( ) ) , new TYPE_5 ( METHOD_5 ( ) ) ) ; } } 
public void METHOD_1 ( Object [ ] params ) { if ( params . length != 1 ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> METHOD_1 ( ( Map < Object , TYPE_1 > ) params [ 0 ] ) ; <END> } 
public TYPE_2 ( Class < TYPE_1 > VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; } 
public void METHOD_1 ( ) throws InterruptedException { int VAR_1 = VAR_2 * VAR_3 ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { METHOD_2 ( null , null ) ; } <START> TYPE_1 . METHOD_3 ( 5 ) ; <END> VAR_4 . METHOD_4 ( ) ; Throwable VAR_5 = VAR_6 . get ( ) ; if ( VAR_5 != null ) { METHOD_5 ( STRING_1 , VAR_5 ) ; } } 
public void METHOD_1 ( ) throws Exception { when ( VAR_1 . getProperty ( STRING_1 , false ) ) . METHOD_2 ( true ) ; boolean b = VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; <START> assertTrue ( b == true ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = Status . VAR_2 ; if ( VAR_3 != null && VAR_3 . METHOD_2 ( ) != null ) { VAR_1 = VAR_3 . METHOD_2 ( ) ; } <START> return VAR_1 ; <END> } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; if ( VAR_1 != null ) { if ( VAR_2 . VAR_3 == null ) { cache . VAR_4 ( STRING_1 + getName ( ) ) ; <START> VAR_1 . METHOD_3 ( STRING_1 + getName ( ) ) ; <END> } if ( VAR_2 . VAR_5 == null ) { cache . VAR_6 ( STRING_2 + getName ( ) ) ; VAR_1 . METHOD_3 ( STRING_2 + getName ( ) ) ; } } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , List < String > VAR_3 , TYPE_3 VAR_4 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) { <END> TYPE_4 VAR_5 = METHOD_3 ( VAR_1 ) ; if ( VAR_5 != null ) { VAR_3 . add ( new TYPE_5 ( STRING_1 , VAR_5 . METHOD_4 ( ) ) . METHOD_5 ( ) ) ; } } } 
private static String METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( STRING_1 ) <= 0 ) <END> VAR_1 = VAR_1 . METHOD_3 ( ) . trim ( ) ; else VAR_1 = VAR_1 . METHOD_3 ( ) . trim ( ) . substring ( 0 , VAR_1 . METHOD_2 ( STRING_1 ) ) ; return VAR_1 ; } 
<START> public String METHOD_1 ( String table , String path ) <END> { return METHOD_2 ( TYPE_1 . builder ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_2 . create ( String . format ( STRING_1 , METHOD_5 ( table ) , path ) ) ) , Optional . empty ( ) , Optional . empty ( ) ) ; } 
<START> public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> try { return METHOD_2 ( VAR_1 ) ; } catch ( TYPE_2 e ) { TYPE_1 config = new TYPE_1 ( METHOD_3 ( ) ) ; config . VAR_2 ( VAR_1 ) ; return config ; } } 
public String METHOD_1 ( ) { <START> String VAR_1 ; <END> if ( VAR_2 . VAR_3 == null || VAR_2 . VAR_3 . length ( ) == 0 ) VAR_1 = STRING_1 ; else if ( Double . VAR_4 ( METHOD_2 ( ) ) ) VAR_1 = STRING_2 ; else VAR_1 = "" + ( int ) METHOD_2 ( ) ; return VAR_1 ; } 
public static boolean METHOD_1 ( ) { TYPE_1 VAR_1 [ ] = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; TYPE_3 VAR_2 ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { if ( VAR_1 [ i ] instanceof TYPE_3 ) { VAR_2 = ( TYPE_3 ) VAR_1 [ i ] ; if ( VAR_2 . METHOD_5 ( ) ) <START> return true ; <END> } } return false ; } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_4 . TYPE_5 VAR_2 ) { if ( METHOD_2 ( ) && VAR_1 != null && VAR_2 != null ) { if ( VAR_1 . VAR_3 != VAR_2 . VAR_4 ) { TYPE_3 . d ( TAG , VAR_1 . name + STRING_1 + VAR_1 . VAR_3 + STRING_2 + VAR_2 . VAR_4 ) ; METHOD_3 ( VAR_2 , TYPE_6 . VAR_6 ) ; <START> <END> return true ; } if ( VAR_7 ) { TYPE_3 . d ( TAG , STRING_3 + VAR_1 . name + STRING_4 ) ; } } } 
TYPE_1 METHOD_1 ( TYPE_2 user , TYPE_3 < TYPE_2 > VAR_1 ) { METHOD_2 ( STRING_1 ) ; return new TYPE_4 < TYPE_2 > ( TYPE_7 . VAR_3 , VAR_1 ) { @Override public TYPE_2 run ( ) throws TYPE_5 { <START> TYPE_6 . error ( STRING_2 ) ; <END> METHOD_3 ( user ) ; return user ; } } . start ( ) ; } 
<START> @Override <END> protected Map < String , Pair < String , String > > METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; return VAR_2 . stream ( ) . collect ( Collectors . VAR_3 ( VAR_4 - > VAR_4 . getId ( ) . toString ( ) , VAR_4 - > TYPE_2 . METHOD_3 ( TYPE_3 . VAR_6 , VAR_1 ) ) ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . VAR_2 ) ; METHOD_2 ( TYPE_1 . VAR_3 ) ; if ( METHOD_3 ( ) != null ) { METHOD_2 ( String . format ( STRING_1 , STRING_2 , METHOD_4 ( ) ) ) ; <START> } <END> } 
<START> public < TYPE_1 > TYPE_2 < TYPE_1 > map ( final TYPE_3 < TYPE_4 , TYPE_1 > f ) { <END> return bind ( a - > METHOD_1 ( f . f ( a ) ) ) ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 child ) { <START> return new TYPE_2 ( child , this . VAR_1 ) ; <END> } 
public synchronized List < TYPE_1 < ? > > METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> } 
private void METHOD_1 ( ) { when ( METHOD_2 ( ) . METHOD_3 ( ) ) . METHOD_4 ( VAR_1 ) ; when ( VAR_1 . get ( VAR_2 ) ) . METHOD_4 ( ( VAR_3 ) ) ; <START> when ( VAR_3 . METHOD_5 ( ) ) . METHOD_4 ( null ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( TYPE_5 . TYPE_4 ) ; METHOD_3 ( cmd . VAR_3 ( TYPE_5 . TYPE_4 ) ) ; List < String > VAR_4 = cmd . VAR_5 ( ) . METHOD_4 ( ) ; <START> assertEquals ( 2 , VAR_4 . size ( ) ) ; <END> assertEquals ( VAR_4 . get ( 0 ) , TYPE_2 . TYPE_3 . toString ( ) ) ; assertEquals ( VAR_4 . get ( 1 ) , String . format ( STRING_1 , TYPE_5 . TYPE_4 ) ) ; } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { String VAR_1 = text == null ? "" : text . VAR_2 ( VAR_3 ) ; <START> if ( VAR_1 . equals ( "" ) ) { <END> return null ; } return new TYPE_1 ( VAR_1 , VAR_3 , type ) ; } 
public List < String > METHOD_1 ( String VAR_1 ) { List < String > VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_2 = new ArrayList < String > ( 0 ) ; } <START> return new TYPE_2 . TYPE_3 . ArrayList < String > ( VAR_2 ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
public Object execute ( TYPE_1 event ) throws TYPE_2 { TYPE_3 VAR_1 = METHOD_1 ( event ) ; <START> if ( VAR_1 == null ) { <END> return null ; } TYPE_4 VAR_2 = new TYPE_4 ( VAR_1 ) ; TYPE_5 VAR_3 = new TYPE_5 ( TYPE_6 . METHOD_2 ( event ) , VAR_2 ) ; VAR_3 . METHOD_3 ( false ) ; VAR_3 . METHOD_4 ( ) ; return null ; } 
public TYPE_5 ( TYPE_1 buf ) { VAR_2 = TYPE_2 . METHOD_1 ( buf , TYPE_3 . class ) ; <START> VAR_3 = null ; <END> data = TYPE_2 . METHOD_1 ( buf , TYPE_4 . class ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( ( ) - > { <START> long VAR_1 = VAR_2 . METHOD_3 ( ) ; <END> METHOD_4 ( STRING_1 , VAR_3 , VAR_1 ) ; VAR_3 = VAR_1 ; } ) ; } 
public List < TYPE_1 > METHOD_1 ( Guid VAR_1 , TYPE_2 VAR_2 , boolean VAR_3 ) { if ( ! METHOD_2 ( VAR_1 ) ) { throw new TYPE_3 ( TYPE_5 . TYPE_4 ) ; } if ( VAR_3 ) { <START> if ( METHOD_3 ( VAR_1 , VAR_2 ) ) { <END> throw new TYPE_3 ( TYPE_5 . VAR_6 ) ; } } else { METHOD_4 ( VAR_1 , VAR_2 ) ; } return METHOD_5 ( VAR_1 , VAR_2 ) ; } 
private static TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( ) ; Assert . VAR_2 ( VAR_1 ) ; if ( TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( TYPE_6 . VAR_4 ) ) { return new TYPE_4 ( VAR_1 ) ; } <START> return new TYPE_5 ( VAR_1 ) ; <END> } 
public long METHOD_1 ( ) { long VAR_1 = - 1 ; try { synchronized ( this ) { VAR_1 = VAR_2 / VAR_3 ; <START> } <END> } catch ( Exception e ) { if ( VAR_3 == 0 && VAR_2 == 0 ) { VAR_1 = 0 ; } } return VAR_1 ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_2 ( ) ; VAR_2 = null ; VAR_3 . METHOD_2 ( ) ; VAR_4 = null ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> } 
public static byte [ ] METHOD_1 ( final String string ) { if ( string == null ) { <START> return null ; <END> } try { return string . VAR_1 ( VAR_2 ) ; } catch ( TYPE_1 e ) { throw TYPE_2 . METHOD_2 ( e ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 entity ) { <START> if ( VAR_1 . METHOD_2 ( VAR_2 ) ) { <END> List < TYPE_1 > VAR_3 = TYPE_3 . METHOD_3 ( VAR_1 , VAR_2 ) ; entity . VAR_4 ( TYPE_4 . METHOD_4 ( VAR_3 , new TYPE_5 < TYPE_1 , TYPE_6 > ( ) { @Override public TYPE_6 apply ( TYPE_1 input ) { return VAR_5 . METHOD_5 ( input , new TYPE_6 ( ) ) ; } } ) ) ; } } 
public String METHOD_1 ( Object element ) { if ( element instanceof String ) { return ( String ) element ; } if ( element instanceof TYPE_1 ) { <START> return ( ( TYPE_1 ) element ) . METHOD_2 ( ) . getName ( ) ; <END> } return null ; } 
public TYPE_5 ( ) { this . VAR_2 = TYPE_1 . METHOD_1 ( TYPE_4 < String , TYPE_2 > create ( ) ) ; <START> this . VAR_4 = TYPE_3 . METHOD_2 ( ) ; <END> } 
<START> public void METHOD_1 ( String VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
static String METHOD_1 ( String line ) { <START> if ( line . VAR_1 ( line . length ( ) - 1 ) == CHAR_1 ) { <END> return line . substring ( 0 , line . length ( ) - 1 ) ; } return line ; } 
<START> private TYPE_1 METHOD_1 ( ) throws TYPE_2 { <END> logger . trace ( STRING_1 ) ; METHOD_2 ( TYPE_3 . METHOD_3 ( STRING_2 ) ) ; final TYPE_1 VAR_1 = TYPE_1 . METHOD_1 ( ) ; if ( ! VAR_1 . METHOD_4 ( ) && ! VAR_1 . METHOD_5 ( ) && ! VAR_1 . METHOD_6 ( ) ) { logger . warn ( STRING_3 , VAR_1 ) ; } logger . debug ( STRING_4 , VAR_1 ) ; return VAR_1 ; } 
<START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) <END> { super ( VAR_2 , VAR_3 ) ; } 
public void close ( ) throws IOException { <START> this . VAR_1 = true ; <END> for ( final TYPE_1 listener : this . VAR_2 ) { try { listener . VAR_3 ( this ) ; } catch ( Throwable t ) { logger . debug ( STRING_1 + this , t ) ; } } this . VAR_4 . METHOD_1 ( ) ; } 
public void run ( ) { log . info ( STRING_1 ) ; try { VAR_1 . METHOD_1 ( this ) ; VAR_2 = true ; METHOD_2 ( ) ; } catch ( InterruptedException VAR_3 ) { log . info ( STRING_2 ) ; Thread . VAR_4 ( ) . METHOD_3 ( ) ; <START> } catch ( Exception e ) { <END> log . error ( STRING_3 , e . getMessage ( ) , e ) ; } finally { VAR_2 = false ; VAR_1 . METHOD_4 ( this ) ; } } 
private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> TYPE_3 VAR_2 = new TYPE_3 ( ) ; <END> VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( METHOD_5 ( ) ) ) ; VAR_2 . METHOD_6 ( VAR_1 . METHOD_4 ( METHOD_7 ( ) ) ) ; VAR_2 . METHOD_8 ( VAR_1 . METHOD_4 ( METHOD_9 ( ) ) ) ; VAR_2 . METHOD_10 ( VAR_1 . METHOD_4 ( METHOD_11 ( ) ) ) ; return VAR_2 . METHOD_12 ( ) ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 , boolean VAR_2 ) { TYPE_1 result = VAR_2 ? null : TYPE_1 . VAR_3 ; try { result = org . VAR_4 . VAR_5 . VAR_6 . TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> if ( null == result && VAR_2 ) { <END> result = TYPE_1 . VAR_3 ; } } catch ( IllegalArgumentException e ) { result = VAR_2 ? TYPE_1 . VAR_3 : null ; } return result ; } 
private void METHOD_1 ( final Set < String > VAR_1 , final String VAR_2 ) { final Collection < String > VAR_3 = METHOD_2 ( ) ; <START> if ( METHOD_3 ( ) && ! VAR_3 . equals ( VAR_1 ) ) { <END> VAR_1 . addAll ( VAR_3 ) ; VAR_4 . clear ( ) ; VAR_4 . addAll ( VAR_1 ) ; log . debug ( STRING_1 , VAR_2 , VAR_1 . size ( ) ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; } } 
public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) TYPE_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; <END> if ( VAR_3 != null ) TYPE_2 . METHOD_4 ( VAR_3 ) ; } 
public void METHOD_1 ( Collection < ? extends TYPE_1 > VAR_1 ) { <START> for ( TYPE_2 listener : TYPE_3 . METHOD_2 ( VAR_2 ) ) { <END> listener . VAR_3 ( ( Collection < TYPE_1 > ) VAR_1 ) ; } } 
<START> public File METHOD_1 ( ) { <END> return this . VAR_1 . METHOD_2 ( ) ; } 
protected void METHOD_1 ( Object VAR_1 ) { for ( int VAR_2 = 0 ; VAR_2 < VAR_3 . length ; VAR_2 ++ ) { Object VAR_4 = VAR_5 . METHOD_2 ( VAR_1 , VAR_3 [ VAR_2 ] ) ; <START> if ( VAR_4 == null ) { <END> continue ; } VAR_6 [ VAR_2 ] . write ( VAR_4 ) ; } } 
private void METHOD_1 ( boolean VAR_1 ) { int c = METHOD_2 ( ) ; <START> while ( c != CHAR_1 && c != VAR_2 && ( VAR_1 || ( c != CHAR_2 ) ) ) { <END> c = METHOD_2 ( ) ; } if ( c == VAR_2 || ! VAR_1 ) { METHOD_3 ( c ) ; } } 
<START> private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 , TYPE_8 { <END> final TYPE_9 VAR_2 = METHOD_2 ( ) ; final TYPE_1 VAR_3 = VAR_4 . METHOD_3 ( ) . METHOD_4 ( sess , VAR_1 , VAR_2 ) ; return VAR_3 ; } 
private TYPE_1 METHOD_1 ( int i , long VAR_1 , long VAR_2 ) { TYPE_1 VAR_3 = TYPE_2 . buffer ( 4 + INT_1 ) ; VAR_3 . METHOD_2 ( VAR_1 ) ; <START> VAR_3 . METHOD_2 ( VAR_2 ) ; <END> VAR_3 . METHOD_3 ( i ) ; return VAR_3 ; } 
private void METHOD_1 ( Guid VAR_1 ) { TYPE_1 VAR_2 = getParameters ( ) . METHOD_2 ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( VAR_2 . getId ( ) , VAR_1 ) ; VAR_3 . METHOD_3 ( TYPE_6 . TYPE_5 ) ; <START> TYPE_3 . getInstance ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_3 ) ; <END> TYPE_4 . METHOD_6 ( VAR_1 , VAR_2 . getId ( ) ) ; } 
public double METHOD_1 ( TYPE_1 node , TYPE_2 version ) { <START> TYPE_3 VAR_1 = ( TYPE_8 . TYPE_9 . equals ( version ) ) <END> ? new TYPE_5 ( ) : new TYPE_6 ( ) ; TYPE_7 VAR_2 = ( TYPE_7 ) node . VAR_3 ( VAR_1 , new TYPE_7 ( 1 ) ) ; return ( double ) VAR_2 . getValue ( ) ; } 
public long METHOD_1 ( int [ ] key ) { long VAR_1 = ( key . length * Integer . VAR_2 ) ; VAR_1 += Arrays . stream ( key ) . filter ( element - > VAR_3 . getValue ( element ) != null ) <START> . METHOD_2 ( element - > VAR_3 . getValue ( element ) . length ( ) * TYPE_1 . VAR_2 ) . METHOD_3 ( ) ; <END> return VAR_1 ; } 
public void add ( int index , T element ) { if ( VAR_1 . add ( element ) ) { try { super . add ( index , element ) ; } catch ( TYPE_1 VAR_2 ) { VAR_1 . remove ( element ) ; <START> throw new TYPE_1 ( ) ; <END> } } } 
public String METHOD_1 ( ) { final String VAR_1 = client . VAR_2 ( ) . METHOD_1 ( ) ; <START> if ( VAR_1 == null ) { <END> throw new RuntimeException ( STRING_1 ) ; } return VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . equals ( VAR_2 ) ) { return null ; <START> } else { <END> return ( TYPE_1 ) VAR_3 . METHOD_3 ( VAR_1 ) ; } } 
protected void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_2 ( STRING_3 , new TYPE_2 ( STRING_4 ) . format ( new Date ( ) ) ) ; synchronized ( this ) { VAR_2 . METHOD_3 ( VAR_3 , TYPE_3 . builder ( ) . command ( STRING_5 ) . build ( ) ) ; } } 
private static String METHOD_1 ( TYPE_1 VAR_1 , String value ) { if ( METHOD_2 ( VAR_1 . getType ( ) ) ) { return String . format ( STRING_1 , VAR_1 . getName ( ) , value ) ; } <START> else { <END> return String . format ( STRING_2 , VAR_1 . getName ( ) , value ) ; } } 
int METHOD_1 ( ) { <START> log . warn ( STRING_1 ) ; <END> return VAR_1 . get ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 entity ) { <START> if ( entity != null ) { <END> Class VAR_1 ; if ( entity . VAR_2 ( ) . equals ( TYPE_5 . TYPE_7 . toString ( ) ) ) { VAR_1 = TYPE_4 . class ; } else { VAR_1 = TYPE_5 . METHOD_2 ( entity . VAR_2 ( ) ) . METHOD_3 ( ) ; } TYPE_6 VAR_3 = TYPE_6 . instance ( ) ; TYPE_1 p = VAR_3 . METHOD_4 ( entity . getId ( ) , VAR_1 ) ; return p ; } return null ; } 
public static List < String > METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { Iterator < String > VAR_2 = VAR_1 . METHOD_2 ( ) ; List < String > VAR_3 = new ArrayList < String > ( ) ; <START> while ( VAR_2 != null && VAR_2 . hasNext ( ) ) { <END> VAR_3 . add ( VAR_2 . next ( ) ) ; } LOG . debug ( STRING_1 , VAR_3 ) ; return VAR_3 ; } 
private ANNOTATION_1 Map < ANNOTATION_2 String , ANNOTATION_2 TYPE_1 > METHOD_1 ( long start , long VAR_1 , TYPE_2 monitor ) { Collection < ANNOTATION_2 TYPE_3 > VAR_2 = METHOD_2 ( start , VAR_1 ) ; if ( VAR_2 == null ) { <START> return null ; <END> } if ( monitor . VAR_3 ( ) ) { return Collections . VAR_4 ; } return METHOD_3 ( VAR_2 , monitor ) ; } 
<START> protected void METHOD_1 ( StringBuilder builder ) <END> { builder . append ( this . VAR_1 ) ; } 
public void METHOD_1 ( ) { start ( ) ; <START> super . METHOD_1 ( true ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 request , TYPE_2 VAR_1 ) { if ( VAR_1 == null ) { return false ; <START> } else if ( VAR_1 instanceof TYPE_3 ) { <END> TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; return VAR_2 . METHOD_2 ( request , this . VAR_3 ) ; } else { String VAR_4 = TYPE_4 . METHOD_3 ( request ) ; return VAR_1 . METHOD_4 ( ) . equals ( VAR_4 ) ; } } 
public void METHOD_1 ( boolean VAR_1 ) { METHOD_2 ( ) . METHOD_1 ( VAR_1 ) ; <START> if ( VAR_1 ) { <END> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( STRING_1 ) ; } else { METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( STRING_2 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 != null ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; } <START> VAR_2 = new TYPE_2 ( VAR_1 , this ) ; <END> METHOD_4 ( VAR_1 ) ; } 
public String toString ( ) { <START> String VAR_1 = ( TYPE_1 < 0 ) ? STRING_1 : "" ; <END> return String . format ( STRING_2 , VAR_1 , TYPE_3 , TYPE_2 , TYPE_6 , TYPE_4 , TYPE_5 ) ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 ) { this . VAR_2 . remove ( VAR_1 ) ; this . VAR_3 . METHOD_2 ( ) ; <START> System . out . println ( STRING_1 + this . VAR_3 . METHOD_3 ( ) ) ; <END> } 
public Object METHOD_1 ( ) throws TYPE_1 { super . METHOD_1 ( ) ; TYPE_2 ctx = new TYPE_2 ( ) ; ctx . VAR_1 ( this ) ; <START> return this . METHOD_2 ( ) ; <END> } 
@Override public Response execute ( TYPE_1 request ) throws IOException { TYPE_2 VAR_1 = METHOD_1 ( request ) ; TYPE_3 VAR_2 = execute ( client , VAR_1 ) ; String url = request . VAR_3 ( ) ; <START> if ( this . VAR_4 != null && this . VAR_4 . VAR_5 != null ) { <END> url = this . VAR_4 . VAR_5 . toString ( ) ; } return METHOD_2 ( url , VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> VAR_1 . METHOD_1 ( ) . METHOD_2 ( true ) ; <END> return VAR_1 . METHOD_1 ( ) ; } 
static TYPE_1 METHOD_1 ( TYPE_2 node ) { <START> if ( node instanceof TYPE_3 ) { <END> return node . VAR_1 ( ) . METHOD_1 ( ) ; } return node . VAR_2 ( ) . METHOD_2 ( TYPE_4 . VAR_4 ) ; } 
public void METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) { this . VAR_1 = Guid . TYPE_1 ( ) . toString ( ) ; } else if ( VAR_1 . length ( ) <= 100 ) { this . VAR_1 = VAR_1 ; } else { this . VAR_1 = VAR_1 . substring ( 0 , 100 ) ; } <START> } <END> 
public void METHOD_1 ( ) throws IOException , InterruptedException { try ( TYPE_1 file = new TYPE_1 ( ) ) { TYPE_2 . write ( STRING_1 , file . file ( ) , VAR_1 ) ; METHOD_2 ( STRING_2 , file . file ( ) . METHOD_3 ( ) ) ; assertThat ( METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ) . METHOD_6 ( VAR_3 ) ; VAR_2 . METHOD_7 ( ) ; } <START> } <END> 
<START> static < TYPE_1 extends TYPE_2 < TYPE_1 > > Optional < Class < ? > > METHOD_1 ( Type type ) { <END> return Optional . of ( type ) . map ( TYPE_3 : : METHOD_2 ) . filter ( Class : : METHOD_3 ) . map ( c - > ( Class < TYPE_1 > ) c ) ; } 
private String METHOD_1 ( ) { ImmutableList < String > VAR_1 = VAR_2 . METHOD_2 ( ) ; return TYPE_1 . METHOD_3 ( TYPE_2 . of ( STRING_1 , VAR_1 . METHOD_4 ( 0 , Math . VAR_3 ( VAR_1 . size ( ) , VAR_4 ) ) , STRING_2 , ImmutableList . VAR_5 ( VAR_1 ) , <START> STRING_3 , TYPE_3 . METHOD_5 ( ) . METHOD_6 ( ) > FLOAT_1 ? VAR_6 : VAR_7 ) ) ; <END> } 
private long METHOD_1 ( long VAR_1 ) { TYPE_1 VAR_2 = <START> new TYPE_2 ( ) ; <END> VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_2 . set ( TYPE_1 . VAR_3 , 0 ) ; VAR_2 . set ( TYPE_1 . VAR_4 , 0 ) ; VAR_2 . add ( TYPE_1 . VAR_5 , 1 ) ; return VAR_2 . METHOD_3 ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = db . VAR_2 ( ) ; VAR_1 . METHOD_2 ( STRING_1 ) . execute ( ) ; try { VAR_1 . METHOD_3 ( STRING_2 ) . METHOD_4 ( TYPE_3 . class ) . METHOD_5 ( ) ; METHOD_6 ( STRING_3 ) ; } catch ( IllegalArgumentException e ) { <START> assertThat ( e ) . METHOD_7 ( ) ; <END> } } 
<START> private static void METHOD_1 ( final TYPE_1 key , final boolean value ) { <END> final TYPE_2 < TYPE_1 , Boolean > cache = TYPE_4 . TYPE_5 . get ( ) ; if ( cache != null ) { cache . put ( key , value ) ; TYPE_4 . TYPE_5 . set ( cache ) ; } } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; <END> } 
<START> private void METHOD_1 ( ) throws IOException { <END> for ( Map . Entry < String , TYPE_1 > entry : VAR_1 . entrySet ( ) ) { String VAR_2 = entry . getKey ( ) ; TYPE_1 VAR_3 = entry . getValue ( ) ; if ( ! VAR_3 . METHOD_2 ( ) . contains ( VAR_4 ) ) { info ( STRING_1 , VAR_4 , VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_4 ) ; VAR_3 . METHOD_4 ( VAR_4 , TYPE_2 . name , TYPE_2 . build ( ) ) ; } } } 
private int METHOD_1 ( TYPE_1 result ) { int VAR_1 ; switch ( result ) { case VAR_2 : VAR_1 = R . VAR_3 . VAR_4 ; break ; case VAR_5 : VAR_1 = R . VAR_3 . VAR_6 ; break ; case VAR_7 : VAR_1 = R . VAR_3 . VAR_8 ; break ; default : <START> return R . VAR_3 . VAR_9 ; <END> } return context . VAR_10 ( ) . METHOD_2 ( VAR_1 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return super . VAR_1 ; <END> } 
<START> public static <END> TYPE_1 create ( long start , long VAR_1 , int VAR_2 , String value , ANNOTATION_1 TYPE_2 parent ) { if ( start > VAR_1 ) { throw new IllegalArgumentException ( Messages . TYPE_3 + CHAR_1 + start + CHAR_2 + VAR_1 + CHAR_3 ) ; } return new TYPE_1 ( start , VAR_1 , value , VAR_2 , parent ) ; } 
private TYPE_1 < Throwable , Throwable > METHOD_1 ( TYPE_2 event ) { return VAR_1 - > { Throwable VAR_2 = METHOD_2 ( VAR_1 ) ; TYPE_2 VAR_3 = event ; if ( VAR_1 instanceof TYPE_3 ) { VAR_3 = ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) ; } return new TYPE_3 ( VAR_3 , new TYPE_4 ( METHOD_4 ( VAR_4 , VAR_2 . getMessage ( ) ) , <START> null , VAR_5 ) , <END> VAR_5 ) ; } ; } 
private void METHOD_1 ( final TYPE_1 context ) { if ( METHOD_2 ( ) ) { if ( ! ( context instanceof TYPE_2 ) ) { context . VAR_1 ( ) ; } else { TYPE_3 . METHOD_3 ( this ) . METHOD_4 ( ) . METHOD_5 ( VAR_2 , false ) . commit ( ) ; } } <START> TYPE_4 . METHOD_6 ( ) ; <END> } 
<START> public boolean METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 , String VAR_6 ) { <END> return TYPE_1 . METHOD_2 ( VAR_1 . toString ( ) , VAR_2 . toString ( ) , VAR_3 . toString ( ) , VAR_4 . toString ( ) , VAR_5 . toString ( ) , VAR_6 . toString ( ) ) ; } 
public Integer METHOD_1 ( Integer VAR_1 , TYPE_1 < ? super T > VAR_2 ) { int i = VAR_1 ; <START> while ( i < index . get ( ) ) { <END> METHOD_2 ( VAR_2 , i ) ; i ++ ; } return i ; } 
public String METHOD_1 ( ) { <START> return VAR_1 + STRING_1 + VAR_2 + STRING_2 ; <END> } 
<START> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> return null ; } 
protected int METHOD_1 ( String VAR_1 ) { TYPE_1 [ ] VAR_2 = this . VAR_3 ; TYPE_2 VAR_4 = new TYPE_2 ( VAR_1 ) ; <START> return Arrays . VAR_5 ( VAR_2 , VAR_4 , ( VAR_6 , VAR_7 ) - > VAR_6 . name . METHOD_2 ( VAR_7 . name ) ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( STRING_1 ) . METHOD_4 ( INT_1 ) ; <START> METHOD_5 ( ) ; <END> Assert . assertTrue ( METHOD_3 ( STRING_2 ) . exists ( ) ) ; } 
@Override public void METHOD_1 ( Context context , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IllegalStateException { <START> if ( ! METHOD_2 ( context , TYPE_4 . VAR_4 . VAR_5 ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } TYPE_3 . METHOD_3 ( context , VAR_1 . getString ( STRING_2 ) ) ; } 
public View METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , TYPE_2 container , TYPE_3 VAR_2 ) { <START> TYPE_2 VAR_3 = METHOD_2 ( VAR_1 , container , VAR_2 ) ; return VAR_3 ; <END> } 
<START> public static Set < TYPE_1 > METHOD_1 ( TYPE_2 ... VAR_1 ) { <END> Set < TYPE_1 > result = new HashSet < > ( ) ; for ( TYPE_2 VAR_2 : VAR_1 ) { result . addAll ( VAR_2 . METHOD_2 ( ) ) ; } return result ; } 
private Long METHOD_1 ( List < Long > VAR_1 , String VAR_2 ) { int VAR_3 = 0 ; for ( Long host : VAR_1 ) { Map < String , String > VAR_4 = VAR_5 . METHOD_2 ( host ) ; if ( VAR_4 . containsKey ( TYPE_1 . VAR_7 ) ) { if ( VAR_4 . get ( TYPE_1 . VAR_7 ) . equalsIgnoreCase ( STRING_1 ) ) { <START> VAR_3 ++ ; <END> } } } return VAR_3 > 0 ? new Long ( 1 ) : new Long ( 0 ) ; } 
<START> void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_2 = VAR_1 ; } 
public Double METHOD_1 ( TYPE_1 < Double > result ) { <START> return ( result . value ) / result . count ; <END> } 
public static void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = TYPE_2 . class . METHOD_2 ( ) ; <START> assert VAR_1 <END> != null ; File VAR_2 = new File ( VAR_3 . METHOD_3 ( ) , STRING_1 ) ; try ( TYPE_3 in = VAR_1 . METHOD_4 ( STRING_1 ) ; TYPE_4 out = new TYPE_5 ( VAR_2 ) ) { TYPE_6 . METHOD_5 ( in , out ) ; } VAR_4 = new TYPE_7 ( VAR_2 . METHOD_6 ( ) , VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 [ ] parameters , TYPE_2 VAR_1 , TYPE_3 method ) { <START> if ( method . VAR_2 ( TYPE_4 . class ) && method . VAR_3 ( ) . METHOD_2 ( TYPE_4 . class ) . METHOD_3 ( ) ) { <END> return true ; } for ( TYPE_1 VAR_4 : parameters ) { if ( VAR_1 . get ( VAR_4 . getName ( ) ) != null ) return false ; } return true ; } 
public String getValue ( TYPE_1 task ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_1 ( task . VAR_2 ( ) ) ; TYPE_4 VAR_3 = TYPE_5 . METHOD_2 ( task ) ; <START> TYPE_6 url = VAR_1 . METHOD_3 ( VAR_3 , task ) ; <END> if ( url == null ) { return task . VAR_4 ( ) ; } return url . toString ( ) ; } 
protected void METHOD_1 ( ) { <START> this . VAR_1 = TYPE_1 . METHOD_2 ( this . METHOD_3 ( ) ) ; <END> if ( this . VAR_2 == null ) { this . VAR_2 = new TYPE_2 ( this . VAR_3 , this . VAR_4 ) ; } this . VAR_5 = true ; } 
public String read ( String key ) { String data = VAR_1 . read ( key ) ; <START> return ( data == null ) ? null : VAR_2 ( VAR_3 . VAR_4 ( VAR_5 , VAR_6 ( data ) ) ; <END> } 
protected void METHOD_1 ( ) { try { TYPE_1 VAR_1 = <START> METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) , TYPE_2 . METHOD_5 ( getParameters ( ) . METHOD_6 ( ) ) ) ; <END> METHOD_7 ( VAR_1 . METHOD_8 ( ) ) ; } catch ( IOException e ) { log . error ( STRING_1 , e ) ; return ; } } 
public TYPE_1 METHOD_1 ( ) { final TYPE_1 row = VAR_1 . METHOD_1 ( ) ; if ( row . size ( ) == 1 ) { if ( VAR_2 == 0 ) { return row ; } else { return new TYPE_2 ( row . get ( 0 ) + VAR_2 ) ; } } else { <START> return new TYPE_2 ( 0 ) ; <END> } } 
public void METHOD_1 ( TYPE_1 ctx ) throws Exception { super . METHOD_1 ( ctx ) ; LOG . info ( STRING_1 , ctx ) ; <START> } <END> 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } <START> if ( ! ( obj instanceof TYPE_1 ) ) { <END> return false ; } if ( ! getClass ( ) . equals ( obj . getClass ( ) ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return getId ( ) == VAR_1 . getId ( ) ; } 
public List < TYPE_1 > METHOD_1 ( final TYPE_4 . TYPE_5 id ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; VAR_1 . addAll ( METHOD_2 ( id ) ) ; VAR_1 . addAll ( METHOD_3 ( id ) ) ; Collections . VAR_2 ( VAR_1 , TYPE_1 . VAR_3 ) ; <START> VAR_1 = Collections . VAR_4 ( TYPE_3 . METHOD_4 ( VAR_1 ) ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( final String VAR_1 , final String value ) { VAR_2 . METHOD_2 ( VAR_1 , ( key , values ) - > { values . forEach ( i - > { <START> if ( ( i . getValue ( ) . equals ( value ) ) && i . VAR_3 ( ) == false ) { <END> i . VAR_4 ( true ) ; } } ) ; return values ; } ) ; } 
<START> public synchronized TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return VAR_1 ; } 
public void METHOD_1 ( int id ) { try { <START> if ( ! TYPE_1 . equals ( id , null ) ) { <END> METHOD_2 ( this . VAR_1 . METHOD_3 ( ) . METHOD_4 ( id ) ) ; } } catch ( TYPE_2 e ) { TYPE_3 . METHOD_5 ( STRING_1 + id + STRING_2 , e . getMessage ( ) ) ; } } 
private void METHOD_1 ( <START> String VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> try ( TYPE_1 VAR_4 = VAR_3 . METHOD_2 ( ) ) { String VAR_5 = VAR_3 . METHOD_3 ( ) ; LOG . debug ( STRING_1 , VAR_5 ) ; VAR_6 . METHOD_4 ( VAR_1 , VAR_1 , VAR_2 , VAR_5 , VAR_4 ) ; } catch ( IOException e ) { LOG . error ( STRING_2 , e ) ; } } 
public void METHOD_1 ( ) throws TYPE_1 { synchronized ( TYPE_2 . class ) { if ( VAR_1 == null ) { VAR_2 = TYPE_3 . get ( METHOD_2 ( ) . getProperty ( VAR_3 ) ) ; <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> try { VAR_1 = METHOD_3 ( ) ; } catch ( final IOException | TYPE_4 e ) { throw new TYPE_1 ( e ) ; } } VAR_4 ++ ; } } 
protected void METHOD_1 ( TYPE_1 configuration ) throws TYPE_2 { <START> String VAR_1 = <END> configuration . getProperty ( STRING_1 , STRING_2 ) ; TYPE_3 . put ( STRING_3 , VAR_1 ) ; } 
<START> void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) <END> throws IOException { TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( TYPE_1 . VAR_4 , null ) ; TYPE_3 VAR_5 = new TYPE_3 ( ) ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { METHOD_4 ( VAR_1 , 10 ) ; VAR_3 . METHOD_3 ( TYPE_1 . VAR_4 , null ) ; } METHOD_4 ( VAR_1 , 10 ) ; } 
public static ArrayList < Guid > METHOD_1 ( String VAR_1 ) { <START> if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { <END> return new ArrayList < Guid > ( ) ; } return METHOD_3 ( Arrays . asList ( VAR_1 . split ( VAR_2 ) ) ) ; } 
public TYPE_1 ( Context context ) { VAR_2 = context ; <START> VAR_3 = STRING_1 ; <END> VAR_4 = TYPE_2 . VAR_6 ; VAR_7 . put ( VAR_3 , VAR_4 ) ; } 
public static TYPE_1 METHOD_1 ( Object input , String content ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( content ) ; if ( input instanceof TYPE_2 ) { TYPE_2 VAR_2 = ( TYPE_2 ) input ; <START> VAR_1 . METHOD_3 ( VAR_2 ) ; <END> } else if ( input instanceof TYPE_3 ) { VAR_1 . METHOD_4 ( ( TYPE_3 ) input ) ; } else { throw new IllegalArgumentException ( STRING_1 + input ) ; } return VAR_1 ; } 
private TYPE_1 < String , TYPE_2 > METHOD_1 ( List < TYPE_3 > VAR_1 ) { TYPE_1 < String , TYPE_2 > VAR_2 ; try { <START> VAR_2 = METHOD_2 ( VAR_1 ) ; <END> } catch ( TYPE_4 e ) { throw TYPE_5 . METHOD_3 ( e ) ; } return VAR_2 ; } 
public static boolean METHOD_1 ( int VAR_1 ) { <START> switch ( METHOD_2 ( VAR_1 ) ) { <END> case VAR_2 : case VAR_3 : return true ; default : return false ; } } 
public List < String > METHOD_1 ( ) { if ( METHOD_2 ( ) ) { METHOD_3 ( ) ; <START> for ( final String VAR_1 : VAR_2 . METHOD_1 ( ) ) { <END> super . METHOD_4 ( VAR_1 ) ; } } return super . METHOD_1 ( ) ; } 
private boolean METHOD_1 ( TYPE_1 event ) { String VAR_1 = event . getType ( ) . getName ( ) ; String VAR_2 = VAR_3 ; if ( VAR_1 . equals ( VAR_2 ) ) { return true ; } <START> if ( ( VAR_2 . METHOD_2 ( TYPE_2 . VAR_5 ) && VAR_1 . startsWith ( VAR_2 . METHOD_3 ( TYPE_2 . VAR_5 , TYPE_2 . VAR_6 ) ) ) ) { <END> return true ; } return false ; } 
ANNOTATION_1 public String server ( ) { if ( server . startsWith ( STRING_1 ) ) { server = <START> STRING_2 + <END> server ; } return server ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; if ( ! VAR_1 . METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( true ) ; } else { VAR_2 . METHOD_4 ( VAR_3 . format ( TYPE_3 . TYPE_4 , VAR_6 . METHOD_5 ( ) ) ) ; } VAR_7 . METHOD_4 ( VAR_6 . METHOD_6 ( ) ) ; VAR_8 . METHOD_7 ( STRING_1 , VAR_3 . METHOD_8 ( TYPE_3 . TYPE_2 ) ) ; <START> VAR_10 = new HashMap < > ( ) ; <END> } 
private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 , String VAR_3 ) { for ( TYPE_1 VAR_4 : VAR_2 ) { <START> if ( StringUtils . VAR_5 ( VAR_4 . METHOD_2 ( ) ) && StringUtils . VAR_5 ( VAR_3 ) && VAR_4 . METHOD_2 ( ) . METHOD_3 ( VAR_3 ) == 0 ) { <END> VAR_1 . add ( VAR_4 ) ; VAR_2 . remove ( VAR_4 ) ; return VAR_4 ; } } return null ; } 
public static ArrayList < Guid > METHOD_1 ( List < String > VAR_1 ) { ArrayList < Guid > VAR_2 = new ArrayList < Guid > ( ) ; <START> if ( TYPE_1 . isEmpty ( VAR_1 ) ) { <END> for ( String VAR_3 : VAR_1 ) { VAR_2 . add ( Guid . VAR_4 ( VAR_3 ) ) ; } } return VAR_2 ; } 
public void METHOD_1 ( ) { <START> assertThat ( Arrays . asList ( VAR_1 ) . iterator ( ) ) . METHOD_2 ( ) . contains ( VAR_1 [ 0 ] ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws Exception { TYPE_1 VAR_2 ; try { VAR_2 = VAR_1 . METHOD_2 ( VAR_3 ) ; } catch ( Exception e ) { log . error ( STRING_1 + VAR_1 . METHOD_3 ( ) , e ) ; <START> throw e ; <END> } return VAR_2 ; } 
public TYPE_1 < TYPE_2 < ? > > METHOD_1 ( TYPE_3 query ) { <START> query . VAR_1 ( METHOD_2 ( query ) ) ; <END> return VAR_2 . METHOD_1 ( query ) ; } 
private static void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 { if ( TYPE_3 . METHOD_2 ( VAR_2 ) ) { if ( VAR_1 . METHOD_3 ( ) == null ) { <START> LOG . debug ( STRING_1 ) ; <END> throw new TYPE_2 ( TYPE_4 . VAR_4 , STRING_2 ) ; } if ( ! VAR_1 . METHOD_4 ( ) ) { LOG . debug ( STRING_3 ) ; throw new TYPE_2 ( TYPE_4 . VAR_4 , STRING_4 ) ; } } } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( String . format ( STRING_1 , VAR_1 , <END> TYPE_1 . VAR_3 ) ) ; METHOD_3 ( ) . METHOD_4 ( STRING_2 , VAR_1 ) . METHOD_5 ( ) . METHOD_6 ( STRING_3 ) . METHOD_7 ( STRING_4 ) . build ( ) . run ( ) ; } 
public void METHOD_1 ( ) throws Exception { <START> this . VAR_1 = null ; <END> this . VAR_2 . clear ( ) ; this . VAR_3 . clear ( ) ; } 
private String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 model , TYPE_3 request ) { TYPE_4 VAR_2 = METHOD_2 ( VAR_1 , model , request ) ; String VAR_3 = METHOD_3 ( request ) ; model . VAR_4 ( STRING_1 , STRING_2 ) ; <START> model . VAR_4 ( STRING_3 , STRING_4 <END> + VAR_3 + STRING_5 ) ; return STRING_2 ; } 
<START> private TYPE_2 ( ANNOTATION_1 Set < TYPE_1 > VAR_2 , int VAR_3 , <END> ANNOTATION_1 Set < TYPE_1 > VAR_4 , long VAR_5 , ANNOTATION_1 Set < String > VAR_6 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 input ) { <START> TYPE_3 VAR_1 = TYPE_3 . METHOD_1 ( input ) ; <END> return new TYPE_1 ( VAR_1 ) ; } 
private void METHOD_1 ( File VAR_1 ) { if ( VAR_1 != null ) { try { TYPE_1 . METHOD_2 ( VAR_1 ) ; } catch ( IOException e ) { <START> TYPE_2 . METHOD_3 ( e ) ; <END> } } } 
public TYPE_1 METHOD_1 ( String VAR_1 , Object ... args ) { String VAR_2 = String . format ( VAR_1 , args ) ; <START> this . VAR_3 . METHOD_2 ( info , VAR_4 , VAR_2 ) ; <END> return super . METHOD_1 ( VAR_2 ) ; } 
public String METHOD_1 ( ) { if ( STRING_1 . equals ( METHOD_2 ( ) . METHOD_3 ( ) ) ) { return METHOD_2 ( ) . METHOD_1 ( ) ; } <START> Optional < String > VAR_1 = Optional . of ( METHOD_2 ( ) . METHOD_4 ( STRING_2 ) ) ; <END> return VAR_1 . METHOD_5 ( "" ) ; } 
public double METHOD_1 ( ) { <START> return ( double ) VAR_1 . METHOD_2 ( ) ; <END> } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 , float VAR_2 ) { <END> VAR_1 . METHOD_2 ( VAR_3 ) ; if ( VAR_4 == FLOAT_1 ) { super . METHOD_3 ( false ) ; } else { super . METHOD_3 ( true ) ; } if ( VAR_5 instanceof TYPE_2 ) { VAR_5 . METHOD_1 ( VAR_1 , VAR_4 ) ; } if ( METHOD_4 ( ) && this . METHOD_5 ( ) != null ) { super . METHOD_1 ( VAR_1 , this . VAR_4 ) ; } VAR_1 . METHOD_2 ( null ) ; } 
protected boolean METHOD_1 ( TYPE_1 TYPE_2 ) { if ( TYPE_2 . METHOD_2 ( ) || TYPE_2 . METHOD_3 ( VAR_1 ) ) { return true ; } TYPE_3 VAR_2 = TYPE_4 . METHOD_4 ( TYPE_3 . class ) ; List < String > VAR_3 = VAR_2 . METHOD_5 ( ) ; <START> return VAR_3 . stream ( ) . METHOD_6 ( TYPE_2 : : METHOD_3 ) ; <END> } 
void METHOD_1 ( ) { <START> this . VAR_1 = true ; <END> this . VAR_2 = true ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( ) . METHOD_3 ( ) . add ( VAR_1 ) ; <END> } 
public < T > TYPE_1 add ( TYPE_2 type , T VAR_1 , T VAR_2 , boolean VAR_3 ) { String VAR_4 = VAR_1 != null ? VAR_1 . toString ( ) : STRING_1 ; <START> String VAR_5 = VAR_2 != null ? VAR_2 . toString ( ) : STRING_1 ; <END> VAR_6 . add ( new TYPE_3 ( type , VAR_4 , VAR_5 , VAR_3 ) ) ; return this ; } 
public String toString ( ) { StringBuilder sb = new StringBuilder ( STRING_1 ) ; <START> if ( table != null ) { <END> sb . append ( table . getPath ( ) ) ; } if ( reader != null ) { sb . append ( STRING_2 ) . append ( TYPE_1 . METHOD_1 ( reader . getId ( ) ) ) ; } sb . append ( STRING_3 ) . append ( reader ) . append ( CHAR_1 ) ; return sb . toString ( ) ; } 
private static TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> TYPE_1 . Builder builder = TYPE_1 . METHOD_2 ( new TYPE_2 ( Type . TYPE_4 . VAR_4 , TYPE_2 . TYPE_5 . VAR_6 , STRING_1 , TYPE_3 . VAR_8 ) ) ; <END> builder . VAR_9 ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_2 . METHOD_3 ( ) ) . METHOD_5 ( 0 ) ; return builder . build ( ) ; } 
<START> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , ANNOTATION_1 String VAR_2 ) { <END> try { if ( TYPE_3 . METHOD_2 ( VAR_2 ) ) { VAR_2 = TYPE_1 . METHOD_3 ( VAR_1 ) ; } return new TYPE_1 ( VAR_2 ) ; } catch ( Exception e ) { logger . error ( STRING_1 , VAR_2 , e ) ; throw e ; } } 
public void METHOD_1 ( TYPE_1 channel ) throws IOException { <START> this . channel = channel ; <END> } 
public void METHOD_1 ( TYPE_1 context ) throws InterruptedException { <START> super . METHOD_1 ( context ) ; <END> VAR_1 . values ( ) . forEach ( TYPE_2 : : close ) ; } 
void METHOD_1 ( ) <START> throws TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , <END> TYPE_7 { byte [ ] VAR_1 = STRING_1 . METHOD_2 ( STRING_2 ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; TYPE_8 VAR_3 = new TYPE_8 ( VAR_1 ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) { return TYPE_1 . METHOD_3 ( VAR_2 , VAR_1 . METHOD_4 ( TYPE_3 . VAR_4 ) ) ; } else { <START> return METHOD_1 ( VAR_1 . METHOD_2 ( ) ) . append ( VAR_5 , VAR_1 . METHOD_4 ( TYPE_3 . VAR_4 ) ) ; <END> } } 
<START> void METHOD_1 ( String id , TYPE_2 . TYPE_3 VAR_1 ) { <END> VAR_2 . put ( id , VAR_1 ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( true , false ) ) { METHOD_3 ( ) ; VAR_2 . METHOD_1 ( ) ; } <START> if ( config . VAR_3 ( ) == TYPE_1 . VAR_5 ) { <END> VAR_6 . METHOD_1 ( ) ; } } 
public static synchronized void METHOD_1 ( int VAR_1 ) { if ( VAR_2 == null ) { VAR_2 = new TYPE_1 ( VAR_1 ) ; } else if ( VAR_2 . METHOD_2 ( ) != VAR_1 ) { <START> VAR_2 . METHOD_3 ( VAR_1 ) ; <END> } } 
public String toString ( ) { <START> return String . valueOf ( value ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { try { return Context . VAR_1 ( ) . METHOD_2 ( "" ) ; } catch ( Exception e ) { <START> logger . error ( STRING_1 , e ) ; <END> } return Collections . VAR_2 ( ) ; } 
public String METHOD_1 ( ) { <START> VAR_1 = StringUtils . isEmpty ( VAR_2 . METHOD_2 ( ) . getName ( ) ) ? VAR_3 <END> : VAR_2 . METHOD_2 ( ) . getName ( ) ; return VAR_1 ; } 
<START> TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , int VAR_4 , <END> TYPE_3 VAR_5 , int VAR_6 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; } 
public String METHOD_1 ( final Object element ) { TYPE_1 item = ( TYPE_1 ) element ; <START> String VAR_1 = item . VAR_2 ( ) ; if ( VAR_1 == null || VAR_1 . trim ( ) . length ( ) == 0 ) { VAR_1 = item . VAR_3 ( ) . getName ( ) ; } <END> return VAR_1 ; } 
public boolean METHOD_1 ( ) { final boolean [ ] VAR_1 = { false } ; TYPE_1 . METHOD_2 ( new TYPE_2 ( ) { @Override public void run ( ) { if ( ! VAR_2 . METHOD_3 ( file . VAR_3 ( ) , false ) ) { TYPE_3 . VAR_5 . debug ( STRING_1 , STRING_2 + file ) ; <START> VAR_1 [ 0 ] = true ; <END> } } } ) ; return VAR_1 [ 0 ] ; } 
private void METHOD_1 ( File VAR_1 , String name , String content ) throws IOException { File file = new File ( VAR_1 , name ) ; <START> file . VAR_2 ( ) ; <END> TYPE_1 VAR_3 = null ; try { VAR_3 = new TYPE_1 ( file ) ; VAR_3 . write ( content . VAR_4 ( STRING_1 ) ) ; } finally { if ( VAR_3 != null ) VAR_3 . close ( ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_4 . METHOD_2 ( VAR_1 , STRING_1 ) ; TYPE_4 . METHOD_3 ( ( VAR_1 . METHOD_4 ( ) == org . VAR_2 . VAR_3 . VAR_4 . TYPE_5 . TYPE_2 . TYPE_6 . VAR_8 ) , STRING_2 ) ; METHOD_5 ( VAR_1 ) ; <START> return create ( VAR_1 , VAR_9 , TYPE_7 . VAR_11 ) ; <END> } 
public TYPE_5 ( TYPE_1 < T > VAR_2 , TYPE_2 < T > filter , List < TYPE_3 < T > > VAR_3 ) { this . VAR_2 = VAR_2 ; this . filter = filter ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = TYPE_4 . create ( ) ; <END> } 
public TYPE_1 add ( int VAR_1 , int VAR_2 , int VAR_3 , int VAR_4 , String offset , TYPE_2 VAR_5 ) { if ( METHOD_1 ( ) ) { <START> VAR_4 = 0 ; <END> } return add ( VAR_5 , VAR_1 , VAR_2 , VAR_3 , VAR_4 , offset , INT_1 , 1 , 1 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 < > ( Integer . VAR_2 , VAR_3 , <END> INT_1 , new TYPE_2 < > ( 0 , 100 , false , false ) ) ; VAR_4 = - 1 ; VAR_1 . METHOD_2 ( VAR_5 - > VAR_4 = ( int ) VAR_5 . METHOD_3 ( ) ) ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 . METHOD_2 ( ) . contains ( STRING_1 ) ) return ; METHOD_3 ( ) ; METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; METHOD_4 ( VAR_1 . METHOD_6 ( ) ) ; METHOD_4 ( VAR_1 . METHOD_7 ( ) ) ; METHOD_1 ( VAR_1 . METHOD_5 ( ) ) ; METHOD_1 ( VAR_1 . METHOD_6 ( ) ) ; METHOD_1 ( VAR_1 . METHOD_7 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , Class < ? > type , Type VAR_2 , TYPE_2 [ ] VAR_3 , TYPE_3 VAR_4 , TYPE_4 < String , Object > VAR_5 , TYPE_5 VAR_6 ) throws IOException , TYPE_6 { <START> VAR_6 . write ( VAR_1 . toString ( ) . METHOD_2 ( ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 context ) throws Exception { METHOD_2 ( ) ; VAR_1 = null ; super . METHOD_1 ( context ) ; VAR_2 = null ; <START> if ( VAR_3 != null ) { <END> TYPE_2 . METHOD_3 ( ) . METHOD_4 ( VAR_3 , TYPE_3 . class ) ; } } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> VAR_2 = VAR_1 ; <END> } 
public static TYPE_1 METHOD_1 ( byte [ ] VAR_1 ) throws TYPE_2 { final TYPE_3 obj = new TYPE_3 ( new String ( VAR_1 , TYPE_4 . VAR_3 ) ) ; <START> return new TYPE_1 ( obj . getString ( VAR_4 ) , obj . getString ( VAR_5 ) , ( int ) obj . VAR_6 ( VAR_7 ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( ! METHOD_2 ( ) ) { VAR_2 . VAR_3 . METHOD_3 ( ) ; throw new TYPE_2 ( STRING_1 , TYPE_5 . TYPE_4 ) ; } else { VAR_6 . add ( VAR_1 ) ; <START> TYPE_3 . METHOD_4 ( VAR_1 ) ; <END> } } 
private String METHOD_1 ( final TYPE_1 TYPE_1 ) { <START> final StringBuilder sb = new StringBuilder ( ) <END> . append ( TYPE_1 . METHOD_2 ( ) ) . append ( TYPE_1 . METHOD_3 ( ) ? STRING_1 : STRING_2 ) ; return sb . toString ( ) ; } 
<START> public void execute ( ) { <END> if ( ! VAR_1 ) { if ( VAR_2 ) VAR_3 . METHOD_1 ( ) ; return ; } VAR_3 . METHOD_2 ( 3 + ( VAR_2 ? 1 : 0 ) ) ; } 
public String getName ( ) { <START> return this . name ; <END> } 
public TYPE_2 ( ) { VAR_2 = TYPE_1 . VAR_4 ; <START> VAR_5 = false ; <END> } 
public void METHOD_1 ( ) throws IOException { if ( VAR_1 ) { VAR_2 . METHOD_2 ( IOException . VAR_3 ) ; VAR_2 . METHOD_3 ( STRING_1 ) ; <START> TYPE_1 . METHOD_4 ( VAR_2 ) ; <END> } TYPE_2 builder = METHOD_5 ( ) ; String [ ] args = builder . build ( ) ; METHOD_6 ( args ) ; if ( ! VAR_1 ) { METHOD_7 ( ) ; } } 
void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException , TYPE_3 , TYPE_4 { List < TYPE_5 > VAR_3 = METHOD_2 ( VAR_1 ) ; if ( ! VAR_3 . isEmpty ( ) ) { METHOD_3 ( VAR_3 , VAR_1 , VAR_2 ) ; } <START> VAR_1 . METHOD_4 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> METHOD_2 ( VAR_1 ) ; <END> } 
private boolean METHOD_1 ( ) { int VAR_1 = VAR_2 . size ( ) ; <START> return VAR_1 > 0 && VAR_1 >= Math . VAR_3 ( VAR_4 , this . VAR_5 ) ; <END> } 
public boolean METHOD_1 ( ) { <START> return -- VAR_1 >= 0 ; <END> } 
public String METHOD_1 ( int VAR_1 ) { <START> if ( VAR_1 >= TYPE_1 . VAR_3 && VAR_1 < VAR_4 . length ) { <END> String VAR_5 = VAR_4 [ VAR_1 ] ; if ( VAR_5 != null ) { return VAR_5 ; } } String VAR_6 = METHOD_2 ( VAR_1 ) ; if ( VAR_6 != null ) { return VAR_6 ; } String VAR_7 = METHOD_3 ( VAR_1 ) ; if ( VAR_7 != null ) { return VAR_7 ; } return Integer . toString ( VAR_1 ) ; } 
private boolean METHOD_1 ( ) { final TYPE_1 VAR_1 = <START> this . METHOD_2 ( ) ; <END> return ( VAR_1 != null && ( VAR_1 . METHOD_3 ( TYPE_1 . VAR_2 ) || VAR_1 . METHOD_3 ( TYPE_1 . VAR_3 ) ) ) ; } 
public Boolean METHOD_1 ( ) { <START> return ( VAR_1 != null ) ? VAR_1 : Boolean . VAR_2 ; <END> } 
private boolean METHOD_1 ( ) { if <START> ( VAR_1 . METHOD_2 ( ) == null || VAR_1 . METHOD_2 ( ) . equals ( "" ) ) { <END> METHOD_3 ( STRING_1 ) ; return false ; } if ( 0 == VAR_2 . METHOD_4 ( ) . length ) { METHOD_3 ( STRING_2 ) ; return false ; } if ( ! METHOD_5 ( ) ) { METHOD_3 ( STRING_3 ) ; return false ; } METHOD_3 ( null ) ; return true ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 connection = TYPE_3 . getInstance ( ) . METHOD_2 ( ) . get ( VAR_1 . METHOD_3 ( ) ) ; <START> <END> if ( connection != null ) TYPE_3 . getInstance ( ) . METHOD_2 ( ) . remove ( connection . VAR_2 ( ) ) ; return true ; } 
public void METHOD_1 ( ) throws IOException { writer = TYPE_1 . METHOD_2 ( VAR_1 , <START> String . format ( STRING_1 , VAR_2 ) , <END> VAR_3 , VAR_4 ) ; writer . VAR_5 ( ) ; } 
public TYPE_5 ( Map conf , List < String > VAR_2 , TYPE_1 VAR_3 , String VAR_4 , String id , TYPE_2 < TYPE_3 > VAR_5 , TYPE_2 < TYPE_4 > VAR_6 ) { this . conf = conf ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_5 ; this . id = id ; <START> this . VAR_5 = VAR_5 ; <END> this . VAR_6 = VAR_6 ; } 
<START> protected Class < ? > METHOD_1 ( TYPE_1 < ? > configuration , TYPE_2 VAR_1 ) { <END> String VAR_2 = configuration . VAR_3 ( ) ; TYPE_3 VAR_4 = VAR_1 . METHOD_2 ( ) ; try { return org . VAR_5 . VAR_6 . TYPE_6 . METHOD_3 ( VAR_2 , VAR_4 ) ; } catch ( TYPE_4 | TYPE_5 e ) { LOGGER . warn ( String . format ( VAR_8 , METHOD_4 ( ) , VAR_2 , VAR_4 ) , e ) ; } return null ; } 
protected void METHOD_1 ( ) { Assert . state ( this . VAR_1 != null || StringUtils . VAR_2 ( this . VAR_3 ) , <START> STRING_1 ) ; <END> } 
protected TYPE_1 METHOD_1 ( boolean VAR_1 ) { TYPE_1 VAR_2 = session . VAR_3 ( STRING_1 , STRING_2 , STRING_3 ) ; if ( VAR_1 ) { VAR_2 . METHOD_2 ( VAR_4 , ( TYPE_2 ) TYPE_3 . METHOD_3 ( VAR_5 ) ) ; } <START> VAR_2 = session . VAR_6 ( VAR_2 ) ; return VAR_2 ; <END> } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , int VAR_3 , Object VAR_4 ) { <START> if ( VAR_4 == null && ! TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) . get ( VAR_3 ) . METHOD_4 ( TYPE_3 . class ) ) <END> throw new TYPE_4 ( format ( STRING_1 , VAR_2 , VAR_1 . METHOD_3 ( ) . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) , VAR_1 . METHOD_3 ( ) . getName ( ) ) ) ; return true ; } 
<START> public void METHOD_1 ( ) { <END> METHOD_2 ( ) . METHOD_3 ( new TYPE_2 . TYPE_3 ( VAR_1 ) ) ; if ( METHOD_4 ( ) . METHOD_5 ( ) ) { METHOD_4 ( ) . METHOD_6 ( ) ; METHOD_4 ( ) . METHOD_7 ( ) ; } VAR_2 . METHOD_8 ( ) ; synchronized ( VAR_3 ) { VAR_3 . clear ( ) ; VAR_2 . METHOD_9 ( ) ; } VAR_2 . METHOD_10 ( ) ; VAR_2 . METHOD_11 ( true ) ; } 
<START> protected org . VAR_1 . VAR_2 . TYPE_4 METHOD_1 ( ) { <END> return super . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) . METHOD_3 ( TYPE_2 . class ) . METHOD_3 ( TYPE_3 . class ) . build ( ) ; } 
public static String METHOD_1 ( TYPE_1 value ) { return value . VAR_1 ( ) . name ( ) + STRING_1 + value . VAR_2 ( ) ; <START> } <END> 
private static void METHOD_1 ( File to ) throws IOException { <START> boolean VAR_1 = to . exists ( ) ; <END> if ( VAR_1 ) { return ; } boolean VAR_2 = to . VAR_3 ( ) ; if ( VAR_2 ) { return ; } throw new IOException ( STRING_1 + to . VAR_4 ( ) ) ; } 
public Map . Entry < TYPE_1 , Collection < TYPE_2 > > next ( ) { final Map . Entry < TYPE_1 , Collection < TYPE_2 > > entry = super . next ( ) ; final TYPE_1 key = entry . getKey ( ) ; final Collection < TYPE_2 > value = entry . getValue ( ) ; <START> return new TYPE_3 < > ( key , value ) ; <END> } 
public void METHOD_1 ( TYPE_1 call ) throws Exception { TYPE_2 VAR_1 = METHOD_2 ( METHOD_3 ( ) ) ; <START> VAR_1 . METHOD_4 ( call ) ; <END> } 
public void METHOD_1 ( ByteBuffer buf , int position ) { final int VAR_1 = buf . position ( ) ; buf . position ( position ) ; METHOD_2 ( buf ) ; <START> buf . position ( VAR_1 ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { <START> if ( VAR_1 != null ) <END> return VAR_1 . METHOD_1 ( ) ; else return null ; } 
private boolean METHOD_1 ( String VAR_1 ) { <START> return VAR_1 . startsWith ( TYPE_1 . METHOD_2 ( ) ) && VAR_1 . METHOD_3 ( TYPE_1 . METHOD_4 ( ) ) ; <END> } 
public String toString ( ) { return TYPE_1 . METHOD_1 ( this ) . METHOD_2 ( ) . add ( STRING_1 , VAR_1 . getName ( ) ) <START> . add ( STRING_2 , VAR_2 . getName ( ) ) <END> . add ( STRING_3 , path ) . toString ( ) ; } 
public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; assertNotNull ( VAR_1 ) ; TYPE_1 VAR_2 = TYPE_2 . METHOD_4 ( VAR_1 , new TYPE_3 < TYPE_1 > ( ) { @Override public boolean apply ( TYPE_1 input ) { return input . VAR_3 ( ) . contains ( STRING_1 ) ; } <START> } ) ; <END> assertNotNull ( VAR_2 ) ; } 
private static void METHOD_1 ( ) { <START> client . VAR_1 ( TYPE_1 . VAR_3 , false ) ; <END> } 
private int METHOD_1 ( final String VAR_1 ) throws TYPE_1 , InterruptedException { <START> try ( TYPE_2 VAR_2 = METHOD_2 ( ) ) { <END> final TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( Collections . VAR_4 ( VAR_1 ) ) . values ( ) . get ( VAR_1 ) . get ( ) ; return VAR_3 . METHOD_4 ( ) . size ( ) ; } } 
public List < String > METHOD_1 ( String name ) { TYPE_1 < String , String > VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> System . out . println ( VAR_1 . get ( name ) ) ; <END> return VAR_1 . get ( name ) ; } 
public boolean METHOD_1 ( String id ) { <START> synchronized ( VAR_1 ) <END> { return METHOD_1 ( id , null ) ; } } 
public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final Collection < TYPE_4 > VAR_3 , final TYPE_5 VAR_4 , final TYPE_6 request ) { VAR_5 . log ( STRING_1 , new TYPE_7 ( VAR_3 ) ) ; <START> final TYPE_8 VAR_6 = VAR_7 . METHOD_2 ( new TYPE_9 ( VAR_2 , VAR_4 , VAR_3 ) , VAR_1 ) ; <END> return METHOD_1 ( request , VAR_1 , VAR_3 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 key , TYPE_3 < ? super TYPE_2 , ? super TYPE_1 , ? extends TYPE_1 > VAR_1 , boolean VAR_2 , TYPE_4 metadata , long VAR_3 ) { METHOD_2 ( key ) ; METHOD_3 ( VAR_1 ) ; TYPE_5 ctx = METHOD_4 ( false , 1 ) ; TYPE_6 command = VAR_4 . METHOD_5 ( key , VAR_1 , VAR_2 , metadata , VAR_3 ) ; <START> ctx . VAR_5 ( command . VAR_6 ( ) ) ; <END> return ( TYPE_1 ) METHOD_6 ( ctx , command ) ; } 
protected void METHOD_1 ( List < Object > VAR_1 ) { <START> log ( STRING_1 ) ; <END> if ( TYPE_1 . getInstance ( ) . METHOD_2 ( ) ) { TYPE_2 VAR_2 = Context . VAR_3 ( TYPE_2 . class ) ; for ( Object VAR_4 : VAR_1 ) { if ( VAR_4 instanceof TYPE_3 ) { VAR_2 . METHOD_3 ( ( TYPE_3 ) VAR_4 ) ; } } } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> for ( TYPE_1 VAR_2 : VAR_3 ) { <END> if ( VAR_2 . getId ( ) . equals ( VAR_1 . getId ( ) ) ) { return VAR_2 ; } } return null ; } 
public Iterator < TYPE_1 < TYPE_2 > > iterator ( ) { <START> return TYPE_3 . iterator ( new TYPE_1 < TYPE_2 > ( ) <END> { @Override public TYPE_4 < TYPE_2 > create ( TYPE_5 config ) { return new TYPE_4 < TYPE_2 > ( ) { @Override public TYPE_6 stream ( ) { return VAR_1 = factory . apply ( config ) ; } @Override public TYPE_7 < TYPE_2 > METHOD_1 ( ) { return VAR_2 ; } } ; } } ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 session = TYPE_3 . METHOD_2 ( ) ; long VAR_2 = ( long ) TYPE_4 . METHOD_3 ( VAR_1 . toString ( ) ) ; TYPE_5 VAR_3 = VAR_4 . bind ( VAR_2 , VAR_1 . toString ( ) , "" ) ; TYPE_6 . Context VAR_5 = TYPE_7 . METHOD_4 ( TYPE_8 . VAR_7 ) ; try { <START> session . execute ( VAR_3 ) ; <END> } finally { VAR_5 . METHOD_5 ( ) ; } } 
private Set < Type > METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 , TYPE_2 VAR_2 ) { return VAR_1 . METHOD_2 ( ) . stream ( ) <START> . map ( VAR_3 - > METHOD_3 ( VAR_3 , VAR_2 ) ) <END> . METHOD_4 ( VAR_4 - > METHOD_5 ( VAR_4 ) . stream ( ) ) . collect ( Collectors . VAR_5 ( ) ) ; } 
<START> public void METHOD_1 ( ) { <END> METHOD_2 ( TYPE_1 . VAR_1 . VAR_2 ) ; METHOD_3 ( VAR_3 ) ; VAR_3 . METHOD_4 ( ) ; TYPE_2 . log ( STRING_1 , STRING_2 , true ) ; } 
<START> protected StringUtils ( ) { <END> } 
public int METHOD_1 ( ) throws Exception { TYPE_1 < ? > VAR_1 = VAR_2 . METHOD_2 ( ) ; int VAR_3 = VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; long VAR_4 = Math . VAR_5 ( VAR_3 , VAR_2 . METHOD_5 ( ) ) ; <START> int VAR_6 = 0 ; <END> if ( VAR_4 > 0 ) { VAR_6 = METHOD_6 ( VAR_1 , VAR_4 ) ; } VAR_2 . METHOD_7 ( VAR_6 ) ; return VAR_6 ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 ; <END> try { VAR_1 = VAR_2 . METHOD_2 ( ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { METHOD_3 ( VAR_3 ) ; } } catch ( TYPE_2 e ) { throw new RuntimeException ( STRING_1 , e ) ; } return VAR_1 ; } 
public static Object METHOD_1 ( Object VAR_1 ) { Object VAR_2 = VAR_1 ; if ( VAR_1 instanceof byte [ ] ) { VAR_2 = TYPE_1 . METHOD_2 ( ( byte [ ] ) VAR_1 ) ; <START> } else if ( VAR_1 instanceof ArrayList ) { ArrayList VAR_3 = ( ArrayList ) VAR_1 ; ArrayList VAR_4 = new ArrayList ( VAR_3 . size ( ) ) ; for ( Object VAR_5 : VAR_3 ) { VAR_4 . add ( METHOD_1 ( VAR_5 ) ) ; } <END> VAR_2 = VAR_4 ; } return VAR_2 ; } 
public TYPE_3 ( TYPE_1 factory , String VAR_2 ) { VAR_3 = new TYPE_2 ( factory ) ; this . VAR_2 = ( StringUtils . VAR_4 ( VAR_2 ) ) ? VAR_2 : VAR_5 ; <START> } <END> 
private void METHOD_1 ( long VAR_1 , long VAR_2 ) { <START> VAR_3 . METHOD_2 ( ( ) - > METHOD_3 ( ) , <END> VAR_2 , VAR_1 , TimeUnit . VAR_4 ) ; } 
public void METHOD_1 ( TYPE_1 < T > VAR_1 ) { <START> TYPE_2 < T > VAR_2 = this . VAR_3 ; <END> synchronized ( this ) { VAR_3 = new TYPE_3 < > ( VAR_1 ) ; VAR_2 . METHOD_1 ( VAR_1 ) ; } } 
<START> public void METHOD_1 ( TYPE_1 id ) { <END> TYPE_2 VAR_1 = VAR_2 . get ( id ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( id ) ; } } 
public Class < ? > METHOD_1 ( TYPE_1 < ? > VAR_1 ) throws TYPE_2 { try { return METHOD_2 ( VAR_1 ) ; } catch ( TYPE_3 | TYPE_4 e ) { throw new TYPE_2 ( e ) ; } catch ( IOException e ) { throw new TYPE_2 ( e ) ; <START> } <END> } 
public TYPE_3 ( TYPE_1 VAR_2 , List < TYPE_2 > VAR_3 , float VAR_4 , int VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; int VAR_6 = 0 ; for ( TYPE_2 VAR_7 : VAR_3 ) VAR_6 += VAR_7 . METHOD_1 ( ) ; this . VAR_8 = VAR_6 ; <START> this . VAR_9 = INT_1 ; <END> } 
private byte [ ] METHOD_1 ( TYPE_1 response ) throws TYPE_2 { TYPE_3 VAR_1 = new TYPE_3 ( ) ; <START> if ( response . VAR_2 ( ) != null && response . VAR_2 ( ) . METHOD_2 ( ) != null ) { <END> METHOD_3 ( ) . METHOD_4 ( response . VAR_2 ( ) . METHOD_2 ( ) , VAR_1 ) ; } return VAR_1 . METHOD_5 ( ) ; } 
public List < TYPE_1 > METHOD_1 ( final TYPE_2 type , final Collection < TYPE_3 > VAR_1 ) { final List < TYPE_1 > result = new ArrayList < > ( VAR_1 . size ( ) ) ; for ( final TYPE_3 VAR_2 : VAR_1 ) { try { result . add ( METHOD_2 ( type , VAR_2 ) ) ; } catch ( TYPE_4 VAR_3 ) { <START> LOGGER . debug ( STRING_1 , VAR_3 . getMessage ( ) , VAR_3 . getClass ( ) . getName ( ) ) ; <END> } } return result ; } 
public void METHOD_1 ( ) { byte [ ] content = VAR_1 . METHOD_2 ( VAR_2 ) ; <START> ArrayList < TYPE_1 > VAR_3 = ( ArrayList < TYPE_1 > ) VAR_1 . METHOD_3 ( content ) ; <END> METHOD_4 ( content . length , 0 ) ; assertEquals ( VAR_4 , VAR_3 . size ( ) ) ; } 
<START> public static long METHOD_1 ( final long VAR_1 ) { <END> long VAR_2 = VAR_1 - 1 ; return ( VAR_2 / 4 ) - ( VAR_2 / 100 ) + ( VAR_2 / INT_1 ) ; } 
public void time ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; <START> VAR_1 . time ( ( TYPE_2 < TYPE_3 > ) ( ) - > { <END> VAR_2 . METHOD_1 ( 10 , TimeUnit . VAR_3 ) ; return null ; } ) ; TYPE_4 VAR_4 = VAR_1 . METHOD_2 ( ) ; assertEquals ( VAR_4 . METHOD_3 ( ) , FLOAT_1 ) ; assertEquals ( VAR_4 . METHOD_4 ( ) , FLOAT_2 ) ; assertEquals ( VAR_4 . METHOD_5 ( ) , FLOAT_2 ) ; } 
public boolean METHOD_1 ( ) throws TYPE_1 { return parse . VAR_1 ( VAR_2 , STRING_1 ) ; <START> } <END> 
public static Logger METHOD_1 ( Class < ? > key ) { <START> return TYPE_1 . METHOD_2 ( key . getName ( ) , name - > new TYPE_2 ( TYPE_3 . METHOD_1 ( key ) ) ) ; <END> } 
public boolean METHOD_1 ( List < String > VAR_1 , int VAR_2 , int VAR_3 , TYPE_1 VAR_4 ) { if ( ! METHOD_2 ( VAR_1 , VAR_2 , VAR_4 ) ) { return false ; } <START> else if ( ! METHOD_3 ( VAR_3 , VAR_1 ) ) { return false ; } return true ; <END> } 
public boolean METHOD_1 ( TYPE_1 state , String [ ] params ) { <START> if ( ( this . VAR_1 != null && ! this . VAR_1 . equals ( "" ) ) && ! this . VAR_1 . equals ( params [ 1 ] ) ) { <END> return false ; } TYPE_2 VAR_2 = state . VAR_3 ( params [ 1 ] ) ; return TYPE_3 . METHOD_2 ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; TYPE_4 parameters = VAR_1 . parameters ( ) ; <START> if ( VAR_2 != null && VAR_2 . is ( TYPE_6 . TYPE_7 . VAR_5 ) && parameters != null ) { <END> TYPE_5 VAR_6 = ( TYPE_5 ) VAR_2 ; VAR_6 . METHOD_3 ( parameters ) ; } super . METHOD_1 ( VAR_1 ) ; } 
<START> public TYPE_1 < TYPE_2 > <END> METHOD_1 ( ) { return VAR_1 ; } 
public static TYPE_1 parse ( String VAR_1 ) { int n = 0 ; for ( TYPE_2 VAR_2 : VAR_3 ) { try { return METHOD_1 ( VAR_2 . parse ( VAR_1 ) ) ; } catch ( TYPE_3 VAR_4 ) { <START> n ++ ; <END> continue ; } } if ( TYPE_4 . matcher ( VAR_1 ) . METHOD_2 ( ) ) { long VAR_5 = Long . VAR_6 ( VAR_1 ) ; return TYPE_5 . METHOD_3 ( VAR_5 ) . METHOD_4 ( VAR_7 ) ; } return null ; } 
public Optional < TYPE_1 > METHOD_1 ( ) { TYPE_1 VAR_1 = null ; if ( VAR_2 instanceof TYPE_2 ) { VAR_1 = new TYPE_3 ( ( TYPE_2 ) VAR_2 ) . METHOD_2 ( ) . get ( ) ; } else if ( VAR_2 instanceof TYPE_4 ) { VAR_1 = ( ( TYPE_4 ) VAR_2 ) . METHOD_2 ( ) ; } else if ( VAR_2 instanceof TYPE_5 ) { VAR_1 = <START> ( ( TYPE_4 ) VAR_2 ) . METHOD_2 ( ) ; <END> } return Optional . VAR_3 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( VAR_2 ) . METHOD_3 ( TYPE_3 . class ) ; VAR_1 . METHOD_4 ( ) ; <START> TYPE_2 . METHOD_2 ( VAR_2 ) . METHOD_5 ( ) ; <END> } 
public void METHOD_1 ( ) { try { TYPE_1 . METHOD_2 ( null , VAR_1 [ 0 ] ) ; } catch ( TYPE_2 e ) { <START> METHOD_3 ( STRING_1 ) ; <END> } } 
private boolean METHOD_1 ( List < String > values ) { if ( values == null ) return true ; <START> if ( values . isEmpty ( ) ) return true ; <END> for ( String VAR_1 : values ) { if ( StringUtils . VAR_2 ( VAR_1 ) ) return true ; } return false ; } 
<START> public static < T > TYPE_1 < T > METHOD_1 ( ANNOTATION_1 Optional < T > VAR_1 ) { <END> TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; return VAR_1 . map ( TYPE_1 : : METHOD_3 ) . METHOD_4 ( TYPE_1 : : empty ) ; } 
private static Map < TYPE_1 , TYPE_2 > METHOD_1 ( TYPE_3 < ? , ? > run ) { <START> TYPE_4 < ? , ? > build = null ; <END> if ( run instanceof TYPE_4 ) return ( ( TYPE_4 ) run ) . METHOD_1 ( ( TYPE_4 ) run ) ; else return TYPE_5 . METHOD_2 ( ) ; } 
public void METHOD_1 ( TYPE_1 < TYPE_2 < ? extends TYPE_3 , ? extends TYPE_4 > > VAR_1 ) throws TYPE_5 { <START> for ( Object VAR_2 : VAR_1 ) { <END> TYPE_2 event = ( TYPE_2 ) VAR_2 ; Assert . assertEquals ( TYPE_6 . VAR_4 , event . VAR_5 ( ) ) ; this . VAR_6 . METHOD_2 ( ) ; event . getKey ( ) ; if ( event . VAR_7 ( ) ) { event . VAR_8 ( ) ; } } } 
TYPE_4 ( String name , TYPE_1 type , TYPE_2 VAR_2 ) { <START> this . VAR_3 = new TYPE_3 ( name , type , true ) <END> . METHOD_1 ( VAR_2 ) . METHOD_2 ( TYPE_5 . VAR_5 ) . build ( ) ; } 
TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { if ( VAR_1 != null ) { <START> return new TYPE_4 < > ( Collections . VAR_2 ( new TYPE_2 ( ) ) , VAR_1 , 1 ) ; <END> } return new TYPE_4 < > ( Collections . VAR_3 ( ) , VAR_1 , 0 ) ; } 
public String METHOD_1 ( ) { String VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; <START> return VAR_1 ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; <START> VAR_1 . METHOD_4 ( STRING_2 ) ; <END> VAR_1 . METHOD_5 ( Integer . VAR_4 . getName ( ) ) ; VAR_1 . METHOD_6 ( STRING_3 ) ; return VAR_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_1 parent ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( parent . getId ( ) ) ; <START> VAR_1 . METHOD_3 ( new TYPE_2 ( ) ) ; <END> if ( parent . VAR_2 ( ) ) { VAR_1 . METHOD_4 ( ) . METHOD_2 ( parent . VAR_3 ( ) . getId ( ) ) ; } return VAR_1 ; } 
public boolean METHOD_1 ( ) { final boolean VAR_1 = <START> VAR_2 . size ( ) <END> > 0 ; return VAR_1 ; } 
public static String METHOD_1 ( String [ ] VAR_1 ) { StringBuilder sb = new StringBuilder ( ) ; boolean VAR_2 = true ; for ( String s : VAR_1 ) { if ( VAR_2 ) { VAR_2 = false ; } else { sb . append ( CHAR_1 ) ; } sb . append ( s ) ; } <START> return sb . toString ( ) ; <END> } 
<START> public synchronized void METHOD_1 ( ) { <END> VAR_1 = true ; VAR_2 = TYPE_1 . METHOD_2 ( VAR_2 ) ; } 
private String METHOD_1 ( String VAR_1 ) throws TYPE_1 { String VAR_2 = null ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_2 ( VAR_4 ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; List < Map < String , String > > result = VAR_3 . METHOD_4 ( ) ; if ( ! result . isEmpty ( ) ) { <START> VAR_2 = result . get ( 0 ) . get ( STRING_1 ) . toString ( ) ; <END> } return VAR_2 ; } 
<START> public void METHOD_1 ( ) { <END> synchronized ( VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { VAR_2 . METHOD_2 ( ) ; } VAR_1 . clear ( ) ; } METHOD_3 ( ) ; } 
public boolean commit ( ) { if ( VAR_1 != null ) { METHOD_1 ( ) ; throw new IllegalStateException ( TYPE_1 . format ( TYPE_2 . get ( ) . VAR_2 , VAR_3 ) ) ; } METHOD_2 ( ) ; try { TYPE_3 . METHOD_3 ( VAR_4 , VAR_3 , TYPE_4 . VAR_6 ) ; VAR_7 = false ; <START> token . close ( ) ; <END> return true ; } catch ( IOException e ) { METHOD_1 ( ) ; return false ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( STRING_1 ) ; VAR_2 . METHOD_2 ( STRING_2 ) ; <START> VAR_2 . METHOD_2 ( STRING_3 ) ; <END> VAR_2 . METHOD_3 ( STRING_4 , STRING_5 + TYPE_3 . VAR_4 ) ; VAR_2 . METHOD_4 ( ) ; return VAR_2 ; } 
public TYPE_3 . TYPE_4 . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_5 METHOD_1 ( <START> TYPE_3 . TYPE_4 . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_6 VAR_7 ) { <END> LOG . info ( STRING_1 ) ; TYPE_2 VAR_8 = new TYPE_2 ( ) ; return VAR_8 . METHOD_1 ( VAR_7 ) ; } 
<START> void remove ( TYPE_1 VAR_1 ) { <END> if ( VAR_2 != null ) { VAR_2 . remove ( VAR_1 ) ; } } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> if <END> ( VAR_1 . METHOD_2 ( VAR_3 ) <= 0 && VAR_2 . METHOD_2 ( VAR_4 ) >= 0 ) { return true ; } return false ; } 
public void VAR_1 ( ) { <START> VAR_2 ( STRING_1 , STRING_2 ) <END> } 
ANNOTATION_1 public void METHOD_1 ( ) { assertThat ( METHOD_2 ( TYPE_1 . class ) , METHOD_3 ( 2 ) ) ; <START> assertThat ( TYPE_2 . VAR_2 , METHOD_4 ( 0 ) ) ; <END> } 
private void METHOD_1 ( final long VAR_1 , final Status status ) throws InterruptedException , TYPE_1 { TYPE_2 . METHOD_2 ( STRING_1 , ( ) - > { try { return VAR_2 . getStatus ( VAR_1 ) . getStatus ( ) == status ; } catch ( Exception e ) { TYPE_3 . METHOD_3 ( e ) ; } return null ; <START> } , TYPE_4 . METHOD_4 ( ) . METHOD_5 ( 10 ) . METHOD_6 ( 10 * Constants . VAR_3 ) ) ; <END> } 
public TYPE_1 < TYPE_2 > message ( String text ) { <START> return new TYPE_3 ( args . VAR_1 , args . VAR_2 , args . index , text ) ; <END> } 
public <START> boolean METHOD_1 ( boolean <END> VAR_1 ) { return this . VAR_1 = VAR_1 ; } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_4 . TYPE_5 VAR_3 , long VAR_4 ) { if ( VAR_2 . METHOD_2 ( STRING_1 , STRING_2 ) ) VAR_5 . METHOD_3 ( false , VAR_1 , TYPE_6 . VAR_7 ) ; if ( VAR_2 . METHOD_2 ( STRING_3 , STRING_2 ) ) <START> VAR_5 . METHOD_3 ( false , VAR_1 , TYPE_6 . VAR_8 ) ; <END> return VAR_1 ; } 
<START> @Override public boolean METHOD_1 ( ) <END> { return false ; } 
byte [ ] METHOD_1 ( int val ) { byte [ ] b = new byte [ 4 ] ; b [ 3 ] = ( byte ) ( val ) ; b [ 2 ] = ( byte ) ( val > > > INT_1 ) ; b [ 1 ] = ( byte ) ( val > > > INT_2 ) ; b [ 0 ] = ( byte ) ( val > > > INT_3 ) ; <START> return b ; <END> } 
<START> protected int <END> METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 text ) { int VAR_4 = VAR_3 . METHOD_2 ( ) ; if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { TYPE_4 VAR_5 = new TYPE_4 ( VAR_6 , VAR_7 ) ; String VAR_8 = VAR_5 . get ( VAR_2 , VAR_1 , String . VAR_9 ) ; VAR_4 = METHOD_1 ( VAR_8 , VAR_4 , text ) ; } return VAR_4 ; } 
private static TYPE_1 METHOD_1 ( Class < ? extends TYPE_1 > VAR_1 ) { TYPE_1 VAR_2 ; try { <START> VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> } catch ( TYPE_2 e ) { throw new IllegalStateException ( STRING_1 + VAR_1 + STRING_2 , e ) ; } return VAR_2 ; } 
<START> private VAR_1 ( String VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
public TYPE_1 append ( final boolean VAR_1 , final boolean VAR_2 ) { if ( VAR_3 != 0 ) { return this ; } if ( VAR_1 == VAR_2 ) { return this ; } if ( VAR_1 ) { <START> VAR_3 = + 1 ; <END> } else { VAR_3 = - 1 ; } return this ; } 
<START> private TYPE_1 METHOD_1 ( TYPE_1 node ) { <END> TYPE_1 VAR_1 = ( TYPE_1 ) node . VAR_2 ( this ) ; while ( ! node . equals ( VAR_1 ) ) { node = VAR_1 ; VAR_1 = ( TYPE_1 ) node . VAR_2 ( this ) ; } return node ; } 
public TYPE_3 ( int VAR_2 ) { try { <START> TYPE_1 s = TYPE_1 . METHOD_1 ( VAR_2 ) ; <END> value = VAR_2 ; VAR_3 = true ; } catch ( IllegalArgumentException e ) { try { TYPE_2 c = TYPE_2 . METHOD_1 ( VAR_2 ) ; value = VAR_2 ; VAR_3 = false ; } catch ( IllegalArgumentException y ) { throw new IllegalArgumentException ( STRING_1 ) ; } } } 
private boolean METHOD_1 ( TYPE_1 instance ) { for ( String type : this . VAR_1 . keySet ( ) ) { if ( METHOD_2 ( instance . VAR_2 ( ) , type ) ) { for ( TYPE_2 VAR_3 : this . VAR_1 . get ( type ) ) { if ( VAR_3 . METHOD_3 ( instance ) ) return true ; } return false ; } } <START> return true ; <END> } 
<START> public void synchronized VAR_1 ( TYPE_1 ctx ) { <END> VAR_3 ( ctx ) ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 row = METHOD_2 ( STRING_1 ) ; Optional < TYPE_2 > VAR_1 = VAR_2 . METHOD_3 ( row ) ; <START> assertTrue ( VAR_1 . isPresent ( ) ) ; <END> TYPE_2 content = VAR_1 . get ( ) ; TYPE_3 VAR_3 = ( TYPE_3 ) content ; METHOD_4 ( VAR_3 . METHOD_5 ( ) ) ; } 
public TYPE_1 list ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; Set < TYPE_2 > VAR_2 = TYPE_3 . METHOD_1 ( this , version ) ; VAR_2 . forEach ( VAR_3 - > { org . VAR_4 . VAR_5 . VAR_6 . model . TYPE_5 VAR_8 = <START> METHOD_2 ( TYPE_4 . map ( VAR_3 , <END> null ) ) ; VAR_1 . METHOD_1 ( ) . add ( VAR_8 ) ; } ) ; return VAR_1 ; } 
public TYPE_1 METHOD_1 ( Optional < TYPE_2 > VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 . METHOD_3 ( ) ) { <START> session . VAR_3 ( ) . log ( ( ) - > STRING_1 ) ; <END> VAR_2 . METHOD_4 ( session . VAR_3 ( ) . METHOD_5 ( ) ) ; VAR_4 . METHOD_6 ( Optional . empty ( ) , Optional . of ( VAR_2 ) ) ; } return VAR_2 ; } 
public Object execute ( TYPE_1 event ) { TYPE_2 VAR_1 = new TYPE_2 ( TYPE_3 . METHOD_1 ( ) . METHOD_2 ( ) , Messages . TYPE_6 , Messages . TYPE_7 , "" , new TYPE_4 ( ) { @Override public String METHOD_3 ( String VAR_4 ) { <START> if ( "" . equals ( VAR_4 ) ) { <END> return Messages . TYPE_8 ; } return null ; } } ) ; if ( VAR_1 . METHOD_4 ( ) == TYPE_5 . VAR_7 ) { METHOD_5 ( VAR_1 . getValue ( ) ) ; } return null ; } 
public void METHOD_1 ( TYPE_1 < T > VAR_1 ) { for ( TYPE_1 < T > VAR_2 : VAR_3 ) { if ( VAR_2 != VAR_1 ) { VAR_2 . METHOD_2 ( ) ; } <START> VAR_3 . clear ( ) ; <END> } } 
protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; TYPE_3 VAR_3 = VAR_1 . METHOD_3 ( ) ; File VAR_4 = VAR_1 . METHOD_4 ( ) ; <START> if ( VAR_1 . METHOD_5 ( ) ) { <END> return new TYPE_4 ( new TYPE_5 ( new TYPE_6 ( VAR_2 . getName ( ) , VAR_4 , VAR_3 ) ) , METHOD_6 ( ) ) ; } else { return new TYPE_6 ( VAR_2 . getName ( ) , VAR_4 , VAR_3 , METHOD_6 ( ) ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_2 ( ) ; TYPE_2 status = VAR_3 . METHOD_3 ( VAR_1 ) ; <START> String VAR_4 = VAR_5 . METHOD_4 ( ) ; <END> if ( VAR_5 != null && VAR_5 . VAR_6 != null ) { TYPE_3 . start ( VAR_7 , status . VAR_8 ( ) , VAR_4 ) ; } else { TYPE_3 . start ( VAR_7 , status . VAR_8 ( ) ) ; } } 
public TYPE_2 ( TYPE_1 factory ) { <START> VAR_2 = factory ; <END> VAR_3 = null ; VAR_4 = false ; VAR_5 = false ; VAR_6 = 1 ; } 
public int METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , int VAR_3 , int VAR_4 ) { double VAR_5 = VAR_2 . METHOD_2 ( ) / VAR_1 . METHOD_2 ( ) ; <START> final int i = ( int ) ( Math . log ( VAR_5 ) / Math . log ( Math . VAR_6 ( 2 , VAR_3 ) ) ) + VAR_7 ; <END> return i ; } 
public TYPE_2 ( List < TYPE_1 > VAR_2 ) { <START> Collections . VAR_3 ( VAR_2 , VAR_4 ) ; <END> } 
public void METHOD_1 ( ) { <START> if ( VAR_1 . get ( 0 ) . METHOD_2 ( ) != null ) { <END> VAR_1 . add ( 0 , new TYPE_1 ( ) ) ; } } 
public static boolean METHOD_1 ( List < String > VAR_1 ) { <START> return VAR_1 . stream ( ) . METHOD_2 ( new HashSet < > ( ) : : add ) ; <END> } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( ) . METHOD_2 ( ) ; <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; <END> } 
protected final List < ? > METHOD_1 ( ) { <START> if ( VAR_1 == TYPE_2 . VAR_3 ) { <END> return VAR_4 ; } if ( VAR_1 == TYPE_2 . VAR_5 ) { return TYPE_1 . METHOD_2 ( 0 , VAR_6 ) . METHOD_3 ( i - > i % 2 == 0 ? METHOD_4 ( ) : null ) . collect ( METHOD_5 ( ) ) ; } return TYPE_1 . METHOD_2 ( 0 , VAR_6 ) . METHOD_3 ( i - > METHOD_4 ( ) ) . collect ( METHOD_5 ( ) ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; TYPE_2 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 == null ) { return ; } TYPE_2 VAR_3 = ( VAR_1 == null ) ? new ArrayList ( ) : new TYPE_3 ( VAR_1 ) ; for ( Object item : VAR_2 ) { <START> METHOD_3 ( VAR_3 ) ; <END> } } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> if ( VAR_1 . size ( ) > 0 ) { <END> for ( TYPE_1 VAR_2 : VAR_1 ) { TYPE_2 VAR_3 = VAR_2 . METHOD_2 ( ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_3 ( ) ; } VAR_2 . close ( ) ; } VAR_1 . clear ( ) ; } } 
private T METHOD_1 ( ) { <START> if ( VAR_1 . size ( ) == 1 ) { <END> return VAR_1 . iterator ( ) . next ( ) ; } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { if ( metadata == null ) { <START> metadata = new TYPE_1 ( ) ; <END> } return metadata ; } 
public void METHOD_1 ( long VAR_1 , long VAR_2 ) { <START> long VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; <END> long VAR_5 = VAR_6 . METHOD_2 ( VAR_2 ) ; VAR_7 . METHOD_3 ( VAR_8 - > Math . max ( VAR_3 , VAR_8 ) ) ; VAR_9 . METHOD_3 ( VAR_8 - > Math . max ( VAR_5 , VAR_8 ) ) ; } 
public final Date METHOD_1 ( ) { <START> return this . VAR_1 ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 , Path VAR_3 , String VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_5 = null ; <END> this . VAR_6 = null ; this . VAR_7 = true ; this . VAR_4 = VAR_4 ; } 
public boolean METHOD_1 ( ) { if ( session . VAR_1 ( VAR_2 ) ) { return true ; } else { <START> return group != null && session . VAR_3 ( VAR_4 ) ; <END> } } 
public String METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { VAR_1 . METHOD_2 ( STRING_1 , STRING_1 ) ; <START> VAR_1 . METHOD_2 ( STRING_2 , STRING_2 ) ; <END> return VAR_2 ? STRING_3 : STRING_4 ; } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <START> List < TYPE_1 > result = VAR_3 . METHOD_2 ( ) <END> . METHOD_3 ( TYPE_1 . class ) . add ( TYPE_4 . METHOD_4 ( STRING_1 , VAR_1 ) ) . add ( TYPE_4 . METHOD_4 ( STRING_2 , VAR_2 ) ) . list ( ) ; return result == null ? new ArrayList < TYPE_1 > ( ) : result ; } 
public static Boolean METHOD_1 ( TYPE_1 ctx , List VAR_1 , Object target ) { for ( Object VAR_2 : VAR_1 ) { Boolean r = METHOD_2 ( ctx , VAR_2 , target ) ; <START> if ( r != null && r ) return false ; <END> } return true ; } 
public Optional < TYPE_1 > METHOD_1 ( final TYPE_2 context , final TYPE_1 VAR_1 ) { METHOD_2 ( ) ; final TYPE_1 VAR_2 = VAR_3 . METHOD_3 ( VAR_1 . getId ( ) ) ; if ( VAR_2 != null ) { return Optional . of ( VAR_2 ) ; } else { if ( VAR_4 ) { throw new TYPE_3 ( STRING_1 + VAR_1 ) ; } else { <START> return Optional . VAR_5 ( VAR_1 ) ; <END> } } } 
public String toString ( ) { <START> return STRING_1 + ( VAR_1 == null ? STRING_2 : VAR_1 ) + <END> STRING_3 + ( VAR_2 == null ? STRING_2 : VAR_2 ) + STRING_4 + ( version == null ? STRING_2 : version ) + STRING_5 + ( VAR_3 == null ? STRING_2 : VAR_3 ) + STRING_6 + Long . toString ( VAR_4 ) + STRING_7 + ( VAR_5 == null ? STRING_2 : VAR_5 . toString ( ) ) + STRING_8 ; } 
void METHOD_1 ( ) { final boolean VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . VAR_3 ) ; if ( ! VAR_1 ) { METHOD_4 ( ) ; } else { <START> final int VAR_4 = Math . max ( 1 , TYPE_2 . METHOD_5 ( ) . METHOD_6 ( ) ) ; <END> METHOD_7 ( VAR_4 , ( ) - > METHOD_4 ( ) ) ; } } 
<START> public String METHOD_1 ( ) { <END> return y ; } 
public void run ( ) { Object VAR_1 = METHOD_1 ( ) . METHOD_2 ( ) ; if ( VAR_1 instanceof TYPE_1 ) { TYPE_1 build = ( TYPE_1 ) VAR_1 ; if ( VAR_2 != null ) { METHOD_3 ( build , VAR_2 ) ; } else { <START> METHOD_3 ( build ) ; <END> } } else if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 ; METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ; } } 
private boolean METHOD_1 ( TYPE_1 token ) { boolean result = false ; if ( ! VAR_1 ) { <START> result = METHOD_2 ( token ) && METHOD_3 ( token ) ; <END> } return result ; } 
public boolean METHOD_1 ( String type , TYPE_1 uri , String VAR_1 ) { <START> boolean VAR_2 = true ; <END> VAR_2 &= TYPE_4 . TYPE_3 . toString ( ) . equalsIgnoreCase ( type ) ; VAR_2 &= METHOD_2 ( ) . METHOD_3 ( ) . equalsIgnoreCase ( uri . VAR_3 ( ) ) ; VAR_2 &= METHOD_2 ( ) . METHOD_4 ( ) . equalsIgnoreCase ( uri . VAR_4 ( ) ) ; return VAR_2 ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 , String in ) { TYPE_2 VAR_3 = TYPE_3 . get ( VAR_1 ) ; <START> return VAR_3 != null ? VAR_3 . METHOD_2 ( VAR_2 , in ) : false ; <END> } 
private TYPE_4 ( ) { <START> VAR_2 = new TYPE_1 < TYPE_2 , TYPE_3 > ( ) ; <END> } 
public final Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { if ( ! VAR_1 ) { return METHOD_2 ( ctx , command ) ; } final Object key = command . getKey ( ) ; try { <START> VAR_2 . METHOD_3 ( key , true ) ; <END> return METHOD_2 ( ctx , command ) ; } finally { VAR_2 . METHOD_4 ( key ) ; } } 
<START> boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_2 . contains ( VAR_1 ) && ! VAR_2 . METHOD_2 ( VAR_1 ) . VAR_3 . isEmpty ( ) ; } 
protected void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = null ; if ( getParameters ( ) . METHOD_2 ( ) == null ) { VAR_1 = METHOD_3 ( ) . METHOD_4 ( getParameters ( ) . getId ( ) ) ; } else { VAR_1 = METHOD_3 ( ) . METHOD_5 ( getParameters ( ) . getId ( ) , getParameters ( ) . METHOD_2 ( ) ) ; } <START> if ( VAR_1 != null && VAR_1 . size ( ) > 0 ) { <END> METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; } } 
<START> TYPE_1 METHOD_1 ( ) throws TYPE_2 { <END> Object VAR_1 = element . VAR_2 ( VAR_3 ) ; if ( VAR_1 instanceof TYPE_1 ) { return ( TYPE_1 ) VAR_1 ; } if ( VAR_1 instanceof TYPE_3 ) { return new TYPE_4 ( ( TYPE_3 ) VAR_1 ) ; } throw new TYPE_5 ( STRING_1 + element . VAR_4 ( ) + STRING_2 + TYPE_6 . VAR_6 + STRING_3 + TYPE_6 . VAR_7 + STRING_4 + TYPE_3 . class . getName ( ) + STRING_5 + VAR_1 . getClass ( ) . getName ( ) ) ; } 
public < TYPE_1 > TYPE_1 METHOD_1 ( Long value , Class < TYPE_1 > type , TYPE_2 options ) { <START> log . debug ( STRING_1 ) ; <END> byte [ ] VAR_1 = ByteBuffer . VAR_2 ( Long . VAR_3 ) . METHOD_2 ( value ) . METHOD_3 ( ) ; return ( TYPE_1 ) new TYPE_3 ( VAR_1 ) ; } 
<START> public final < R > R METHOD_1 ( ANNOTATION_1 TYPE_1 < ? extends R > VAR_1 ) { <END> try { return TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) . apply ( this ) ; } catch ( Throwable ex ) { TYPE_3 . METHOD_3 ( ex ) ; throw TYPE_4 . METHOD_4 ( ex ) ; } } 
public Object METHOD_1 ( TYPE_1 VAR_1 , int position ) { <START> int VAR_2 = VAR_3 ; <END> switch ( position ) { case VAR_3 : VAR_2 = R . id . VAR_4 ; break ; case VAR_5 : VAR_2 = R . id . VAR_6 ; break ; default : } return METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 uri , TYPE_2 configuration ) throws IOException { <START> this . VAR_1 . METHOD_1 ( uri , configuration ) ; <END> } 
public static void METHOD_1 ( String [ ] args ) { <START> int status = METHOD_2 ( args ) ; <END> System . VAR_1 ( status ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 writer ) throws TYPE_3 { <START> System . out . println ( writer . VAR_2 ( ) ) ; <END> } 
public List < ANNOTATION_1 TYPE_1 > METHOD_1 ( ) { <START> return TYPE_2 < ANNOTATION_1 TYPE_1 > METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 message , int VAR_2 ) { boolean VAR_3 = false ; <START> for ( String VAR_4 : message . VAR_5 ( STRING_1 ) ) { <END> if ( VAR_4 . contains ( context . getString ( R . string . VAR_6 ) ) ) VAR_3 = true ; } VAR_7 . METHOD_1 ( VAR_1 , message , VAR_2 , VAR_3 ) ; } 
public void METHOD_1 ( TYPE_1 trace ) { super . METHOD_1 ( trace ) ; METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> } 
<START> public static void METHOD_1 ( String VAR_1 , Logger log ) { <END> Set < String > VAR_2 = METHOD_2 ( VAR_1 , log ) ; log . info ( STRING_1 + VAR_2 ) ; for ( String VAR_3 : VAR_2 ) { try { METHOD_3 ( VAR_3 , log ) ; } catch ( Throwable t ) { log . warn ( STRING_2 + VAR_3 , t ) ; } } } 
public boolean equals ( Object o ) { if ( o == null ) { return false ; } if ( this == o ) { return true ; } <START> if ( ! ( this . getClass ( ) . equals ( o . getClass ( ) ) ) ) { <END> return false ; } TYPE_1 that = ( TYPE_1 ) o ; return TYPE_2 . METHOD_1 ( VAR_1 , that . VAR_1 ) ; } 
public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( METHOD_4 ( VAR_1 ) ) ; VAR_2 . METHOD_5 ( VAR_1 , 0 ) ; <START> client . VAR_3 ( VAR_4 ) ; <END> TYPE_1 node = VAR_5 . METHOD_6 ( ) . iterator ( ) . next ( ) ; client . VAR_6 ( node , INT_1 ) ; assertEquals ( 0 , VAR_7 . METHOD_7 ( ) ) ; time . VAR_8 ( INT_1 ) ; assertEquals ( 1 , VAR_7 . METHOD_7 ( ) ) ; } 
public TYPE_3 ( TYPE_1 data ) { TYPE_2 . METHOD_1 ( data , STRING_1 ) ; <START> this . data = data ; <END> } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { try { <START> VAR_2 . remove ( VAR_1 ) ; <END> VAR_1 . close ( ) ; } catch ( IOException VAR_3 ) { VAR_4 . VAR_5 . METHOD_2 ( VAR_1 , VAR_3 ) ; } finally { METHOD_3 ( ) ; } } 
public List < TYPE_1 > METHOD_1 ( ) { <START> String VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> List < TYPE_2 > VAR_3 = VAR_4 . METHOD_4 ( VAR_1 ) ; List < TYPE_1 > VAR_5 = new ArrayList < TYPE_1 > ( VAR_3 . size ( ) ) ; for ( TYPE_2 VAR_6 : VAR_3 ) { VAR_5 . add ( new TYPE_3 ( VAR_6 , this ) ) ; } return VAR_5 ; } 
protected TYPE_4 ( TYPE_1 item , TYPE_1 VAR_2 , Integer VAR_3 , TYPE_2 config ) { this . item = item ; this . VAR_3 = VAR_3 ; if ( config instanceof TYPE_3 ) { TYPE_3 VAR_4 = ( TYPE_3 ) config ; <START> VAR_4 . METHOD_1 ( item , VAR_2 ) ; <END> this . config = VAR_4 ; } else { this . config = config ; } } 
public static void METHOD_1 ( File source , File VAR_1 ) throws IOException { <START> try ( TYPE_1 in = new TYPE_2 ( source ) ) { <END> try ( TYPE_3 out = new TYPE_4 ( new TYPE_5 ( VAR_1 ) ) ) { METHOD_2 ( in , out ) ; } } } 
public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( this ) ; TYPE_2 list = this . VAR_2 ; <START> TYPE_1 VAR_3 = list . VAR_4 ( VAR_1 . METHOD_3 ( ) ) ; <END> list . set ( VAR_1 ) ; return VAR_3 ; } 
public TYPE_2 ( TYPE_1 VAR_2 , long VAR_3 , byte [ ] data ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; this . data = data ; this . VAR_4 = VAR_2 . VAR_5 ; } 
<START> public boolean METHOD_1 ( char VAR_1 , int VAR_2 ) { <END> if ( super . METHOD_1 ( VAR_1 , VAR_2 ) || ! VAR_3 ) { return true ; } else if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { this . METHOD_3 ( TYPE_2 . toString ( VAR_1 ) ) ; return true ; } else { return false ; } } 
Map < String , String > METHOD_1 ( ) throws TYPE_1 , TYPE_2 { Map < String , String > parameters ; try { parameters = TYPE_3 . METHOD_1 ( ) ; } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } <START> return parameters ; <END> } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , List < TYPE_3 > VAR_2 ) { <START> TYPE_1 VAR_3 = new TYPE_1 ( METHOD_2 ( VAR_1 , STRING_1 ) , METHOD_2 ( VAR_2 , STRING_2 ) ) ; <END> VAR_3 . METHOD_3 ( ) ; return VAR_3 ; } 
public static TYPE_1 METHOD_1 ( ) { TYPE_2 < TYPE_1 > reader = new TYPE_2 < TYPE_1 > ( TYPE_6 . VAR_2 , STRING_1 , STRING_1 , TYPE_1 . class ) ; TYPE_3 status = reader . read ( ) ; if ( ! status . VAR_3 ( ) ) { <START> TYPE_4 . log ( status ) ; <END> } TYPE_1 VAR_4 = reader . VAR_5 ( ) ; if ( VAR_4 != null ) { return VAR_4 ; } return new TYPE_5 ( ) ; } 
public void METHOD_1 ( String message ) { <START> buffer . append ( message + STRING_1 ) ; <END> } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 , final int VAR_3 , final Boolean VAR_4 , final String VAR_5 ) { final TYPE_2 VAR_6 = new TYPE_2 ( ) ; VAR_6 . METHOD_2 ( VAR_1 ) ; VAR_6 . METHOD_3 ( VAR_2 ) ; VAR_6 . METHOD_4 ( VAR_3 ) ; VAR_6 . METHOD_5 ( VAR_4 ) ; VAR_6 . METHOD_6 ( VAR_5 ) ; <START> VAR_1 . METHOD_7 ( ) . add ( VAR_6 ) ; <END> VAR_7 . METHOD_8 ( VAR_6 ) ; } 
<START> public void METHOD_1 ( ) { <END> VAR_1 = new TYPE_1 ( ( TYPE_2 ) VAR_2 . METHOD_2 ( ) , this ) ; TYPE_3 VAR_3 = new TYPE_3 ( ) { @Override public void METHOD_3 ( Collection < ? extends TYPE_4 > VAR_4 ) { VAR_5 . METHOD_4 ( VAR_4 ) ; VAR_5 . METHOD_5 ( ) . remove ( VAR_4 ) ; VAR_5 . METHOD_5 ( ) . METHOD_6 ( VAR_6 ) ; } } ; VAR_7 = new TYPE_5 ( ( TYPE_2 ) VAR_2 . METHOD_2 ( ) , this , VAR_3 ) ; } 
ANNOTATION_1 public void METHOD_1 ( ) throws Exception { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; } if ( cache != null ) { cache . VAR_2 ( ) ; } client . VAR_3 ( ) . METHOD_3 ( ) ; <START> if ( client . VAR_3 ( ) . METHOD_4 ( ) > 0 ) { <END> System . out . println ( STRING_1 ) ; Thread . VAR_4 ( INT_1 ) ; System . out . println ( STRING_2 + client . VAR_3 ( ) . METHOD_4 ( ) ) ; } } 
public void METHOD_1 ( String ... VAR_1 ) { try { METHOD_2 ( Arrays . stream ( VAR_1 ) ) ; } catch ( TYPE_1 e ) { <START> throw new TYPE_1 ( STRING_1 + VAR_1 , e . VAR_2 ( ) ) ; <END> } super . METHOD_1 ( VAR_1 ) ; } 
protected void METHOD_1 ( int VAR_1 ) { if ( VAR_1 == 0 ) { METHOD_2 ( ) ; } METHOD_3 ( new TYPE_1 ( ) ) ; METHOD_3 ( new TYPE_2 ( ) ) ; METHOD_3 ( new TYPE_3 ( ) ) ; METHOD_3 ( new TYPE_4 ( ) ) ; METHOD_3 ( new TYPE_5 ( ) ) ; <START> METHOD_3 ( new TYPE_6 ( new TYPE_7 ( METHOD_4 ( ) , METHOD_5 ( ) ) ) ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) throws Exception { TYPE_3 . debug ( STRING_1 + VAR_1 ) ; TYPE_4 request = METHOD_2 ( VAR_1 ) . METHOD_3 ( TYPE_5 . create ( VAR_3 , VAR_2 ) ) . build ( ) ; <START> TYPE_3 . error ( VAR_1 . toString ( ) ) ; <END> TYPE_3 . error ( VAR_2 ) ; TYPE_6 call = client . VAR_4 ( request ) ; Response response = call . execute ( ) ; return TYPE_1 . from ( response ) ; } 
<START> public TYPE_1 ( List < T > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; this . i = 0 ; } 
<START> private void METHOD_1 ( TYPE_2 . TYPE_3 [ ] VAR_1 ) { <END> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { VAR_1 [ i ] . METHOD_2 ( ) ; } } 
public void METHOD_1 ( TYPE_1 output ) throws IOException { output . VAR_1 ( VAR_2 ) ; if ( VAR_2 != null ) { output . VAR_3 ( id ) ; } output . VAR_4 ( VAR_5 ) ; <START> if ( VAR_6 != null ) { <END> TYPE_2 . METHOD_2 ( VAR_6 , output ) ; } else { assert VAR_7 != null ; TYPE_2 . METHOD_3 ( VAR_7 , output ) ; } } 
public static TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( METHOD_2 ( ) , METHOD_3 ( 1 , INT_1 ) , METHOD_2 ( ) ) ; <END> } 
<START> boolean METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = VAR_1 + VAR_3 ; return VAR_4 . remove ( TYPE_1 . name ( TYPE_2 . class , VAR_2 + STRING_1 ) ) && VAR_4 . remove ( TYPE_1 . name ( Log . VAR_5 , VAR_2 + STRING_2 ) ) && VAR_4 . remove ( TYPE_1 . name ( TYPE_2 . VAR_5 , VAR_2 + STRING_3 ) ) && VAR_4 . remove ( TYPE_1 . name ( TYPE_2 . VAR_5 , VAR_2 + STRING_4 ) ) ; } 
public void METHOD_1 ( ) { <START> this . METHOD_2 ( ( ) - > { <END> log . info ( STRING_1 ) ; METHOD_3 ( ) ; METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ; METHOD_4 ( ) . METHOD_5 ( VAR_2 ) ; VAR_3 = true ; } ) ; } 
public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( float VAR_1 ) { METHOD_2 ( STRING_1 , VAR_1 ) ; <START> assert VAR_1 == VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; <END> } 
public static boolean METHOD_1 ( Class < ? > VAR_1 ) { if ( VAR_1 == null ) { return false ; } else if ( VAR_1 . METHOD_2 ( ) ) { return TYPE_1 . contains ( VAR_1 ) ; } else { <START> return TYPE_2 . class . METHOD_3 ( VAR_1 ) ; <END> } } 
public List < TYPE_1 > METHOD_1 ( TYPE_2 element , TYPE_2 VAR_1 , int VAR_2 ) { <START> ArrayList < Object > VAR_3 = new ArrayList < > ( ) ; <END> return METHOD_1 ( element , VAR_1 , VAR_3 , VAR_4 , VAR_2 ) ; } 
public final TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { <START> while ( true ) { <END> TYPE_1 < TYPE_2 > VAR_2 = VAR_3 . get ( ) ; if ( VAR_3 . METHOD_2 ( VAR_2 , VAR_1 ) ) return VAR_2 ; } } 
public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( ) { @Override public boolean METHOD_2 ( ) { return TYPE_3 . this . METHOD_2 ( ) ; } @Override public TYPE_2 METHOD_3 ( ) { return TYPE_3 . VAR_2 . METHOD_3 ( ) ; } @Override public void METHOD_4 ( ) { TYPE_3 . VAR_2 . METHOD_4 ( ) ; } } ; <END> } 
public void METHOD_1 ( ) { <START> for ( Object VAR_1 : VAR_2 . METHOD_2 ( ) ) { <END> TYPE_1 VAR_3 = ( TYPE_1 ) VAR_1 ; VAR_3 . METHOD_3 ( TYPE_1 . TYPE_2 . VAR_5 , STRING_1 ) ; } VAR_6 . set ( false ) ; } 
public void METHOD_1 ( long VAR_1 , TYPE_1 location ) { <START> VAR_2 . METHOD_2 ( VAR_1 , x - > new HashMap < > ( ) ) ; <END> VAR_2 . get ( VAR_1 ) . put ( location . VAR_3 ( ) , location ) ; } 
public String getName ( ) { return METHOD_1 ( Constants . VAR_1 ) != null <START> ? VAR_2 . METHOD_2 ( ) . get ( Constants . VAR_1 ) <END> : METHOD_3 ( ) ; } 
public TYPE_6 ( TYPE_1 project , TYPE_2 VAR_2 ) { this . project = project ; this . VAR_2 = VAR_2 ; VAR_3 = ( TYPE_3 ) TYPE_4 . METHOD_1 ( ) ; <START> parameters = new HashMap < String , List < TYPE_5 > > ( ) ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { if ( ! METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; <START> VAR_2 . METHOD_7 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; <END> } } } 
public int read ( int offset , int [ ] VAR_1 , int VAR_2 ) { VAR_3 = METHOD_1 ( VAR_3 , VAR_1 , VAR_2 ) ; <START> VAR_4 = VAR_2 ; <END> return VAR_4 ; } 
<START> public void start ( TYPE_1 ctx ) <END> throws TYPE_2 { if ( VAR_1 == null ) { VAR_1 = new TYPE_3 ( ) ; VAR_1 . start ( ) ; } } 
public String getValue ( ) { <START> return name ( ) . METHOD_1 ( ) ; <END> } 
<START> public boolean start ( ) <END> { if ( ! VAR_1 . get ( ) ) { LOGGER . info ( STRING_1 , id ) ; VAR_1 . set ( VAR_2 . METHOD_1 ( ) ) ; } return VAR_1 . get ( ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 ) { try { TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { <START> TYPE_2 . METHOD_4 ( VAR_1 . METHOD_3 ( ) ) ; <END> } catch ( Exception e ) { throw new RuntimeException ( e ) ; } METHOD_5 ( VAR_1 . METHOD_3 ( ) , VAR_3 , false ) ; METHOD_5 ( VAR_1 . METHOD_3 ( ) , VAR_4 , false ) ; } 
public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = 1 ; result = VAR_1 * result <START> + ( ( VAR_2 == null ) ? 0 : VAR_2 . METHOD_1 ( ) ) ; <END> result = VAR_1 * result + ( ( VAR_3 == null ) ? 0 : VAR_3 . METHOD_1 ( ) ) ; return result ; } 
private <START> List < TYPE_1 > list ( final <END> TYPE_2 request ) throws TYPE_3 { TYPE_4 VAR_1 = VAR_2 . get ( ) ; VAR_1 . METHOD_1 ( request . VAR_3 ( ) ) ; VAR_1 . METHOD_2 ( request . VAR_4 ( ) ) ; VAR_1 . METHOD_3 ( request . VAR_5 ( ) ) ; VAR_1 . METHOD_4 ( request . VAR_6 ( ) ) ; Map < String , TYPE_1 > result = VAR_1 . apply ( ) ; return ImmutableList . VAR_7 ( result . values ( ) ) ; } 
public void METHOD_1 ( ) { <START> Long VAR_1 = TYPE_2 . TYPE_3 . getId ( ) ; <END> Long VAR_2 = item . VAR_3 ( ) . getId ( ) ; assertEquals ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_3 ( ) . METHOD_4 ( true ) ; <END> VAR_1 . METHOD_5 ( ) . METHOD_6 ( this ) ; } 
<START> public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { <END> logger . debug ( STRING_1 , VAR_1 ) ; TYPE_3 VAR_2 = new TYPE_3 ( this ) ; VAR_2 . VAR_1 = VAR_1 ; return VAR_2 ; } 
private void METHOD_1 ( String VAR_1 ) { try { TYPE_1 VAR_2 = this . connection . VAR_3 ( ) ; VAR_2 . METHOD_1 ( VAR_1 ) ; <START> VAR_2 . close ( ) ; <END> } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
private void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 Collection < TYPE_2 > VAR_2 , ANNOTATION_1 List < String > VAR_3 ) { for ( TYPE_2 VAR_4 : VAR_2 ) { Set < String > VAR_5 = TYPE_3 . METHOD_2 ( ) ; TYPE_4 VAR_6 = METHOD_3 ( VAR_4 ) ; METHOD_4 ( VAR_1 , VAR_6 , VAR_5 ) ; <START> VAR_5 . addAll ( METHOD_5 ( VAR_3 , VAR_1 ) ) ; <END> VAR_7 . put ( VAR_4 . getPath ( ) , TYPE_3 . METHOD_6 ( VAR_5 ) ) ; } } 
public void METHOD_1 ( ) throws IOException { String [ ] VAR_1 = new String [ ] { STRING_1 , STRING_2 , STRING_3 , STRING_4 } ; <START> TYPE_1 VAR_2 = new TYPE_2 ( VAR_3 ) ; <END> List < String > VAR_4 = new ArrayList < > ( ) ; VAR_2 . METHOD_2 ( VAR_4 , VAR_1 , 3 , null ) ; Assert . assertEquals ( 2 , VAR_4 . size ( ) ) ; Assert . assertTrue ( VAR_4 . contains ( STRING_5 ) ) ; Assert . assertTrue ( VAR_4 . contains ( STRING_6 ) ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . create ( db , VAR_3 . METHOD_2 ( ) ) ; TYPE_4 . TYPE_5 VAR_4 = VAR_1 . to ( VAR_5 , STRING_1 ) . METHOD_3 ( ) ; List < TYPE_3 > VAR_6 = METHOD_4 ( VAR_4 ) ; <START> assertThat ( VAR_6 . size ( ) ) . METHOD_5 ( 0 ) ; <END> } 
protected void METHOD_1 ( ) { boolean VAR_1 = METHOD_2 ( ) . getStatus ( ) == TYPE_2 . TYPE_1 && METHOD_2 ( ) . METHOD_3 ( ) != null ; METHOD_4 ( VAR_1 ? METHOD_5 ( ) : METHOD_6 ( ) ) ; <START> VAR_4 . METHOD_7 ( METHOD_2 ( ) , VAR_5 , METHOD_8 ( ) ) ; <END> } 
<START> public void METHOD_1 ( ) { <END> try { TYPE_1 . METHOD_2 ( STRING_1 ) ; METHOD_3 ( STRING_2 ) ; } catch ( TYPE_2 e ) { } } 
public static String toString ( int VAR_1 ) { try { TYPE_1 [ ] VAR_2 = TYPE_2 . class . METHOD_1 ( ) ; <START> for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { <END> TYPE_1 field = VAR_2 [ i ] ; if ( field . getInt ( null ) == VAR_1 ) { return field . getName ( ) ; } } } catch ( TYPE_3 e ) { } return STRING_1 + VAR_1 + STRING_2 ; } 
public List < TYPE_1 > METHOD_1 ( List < String > VAR_1 ) throws TYPE_2 { <START> if ( VAR_1 == null || ! VAR_1 . isEmpty ( ) ) { <END> throw new TYPE_2 ( STRING_1 , ( Object [ ] ) null ) ; } return VAR_2 . METHOD_1 ( VAR_1 ) ; } 
<START> private int METHOD_1 ( final String VAR_1 , <END> final String VAR_2 ) { final TYPE_1 matcher = TYPE_2 . METHOD_2 ( VAR_2 ) . matcher ( VAR_1 ) ; final List < String > VAR_3 = new ArrayList < > ( ) ; while ( matcher . VAR_4 ( ) ) { VAR_3 . add ( matcher . group ( ) ) ; } return VAR_3 . size ( ) ; } 
public void METHOD_1 ( ) { String VAR_1 = STRING_1 ; when ( VAR_2 . METHOD_2 ( METHOD_3 ( ) ) ) . METHOD_4 ( null ) ; VAR_3 . METHOD_5 ( VAR_1 ) ; Assert . assertNotNull ( VAR_2 . METHOD_2 ( VAR_1 ) ) ; <START> METHOD_6 ( VAR_2 ) . METHOD_2 ( VAR_1 ) ; <END> METHOD_6 ( VAR_3 ) . METHOD_5 ( VAR_1 ) ; } 
public void run ( ) { log . info ( Thread . VAR_1 ( ) . getName ( ) + STRING_1 ) ; try { VAR_2 . METHOD_1 ( VAR_3 , VAR_4 ) ; } catch ( IOException e ) { <START> e . VAR_5 ( ) ; <END> } log . info ( Thread . VAR_1 ( ) . getName ( ) + STRING_2 ) ; } 
public TYPE_1 METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; try { <START> return VAR_2 ; <END> } finally { VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; } } 
public static TYPE_1 < Object [ ] > METHOD_1 ( ) { return ImmutableList . of ( <START> new Object [ ] { TYPE_2 . VAR_2 , false } , new Object [ ] { TYPE_2 . VAR_2 , true } , new Object [ ] { TYPE_2 . VAR_3 , false } , new Object [ ] { TYPE_2 . VAR_3 , true } <END> ) ; } 
<START> public static ByteBuffer METHOD_1 ( final TYPE_1 VAR_1 , ByteBuffer buffer ) { <END> if ( buffer . position ( ) < buffer . VAR_2 ( ) ) { return buffer ; } ByteBuffer VAR_3 = METHOD_2 ( buffer , VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; buffer . VAR_4 ( ) ; VAR_3 . put ( buffer ) ; return VAR_3 ; } 
public void METHOD_1 ( ) { TYPE_1 parser = new TYPE_1 ( ) ; String VAR_1 = STRING_1 ; String VAR_2 = STRING_2 ; Assert . assertTrue ( parser . parse ( VAR_1 ) . METHOD_2 ( ) ) ; <START> Assert . assertEquals ( parser . parse ( VAR_1 ) , parser . parse ( VAR_2 ) ) ; <END> } 
public TYPE_4 ( double VAR_2 ) { <START> this . VAR_3 = new TYPE_1 < > ( <END> VAR_4 , TYPE_3 < String > METHOD_1 ( ) , TYPE_2 . valueOf ( VAR_2 ) , TYPE_2 . VAR_6 ) ; } 
public boolean METHOD_1 ( TYPE_1 command , TYPE_2 response ) { boolean VAR_1 = false ; try { byte [ ] data = METHOD_2 ( response ) ; <START> String message = data != null ? new String ( data ) : null ; <END> switch ( response . VAR_2 ( ) ) { case INT_1 : case INT_2 : VAR_1 = super . METHOD_1 ( command , response ) ; break ; default : break ; } } finally { METHOD_3 ( response ) ; } return VAR_1 ; } 
public static void METHOD_1 ( TYPE_1 channel ) { if ( channel instanceof TYPE_2 ) { if ( ( ( TYPE_2 ) channel ) . METHOD_2 ( ) instanceof TYPE_3 ) { <START> TYPE_3 VAR_1 = ( TYPE_3 ) ( ( TYPE_2 ) channel ) <END> . METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( VAR_1 , Boolean . VAR_3 ) == null ) { VAR_1 . METHOD_4 ( VAR_4 ) ; } } } } 
public TYPE_4 ( final TYPE_1 config , final TYPE_2 db , final File VAR_2 , final File VAR_3 ) { super ( config , db , VAR_2 , VAR_3 ) ; this . VAR_4 = new TYPE_3 ( config , db , VAR_2 , VAR_3 ) ; <START> this . METHOD_1 ( ) ; <END> } 
<START> TYPE_1 < TYPE_2 > METHOD_1 ( boolean VAR_1 ) <END> { int VAR_2 = 0 ; TYPE_1 < TYPE_2 > VAR_3 = new TYPE_3 < > ( VAR_1 ? metadata . VAR_4 . METHOD_2 ( ) : metadata . VAR_4 ) ; while ( VAR_2 <= VAR_5 ) { int VAR_6 = VAR_7 . METHOD_3 ( VAR_5 / 10 ) * ( VAR_7 . METHOD_3 ( 3 ) + 2 / 3 ) ; VAR_2 += VAR_6 ; VAR_3 . add ( METHOD_4 ( VAR_2 ) ) ; } return VAR_3 ; } 
<START> public Optional < String > METHOD_1 ( ) { <END> return Optional . VAR_1 ( VAR_2 ) ; } 
ANNOTATION_1 <START> public void <END> METHOD_1 ( ) { try { new TYPE_1 ( null ) { } ; METHOD_2 ( ) ; } catch ( TYPE_2 VAR_1 ) { } } 
public boolean METHOD_1 ( TYPE_1 node ) throws TYPE_2 { if ( node . VAR_1 ( ) ) { if ( VAR_2 != null ) { throw new TYPE_3 ( STRING_1 ) ; } this . VAR_2 = node ; this . VAR_1 = true ; <START> } else if ( node . getClass ( ) . METHOD_2 ( TYPE_4 . class ) ) { <END> this . VAR_1 = true ; } return true ; } 
public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 + VAR_2 + VAR_3 ) ; <END> } 
public boolean METHOD_1 ( String name , TYPE_1 VAR_1 ) { TYPE_1 value = VAR_2 . METHOD_2 ( name , VAR_1 ) ; if ( value == null ) return true ; else return false ; <START> } <END> 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( ) != null || METHOD_3 ( ) == null ? this : org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_2 . METHOD_1 ( METHOD_3 ( ) ) ; <END> } 
private void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( VAR_1 , new TYPE_1 . TYPE_3 ( ) { <END> @Override public void METHOD_3 ( ) { METHOD_4 ( TYPE_4 . VAR_3 ) ; } } ) ; } 
public < T > T METHOD_1 ( TYPE_1 < T > type ) { Assert . VAR_1 ( type , STRING_1 ) ; <START> final String url = METHOD_2 ( true ) ; <END> return VAR_2 . METHOD_3 ( url , VAR_3 , METHOD_4 ( VAR_4 ) , type ) . METHOD_5 ( ) ; } 
public TYPE_1 METHOD_1 ( List < ? extends TYPE_2 > VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 ) { String <START> VAR_3 = <END> VAR_2 . METHOD_2 ( ) ; if ( VAR_3 != null ) { if ( ! TYPE_3 . matcher ( VAR_2 . METHOD_2 ( ) ) . METHOD_3 ( ) ) { return new TYPE_1 ( TYPE_4 . VAR_5 , String . format ( STRING_1 , VAR_2 . getName ( ) ) , String . format ( STRING_2 , VAR_2 . METHOD_2 ( ) ) ) ; } } } return TYPE_1 . VAR_6 ; } 
public List < TYPE_1 > METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final TYPE_4 context ) throws TYPE_5 { <START> return VAR_3 . execute ( false , TYPE_5 . class , new TYPE_6 < List < TYPE_1 > > ( ) { <END> @Override public List < TYPE_1 > METHOD_2 ( final TYPE_7 VAR_4 ) throws TYPE_8 , TYPE_9 { final TYPE_10 VAR_5 = VAR_4 . METHOD_3 ( TYPE_10 . class ) ; return VAR_6 . METHOD_1 ( VAR_5 , TYPE_11 . VAR_8 , VAR_1 , VAR_2 , context ) ; } } ) ; } 
public void run ( ) { while ( true ) { METHOD_1 ( VAR_1 , Long . VAR_2 , VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) , VAR_3 . METHOD_4 ( ) . METHOD_3 ( ) ) ; synchronized ( VAR_4 ) { if ( VAR_5 ) { VAR_5 = false ; } else { VAR_4 . remove ( VAR_1 . METHOD_5 ( ) ) ; <START> break ; <END> } } } } 
public final Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { try { if ( METHOD_2 ( command ) ) { return METHOD_3 ( ctx , command ) ; } <START> METHOD_4 ( ctx , Arrays . stream ( command . VAR_1 ( ) ) , METHOD_5 ( command ) ) ; <END> return METHOD_3 ( ctx , command ) ; } finally { if ( ! ctx . VAR_2 ( ) ) { VAR_3 . METHOD_6 ( ctx ) ; } } } 
public TYPE_1 ( double VAR_2 , double VAR_3 ) { <START> VAR_4 = VAR_3 + FLOAT_1 ; <END> VAR_5 = VAR_2 + FLOAT_1 ; if ( VAR_4 < - FLOAT_2 || VAR_4 > FLOAT_2 ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( VAR_5 < - FLOAT_3 || VAR_5 > FLOAT_3 ) { throw new IllegalArgumentException ( STRING_2 ) ; } } 
public final static TYPE_1 getInstance ( ) { try { <START> return new TYPE_1 ( ) ; <END> } catch ( TYPE_2 e ) { return new TYPE_1 ( TYPE_3 . VAR_2 ) ; } } 
private static void METHOD_1 ( ) { switch ( TYPE_1 . METHOD_2 ( ) ) { <START> case TYPE_1 . VAR_1 : <END> TYPE_2 . METHOD_3 ( ) ; break ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { Date VAR_2 = METHOD_2 ( VAR_1 ) ; <START> Date VAR_3 = METHOD_3 ( VAR_1 ) ; <END> VAR_1 . METHOD_4 ( VAR_2 ) ; } 
protected TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = METHOD_2 ( TYPE_1 . class ) ; <END> } return VAR_1 ; } 
<START> public long METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) throws TYPE_3 { TYPE_1 connection = null ; TYPE_4 VAR_3 = METHOD_2 ( VAR_1 ) ; TYPE_5 VAR_4 = TYPE_6 . get ( VAR_3 . getId ( ) ) ; if ( VAR_4 != null ) { connection = VAR_4 . METHOD_1 ( VAR_1 , VAR_2 ) ; } else { <START> connection = TYPE_7 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } return connection ; } 
protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = getParameters ( ) . METHOD_2 ( ) ; return METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( VAR_1 . getId ( ) ) ) && <START> METHOD_3 ( METHOD_4 ( ) . METHOD_6 ( VAR_1 . METHOD_7 ( ) , <END> VAR_1 . METHOD_8 ( ) ) ) ; } 
public void METHOD_1 ( final String VAR_1 ) { final Integer VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 > 0 ) { <END> this . VAR_1 = Integer . toString ( VAR_2 ) ; } else { this . VAR_1 = VAR_1 ; } } 
protected TYPE_1 run ( TYPE_2 monitor ) { while ( ! monitor . VAR_1 ( ) ) { try { Thread . VAR_2 ( VAR_3 ) ; } catch ( InterruptedException e ) { <START> Thread . VAR_4 ( ) . METHOD_1 ( ) ; <END> } } monitor . VAR_5 ( ) ; return Status . VAR_6 ; } 
public void METHOD_1 ( TYPE_1 event , List < TYPE_2 > VAR_1 ) { String id = event . VAR_2 ( ) . getId ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { <START> if ( VAR_3 . getType ( ) . METHOD_2 ( STRING_1 , STRING_2 ) . METHOD_3 ( TYPE_3 . VAR_5 ) . equals ( id ) ) { <END> VAR_3 . close ( ) ; break ; } } } 
public TYPE_2 ( ) { VAR_2 . put ( STRING_1 , new TYPE_1 ( ) { @Override public void run ( ) { METHOD_1 ( ) ; } } ) ; <START> } <END> 
public void METHOD_1 ( int VAR_1 ) { <START> if ( VAR_2 == - 1 ) { <END> VAR_2 = VAR_1 ; } else { if ( VAR_2 < VAR_1 ) { VAR_2 = VAR_1 ; } } } 
<START> public TYPE_1 ( ) { <END> VAR_2 = new ArrayList < > ( ) ; VAR_3 = new ArrayList < > ( ) ; } 
public void METHOD_1 ( ) throws Exception { <START> for ( TYPE_1 version : VAR_1 ) { <END> METHOD_2 ( version , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; } } 
private String METHOD_1 ( String url ) { File f = new File ( url ) ; if ( ! f . VAR_1 ( ) ) <START> if ( repo . VAR_2 ( ) ) { <END> url = new File ( repo . VAR_3 ( ) , url ) . METHOD_2 ( ) ; } else { url = new File ( repo . VAR_4 ( ) , url ) . METHOD_2 ( ) ; } return url ; } 
<START> public void METHOD_1 ( int VAR_1 ) { <END> size += VAR_1 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { try { return TYPE_4 . METHOD_2 ( METHOD_3 ( VAR_2 . METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ) , ( VAR_3 , t ) - > { if ( t != null ) { return METHOD_6 ( t , VAR_1 ) ; <START> } <END> return TYPE_5 . METHOD_7 ( ) ; } ) ; } catch ( Throwable e ) { return METHOD_6 ( e , VAR_1 ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , String text ) { <START> if ( VAR_2 != null ) { <END> METHOD_2 ( ) ; try { VAR_3 . write ( CHAR_1 ) ; METHOD_3 ( VAR_1 ) ; VAR_3 . write ( text ) ; VAR_3 . write ( CHAR_1 ) ; VAR_3 . write ( CHAR_2 ) ; VAR_3 . write ( VAR_2 ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } 
protected TYPE_1 METHOD_1 ( TYPE_2 info ) { TYPE_3 factory = TYPE_4 . getInstance ( ) . METHOD_2 ( ) ; <START> TYPE_5 file = ( TYPE_5 ) info . file ; <END> return factory . VAR_1 ( file , info . VAR_2 , info . VAR_3 , info . VAR_4 ) ; } 
protected void METHOD_1 ( ) { <START> if ( VAR_1 != null ) <END> VAR_1 . METHOD_2 ( context , parent . VAR_2 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 page ) { METHOD_2 ( page , STRING_1 ) ; METHOD_3 ( ! METHOD_4 ( ) , STRING_2 ) ; index . VAR_1 ( page ) ; if ( ! VAR_2 . METHOD_5 ( ( index . VAR_3 ( ) . METHOD_6 ( ) ) ) ) { index . VAR_4 ( ) ; } <START> VAR_2 . METHOD_7 ( index . VAR_3 ( ) . METHOD_6 ( ) ) ; <END> VAR_5 . METHOD_8 ( page . VAR_6 ( ) , page . VAR_7 ( ) ) ; } 
public TYPE_1 METHOD_1 ( ) { String VAR_1 = VAR_2 == null ? "" : VAR_2 . getName ( ) ; <START> final String s = METHOD_2 ( ) + STRING_1 + ( TYPE_3 . TYPE_4 . equals ( VAR_1 ) ? "" : VAR_1 ) ; <END> return s ; } 
protected String METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { String VAR_2 = METHOD_2 ( ) ; String VAR_3 = METHOD_3 ( ) ; String VAR_4 = METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; String VAR_5 = METHOD_6 ( ) ; String VAR_6 = STRING_1 + VAR_5 + STRING_2 ; <START> String command = STRING_3 + VAR_6 + VAR_3 + STRING_4 + VAR_4 + STRING_5 + TYPE_3 . VAR_8 + VAR_2 + STRING_6 ; <END> return command ; } 
private void METHOD_1 ( ) { <START> TYPE_1 < TYPE_2 > VAR_1 = METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( Arrays . asList ( TYPE_2 . values ( ) ) ) ; VAR_1 . METHOD_4 ( false ) ; VAR_1 . METHOD_5 ( TYPE_2 . VAR_2 ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 == 0 ) { return ; } METHOD_2 ( VAR_2 != null ) ; int [ ] VAR_3 = METHOD_3 ( ) ; <START> METHOD_2 ( VAR_4 + VAR_1 - 1 < VAR_3 . length && VAR_3 [ VAR_4 ] >= 0 && <END> VAR_3 [ VAR_4 + VAR_1 - 1 ] < VAR_2 . METHOD_4 ( ) ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; VAR_5 += VAR_1 ; } 
public TYPE_1 METHOD_1 ( ) throws Exception { org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . context . TYPE_1 VAR_5 = TYPE_2 . METHOD_2 ( ) ; String VAR_6 = VAR_5 . METHOD_3 ( ) ; String VAR_7 = VAR_5 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) ; <START> TYPE_3 properties = VAR_8 . METHOD_8 ( VAR_7 + STRING_1 + VAR_6 + STRING_1 + VAR_6 ) ; <END> return new TYPE_1 ( VAR_5 . METHOD_4 ( ) , properties ) ; } 
protected boolean METHOD_1 ( TYPE_1 properties ) { boolean VAR_1 = properties . VAR_2 ( ) != null ; <START> return VAR_1 ; <END> } 
private void METHOD_1 ( ) throws InterruptedException { if ( TYPE_1 != null ) { TYPE_1 . run ( ) ; <START> if ( Thread . VAR_1 ( ) . METHOD_2 ( ) ) { throw new InterruptedException ( STRING_1 ) ; } <END> } } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { if ( VAR_1 == TYPE_2 . VAR_3 ) { <START> return VAR_4 ; <END> } return VAR_5 . get ( VAR_1 ) ; } 
protected void METHOD_1 ( TYPE_1 props ) throws IOException { try { super . METHOD_1 ( props ) ; } catch ( TYPE_2 e ) { if ( VAR_1 != null && VAR_2 ) { TYPE_3 VAR_3 = VAR_1 . out ( ) ; props . VAR_4 ( VAR_3 , VAR_5 ) ; VAR_3 . METHOD_2 ( ) ; <START> VAR_3 . close ( ) ; <END> } } } 
public Builder METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( VAR_2 == null ) { <START> VAR_2 = new ArrayList ( ) ; <END> } if ( VAR_2 . contains ( VAR_1 ) ) { throw new IllegalStateException ( STRING_2 ) ; } VAR_2 . add ( VAR_1 ) ; return this ; } 
private Object METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { try { return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; } catch ( TYPE_4 . TYPE_5 . TYPE_3 t ) { <START> return new TYPE_3 ( t . VAR_4 ( ) ) ; <END> } catch ( Throwable t ) { return new TYPE_3 ( t ) ; } } 
public void METHOD_1 ( ) throws IOException { try ( TYPE_1 VAR_1 = METHOD_2 ( ) ) { TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( "" , input ) ; <START> TYPE_3 . METHOD_4 ( VAR_2 , <END> VAR_3 ) ; } } 
private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 repo , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 , String path , byte [ ] content ) throws IOException , TYPE_7 { switch ( VAR_1 ) { case VAR_6 : VAR_4 . add ( new TYPE_8 ( path ) ) ; break ; case VAR_7 : case VAR_8 : <START> VAR_4 . add ( METHOD_2 ( VAR_1 , repo , VAR_2 , VAR_3 , path , VAR_5 , content ) ) ; <END> } VAR_4 . METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( final long id ) { <START> TYPE_2 result = this . VAR_1 . get ( id , VAR_2 - > this . VAR_3 . METHOD_2 ( id ) ) ; <END> return METHOD_3 ( result ) ; } 
public Map < String , Object > METHOD_1 ( String VAR_1 ) throws TYPE_1 { <START> return this . METHOD_1 ( VAR_1 , METHOD_2 ( VAR_1 ) . getName ( ) ) ; <END> } 
<START> public TYPE_1 METHOD_1 ( String name , String VAR_1 , TYPE_2 session ) { <END> return METHOD_2 ( session ) . METHOD_1 ( name , VAR_1 ) ; } 
private int METHOD_1 ( Map < String , Object > VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , int VAR_5 ) { if ( ( VAR_5 -= METHOD_2 ( VAR_3 , VAR_1 ) ) > 0 ) { if ( VAR_4 . length ( ) > VAR_5 ) { VAR_4 = VAR_4 . substring ( 0 , VAR_5 ) ; METHOD_3 ( VAR_2 , VAR_3 , VAR_4 ) ; } VAR_1 . put ( VAR_3 , VAR_4 ) ; return VAR_5 - VAR_4 . length ( ) ; } <START> return 0 ; <END> } 
public static TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { return METHOD_2 ( ( ) - > { try { VAR_1 . run ( ) ; } catch ( Exception e ) { <START> throw new TYPE_4 ( e ) ; <END> } } ) ; } 
public void add ( String VAR_1 , TYPE_1 VAR_2 ) { <START> this . VAR_3 = this . VAR_3 == null ? new HashMap < > ( ) : this . VAR_3 ; <END> this . VAR_3 . put ( VAR_1 , VAR_2 ) ; } 
public Context METHOD_1 ( ) { <START> return context ; <END> } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ( ) - > { try { <START> TYPE_1 . METHOD_3 ( TYPE_2 . METHOD_4 ( ) . METHOD_5 ( 1 , VAR_2 / INT_1 ) ) ; <END> log . info ( STRING_1 ) ; METHOD_6 ( METHOD_7 ( ) ) ; } catch ( InterruptedException e ) { Thread . VAR_3 ( ) . METHOD_8 ( ) ; } catch ( Throwable t ) { log . error ( t , STRING_2 ) ; } } , 0 , VAR_2 , TimeUnit . TYPE_3 ) ; } 
private TYPE_1 < TYPE_2 , TYPE_3 < ? > > METHOD_1 ( ) { TYPE_1 < TYPE_2 , TYPE_3 < ? > > builder = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( 100 ) . METHOD_4 ( new TYPE_4 ( ) ) . METHOD_5 ( INT_1 ) ; if ( logger . VAR_1 ( ) ) <START> builder = builder . VAR_2 ( new TYPE_5 ( ) ) ; <END> return builder ; } 
public void METHOD_1 ( TYPE_1 context ) { VAR_1 = 0 ; VAR_2 = false ; VAR_3 = 0 ; <START> VAR_4 . clear ( ) ; <END> this . context = context ; METHOD_2 ( context . VAR_5 ( ) ) ; VAR_4 . clear ( ) ; } 
public static TYPE_1 METHOD_1 ( String name ) { TYPE_2 VAR_1 = TYPE_2 . getInstance ( ) ; if ( VAR_1 . METHOD_2 ( ) ) { <START> TYPE_1 VAR_2 = new TYPE_1 ( name ) ; <END> TYPE_1 VAR_3 ; if ( ( VAR_3 = VAR_1 . METHOD_3 ( ) . get ( name ) ) != null ) { return ( VAR_3 ) ; } } return null ; } 
<START> public TYPE_6 ( final TYPE_4 . TYPE_5 . VAR_2 . TYPE_7 < TYPE_2 > VAR_4 , <END> TYPE_3 VAR_5 ) { this ( VAR_5 , VAR_4 ) ; } 
void METHOD_1 ( TYPE_1 event ) { <START> TYPE_2 . VAR_2 . info ( STRING_1 ) ; <END> next ( ) ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> final TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; final Object VAR_2 = METHOD_2 ( Object . VAR_3 ) ; final TYPE_2 < Object > VAR_4 = METHOD_2 ( TYPE_2 . VAR_3 ) ; TYPE_3 . METHOD_3 ( VAR_1 , VAR_2 , VAR_4 ) ; METHOD_4 ( VAR_4 , METHOD_5 ( 1 ) ) . METHOD_6 ( METHOD_7 ( VAR_2 ) ) ; METHOD_4 ( VAR_1 , METHOD_5 ( 1 ) ) . METHOD_3 ( METHOD_7 ( VAR_2 ) ) ; } 
<START> static TYPE_1 <END> METHOD_1 ( String VAR_1 , String VAR_2 ) { return new TYPE_1 ( VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 ) ; <START> VAR_1 . METHOD_2 ( VAR_5 ) ; <END> Assert . VAR_6 ( VAR_2 . METHOD_3 ( VAR_7 ) . METHOD_4 ( STRING_1 ) , VAR_4 . METHOD_5 ( VAR_3 . METHOD_6 ( ) , STRING_2 , STRING_3 , VAR_7 . METHOD_7 ( ) ) ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 user ) throws TYPE_3 { <START> TYPE_1 VAR_1 ; <END> VAR_1 = METHOD_2 ( user ) ; if ( VAR_1 == null ) { VAR_1 = user . VAR_2 ( METHOD_3 ( ) ) ; } return VAR_1 ; } 
public void METHOD_1 ( ) { Assert . assertNotNull ( this . c . VAR_1 ( ) ) ; <START> final Set < String > VAR_2 = TYPE_1 . METHOD_2 ( ) ; <END> VAR_2 . add ( STRING_1 ) ; this . c . VAR_3 ( VAR_2 ) ; Assert . assertEquals ( VAR_2 , this . c . VAR_1 ( ) ) ; this . c . VAR_3 ( null ) ; Assert . assertThat ( this . c . VAR_1 ( ) , TYPE_2 . empty ( ) ) ; } 
<START> public static < T > TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , ImmutableList < TYPE_3 < ? > > args ) { <END> return new TYPE_1 ( VAR_1 , args ) ; } 
private void METHOD_1 ( ) { <START> Optional < Object > VAR_1 = Optional . VAR_2 ( ) ; <END> if ( ! VAR_1 . isEmpty ( ) ) { VAR_1 . get ( ) ; } } 
public void METHOD_1 ( TYPE_1 entry ) throws TYPE_2 { if ( VAR_1 != null ) { Boolean VAR_2 = VAR_1 . apply ( entry ) ; if ( ( VAR_2 != null ) && ! VAR_2 ) { throw new TYPE_2 ( STRING_1 <START> + entry . VAR_3 ( ) + STRING_2 + entry . VAR_4 ( ) + STRING_3 + entry . VAR_5 ( ) ) ; <END> } } else { super . METHOD_1 ( entry ) ; } } 
public List < TYPE_1 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( new TYPE_1 ( getParameters ( ) . METHOD_2 ( ) . METHOD_3 ( ) , <END> TYPE_3 . TYPE_2 , METHOD_4 ( ) . METHOD_5 ( ) ) ) ; } 
public void METHOD_1 ( Throwable t ) { <START> TYPE_1 . METHOD_2 ( t ) ; <END> TYPE_2 . METHOD_3 ( context , t . VAR_1 ( ) , TYPE_2 . VAR_2 ) . METHOD_4 ( ) ; } 
public static Object METHOD_1 ( Object VAR_1 , TYPE_1 VAR_2 ) { try { VAR_2 . METHOD_2 ( ) ; } catch ( InterruptedException e ) { METHOD_3 ( ) . METHOD_4 ( ) ; <START> return VAR_1 ; <END> } return VAR_1 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_2 ( Boolean . VAR_4 ( VAR_2 . value ( ) ) ) ; <START> VAR_1 . add ( METHOD_3 ( VAR_2 ) , VAR_3 ) ; <END> VAR_5 . METHOD_4 ( VAR_3 ) ; return VAR_3 ; } 
public void METHOD_1 ( ) { Map < String , Object > VAR_1 = new HashMap < > ( ) ; TYPE_1 VAR_2 = new TYPE_1 ( STRING_1 , VAR_1 ) ; <START> assertThat ( VAR_3 ) . METHOD_2 ( ) ; <END> assertThat ( VAR_3 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_1 . class ) ; VAR_3 . execute ( VAR_2 ) ; METHOD_5 ( VAR_4 ) . METHOD_6 ( VAR_2 ) ; METHOD_5 ( VAR_5 ) . METHOD_7 ( TYPE_4 < TYPE_2 < TYPE_3 > > METHOD_8 ( ) ) ; } 
public void METHOD_1 ( boolean set ) { boolean VAR_1 = StringUtils . VAR_2 ( VAR_3 . METHOD_2 ( ) ) ; <START> if ( set ) { METHOD_3 ( VAR_1 ) ; } else { assertTrue ( VAR_1 ) ; } <END> } 
<START> public int METHOD_1 ( ByteBuffer VAR_1 ) { <END> int start = VAR_1 . position ( ) ; if ( ! VAR_2 . isPresent ( ) ) { METHOD_2 ( ) ; } VAR_1 . put ( VAR_2 . get ( ) ) ; final TYPE_1 VAR_3 = METHOD_3 ( ) ; if ( VAR_3 . METHOD_4 ( ) > 0 ) { METHOD_5 ( VAR_1 , start , VAR_3 ) ; } return VAR_4 + METHOD_6 ( ) ; } 
protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) ) ; <START> return METHOD_3 ( VAR_1 . METHOD_4 ( ) ) && super . METHOD_1 ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> List < TYPE_2 > VAR_2 = METHOD_2 ( VAR_1 ) ; <END> int count = 0 ; for ( TYPE_2 VAR_3 : VAR_2 ) { if ( VAR_3 . METHOD_3 ( ) ) count ++ ; } if ( count > 1 ) METHOD_4 ( VAR_1 ) ; else METHOD_5 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { final int VAR_1 = VAR_2 . METHOD_2 ( ) ; final int n = VAR_1 / Long . VAR_3 ; <START> for ( int i = 0 ; i < n ; i += Long . VAR_3 ) { <END> VAR_2 . METHOD_3 ( i , INT_1 ) ; } for ( int i = n ; i < VAR_1 ; i ++ ) { VAR_2 . put ( i , ( byte ) 0 ) ; } } 
private void METHOD_1 ( ) { long VAR_1 = 0 ; if ( METHOD_2 ( ) . METHOD_3 ( ) != null ) { for ( TYPE_1 VAR_2 : METHOD_2 ( ) . METHOD_3 ( ) ) { <START> if ( VAR_2 . METHOD_4 ( ) ) { <END> VAR_1 += VAR_2 . METHOD_5 ( ) ; } } } Pair < TYPE_2 , Double > VAR_3 = TYPE_3 . METHOD_6 ( VAR_1 , TYPE_2 . VAR_4 ) ; METHOD_7 ( VAR_3 ) ; } 
public void start ( ) throws Exception { logger . info ( STRING_1 ) ; METHOD_1 ( ) ; logger . trace ( STRING_2 ) ; METHOD_2 ( ) ; <START> if ( VAR_1 == null ) { <END> VAR_1 = new ArrayList < TYPE_1 > ( ) ; if ( config != null ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 ) ; VAR_2 . METHOD_3 ( config ) ; VAR_1 . add ( VAR_2 ) ; } } for ( TYPE_1 s : VAR_1 ) { s . start ( ) ; } } 
private boolean METHOD_1 ( ) { int VAR_1 ; try { VAR_1 = METHOD_2 ( ) . getInt ( STRING_1 ) ; <START> } catch ( TYPE_1 e ) { <END> throw new RuntimeException ( e ) ; } return VAR_1 == TYPE_2 . VAR_3 ; } 
public void METHOD_1 ( ) { <START> final TYPE_1 VAR_1 = this . VAR_2 . METHOD_2 ( ) ; <END> VAR_1 . execute ( STRING_1 ) ; } 
public void METHOD_1 ( ) throws IOException , TYPE_1 { try ( TYPE_2 stream = VAR_1 . METHOD_2 ( STRING_1 , STRING_2 , STRING_3 ) ) { TYPE_3 . METHOD_3 ( stream ) ; <START> stream . close ( ) ; <END> } } 
private void METHOD_1 ( ) { try ( TYPE_1 VAR_1 = db . VAR_2 ( ) ) { db . execute ( STRING_1 + VAR_3 ) ; VAR_1 . METHOD_2 ( ) ; } try ( TYPE_1 VAR_1 = db . VAR_2 ( ) ) { <START> db . VAR_4 ( ) . METHOD_3 ( 1 , TimeUnit . VAR_5 ) ; <END> VAR_1 . METHOD_2 ( ) ; } } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 == null ) <END> return TYPE_2 . METHOD_2 ( STRING_1 , METHOD_3 ( ) ) . METHOD_4 ( TYPE_2 . METHOD_2 ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ) ; TYPE_3 VAR_3 = TYPE_3 . getInstance ( TYPE_4 . METHOD_5 ( ) ) ; return VAR_3 . METHOD_6 ( TYPE_2 . METHOD_2 ( STRING_1 , METHOD_3 ( ) ) , TYPE_2 . METHOD_2 ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ) ; } 
void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_1 . get ( ) , 0 ) ; <END> } 
private boolean METHOD_1 ( final TYPE_1 cmd ) { <START> String VAR_1 = cmd . VAR_2 ( ) ; <END> if ( VAR_1 . startsWith ( VAR_3 ) ) { return true ; } return false ; } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( true ) ; <END> TYPE_1 . METHOD_3 ( ) . METHOD_4 ( false ) ; TYPE_2 . METHOD_5 ( 100 ) ; TYPE_3 . METHOD_6 ( ) ; TYPE_4 . METHOD_7 ( ) ; TYPE_5 . METHOD_8 ( ) ; TYPE_2 . METHOD_5 ( ) ; } 
public byte [ ] METHOD_1 ( ) { byte [ ] VAR_1 = VAR_2 == null ? new byte [ ] { } : StringUtils . VAR_3 ( VAR_2 ) ; <START> byte [ ] VAR_4 = StringUtils . VAR_3 ( VAR_5 . toString ( ) ) ; <END> int VAR_6 = 2 + VAR_1 . length + VAR_4 . length ; return ByteBuffer . VAR_7 ( VAR_6 ) . put ( VAR_8 ) . put ( VAR_1 ) . put ( VAR_9 ) . put ( VAR_4 ) . METHOD_2 ( ) ; } 
public TYPE_3 ( Map < String , Object > VAR_2 , TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = METHOD_1 ( ) ; <START> this . VAR_5 = false ; <END> this . VAR_6 = new TYPE_2 < > ( ) ; } 
public void METHOD_1 ( ) { long VAR_1 = VAR_2 . value ; long VAR_3 = VAR_4 . value ; <START> TYPE_1 . time . TYPE_2 VAR_6 = TYPE_1 . time . TYPE_2 . METHOD_2 ( VAR_1 - ( VAR_1 % VAR_3 ) ) ; <END> out . value = VAR_6 . METHOD_3 ( ) ; } 
public TYPE_1 METHOD_1 ( Map . Entry < TYPE_2 , TYPE_1 > entry ) { action . VAR_1 ( entry . getKey ( ) , entry . getValue ( ) ) ; <START> return entry . getValue ( ) ; <END> } 
private TYPE_1 user ( TYPE_6 . TYPE_7 ... VAR_1 ) { TYPE_4 . TYPE_8 VAR_2 = new TYPE_4 . TYPE_8 ( ) { @Override public TYPE_4 create ( final TYPE_1 VAR_3 , final String VAR_4 ) { <START> return new TYPE_4 ( VAR_5 , VAR_3 , VAR_4 , null ) ; <END> } } ; return new TYPE_1 ( TYPE_9 < TYPE_6 . TYPE_7 > METHOD_1 ( ) , TYPE_9 < TYPE_6 . TYPE_7 > METHOD_1 ( ) , VAR_2 , new TYPE_5 ( VAR_1 ) , METHOD_2 ( ) ) ; } 
private boolean METHOD_1 ( TYPE_1 connection ) { Thread VAR_1 = Thread . VAR_1 ( ) ; String VAR_2 = VAR_1 . getName ( ) ; <START> String VAR_3 = String . format ( STRING_1 , VAR_2 , connection . VAR_4 ( ) , VAR_5 ) ; <END> VAR_1 . METHOD_2 ( VAR_3 ) ; try { return connection . VAR_6 ( ) ; } finally { VAR_1 . METHOD_2 ( VAR_2 ) ; } } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( ) ) { if ( METHOD_3 ( ) . getStatus ( ) != TYPE_4 . TYPE_2 && VAR_4 . METHOD_4 ( ) ) { return METHOD_5 ( TYPE_3 . VAR_6 ) ; } <START> if ( ! METHOD_6 ( ) ) { <END> return false ; } return METHOD_7 ( VAR_1 . METHOD_8 ( ) ) ; } return true ; } 
public TYPE_2 ( TYPE_1 from , TYPE_1 to ) { this . VAR_2 = from ; <START> this . VAR_3 = to ; <END> this . VAR_4 = TYPE_3 . VAR_6 ; } 
public void METHOD_1 ( ) { if ( state == TYPE_4 . VAR_2 ) { state = TYPE_4 . VAR_3 ; TYPE_1 < TYPE_2 > VAR_4 = METHOD_2 ( new TYPE_3 ( VAR_5 , VAR_6 , VAR_7 ) ) ; <START> VAR_4 . METHOD_3 ( ) ; <END> VAR_8 = VAR_4 . iterator ( ) ; } } 
public void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> METHOD_2 ( VAR_1 ) ; } 
public TYPE_1 build ( ) { <START> List < TYPE_2 < TYPE_3 > > VAR_1 = VAR_2 ? METHOD_1 ( this . VAR_1 , VAR_3 - > ! VAR_3 . METHOD_2 ( ) ) : this . VAR_1 ; <END> return new TYPE_1 ( VAR_4 , VAR_1 , VAR_5 ) ; } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { <START> return METHOD_2 ( ) . get ( VAR_1 . toString ( ) ) ; <END> } 
<START> public synchronized TYPE_1 METHOD_1 ( TYPE_1 uri , TYPE_2 VAR_1 ) { <END> TYPE_3 args = new TYPE_3 ( uri ) ; synchronized ( VAR_2 ) { TYPE_4 db = VAR_3 . METHOD_2 ( ) ; final long VAR_4 = db . VAR_5 ( args . table , null , VAR_1 ) ; if ( VAR_4 <= 0 ) return null ; uri = TYPE_5 . METHOD_3 ( uri , VAR_4 ) ; METHOD_4 ( uri ) ; return uri ; } } 
protected void METHOD_1 ( TYPE_1 m ) { try { TYPE_2 VAR_1 = METHOD_2 ( new TYPE_1 [ ] { m } ) ; <START> TYPE_3 VAR_2 = METHOD_3 ( ) ; <END> boolean VAR_3 = TYPE_4 . METHOD_4 ( METHOD_5 ( ) ) ; if ( VAR_3 ) { TYPE_4 . METHOD_6 ( VAR_1 , VAR_2 ) ; TYPE_4 . METHOD_7 ( VAR_1 , VAR_2 ) ; } } catch ( TYPE_5 VAR_4 ) { TYPE_6 . log ( VAR_4 ) ; } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_2 TYPE_1 VAR_2 ) throws Exception { System . VAR_3 ( STRING_1 , STRING_2 <START> + STRING_3 ) ; <END> TYPE_2 . METHOD_2 ( STRING_4 , STRING_5 , getPath ( STRING_6 ) ) ; assertThat ( STRING_7 , VAR_2 . METHOD_3 ( ) , is ( VAR_4 ) ) ; assertThat ( STRING_8 , VAR_1 . METHOD_3 ( ) , is ( "" ) ) ; } 
private static Map < String , String > METHOD_1 ( final TYPE_1 < String , String > VAR_1 ) { final HashMap < String , String > result = new HashMap < > ( ) ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 - > { <START> System . out . println ( VAR_2 ) ; <END> result . put ( VAR_2 . key , VAR_2 . value ) ; } ) ; return result ; } 
public TYPE_1 METHOD_1 ( TYPE_2 request , String name , long VAR_1 ) { <START> TYPE_1 VAR_2 ; <END> if ( VAR_3 ) { VAR_2 = new TYPE_3 ( name , VAR_1 , VAR_4 ) ; } else if ( VAR_5 ) { VAR_2 = new TYPE_4 ( name , VAR_1 , VAR_6 , VAR_4 ) ; } else { VAR_2 = new TYPE_5 ( name , VAR_1 ) ; } VAR_2 . METHOD_2 ( VAR_7 ) ; List < TYPE_6 > list = METHOD_3 ( request ) ; list . add ( VAR_2 ) ; return VAR_2 ; } 
public boolean METHOD_1 ( Date VAR_1 ) { if ( VAR_2 != null && VAR_3 != null && VAR_2 . METHOD_2 ( VAR_3 ) ) { throw new TYPE_1 ( STRING_1 , ( Object [ ] ) null ) ; } if ( METHOD_3 ( ) ) { return false ; } if ( VAR_1 == null ) { VAR_1 = new Date ( ) ; } <START> if ( VAR_4 == null || ! METHOD_4 ( VAR_1 ) || VAR_2 == null ) { <END> return false ; } return VAR_1 . METHOD_2 ( VAR_2 ) ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! VAR_2 . isEmpty ( ) ) for <END> ( TYPE_2 VAR_3 : VAR_2 ) { VAR_3 . METHOD_1 ( this , VAR_1 ) ; } } 
public void METHOD_1 ( TYPE_1 event ) { TYPE_2 VAR_1 = null ; if ( event . VAR_2 ( ) instanceof TYPE_2 ) { VAR_1 = ( TYPE_2 ) event . VAR_2 ( ) ; } if ( VAR_1 != null ) { boolean VAR_3 = VAR_1 . METHOD_2 ( ) ; METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ! VAR_3 ) ; METHOD_4 ( ) ; } else { METHOD_3 ( ) ; } event . VAR_4 ( ) ; <START> event . VAR_5 ( ) ; <END> } 
<START> public void METHOD_1 ( TYPE_1 VAR_1 ) throws IllegalStateException { <END> if ( VAR_2 == null ) { throw new IllegalStateException ( STRING_1 ) ; } if ( VAR_1 == null ) { VAR_1 = TYPE_1 . NONE ; } if ( VAR_3 . equals ( VAR_1 ) ) { return ; } VAR_3 = VAR_1 ; TYPE_2 . METHOD_2 ( VAR_1 . getValue ( ) ) ; } 
<START> public synchronized Long METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; } 
public TYPE_2 ( TYPE_1 writer , String VAR_2 ) { this . writer = writer ; <START> this . VAR_2 = VAR_2 != null ? VAR_2 . METHOD_1 ( ) : null ; <END> } 
public String METHOD_1 ( ) { <START> return ( ( TYPE_1 ) entity . VAR_1 ( ) ) . METHOD_2 ( ) + "" ; <END> } 
public static Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] { { new TYPE_1 ( STRING_1 , STRING_2 ) , <START> STRING_3 , <END> new TYPE_2 ( INT_1 , INT_2 ) } , } ; } 
protected TYPE_2 ( final Map < String , TYPE_1 > VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> } 
public final boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ( VAR_2 && METHOD_2 ( ) ) || VAR_3 . METHOD_1 ( VAR_1 ) ; <END> } 
private void METHOD_1 ( org . VAR_1 . VAR_2 . VAR_3 . File resource , TYPE_1 context ) { TYPE_2 < Integer > VAR_4 = context . VAR_5 ( resource , TYPE_3 . VAR_7 ) ; if ( VAR_4 != null ) { <START> double VAR_8 = context . VAR_5 ( resource , TYPE_3 . VAR_7 ) . getValue ( ) ; <END> context . VAR_9 ( resource , METHOD_2 ( resource , context ) ) ; context . VAR_9 ( resource , VAR_10 , VAR_8 ) ; context . VAR_9 ( resource , VAR_11 , VAR_8 ) ; } } 
TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 resource = METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; <START> if ( resource != null ) { <END> return METHOD_4 ( VAR_2 . METHOD_5 ( resource . VAR_3 ( ) ) . METHOD_6 ( ) ) ; } return null ; } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 < > ( TYPE_2 . class ) ; VAR_2 = METHOD_2 ( TYPE_3 . class ) ; <START> <END> } 
public boolean METHOD_1 ( int VAR_1 ) { if ( VAR_1 == TYPE_3 . VAR_3 ) { if ( METHOD_2 ( ) != null ) { METHOD_3 ( true ) ; } else { TYPE_1 . METHOD_4 ( TYPE_2 . METHOD_5 ( ) . METHOD_6 ( ) , Messages . TYPE_4 , Messages . TYPE_5 ) ; } return true ; } else if ( VAR_1 == TYPE_3 . VAR_6 ) { <START> if ( ! VAR_7 . METHOD_7 ( ) ) { <END> METHOD_8 ( ) ; return false ; } return true ; } return false ; } 
public TYPE_1 apply ( TYPE_2 VAR_1 ) { <START> VAR_2 = true ; <END> return null ; } 
public boolean METHOD_1 ( Object request , Object target ) { int VAR_1 = <START> 0 ; <END> if ( request instanceof TYPE_1 ) { VAR_1 = ( ( TYPE_1 ) request ) . METHOD_2 ( ) ; } else if ( request instanceof TYPE_2 ) { VAR_1 = ( ( TYPE_2 ) request ) . VAR_2 ; } return ( VAR_1 == SWT . VAR_3 + SWT . VAR_4 ) ; } 
public Object METHOD_1 ( Object VAR_1 ) { <START> METHOD_2 ( ) ; <END> if ( VAR_1 == null ) return null ; return VAR_2 . METHOD_1 ( VAR_3 . METHOD_3 ( VAR_1 ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) { <START> List < TYPE_5 > VAR_5 = new ArrayList < > ( ) ; <END> for ( TYPE_6 VAR_6 : VAR_7 ) { VAR_5 . add ( METHOD_2 ( VAR_1 , VAR_3 , VAR_4 , VAR_6 ) ) ; } return new TYPE_1 ( VAR_5 , VAR_8 ) ; } 
public final String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < Object > ... args ) { assert args . length == 1 : STRING_1 + args . length ; Object VAR_2 = args [ 0 ] . value ( ) ; <START> return null != VAR_2 ? type : TYPE_4 . TYPE_5 . getName ( ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( STRING_1 ) ; if ( VAR_1 . METHOD_3 ( ) ) return null ; <START> return ( TYPE_1 ) TYPE_3 . METHOD_4 ( VAR_1 ) ; <END> } 
private TYPE_1 < Long > METHOD_1 ( TYPE_2 channel , TYPE_3 VAR_1 ) { return METHOD_2 ( VAR_2 . VAR_3 , VAR_4 - > VAR_5 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , <START> METHOD_6 ( VAR_1 . METHOD_4 ( ) , TYPE_4 . METHOD_7 ( channel ) ) , <END> METHOD_8 ( VAR_1 ) ) , uri , LOGGER , VAR_6 ) ; } 
public void METHOD_1 ( ) throws Exception { String VAR_1 = METHOD_2 ( STRING_1 ) ; TYPE_1 resource = TYPE_3 . TYPE_4 . METHOD_3 ( VAR_1 , TYPE_1 . class ) ; assertNotNull ( resource ) ; assertEquals ( STRING_2 , resource . getId ( ) ) ; <START> assertEquals ( STRING_3 , resource . VAR_2 ( ) ) ; <END> } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; <START> throw new RuntimeException ( STRING_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 < ? > message , TYPE_2 VAR_1 ) throws Exception { if ( METHOD_2 ( VAR_1 ) ) { String VAR_2 = ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) . toString ( ) ; TYPE_4 < T > VAR_3 = METHOD_4 ( VAR_2 ) ; <START> if ( VAR_3 != null ) { <END> VAR_3 . METHOD_5 ( message ) ; } else { logger . debug ( STRING_1 , VAR_2 , message ) ; } } } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; METHOD_3 ( ) . METHOD_4 ( VAR_1 != null && VAR_1 . METHOD_5 ( ) <START> && VAR_1 . METHOD_6 ( ) != null <END> && TYPE_2 . VAR_3 . METHOD_7 ( VAR_1 . METHOD_6 ( ) ) <= 0 ) ; } 
public void METHOD_1 ( Boolean VAR_1 ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { System . VAR_2 ( VAR_3 , STRING_1 ) ; } else { System . VAR_4 ( VAR_3 ) ; } <START> this . VAR_1 = VAR_1 ; <END> } 
public static String METHOD_1 ( final int value ) { switch ( value ) { case VAR_1 : return STRING_1 ; case VAR_2 : return STRING_2 ; case VAR_3 : return STRING_3 ; default : break ; } <START> return null ; <END> } 
protected boolean METHOD_1 ( ) { <START> return StringUtils . equals ( METHOD_2 ( ) . METHOD_3 ( ) , getParameters ( ) . METHOD_4 ( ) ) ; <END> } 
public static boolean METHOD_1 ( TYPE_1 client , String VAR_1 , TYPE_2 VAR_2 , TYPE_3 . Status VAR_3 ) throws TYPE_4 , InterruptedException { for ( int VAR_4 = 0 ; VAR_4 < INT_1 ; VAR_4 ++ ) { TYPE_3 . Status status = METHOD_2 ( client , VAR_1 , VAR_2 ) ; logger . info ( STRING_1 + status ) ; if ( status == VAR_3 ) { return true ; } <START> TimeUnit . VAR_5 . METHOD_3 ( 5 ) ; <END> } return false ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> TYPE_2 . METHOD_2 ( this , TYPE_6 . VAR_2 , TYPE_6 . VAR_3 , TYPE_5 . VAR_5 ) ; <END> VAR_6 = TYPE_3 . METHOD_3 ( TYPE_4 . class ) ; METHOD_4 ( ) ; } 
public static final void METHOD_1 ( TYPE_1 group , TYPE_2 m ) { for ( TYPE_3 VAR_1 : group . VAR_2 ( ) ) { METHOD_1 ( VAR_1 , m ) ; } for ( TYPE_1 VAR_3 : group . VAR_4 ( ) ) { <START> for ( TYPE_3 VAR_1 : VAR_3 . METHOD_2 ( ) ) { <END> METHOD_1 ( VAR_1 , m ) ; } } } 
public void METHOD_1 ( TYPE_1 task ) { <START> VAR_1 . put ( task . VAR_2 ( ) , task ) ; <END> } 
public static TYPE_1 METHOD_1 ( String value ) { <START> TYPE_1 [ ] VAR_1 = TYPE_1 . values ( ) ; <END> for ( TYPE_1 item : VAR_1 ) { if ( item . toString ( ) . equalsIgnoreCase ( value ) ) { return item ; } } return ( TYPE_1 ) TYPE_2 . METHOD_2 ( value , VAR_2 ) ; } 
protected static void METHOD_1 ( Map < String , Map < TYPE_1 , List < TYPE_2 > > > VAR_1 , String location , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> Map < TYPE_1 , List < TYPE_2 > > VAR_4 = VAR_1 . METHOD_2 ( location , VAR_5 - > new HashMap < > ( ) ) ; List < TYPE_2 > VAR_6 = VAR_4 . METHOD_2 ( VAR_2 , VAR_5 - > new ArrayList < > ( ) ) ; <END> VAR_6 . add ( VAR_3 ) ; } 
<START> public TYPE_5 ( <END> TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 reader , TYPE_4 VAR_4 ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; this . reader = METHOD_1 ( reader ) ; this . VAR_4 = METHOD_1 ( VAR_4 ) ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 location ) { super ( VAR_2 , TYPE_3 . METHOD_1 ( ) . METHOD_2 ( ) ) ; <START> System . out . println ( STRING_1 + TYPE_3 . METHOD_1 ( ) . METHOD_2 ( ) ) ; <END> METHOD_3 ( location , null , null , null , null ) ; } 
private String METHOD_1 ( ) { StringBuilder VAR_1 = new StringBuilder ( "" ) ; <START> for ( TYPE_1 a : TYPE_3 < TYPE_1 > METHOD_2 ( METHOD_3 ( ) ) ) <END> { if ( a . VAR_3 ( ) == TYPE_2 . VAR_5 ) { VAR_1 . append ( a . VAR_6 ( ) ) . append ( STRING_1 ) ; } } return VAR_1 . substring ( 0 , VAR_1 . length ( ) - 2 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> VAR_2 = new TYPE_2 ( ) ; } 
void METHOD_1 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 e ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> if ( 0 <= VAR_1 && VAR_3 == TYPE_3 . TYPE_2 . VAR_6 ) { <END> String n = VAR_2 . getValue ( VAR_1 ) ; METHOD_3 ( VAR_7 , ! n . isEmpty ( ) ? n : null ) ; } } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 == null ) { VAR_2 = METHOD_2 ( ) ; } String VAR_3 = VAR_1 . getName ( ) ; final int VAR_4 ; try { VAR_4 = VAR_2 . METHOD_3 ( VAR_3 , VAR_1 ) ; <START> System . out . println ( STRING_1 + VAR_4 + STRING_2 ) ; <END> } catch ( IOException | TYPE_2 e ) { throw new RuntimeException ( e ) ; } return Integer . toString ( VAR_4 ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { <START> if ( ! METHOD_2 ( VAR_1 , false ) && ( METHOD_3 ( VAR_1 ) || METHOD_4 ( VAR_1 ) ) ) { <END> return true ; } if ( ! METHOD_2 ( VAR_1 , false ) && METHOD_5 ( VAR_1 ) ) { return true ; } while ( VAR_1 != null ) { if ( VAR_1 . equals ( VAR_2 ) ) { return true ; } VAR_1 = VAR_1 . METHOD_6 ( ) ; } } return false ; } 
TYPE_3 ( final int VAR_2 ) { this . VAR_3 = new ArrayList < TYPE_1 > ( VAR_2 ) ; <START> for ( int index = 0 ; index < VAR_2 ; index += 1 ) { <END> this . VAR_3 . add ( index , new TYPE_2 ( index ) ) ; } } 
<START> @Override public String METHOD_1 ( String VAR_1 ) { <END> return VAR_1 ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <START> throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , <END> TYPE_7 { boolean VAR_2 = new TYPE_8 ( VAR_1 ) . VAR_3 || new TYPE_9 ( VAR_1 ) . VAR_4 . length ( ) > 0 ; return VAR_2 ? TYPE_1 . METHOD_2 ( new TYPE_10 ( VAR_1 ) ) : null ; } 
public T METHOD_1 ( int value ) { METHOD_2 ( ) . VAR_1 = String . valueOf ( value ) ; METHOD_2 ( ) . VAR_2 = TYPE_1 . TYPE_2 . VAR_5 ; <START> return METHOD_3 ( ) ; <END> } 
<START> @Override public void METHOD_1 ( ) throws Exception { <END> } 
boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { boolean VAR_3 = false ; for ( TYPE_2 VAR_4 : VAR_1 . METHOD_2 ( ) ) { <START> VAR_3 |= VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) . equals ( VAR_2 . METHOD_4 ( ) ) ; <END> } return VAR_3 ; } 
public void METHOD_1 ( ) <START> throws Exception { <END> VAR_1 = TYPE_1 . METHOD_2 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( ) ; VAR_3 = VAR_2 . METHOD_4 ( ) ; VAR_4 = new TYPE_3 ( VAR_1 , VAR_5 ) ; VAR_4 . start ( ) ; } 
public boolean METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 . get ( ) , STRING_1 ) ; <END> METHOD_3 ( STRING_2 ) ; Optional < Boolean > result = METHOD_4 ( this : : METHOD_5 ) ; return result . VAR_2 ( ( ) - > state . get ( ) != TYPE_1 . VAR_4 || VAR_5 . METHOD_6 ( ) ) ; } 
<START> public TYPE_3 ( String VAR_2 , String VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = new TYPE_1 ( this ) ; this . start = new TYPE_2 ( this ) ; } 
private double METHOD_1 ( double x ) { try { TYPE_1 VAR_1 = new TYPE_1 ( ) ; return VAR_1 . METHOD_1 ( x ) ; <START> } catch ( Exception ex ) { <END> return Double . TYPE_2 ; } } 
public Response METHOD_1 ( ANNOTATION_1 ( VAR_1 . VAR_2 ) TYPE_1 VAR_3 ) { <START> if ( VAR_4 . METHOD_2 ( ) < 2 ) { <END> return Response . status ( Response . Status . VAR_5 ) . build ( ) ; } return Response . VAR_6 ( ) . build ( ) ; } 
public void METHOD_1 ( TYPE_1 user , String VAR_1 , String VAR_2 ) throws TYPE_2 { <START> TYPE_3 . METHOD_2 ( user . VAR_3 ( ) , VAR_1 , user . VAR_4 ( ) ) ; <END> VAR_5 . METHOD_1 ( user , VAR_1 , VAR_2 ) ; } 
public void METHOD_1 ( long VAR_1 ) { if ( VAR_2 == null ) { <START> Optional < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( VAR_4 ) ; <END> METHOD_3 ( VAR_2 . isPresent ( ) , STRING_1 ) ; this . VAR_2 = VAR_2 . get ( ) ; } if ( VAR_1 > 0 ) { VAR_2 . METHOD_4 ( VAR_1 ) ; } else { VAR_2 . METHOD_5 ( - VAR_1 ) ; } } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( ) . assertThat ( new TYPE_1 ( ) ) <START> . METHOD_3 ( p - > METHOD_4 ( p , TYPE_2 . METHOD_5 ( ) ) ) <END> . METHOD_6 ( ) ; } 
<START> public void METHOD_1 ( int count ) { <END> VAR_1 = count ; } 
public TYPE_2 ( ) { <START> METHOD_1 ( TYPE_1 . METHOD_2 ( p - > ! VAR_2 . METHOD_3 ( ) . equals ( p ) ) ) ; <END> } 
private boolean METHOD_1 ( ) { <START> return ( VAR_1 == null ) <END> || ( VAR_1 . METHOD_2 ( ) == METHOD_3 ( ) ) ; } 
<START> void METHOD_1 ( Object VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> TYPE_3 < TYPE_2 > VAR_2 = new TYPE_4 < > ( VAR_3 ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; return new TYPE_1 ( this , VAR_2 ) ; } 
private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 , TYPE_1 child ) { if ( null != child && TYPE_2 . METHOD_2 ( VAR_2 ) ) { for ( TYPE_1 VAR_3 : VAR_2 ) { <START> if ( child . VAR_4 ( ) . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) == 0 ) { <END> VAR_1 . add ( VAR_3 ) ; VAR_2 . remove ( VAR_3 ) ; return VAR_3 ; } } } return null ; } 
<START> private void METHOD_1 ( final byte [ ] source ) { <END> final long VAR_1 = TYPE_1 . METHOD_2 ( source ) ; final int version = TYPE_2 . read ( source ) ; final byte [ ] b = TYPE_2 . METHOD_3 ( version , source ) ; final TYPE_3 reader = new TYPE_3 ( b ) ; final TYPE_4 VAR_2 = METHOD_4 ( VAR_1 , reader . VAR_3 ( ) ) ; reader . VAR_4 ( VAR_2 , 0 ) ; } 
public void close ( ) throws TYPE_1 { if ( ! VAR_1 && VAR_2 instanceof TYPE_2 ) { ( ( TYPE_2 ) VAR_2 ) . close ( ) ; } <START> } <END> 
public TYPE_1 METHOD_1 ( File f , TYPE_3 . TYPE_4 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) <END> return TYPE_1 . VAR_2 ; else if ( VAR_1 . METHOD_3 ( ) ) { return TYPE_1 . VAR_3 ; } else if ( VAR_1 . METHOD_4 ( ) ) return TYPE_1 . VAR_4 ; else return TYPE_1 . VAR_5 ; } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { String type = VAR_2 . type ( ) . name ( ) . METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( ) ) { for ( int i = 0 ; i < VAR_2 . METHOD_4 ( ) ; i ++ ) { <START> type += STRING_1 ; <END> } } return METHOD_1 ( VAR_1 , type ) ; } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 , VAR_1 , VAR_2 , <START> TYPE_1 . get ( TYPE_2 . METHOD_3 ( ) , TYPE_3 : : METHOD_4 ) . METHOD_5 ( TYPE_3 . TYPE_1 . TYPE_4 . VAR_5 ) ) ; <END> } 
protected void METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; <START> TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( TYPE_6 . TYPE_5 . VAR_5 , STRING_1 ) ; <END> if ( VAR_2 instanceof TYPE_3 ) { METHOD_4 ( ( TYPE_3 ) VAR_2 ) ; } else { ( ( TYPE_4 ) METHOD_5 ( ) ) . METHOD_6 ( 0 ) ; } super . METHOD_1 ( ) ; } 
@Override public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_5 . TYPE_7 VAR_3 , Context VAR_4 , TYPE_5 . TYPE_6 VAR_5 ) { if ( VAR_6 == null ) { VAR_6 = new TYPE_4 ( VAR_7 ) ; VAR_6 . METHOD_2 ( TYPE_8 . VAR_9 ) ; } VAR_6 . setText ( VAR_2 . getKey ( ) . toString ( ) ) ; <START> VAR_7 . METHOD_3 ( VAR_6 ) ; <END> VAR_5 . METHOD_4 ( ) ; } 
public String METHOD_1 ( TYPE_1 < ? > element ) { <START> return "" ; <END> } 
public TYPE_3 ( ) { <START> TYPE_1 . METHOD_1 ( ) ; <END> VAR_2 = new TYPE_2 ( ) ; } 
<START> void METHOD_1 ( String to ) { <END> if ( to != null && ! "" . equals ( to ) ) { to = to . VAR_1 ( STRING_1 , STRING_2 ) ; props . put ( STRING_3 , to ) ; } } 
<START> private void METHOD_1 ( ) throws TYPE_1 { <END> when ( VAR_1 . METHOD_2 ( VAR_2 + VAR_3 , VAR_2 + VAR_4 , VAR_2 + VAR_5 , VAR_2 + VAR_6 ) ) . METHOD_3 ( new TYPE_2 ( VAR_7 ) ) ; when ( VAR_1 . METHOD_2 ( VAR_2 + VAR_3 , VAR_2 + VAR_4 , VAR_2 + VAR_5 , VAR_2 + VAR_8 ) ) . METHOD_3 ( new TYPE_2 ( VAR_9 ) ) ; } 
public TYPE_1 METHOD_1 ( Object [ ] VAR_1 ) { String VAR_2 = "" ; <START> if ( VAR_1 . length == 0 ) { <END> VAR_2 = VAR_3 ; } else { final Object VAR_4 = VAR_1 [ 0 ] ; if ( VAR_1 . length != 1 || false == VAR_4 instanceof TYPE_2 || ( VAR_4 instanceof TYPE_2 && false == ( ( TYPE_2 ) VAR_4 ) . getType ( ) instanceof TYPE_3 ) ) { VAR_2 = Messages . TYPE_4 ; } } return METHOD_2 ( VAR_2 ) ; } 
public boolean METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 == VAR_3 ) { boolean VAR_4 = TYPE_2 . METHOD_2 ( VAR_2 ) ; boolean VAR_5 = TYPE_2 . METHOD_3 ( VAR_2 ) ; TYPE_3 filter = METHOD_4 ( ) ; boolean VAR_6 = filter == null ; boolean VAR_7 = TYPE_2 . METHOD_5 ( VAR_2 , filter ) ; <START> return VAR_4 && ( VAR_5 || VAR_6 || VAR_7 ) ; <END> } return false ; } 
public TYPE_1 < TYPE_2 , TYPE_2 > METHOD_1 ( ) { return new TYPE_3 < TYPE_2 > ( ) { ANNOTATION_1 ( VAR_1 = STRING_1 , VAR_2 = STRING_2 ) @Override public TYPE_2 METHOD_2 ( TYPE_2 VAR_3 ) { <START> TYPE_4 VAR_4 = TYPE_5 . METHOD_3 ( VAR_3 ) ; <END> if ( TYPE_6 . METHOD_4 ( VAR_4 . METHOD_5 ( ) ) ) { VAR_4 . METHOD_6 ( TYPE_8 . VAR_6 ) ; } TYPE_2 VAR_7 = TYPE_5 . METHOD_7 ( VAR_4 , TYPE_7 . METHOD_8 ( ) . METHOD_9 ( ) ) ; return VAR_7 ; } } ; } 
private void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( new TYPE_1 ( ) { @Override public void run ( ) <END> { TYPE_2 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null && ! VAR_1 . METHOD_5 ( ) ) { VAR_2 . METHOD_6 ( ) ; } } } ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { for ( TYPE_3 VAR_3 : TYPE_3 . METHOD_2 ( VAR_2 ) ) { if ( VAR_3 . METHOD_3 ( VAR_1 ) ) { <START> HashMap < String , TYPE_1 > VAR_4 = TYPE_4 . METHOD_4 ( ) ; <END> for ( TYPE_5 VAR_5 : VAR_3 . METHOD_5 ( VAR_1 ) ) { VAR_4 . put ( VAR_5 . name , VAR_5 . location ) ; } VAR_3 . METHOD_6 ( VAR_4 ) ; return true ; } } return false ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 uri ) { if ( TYPE_8 . VAR_3 . VAR_4 < TYPE_8 . VAR_5 . VAR_6 ) { final TYPE_3 VAR_7 = uri . toString ( ) . startsWith ( TYPE_6 . TYPE_7 . VAR_8 . toString ( ) ) ? TYPE_6 . TYPE_7 . METHOD_2 ( VAR_1 , uri ) <START> : uri ; <END> return METHOD_3 ( VAR_1 , VAR_7 ) ; } else { return TYPE_5 . get ( VAR_1 , uri ) ; } } 
public Collection < String > METHOD_1 ( String VAR_1 ) { <START> List < String > VAR_2 = VAR_3 . get ( VAR_1 ) ; <END> if ( VAR_2 == null ) { return Collections . VAR_4 ( ) ; } return VAR_2 ; } 
private void METHOD_1 ( final TYPE_1 resource ) { TYPE_2 project = resource . VAR_1 ( ) ; TYPE_3 VAR_2 = TYPE_3 . METHOD_2 ( project ) ; if ( VAR_2 == null ) return ; TYPE_4 VAR_3 = VAR_2 . METHOD_3 ( resource ) ; if ( VAR_3 != VAR_4 ) <START> { <END> METHOD_4 ( VAR_3 ) ; } } 
public void apply ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_1 ( TYPE_2 . VAR_3 ) ; <START> VAR_1 . METHOD_2 ( 1 ) ; <END> VAR_1 . METHOD_3 ( data ) ; } 
private List < TYPE_1 > METHOD_1 ( TYPE_2 session , TYPE_3 resource , TYPE_4 VAR_1 ) { final List < TYPE_1 > VAR_2 = TYPE_5 . METHOD_2 ( ) ; VAR_2 . add ( TYPE_1 . VAR_3 ) ; <START> return VAR_2 ; <END> } 
<START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , byte [ ] VAR_2 ) throws TYPE_3 { <END> TYPE_4 VAR_3 = this . METHOD_2 ( null , VAR_2 , true ) ; if ( VAR_3 . VAR_4 == TYPE_5 . VAR_6 ) { return TYPE_1 . VAR_7 ; } else if ( VAR_3 . VAR_4 == TYPE_5 . VAR_8 ) { return TYPE_1 . VAR_7 ; } return TYPE_1 . METHOD_3 ( VAR_3 . VAR_9 / INT_1 , VAR_3 . VAR_10 , TYPE_6 . VAR_12 ) ; } 
void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> if ( this . VAR_1 != null ) { VAR_1 . METHOD_3 ( ) ; } } 
public void METHOD_1 ( Set < String > VAR_1 ) { Optional < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( true ) ; <START> Set < TYPE_2 > VAR_4 = new HashSet < > ( ) ; <END> if ( VAR_2 . isPresent ( ) ) { for ( String VAR_5 : VAR_1 ) { VAR_4 . addAll ( VAR_2 . get ( ) . METHOD_3 ( VAR_5 , TYPE_3 . create ( "" ) ) ) ; } } VAR_4 . forEach ( super : : METHOD_4 ) ; } 
public boolean METHOD_1 ( String VAR_1 ) { <START> List < String > VAR_2 = ImmutableList . of ( STRING_1 ) ; <END> for ( String path : VAR_2 ) { if ( VAR_1 . startsWith ( path ) && ! VAR_1 . equals ( path ) ) { return true ; } } return false ; } 
public void execute ( TYPE_1 command ) { final TYPE_1 VAR_1 = METHOD_1 ( command , VAR_2 ) ; try { super . execute ( METHOD_2 ( VAR_1 ) ) ; <START> } catch ( TYPE_2 e ) { <END> VAR_2 . METHOD_3 ( ) ; throw e ; } } 
public void METHOD_1 ( ) { <START> final int [ ] VAR_1 = new int [ ] { INT_1 } ; <END> assertEquals ( STRING_1 , METHOD_2 ( new TYPE_1 ( TYPE_2 . METHOD_3 ( INT_2 , VAR_1 ) ) ) ) ; } 
private void METHOD_1 ( Context context , TYPE_1 VAR_1 ) { <START> ( ( TYPE_2 ) context ) . METHOD_2 ( ) ; <END> TYPE_3 VAR_2 = new TYPE_3 ( context , TYPE_4 . class ) ; TYPE_5 . getInstance ( ) . METHOD_3 ( VAR_1 ) ; context . VAR_3 ( VAR_2 ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( ) . getParameters ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_2 . VAR_2 ) ; TYPE_1 . METHOD_5 ( <START> METHOD_2 ( ) . getParameters ( ) . METHOD_6 ( ) , TYPE_2 . VAR_2 ) ; <END> } 
public void METHOD_1 ( ) { Set < TYPE_1 < TYPE_2 > > VAR_1 = VAR_2 . METHOD_2 ( METHOD_3 ( ) , VAR_3 ) ; assertEquals ( VAR_4 , VAR_1 . isEmpty ( ) ) ; if ( VAR_4 ) { assertTrue ( VAR_1 . isEmpty ( ) ) ; } else { assertEquals ( 1 , VAR_1 . size ( ) ) ; <START> assertTrue ( VAR_1 . iterator ( ) . next ( ) . getMessage ( ) . equals ( message ) ) ; <END> } } 
public TYPE_1 METHOD_1 ( ) throws IOException { VAR_1 = null ; VAR_2 = null ; while ( true ) { METHOD_2 ( ) ; if ( VAR_1 != null ) { return TYPE_1 . VAR_3 ; } METHOD_3 ( ) ; if ( VAR_2 != null ) { return TYPE_1 . LOG ; } <START> if ( VAR_4 == null || VAR_4 . METHOD_4 ( ) || VAR_4 . VAR_5 . METHOD_5 ( ) ) { <END> return TYPE_1 . VAR_6 ; } } } 
public boolean hasNext ( ) { if ( VAR_1 != null ) { return true ; } try { VAR_1 = METHOD_1 ( ) ; return true ; } catch ( TYPE_1 e ) { <START> return false ; <END> } } 
public void METHOD_1 ( TYPE_1 monitor ) throws TYPE_2 { if ( monitor == null ) <START> monitor = new TYPE_3 ( ) ; <END> TYPE_4 VAR_1 = TYPE_4 . METHOD_2 ( monitor , STRING_1 , this . VAR_2 . length ) ; for ( TYPE_5 VAR_3 : this . VAR_2 ) { METHOD_3 ( VAR_3 , VAR_1 . METHOD_4 ( 1 ) ) ; } } 
public void METHOD_1 ( ) throws InterruptedException { METHOD_2 ( ) . METHOD_3 ( VAR_1 . id ( ) ) ; <START> METHOD_4 ( VAR_2 ) ; <END> METHOD_5 ( VAR_2 . id ( ) ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 != null ) { this . VAR_1 = VAR_1 ; } <END> return this ; } 
<START> private boolean METHOD_1 ( Type type ) { <END> return type . VAR_1 ( VAR_2 ) || type . VAR_1 ( VAR_3 ) ; } 
<START> public synchronized TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { throw new TYPE_1 . TYPE_3 ( STRING_1 ) ; } return VAR_1 ; } 
<START> public TYPE_1 ( String path , String VAR_2 , long VAR_3 ) { <END> this . path = METHOD_1 ( path , STRING_1 ) ; this . VAR_2 = METHOD_1 ( VAR_2 , STRING_2 , path ) ; this . VAR_3 = VAR_3 ; } 
public <START> double ANNOTATION_1 [ ] METHOD_1 ( ) <END> { return VAR_1 ; } 
<START> public void METHOD_1 ( int j , TYPE_1 VAR_1 ) { <END> int VAR_2 = VAR_3 [ j ] , i = VAR_4 [ VAR_2 ] ; while ( i < VAR_3 [ j + 1 ] ) { VAR_1 . apply ( VAR_4 [ i ] , j , values [ i ] ) ; i ++ ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; if ( TYPE_3 . class . METHOD_2 ( VAR_1 . getClass ( ) ) ) { <START> this . VAR_1 = ( TYPE_3 ) VAR_1 ; <END> } else { Assert . VAR_3 ( TYPE_2 . class , VAR_1 , STRING_2 + TYPE_2 . class . getName ( ) + STRING_3 + TYPE_3 . class . getName ( ) ) ; this . VAR_1 = VAR_1 ; } return this . execute ( ) ; } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } VAR_1 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_1 . equals ( STRING_2 ) ) { <END> return VAR_2 ; } if ( VAR_1 . equals ( STRING_3 ) || VAR_1 . equals ( STRING_4 ) ) { return VAR_3 ; } throw new IllegalArgumentException ( STRING_5 + VAR_1 + STRING_6 ) ; } 
protected TYPE_1 METHOD_1 ( Map < String , Integer > VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; for ( Map . Entry < String , Integer > VAR_3 : VAR_1 . entrySet ( ) ) { TYPE_2 VAR_4 = METHOD_2 ( VAR_3 . getKey ( ) ) ; TYPE_3 . METHOD_3 ( 0 , VAR_3 . getValue ( ) ) . forEach ( i - > VAR_2 . METHOD_4 ( VAR_4 ) ) ; } <START> ; <END> return VAR_2 ; } 
private void METHOD_1 ( byte [ ] VAR_1 , TYPE_1 VAR_2 , String VAR_3 , TYPE_5 . TYPE_6 VAR_4 ) { TYPE_3 VAR_5 = TYPE_4 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , false , VAR_4 ) ; METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( R . id . VAR_6 , VAR_5 , VAR_7 ) <START> . METHOD_6 ( ) ; <END> } 
public TYPE_1 ( String VAR_2 , ANNOTATION_1 String VAR_3 , ANNOTATION_1 String VAR_4 , String name , String url ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = METHOD_1 ( VAR_4 ) ; <END> this . name = METHOD_1 ( name ) ; this . url = METHOD_1 ( url ) ; } 
private static List < String > METHOD_1 ( final Object VAR_1 ) { if ( VAR_1 instanceof List ) { return ( List < String > ) VAR_1 ; } <START> return Collections . VAR_2 ( ( String ) VAR_1 ) ; <END> } 
protected String METHOD_1 ( String VAR_1 ) { if ( ! VAR_1 . startsWith ( VAR_2 ) ) { throw new IllegalArgumentException ( String . format ( STRING_1 , VAR_1 , VAR_2 ) ) ; } <START> return VAR_1 . METHOD_2 ( VAR_2 , "" ) ; <END> } 
protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { File VAR_2 ; String VAR_3 = TYPE_3 . METHOD_2 ( VAR_4 , VAR_1 ) ; if ( VAR_3 != null ) { VAR_2 = new File ( VAR_3 ) ; } else { <START> VAR_2 = new File ( this . ctx . VAR_5 ( ) . METHOD_3 ( ) , VAR_6 ) ; <END> } Log . d ( TAG , STRING_1 + VAR_2 . METHOD_3 ( ) ) ; return new TYPE_4 ( VAR_2 , METHOD_4 ( VAR_1 ) ) ; } 
public void run ( final TYPE_1 configuration , final TYPE_2 VAR_1 ) throws Exception { <START> log . info ( STRING_1 ) ; <END> METHOD_1 ( configuration , VAR_1 ) ; METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_1 ) ; METHOD_5 ( VAR_1 ) ; } 
private static TYPE_1 METHOD_1 ( TYPE_2 stream ) throws IOException , TYPE_3 { String line ; StringBuilder result = new StringBuilder ( ) ; TYPE_4 reader = new TYPE_4 ( new TYPE_5 ( stream ) ) ; try { while ( ( line = reader . VAR_1 ( ) ) != null ) { result . append ( line ) ; } } finally { <START> reader . close ( ) ; <END> } return new TYPE_1 ( result . toString ( ) ) ; } 
<START> public void METHOD_1 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } 
<START> public void METHOD_1 ( ) throws TYPE_1 { <END> request . VAR_1 ( STRING_1 , STRING_2 ) ; matcher = new TYPE_2 ( new TYPE_3 ( STRING_3 , STRING_4 ) ) ; matcher . VAR_2 ( true ) ; assertThat ( matcher . VAR_3 ( request ) ) . METHOD_2 ( ) ; } 
default void VAR_1 ( final TYPE_1 < ? super VAR_3 > filter , TYPE_3 < ? super VAR_3 , TYPE_2 < VAR_3 , VAR_6 > > action ) throws InterruptedException { <START> iterator ( ) . VAR_7 ( VAR_8 - > { <END> if ( filter == null || filter . VAR_9 ( VAR_8 . getKey ( ) ) ) { action . VAR_9 ( VAR_8 . getKey ( ) , VAR_8 ) ; } } ) ; } 
private void METHOD_1 ( final String VAR_1 , final TYPE_1 user ) { <START> TYPE_2 VAR_2 = TYPE_2 . getInstance ( ) ; <END> try { VAR_2 . METHOD_2 ( new TYPE_3 ( ) . METHOD_3 ( TYPE_4 . format ( user . VAR_3 ( ) , STRING_1 , VAR_1 ) ) . METHOD_4 ( TYPE_7 . VAR_5 ) . METHOD_5 ( TYPE_8 . VAR_7 ) . create ( ) , list ( user . VAR_8 ( ) ) ) ; } catch ( TYPE_5 e ) { throw new TYPE_6 ( e ) ; } } 
<START> public synchronized void METHOD_1 ( long VAR_1 ) { <END> VAR_2 . METHOD_2 ( VAR_3 - > { if ( VAR_1 <= VAR_3 ) { return VAR_3 ; } return VAR_1 ; } ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . VAR_2 . METHOD_2 ( CHAR_1 ) == - 1 ) return false ; for ( TYPE_2 VAR_3 : VAR_4 ) { if ( VAR_3 . getPath ( ) . METHOD_3 ( VAR_1 . VAR_2 ) > 0 ) return false ; <END> if ( VAR_3 . METHOD_4 ( VAR_1 . VAR_2 ) ) { return true ; } } return false ; } 
public void write ( TYPE_1 out ) { try { TYPE_2 . METHOD_1 ( results . VAR_1 ( ) , out ) ; } catch ( IOException e ) { <START> log . warn ( e . getMessage ( ) ) ; <END> throw new TYPE_3 ( Response . status ( Status . VAR_2 ) . entity ( STRING_1 ) . build ( ) ) ; } finally { results . VAR_3 ( ) ; } } 
private static Collection < ANNOTATION_1 TYPE_1 > METHOD_1 ( ) { Set < ANNOTATION_1 String > VAR_1 = <START> Collections . VAR_2 ( TYPE_3 . VAR_4 ) ; <END> TYPE_2 VAR_5 = new TYPE_2 ( StringUtils . VAR_6 , VAR_1 ) ; return Collections . VAR_2 ( VAR_5 ) ; } 
<START> protected boolean METHOD_1 ( boolean VAR_1 , boolean VAR_2 ) { <END> return ( TYPE_1 . instance ( ) . METHOD_2 ( ) != TYPE_2 . VAR_4 || VAR_1 || VAR_2 ) ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_1 < TYPE_2 > result = new TYPE_3 < > ( ) ; <START> result . addAll ( VAR_1 ) ; <END> VAR_1 . clear ( ) ; return result ; } 
private void METHOD_1 ( ) throws TYPE_1 { VAR_1 . addAll ( VAR_2 ) ; <START> VAR_1 . addAll ( VAR_3 ) ; <END> TYPE_2 config = METHOD_2 ( METHOD_3 ( ) , VAR_1 ) ; log . info ( STRING_1 ) ; METHOD_4 ( STRING_2 , config ) ; } 
<START> private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , final TYPE_2 target ) { <END> if ( target != null && METHOD_2 ( VAR_1 , target ) ) { return VAR_1 . METHOD_3 ( target . VAR_2 ( ) , TYPE_3 . VAR_4 ) ; } return VAR_1 ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_4 = VAR_2 ; <START> this . VAR_5 = VAR_3 ; <END> } 
private String METHOD_1 ( ) { TYPE_1 [ ] VAR_1 = VAR_2 . METHOD_2 ( TYPE_2 . TYPE_3 . VAR_5 ) ; <START> return VAR_1 [ 0 ] . name ; <END> } 
private boolean METHOD_1 ( Long VAR_1 , Long VAR_2 ) { <START> return VAR_2 != - 1 && VAR_1 + VAR_2 < System . currentTimeMillis ( ) / INT_1 ; <END> } 
private void METHOD_1 ( ) { if ( context . VAR_1 ( ) . METHOD_2 ( ) != null ) { final String VAR_2 = context . VAR_1 ( ) . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( Constants . VAR_4 . METHOD_4 ( VAR_2 ) , VAR_5 . METHOD_5 ( ) , VAR_2 , TYPE_1 . VAR_7 , ( ) - > METHOD_6 ( VAR_5 . METHOD_7 ( ) ) , ( ) - > { <START> } ) ; <END> } else { METHOD_6 ( VAR_5 . METHOD_7 ( ) ) ; } } 
<START> public TYPE_1 get ( final String key ) { <END> return super . get ( key . VAR_1 ( ) ) ; } 
public static byte [ ] METHOD_1 ( ByteBuffer buf ) { byte [ ] VAR_1 = new byte [ buf . VAR_2 ( ) ] ; int VAR_3 = buf . position ( ) ; buf . get ( VAR_1 ) ; <START> buf . position ( VAR_3 ) ; <END> return VAR_1 ; } 
private boolean METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) return VAR_2 . METHOD_3 ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { <START> if ( VAR_2 . METHOD_3 ( ) ) { <END> return true ; } try { Thread . VAR_3 ( 100 ) ; } catch ( InterruptedException e ) { } } return false ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) throws Exception { return VAR_2 == null ? null : <START> ( TYPE_1 ) TYPE_2 . METHOD_2 ( VAR_2 . get ( VAR_1 ) , TYPE_1 . class ) ; <END> } 
public void METHOD_1 ( ) { try { this . VAR_1 . METHOD_2 ( ) ; } catch ( Exception e ) { <START> throw new TYPE_1 ( STRING_1 + this . path , e ) ; <END> } } 
protected void METHOD_1 ( ) { METHOD_2 ( true ) ; for ( Map . Entry < TYPE_1 , List < TYPE_2 > > VAR_1 : METHOD_3 ( ) . entrySet ( ) ) { METHOD_4 ( VAR_1 . getKey ( ) , VAR_1 . getValue ( ) ) ; } <START> if ( TYPE_3 . METHOD_5 ( METHOD_6 ( ) . METHOD_7 ( ) ) ) { <END> METHOD_8 ( ) ; } } 
protected void METHOD_1 ( ) { TYPE_1 parameters = getParameters ( ) ; status = METHOD_2 ( ) . METHOD_3 ( parameters . VAR_1 ( ) , <START> new ArrayList < > ( parameters . VAR_2 ( ) ) ) ; <END> METHOD_4 ( ) ; } 
public static void METHOD_1 ( ) throws Exception { VAR_1 = new TYPE_1 ( ) ; TYPE_2 . METHOD_2 ( VAR_1 ) ; VAR_1 . METHOD_3 ( TYPE_3 . METHOD_4 ( ) . METHOD_5 ( ) ) ; VAR_1 . METHOD_6 ( TYPE_3 . METHOD_4 ( ) . METHOD_7 ( ) ) ; <START> VAR_2 = new TYPE_4 ( ) ; <END> VAR_3 = TYPE_2 . METHOD_8 ( VAR_1 , VAR_2 ) ; } 
public void close ( ) { METHOD_1 ( ) ; METHOD_2 ( VAR_1 ) ; for ( TYPE_1 VAR_2 : VAR_3 ) { METHOD_2 ( VAR_2 ) ; } <START> METHOD_3 ( ) ; <END> METHOD_2 ( VAR_4 ) ; METHOD_2 ( VAR_5 ) ; } 
public Long METHOD_1 ( String VAR_1 , final long VAR_2 ) { final TYPE_1 < TYPE_2 > VAR_3 = TYPE_3 . create ( ) ; VAR_3 . METHOD_2 ( STRING_1 , VAR_2 ) ; VAR_3 . METHOD_2 ( STRING_2 , VAR_1 ) ; VAR_3 . METHOD_2 ( STRING_3 , TYPE_5 . Type . TYPE_4 ) ; TYPE_2 VAR_6 = METHOD_3 ( VAR_3 ) ; if ( VAR_6 != null ) { <START> return ( new Long ( VAR_6 . METHOD_4 ( ) ) ) ; <END> } return null ; } 
public List < TYPE_2 . TYPE_3 > METHOD_1 ( ) { <START> ArrayList < TYPE_2 . TYPE_3 > VAR_1 = new ArrayList < > ( super . METHOD_1 ( ) ) ; <END> VAR_1 . add ( TYPE_2 . TYPE_3 . VAR_2 ) ; VAR_1 . add ( TYPE_2 . TYPE_3 . VAR_3 ) ; VAR_1 . add ( TYPE_2 . TYPE_3 . VAR_4 ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 ) ; <START> String VAR_1 = STRING_2 <END> + STRING_3 + STRING_4 + STRING_5 ; METHOD_3 ( VAR_2 + VAR_1 + VAR_1 + VAR_3 , null ) ; } 
public boolean METHOD_1 ( TYPE_1 < ? > VAR_1 ) { return VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) && ( VAR_1 instanceof TYPE_2 ) <START> || ( VAR_1 instanceof TYPE_3 ) ; <END> } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) <START> return null ; <END> return VAR_2 . METHOD_3 ( ) ; } 
private int METHOD_1 ( ) { <START> if ( ! METHOD_2 ( ) ) { <END> return 0 ; } return TYPE_1 . METHOD_3 ( info , VAR_1 + VAR_2 ) < < INT_1 ; } 
protected void update ( final Map < String , Object > VAR_1 ) { final String id = ( String ) VAR_1 . get ( METHOD_1 ( ) ) ; logger . debug ( STRING_1 , id , VAR_1 ) ; final Map < String , Object > VAR_2 = VAR_3 . get ( id ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( VAR_1 ) ; } else { <START> METHOD_3 ( VAR_1 ) ; <END> } } 
private < T extends TYPE_1 > T METHOD_1 ( Class < T > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_1 . METHOD_2 ( VAR_2 . getClass ( ) ) ) { if ( VAR_2 instanceof TYPE_2 ) { <START> METHOD_3 ( ( TYPE_2 ) VAR_2 ) ; <END> } return ( T ) VAR_2 ; } } log . error ( STRING_1 + VAR_1 ) ; return null ; } 
private TYPE_3 ( final String url ) { TYPE_1 VAR_2 = null ; try { VAR_2 = new TYPE_1 ( url ) ; } catch ( TYPE_2 e ) { LOG . info ( TYPE_4 . VAR_4 , e ) ; } if ( VAR_2 == null ) { return ; } VAR_5 = VAR_2 . METHOD_1 ( STRING_1 ) ; if ( VAR_5 == null ) { <START> LOG . info ( STRING_2 ) ; <END> } else { METHOD_2 ( ) ; } } 
public void METHOD_1 ( ) { <START> if ( VAR_1 instanceof TYPE_1 ) { ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( ) . add ( ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) , VAR_3 ) ; METHOD_4 ( false ) ; ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( ) . remove ( VAR_2 ) ; } <END> } 
public long METHOD_1 ( ) { <START> return System . currentTimeMillis ( ) - VAR_1 . get ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( 1 ) ; when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_2 . TYPE_1 . VAR_4 ) ; METHOD_5 ( ) ; VAR_5 . METHOD_6 ( VAR_1 , VAR_6 , listener , null ) ; <START> METHOD_7 ( VAR_7 ) . METHOD_8 ( METHOD_9 ( ) ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( R . id . VAR_3 ) ; if ( VAR_1 instanceof TYPE_2 ) { VAR_2 . METHOD_3 ( TYPE_3 . VAR_5 , 0 ) ; <START> return ; <END> } super . METHOD_1 ( ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , Object parent , Object element ) { <START> TYPE_2 VAR_2 = ( TYPE_2 ) element ; <END> TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( ) . METHOD_3 ( VAR_4 . METHOD_4 ( VAR_2 ) ) ; if ( VAR_3 == null ) { return true ; } return ! VAR_3 . METHOD_5 ( ) . METHOD_6 ( ) ; } 
public void METHOD_1 ( TYPE_1 context ) { super . context = context ; if ( VAR_1 ) { try { VAR_2 = TYPE_2 . METHOD_2 ( VAR_3 , TYPE_2 . VAR_4 ) ; <START> } catch ( RuntimeException e ) { <END> throw new IllegalArgumentException ( STRING_1 + getClass ( ) . METHOD_3 ( ) + STRING_2 + VAR_3 , e ) ; } } else { VAR_5 = VAR_3 . split ( STRING_3 ) ; } METHOD_4 ( context . VAR_6 ( ) ) ; } 
private boolean METHOD_1 ( Object value ) { if ( value == null ) { System . out . METHOD_2 ( STRING_1 ) ; <START> } <END> return TYPE_1 . METHOD_3 ( value ) && ( ( value instanceof String ) || ( VAR_1 . METHOD_4 ( value . getClass ( ) ) ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 != null ) { <END> TYPE_2 . METHOD_2 ( ) ; key ( ) . METHOD_3 ( VAR_2 ) ; value ( ) . METHOD_3 ( VAR_2 ) ; } VAR_3 . METHOD_1 ( ) ; VAR_4 . METHOD_1 ( ) ; } 
public static void METHOD_1 ( String path ) throws IOException { try { TYPE_1 . METHOD_2 ( TYPE_2 . get ( path ) ) ; } catch ( TYPE_3 e ) { <START> LOG . info ( STRING_1 + path + STRING_2 ) ; <END> } } 
public TYPE_1 ( ) { <START> this ( false , false , false , 0 , 0 , 0 , "" , "" , "" ) ; <END> VAR_2 = false ; } 
public TYPE_1 ( int VAR_2 , long VAR_3 , long VAR_4 , List < Class < ? > > VAR_5 ) { this . VAR_6 = VAR_5 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_7 = VAR_2 ; <START> this . VAR_8 . set ( false ) ; <END> } 
public void METHOD_1 ( Exception e ) { <START> String VAR_1 = e . getMessage ( ) . METHOD_2 ( VAR_2 , STRING_1 ) ; <END> VAR_3 . METHOD_3 ( METHOD_4 ( VAR_4 , e , VAR_1 ) ) . METHOD_5 ( ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 . assertTrue ( VAR_1 . METHOD_3 ( ) ) ; <START> TYPE_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_2 ) ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( ) ; <END> int VAR_1 = 5 ; final String VAR_2 = STRING_1 ; final String VAR_3 = STRING_2 ; METHOD_3 ( VAR_1 , VAR_2 , VAR_3 ) ; } 
<START> private boolean METHOD_1 ( Set < String > VAR_1 ) { <END> for ( String VAR_2 : VAR_1 ) { if ( METHOD_2 ( ) . METHOD_3 ( VAR_2 ) . size ( ) > 0 || METHOD_2 ( ) . METHOD_4 ( VAR_2 ) . size ( ) > 0 ) { return true ; } } return false ; } 
public void update ( ) { VAR_1 = VAR_2 . METHOD_1 ( VAR_3 ) . VAR_1 ; task . VAR_4 ( VAR_1 ) ; <START> task . VAR_5 ( VAR_3 ) ; <END> } 
public static String METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( ) . METHOD_1 ( ) ; <END> } 
public TYPE_1 add ( TYPE_2 < TYPE_3 > VAR_1 ) throws TYPE_4 , TYPE_5 { <START> for ( TYPE_3 id : VAR_1 ) { <END> add ( id ) ; } return this ; } 
<START> public TYPE_4 ( TYPE_1 VAR_2 ) { <END> super ( VAR_2 , TYPE_2 . get ( TYPE_3 . class ) ) ; } 
<START> public int value ( ) { <END> return VAR_1 . METHOD_1 ( ) ; } 
private void METHOD_1 ( ) throws IOException { if ( ! METHOD_2 ( ) . get ( VAR_1 ) ) { return ; } TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 . METHOD_3 ( TYPE_2 . class ) , <START> config . get ( TYPE_3 . VAR_5 ) . METHOD_4 ( ) , <END> config . get ( VAR_6 ) . toString ( ) , config . get ( VAR_7 ) , config . get ( VAR_8 ) ) ; VAR_9 . METHOD_5 ( VAR_2 ) ; } 
public void METHOD_1 ( TYPE_1 event ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( ( METHOD_4 ( ) && ! VAR_1 . METHOD_5 ( ) ) <START> || METHOD_6 ( ) ) { <END> log . debug ( STRING_1 ) ; METHOD_7 ( VAR_2 . METHOD_8 ( ) ) ; } } 
private void METHOD_1 ( Map < Integer , Map < Integer , String > > VAR_1 ) { if ( ! VAR_1 . isEmpty ( ) ) { <START> VAR_1 . forEach ( ( VAR_2 , VAR_3 ) - > { <END> model . VAR_4 ( VAR_2 , new TYPE_1 ( ) ) ; VAR_3 . forEach ( ( VAR_5 , VAR_6 ) - > model . VAR_7 ( VAR_2 , VAR_5 , ( ) - > new TYPE_2 ( new TYPE_3 ( VAR_6 ) ) ) ) ; } ) ; } } 
public static boolean METHOD_1 ( String VAR_1 , TYPE_1 project ) { if ( VAR_1 == null ) { return false ; } <START> TYPE_2 user = TYPE_2 . METHOD_2 ( VAR_1 ) ; <END> if ( user == null || user . VAR_2 ( ) ) { return false ; } if ( user . VAR_3 ( ) || TYPE_3 . METHOD_3 ( user . id , project . id ) ) { return true ; } return false ; } 
public void METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; <START> if ( VAR_2 != null ) { VAR_2 . METHOD_1 ( ) ; } <END> } 
private void METHOD_1 ( TYPE_1 out ) throws IOException { out . VAR_1 ( VAR_2 ) ; out . VAR_1 ( VAR_3 ) ; out . VAR_1 ( VAR_4 ) ; synchronized ( VAR_5 ) { if ( VAR_6 == null ) { VAR_6 = METHOD_2 ( TYPE_2 . class , <START> VAR_7 ) ; ; <END> } } out . VAR_1 ( VAR_6 ) ; out . VAR_1 ( VAR_8 ) ; out . VAR_1 ( VAR_9 ) ; } 
public TYPE_2 ( ) { String VAR_2 = Context . VAR_3 ( ) . getString ( STRING_1 ) ; if ( VAR_2 != null ) { VAR_4 . addAll ( Arrays . asList ( VAR_2 . split ( STRING_2 ) ) ) ; } <START> VAR_5 = TYPE_1 . METHOD_1 ( Context . VAR_3 ( ) . getString ( STRING_3 , VAR_6 ) . split ( STRING_2 ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) throws TYPE_2 { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 . isEmpty ( ) ) { <END> throw new TYPE_2 ( STRING_1 ) ; } int VAR_2 = VAR_3 . METHOD_3 ( VAR_1 . size ( ) ) ; return VAR_1 . get ( VAR_2 ) ; } 
public void METHOD_1 ( int VAR_1 ) { <START> this . METHOD_1 ( VAR_1 , <END> VAR_1 ) ; } 
private boolean METHOD_1 ( TYPE_1 request ) { if ( VAR_1 == null <START> || VAR_1 . length ( ) == 0 ) { <END> return false ; } return request . VAR_2 ( VAR_1 ) == null ; } 
private void METHOD_1 ( List < List < Object > > VAR_1 , List < TYPE_1 > VAR_2 ) { for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { TYPE_1 VAR_3 = VAR_2 . get ( i ) ; Object VAR_4 = ( ( TYPE_2 ) VAR_3 ) . METHOD_2 ( ) ; <START> LOG . debug ( STRING_1 , VAR_5 , VAR_1 . get ( i ) , VAR_4 ) ; <END> } } 
public TYPE_2 ( String VAR_2 , String VAR_3 , List < TYPE_1 > VAR_4 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = new ArrayList < TYPE_1 > ( VAR_4 ) ; } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <START> super ( VAR_2 ) ; <END> this . response = new TYPE_4 ( ) ; this . VAR_5 = new TYPE_5 ( ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_6 = new TYPE_6 ( ) ; } 
<START> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> super ( VAR_2 ) ; VAR_4 = VAR_3 ; VAR_5 = new TYPE_3 ( VAR_4 ) ; } 
public long METHOD_1 ( ) { <START> if ( ! METHOD_2 ( ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } return VAR_1 ; } 
static public < T > TYPE_1 < T > METHOD_1 ( TYPE_2 < TYPE_1 < T > > VAR_1 , TYPE_3 VAR_2 ) { if ( VAR_2 == null ) { return TYPE_1 . METHOD_2 ( ( ) - > { try { return VAR_1 . call ( ) ; } catch ( Exception e ) { <START> return TYPE_4 . error ( e ) ; <END> } } ) ; } else { return TYPE_5 . METHOD_3 ( ( ) - > VAR_1 . call ( ) , VAR_2 ) ; } } 
public int METHOD_1 ( ) { <START> if ( VAR_1 == null ) <END> return 0 ; return VAR_1 . VAR_2 ; } 
public TYPE_1 < TYPE_2 > METHOD_1 ( String VAR_1 ) { TYPE_3 < TYPE_2 > VAR_2 = new TYPE_3 < TYPE_2 > ( ) ; TYPE_4 VAR_3 = METHOD_2 ( ) ; if ( VAR_3 == null ) { METHOD_3 ( VAR_2 , null , null , VAR_4 ) ; } else { VAR_3 . METHOD_1 ( VAR_1 , VAR_2 , null ) ; } <START> return VAR_2 ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 , STRING_1 ) ; <END> System . VAR_3 ( TYPE_1 . VAR_5 , STRING_2 ) ; METHOD_3 ( false ) ; } 
public TYPE_7 ( TYPE_1 parent , TYPE_2 VAR_2 ) { super ( parent , VAR_2 , SWT . VAR_3 | SWT . VAR_4 | SWT . VAR_5 ) ; TYPE_3 . METHOD_1 ( this ) ; METHOD_2 ( this ) ; METHOD_3 ( this ) ; TYPE_4 . METHOD_4 ( ) ; METHOD_5 ( new TYPE_5 ( ) { @Override <START> public void METHOD_6 ( TYPE_6 e ) { <END> TYPE_3 . METHOD_7 ( TYPE_7 . VAR_6 ) ; } } ) ; } 
private Map < String , TYPE_1 > METHOD_1 ( Integer s , Map < String , TYPE_1 > VAR_1 ) { if ( VAR_1 == null ) { return Collections . VAR_2 ( VAR_3 , TYPE_1 . METHOD_2 ( VAR_4 ) ) ; } else { Map < String , TYPE_1 > VAR_5 = new HashMap < > ( VAR_1 ) ; VAR_5 . METHOD_3 ( VAR_3 , this : : METHOD_4 ) ; <START> return Collections . VAR_6 ( VAR_5 ) ; <END> } } 
<START> private HashMap < String , String > METHOD_1 ( ) { <END> HashMap < String , String > params = new HashMap < > ( ) ; params . put ( VAR_1 , METHOD_2 ( name ) ) ; params . put ( VAR_2 , VAR_3 ) ; params . put ( VAR_4 , VAR_5 ) ; return params ; } 
public String METHOD_1 ( ) { TYPE_1 VAR_1 = this . METHOD_2 ( ) ; if ( VAR_1 == null ) return null ; <START> return VAR_1 . METHOD_3 ( ) ; <END> } 
public TYPE_1 ( List < Type > VAR_2 , List < Type > VAR_3 ) { this . VAR_2 = ImmutableList . VAR_4 ( VAR_2 ) ; <START> this . VAR_3 = VAR_3 ; <END> } 
public boolean METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { <START> return VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ; <END> } return VAR_1 . METHOD_1 ( ) ; } 
public void METHOD_1 ( List < String > VAR_1 ) { log . debug ( STRING_1 , <START> Arrays . toString ( VAR_1 . METHOD_2 ( ) ) ) ; <END> VAR_1 . forEach ( TYPE_1 : : METHOD_3 ) ; } 
public String METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { return null ; } String VAR_3 = VAR_2 . METHOD_3 ( ) ; if ( VAR_3 . isEmpty ( ) ) { return VAR_2 . METHOD_4 ( ) ; } <START> return VAR_2 . METHOD_4 ( ) + STRING_1 + VAR_2 . METHOD_3 ( ) ; <END> } 
<START> private void METHOD_1 ( Map < String , List < String > > VAR_1 , String VAR_2 , <END> String ... VAR_3 ) { assertTrue ( VAR_1 . containsKey ( VAR_2 ) , STRING_1 + VAR_2 ) ; assertEquals ( VAR_1 . get ( VAR_2 ) . size ( ) , VAR_3 . length , STRING_2 + VAR_2 ) ; assertTrue ( VAR_1 . get ( VAR_2 ) . METHOD_2 ( Arrays . asList ( VAR_3 ) ) , STRING_3 + Arrays . asList ( VAR_3 ) ) ; } 
private void METHOD_1 ( ) { if ( ! VAR_1 ) return ; <START> if ( ! METHOD_2 ( ) ) { <END> throw VAR_2 ; } } 
public void METHOD_1 ( Class < ? > VAR_1 ) { <START> System . out . println ( STRING_1 + VAR_1 . getName ( ) ) ; <END> VAR_2 . add ( VAR_1 ) ; } 
<START> public TYPE_2 ( boolean VAR_2 , TYPE_1 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; VAR_1 . METHOD_4 ( STRING_2 ) ; <START> VAR_1 . METHOD_5 ( Integer . VAR_4 . getName ( ) ) ; <END> VAR_1 . METHOD_6 ( STRING_3 ) ; return VAR_1 ; } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_4 = ( TYPE_3 ) VAR_2 . METHOD_1 ( ) ; this . VAR_5 = VAR_3 ; this . VAR_6 = ( Integer ) VAR_5 . getValue ( VAR_7 , VAR_2 ) ; this . VAR_8 = ( Double ) VAR_5 . getValue ( VAR_9 , VAR_2 ) ; <START> this . VAR_10 = METHOD_2 ( VAR_5 . getValue ( VAR_11 , VAR_2 ) ) ; <END> this . VAR_12 = VAR_2 ; } 
<START> TYPE_1 ( String VAR_2 ) { <END> this . VAR_2 = VAR_2 ; } 
public static List < TYPE_1 > METHOD_1 ( String ... VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( String name : VAR_1 ) { if ( name . equals ( TYPE_1 . VAR_3 ) || <START> name . equals ( STRING_1 ) ) { <END> VAR_2 . add ( TYPE_1 . VAR_4 ) ; } else { VAR_2 . add ( TYPE_1 . METHOD_2 ( name ) ) ; } } return VAR_2 ; } 
private static String METHOD_1 ( TYPE_1 node ) { <START> TYPE_2 . METHOD_2 ( node . VAR_1 ( ) ) ; <END> return node . VAR_2 ( ) ? null : node . VAR_3 ( ) ; } 
public void METHOD_1 ( ) { when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( TYPE_2 . VAR_3 ) ; final String [ ] result = page . VAR_4 ( TYPE_1 . VAR_6 ) ; final List < String > VAR_7 = Arrays . asList ( result ) ; <START> METHOD_4 ( VAR_7 . contains ( STRING_1 ) ) ; <END> METHOD_4 ( VAR_7 . contains ( STRING_2 ) ) ; assertEquals ( 0 , VAR_7 . size ( ) ) ; } 
public static TYPE_1 < ? > METHOD_1 ( final Context context , final long VAR_1 ) { if ( TYPE_2 . METHOD_2 ( ) ) { TYPE_3 . METHOD_3 ( context , TYPE_4 . METHOD_4 ( VAR_1 ) . METHOD_5 ( ) , false ) ; } <START> return METHOD_6 ( context , VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 response ) throws Exception { VAR_1 [ VAR_2 ] = new TYPE_2 ( VAR_3 , response ) ; <START> VAR_4 . METHOD_2 ( ) ; <END> if ( VAR_4 . get ( ) == 0 ) { VAR_5 . METHOD_1 ( VAR_1 ) ; } } 
public synchronized TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { if ( VAR_1 == null ) throw new TYPE_4 ( STRING_1 ) ; <START> if ( VAR_2 == null ) throw new TYPE_4 ( STRING_2 ) ; <END> org . VAR_3 . VAR_4 . VAR_5 . TYPE_5 project = get ( VAR_1 ) ; if ( project == null ) throw new TYPE_4 ( STRING_3 + VAR_1 + STRING_4 ) ; return project . VAR_7 ( VAR_2 ) ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 , Object parent , Object element ) { if ( element instanceof TYPE_2 ) { if ( METHOD_2 ( ) && VAR_1 instanceof TYPE_3 ) { TYPE_2 VAR_2 = ( TYPE_2 ) element ; <START> if ( VAR_2 . METHOD_3 ( ) . length > 0 ) { return METHOD_4 ( ( TYPE_3 ) VAR_1 , VAR_2 ) ; } return false ; <END> } } return true ; } 
public Response METHOD_1 ( ) throws Exception { TYPE_1 session = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_3 ( ) ) ; <START> List < String > VAR_1 = new ArrayList < String > ( session . VAR_2 ( ) . METHOD_5 ( ) ) ; <END> Collections . VAR_3 ( VAR_1 ) ; return METHOD_6 ( VAR_1 ) ; } 
public boolean METHOD_1 ( final TYPE_1 from , final TYPE_2 event , final TYPE_1 to ) { <START> TYPE_3 . METHOD_2 ( from , STRING_1 ) ; <END> TYPE_3 . METHOD_2 ( event , STRING_2 ) ; TYPE_3 . METHOD_2 ( to , STRING_3 ) ; TYPE_4 VAR_1 = new TYPE_4 ( from , event , to ) ; return METHOD_1 ( VAR_1 ) ; } 
Type METHOD_1 ( List < Type > VAR_1 ) { <START> return VAR_2 . METHOD_1 ( VAR_1 . METHOD_2 ( new Type [ VAR_1 . size ( ) ] ) ) ; <END> } 
public Response METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 TYPE_2 VAR_2 , ANNOTATION_2 ( STRING_1 ) String type , ANNOTATION_1 TYPE_3 config , ANNOTATION_1 TYPE_4 VAR_3 ) throws Exception { <START> METHOD_2 ( VAR_4 ) ; <END> Response response = super . METHOD_3 ( VAR_1 , config , VAR_3 , VAR_2 , type ) ; response . VAR_5 ( ) . add ( STRING_2 , STRING_3 ) ; return response ; } 
public Optional < TYPE_1 > build ( ) { if ( this . VAR_1 ) { try { METHOD_1 ( ) ; } catch ( Exception e ) { throw logger . VAR_2 ( e ) ; } return Optional . of ( new TYPE_1 ( VAR_3 , VAR_4 ) ) ; } <START> return Optional . empty ( ) ; <END> } 
protected void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; final Collection < TYPE_1 > VAR_2 = VAR_3 == null ? new ArrayList < TYPE_1 > ( ) : VAR_3 ; <START> if ( METHOD_3 ( ) . METHOD_4 ( ) != VAR_2 ) { <END> METHOD_3 ( ) . METHOD_5 ( VAR_2 , VAR_1 ) ; } else { METHOD_3 ( ) . METHOD_6 ( VAR_1 ) ; } } 
public TYPE_1 ( ) throws IOException { <START> super ( ) ; <END> } 
private Guid METHOD_1 ( Guid VAR_1 , TYPE_1 type , TYPE_2 status ) { return METHOD_2 ( VAR_1 , type , <START> status ) . stream ( ) . map ( TYPE_3 : : getId ) . METHOD_3 ( ) . METHOD_4 ( Guid . TYPE_4 ) ; <END> } 
<START> public static List < TYPE_1 > METHOD_1 ( TYPE_2 query ) <END> { return TYPE_3 . METHOD_2 ( query . VAR_1 ( ) , query . VAR_2 ( ) . METHOD_3 ( query . VAR_3 ( ) ) ) ; } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 . is ( TYPE_7 . TYPE_6 . VAR_4 ) ) { TYPE_2 VAR_5 = ( TYPE_2 ) VAR_1 ; TYPE_3 TYPE_4 = METHOD_2 ( VAR_5 ) ; return TYPE_5 . stream ( ) . METHOD_3 ( TYPE_4 : : equals ) ; } return false ; } 
private TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_1 . get ( request ) ; return VAR_1 . VAR_2 ? VAR_1 : <START> TYPE_2 . METHOD_2 ( ) . METHOD_3 ( user , request , uri , response ) ; <END> } 
public File METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == null ) { VAR_1 = METHOD_3 ( ) ; <START> } <END> } return VAR_1 . METHOD_4 ( ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 . getMessage ( ) . split ( STRING_1 ) [ 0 ] ; if ( VAR_2 . METHOD_1 ( VAR_3 ) ) { return VAR_1 . getMessage ( ) . contains ( VAR_4 ) == VAR_5 ; <START> } else { <END> return false ; } } 
<START> private static void METHOD_1 ( Collection < Pair < Object , String > > result , String element ) { <END> if ( element . length ( ) > 0 ) { List < String > list = Arrays . asList ( element . split ( STRING_1 ) ) ; list . forEach ( VAR_1 - > { String value = VAR_1 . split ( STRING_2 ) [ 0 ] ; result . add ( new Pair < > ( value , value ) ) ; } ) ; } } 
public List < String > METHOD_1 ( final String VAR_1 ) throws TYPE_1 { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_1 ( VAR_1 ) ; List < String > VAR_4 = new ArrayList < > ( ) ; if ( null != VAR_2 && ! VAR_2 . isEmpty ( ) ) { for ( TYPE_2 VAR_5 : VAR_2 ) { VAR_4 . add ( VAR_5 . METHOD_2 ( ) ) ; } return VAR_4 ; <START> } else { <END> return VAR_4 ; } } 
public void METHOD_1 ( ) { VAR_1 = VAR_2 ; VAR_3 = true ; VAR_4 = true ; VAR_5 = false ; VAR_6 = false ; <START> VAR_7 = true ; <END> VAR_8 = null ; VAR_9 = null ; VAR_10 = null ; VAR_11 = null ; } 
public static boolean METHOD_1 ( final String VAR_1 , final String VAR_2 ) { if ( ! METHOD_2 ( VAR_1 ) ) { return false ; } if ( ! METHOD_3 ( VAR_2 ) ) { return false ; } final TYPE_1 VAR_3 = new TYPE_1 ( VAR_2 ) ; VAR_3 . METHOD_4 ( true ) ; final boolean VAR_4 = VAR_3 . METHOD_5 ( ) . METHOD_6 ( VAR_1 ) ; <START> return ! VAR_4 ; <END> } 
public void METHOD_1 ( final TYPE_1 object ) { super . METHOD_1 ( object ) ; if ( object . VAR_1 ( ) ) { object . VAR_2 ( ) . METHOD_2 ( 1 ) ; } <START> VAR_3 . METHOD_3 ( true ) ; <END> } 
public String [ ] METHOD_1 ( long VAR_1 ) { <START> ctx . VAR_2 ( VAR_1 ) ; <END> return TYPE_1 . METHOD_1 ( VAR_1 ) ; } 
public synchronized boolean METHOD_1 ( ) { if ( ( Boolean ) METHOD_2 ( ) . get ( STRING_1 ) && METHOD_3 ( ) == null ) { METHOD_4 ( METHOD_5 ( ) ) ; <START> log . error ( STRING_2 ) ; <END> return true ; } return false ; } 
public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) throws IOException { <START> this . VAR_2 = new TYPE_1 ( VAR_2 ) ; <END> this . VAR_4 = TYPE_3 . get ( this . VAR_2 ) ; this . VAR_5 = new TYPE_4 ( this . VAR_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_6 = true ; } 
ANNOTATION_1 public void METHOD_1 ( ) throws TYPE_1 { final TYPE_2 parser = TYPE_2 . METHOD_2 ( STRING_1 ) ; assertEquals ( STRING_2 , parser . type . name ) ; assertEquals ( STRING_3 , parser . VAR_1 ) ; assertEquals ( STRING_4 , parser . version . toString ( ) ) ; <START> assertEquals ( STRING_5 , parser . VAR_2 ) ; <END> assertEquals ( STRING_6 , parser . VAR_3 ( ) ) ; } 
public void METHOD_1 ( ) throws Exception { <START> this . VAR_1 = this . VAR_2 . METHOD_2 ( ) ; <END> Assert . VAR_3 ( this . VAR_1 , STRING_1 ) ; } 
public int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , status , description , <START> status <END> ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { return new TYPE_3 ( ) . METHOD_2 ( STRING_1 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_2 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_3 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_4 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_5 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_6 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_7 , new TYPE_4 ( ) ) <START> . METHOD_3 ( STRING_1 ) . METHOD_3 ( STRING_6 ) ; <END> } 
public String METHOD_1 ( ) throws IOException { if ( VAR_1 == null ) { <START> throw new TYPE_4 . TYPE_5 . TYPE_2 ( STRING_1 ) ; <END> } return ( ( TYPE_3 ) VAR_1 ) . METHOD_1 ( ) ; } 
public void METHOD_1 ( final String VAR_1 ) throws IOException { try { new TYPE_1 ( this . VAR_2 . source ( ) ) . METHOD_2 ( STRING_1 ) . set ( this . VAR_3 ) . set ( VAR_1 ) <START> . set ( 1 ) <END> . METHOD_3 ( TYPE_3 . VAR_5 ) ; } catch ( final TYPE_2 ex ) { throw new IOException ( ex ) ; } } 
public TYPE_2 ( TYPE_1 parameters ) { <START> super ( parameters , false ) ; <END> } 
void run ( ) { if ( VAR_1 ) { return ; } TYPE_1 < ? super Long > VAR_2 = this . VAR_2 ; long e = VAR_3 ; for ( long i = index ; i != e && get ( ) == 0 ; i ++ ) { <START> VAR_2 . METHOD_1 ( ( long ) i ) ; <END> } if ( get ( ) == 0 ) { METHOD_2 ( 1 ) ; VAR_2 . METHOD_3 ( ) ; } } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_2 < TYPE_1 , TYPE_3 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , true ) ; for ( TYPE_3 VAR_4 : VAR_2 . values ( ) ) VAR_4 . run ( ) ; <START> VAR_2 . clear ( ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( VAR_1 , VAR_2 ) ; <START> Object [ ] args = { VAR_3 , VAR_2 , false } ; <END> METHOD_4 ( VAR_4 . create ( VAR_3 , true ) . apply ( VAR_2 ) , STRING_1 ) ; } 
public long METHOD_1 ( ) { return VAR_1 + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) + <START> ( VAR_3 != null ? VAR_3 . METHOD_1 ( ) : 0 ) ; <END> } 
public void METHOD_1 ( T request , TYPE_1 response , TYPE_2 VAR_1 , TYPE_3 target , String VAR_2 , String VAR_3 , Boolean VAR_4 , TYPE_4 VAR_5 , String VAR_6 ) { LOG . trace ( STRING_1 ) ; <START> if ( METHOD_2 ( ) != null && METHOD_3 ( VAR_6 ) ) { <END> METHOD_2 ( ) . METHOD_1 ( request , response , VAR_1 , target , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , METHOD_4 ( ) ) ; } LOG . trace ( STRING_2 ) ; } 
public TYPE_6 ( TYPE_1 map , TYPE_2 VAR_2 ) { if ( VAR_2 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } VAR_3 = null ; TYPE_3 parser = new TYPE_3 ( VAR_2 ) ; VAR_3 = parser . VAR_4 ( ) ; HashMap < TYPE_4 , Object > VAR_5 = new HashMap < > ( ) ; for ( TYPE_4 VAR_6 : parser . VAR_7 ( ) ) { VAR_5 . put ( VAR_6 , null ) ; } <START> VAR_8 = new TYPE_5 ( map , VAR_5 ) ; <END> METHOD_1 ( VAR_8 ) ; } 
protected int METHOD_1 ( int [ ] VAR_1 , int VAR_2 , int VAR_3 ) { int VAR_4 = 0 ; int length = 0 ; for ( int i = VAR_2 ; i < VAR_1 . length ; i ++ ) { length ++ ; if ( VAR_5 != VAR_1 [ i ] ) { VAR_4 ++ ; } <START> if ( VAR_4 == VAR_3 ) { <END> break ; } } return length ; } 
<START> protected TYPE_1 METHOD_1 ( String model , TYPE_2 config , TYPE_3 session ) { <END> TYPE_4 VAR_1 = null ; try { VAR_1 = new TYPE_4 ( model , config , session ) ; } catch ( TYPE_5 e ) { TYPE_6 . METHOD_2 ( ) . METHOD_3 ( ) . log ( e . getStatus ( ) ) ; } return VAR_1 ; } 
<START> public TYPE_1 ( ) { <END> } 
private int METHOD_1 ( Object o , int index ) { if ( o instanceof TYPE_1 ) { TYPE_2 VAR_1 = ( ( TYPE_1 ) o ) . get ( index ) ; int size ; if ( VAR_1 instanceof TYPE_3 ) size = 0 ; else <START> size = VAR_1 . METHOD_2 ( ) . size ( ) ; <END> return size ; } if ( o instanceof List ) { return ( ( List < TYPE_4 > ) o ) . get ( index ) . METHOD_1 ( ) ; } throw new IllegalStateException ( STRING_1 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { final TYPE_1 VAR_2 = new TYPE_1 ( ) ; TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 ) ; if ( VAR_1 . METHOD_3 ( ) != null ) { VAR_2 . METHOD_4 ( TYPE_4 . METHOD_5 ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ) ; } <START> VAR_2 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ; <END> return VAR_2 ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == this || VAR_1 instanceof TYPE_2 ) { return true ; } <START> return false ; <END> } 
private Collection < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > result = new ArrayList < > ( ) ; result . addAll ( VAR_1 ) ; <START> result . addAll ( VAR_2 ) ; <END> return result ; } 
@Override public boolean equals ( Object VAR_1 ) { <START> return VAR_1 != null && ( VAR_1 instanceof TYPE_1 ) && TYPE_2 . equals ( name , ( ( TYPE_1 ) VAR_1 ) . name ) ; <END> } 
<START> public static boolean METHOD_1 ( String VAR_1 , String text , boolean VAR_2 ) { <END> return VAR_2 ? StringUtils . VAR_3 ( VAR_1 , text ) : StringUtils . contains ( VAR_1 , text ) ; } 
public <START> List < String > METHOD_1 ( ) <END> { return new ArrayList < > ( VAR_1 ) ; } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( TYPE_1 . class ) . to ( builder . VAR_1 ( ) ) . in ( TYPE_2 . class ) ; <END> bind ( TYPE_3 . class ) . to ( TYPE_4 . class ) . in ( TYPE_2 . class ) ; bind ( TYPE_5 . class ) . to ( TYPE_6 . class ) . in ( TYPE_2 . class ) ; } 
protected void METHOD_1 ( ) { <START> TYPE_1 . log ( this . toString ( ) + STRING_1 ) ; <END> VAR_1 . METHOD_1 ( METHOD_2 ( ) , new TYPE_2 ( view ) , context . getStatus ( ) . METHOD_3 ( ) ) ; } 
public TYPE_2 ( ) { <START> super ( ) ; <END> VAR_2 = new TYPE_1 ( this ) ; } 
<START> public TYPE_1 ( ) { <END> super ( ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , String [ ] VAR_2 ) throws TYPE_2 { final long VAR_3 = Long . VAR_4 ( VAR_1 ) ; METHOD_2 ( VAR_3 ) ; final TYPE_3 result = new TYPE_3 ( VAR_2 ) ; <START> result . VAR_5 ( VAR_6 . METHOD_3 ( VAR_3 ) ) ; <END> return result ; } 
public TYPE_1 filter ( TYPE_1 request ) throws TYPE_2 { if ( this . VAR_1 ) { request = METHOD_1 ( request , this . VAR_2 ) ; } else { request = METHOD_2 ( request ) ; <START> } <END> VAR_3 . METHOD_3 ( VAR_4 , request , STRING_1 ) ; return request ; } 
public void METHOD_1 ( TYPE_1 key , long VAR_1 , TimeUnit VAR_2 ) { <START> if ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( TYPE_3 . VAR_4 ) ) { <END> throw new TYPE_2 ( STRING_1 ) ; } METHOD_6 ( key ) ; METHOD_7 ( key , VAR_1 , VAR_2 ) ; } 
<START> public TYPE_1 METHOD_1 ( String name ) { <END> TYPE_1 channel = this . VAR_1 . METHOD_2 ( name ) ; if ( channel == null ) { channel = this . VAR_1 . METHOD_3 ( name ) ; METHOD_4 ( name , channel ) ; } return channel ; } 
protected TYPE_1 METHOD_1 ( ANNOTATION_1 final TYPE_2 VAR_1 , ANNOTATION_1 TYPE_3 session ) { return new TYPE_1 ( ) { @Override public void METHOD_2 ( ANNOTATION_1 TYPE_4 o ) { <START> super . METHOD_2 ( o ) ; <END> METHOD_3 ( o . VAR_2 ( ) , o . VAR_3 ( ) , VAR_1 ) ; } @Override public void METHOD_4 ( ANNOTATION_1 TYPE_5 o ) { super . METHOD_4 ( o ) ; METHOD_3 ( o . VAR_2 ( ) , o . VAR_3 ( ) , VAR_1 ) ; } } ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> this . name = this . METHOD_1 ( ) . METHOD_2 ( ) ; <END> } 
public void start ( ) { VAR_1 = TYPE_1 . METHOD_1 ( cache . getName ( ) ) ; this . VAR_2 = configuration . VAR_3 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; this . VAR_4 = configuration . VAR_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; <START> this . VAR_5 = configuration . VAR_6 ( ) . METHOD_6 ( ) . METHOD_7 ( ) || configuration . VAR_6 ( ) . METHOD_6 ( ) . METHOD_8 ( ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { String VAR_1 = null ; TYPE_1 url = null ; try { VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; } catch ( TYPE_2 ex ) { <START> LOG . error ( STRING_1 , ex . VAR_4 ( ) , ex ) ; <END> } try { url = new TYPE_1 ( VAR_1 ) ; } catch ( TYPE_3 ex ) { LOG . error ( STRING_2 , ex . getMessage ( ) , ex ) ; } return url ; } 
public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > result = new ArrayList < > ( ) ; Set < TYPE_1 > VAR_1 = new HashSet < > ( ) ; for ( TYPE_2 f : METHOD_2 ( ) ) { <START> TYPE_1 VAR_2 = f . VAR_3 ( ) ; <END> if ( VAR_1 . add ( VAR_2 ) ) { result . add ( VAR_2 ) ; } } return Collections . VAR_4 ( result ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 , Object content ) { TYPE_1 request = request ( TYPE_3 . VAR_3 , VAR_1 ) ; try { String VAR_4 = new TYPE_2 ( ) . METHOD_2 ( content ) ; <START> request . VAR_5 ( VAR_4 . METHOD_3 ( STRING_1 ) ) ; <END> } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return request ; } 
private int [ ] METHOD_1 ( ) { <START> int props [ ] = new int [ VAR_1 ] ; <END> for ( int i = 0 ; i < VAR_1 ; i ++ ) { props [ i ] = i ; } return props ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 req = request ( TYPE_2 . VAR_2 , METHOD_2 ( ) + STRING_1 + METHOD_3 ( ) ) ; req . VAR_3 ( STRING_2 , "" ) ; METHOD_4 ( req ) ; <START> METHOD_5 ( VAR_4 <END> . METHOD_6 ( Context . VAR_5 ( ) . METHOD_7 ( METHOD_3 ( ) ) ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; if ( VAR_2 != VAR_1 . METHOD_3 ( ) ) { throw new IllegalArgumentException ( STRING_2 ) ; } TYPE_2 [ ] VAR_3 = Arrays . VAR_4 ( VAR_5 , VAR_5 . length + 1 ) ; <START> System . VAR_6 ( VAR_5 , 0 , VAR_3 , 0 , VAR_5 . length ) ; <END> VAR_3 [ VAR_5 . length ] = VAR_1 ; return new TYPE_1 ( VAR_3 ) ; } 
public void close ( ) { TYPE_1 . METHOD_1 ( VAR_1 ) ; try { VAR_2 . METHOD_2 ( ) ; } <START> finally { <END> } } 
private void METHOD_1 ( Throwable t ) { List < TYPE_1 > VAR_1 ; synchronized ( VAR_2 ) { <START> VAR_1 = new ArrayList < > ( VAR_2 . size ( ) ) ; <END> VAR_1 . addAll ( VAR_2 . values ( ) ) ; } for ( TYPE_1 data : VAR_1 ) { data . VAR_3 . METHOD_2 ( false ) ; data . VAR_4 ( t ) ; } } 
<START> public final int METHOD_1 ( ) { return ( int ) ( VAR_1 > > > INT_1 ) ; } <END> 
private void close ( ) { try { METHOD_1 ( ) ; <START> VAR_1 . close ( ) ; <END> if ( VAR_2 != null ) { VAR_2 . close ( ) ; VAR_2 = null ; } } catch ( Exception ex ) { } } 
private static void METHOD_1 ( TYPE_1 VAR_1 , File file , String VAR_2 ) { byte [ ] VAR_3 = VAR_2 . METHOD_2 ( ) ; try ( TYPE_2 VAR_4 = VAR_1 . create ( file ) ) { VAR_4 . write ( ByteBuffer . VAR_5 ( VAR_3 ) ) ; <START> VAR_4 . close ( ) ; <END> } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
public boolean METHOD_1 ( ) { <START> return VAR_1 != null && VAR_1 . METHOD_1 ( ) ; <END> } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; <START> METHOD_1 ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> } 
public String METHOD_1 ( ) { String VAR_1 = METHOD_2 ( VAR_2 [ VAR_3 ] ) ; String VAR_4 = METHOD_2 ( VAR_2 [ VAR_5 ] ) ; TYPE_1 sb = new TYPE_1 ( ) ; <START> sb . append ( VAR_1 ) . append ( CHAR_1 ) . append ( TYPE_2 . VAR_7 ) . append ( TYPE_2 . VAR_8 ) . append ( CHAR_1 ) ; <END> sb . append ( VAR_4 ) ; return sb . toString ( ) ; } 
public boolean METHOD_1 ( TYPE_1 request ) throws TYPE_2 { TYPE_3 VAR_1 = request . VAR_2 ( ) ; TYPE_4 VAR_3 = VAR_4 . METHOD_2 ( TYPE_4 . class ) ; if ( null == VAR_3 ) { return true ; } TYPE_3 [ ] VAR_5 = VAR_3 . METHOD_3 ( ) ; <START> if ( TYPE_5 . isEmpty ( VAR_5 ) || TYPE_5 . contains ( VAR_5 , VAR_1 ) ) { <END> return true ; } return false ; } 
private boolean METHOD_1 ( String string ) { try { TYPE_1 uri = new TYPE_1 ( STRING_1 + string ) ; if ( uri . VAR_1 ( ) == null || uri . VAR_2 ( ) == - 1 ) { <START> throw new TYPE_2 ( uri . toString ( ) , STRING_2 ) ; <END> } } catch ( TYPE_2 ex ) { return false ; } return true ; } 
private int METHOD_1 ( ) { <START> if ( ! METHOD_2 ( VAR_1 ) ) VAR_1 = VAR_2 ; <END> return VAR_1 ++ ; } 
public TYPE_2 ( TYPE_1 ... VAR_2 ) { <START> this . VAR_2 = new ArrayList < > ( Arrays . asList ( VAR_2 ) ) ; <END> } 
public void METHOD_1 ( ) { int i = VAR_1 . get ( 0 ) ; <START> assertTrue ( i == 1 ) ; <END> try { VAR_1 . get ( VAR_1 . size ( ) ) ; } catch ( TYPE_1 e ) { return ; } METHOD_2 ( STRING_1 ) ; } 
public String METHOD_1 ( TYPE_1 [ ] args , String [ ] VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( args , VAR_1 ) ; TYPE_4 . METHOD_3 ( VAR_2 ) ; String cmd = VAR_2 . getString ( 0 ) ; <START> if ( args . length == 2 ) <END> return VAR_3 . METHOD_1 ( cmd , VAR_2 . getInt ( 1 ) ) ; else return VAR_3 . METHOD_1 ( cmd ) ; } 
<START> public synchronized static Set < Class < ? extends TYPE_1 > > METHOD_1 ( TYPE_2 VAR_1 ) { <END> final Set < Class < ? extends TYPE_1 > > VAR_2 = VAR_1 . METHOD_2 ( TYPE_1 . class ) ; logger . debug ( STRING_1 , VAR_2 . size ( ) , VAR_2 ) ; return VAR_2 ; } 
protected Map < String , Object > METHOD_1 ( String VAR_1 ) { Map < String , Object > VAR_2 = new TYPE_1 < String , Object > ( ) ; for ( Map . Entry < String , Object > e : VAR_3 . entrySet ( ) ) { <START> if ( e . getKey ( ) != null && e . getKey ( ) . startsWith ( VAR_1 ) ) { <END> VAR_2 . put ( e . getKey ( ) , e . getValue ( ) ) ; } } return VAR_2 ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 = METHOD_2 ( VAR_2 ) ; if ( R . VAR_3 . METHOD_3 ( TYPE_2 . VAR_5 ) && ! R . VAR_3 . get ( TYPE_2 . VAR_5 ) . isEmpty ( ) ) { <START> LOGGER . info ( STRING_1 ) ; <END> METHOD_4 ( VAR_2 ) ; } return VAR_2 ; } 
<START> public synchronized TYPE_1 METHOD_1 ( String VAR_1 , String host , int VAR_2 , TYPE_2 [ ] VAR_3 ) { <END> return new TYPE_3 ( VAR_4 , VAR_3 , VAR_5 , VAR_6 , host , VAR_2 , this ) ; } 
<START> public static TYPE_1 get ( ) { <END> return TYPE_2 . METHOD_1 ( TYPE_3 . class ) . METHOD_2 ( ) ? VAR_1 : VAR_2 ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( METHOD_2 ( ) , STRING_1 ) ; TYPE_3 res = METHOD_3 ( ) . execute ( VAR_1 ) ; if ( res != null && res . VAR_2 ( ) ) { <START> if ( res . VAR_3 ( ) . equals ( STRING_2 ) ) { <END> return TYPE_1 . VAR_4 ; } } return TYPE_1 . VAR_5 ; } 
public boolean METHOD_1 ( ) { boolean VAR_1 = false ; if <START> ( TYPE_2 . TYPE_3 . METHOD_2 ( ) . equals ( METHOD_3 ( ) ) ) <END> { VAR_1 = true ; } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 out , Object data ) throws IOException { if ( data != null ) { <START> out . VAR_1 ( data ) ; <END> } else { logger . warn ( STRING_1 ) ; } } 
public void METHOD_1 ( ) { try { log . debug ( STRING_1 ) ; TYPE_1 . METHOD_2 ( TYPE_2 . TYPE_3 , ( ) - > { VAR_3 . METHOD_3 ( new Date ( ) ) ; VAR_4 . METHOD_4 ( VAR_3 ) ; <START> log . debug ( STRING_2 ) ; <END> return null ; } ) ; } catch ( Exception ex ) { log . error ( STRING_3 , ex . getMessage ( ) ) ; log . debug ( STRING_4 , ex ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_3 . METHOD_2 ( STRING_1 ) ; <END> this . VAR_2 . put ( Utils . VAR_3 , VAR_1 ) ; return this ; } 
private boolean METHOD_1 ( TYPE_1 entity , TYPE_2 position ) { <START> return entity . VAR_1 ( ) || VAR_2 . METHOD_2 ( position ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; <START> TYPE_4 VAR_4 = null ; <END> if ( ( VAR_3 != null ) && ( VAR_3 instanceof TYPE_4 ) ) { return ( ( TYPE_4 ) VAR_3 ) . METHOD_3 ( ) ; } return null ; } 
<START> @Override public String toString ( ) <END> { return STRING_1 + metadata + CHAR_1 ; } 
public static TYPE_1 METHOD_1 ( final List < TYPE_2 > VAR_1 , final TYPE_3 VAR_2 ) { <START> final TYPE_1 VAR_3 = new TYPE_1 ( <END> new TYPE_4 ( STRING_1 ) , VAR_1 , VAR_2 ) ; return VAR_3 ; } 
public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { METHOD_2 ( VAR_2 . isPresent ( ) , STRING_1 ) ; if ( VAR_3 ) { <START> throw new IllegalStateException ( STRING_2 ) ; <END> } VAR_2 . get ( ) . METHOD_3 ( VAR_1 . getId ( ) , VAR_4 ) ; } 
public TYPE_1 [ ] METHOD_1 ( int start , int length ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( new TYPE_4 ( ) , length ) ; <START> for ( int i = start ; i < start + length ; i ++ ) { <END> VAR_1 . METHOD_3 ( ) ; } return new TYPE_1 [ ] { VAR_1 . build ( ) } ; } 
public List < TYPE_1 > METHOD_1 ( ) { <START> LOG . info ( STRING_1 ) ; <END> TYPE_2 VAR_1 = new TYPE_2 ( ) ; return VAR_1 . METHOD_2 ( ) ; } 
protected void METHOD_1 ( ) { logger ( ) . debug ( STRING_1 , getName ( ) , METHOD_2 ( ) ) ; try { client . close ( ) ; VAR_1 . METHOD_3 ( ) ; } catch ( Exception e ) { <START> } <END> } 
private void METHOD_1 ( String description ) { VAR_1 . setText ( description ) ; VAR_1 . METHOD_2 ( new TYPE_1 ( ) { @Override public void run ( ) { if ( ! VAR_2 . METHOD_3 ( ) ) { return ; } if ( VAR_1 . METHOD_4 ( ) > 2 ) { <START> VAR_1 . METHOD_5 ( View . VAR_3 ) ; <END> } else { VAR_1 . METHOD_5 ( View . VAR_4 ) ; } } } ) ; } 
<START> TYPE_1 METHOD_1 ( ) { <END> return TYPE_1 . this ; } 
<START> public static String get ( ) { return props . VAR_1 ( VAR_2 , STRING_1 ) ; } <END> 
<START> protected TYPE_1 METHOD_1 ( TYPE_1 parent , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <END> TYPE_1 VAR_3 = METHOD_2 ( parent , VAR_2 ) ; METHOD_3 ( VAR_3 , VAR_2 ) ; METHOD_4 ( VAR_3 , VAR_2 , VAR_1 ) ; METHOD_5 ( parent , VAR_1 , VAR_2 ) ; return VAR_3 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 . size ( ) > 0 ) { METHOD_2 ( VAR_1 ) ; } else { METHOD_3 ( VAR_1 ) ; } <START> Log . d ( getClass ( ) . METHOD_4 ( ) , STRING_1 + VAR_2 . size ( ) ) ; <END> } 
private static void METHOD_1 ( File VAR_1 ) { long VAR_2 = System . currentTimeMillis ( ) - ( VAR_3 * Constants . VAR_4 ) ; File [ ] VAR_5 = VAR_1 . METHOD_2 ( ) ; for ( File file : VAR_5 ) { if ( ! TYPE_1 . METHOD_3 ( file , VAR_2 ) ) { <START> METHOD_4 ( file ) ; <END> } } } 
boolean VAR_1 ( ) throws Exception ; } public static void VAR_2 ( String message , <START> int VAR_3 , <END> TYPE_2 VAR_5 ) throws Exception { int VAR_6 = INT_1 ; final long VAR_7 = System . currentTimeMillis ( ) + VAR_3 * INT_2 ; while ( System . currentTimeMillis ( ) < VAR_7 ) { if ( VAR_5 . VAR_1 ( ) ) { return ; } TYPE_1 . VAR_9 ( ) . VAR_6 ( VAR_6 ) ; } VAR_10 ( message ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( false ) ; if ( METHOD_3 ( ) == null ) { log . warn ( STRING_1 ) ; <START> METHOD_4 ( true ) ; <END> } METHOD_3 ( ) . METHOD_5 ( TYPE_2 . TYPE_1 ) ; METHOD_6 ( ) . METHOD_7 ( METHOD_8 ( ) ) ; METHOD_9 ( ) . update ( METHOD_3 ( ) . METHOD_10 ( ) ) ; METHOD_4 ( true ) ; } 
protected TYPE_1 METHOD_1 ( ) { TYPE_1 element = new TYPE_1 ( ) ; element . VAR_1 ( TYPE_2 . METHOD_2 ( METHOD_3 ( ) ) . METHOD_4 ( TYPE_3 . from ( Arrays . asList ( <START> VAR_2 . METHOD_5 ( ) ) ) . METHOD_6 ( VAR_3 ) ) ) ; <END> return element ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( VAR_1 != null ) { VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; METHOD_5 ( VAR_1 ) ; ( ( TYPE_1 ) VAR_2 ) . METHOD_6 ( VAR_1 ) ; <START> TYPE_2 . d ( TAG , STRING_1 + VAR_1 . METHOD_7 ( ) + STRING_2 ) ; <END> } } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> return Double . VAR_1 ( that . VAR_2 , VAR_2 ) == 0 && <END> Double . VAR_1 ( that . VAR_3 , VAR_3 ) == 0 && TYPE_2 . equals ( VAR_4 , that . VAR_4 ) ; } 
public TYPE_2 ( final TYPE_1 VAR_2 , final TYPE_1 VAR_3 , final String VAR_4 , final String VAR_5 , final String VAR_6 , final boolean VAR_7 , final long VAR_8 , final int VAR_9 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; this . VAR_8 = VAR_8 ; <START> this . VAR_10 = VAR_9 ; <END> } 
public void METHOD_1 ( String VAR_1 , boolean VAR_2 ) { table . VAR_3 ( STRING_1 , true ) ; <START> VAR_4 . METHOD_1 ( STRING_1 , true ) ; <END> } 
private void METHOD_1 ( String s ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_2 . getInstance ( ) ) ; TYPE_1 . TYPE_4 e = VAR_1 . METHOD_3 ( ) ; e . VAR_2 ( STRING_1 , true ) ; e . VAR_3 ( STRING_2 , s ) ; <START> e . commit ( ) ; <END> } 
default List < TYPE_1 > VAR_2 ( ) { <START> return VAR_3 ( ) ; <END> } 
public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { VAR_4 = new TYPE_3 ( VAR_2 ) ; VAR_5 = new TYPE_4 ( VAR_2 ) ; VAR_6 = new TYPE_5 ( VAR_3 ) ; VAR_7 = <START> VAR_5 . VAR_8 . equals ( TYPE_4 . VAR_9 ) <END> ? null : new TYPE_6 ( VAR_5 . VAR_8 , VAR_4 ) ; } 
private void METHOD_1 ( Exception ex , TYPE_1 VAR_1 , TYPE_2 < ? > message ) { if ( this . logger . VAR_2 ( ) ) { this . logger . info ( STRING_1 + VAR_1 + STRING_2 + message + STRING_3 + ex . getMessage ( ) + STRING_4 ) ; } else if ( this . logger . VAR_3 ( ) ) { this . logger . debug ( STRING_1 + VAR_1 + STRING_2 + message + <START> STRING_5 , ex ) ; <END> } } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( true ) ; <START> METHOD_3 ( ) ; <END> log . info ( STRING_1 ) ; } 
private static List < TYPE_1 > METHOD_1 ( TYPE_2 [ ] VAR_1 ) { <START> List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; <END> for ( TYPE_2 VAR_3 : VAR_1 ) { TYPE_3 args = new TYPE_3 ( new ArrayList < String > ( ) ) ; VAR_2 . add ( new TYPE_1 ( VAR_3 , args ) ) ; } return VAR_2 ; } 
public String METHOD_1 ( String name ) throws IOException { String output = "" ; if ( METHOD_2 ( ) != null ) { try ( TYPE_1 is = METHOD_3 ( name ) ) { if ( is == null ) { output = TYPE_2 . METHOD_4 ( new File ( name ) , VAR_1 ) ; } <START> else output = TYPE_3 . toString ( is , VAR_1 ) ; <END> } } return output ; } 
public void METHOD_1 ( int VAR_1 , String startsWith ) { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( new TYPE_2 ( ) . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_4 , VAR_5 ) , <START> new TYPE_4 ( new TYPE_5 ( VAR_6 ) , TYPE_7 . VAR_8 , TYPE_6 . METHOD_5 ( startsWith ) ) ) ) ; <END> assertEquals ( VAR_1 , VAR_2 . size ( ) ) ; } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_1 > VAR_2 ) { String VAR_3 = METHOD_2 ( VAR_1 ) ; <START> if ( null == VAR_3 ) { <END> return false ; } String VAR_4 = null ; for ( TYPE_1 VAR_5 : VAR_2 ) { VAR_4 = METHOD_2 ( VAR_5 ) ; if ( VAR_3 . equals ( VAR_4 ) ) { return true ; } } return false ; } 
public static TYPE_1 < TYPE_2 , Double > METHOD_1 ( ) { return new TYPE_1 < TYPE_2 , Double > ( ) { @Override ANNOTATION_1 public Double apply ( TYPE_2 input ) { if ( input . VAR_1 ( ) == null ) return null ; <START> return input . VAR_1 ( ) . METHOD_2 ( ) ; <END> } } ; } 
public void METHOD_1 ( TYPE_1 request ) throws InterruptedException { TYPE_2 stream = new TYPE_2 ( request . VAR_1 ( ) ) ; try { stream . VAR_2 ( ) ; } catch ( IOException e ) { <START> throw new InterruptedException ( STRING_1 + e ) ; <END> } VAR_3 . put ( request ) ; } 
<START> public static final TYPE_1 create ( ) { <END> return new TYPE_2 ( ) ; } 
public void METHOD_1 ( ) { for ( Path file : VAR_1 ) { try { if ( VAR_2 . exists ( file ) && ! VAR_2 . METHOD_2 ( file , false ) ) { throw new IOException ( STRING_1 ) ; } } catch ( IOException e ) { log . warn ( e , STRING_2 + file ) ; } <START> } <END> VAR_3 . METHOD_1 ( ) ; } 
private void METHOD_1 ( String content ) throws IOException { File VAR_1 = new File ( VAR_2 . METHOD_2 ( ) , STRING_1 ) ; write ( VAR_1 , content ) ; <START> final long VAR_3 = TYPE_1 . getInstance ( ) . METHOD_3 ( ) ; <END> final int VAR_4 = INT_1 * INT_2 ; VAR_1 . METHOD_4 ( VAR_3 - VAR_4 ) ; } 
protected TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( STRING_1 , new ArrayList < > ( ) , false , true ) ; <END> } 
private void METHOD_1 ( String path , String source , String VAR_1 ) throws Exception { String VAR_2 = METHOD_2 ( path , source , VAR_1 ) ; VAR_3 . METHOD_3 ( new TYPE_1 ( VAR_2 ) , <START> TYPE_2 . METHOD_4 ( TYPE_3 . METHOD_5 ( ) ) ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; <START> if ( VAR_2 != null ) { <END> VAR_1 = VAR_2 ; } else { for ( TYPE_1 VAR_3 : this . METHOD_2 ( ) ) { if ( VAR_3 instanceof TYPE_2 ) { TYPE_2 VAR_4 = ( TYPE_2 ) VAR_3 ; if ( VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) && ( this . METHOD_5 ( ) == VAR_4 . getValue ( ) ) ) { VAR_1 = VAR_4 ; break ; } } } } return VAR_1 ; } 
<START> TYPE_1 ( TYPE_1 VAR_1 ) <END> { super ( VAR_1 ) ; this . id = VAR_1 . id ; this . VAR_2 = VAR_1 . VAR_2 ; this . name = VAR_1 . name ; } 
<START> public TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_2 . VAR_2 ) Long id ) { <END> VAR_3 . METHOD_1 ( id ) ; return null ; } 
protected TYPE_1 METHOD_1 ( ) { String version = TYPE_2 . METHOD_2 ( ) ; TYPE_3 VAR_1 = null ; <START> if ( version . startsWith ( STRING_1 ) && ( version . contains ( STRING_2 ) || version . contains ( STRING_3 ) ) ) { <END> VAR_1 = new TYPE_3 ( new String ( STRING_4 ) ) ; } else { VAR_1 = new TYPE_3 ( new String ( STRING_5 ) ) ; } METHOD_3 ( VAR_1 ) ; return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 event , boolean VAR_1 ) { if ( VAR_2 && METHOD_2 ( ) ) { return ; } if ( ( VAR_3 . equals ( TYPE_3 . VAR_5 ) || VAR_1 ) && VAR_6 != null ) { <START> ANNOTATION_1 TYPE_2 VAR_7 = VAR_6 ; <END> METHOD_3 ( VAR_7 , event ) ; if ( ! VAR_7 . METHOD_4 ( ) ) { METHOD_5 ( VAR_7 ) ; VAR_6 = null ; } } } 
public boolean METHOD_1 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
private Guid METHOD_1 ( TYPE_1 action ) { if ( action . VAR_1 ( ) && <START> ( action . VAR_2 ( ) . METHOD_2 ( ) || action . VAR_2 ( ) . METHOD_3 ( ) ) ) { <END> return METHOD_4 ( action ) ; } return null ; } 
public Object [ ] factory ( ) { <START> List VAR_1 = new ArrayList < > ( ) ; <END> VAR_1 . add ( new TYPE_1 ( ) . METHOD_1 ( false ) . METHOD_2 ( TYPE_2 . VAR_3 ) . METHOD_3 ( false ) ) ; VAR_1 . add ( new TYPE_1 ( ) . METHOD_1 ( true ) . METHOD_2 ( TYPE_2 . VAR_3 ) . METHOD_3 ( false ) ) ; return VAR_1 . METHOD_4 ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> Set < TYPE_2 > VAR_2 = null ; <END> boolean VAR_3 = false ; if ( VAR_1 != null ) { VAR_2 = VAR_1 . METHOD_2 ( ) ; for ( TYPE_2 VAR_4 : VAR_2 ) { if ( VAR_4 instanceof TYPE_3 ) { VAR_3 = true ; } } } return VAR_3 ; } 
TYPE_1 read ( long VAR_1 ) { if ( ! VAR_2 . getParameters ( ) . METHOD_1 ( ) ) { TYPE_1 data = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( data == null ) { final TYPE_1 VAR_4 = METHOD_3 ( VAR_1 ) ; <START> data = VAR_3 . METHOD_4 ( ) . METHOD_5 ( VAR_1 , ( VAR_5 ) - > VAR_4 ) ; <END> } return data ; } return METHOD_3 ( VAR_1 ) ; } 
public void METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 ) ; <END> VAR_1 = null ; } 
public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 != null && METHOD_3 ( VAR_1 ) ) { <END> return METHOD_4 ( ) ? TYPE_1 . VAR_2 : TYPE_1 . VAR_3 ; } else { return METHOD_4 ( ) ? TYPE_1 . VAR_4 : TYPE_1 . VAR_5 ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . VAR_3 ) ; <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; <END> return VAR_1 ; } 
public boolean METHOD_1 ( String key , int VAR_1 ) { <START> String VAR_2 = String . format ( TYPE_1 . VAR_4 , STRING_1 , key , VAR_1 ) ; <END> return METHOD_2 ( VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> METHOD_2 ( VAR_1 . METHOD_3 ( ) . equals ( VAR_2 ) , STRING_1 ) ; <END> return VAR_3 . METHOD_1 ( ( TYPE_3 ) VAR_1 ) ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , String value ) { METHOD_2 ( INT_1 , TimeUnit . VAR_3 ) ; try { VAR_4 . METHOD_3 ( TYPE_1 . METHOD_4 ( <START> TYPE_2 . METHOD_5 ( VAR_1 ) , VAR_2 , METHOD_6 ( value ) ) ) ; <END> } finally { METHOD_7 ( ) ; } } 
public String parse ( ) { StringBuilder VAR_1 = new StringBuilder ( "" ) ; for ( String VAR_2 : VAR_3 ) { <START> VAR_1 . append ( VAR_2 + STRING_1 ) ; <END> } return VAR_1 . toString ( ) ; } 
public void METHOD_1 ( ) throws IOException { TYPE_1 < ? > VAR_1 = new TYPE_1 < > ( new TYPE_2 < > ( ) ) ; VAR_1 . create ( TYPE_3 . create ( Type . VAR_2 ) , new TYPE_4 ( ) ) ; VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; <START> VAR_1 . close ( ) ; <END> } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { this . VAR_1 = VAR_1 ; <START> return this ; <END> } 
<START> public long METHOD_1 ( long VAR_1 ) { <END> TYPE_1 trace = VAR_2 ; if ( trace != null ) { TYPE_2 VAR_3 = trace . VAR_4 ( ) ; return trace . VAR_5 ( VAR_1 - trace . VAR_6 ( ) ) + VAR_3 . METHOD_2 ( ) ; } return 0 ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; try { TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( ) ; TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( ) ; VAR_1 = VAR_3 . METHOD_4 ( ) ; } catch ( TYPE_4 VAR_4 ) { <START> VAR_4 . METHOD_5 ( ) ; <END> } return VAR_1 ; } 
public TYPE_7 ( ) { TYPE_5 . TYPE_6 . METHOD_1 ( new TYPE_2 ( ) { @Override public void METHOD_2 ( TYPE_3 buffer ) { <START> TYPE_4 job = VAR_2 . get ( buffer . VAR_3 ( ) ) ; <END> if ( job != null ) { job . VAR_4 ( ) ; } VAR_2 . remove ( buffer . VAR_3 ( ) ) ; } } ) ; } 
<START> public void METHOD_1 ( ) { <END> this . VAR_1 = new TYPE_1 ( node ) ; } 
protected void METHOD_1 ( final TYPE_1 id , final int type , final byte [ ] data ) { try { super . METHOD_1 ( id , type , data ) ; } catch ( TYPE_2 e ) { <START> TYPE_3 o = new TYPE_3 ( id . VAR_1 ( ) , type , <END> e . VAR_2 ( ) ) ; VAR_3 . add ( o ) ; } } 
public TYPE_1 ( ) { <START> this . VAR_2 = false ; <END> } 
public String METHOD_1 ( ) { if ( VAR_1 == null ) { return "" ; } <START> String s = VAR_1 . getName ( ) . METHOD_2 ( STRING_1 , "" ) + STRING_2 + VAR_2 ; <END> return s ; } 
public void METHOD_1 ( String VAR_1 ) { <START> METHOD_2 ( VAR_2 , VAR_1 ) ; <END> } 
private static < T > void METHOD_1 ( TYPE_1 < T > VAR_1 ) { <START> for ( T VAR_2 : VAR_1 ) { <END> System . out . println ( STRING_1 + VAR_2 ) ; } } 
public int METHOD_1 ( ) { if ( VAR_1 == null ) { return 0 ; } else { return VAR_1 . METHOD_1 ( ) ; <START> } <END> } 
public Response METHOD_1 ( ) throws Exception { TYPE_1 session = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_3 ( ) ) ; TYPE_2 VAR_1 = METHOD_4 ( ) . METHOD_5 ( ) ; String type = VAR_1 . getString ( STRING_1 ) ; TYPE_3 log = ( TYPE_3 ) session . VAR_2 ( ) . METHOD_6 ( type ) ; <START> List < TYPE_4 > VAR_3 = ( log == null ? null : log . VAR_4 ( ) ) ; <END> return METHOD_7 ( VAR_3 ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( "" , new String [ ] { } , null ) ; <END> } 
public int getId ( ) { try { return id ; } catch ( RuntimeException e ) { throw METHOD_1 ( e ) ; } catch ( TYPE_1 e ) { throw METHOD_1 ( e ) ; } catch ( Throwable t ) { throw METHOD_1 ( t ) ; <START> } <END> } 
public TYPE_3 ( HashMap < String , String > VAR_2 ) { this . VAR_2 = VAR_2 ; try { String VAR_3 = VAR_2 . get ( STRING_1 ) ; TYPE_1 url = new TYPE_1 ( VAR_3 ) ; String VAR_4 = url . VAR_5 ( ) ; VAR_6 = STRING_2 + VAR_4 ; <START> } catch ( TYPE_2 VAR_7 ) { <END> VAR_7 . METHOD_1 ( ) ; } } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , INT_1 ) ; METHOD_2 ( STRING_2 , TYPE_1 . METHOD_3 ( ) ) ; <START> METHOD_4 ( STRING_3 , TYPE_2 . class , null ) ; <END> } 
public boolean METHOD_1 ( File file , boolean VAR_1 ) { if ( VAR_1 ) { return this . METHOD_2 ( file ) ; } <START> return file . VAR_2 ( ) ; <END> } 
public ArrayList < TYPE_1 > METHOD_1 ( int resource ) { <START> ArrayList < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; <END> for ( TYPE_1 VAR_2 : VAR_3 ) { if ( ( VAR_2 . METHOD_2 ( ) & resource ) > 0 ) { VAR_1 . add ( VAR_2 ) ; } } return VAR_1 ; } 
public static TYPE_1 getInstance ( final TYPE_2 VAR_1 ) { if ( instance == null ) { instance = new TYPE_1 ( ) ; } <START> instance . VAR_2 ( VAR_1 ) ; <END> return instance ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( TYPE_2 . METHOD_2 ( VAR_1 ) ) <END> this . VAR_1 = VAR_1 ; return this ; } 
<START> public void <END> METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 ; } 
<START> public synchronized void clear ( ) { <END> VAR_1 . METHOD_1 ( INT_1 , INT_1 ) ; VAR_1 . METHOD_2 ( INT_1 , INT_1 ) ; VAR_1 . METHOD_3 ( ) ; super . clear ( ) ; } 
public List < Object > METHOD_1 ( ) { <START> Set < Object > VAR_1 = METHOD_2 ( new TYPE_1 < > ( VAR_2 ) ) ; <END> for ( List < Object > VAR_3 : VAR_4 ) { if ( VAR_3 != null ) { VAR_1 . addAll ( VAR_3 ) ; } } return new ArrayList < > ( VAR_1 ) ; } 
public void METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) ; VAR_2 = VAR_1 ; if ( VAR_3 != null && VAR_1 != null && <START> VAR_1 . length ( ) > 0 ) { <END> TYPE_1 VAR_4 = TYPE_2 . METHOD_3 ( VAR_3 , TYPE_3 . VAR_6 , TYPE_3 . OS ) ; VAR_4 . METHOD_4 ( VAR_1 ) ; } else { METHOD_5 ( TYPE_3 . VAR_6 , TYPE_3 . OS ) ; } } 
public TYPE_1 METHOD_1 ( ) { return new TYPE_2 ( VAR_1 . METHOD_2 ( ) ? VAR_1 . METHOD_3 ( ) : ( entity . VAR_2 ( ) ? entity . VAR_3 ( ) : null ) , <START> <END> VAR_1 . METHOD_4 ( ) ? VAR_1 . METHOD_5 ( ) : ( entity . VAR_4 ( ) ? entity . VAR_5 ( ) : null ) ) ; } 
public TYPE_1 METHOD_1 ( Boolean VAR_1 , TYPE_2 VAR_2 ) { for ( TYPE_3 VAR_3 : VAR_2 . METHOD_2 ( ) ) { <START> VAR_3 . METHOD_3 ( this , VAR_1 ) ; <END> } return null ; } 
public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { synchronized ( VAR_2 ) { this . VAR_1 . clear ( ) ; this . VAR_1 . addAll ( VAR_1 ) ; <START> } <END> return this ; } 
private static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , Collection < TYPE_2 > VAR_2 , List < TYPE_2 > VAR_3 ) { VAR_2 = METHOD_2 ( VAR_2 , VAR_1 ) ; List < TYPE_2 > VAR_4 = METHOD_3 ( VAR_1 ) ; Set < TYPE_2 > VAR_5 = METHOD_4 ( VAR_2 , VAR_4 , VAR_3 ) ; TYPE_1 VAR_6 = METHOD_5 ( VAR_1 , VAR_5 ) ; <START> return VAR_6 ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 parent , TYPE_3 VAR_1 , TYPE_3 VAR_2 ) throws TYPE_4 , IOException { if ( METHOD_2 ( VAR_2 ) ) { <START> return null ; <END> } TYPE_5 VAR_3 = ( TYPE_5 ) parent ; TYPE_1 obj = METHOD_3 ( VAR_3 , VAR_2 ) ; METHOD_4 ( obj ) ; METHOD_5 ( obj ) ; METHOD_6 ( VAR_3 ) ; METHOD_7 ( 1 ) ; log . info ( STRING_1 , obj . VAR_4 ( ) , METHOD_8 ( ) ) ; return obj ; } 
public int METHOD_1 ( ) { <START> return METHOD_2 ( METHOD_3 ( ) , METHOD_4 ( ) , METHOD_5 ( ) , METHOD_6 ( ) , METHOD_7 ( ) , VAR_1 ) ; <END> } 
public void METHOD_1 ( TYPE_1 < ? super TYPE_2 > s ) { VAR_1 = s ; ++ VAR_2 ; s . VAR_3 ( new TYPE_3 ( ) { @Override public void request ( long n ) { <START> if ( VAR_2 == 1 ) { <END> } else { METHOD_2 ( n ) ; } } @Override public void METHOD_3 ( ) { VAR_4 = 0 ; } } ) ; } 
protected static boolean METHOD_1 ( Guid VAR_1 ) { <START> boolean VAR_2 = ! METHOD_2 ( VAR_1 , new TYPE_2 . TYPE_3 . ArrayList < String > ( ) ) ; <END> VAR_2 = VAR_2 && METHOD_3 ( VAR_1 ) ; return VAR_2 ; } 
public void METHOD_1 ( Object VAR_1 ) { VAR_2 = VAR_1 ; TYPE_1 [ ] input = VAR_3 . METHOD_2 ( VAR_1 ) ; synchronized ( VAR_4 ) { <START> VAR_5 = null ; <END> } if ( VAR_6 != null ) { METHOD_3 ( input ) ; METHOD_4 ( 0 ) ; VAR_7 = SWT . VAR_8 ; VAR_9 = SWT . VAR_8 ; VAR_10 = null ; METHOD_5 ( input ) ; } } 
public void METHOD_1 ( TYPE_1 event ) { if ( event . VAR_1 ( ) ) { index = 0 ; METHOD_2 ( ) ; METHOD_3 ( VAR_2 ) . METHOD_4 ( VAR_3 , new TYPE_2 ( ) { @Override public void f ( ) { <START> TYPE_3 . VAR_5 . log ( STRING_1 ) ; <END> VAR_6 = false ; METHOD_3 ( STRING_2 , VAR_2 ) . remove ( ) ; } } ) ; } else { METHOD_3 ( VAR_2 ) . METHOD_5 ( VAR_3 ) ; } } 
public int METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( LOG . VAR_2 ( ) ) { <START> LOG . trace ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } return 0 ; } 
public void update ( TYPE_1 name , String VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = new TYPE_3 ( name , VAR_1 ) ; Map < String , String > VAR_3 = VAR_2 . METHOD_1 ( ) ; <START> TYPE_4 conf = new TYPE_4 ( VAR_3 , VAR_2 ) ; <END> try { VAR_4 . METHOD_2 ( conf ) ; } catch ( TYPE_5 e ) { throw new TYPE_2 ( e ) ; } builder . VAR_5 ( name . VAR_6 ( ) ) ; } 
@Override public Pair < TYPE_1 , TYPE_2 > METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_3 { <START> final TYPE_1 VAR_2 = this . METHOD_2 ( VAR_1 ) ; <END> final TYPE_2 type = VAR_3 . METHOD_3 ( VAR_2 ) ; return Pair . of ( VAR_2 , type ) ; } 
public Object METHOD_1 ( Object instance ) throws TYPE_1 { <START> return instance ; <END> } 
private void METHOD_1 ( TYPE_1 action ) { <START> if ( ! ( action . VAR_1 ( ) && action . VAR_2 ( ) . METHOD_2 ( ) ) ) { return ; } action . VAR_2 ( ) . METHOD_3 ( ) . forEach ( this : : METHOD_4 ) ; <END> } 
public TYPE_1 METHOD_1 ( Context context ) { final TYPE_2 VAR_1 = context . VAR_2 ( ) ; TYPE_3 VAR_3 ; try { <START> if ( VAR_4 . VAR_5 != null ) { <END> return new TYPE_4 ( VAR_4 . VAR_5 ) ; } VAR_3 = VAR_1 . METHOD_2 ( VAR_4 . VAR_6 ) ; final int id = VAR_3 . METHOD_3 ( VAR_4 . VAR_7 , null , null ) ; return VAR_3 . METHOD_1 ( id ) ; } catch ( TYPE_5 e ) { } return null ; } 
protected boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> Log . d ( TAG , STRING_1 ) ; Log . d ( TAG , STRING_2 + VAR_1 ) ; <END> return false ; } 
public boolean equals ( Object o ) { TYPE_1 VAR_1 = ( TYPE_1 ) o ; <START> if ( ! group . equals ( VAR_1 . group ) ) return false ; <END> if ( ! VAR_2 . equals ( VAR_1 . VAR_2 ) ) return false ; return true ; } 
public void METHOD_1 ( final TYPE_1 < TYPE_2 > VAR_1 ) { input . VAR_2 = null ; <START> input . VAR_2 = event - > { <END> VAR_1 . METHOD_2 ( event ) ; return this ; } ; } 
public boolean METHOD_1 ( Object key ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
protected TYPE_1 METHOD_1 ( ) { return ( ) <START> - > { return ImmutableList . of ( METHOD_2 ( Messages . TYPE_5 , TYPE_2 . METHOD_3 ( TYPE_3 : : getName ) ) , new TYPE_4 ( Messages . TYPE_6 ) ) ; } ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , int VAR_3 ) { VAR_4 = VAR_1 ; VAR_5 = VAR_2 ; <START> VAR_6 . add ( new TYPE_2 ( TYPE_4 . TYPE_5 . METHOD_2 ( TYPE_6 . VAR_8 ) , <END> STRING_1 , TYPE_7 . VAR_10 , FLOAT_1 ) ) ; if ( VAR_3 == 0 ) { METHOD_3 ( ) ; } else { METHOD_4 ( ) ; } } 
protected void METHOD_1 ( ) { logger . debug ( STRING_1 ) ; try { VAR_1 . METHOD_2 ( ) ; } catch ( Exception t ) { logger . error ( t . getMessage ( ) , t ) ; } VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; VAR_2 . METHOD_5 ( channel ) ; <START> channel . VAR_3 ( ) . remove ( TYPE_1 . class ) ; <END> } 
public static List < String > METHOD_1 ( TYPE_1 VAR_1 ) { <START> List < String > VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { VAR_2 = new ArrayList < > ( ) ; VAR_2 . add ( "" ) ; } return VAR_2 ; } 
public void METHOD_1 ( TYPE_1 trace ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> if ( ! ( VAR_1 instanceof TYPE_3 ) ) { <END> return ; } try { VAR_1 . METHOD_3 ( trace ) ; VAR_1 . METHOD_4 ( ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_5 ( ) ; } VAR_2 = ( TYPE_3 ) VAR_1 ; } catch ( TYPE_4 e ) { TYPE_5 . METHOD_6 ( ) . METHOD_7 ( STRING_1 , e ) ; } } 
@Override public void METHOD_1 ( Context context , TYPE_1 VAR_1 ) { String action = VAR_1 . METHOD_2 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( TYPE_3 . equals ( action ) ) { if ( VAR_2 != null ) { <START> METHOD_4 ( VAR_2 . METHOD_5 ( VAR_3 , false ) ) ; <END> } } else if ( TYPE_4 . equals ( action ) ) { METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; } } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 ) ; TYPE_1 . TYPE_3 . METHOD_3 ( VAR_1 ) ; VAR_2 . METHOD_4 ( VAR_1 , VAR_3 . size ( ) ) ; METHOD_5 ( ) ; <START> if ( METHOD_6 ( ) != null ) { <END> METHOD_6 ( ) . METHOD_7 ( ) ; } } 
<START> public TYPE_1 ( int VAR_2 , int ... VAR_3 ) <END> { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public Map < String , Object > METHOD_1 ( String token ) { <START> TYPE_1 response = Optional . of ( this . VAR_1 . METHOD_2 ( token ) ) <END> . map ( this : : METHOD_3 ) . map ( this : : METHOD_4 ) . map ( this : : METHOD_5 ) . map ( this : : METHOD_6 ) . filter ( TYPE_1 : : METHOD_7 ) . METHOD_8 ( ( ) - > new TYPE_2 ( STRING_1 + token + STRING_2 ) ) ; return METHOD_9 ( response ) ; } 
private boolean METHOD_1 ( ) { boolean VAR_1 = ( METHOD_2 ( ) . METHOD_3 ( ) && <START> ! METHOD_2 ( ) . METHOD_4 ( ) ) <END> || METHOD_2 ( ) . METHOD_5 ( ) ; log . info ( STRING_1 , METHOD_2 ( ) . getName ( ) , VAR_1 ? STRING_2 : STRING_3 , METHOD_2 ( ) . METHOD_3 ( ) , METHOD_2 ( ) . METHOD_4 ( ) , METHOD_2 ( ) . METHOD_5 ( ) ) ; return VAR_1 ; } 
public void METHOD_1 ( ) { super . METHOD_1 ( ) ; VAR_1 . METHOD_2 ( false ) ; <START> VAR_2 . METHOD_2 ( VAR_3 . METHOD_3 ( ) . getValue ( ) ) ; <END> } 
protected void METHOD_1 ( ) { <START> VAR_1 = METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) . toString ( ) ) ; <END> METHOD_5 ( ) ; TYPE_1 VAR_2 = METHOD_6 ( VAR_1 . VAR_3 ) ; VAR_2 . METHOD_7 ( getParameters ( ) . METHOD_4 ( ) ) ; METHOD_8 ( VAR_2 ) ; } 
<START> Boolean METHOD_1 ( ) { <END> final String VAR_1 = TYPE_2 . VAR_3 ; final TYPE_1 user = VAR_4 . METHOD_2 ( ) ; return VAR_5 . METHOD_3 ( VAR_1 , user ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( ) ? null : new TYPE_2 ( ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { TYPE_3 VAR_2 = METHOD_2 ( VAR_3 , TYPE_4 . class ) ; TYPE_5 VAR_4 = VAR_2 . in ( ) ; try { return new TYPE_6 ( VAR_4 ) . build ( ) ; } finally { VAR_4 . close ( ) ; <START> } <END> } 
public void METHOD_1 ( ) throws Exception { String data = METHOD_2 ( STRING_1 ) ; TYPE_1 resource = TYPE_3 . TYPE_4 . METHOD_3 ( data , TYPE_1 . class ) ; assertNotNull ( resource ) ; <START> assertNotNull ( resource . getId ( ) ) ; <END> } 
public TYPE_1 ( String VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> VAR_3 = true ; } 
private int METHOD_1 ( int VAR_1 ) { <START> if ( VAR_2 ) VAR_3 . METHOD_2 ( ) ; <END> if ( VAR_1 == VAR_4 ) { VAR_1 = 0 ; Thread . VAR_5 ( ) ; } else { VAR_1 ++ ; TYPE_1 . METHOD_3 ( ) ; } return VAR_1 ; } 
private static String METHOD_1 ( ) { <START> final StringBuilder sb = new StringBuilder ( ) <END> . append ( METHOD_2 ( VAR_1 ) ) . append ( STRING_1 ) . append ( METHOD_2 ( VAR_2 ) ) ; return sb . toString ( ) ; } 
public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) > 0 ) { VAR_1 . METHOD_3 ( VAR_1 . METHOD_2 ( ) - 1 , true ) ; <START> } <END> } 
public int METHOD_1 ( ) { <START> int result = name != null ? name . VAR_1 ( ) : 0 ; <END> result = INT_1 * result + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) ; result = INT_1 * result + ( VAR_3 != null ? VAR_3 . METHOD_1 ( ) : 0 ) ; return result ; } 
public TYPE_3 ( ) { VAR_2 = this ; <START> VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_1 ( new TYPE_2 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 < ? > VAR_1 , boolean VAR_2 ) { if ( VAR_1 . equals ( METHOD_2 ( ) ) ) { return this ; <START> } else if ( TYPE_3 . METHOD_3 ( VAR_1 ) . equals ( TYPE_6 . TYPE_7 ) <END> && METHOD_2 ( ) . id ( ) == TYPE_6 . TYPE_7 . id ( ) ) { return this ; } return TYPE_5 . METHOD_4 ( this , VAR_1 , VAR_2 ) ; } 
public static boolean METHOD_1 ( ) { boolean VAR_1 = true ; for ( Map . Entry < String , String > entry : METHOD_2 ( ) . entrySet ( ) ) { String VAR_2 = entry . getKey ( ) ; if ( ! TYPE_1 . METHOD_3 ( VAR_2 ) ) { <START> LOG . warn ( STRING_1 + VAR_2 ) ; <END> VAR_1 = false ; } } return VAR_1 ; } 
public String METHOD_1 ( ) { if ( VAR_1 != null ) { METHOD_2 ( ) ; } else { synchronized ( this ) { <START> log . info ( STRING_1 ) ; <END> METHOD_3 ( TYPE_1 . VAR_3 ) ; try { METHOD_4 ( ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; } catch ( Exception e ) { log . error ( STRING_2 , e ) ; } finally { METHOD_3 ( TYPE_1 . VAR_4 ) ; log . info ( STRING_3 ) ; } } } return METHOD_7 ( ) ; } 
static List < TYPE_1 > list ( Type [ ] VAR_1 ) { List < TYPE_1 > result = new ArrayList < > ( VAR_1 . length ) ; <START> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <END> result . add ( get ( VAR_1 [ i ] ) ) ; } return result ; } 
private boolean METHOD_1 ( ) { String value = Optional . VAR_1 ( TYPE_1 . getProperty ( STRING_1 ) ) <START> . METHOD_2 ( STRING_2 ) ; <END> return Boolean . VAR_2 ( value ) ; } 
public Map < String , Integer > METHOD_1 ( ) { <START> synchronized ( this ) { <END> Map < String , Integer > VAR_1 = new HashMap < String , Integer > ( ) ; VAR_1 . put ( STRING_1 , VAR_2 . size ( ) ) ; VAR_1 . put ( STRING_2 , VAR_3 . size ( ) ) ; return VAR_1 ; } } 
public void next ( ) { <START> TYPE_1 VAR_1 = ( TYPE_1 ) this . METHOD_1 ( ) ; <END> TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_3 ) ; if ( VAR_2 != null ) new TYPE_5 . TYPE_4 ( VAR_4 , VAR_2 , VAR_5 ) . execute ( ) ; } 
public void METHOD_1 ( ) throws IOException { final TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) ; final TYPE_3 VAR_2 = new TYPE_3 ( ) ; try { VAR_1 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( STRING_1 ) ; <START> final int VAR_3 = VAR_2 . METHOD_5 ( ) ; <END> TYPE_4 . assertThat ( TYPE_5 . METHOD_6 ( VAR_3 ) , TYPE_6 . METHOD_7 ( true ) ) ; TYPE_4 . assertThat ( VAR_2 . METHOD_8 ( ) , TYPE_6 . METHOD_7 ( true ) ) ; } finally { VAR_1 . close ( ) ; } } 
@Override public void close ( ) { TYPE_1 VAR_1 = TYPE_2 . get ( STRING_1 ) ; if ( VAR_1 != null ) { VAR_1 . close ( ) ; TYPE_2 . METHOD_1 ( STRING_1 ) ; } <START> factory . close ( ) ; <END> } 
void METHOD_1 ( long VAR_1 , long size ) throws IOException { long VAR_2 = Math . VAR_3 ( size , METHOD_2 ( ) . METHOD_3 ( ) - VAR_1 ) ; VAR_4 = ByteBuffer . VAR_5 ( ( int ) VAR_2 ) ; <START> METHOD_4 ( ) . position ( offset . VAR_6 ( ) + VAR_1 ) ; <END> METHOD_4 ( ) . read ( VAR_4 ) ; VAR_7 = VAR_1 ; } 
public TYPE_2 ( String VAR_2 , TYPE_1 VAR_3 ) { super ( VAR_3 ) ; <START> METHOD_1 ( VAR_2 , STRING_1 ) ; <END> this . VAR_2 = VAR_2 ; } 
public TYPE_1 build ( ) throws IllegalArgumentException { <START> List < long [ ] > cache = new ArrayList < long [ ] > ( ) ; <END> for ( byte [ ] VAR_1 : VAR_2 ) { long [ ] result = new long [ 2 ] ; result [ 0 ] = VAR_3 . apply ( VAR_1 , 0 ) ; result [ 1 ] = VAR_3 . apply ( VAR_1 , 1 ) - result [ 0 ] ; cache . add ( result ) ; } return new TYPE_1 ( VAR_3 , cache ) ; } 
<START> public Object METHOD_1 ( Object parent ) { <END> if ( parent == null ) { return this ; } if ( parent instanceof TYPE_1 ) { this . VAR_1 = ( TYPE_2 ) parent ; return this . VAR_1 ; } else { throw new IllegalArgumentException ( STRING_1 + parent . getClass ( ) . getName ( ) + STRING_2 ) ; } } 
public TYPE_1 < TYPE_2 , TYPE_3 < TYPE_4 > , TYPE_5 > METHOD_1 ( ) { <START> return bind ( a - > METHOD_2 ( ) . map ( new TYPE_6 < TYPE_3 < TYPE_4 > , TYPE_3 < TYPE_4 > > ( ) { <END> public TYPE_3 < TYPE_4 > f ( final TYPE_3 < TYPE_4 > VAR_1 ) { return VAR_1 . METHOD_3 ( a ) ; } } ) ) ; } 
public String METHOD_1 ( ) { <START> if ( null == this . VAR_1 ) { return "" ; } return this . VAR_1 ; <END> } 
public boolean execute ( short a , TYPE_1 b ) { try { <START> for ( TYPE_2 c : b . values ( ) ) { <END> c . VAR_1 ( ) ; } } catch ( Exception e ) { TYPE_3 . METHOD_1 ( ) . log ( Level . VAR_2 , STRING_1 , e ) ; } return true ; } 
protected static double METHOD_1 ( TYPE_1 node , TYPE_2 key , TYPE_3 version , boolean VAR_1 ) { List < TYPE_4 > VAR_2 = METHOD_2 ( node , VAR_1 ) ; double VAR_3 = 0 ; for ( TYPE_4 VAR_4 : VAR_2 ) { double val = TYPE_5 . get ( key , VAR_4 , version ) ; <START> VAR_3 += val == Double . TYPE_6 ? 1 : val ; <END> } return VAR_3 / VAR_2 . size ( ) ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { type . VAR_2 = "" ; <START> TYPE_2 element = VAR_1 . METHOD_2 ( ) ; <END> if ( element instanceof TYPE_3 ) { new TYPE_4 ( ( TYPE_3 ) element , STRING_1 ) . METHOD_3 ( ) ; } type . VAR_3 ( VAR_1 . METHOD_2 ( ) ) ; } 
public boolean METHOD_1 ( ) { <START> VAR_1 = VAR_1 || VAR_2 . METHOD_2 ( ) ; <END> return VAR_1 ; } 
public void METHOD_1 ( String VAR_1 ) { TYPE_1 . METHOD_2 ( TYPE_2 . class , VAR_1 ) ; final Set < String > VAR_2 = StringUtils <START> . VAR_3 ( VAR_1 ) ; <END> Assert . VAR_4 ( VAR_2 , STRING_1 ) ; this . VAR_2 = VAR_2 ; } 
<START> final TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <END> while ( VAR_1 != null && ( VAR_1 . getType ( ) == TYPE_1 . VAR_2 || VAR_1 . getType ( ) == TYPE_1 . VAR_3 || VAR_1 . getType ( ) == TYPE_1 . VAR_4 ) ) { VAR_1 = VAR_1 . METHOD_2 ( ) ; } return VAR_1 ; } 
public boolean METHOD_1 ( ) { <START> if ( this . VAR_1 == null || VAR_2 == null ) { <END> return true ; } else { return false ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 < String , TYPE_3 > VAR_1 ) { <START> return new TYPE_1 ( this . VAR_1 ) ; <END> } 
public boolean METHOD_1 ( Object o ) { if ( o instanceof String || o instanceof Long || o instanceof Integer || o instanceof Double || o instanceof TYPE_1 <START> || o instanceof Boolean || o instanceof byte [ ] || o instanceof TYPE_2 ) { <END> return true ; } return METHOD_2 ( ) . METHOD_3 ( o . getClass ( ) ) ; } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = <START> TYPE_2 . METHOD_2 ( false , TYPE_3 . create ( new TYPE_4 ( STRING_1 ) ) ) ; <END> VAR_2 = TYPE_2 . METHOD_3 ( VAR_1 , new TYPE_4 ( STRING_2 ) ) ; } 
public Builder METHOD_1 ( String VAR_1 ) { <START> this . VAR_2 . add ( VAR_1 ) ; <END> return this ; } 
<START> public String METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; return VAR_2 . METHOD_3 ( ) ; } 
public TYPE_1 ( Context context ) { super ( TYPE_1 . class . getName ( ) , context ) ; <START> for ( String VAR_1 : context . VAR_2 ) { <END> TYPE_2 VAR_3 = new TYPE_2 ( new TYPE_3 ( VAR_1 ) ) ; VAR_4 . add ( VAR_3 ) ; } } 
protected void METHOD_1 ( ) { <START> VAR_1 . clear ( ) ; <END> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( 0 ) . METHOD_5 ( ) . METHOD_6 ( null ) ; super . METHOD_1 ( ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( ) . toString ( ) . isEmpty ( ) ) { Log . i ( TAG , STRING_1 ) ; VAR_2 . setText ( "" ) ; } if ( METHOD_3 ( ) ) { METHOD_4 ( false ) ; } <START> TYPE_2 . this . METHOD_5 ( ) ; <END> } 
<START> private void METHOD_1 ( String VAR_1 ) throws TYPE_1 { <END> if ( ! VAR_1 . equalsIgnoreCase ( STRING_1 ) ) { throw new TYPE_1 ( STRING_2 + VAR_1 + STRING_3 ) ; } } 
public byte [ ] METHOD_1 ( ) { <START> Object VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> METHOD_3 ( VAR_1 instanceof byte [ ] , STRING_1 , VAR_1 . getClass ( ) ) ; byte [ ] VAR_3 = ( byte [ ] ) VAR_1 ; if ( VAR_2 . METHOD_4 ( ) ) { return VAR_3 ; } return VAR_2 . METHOD_5 ( ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) && VAR_1 . METHOD_3 ( ) <END> == METHOD_4 ( ) ) { return VAR_1 . METHOD_5 ( METHOD_4 ( ) ) ; } return null ; } 
<START> public TYPE_3 ( TYPE_1 VAR_2 ) { <END> Assert . VAR_3 ( VAR_2 , STRING_1 ) ; this . VAR_4 = new TYPE_2 ( ) ; this . VAR_4 . METHOD_1 ( VAR_2 ) ; this . VAR_4 . METHOD_2 ( false ) ; this . VAR_4 . METHOD_3 ( ) ; } 
public TYPE_1 build ( ) { <START> try { <END> return VAR_1 ; } finally { VAR_1 = null ; } } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { try { TYPE_2 method = TYPE_3 . class . METHOD_2 ( STRING_1 ) ; method . VAR_2 ( true ) ; method . VAR_3 ( VAR_1 ) ; } catch ( Exception e ) { <START> e . VAR_4 ( ) ; <END> METHOD_3 ( STRING_2 + e . toString ( ) ) ; } } 
public TYPE_1 ( String VAR_2 , String val , String VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . val = val ; this . VAR_3 = VAR_3 ; } 
private TYPE_1 METHOD_1 ( ) { org . VAR_1 . client . VAR_2 . configuration . TYPE_4 VAR_4 = super . METHOD_2 ( VAR_5 . get ( 0 ) . METHOD_3 ( ) ) ; VAR_4 . METHOD_4 ( new TYPE_2 ( ) ) ; <START> VAR_4 . METHOD_5 ( METHOD_6 ( ) ) ; <END> return new TYPE_3 ( VAR_4 . build ( ) ) ; } 
<START> static synchronized TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return new ArrayList < TYPE_2 > ( VAR_1 ) ; } 
private void METHOD_1 ( final boolean VAR_1 , final TYPE_1 ... VAR_2 ) { for ( TYPE_1 VAR_3 : VAR_2 ) { VAR_3 . METHOD_2 ( VAR_1 ) ; } if ( VAR_2 . length > 0 <START> && VAR_1 ) <END> { for ( TYPE_1 VAR_3 : VAR_2 ) { if ( VAR_3 instanceof TYPE_2 ) { VAR_3 . METHOD_3 ( ) ; break ; } } } } 
public Object METHOD_1 ( Object VAR_1 , TYPE_1 method , Object [ ] args ) throws Throwable { Object object = method . VAR_2 ( VAR_3 , args ) ; if ( method . getName ( ) . equals ( STRING_1 ) && VAR_4 . contains ( object . getClass ( ) ) ) { <START> object = METHOD_2 ( object ) ; <END> } return object ; } 
private boolean METHOD_1 ( TYPE_1 position ) { return VAR_1 && ! position . VAR_2 ( ) <START> || position . VAR_3 ( ) > INT_1 || position . VAR_4 ( ) > INT_2 <END> || position . VAR_3 ( ) < - INT_1 || position . VAR_4 ( ) < - INT_2 ; } 
public TYPE_8 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final TYPE_3 VAR_4 , final TYPE_4 source , final TYPE_4 target ) { this ( VAR_2 , VAR_3 ) ; VAR_5 = new TYPE_5 ( VAR_4 , VAR_3 , source , target , TYPE_6 . METHOD_1 ( METHOD_2 ( ) ) ) ; <START> this . container = ( TYPE_7 ) source ; <END> } 
public static TYPE_1 METHOD_1 ( final String VAR_1 , final String VAR_2 ) { final TYPE_1 VAR_3 = new TYPE_1 ( 1 ) ; <START> final TYPE_2 < String , List < TYPE_3 > > VAR_4 = new TYPE_2 < > ( ) ; <END> final List < TYPE_3 > VAR_5 = new ArrayList < > ( ) ; VAR_5 . add ( new TYPE_3 ( VAR_1 , 1 , VAR_2 ) ) ; VAR_4 . put ( VAR_1 , VAR_5 ) ; VAR_3 . METHOD_2 ( VAR_4 ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; return VAR_3 ; } 
public TYPE_1 < TYPE_2 > table ( final String VAR_1 , TYPE_3 conf ) throws TYPE_4 { <START> boolean VAR_2 = ! conf . VAR_3 ( TYPE_3 . TYPE_5 . VAR_5 ) ; <END> return new TYPE_1 < > ( VAR_6 , ( ) - > db . VAR_7 ( VAR_8 , VAR_1 , false , false , VAR_2 ) ) ; } 
<START> public List < TYPE_1 > METHOD_1 ( TYPE_2 session ) { <END> return METHOD_2 ( session ) . METHOD_1 ( ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 configuration = METHOD_2 ( ) ; VAR_2 . METHOD_3 ( configuration ) ; configuration . set ( STRING_1 , STRING_2 ) ; try { <START> TYPE_5 . METHOD_4 ( configuration ) ; <END> } catch ( IOException exception ) { throw new TYPE_6 ( exception ) ; } TYPE_7 . METHOD_4 ( configuration ) ; return new TYPE_1 ( VAR_1 ) ; } 
public void METHOD_1 ( ) throws Exception { if ( this . VAR_1 != null ) { this . VAR_1 . close ( ) ; } final Path VAR_2 = TYPE_1 . METHOD_2 ( ) ; if ( TYPE_2 . exists ( VAR_2 ) ) { <START> TYPE_2 . METHOD_3 ( TYPE_1 ) ; <END> } } 
public List < String > METHOD_1 ( final String ... args ) { final List < String > list = new ArrayList < String > ( args . length ) ; list . addAll ( Arrays . asList ( args ) ) ; <START> final List < String > result = new TYPE_1 < > ( ) ; <END> result . addAll ( list . VAR_1 ( 0 , TYPE_2 . VAR_3 ) ) ; return result ; } 
List < Object > METHOD_1 ( int VAR_1 ) { <START> ArrayList < Object > result = new ArrayList < Object > ( ) ; <END> for ( Object [ ] VAR_2 : VAR_3 ) { result . add ( VAR_2 [ VAR_1 ] ) ; } return result ; } 
private static TYPE_1 METHOD_1 ( Context context ) { final int VAR_1 = R . string . VAR_2 ; final String VAR_3 = context . getString ( R . string . TYPE_3 ) ; final String VAR_5 = context . getString ( R . string . TYPE_4 ) ; if ( TYPE_2 . METHOD_2 ( context ) ) return context . getString ( VAR_1 , VAR_3 ) ; <START> return context . getString ( VAR_1 , VAR_5 ) ; <END> } 
public void METHOD_1 ( TYPE_1 view , int VAR_1 , int VAR_2 , int VAR_3 ) { if ( VAR_3 < VAR_4 ) { VAR_5 = VAR_6 ; VAR_4 = VAR_3 ; if ( VAR_3 == 0 ) { <START> VAR_7 = true ; <END> } } if ( VAR_7 && ( VAR_3 > VAR_4 ) ) { VAR_7 = false ; VAR_4 = VAR_3 ; VAR_5 ++ ; } if ( ! VAR_7 && ( VAR_3 - VAR_2 ) <= ( VAR_1 + VAR_8 ) ) { VAR_7 = METHOD_2 ( VAR_5 + 1 , VAR_3 ) ; } } 
private String METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> String VAR_2 = String . VAR_3 ( STRING_1 , VAR_1 . stream ( ) . map ( t - > t . id ( ) ) . collect ( Collectors . VAR_4 ( ) ) ) ; <END> return VAR_2 ; } 
public void METHOD_1 ( String s ) { if ( s != null && ! s . equals ( "" ) ) <START> VAR_1 = new HashSet < String > ( Arrays . asList ( s . split ( STRING_1 ) ) ) ; <END> } 
private Throwable METHOD_1 ( Object error ) { try { return ( ( TYPE_1 ) error ) . METHOD_2 ( ) ; <START> } catch ( Exception e ) { <END> return ( Throwable ) error ; } } 
public void run ( ) { try { this . VAR_1 . METHOD_1 ( ) ; } catch ( final InterruptedException ex ) { Thread . VAR_2 ( ) . METHOD_2 ( ) ; Logger . warn ( this , STRING_1 , ex ) ; } catch ( final Throwable ex ) { <START> Logger . error ( this , STRING_1 , TYPE_1 . METHOD_3 ( ex ) ) ; <END> } } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } 
public TYPE_1 ( ) { <START> this . VAR_2 = METHOD_1 ( 100 ) ; <END> } 
<START> private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { <END> return VAR_1 . METHOD_2 ( ) || VAR_1 . METHOD_3 ( ) . contains ( VAR_2 ) ; } 
public void start ( ) throws Exception { <START> METHOD_1 ( ) ; <END> TYPE_1 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ; } 
public static TYPE_1 METHOD_1 ( String ... VAR_1 ) { TYPE_2 s = null ; final int length = VAR_1 . length ; <START> for ( int i = 0 ; i < length ; i ++ ) { <END> s = new TYPE_2 ( VAR_1 [ length - 1 - i ] , s ) ; } return new TYPE_1 ( s ) ; } 
private void METHOD_1 ( ) { this . VAR_1 = new TYPE_1 ( session ) ; this . VAR_1 . METHOD_2 ( ) ; this . VAR_2 = new TYPE_2 ( session ) ; <START> this . VAR_2 . METHOD_2 ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> VAR_2 . METHOD_3 ( VAR_1 ) ; <END> VAR_1 . METHOD_4 ( ) ; } 
public void METHOD_1 ( ByteBuffer buffer ) { <START> VAR_1 = null ; <END> VAR_1 = buffer ; } 
protected TYPE_1 < ? > METHOD_1 ( Map < String , String > map , int key ) { return ( ( ) - > { try { <START> VAR_1 . METHOD_2 ( ) ; <END> return map . put ( STRING_1 + key , STRING_2 + key ) ; } finally { VAR_1 . METHOD_3 ( ) ; } } ) ; } 
public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = TYPE_2 . getInstance ( ) ; <START> TYPE_3 VAR_3 = TYPE_3 . getInstance ( null ) ; <END> VAR_3 . METHOD_2 ( new TYPE_4 ( ) ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; VAR_2 . METHOD_5 ( METHOD_6 ( ) ) ; VAR_2 . METHOD_5 ( METHOD_7 ( ) ) ; VAR_2 . METHOD_5 ( METHOD_8 ( ) ) ; } 
public void METHOD_1 ( final String name , final TYPE_1 info ) throws TYPE_2 , IOException { final String id = getId ( name ) ; final TYPE_3 out = METHOD_2 ( name , info , id ) ; METHOD_3 ( name , info , id , out ) ; <START> out . close ( ) ; <END> } 
private String METHOD_1 ( String text ) { StringBuilder VAR_1 = new StringBuilder ( ) ; <START> for ( char VAR_2 : text . VAR_3 ( ) ) { <END> if ( VAR_2 != INT_1 && VAR_2 != INT_2 ) { VAR_1 . append ( VAR_2 ) ; } } return VAR_1 . toString ( ) ; } 
public void METHOD_1 ( ) { <START> ( new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 ) ) . log ( TYPE_2 . VAR_5 ) ; <END> } 
public TYPE_4 ( final TYPE_1 session , final TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <START> this ( session , VAR_2 , VAR_3 , null ) ; <END> } 
public TYPE_1 < TYPE_2 > METHOD_1 ( ANNOTATION_1 ( STRING_1 ) List < String > VAR_1 ) throws Exception { <START> TYPE_1 < TYPE_2 > stream ; <END> try ( TYPE_3 VAR_2 = VAR_3 . METHOD_2 ( VAR_4 , TYPE_4 . TYPE_5 . VAR_7 ) ) { stream = METHOD_3 ( VAR_1 , VAR_2 ) ; } return stream ; } 
public TYPE_3 ( ANNOTATION_1 ( STRING_1 ) String id , ANNOTATION_1 ( STRING_2 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_3 ) TYPE_2 VAR_3 ) { this . id = id ; <START> this . VAR_2 = VAR_2 != null ? VAR_2 . METHOD_1 ( ) : null ; <END> this . VAR_3 = VAR_3 ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , SWT . VAR_3 ) ; TYPE_2 VAR_4 ; for ( int i = 0 ; i < VAR_5 . length ; i ++ ) { VAR_4 = new TYPE_2 ( VAR_1 , SWT . NONE ) ; VAR_4 . setText ( VAR_5 [ i ] ) ; final int column = i ; VAR_4 . METHOD_2 ( METHOD_3 ( e - > { <START> METHOD_4 ( column ) ; <END> } ) ) ; } return VAR_1 ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 f ) throws IOException { TYPE_3 in = f . in ( ) ; try { return METHOD_2 ( in ) ; } finally { <START> in . close ( ) ; <END> } } 
<START> public static TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 ) { <END> return TYPE_2 . get ( VAR_1 ) . get ( ) ; } 
public byte [ ] get ( TYPE_1 key ) { byte [ ] res = VAR_1 . get ( key ) ; if ( res == null ) { <START> res = VAR_2 . get ( key ) ; <END> } if ( res == null ) { VAR_3 . METHOD_1 ( ) ; } else { put ( key , res ) ; VAR_4 . METHOD_1 ( ) ; } return res ; } 
<START> public TYPE_1 <END> METHOD_1 ( TYPE_2 page ) { return METHOD_2 ( create ( STRING_1 + page . VAR_1 ( ) + STRING_2 , STRING_3 , VAR_2 , NONE , VAR_3 ) , page . VAR_4 ( ) ) ; } 
private void METHOD_1 ( TYPE_1 s ) { <START> if ( TYPE_3 . TYPE_4 . equals ( VAR_1 ) ) { <END> METHOD_2 ( s ) ; } else { METHOD_3 ( s ) ; } } 
public TYPE_2 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; VAR_3 = null ; <START> VAR_4 = null ; <END> } 
public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> Assert . assertEquals ( METHOD_3 ( STRING_1 ) . text ( ) , STRING_2 ) ; } 
public void METHOD_1 ( String VAR_1 , TYPE_1 listener ) throws TYPE_2 { <START> TYPE_3 VAR_2 = <END> new TYPE_3 ( VAR_1 , listener , this , VAR_3 ) ; synchronized ( VAR_4 ) { TYPE_3 VAR_5 = VAR_6 . put ( listener , VAR_2 ) ; if ( VAR_5 != null ) { throw new IllegalArgumentException ( STRING_1 ) ; } } VAR_2 . start ( ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { <START> ( ( TYPE_2 ) this . METHOD_2 ( ) . METHOD_3 ( ) ) . clear ( ) ; <END> } 
private Optional < TYPE_1 > METHOD_1 ( ) { try { return Optional . of ( VAR_1 . get ( ) ) ; } <START> catch ( Exception VAR_2 ) { <END> } return Optional . empty ( ) ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( TYPE_2 . METHOD_2 ( VAR_2 ) ) { return true ; } else { try { return VAR_3 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_2 ) ; } catch ( TYPE_3 e ) { <START> LOG . warn ( STRING_1 , e ) ; <END> } } return false ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = r . VAR_2 ( STRING_1 , "" , null ) ; TYPE_1 VAR_3 = r . VAR_2 ( STRING_2 , "" , null ) ; r . VAR_4 . METHOD_2 ( VAR_1 ) ; r . VAR_4 . METHOD_3 ( ) . METHOD_4 ( VAR_1 , VAR_3 ) ; r . VAR_4 . METHOD_3 ( ) . METHOD_5 ( ) ; <START> METHOD_6 ( r . VAR_4 . METHOD_7 ( VAR_1 . METHOD_8 ( ) ) ) ; <END> } 
protected void METHOD_1 ( ) { if ( METHOD_2 ( ) ) { view . VAR_1 ( TYPE_3 . TYPE_4 . METHOD_3 ( ) , Constants . VAR_2 . METHOD_4 ( ) , new TYPE_2 ( ) { @Override public void execute ( ) { METHOD_1 ( true ) ; } } , new TYPE_2 ( ) { @Override public void execute ( ) { METHOD_1 ( false ) ; } } , <START> new TYPE_2 ( ) { <END> @Override public void execute ( ) { } } ) ; } else { METHOD_1 ( false ) ; } } 
public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) throws TYPE_2 { <START> synchronized ( VAR_2 ) { <END> if ( VAR_1 != null && VAR_1 . length > 0 ) { TYPE_3 target = TYPE_4 . METHOD_2 ( VAR_1 [ 0 ] , TYPE_3 . class ) ; Set < TYPE_1 > set = VAR_2 . get ( target ) ; if ( set != null ) { set . VAR_3 ( Arrays . asList ( VAR_1 ) ) ; if ( set . isEmpty ( ) ) { VAR_2 . remove ( target ) ; } } } } } 
public Collection < TYPE_1 > METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_1 > VAR_2 = new TYPE_2 < TYPE_1 > ( ) ; <START> VAR_1 . METHOD_2 ( ) ; <END> Object action = METHOD_3 ( VAR_1 ) ; for ( Object VAR_3 : VAR_4 . METHOD_4 ( ) . METHOD_5 ( action , TYPE_4 . TYPE_3 ) ) { if ( ! VAR_3 . equals ( VAR_1 ) ) { VAR_2 . add ( VAR_4 . METHOD_6 ( ) . METHOD_7 ( VAR_3 ) ) ; } } return VAR_2 ; } 
<START> public TYPE_1 iterator ( String query , int VAR_1 , int VAR_2 ) throws TYPE_2 { <END> try { METHOD_1 ( ) ; TYPE_3 VAR_3 = METHOD_2 ( VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; logger . trace ( query ) ; return METHOD_4 ( VAR_3 , query ) ; } catch ( final TYPE_4 e ) { throw e ; } catch ( final Exception e ) { throw new TYPE_2 ( STRING_1 , e ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( ) ; for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { if ( VAR_4 != null ) { VAR_2 . get ( i ) . METHOD_3 ( VAR_4 ) ; } <START> METHOD_4 ( VAR_2 . get ( i ) , VAR_5 , VAR_6 , VAR_7 == i ? true : false , <END> VAR_1 , time ) ; } } 
public TYPE_2 ( final Object data , final TYPE_1 VAR_2 , final String VAR_3 ) { if ( null == data ) { <START> this . type = Object . VAR_4 . getName ( ) ; <END> } else { this . type = data . getClass ( ) . getName ( ) ; } this . data = data ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; } 
public TYPE_1 < TYPE_2 < TYPE_3 , TYPE_4 > > iterator ( ) { return new TYPE_5 < > ( new TYPE_6 < > ( TYPE_7 . iterator ( stream ( ) ) , cache , <START> e - > e . getKey ( ) ) , e - > new TYPE_8 < > ( cache , e ) ) ; <END> } 
public void METHOD_1 ( ) { <START> VAR_1 = null ; <END> } 
public void METHOD_1 ( ) throws Exception { <START> VAR_1 . METHOD_2 ( ) . remove ( STRING_1 ) ; <END> METHOD_3 ( VAR_1 . METHOD_2 ( ) . get ( STRING_1 ) ) ; String result = ( String ) VAR_2 . METHOD_4 ( STRING_2 , new TYPE_1 ( ) . cache ( VAR_1 . METHOD_2 ( STRING_3 ) ) . METHOD_5 ( STRING_1 , STRING_4 ) ) . get ( ) ; assertEquals ( STRING_5 , result ) ; assertEquals ( STRING_4 , VAR_1 . METHOD_2 ( ) . get ( STRING_1 ) ) ; } 
public TYPE_1 METHOD_1 ( ) { <START> return ( TYPE_1 ) ( super . METHOD_1 ( ) ) ; <END> } 
public void METHOD_1 ( long VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> VAR_2 . stream ( ) . forEach ( VAR_3 - > VAR_3 . METHOD_2 ( this , VAR_1 ) ) ; <END> } 
public Set < Integer > METHOD_1 ( ) { synchronized ( VAR_1 ) { Set < Integer > VAR_2 = new HashSet < Integer > ( VAR_1 ) ; <START> VAR_2 . addAll ( VAR_1 ) ; <END> return VAR_2 ; } } 
public void METHOD_1 ( ) { <START> this . VAR_1 . METHOD_2 ( null ) ; <END> this . parent . VAR_2 ( ) ; this . VAR_1 = null ; this . VAR_3 = null ; this . parent = null ; } 
private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { return VAR_1 instanceof TYPE_2 || <START> ( VAR_1 instanceof TYPE_3 && TYPE_2 . class . METHOD_2 ( ) . equals ( ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) . name ( ) ) ) || <END> ( null != VAR_1 && VAR_1 instanceof TYPE_4 && TYPE_2 . class . getName ( ) . equals ( TYPE_4 . class . METHOD_4 ( VAR_1 ) . getType ( ) ) ) ; } 
public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) != null ? METHOD_2 ( ) . METHOD_3 ( ) : null ; return METHOD_4 ( ) != null && VAR_1 != null <START> && ( VAR_1 . METHOD_5 ( ) == METHOD_4 ( ) || ( VAR_1 . METHOD_5 ( ) != null && ( VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) . equals ( METHOD_4 ( ) . METHOD_6 ( ) ) ) ) ) ; <END> } 
private void METHOD_1 ( String VAR_1 ) { TYPE_1 context ; <START> try { <END> context = METHOD_2 ( new TYPE_2 ( STRING_1 , VAR_1 ) ) ; VAR_2 . METHOD_3 ( context ) ; TYPE_3 VAR_3 = new TYPE_3 ( ImmutableList . of ( ( TYPE_4 ) VAR_2 ) ) ; VAR_3 . METHOD_4 ( context ) ; } catch ( IOException e ) { TYPE_5 . METHOD_5 ( e ) ; } } 
public void METHOD_1 ( ) throws Exception { long [ ] VAR_1 = b . VAR_2 ( STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 ) ; <START> assertThat ( VAR_1 ) . METHOD_2 ( new long [ ] { 1 , 2 , 3 , 4 , 5 } ) ; <END> } 
public void METHOD_1 ( ) throws Exception { METHOD_2 ( asList ( TYPE_1 . add ( INT_1 , index , STRING_1 ) , TYPE_1 . add ( INT_2 , index , STRING_1 ) , TYPE_1 . add ( INT_3 , index , STRING_2 ) ) ) ; assertThat ( query ( METHOD_3 ( 1 , STRING_1 ) ) , METHOD_4 ( asList ( INT_1 , INT_2 ) ) ) ; <START> assertThat ( query ( TYPE_2 . exists ( 1 ) ) , METHOD_4 ( asList ( INT_1 , INT_2 , INT_3 ) ) ) ; <END> } 
Response METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> return METHOD_2 ( VAR_3 , VAR_1 , VAR_2 , VAR_4 ) ; <END> } 
<START> private void METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; Collection < ? extends TYPE_2 > VAR_4 = VAR_2 . METHOD_3 ( ) ; Object VAR_5 = METHOD_4 ( VAR_1 ) ; VAR_6 . METHOD_5 ( VAR_5 ) . forEach ( VAR_7 - > METHOD_1 ( VAR_7 , VAR_4 ) ) ; } 
private void METHOD_1 ( ) { log . error ( STRING_1 , getClass ( ) . getName ( ) ) ; METHOD_2 ( ) ; METHOD_3 ( ) ; <START> if ( METHOD_4 ( ) == TYPE_1 . VAR_2 ) { <END> METHOD_5 ( ) ; } } 
public void METHOD_1 ( ) { final TYPE_1 builder = new TYPE_1 ( ) ; final String input = STRING_1 ; <START> final TYPE_2 < String , Object > VAR_1 = new TYPE_2 < > ( ) ; <END> builder . table ( input , VAR_2 ) . METHOD_2 ( TYPE_3 . METHOD_3 ( ) , VAR_3 ) . count ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ; METHOD_6 ( builder , input , VAR_1 ) ; } 
private static TYPE_1 METHOD_1 ( String path ) { try { return new TYPE_1 ( path ) ; } catch ( TYPE_2 e ) { try { return new File ( path ) . METHOD_2 ( ) . METHOD_3 ( ) ; } catch ( TYPE_2 VAR_1 ) { <START> throw new IllegalStateException ( VAR_1 ) ; <END> } } } 
protected void METHOD_1 ( final TYPE_1 filter , final TYPE_2 VAR_1 ) { <START> ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( filter . VAR_2 ( ) ) ; <END> VAR_3 . METHOD_3 ( new TYPE_4 ( METHOD_4 ( ) , filter , VAR_1 ) ) ; } 
<START> void METHOD_1 ( Set < String > VAR_1 ) throws Exception { <END> if ( VAR_2 != null ) { for ( TYPE_1 VAR_3 : VAR_2 ) { METHOD_2 ( factory . VAR_4 ( VAR_3 ) , VAR_1 , false ) ; } } } 
private void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) ; while ( VAR_1 . METHOD_3 ( ) ) { } <START> VAR_1 . METHOD_4 ( ) ; <END> return ; } 
private Map < String , List < Entry < T > > > METHOD_1 ( final Map < String , List < Entry < T > > > VAR_1 ) { final Map < String , List < Entry < T > > > VAR_2 = new HashMap < > ( ) ; VAR_1 . forEach ( ( key , value ) - > VAR_2 . put ( key , new TYPE_1 < > ( value ) ) ) ; <START> return VAR_2 ; <END> } 
@Override public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> Double value = VAR_1 . properties ( ) . METHOD_2 ( STRING_1 , Double . VAR_2 ) ; <END> if ( value . equals ( Double . VAR_2 ) ) { TYPE_2 . METHOD_1 ( VAR_1 . event ( ) ) ; } else { TYPE_2 . METHOD_1 ( VAR_1 . event ( ) , value ) ; } } 
<START> public TYPE_2 ( ) { <END> super ( null , TYPE_1 . VAR_3 ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_2 ( null ) ; <END> METHOD_2 ( new TYPE_3 ( VAR_1 ) ) ; } 
TYPE_6 ( String VAR_2 , String table , List < TYPE_1 > VAR_3 ) { super ( VAR_2 ) ; this . table = table ; this . VAR_3 = VAR_3 ; this . VAR_4 = new TYPE_2 ( this ) ; this . VAR_5 = new TYPE_3 ( this ) ; this . VAR_6 = new TYPE_4 ( this ) ; for ( TYPE_1 VAR_7 : VAR_3 ) { if ( VAR_7 instanceof TYPE_5 ) { <START> if ( ( ( TYPE_5 ) VAR_7 ) . key instanceof Integer ) { <END> METHOD_1 ( ) ; } } } } 
File remove ( long VAR_1 ) { File VAR_2 = null ; TYPE_1 < File > VAR_3 = VAR_4 . get ( VAR_1 ) ; <START> if ( VAR_3 != null ) { <END> if ( VAR_3 . size ( ) != 0 ) { VAR_2 = VAR_3 . remove ( ) ; } } return VAR_2 ; } 
public TYPE_1 create ( ) { <START> List < TYPE_2 > VAR_1 = new TYPE_3 < TYPE_2 > ( ) ; <END> for ( TYPE_4 < ? , ? > VAR_2 : this . VAR_1 ) VAR_1 . add ( VAR_2 . create ( ) ) ; return new TYPE_1 ( VAR_3 , VAR_1 ) ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , String VAR_3 , TYPE_2 container , <END> String VAR_4 , String VAR_5 ) throws TYPE_3 { METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , container , VAR_4 , VAR_5 , true , true ) ; } 
public void METHOD_1 ( List < TYPE_1 > args ) { <START> if ( ! ( args . size ( ) > 0 ) ) { <END> throw new TYPE_2 ( STRING_1 , name ( ) ) ; } } 
public boolean METHOD_1 ( T VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( VAR_1 ) ) return false ; TYPE_1 event = new TYPE_1 ( this , id . toString ( ) , this . value , VAR_1 ) ; <START> this . value = VAR_1 ; <END> METHOD_3 ( event ) ; return true ; } 
public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> final TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( ( ) - > { <END> } ) . METHOD_3 ( ) ; TYPE_2 . METHOD_2 ( ( ) - > { METHOD_4 ( VAR_1 . get ( ) ) ; VAR_1 . set ( true ) ; VAR_2 . METHOD_5 ( ) ; VAR_2 . METHOD_6 ( ) ; } ) . METHOD_3 ( ) ; METHOD_7 ( ) ; assertTrue ( VAR_1 . get ( ) ) ; } 
TYPE_2 ( String name ) { this . name = name ; <START> VAR_2 = new HashMap < String , TYPE_1 > ( ) ; <END> } 
public void METHOD_1 ( ) { Double [ ] params = new Double [ 2 ] ; params [ 0 ] = VAR_1 ; <START> params [ 1 ] = VAR_2 ; <END> TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_2 ( params ) ; METHOD_3 ( VAR_3 ) ; } 
<START> public void METHOD_1 ( final TYPE_1 VAR_1 ) throws IOException { <END> final byte [ ] data = VAR_1 . METHOD_2 ( ) ; if ( data != null ) { final String key = VAR_2 . METHOD_3 ( VAR_3 . getId ( ) ) ; VAR_4 . set ( key , METHOD_4 ( VAR_3 . METHOD_5 ( ) ) , data ) ; } else { VAR_5 . warn ( STRING_1 + VAR_1 . getStatus ( ) + STRING_2 + VAR_3 . METHOD_6 ( ) + STRING_3 + STRING_4 ) ; } } 
public void METHOD_1 ( ) throws Exception { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } } 
protected void METHOD_1 ( final TYPE_1 request ) { <START> if ( VAR_1 == null || VAR_1 . METHOD_2 ( ) ) { <END> request . VAR_2 ( ) ; return ; } TYPE_2 VAR_3 = new TYPE_2 ( this , request ) ; if ( TYPE_3 . METHOD_3 ( ) ) { TYPE_3 . METHOD_4 ( request , STRING_1 ) ; } VAR_1 . execute ( VAR_3 ) ; } 
public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 item ) { for ( TYPE_1 VAR_1 : VAR_2 ) { <START> if ( item . VAR_3 == VAR_1 . VAR_3 <END> && item . VAR_4 == VAR_1 . VAR_4 && item . name . equals ( VAR_1 . name ) ) { return true ; } } return false ; } 
public void METHOD_1 ( ) { <START> long r = get ( ) ; <END> if ( r != Long . VAR_1 ) { VAR_2 . METHOD_1 ( ) ; } } 
public TYPE_2 ( ) { <START> VAR_2 = new TYPE_1 < > ( ) ; <END> } 
public void METHOD_1 ( ) throws Exception { TYPE_1 out = new TYPE_1 ( ) ; TYPE_2 . get ( ) . METHOD_2 ( out ) ; <START> System . out . println ( out . toString ( ) ) ; <END> assertThat ( out . toString ( ) , METHOD_3 ( STRING_1 ) ) ; assertThat ( out . toString ( ) , METHOD_3 ( STRING_2 ) ) ; } 
private TYPE_1 < String > METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> return e - > VAR_1 . contains ( e ) ; } else if ( VAR_2 != null ) { return e - > ! VAR_2 . contains ( e ) ; } else { return e - > true ; } } 
public void METHOD_1 ( ) { <START> for ( int VAR_1 = 1 ; VAR_1 < INT_1 ; VAR_1 ++ ) { <END> METHOD_2 ( METHOD_3 ( VAR_1 ) + STRING_1 ) ; } } 
public void METHOD_1 ( TYPE_1 event ) { <START> Map < String , Object > VAR_1 = null ; <END> if ( event . VAR_2 ( ) ) { VAR_1 = METHOD_2 ( ) . METHOD_3 ( STRING_1 , METHOD_4 ( event ) ) ; } else { VAR_1 = METHOD_2 ( ) . METHOD_3 ( STRING_2 , METHOD_5 ( event ) ) ; } event . VAR_3 ( ( Integer ) VAR_1 . get ( STRING_3 ) ) ; } 
public void METHOD_1 ( ) throws Exception { try { client . VAR_1 ( TYPE_1 . VAR_3 , 1 ) ; <START> client . VAR_4 ( ) <END> . METHOD_2 ( STRING_1 + STRING_2 , VAR_5 ) . run ( ) ; } finally { client . VAR_6 ( TYPE_1 . VAR_3 ) ; } } 
private static void METHOD_1 ( TYPE_1 TYPE_2 , TYPE_3 VAR_1 , List < String > VAR_2 ) { TYPE_2 . METHOD_2 ( ) ; <START> for ( String name : VAR_2 ) { TYPE_2 . add ( name ) ; } <END> TYPE_2 . METHOD_3 ( ( null == VAR_1 ) ? VAR_2 . size ( ) - 1 : TYPE_2 . METHOD_4 ( VAR_1 . getName ( ) ) ) ; } 
boolean METHOD_1 ( ) { <START> return ! METHOD_2 ( ) . METHOD_3 ( ) ; <END> } 
public VAR_1 ( ) <START> { } <END> 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> for ( TYPE_2 listener : VAR_2 ) { <END> listener . VAR_3 ( VAR_1 ) ; } } 
public double METHOD_1 ( int VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , VAR_4 , VAR_5 ) ; Path path = VAR_6 ? VAR_2 . METHOD_2 ( to , VAR_1 ) : VAR_2 . METHOD_2 ( VAR_1 , to ) ; <START> if ( path . VAR_7 ( ) ) return path . VAR_8 ( ) ; else return Double . VAR_9 ; <END> } 
public boolean METHOD_1 ( String user , List < ByteBuffer > VAR_1 ) throws TYPE_1 { <START> if ( VAR_1 . size ( ) == 0 ) { <END> return true ; } TYPE_2 VAR_2 = METHOD_2 ( user ) ; for ( ByteBuffer VAR_3 : VAR_1 ) { if ( ! VAR_2 . contains ( TYPE_3 . METHOD_3 ( VAR_3 ) ) ) { return false ; } } return true ; } 
public synchronized long METHOD_1 ( final int offset ) { TYPE_1 VAR_1 = VAR_2 ; if ( VAR_1 != null ) { return <START> VAR_2 . VAR_3 <END> + Math . VAR_4 ( VAR_1 . VAR_5 * offset ) ; } return 0 ; } 
private String METHOD_1 ( TYPE_1 VAR_1 ) { try { <START> TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> if ( VAR_2 == null ) { throw new TYPE_4 ( STRING_1 ) ; } TYPE_5 element = VAR_2 . METHOD_4 ( VAR_1 ) ; return TYPE_6 . METHOD_5 ( element ) ; } catch ( Exception e ) { throw new TYPE_4 ( e ) ; } } 
public boolean METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 : ( parent != null && parent . VAR_1 ( ) ) ; <END> } 
public TYPE_4 ( Map < String , String > VAR_2 , TYPE_1 [ ] VAR_3 , String VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = Optional . VAR_6 ( ( TYPE_2 ) TYPE_3 . METHOD_1 ( ) ) <START> . map ( VAR_7 - > VAR_7 . METHOD_2 ( ) ) ; <END> } 
TYPE_1 ( int VAR_2 ) { <START> this . list = new ArrayList < T > ( VAR_2 ) ; <END> } 
protected boolean METHOD_1 ( ) { if ( ! super . METHOD_1 ( ) ) { return false ; } if ( Guid . VAR_1 ( getParameters ( ) . METHOD_2 ( ) ) ) { METHOD_3 ( TYPE_1 . VAR_3 ) ; return false ; } if ( METHOD_4 ( ) == null ) { METHOD_3 ( TYPE_1 . VAR_4 ) ; return false ; <START> } <END> if ( METHOD_5 ( ) . isEmpty ( ) ) { METHOD_3 ( TYPE_1 . VAR_5 ) ; return false ; } return true ; } 
private void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) throws Exception { <START> System . out . println ( STRING_1 ) ; <END> System . out . println ( STRING_2 ) ; System . out . println ( VAR_2 + STRING_3 + VAR_1 + STRING_4 ) ; System . out . println ( STRING_5 + VAR_3 ) ; System . out . println ( STRING_1 ) ; } 
static TYPE_1 METHOD_1 ( ) { return new TYPE_2 ( ) { @Override protected void METHOD_2 ( ) { final String VAR_1 = VAR_2 ; final TYPE_3 < TYPE_4 < TYPE_6 . TYPE_9 , TYPE_6 > > type = new TYPE_3 < TYPE_4 < TYPE_6 . TYPE_9 , TYPE_6 > > ( ) { } ; METHOD_3 ( type , VAR_1 ) . METHOD_4 ( INT_1 ) <START> . METHOD_5 ( INT_2 , VAR_3 ) <END> . METHOD_6 ( TYPE_10 . VAR_5 ) ; bind ( TYPE_7 . class ) . in ( TYPE_8 . class ) ; } } ; } 
private void METHOD_1 ( ) { TYPE_2 . TYPE_4 session = TYPE_2 . Context . METHOD_2 ( ) . session ( ) ; String VAR_1 = session . get ( TYPE_5 . VAR_3 ) ; <START> TYPE_3 . request ( ) . METHOD_3 ( VAR_1 ) ; <END> } 
private boolean METHOD_1 ( ) { <START> return TYPE_1 . equals ( VAR_1 . VAR_2 , <END> TYPE_3 . TYPE_4 ) && VAR_3 ; } 
private synchronized int METHOD_1 ( long VAR_1 , int VAR_2 ) { int n = new TYPE_1 ( ) . METHOD_2 ( VAR_1 , VAR_2 ) ; if ( n == 0 ) { <START> log . trace ( STRING_1 ) ; <END> } else { log . info ( STRING_2 , n ) ; } return n ; } 
public TYPE_1 value ( ) { <START> return VAR_1 != null ? VAR_1 . f ( ) : null ; <END> } 
<START> @Override public void METHOD_1 ( ) { <END> super . METHOD_1 ( ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; } } 
void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; int VAR_3 = ( VAR_2 == null ) ? 0 : VAR_2 . size ( ) ; <START> if ( VAR_3 < 0 ) <END> return ; TYPE_4 . METHOD_1 ( VAR_1 , VAR_3 , VAR_2 ) ; } 
public Boolean METHOD_1 ( ) { <START> return ( VAR_1 != null && VAR_1 ) ? VAR_1 : null ; <END> } 
private void METHOD_1 ( String VAR_1 ) { TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> boolean VAR_2 = false ; <END> if ( VAR_1 . METHOD_3 ( STRING_2 ) == 0 ) { VAR_2 = true ; } else if ( VAR_1 . METHOD_3 ( STRING_3 ) == 0 ) { VAR_2 = true ; } else if ( VAR_1 . METHOD_3 ( STRING_4 ) == 0 ) { VAR_2 = true ; } if ( ! VAR_2 ) { throw new TYPE_2 ( STRING_5 ) ; } } 
public int METHOD_1 ( TYPE_1 VAR_1 ) { <START> return this . getName ( ) . METHOD_1 ( VAR_1 . getName ( ) ) ; <END> } 
<START> private TYPE_1 < TYPE_2 > METHOD_1 ( boolean VAR_1 ) { <END> return VAR_1 ? new TYPE_3 < > ( ) : new TYPE_4 < > ( ) ; } 
public void run ( ) { <START> if ( VAR_1 . METHOD_1 ( ) == null ) <END> return ; VAR_2 = new TYPE_1 ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) , VAR_1 . METHOD_1 ( ) , VAR_1 . VAR_3 ) ; if ( VAR_2 . METHOD_5 ( ) == TYPE_2 . VAR_5 ) { VAR_1 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ; } } 
public String METHOD_1 ( ) { <START> return METHOD_2 ( VAR_1 , getString ( VAR_1 , VAR_2 ) ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 e ) { <START> if ( logger . VAR_1 ( ) ) { <END> logger . debug ( STRING_1 + e . getMessage ( ) ) ; } if ( e instanceof TYPE_3 ) { return new TYPE_4 ( e . getMessage ( ) , e ) ; } else { return new TYPE_5 ( e . getMessage ( ) , e ) ; } } 
private void METHOD_1 ( String VAR_1 ) { try { new TYPE_1 ( VAR_1 ) ; } catch ( TYPE_2 e ) { <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> } } 
private boolean METHOD_1 ( ANNOTATION_1 TYPE_1 user , ANNOTATION_1 TYPE_2 < ? , ? > run ) throws TYPE_3 { TYPE_4 VAR_1 = null ; try { TYPE_5 VAR_2 = user . VAR_3 ( ) ; VAR_1 = VAR_4 . VAR_5 . VAR_6 . METHOD_2 ( VAR_2 ) ; return TYPE_6 . METHOD_1 ( run ) ; } finally { if ( VAR_1 != null ) { TYPE_7 . METHOD_3 ( VAR_1 ) ; } <START> } <END> } 
public void METHOD_1 ( int index , long VAR_1 , long size ) { try { VAR_2 . get ( index ) . METHOD_1 ( VAR_1 , size ) ; } catch ( Exception e ) { <START> logger . error ( STRING_1 , e ) ; <END> } } 
public void METHOD_1 ( int VAR_1 ) throws InterruptedException { <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> if ( ! VAR_2 . METHOD_2 ( VAR_1 , TimeUnit . VAR_3 ) ) { throw new RuntimeException ( STRING_2 ) ; } } 
<START> protected boolean METHOD_1 ( ) { <END> if ( ! ( METHOD_2 ( METHOD_3 ( ) ) && METHOD_2 ( METHOD_4 ( ) ) ) ) { return false ; } return true ; } 
public List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 ) { <START> return Collections . VAR_2 ( ) ; <END> } return METHOD_2 ( VAR_3 ) ; } 
TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , String name ) { this . VAR_3 = VAR_3 ; this . name = name ; METHOD_1 ( new TYPE_3 ( VAR_2 ) ) ; METHOD_2 ( ) ; METHOD_3 ( false ) ; METHOD_4 ( new TYPE_4 ( ) ) ; METHOD_5 ( ) ; <START> METHOD_6 ( ) ; <END> METHOD_7 ( ) ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> TYPE_2 = VAR_1 ; <END> } 
public String METHOD_1 ( ) { return VAR_1 . get ( VAR_2 ) ; <START> } <END> 
public void METHOD_1 ( TYPE_1 msg ) { switch ( msg . VAR_1 ) { case VAR_2 : <START> synchronized ( this ) { <END> TYPE_2 VAR_3 = ( TYPE_2 ) msg . obj ; List < TYPE_3 > VAR_4 = ( List < TYPE_3 > ) VAR_3 . result ; METHOD_2 ( VAR_4 ) ; } break ; default : METHOD_3 ( STRING_1 + msg . VAR_1 ) ; break ; } } 
private void METHOD_1 ( String state , String VAR_1 , TYPE_1 request ) { if ( request != null ) { request . VAR_2 ( ) . METHOD_2 ( STRING_1 + VAR_1 , state ) ; <START> } <END> } 
<START> private void METHOD_1 ( TYPE_1 resource , TYPE_2 VAR_1 ) { <END> if ( LOG . VAR_2 ( ) ) { TYPE_2 VAR_3 = TYPE_3 . get ( resource ) ; if ( VAR_3 == null ) { TYPE_3 . put ( resource , VAR_1 ) ; } else { LOG . debug ( STRING_1 , VAR_1 , resource ) ; } } } 
<START> private List < TYPE_1 > METHOD_1 ( ) { <END> if ( VAR_1 == null ) { return Collections . VAR_2 ( ) ; } return VAR_1 ; } 
private String METHOD_1 ( String VAR_1 ) { TYPE_1 key = VAR_2 . METHOD_2 ( VAR_1 ) ; if ( key != null ) { TYPE_2 VAR_3 = VAR_4 . METHOD_3 ( key ) ; if ( VAR_3 != null ) <START> return VAR_3 . getValue ( ) ; <END> } return null ; } 
public float METHOD_1 ( ) { VAR_1 = new TYPE_1 ( VAR_2 . VAR_3 , model . getValue ( ) . toString ( ) ) ; <START> return TYPE_2 . max ( VAR_2 . VAR_4 . METHOD_2 ( ) , <END> VAR_2 . VAR_4 . METHOD_3 ( ) + VAR_2 . VAR_4 . METHOD_4 ( ) + VAR_1 . VAR_5 ) ; } 
private void METHOD_1 ( ) { new TYPE_1 ( STRING_1 ) . METHOD_2 ( ) ; <START> new TYPE_2 ( new TYPE_3 ( STRING_2 ) ) ; <END> new TYPE_4 ( STRING_2 ) ; new TYPE_1 ( STRING_3 ) . METHOD_2 ( ) ; } 
public synchronized void METHOD_1 ( String VAR_1 , int VAR_2 ) { boolean VAR_3 = VAR_4 . remove ( VAR_1 , VAR_2 ) ; if ( VAR_5 . METHOD_2 ( ) ) { if ( VAR_3 ) { VAR_5 . debug ( STRING_1 + VAR_1 + STRING_2 + VAR_2 ) ; } else { <START> VAR_5 . info ( STRING_3 + VAR_1 + STRING_2 + VAR_2 + STRING_4 ) ; <END> } } } 
public String METHOD_1 ( ) { String VAR_1 = System . getProperty ( VAR_2 , null ) ; if ( VAR_1 == null ) { TYPE_1 VAR_3 = TYPE_2 . METHOD_2 ( ) ; try { VAR_1 = VAR_3 . getValue ( VAR_2 , new TYPE_3 ( ) ) ; } catch ( TYPE_4 e ) { <START> throw new RuntimeException ( e ) ; <END> } } return VAR_1 ; } 
public void METHOD_1 ( boolean VAR_1 ) { <START> METHOD_2 ( ) . METHOD_1 ( true == VAR_1 ) ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> TYPE_3 . bind ( this . VAR_2 ) ; <END> METHOD_1 ( ) ; } 
public TYPE_1 METHOD_1 ( ) throws IOException , TYPE_2 { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> TYPE_3 VAR_2 = null ; <END> try { VAR_2 = new TYPE_4 ( new File ( VAR_3 ) ) ; VAR_1 . METHOD_3 ( VAR_2 , METHOD_4 ( VAR_4 ) ) ; return VAR_1 ; } finally { METHOD_5 ( VAR_2 ) ; } } 
private List < TYPE_1 > METHOD_1 ( Set < TYPE_1 > VAR_1 , Set < TYPE_1 > VAR_2 ) { List < TYPE_1 > VAR_3 = new ArrayList < TYPE_1 > ( ) ; <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> VAR_3 . addAll ( VAR_1 ) ; return VAR_3 ; } 
public TYPE_3 ( ) { VAR_2 = <START> new TYPE_1 < TYPE_2 , org . VAR_3 . VAR_4 . VAR_5 . TYPE_4 > ( ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { this . VAR_1 = VAR_1 ; <START> METHOD_2 ( ) ; <END> } 
public void METHOD_1 ( int VAR_1 ) { long VAR_2 = TYPE_1 . currentTimeMillis ( ) ; int VAR_3 = METHOD_2 ( size ( ) , VAR_1 ) ; int VAR_4 = 0 ; int VAR_5 = 3 ; int VAR_6 = 0 ; <START> while ( true ) { <END> VAR_4 += METHOD_3 ( VAR_3 , VAR_2 ) ; if ( VAR_4 >= VAR_3 ) { break ; } VAR_6 ++ ; if ( VAR_6 > VAR_5 ) { break ; } } } 
public static TYPE_1 METHOD_1 ( String VAR_1 ) { METHOD_2 ( STRING_1 ) ; <START> METHOD_2 ( STRING_2 ) ; <END> METHOD_2 ( STRING_3 ) ; try { return TYPE_2 . METHOD_3 ( VAR_1 ) ; } catch ( TYPE_3 VAR_2 ) { return null ; } } 
private List < Iterator < Entry < TYPE_1 > > > METHOD_1 ( boolean VAR_1 ) { return VAR_2 . stream ( ) . map ( VAR_3 - > { synchronized ( VAR_3 ) { return VAR_3 . iterator ( VAR_1 ) ; } <START> } ) . collect ( Collectors . VAR_4 ( ) ) ; <END> } 
private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; try { boolean VAR_2 = VAR_1 . METHOD_3 ( VAR_3 + VAR_4 , TimeUnit . VAR_5 ) ; String VAR_6 = VAR_2 ? STRING_1 : STRING_2 ; TYPE_1 . METHOD_4 ( STRING_3 + VAR_6 , false ) ; if ( ! VAR_2 ) { <START> System . VAR_7 ( 0 ) ; <END> } } catch ( InterruptedException e ) { Thread . VAR_8 ( ) . METHOD_5 ( ) ; } finally { VAR_9 . METHOD_6 ( ) ; VAR_10 . METHOD_6 ( ) ; } } 
public Boolean METHOD_1 ( final String VAR_1 , final String key ) { return new TYPE_1 < Boolean > ( VAR_2 , VAR_3 , VAR_4 ) { @Override public Boolean execute ( TYPE_2 connection ) { return connection . VAR_5 ( VAR_1 ) ; } <START> } . run ( 1 , key ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> VAR_2 = new TYPE_2 [ 2 ] ; <END> VAR_3 = ( TYPE_3 ) METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ; VAR_4 = METHOD_2 ( ) . getString ( STRING_2 ) ; } 
public void METHOD_1 ( ) { if ( TYPE_2 . VAR_2 ) Log . d ( TAG , STRING_1 ) ; VAR_3 . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . VAR_5 ) ; <START> if ( VAR_6 != null ) { VAR_6 . METHOD_4 ( ) ; } <END> } 
public Collection < String > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { VAR_1 = true ; List < TYPE_1 > VAR_2 = new TYPE_2 < > ( ) ; VAR_2 . addAll ( VAR_3 . METHOD_1 ( ) ) ; VAR_2 . addAll ( VAR_4 ) ; <START> VAR_5 . METHOD_2 ( ) ; <END> return VAR_2 ; } 
public TYPE_3 . TYPE_4 get ( ) { TYPE_2 user = VAR_1 . get ( ) ; <START> TYPE_3 . TYPE_4 VAR_2 = VAR_3 . METHOD_1 ( ) ; <END> if ( user . VAR_4 ( ) ) { VAR_2 = VAR_3 . METHOD_2 ( ) ; } return VAR_2 ; } 
final TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { return TYPE_4 . builder ( ) . METHOD_2 ( VAR_1 ) <START> . METHOD_3 ( TYPE_4 . VAR_2 ) <END> . build ( ) ; } 
public static String METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 VAR_2 = METHOD_2 ( ) ; TYPE_3 writer = new TYPE_3 ( ) ; TYPE_4 VAR_3 = VAR_2 . METHOD_3 ( writer ) ; VAR_3 . METHOD_4 ( ) ; VAR_3 . METHOD_5 ( VAR_1 ) ; <START> String result = writer . VAR_4 ( ) . toString ( ) ; <END> return result ; } 
private String METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 , server . url ( STRING_2 ) . uri ( ) , null , null , ImmutableList . of ( new TYPE_2 ( STRING_3 , TYPE_5 . VAR_3 ) ) , ImmutableList . of ( ImmutableList . of ( INT_1 ) ) , TYPE_3 . builder ( ) . METHOD_2 ( STRING_4 ) . build ( ) , null , null , <START> null , <END> null ) ; return TYPE_4 . METHOD_3 ( VAR_1 ) ; } 
<START> protected HashMap < String , Object > METHOD_1 ( String url , <END> String VAR_1 , String VAR_2 , boolean VAR_3 ) { return new HashMap < String , Object > ( ) { { put ( STRING_1 , url ) ; put ( VAR_4 , TYPE_2 . TYPE_3 . toString ( ) ) ; put ( STRING_2 , true ) ; put ( STRING_3 , VAR_1 ) ; put ( STRING_4 , VAR_2 ) ; put ( VAR_5 , VAR_3 ) ; } } ; } 
public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 ) ; TYPE_3 . METHOD_3 ( VAR_1 ) ; <START> TYPE_4 . getInstance ( ) . METHOD_4 ( VAR_1 ) ; <END> } 
protected static int METHOD_1 ( String string , int VAR_1 , String text ) { if ( string == null || string . length ( ) == 0 ) { return 0 ; } try { string = ( string + STRING_1 ) . substring ( 0 , INT_1 ) ; return Integer . parseInt ( string ) * VAR_1 ; } catch ( TYPE_1 | TYPE_2 e ) { <START> throw ( TYPE_3 ) new TYPE_3 ( <END> STRING_2 , text , 0 ) . METHOD_2 ( e ) ; } } 
public TYPE_1 [ ] METHOD_1 ( ) { TYPE_1 [ ] result = new TYPE_1 [ VAR_1 + ( VAR_2 == null ? 1 : 2 ) ] ; int VAR_3 = 0 ; <START> for ( TYPE_2 VAR_4 : METHOD_2 ( ) ) <END> if ( VAR_4 instanceof TYPE_1 ) result [ VAR_3 ++ ] = ( TYPE_1 ) VAR_4 ; else throw new TYPE_3 ( STRING_1 + STRING_2 + STRING_3 ) ; if ( VAR_2 != null ) result [ VAR_1 + 1 ] = VAR_2 ; return result ; } 
private String METHOD_1 ( Object VAR_1 , TYPE_1 e ) { String VAR_2 = VAR_3 . METHOD_2 ( e . VAR_4 ( ) ) ; if ( VAR_1 instanceof TYPE_2 ) { return TYPE_3 . getInstance ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; } else if ( VAR_1 instanceof TYPE_4 ) { return TYPE_3 . getInstance ( ) . METHOD_3 ( ) . METHOD_5 ( VAR_2 ) ; } <START> throw new IllegalArgumentException ( STRING_1 + VAR_1 . getClass ( ) . getName ( ) ) ; <END> } 
public final void METHOD_1 ( final Date VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> } 
public static void METHOD_1 ( final File d , boolean VAR_1 ) throws IOException { <START> if ( VAR_1 && d . exists ( ) && d . VAR_2 ( ) ) <END> return ; if ( ! d . VAR_3 ( ) ) throw new IOException ( TYPE_1 . format ( TYPE_2 . get ( ) . VAR_4 , d . VAR_5 ( ) ) ) ; } 
protected void METHOD_1 ( ) { METHOD_2 ( new TYPE_1 ( new <START> TYPE_2 ( null , null ) ) ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( this . METHOD_2 ( ) ) <END> { set ( VAR_2 , VAR_1 ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 context ) { METHOD_2 ( node . VAR_1 ( ) == VAR_2 , STRING_1 ) ; if ( node . VAR_3 ( ) . isPresent ( ) ) { return METHOD_3 ( node , context ) ; } else { return METHOD_4 ( node , context ) ; <START> } <END> } 
public void METHOD_1 ( TYPE_1 < TYPE_2 < ? extends TYPE_3 , ? extends TYPE_4 > > VAR_1 ) throws TYPE_5 { <START> for ( Object VAR_2 : VAR_1 ) { <END> TYPE_2 event = ( TYPE_2 ) VAR_2 ; Assert . assertEquals ( TYPE_6 . VAR_4 , event . VAR_5 ( ) ) ; this . VAR_6 . METHOD_2 ( ) ; event . getKey ( ) ; event . getValue ( ) ; event . VAR_7 ( ) ; } } 
private static TYPE_1 METHOD_1 ( Context context , long VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_3 ) ; VAR_2 . METHOD_2 ( VAR_4 , VAR_1 ) ; <START> long VAR_5 = VAR_1 ; <END> return TYPE_1 . METHOD_3 ( context , ( int ) VAR_5 , VAR_2 , TYPE_1 . VAR_6 ) ; } 
<START> public boolean METHOD_1 ( ) throws RuntimeException <END> { File [ ] VAR_1 = VAR_2 . METHOD_2 ( TYPE_1 . VAR_4 ) ; if ( VAR_1 == null ) { throw new RuntimeException ( STRING_1 ) ; } return VAR_1 . length > 0 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_1 ( VAR_1 ) ; <END> } 
<START> public TYPE_2 ( TYPE_1 VAR_2 , String value ) { <END> super ( VAR_2 , null ) ; this . value = value ; } 
private void METHOD_1 ( final TYPE_1 VAR_1 , final Boolean VAR_2 ) { <START> if ( VAR_2 == null ) { <END> return ; } VAR_1 . add ( TYPE_2 . METHOD_2 ( STRING_1 , VAR_2 ) ) ; } 
public List < String > METHOD_1 ( final String VAR_1 ) throws TYPE_1 { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_1 ( VAR_1 ) ; if ( null != VAR_2 && ! VAR_2 . isEmpty ( ) ) { List < String > VAR_4 = new ArrayList < > ( ) ; for ( TYPE_2 VAR_5 : VAR_2 ) { VAR_4 . add ( VAR_5 . METHOD_2 ( ) ) ; } return VAR_4 ; <START> } else { <END> return null ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 event : VAR_1 ) { <START> if ( TYPE_3 . equals ( event . getName ( ) ) ) { <END> TYPE_4 context = ( TYPE_4 ) event . VAR_2 ( ) ; TYPE_5 VAR_3 = context . VAR_4 ( ) ; if ( TYPE_6 . equals ( VAR_3 . getType ( ) ) ) { METHOD_2 ( context . VAR_5 ( ) , VAR_3 . getId ( ) ) ; } } } } 
public Set < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = new TYPE_2 < TYPE_1 > ( ) ; <END> } return VAR_1 ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_3 value = VAR_3 . getValue ( VAR_2 ) ; if ( value == null ) { value = VAR_4 . METHOD_3 ( VAR_1 ) ; VAR_3 = VAR_3 . METHOD_4 ( value ) ; METHOD_5 ( VAR_1 , value ) ; VAR_3 = VAR_3 . put ( VAR_2 , value ) ; } else { VAR_3 = VAR_3 . METHOD_4 ( value ) ; <START> VAR_3 = VAR_3 . put ( VAR_2 , value ) ; <END> } } 
<START> public TYPE_4 ( String <END> VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_3 . METHOD_1 ( ) ? VAR_3 . METHOD_2 ( ) : null ; this . VAR_7 = VAR_3 . METHOD_3 ( ) ? VAR_3 . METHOD_4 ( ) : null ; } 
public boolean METHOD_1 ( Guid VAR_1 ) { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> return VAR_2 . size ( ) > 0 ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> <END> try ( TYPE_3 VAR_2 = new TYPE_3 ( VAR_3 . METHOD_2 ( ) ) ) { if ( VAR_4 . containsKey ( VAR_1 ) ) { TYPE_4 VAR_5 = VAR_4 . get ( VAR_1 ) ; return VAR_4 . get ( VAR_1 ) . METHOD_3 ( ) ; } else { throw new TYPE_2 ( String . format ( STRING_1 , VAR_1 . toString ( ) ) ) ; } } } 
public static boolean METHOD_1 ( final String version ) { boolean result = true ; if ( version == null || version . trim ( ) . length ( ) < 1 ) { <START> result = false ; <END> } try { TYPE_1 VAR_1 = new TYPE_2 ( version ) . METHOD_2 ( ) ; } catch ( final TYPE_3 e ) { result = false ; } catch ( final TYPE_4 e ) { result = false ; } return result ; } 
public void METHOD_1 ( TYPE_1 connection , int VAR_1 , TYPE_2 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) throws TYPE_4 { switch ( VAR_1 ) { case TYPE_5 . VAR_6 : { METHOD_2 ( VAR_2 , VAR_3 , VAR_4 ) ; } <START> case TYPE_5 . VAR_7 : { <END> METHOD_3 ( VAR_2 , VAR_3 , VAR_4 ) ; } default : throw new TYPE_4 ( STRING_1 ) ; } } 
public Builder METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> this . VAR_1 . addAll ( Arrays . asList ( VAR_1 ) ) ; <END> return this ; } 
public void METHOD_1 ( ) throws TYPE_1 { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( STRING_1 , 100 ) ; params . put ( STRING_2 , STRING_3 ) ; params . put ( STRING_4 , STRING_5 ) ; <START> TYPE_2 VAR_1 = TYPE_2 . create ( params ) ; <END> assertNotNull ( VAR_1 ) ; METHOD_2 ( TYPE_3 . TYPE_4 . VAR_4 , STRING_6 , params ) ; } 
<START> private boolean METHOD_1 ( TYPE_1 result ) { <END> TYPE_2 m = result . VAR_1 ( ) ; return m . VAR_2 ( ) || m . VAR_3 ( ) ; } 
private static void METHOD_1 ( String value ) throws TYPE_1 { <START> final TYPE_2 VAR_1 = TYPE_2 . getInstance ( ) ; <END> if ( ! VAR_1 . METHOD_2 ( value ) ) { throw new TYPE_1 ( TYPE_3 . VAR_3 , STRING_1 ) ; } } 
private void addAll ( Object VAR_1 ) throws TYPE_1 { if ( VAR_1 . getClass ( ) . METHOD_1 ( ) ) { int length = TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> this . VAR_2 . METHOD_3 ( length ) ; <END> for ( int i = 0 ; i < length ; i += 1 ) { this . put ( TYPE_3 . METHOD_4 ( TYPE_2 . get ( VAR_1 , i ) ) ) ; } } else { throw new TYPE_1 ( STRING_1 ) ; } } 
<START> public static <END> synchronized TYPE_1 METHOD_1 ( Context context ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_2 ( context ) ; } return VAR_1 ; } 
protected void METHOD_1 ( int VAR_1 , int VAR_2 ) { try { if ( VAR_3 . METHOD_2 ( ) ) { <START> double VAR_4 = VAR_1 + VAR_2 ; <END> if ( VAR_4 > 0 ) { double d = VAR_1 / VAR_4 ; METHOD_3 ( ) . METHOD_4 ( d ) ; METHOD_3 ( ) . METHOD_5 ( d ) ; } } } finally { VAR_3 . METHOD_6 ( ) ; } } 
public void METHOD_1 ( TYPE_1 element ) { <START> if ( element instanceof TYPE_2 && element != METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) { <END> ( ( TYPE_2 ) element ) . METHOD_5 ( STRING_1 ) ; } } 
public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( new TYPE_2 ( ) ) ; <END> } 
<START> public < T > TYPE_1 < T > METHOD_1 ( Class < T > type , ANNOTATION_1 Class < ? > VAR_1 , ANNOTATION_2 String VAR_2 ) throws TYPE_2 { <END> TYPE_1 m = VAR_3 . get ( type ) ; if ( m == null && type . VAR_4 ( TYPE_3 . class ) != null ) { m = new TYPE_1 < T > ( this , type , VAR_1 , VAR_2 ) ; } return m ; } 
<START> public void METHOD_1 ( ) { <END> VAR_1 = "" ; final TYPE_1 result = TYPE_2 . METHOD_2 ( TYPE_3 . class ) ; assertEquals ( 0 , result . VAR_2 ( ) ) ; assertEquals ( STRING_1 + STRING_2 , VAR_1 ) ; } 
public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( ) , SWT . NONE ) ; <END> event = new TYPE_3 ( VAR_1 , true ) ; VAR_2 = new TYPE_4 ( ) ; } 
public void METHOD_1 ( ) { String user = System . getProperty ( STRING_1 ) ; String VAR_1 = TYPE_1 . METHOD_2 ( STRING_2 ) ; assertTrue ( VAR_1 . startsWith ( STRING_3 ) ) ; String VAR_2 = TYPE_1 . METHOD_2 ( STRING_4 ) ; <START> if ( ! STRING_5 . equals ( user ) ) <END> assertTrue ( VAR_2 . startsWith ( STRING_6 + user ) ) ; } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> String VAR_2 = VAR_3 . METHOD_2 ( VAR_4 ) ; String VAR_5 = VAR_3 . METHOD_3 ( VAR_4 ) . METHOD_4 ( ) ; TYPE_3 VAR_6 = VAR_1 . getProperty ( String . format ( STRING_1 , VAR_2 , VAR_5 ) ) ; if ( VAR_6 . METHOD_5 ( ) ) { String VAR_7 = VAR_6 . getValue ( String . VAR_8 ) ; if ( StringUtils . VAR_9 ( VAR_7 ) && ! METHOD_6 ( VAR_7 ) ) { throw new TYPE_2 ( ) ; } } } 
protected void METHOD_1 ( ) { METHOD_2 ( null ) ; <START> METHOD_3 ( null ) ; <END> } 
public TYPE_2 ( T parameters , TYPE_1 VAR_2 ) { super ( parameters , VAR_2 ) ; <START> METHOD_1 ( parameters . VAR_3 ( ) ) ; <END> } 
public String METHOD_1 ( ) throws IOException { <START> return VAR_1 . METHOD_2 ( ) ; <END> } 
<START> public TYPE_1 ( int size , float VAR_2 ) <END> { this . size = size ; this . VAR_2 = VAR_2 ; } 
<START> public TYPE_1 ( String VAR_2 , String VAR_3 , int VAR_4 , boolean VAR_5 ) { <END> super ( VAR_2 , String . format ( STRING_1 , VAR_3 ) , STRING_2 + VAR_3 ) ; this . VAR_6 = VAR_4 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_5 ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . VAR_3 ) ) { return ; } final String VAR_4 = VAR_1 . METHOD_4 ( ) + TYPE_2 . VAR_5 ; long count = VAR_1 . METHOD_2 ( ) . keySet ( ) . stream ( ) . filter ( key - > key . startsWith ( VAR_4 ) ) . count ( ) ; <START> VAR_1 . METHOD_5 ( count > 0 ? VAR_4 + STRING_1 + count : VAR_4 , TYPE_2 . VAR_3 ) ; <END> } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; METHOD_1 ( parameters . VAR_2 ( ) ) ; <START> METHOD_2 ( parameters . VAR_3 ( ) ) ; <END> } 
public String METHOD_1 ( TYPE_1 VAR_1 ) { logger . trace ( STRING_1 ) ; logger . trace ( STRING_2 ) ; TYPE_2 . Response response = VAR_1 . METHOD_2 ( new TYPE_2 ( ) ) ; if ( ( response == null ) || ( ! response . VAR_2 ( ) ) ) { logger . trace ( STRING_3 ) ; return null ; <START> } else { <END> logger . trace ( STRING_4 , response . VAR_3 ( ) ) ; return response . VAR_3 ( ) ; } } 
private static int METHOD_1 ( int VAR_1 ) { int VAR_2 = VAR_1 / VAR_3 ; if ( VAR_2 == 0 ) { VAR_2 = 1 ; } <START> return VAR_2 ; <END> } 
<START> public synchronized Long size ( ) <END> { final File file = path . VAR_1 ( ) ; Long size = ( file . exists ( ) && ! file . VAR_2 ( ) ) ? file . length ( ) : INT_1 ; if ( VAR_3 < INT_1 || VAR_4 > VAR_5 ) { Long VAR_3 = INT_1 ; VAR_5 = VAR_4 ; for ( TYPE_1 child : VAR_6 ) { VAR_3 += child . size ( ) ; } this . VAR_3 = VAR_3 ; } size += VAR_3 ; return size ; } 
public TYPE_2 ( TYPE_1 VAR_2 , boolean vm ) { <START> if ( VAR_2 == null ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } this . VAR_2 = VAR_2 ; VAR_3 = vm ; } 
private static boolean METHOD_1 ( Pair < TYPE_1 , Integer > VAR_1 , int context ) { <START> return ( VAR_1 . VAR_2 & context ) == context ; <END> } 
<START> private void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 == null ) { return ; } if ( ! VAR_2 . contains ( VAR_1 ) ) { return ; } VAR_2 . remove ( VAR_1 ) ; if ( page != null ) { page . VAR_3 ( this , VAR_1 , TYPE_2 . VAR_5 ) ; } } 
public void METHOD_1 ( ) throws Exception { System . out . println ( VAR_1 + STRING_1 ) ; TYPE_1 VAR_2 = METHOD_2 ( ) ; VAR_3 . METHOD_3 ( sess , VAR_2 , VAR_4 ) ; VAR_3 . METHOD_3 ( sess , VAR_4 , VAR_5 ) ; VAR_3 . METHOD_3 ( sess , VAR_5 , VAR_6 ) ; <START> VAR_3 . METHOD_4 ( sess , VAR_6 , VAR_4 , false ) ; <END> } 
private TYPE_1 METHOD_1 ( ) { final TYPE_1 listener = new TYPE_1 ( ) { @Override public void <START> METHOD_2 ( TYPE_2 e ) { <END> METHOD_3 ( ) ; } @Override public void METHOD_4 ( TYPE_2 e ) { } } ; return listener ; } 
public void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { String VAR_4 = VAR_5 . METHOD_2 ( VAR_1 ) ; String VAR_6 = VAR_4 + VAR_2 ; String VAR_7 = VAR_3 ; <START> if ( ! VAR_7 . startsWith ( STRING_1 ) ) { <END> VAR_7 = VAR_4 + VAR_7 ; } VAR_8 . get ( VAR_6 ) ; String VAR_9 = VAR_8 . METHOD_3 ( ) ; TYPE_1 . assertEquals ( VAR_9 , VAR_7 ) ; } 
public void METHOD_1 ( ) { try { close ( false ) ; } catch ( final RuntimeException e ) { <START> log . warn ( String . format ( STRING_1 , id ) , e ) ; <END> } log . info ( STRING_2 ) ; } 
public boolean METHOD_1 ( int VAR_1 , float VAR_2 ) { <START> TYPE_3 . TYPE_4 . client . TYPE_2 VAR_3 = this . client . VAR_4 . VAR_5 . METHOD_2 ( ) ; <END> if ( VAR_3 != null ) { VAR_3 . METHOD_3 ( VAR_2 , this . client . VAR_4 , this . client ) ; return true ; } return VAR_6 . METHOD_3 ( VAR_1 , VAR_2 ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 ctx ) { TYPE_3 a = ( TYPE_3 ) this . type ; <START> if ( <END> METHOD_2 ( ) && a . VAR_1 ( ) instanceof TYPE_4 && ( ( TYPE_4 ) a . VAR_1 ( ) ) . getName ( ) . equals ( this . VAR_2 ) ) { return new TYPE_5 ( new TYPE_6 ( VAR_3 ) , VAR_4 ) ; } return ( ( TYPE_3 ) type ) . METHOD_3 ( ) . METHOD_4 ( ctx ) ; } 
public TYPE_1 METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . isEmpty ( ) ) { METHOD_3 ( false ) ; return null ; } else { <START> METHOD_3 ( true ) ; <END> return VAR_1 . get ( 0 ) ; } } 
public TYPE_4 ( ANNOTATION_1 final Long VAR_2 , final TYPE_1 child ) { super ( child ) ; this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; TYPE_3 . METHOD_2 ( VAR_2 >= INT_1 , STRING_2 ) ; VAR_3 = this . VAR_2 ; <START> VAR_4 = false ; <END> } 
public void add ( TYPE_1 VAR_1 , TYPE_2 v ) { if ( key == null ) { key = VAR_1 ; VAR_2 . add ( VAR_1 . METHOD_1 ( ) ) ; values . add ( v ) ; size ++ ; } else if ( key . VAR_3 ( VAR_1 . METHOD_2 ( ) ) == 0 <START> && key . VAR_4 ( VAR_1 . METHOD_3 ( ) ) == 0 ) { <END> VAR_2 . add ( VAR_1 . METHOD_1 ( ) ) ; values . add ( v ) ; } else { } } 
public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( ) ; <START> String version = METHOD_3 ( ) ; <END> if ( version == null || ! version . equals ( TYPE_3 . VAR_3 ) ) { VAR_4 . VAR_5 . VAR_6 . METHOD_4 ( TYPE_2 . VAR_8 , version , TYPE_3 . VAR_3 , VAR_9 ) ; } } return VAR_1 ; } 
private boolean METHOD_1 ( String value ) { <START> return value . length ( ) == 4 || Integer . parseInt ( value ) < INT_1 ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = ( TYPE_2 ) METHOD_2 ( ) . get ( STRING_1 ) ; <END> return new TYPE_1 ( VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; try { TYPE_2 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 != null ) { TYPE_3 VAR_3 = new TYPE_3 ( VAR_2 ) ; VAR_3 . METHOD_3 ( ) ; VAR_1 . add ( VAR_2 ) ; <START> } <END> } catch ( Exception ex ) { TYPE_4 . log ( TYPE_5 . class , TYPE_6 . VAR_5 , STRING_1 , ex ) ; } } 
<START> public List METHOD_1 ( ) <END> { return VAR_1 ; } 
private static long METHOD_1 ( long [ ] VAR_1 ) { if ( VAR_1 == null ) { return 0 ; } int VAR_2 = 0 ; <START> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <END> VAR_2 |= VAR_1 [ i ] ; } return VAR_2 ; } 
private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , <START> TYPE_3 VAR_3 ) { <END> if ( VAR_1 instanceof TYPE_4 ) { TYPE_4 VAR_4 = ( TYPE_4 ) VAR_1 ; if ( VAR_4 . METHOD_2 ( ) . equals ( VAR_3 . METHOD_2 ( ) ) && VAR_4 . METHOD_3 ( ) . equals ( VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) ) { return true ; } } return false ; } 
public static void log ( Throwable e ) { <START> log ( new Status ( TYPE_1 . VAR_2 , VAR_3 , TYPE_1 . VAR_4 , e . VAR_5 ( ) , e ) ) ; <END> } 
private boolean METHOD_1 ( TYPE_1 channel ) { <START> boolean VAR_1 = TYPE_2 . METHOD_2 ( channel . VAR_2 ( ) , false ) ; <END> boolean VAR_3 = TYPE_2 . METHOD_2 ( channel . VAR_4 ( ) , false ) ; return ! ( VAR_1 || VAR_3 ) ; } 
default TYPE_1 VAR_2 ( ) { <START> throw new TYPE_2 ( ) ; <END> } 
public TYPE_1 METHOD_1 ( Context context , String token ) throws TYPE_2 { TYPE_3 VAR_1 = METHOD_2 ( context ) ; TYPE_4 VAR_2 = METHOD_3 ( VAR_1 , TYPE_1 . class ) ; TYPE_5 < TYPE_1 > VAR_3 = VAR_2 . from ( TYPE_1 . class ) ; VAR_2 . METHOD_4 ( VAR_3 ) ; VAR_2 . METHOD_5 ( VAR_1 . METHOD_6 ( VAR_3 . get ( TYPE_6 . token ) , token ) ) ; <START> return METHOD_7 ( context , VAR_2 , true , TYPE_1 . class , - 1 , - 1 ) ; <END> } 
public static void METHOD_1 ( TYPE_1 project , boolean VAR_1 ) { if ( VAR_1 != METHOD_2 ( project ) ) { METHOD_3 ( project ) . METHOD_4 ( VAR_2 , VAR_1 ) ; <START> TYPE_2 . METHOD_5 ( project , true ) ; <END> } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 element ) { T VAR_2 = METHOD_2 ( element ) ; if ( VAR_2 != null ) { boolean VAR_3 = METHOD_3 ( VAR_2 , VAR_1 ) ; if ( ! VAR_3 ) { VAR_4 . put ( VAR_2 , true ) ; <START> } else if ( ! VAR_4 . containsKey ( VAR_2 ) ) { <END> VAR_4 . put ( VAR_2 , false ) ; } } } 
public String toString ( ) { return METHOD_1 ( this ) . METHOD_2 ( ) <START> . add ( STRING_1 , this . VAR_1 ) <END> . add ( STRING_2 , VAR_2 ) . add ( STRING_3 , VAR_3 ) . toString ( ) ; } 
public void METHOD_1 ( ) throws Exception { TYPE_1 msg = METHOD_2 ( METHOD_3 ( STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 + STRING_7 + STRING_8 ) ) ; METHOD_4 ( msg . VAR_1 ( ) , STRING_9 ) ; <START> METHOD_4 ( msg . VAR_2 ( TYPE_3 . VAR_4 ) , STRING_10 ) ; <END> METHOD_5 ( TYPE_2 . METHOD_6 ( msg . VAR_5 ( ) ) ) ; } 
<START> public TYPE_1 METHOD_1 ( ) { <END> return new TYPE_1 ( VAR_1 , config . VAR_2 ( ) + STRING_1 ) ; } 
<START> private void METHOD_1 ( TYPE_1 result ) { <END> assertNotNull ( result ) ; assertTrue ( result . VAR_1 ( ) ) ; } 
public static TYPE_1 METHOD_1 ( TYPE_2 stream , TYPE_3 VAR_1 ) throws IOException { TYPE_4 VAR_2 = stream . VAR_3 ( ) ; if ( ! VAR_2 . equals ( VAR_4 ) ) { throw new IllegalStateException ( STRING_1 + VAR_4 ) ; } TYPE_5 VAR_5 = TYPE_5 . values ( ) [ stream . VAR_3 ( ) ] ; <START> boolean VAR_6 = stream . VAR_7 ( ) == 1 ; <END> return new TYPE_1 ( VAR_5 , VAR_6 , VAR_1 ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( ! METHOD_2 ( VAR_1 ) ) return ; for ( TYPE_3 config : VAR_3 ) { <START> List < TYPE_1 > VAR_4 = TYPE_4 . filter ( config . VAR_5 ( VAR_1 . METHOD_3 ( ) , null ) , TYPE_1 . class ) ; <END> for ( TYPE_1 project : VAR_4 ) TYPE_5 . add ( VAR_1 , project , config , VAR_2 ) ; } } 
public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; TYPE_2 VAR_2 = <START> METHOD_2 ( ) . get ( ) ; <END> TYPE_3 VAR_3 = new TYPE_4 ( VAR_2 ) . METHOD_3 ( ) ; TYPE_5 VAR_4 = TYPE_6 . METHOD_4 ( VAR_3 , false ) ; if ( VAR_4 instanceof TYPE_1 ) { VAR_1 = ( TYPE_1 ) VAR_4 ; } return VAR_1 ; } 
public TYPE_2 ( TYPE_1 VAR_2 ) { this ( VAR_2 . METHOD_1 ( ) ) ; <START> VAR_3 = new HashSet < > ( ) ; <END> } 
public synchronized void METHOD_1 ( ) { for ( Entry < String , TYPE_1 > entry : VAR_1 . entrySet ( ) ) { entry . getValue ( ) . METHOD_1 ( ) ; } <START> super . METHOD_1 ( ) ; <END> } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_2 ( ) ; if ( VAR_2 . getType ( ) == TYPE_3 . VAR_4 && METHOD_3 ( VAR_2 ) && METHOD_4 ( VAR_2 ) <START> && ! TYPE_2 . METHOD_5 ( VAR_2 , STRING_1 ) ) { <END> METHOD_6 ( VAR_1 ) ; } } 
public static boolean METHOD_1 ( int [ ] version ) { <START> int VAR_1 = METHOD_2 ( version , VAR_2 ) ; <END> if ( VAR_1 < 0 ) return true ; else if ( VAR_1 == 0 ) return false ; if ( METHOD_2 ( version , VAR_3 ) <= 0 ) return true ; return false ; } 
protected void METHOD_1 ( ) { this . VAR_1 = new TYPE_1 ( METHOD_2 ( ) , this ) ; <START> METHOD_3 ( ) . METHOD_4 ( this . VAR_1 ) ; <END> } 
public static TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 VAR_1 ) { return new TYPE_1 < TYPE_2 > ( ) { @Override public TYPE_2 apply ( TYPE_4 VAR_2 ) { try { TYPE_5 element = METHOD_2 ( VAR_1 , VAR_2 ) ; return element . VAR_3 ( ) ? METHOD_3 ( VAR_1 , element , VAR_2 ) : null ; <START> } catch ( TYPE_6 e ) { <END> return null ; } catch ( TYPE_7 e ) { return null ; } } @Override public String toString ( ) { return STRING_1 + VAR_1 ; } } ; } 
public TYPE_1 < ? > METHOD_1 ( TYPE_2 context ) { TYPE_3 VAR_1 = new TYPE_3 ( true ) ; VAR_1 . METHOD_2 ( context . VAR_2 ( ) ) ; <START> if ( VAR_3 != null ) { <END> VAR_1 . METHOD_3 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; } return new TYPE_4 ( context , VAR_1 ) ; } 
public String [ ] METHOD_1 ( ) { <START> return this . VAR_1 . METHOD_2 ( new String [ ] { } ) ; <END> } 
public static Long METHOD_1 ( String VAR_1 ) { try { TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , TYPE_3 . VAR_5 ) ; Date VAR_6 = VAR_2 . parse ( VAR_1 ) ; <START> return VAR_6 . METHOD_2 ( ) ; <END> } catch ( TYPE_2 e ) { logger . warn ( STRING_1 + VAR_1 + STRING_2 ) ; return null ; } } 
<START> public TYPE_2 ( TYPE_1 context ) { <END> this . context = context ; } 
public void METHOD_1 ( final TYPE_1 VAR_1 ) { final Object target = METHOD_2 ( VAR_1 ) ; <START> if ( this . VAR_2 != null && ! TYPE_2 . METHOD_3 ( target ) ) { <END> VAR_2 . METHOD_4 ( VAR_1 ) ; } } 
<START> public void METHOD_1 ( Class < ? extends TYPE_1 > filter , <END> Class < ? extends TYPE_1 > VAR_1 ) { Integer position = METHOD_2 ( VAR_1 ) ; if ( position == null ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; } put ( filter , position + 1 ) ; } 
public boolean METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return false ; } boolean result = false ; for ( TYPE_1 VAR_2 : VAR_3 ) { <START> result |= VAR_2 . matcher ( VAR_1 ) . METHOD_1 ( ) ; <END> } return result ; } 
public TYPE_1 < String , TYPE_2 > build ( ) { <START> return new TYPE_3 < TYPE_2 > ( VAR_1 , new TYPE_4 < String , TYPE_2 > ( map ) ) ; <END> } 
<START> static boolean METHOD_1 ( TYPE_1 VAR_1 ) { return ( VAR_1 instanceof TYPE_2 ) ; } <END> 
public static TYPE_1 < byte [ ] > METHOD_1 ( String url , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = TYPE_4 . create ( TYPE_3 . class , VAR_1 ) ; try { return VAR_2 . METHOD_2 ( METHOD_3 ( url ) , METHOD_4 ( url ) ) . METHOD_5 ( response - > TYPE_5 . METHOD_6 ( response . getValue ( ) ) ) ; } catch ( TYPE_6 ex ) { <START> return TYPE_1 . empty ( ) ; <END> } } 
public long METHOD_1 ( ) { if ( VAR_1 . size ( ) == 0 ) { return Long . VAR_2 ; } <START> TYPE_1 VAR_3 = VAR_1 . get ( 0 ) ; <END> return VAR_3 . METHOD_2 ( ) ; } 
private static String METHOD_1 ( List < String > VAR_1 ) <START> { <END> int VAR_2 = VAR_1 . METHOD_2 ( STRING_1 ) + 1 ; return VAR_1 . get ( VAR_2 ) ; } 
private void METHOD_1 ( ) { <START> METHOD_1 ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> } 
public TYPE_1 METHOD_1 ( TYPE_2 element ) { <START> TYPE_2 VAR_1 = element ; <END> if ( VAR_1 . METHOD_2 ( VAR_2 ) ) { if ( element . VAR_3 ( VAR_2 ) ) { return TYPE_1 . VAR_4 ; } } if ( element instanceof TYPE_3 ) { VAR_5 ++ ; } return TYPE_1 . VAR_6 ; } 
protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ! METHOD_2 ( VAR_1 , false ) . isEmpty ( ) ; <END> } 
protected TYPE_1 METHOD_1 ( String VAR_1 ) { if ( TYPE_2 . getInstance ( ) . METHOD_2 ( VAR_1 ) ) { return TYPE_3 . VAR_3 ; <START> } else { <END> return TYPE_3 . VAR_4 ; } } 
public void METHOD_1 ( final Map < TYPE_1 , TYPE_2 > VAR_1 , TYPE_3 VAR_2 ) { METHOD_2 ( ) ; try { METHOD_3 ( ) ; METHOD_4 ( VAR_1 ) ; log . debug ( STRING_1 , VAR_1 ) ; VAR_1 . forEach ( this : : METHOD_5 ) ; VAR_3 . METHOD_6 ( new HashMap < > ( VAR_1 ) , VAR_2 ) ; } catch ( TYPE_4 e ) { <START> log . error ( STRING_2 ) ; <END> VAR_2 . METHOD_7 ( VAR_1 , e ) ; } finally { METHOD_8 ( ) ; } } 
public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) throws Exception { if ( trace ) { log . VAR_2 ( STRING_1 , METHOD_2 ( VAR_1 ) ) ; } else if ( debug ) { <START> log . VAR_3 ( STRING_2 , VAR_1 . length ) ; <END> } if ( VAR_4 != null ) { METHOD_3 ( VAR_1 ) ; } else { METHOD_4 ( VAR_1 ) ; } } 
protected TYPE_4 ( TYPE_1 VAR_2 , String VAR_3 , TYPE_2 VAR_4 , TYPE_2 VAR_5 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 ; <END> this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; VAR_6 = TYPE_3 . METHOD_1 ( VAR_2 ) ; } 
public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) . remove ( VAR_2 ) ; <END> VAR_3 . METHOD_1 ( ) ; VAR_4 . METHOD_1 ( ) ; VAR_5 . METHOD_1 ( ) ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; VAR_2 . METHOD_3 ( ) . METHOD_1 ( ) ; ( ( TYPE_1 ) VAR_2 . METHOD_5 ( ) ) . METHOD_1 ( ) ; } 
public boolean METHOD_1 ( ) { if ( metadata . getType ( ) . METHOD_2 ( ) == TYPE_1 . VAR_2 || metadata . getType ( ) . METHOD_2 ( ) == TYPE_1 . VAR_3 || metadata . getType ( ) . METHOD_2 ( ) == TYPE_1 . VAR_4 ) { return true ; } <START> return false ; <END> } 
protected Builder ( ) { super ( TYPE_1 . class ) ; id ( STRING_1 ) . name ( STRING_2 ) . METHOD_1 ( STRING_3 ) . METHOD_2 ( STRING_4 ) . METHOD_3 ( TYPE_2 . create ( STRING_5 ) ) . version ( STRING_6 ) . METHOD_4 ( STRING_7 ) . METHOD_5 ( TYPE_3 . METHOD_5 ( ) ) . METHOD_6 ( TYPE_7 < Class < ? extends TYPE_4 > > of ( <START> TYPE_5 . class , <END> TYPE_6 . class ) ) ; } 
TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( new TYPE_2 ( System . err , <START> TYPE_3 . VAR_2 ) ) ; <END> } 
public void METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { File file = ( File ) VAR_2 . METHOD_3 ( i ) ; if ( file != null ) { <START> if ( file . VAR_3 ( ) ) { <END> } else { METHOD_4 ( ) . METHOD_5 ( i , true ) ; VAR_4 . METHOD_6 ( file ) ; } } } } 
<START> public TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = null ; try { VAR_1 = VAR_2 == null ? null : new TYPE_1 ( VAR_2 ) ; } catch ( TYPE_2 VAR_3 ) { METHOD_2 ( STRING_1 , this . name , VAR_2 ) ; } for ( TYPE_3 p : METHOD_3 ( ) ) { TYPE_1 v = p . VAR_4 ( ) ; if ( v == null ) { continue ; } if ( VAR_1 == null || v . VAR_5 ( VAR_1 ) ) { VAR_1 = v ; } } return VAR_1 ; } 
public void METHOD_1 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> } 
public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; METHOD_2 ( VAR_2 ) ; METHOD_2 ( VAR_3 ) ; METHOD_2 ( VAR_4 ) ; <START> <END> } 
public TYPE_3 ( TYPE_1 VAR_2 ) { <START> this . VAR_3 = ( TYPE_2 ) VAR_2 . METHOD_1 ( ) ; this . VAR_4 = VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; <END> } 
public static long METHOD_1 ( byte [ ] VAR_1 ) { int p = 0 ; long VAR_2 = 0 ; int c , VAR_3 = 0 ; do { c = VAR_1 [ p ++ ] & INT_1 ; <START> VAR_2 |= ( ( c & INT_2 ) < < VAR_3 ) ; <END> VAR_3 += INT_3 ; } while ( ( c & INT_4 ) != 0 ) ; return VAR_2 ; } 
public TYPE_1 apply ( TYPE_2 node , TYPE_3 VAR_1 , Context context ) { Map < TYPE_4 , TYPE_5 > VAR_2 = <START> METHOD_1 ( TYPE_6 . METHOD_2 ( node ) , context , metadata , VAR_3 ) ; <END> if ( VAR_2 . isEmpty ( ) ) { return TYPE_1 . empty ( ) ; } return TYPE_1 . METHOD_3 ( new TYPE_7 ( context . VAR_4 ( ) . METHOD_4 ( ) , METHOD_5 ( context , node , TYPE_8 . create ( VAR_2 ) ) , METHOD_6 ( node . VAR_5 ( ) ) ) ) ; } 
protected void METHOD_1 ( ) { String action = METHOD_2 ( ) . METHOD_3 ( ) ; if ( action == null || ! action . equals ( STRING_1 ) ) { TYPE_1 VAR_1 = new TYPE_1 ( this , TYPE_2 . class ) ; METHOD_4 ( VAR_1 ) ; METHOD_5 ( ) ; } else { METHOD_2 ( ) . METHOD_6 ( null ) ; } <START> super . METHOD_1 ( ) ; <END> } 
public TYPE_2 ( TYPE_1 VAR_2 , double value , double VAR_3 ) { <START> super ( VAR_2 + STRING_1 ) ; <END> this . VAR_2 = VAR_2 ; this . value = value ; this . VAR_3 = VAR_3 ; } 
public TYPE_1 METHOD_1 ( ) { final TYPE_2 properties = TYPE_3 . VAR_2 . METHOD_2 ( ) ; <START> properties . VAR_3 ( ) . addAll ( METHOD_3 ( ) . entrySet ( ) ) ; <END> return properties ; } 
<START> public static TYPE_1 getInstance ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ; } 
private void METHOD_1 ( Throwable t ) { if ( message . VAR_1 ( ) ) { TYPE_1 response = new TYPE_1 ( TYPE_2 . TYPE_7 . VAR_3 ) . METHOD_2 ( TYPE_5 . VAR_5 , TYPE_2 . VAR_6 ) ; if ( t instanceof TYPE_3 ) { <START> response = response . VAR_7 ( TYPE_5 . VAR_8 . VAR_8 , TYPE_4 . METHOD_3 ( TYPE_6 . VAR_10 . VAR_11 ) ) ; <END> } TYPE_2 . instance ( ) . METHOD_4 ( response , id , message . from ) ; } } 
public Optional < TYPE_1 > METHOD_1 ( TYPE_2 context ) { <START> final String VAR_1 = context . VAR_2 ( this . VAR_3 ) ; <END> final String VAR_4 = context . VAR_2 ( this . VAR_5 ) ; if ( VAR_1 == null || VAR_4 == null ) { return Optional . empty ( ) ; } return Optional . of ( new TYPE_1 ( VAR_1 , VAR_4 ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_1 , <END> false ) ; } 
public boolean METHOD_1 ( ) { <START> if ( parent != null ) { <END> return parent . VAR_1 ( ) ; } return VAR_2 ; } 
<START> public TYPE_1 value ( ) { <END> return METHOD_1 ( ) . run ( ) ; } 
private TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_2 VAR_4 ) { <START> super ( VAR_3 , VAR_4 ) ; <END> this . VAR_2 = VAR_2 ; } 
private void METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_2 = new HashMap < > ( 1 ) ; return ; } VAR_2 = new HashMap < > ( VAR_1 . size ( ) * 4 / 3 ) ; for ( TYPE_1 <START> element : <END> VAR_1 ) { METHOD_2 ( element ) ; } } 
public File METHOD_1 ( Collection < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) throws IOException { TYPE_3 VAR_3 = new TYPE_3 ( ) ; File file = new File ( STRING_1 ) ; TYPE_4 VAR_4 = new TYPE_4 ( file ) ; <START> try { <END> VAR_3 . METHOD_2 ( VAR_1 , VAR_4 , new File ( VAR_2 ) ) ; } catch ( IOException e ) { throw new IOException ( e . getMessage ( ) ) ; } finally { VAR_4 . METHOD_3 ( ) ; VAR_4 . close ( ) ; } return file ; } 
private TYPE_1 source ( TYPE_2 iterator ) { <START> if ( iterator instanceof TYPE_3 ) <END> return TYPE_1 . create ( ( TYPE_3 ) iterator ) ; return TYPE_1 . create ( db . VAR_1 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 , int options , TYPE_2 monitor ) throws TYPE_3 { TYPE_4 <START> VAR_2 = <END> TYPE_4 . METHOD_2 ( monitor , 1 ) ; final TYPE_5 VAR_3 = METHOD_3 ( VAR_4 . NONE , null ) ; if ( VAR_3 . METHOD_4 ( ) ) { METHOD_5 ( VAR_3 , VAR_1 , options , VAR_2 . split ( 1 ) ) ; } else { METHOD_6 ( VAR_3 , VAR_1 , options , VAR_2 . split ( 1 ) ) ; } } 
public void METHOD_1 ( ) { if ( VAR_1 != null && VAR_2 == TYPE_2 . VAR_4 ) <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 = TYPE_2 . VAR_5 ; try { METHOD_3 ( ) ; } catch ( Exception e ) { throw new TYPE_1 ( e ) ; } } 
public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( TYPE_2 . class ) ; String VAR_2 = VAR_1 . METHOD_3 ( ) . toString ( ) ; <START> assertThat ( VAR_2 , METHOD_4 ( STRING_1 ) ) ; <END> } 
public List < TYPE_1 > METHOD_1 ( ) { METHOD_2 ( ) ; <START> return VAR_1 . values ( ) . stream ( ) . collect ( Collectors . VAR_2 ( ) ) ; <END> } 
public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , Map < String , String > VAR_3 ) throws TYPE_2 , TYPE_3 { try { <START> VAR_4 . METHOD_2 ( INT_1 , TimeUnit . VAR_5 ) ; <END> } catch ( InterruptedException exception ) { exception . VAR_6 ( ) ; } super . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; } 
<START> public static String <END> METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { return METHOD_1 ( VAR_1 , VAR_2 , VAR_1 . METHOD_2 ( ) ) ; } 
private void METHOD_1 ( String VAR_1 , int VAR_2 , String message , Object ... VAR_3 ) { TYPE_1 . METHOD_2 ( VAR_2 , METHOD_3 ( VAR_1 ) , ( TYPE_2 ) METHOD_4 ( VAR_1 , VAR_4 , false ) , ( TYPE_2 ) METHOD_4 ( VAR_1 , VAR_5 , false ) , message , VAR_3 ) ; VAR_6 . remove ( VAR_1 ) ; <START> METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; <END> } 
private int METHOD_1 ( ) { int result = System . VAR_1 ( VAR_2 ) ; result = INT_1 * result + System . VAR_1 ( VAR_3 ) ; <START> result = INT_1 * result + ( VAR_4 != null ? VAR_4 . METHOD_2 ( ) : 0 ) ; <END> result = INT_1 * result + System . VAR_1 ( VAR_5 ) ; return result ; } 
public int METHOD_1 ( ) { int VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != VAR_2 ) { return VAR_1 ; } else { <START> return TYPE_1 . METHOD_3 ( ) . METHOD_4 ( ) - 1 ; <END> } } 
<START> protected String METHOD_1 ( TYPE_1 id ) { <END> return STRING_1 + VAR_1 . METHOD_2 ( id . VAR_2 ( ) ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> METHOD_2 ( true ) ; <END> return new TYPE_3 ( METHOD_3 ( ) , METHOD_4 ( ) ) ; } 
public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <START> if ( ! TYPE_4 . METHOD_2 ( VAR_1 ) && this instanceof TYPE_5 && ( ( TYPE_5 ) this ) . METHOD_3 ( ) ) { <END> for ( TYPE_2 VAR_4 : ( ( TYPE_5 ) this ) . METHOD_4 ( VAR_1 , VAR_3 . VAR_5 , VAR_3 , VAR_2 ) ) { METHOD_5 ( VAR_1 , VAR_3 , VAR_4 , VAR_2 ) ; } } return super . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; } 
<START> protected void METHOD_1 ( final TYPE_1 VAR_1 ) { <END> if ( VAR_1 != null ) { VAR_2 . METHOD_1 ( VAR_3 . VAR_4 . create ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( ) ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 message , TYPE_3 session ) throws TYPE_4 { <START> try { try ( TYPE_5 target = TYPE_5 . METHOD_2 ( this , session , METHOD_3 ( ) ) ) { try ( TYPE_6 out = target . VAR_1 ( ) ) { <END> VAR_2 . run ( message . VAR_3 ( ) , out ) ; } return target . VAR_4 ( ) ; } } catch ( Exception e ) { throw new TYPE_4 ( this , STRING_1 , e ) ; } } 
public void METHOD_1 ( TYPE_1 session , Object VAR_1 ) { session . VAR_2 ( VAR_3 , VAR_1 ) ; if ( VAR_4 != null ) { <START> if ( VAR_4 . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) < 0 ) { <END> throw new TYPE_2 ( STRING_1 ) ; } } VAR_5 . METHOD_4 ( session , VAR_1 ) ; } 
private static boolean METHOD_1 ( TYPE_1 VAR_1 , Map < String , TYPE_2 > VAR_2 ) { String VAR_3 = VAR_1 . getKey ( ) ; TYPE_2 VAR_4 = VAR_2 . get ( VAR_3 ) ; if ( VAR_4 == null ) { if ( TYPE_1 . Type . VAR_5 == VAR_1 . getType ( ) ) { <START> return VAR_6 ; <END> } throw new IllegalStateException ( String . format ( STRING_1 , VAR_3 ) ) ; } return VAR_4 . METHOD_2 ( ) ; } 
<START> public void error ( TYPE_1 e ) throws TYPE_2 { <END> if ( VAR_1 == null ) { VAR_1 = e ; VAR_2 = new StringBuilder ( INT_1 ) ; VAR_2 . append ( CHAR_1 ) . append ( VAR_3 ) . append ( CHAR_1 ) . append ( STRING_1 ) ; } VAR_2 . append ( CHAR_2 ) . append ( e . toString ( ) ) ; } 
public void METHOD_1 ( String name , String VAR_1 , String VAR_2 , String VAR_3 ) { TYPE_1 . METHOD_2 ( TYPE_1 . TYPE_3 . VAR_5 ) ; <START> VAR_6 . METHOD_3 ( false ) ; <END> if ( VAR_7 ) { TYPE_2 . METHOD_4 ( this , name , VAR_1 , VAR_2 , VAR_3 , false ) ; } else { TYPE_2 . METHOD_5 ( this , name , VAR_1 , VAR_2 , VAR_3 ) ; } METHOD_6 ( TYPE_4 . VAR_9 ) ; METHOD_7 ( ) ; } 
protected void log ( final Level VAR_1 , final String msg , final Throwable t ) { <START> this . logger . log ( VAR_1 , this . VAR_2 + STRING_1 + msg , t ) ; <END> } 
<START> private short [ ] METHOD_1 ( int [ ] VAR_1 ) { <END> if ( VAR_1 == null ) { return null ; } short [ ] VAR_2 = new short [ VAR_1 . length ] ; for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { VAR_2 [ i ] = METHOD_2 ( VAR_1 [ i ] ) ; } return VAR_2 ; } 
protected void METHOD_1 ( List < TYPE_1 > VAR_1 ) { if ( VAR_1 == null ) { METHOD_2 ( STRING_1 , STRING_2 ) ; } else { <START> for ( TYPE_1 VAR_2 : VAR_1 ) { <END> VAR_3 . add ( VAR_2 ) ; } } for ( int i = 0 ; i < INT_1 ; i ++ ) VAR_3 . add ( new TYPE_1 ( STRING_3 + i , STRING_4 + i , STRING_5 + i ) ) ; VAR_4 . METHOD_3 ( ) ; } 
public TYPE_2 ( String VAR_2 , String VAR_3 ) { VAR_4 = VAR_2 . substring ( 1 , VAR_2 . length ( ) - 1 ) ; <START> VAR_5 = ( STRING_1 . equalsIgnoreCase ( VAR_3 ) ) ? TYPE_1 . VAR_7 : TYPE_1 . VAR_8 ; <END> } 
public TYPE_4 ( TYPE_1 VAR_2 , Optional < TYPE_2 > filter , boolean VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . filter = filter . VAR_5 ( null ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = METHOD_1 ( VAR_4 , STRING_2 ) ; this . VAR_6 = this . filter != null && ! this . filter . VAR_7 ( ) ; <START> this . VAR_8 = this . filter == null || this . filter . VAR_9 ( ) ; <END> } 
public void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { this . VAR_2 = null ; if ( VAR_1 != null ) { <START> this . VAR_1 = new HashSet < > ( VAR_1 ) ; <END> } } 
public TYPE_1 ( T parameters ) { super ( parameters ) ; <START> this . METHOD_1 ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> } 
private Collection < File > METHOD_1 ( File VAR_1 ) throws IOException { Collection < File > VAR_2 = new ArrayList < > ( ) ; <START> TYPE_1 < Path > VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , STRING_1 ) ; <END> VAR_3 . forEach ( path - > VAR_2 . add ( path . VAR_4 ( ) ) ) ; return VAR_2 ; } 
private String METHOD_1 ( ) { TYPE_1 VAR_1 = getClass ( ) . METHOD_2 ( ) ; if ( VAR_1 instanceof TYPE_2 ) { <START> TYPE_3 url = ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( TYPE_5 . VAR_3 ) ; <END> try { TYPE_4 VAR_4 = new TYPE_4 ( url . VAR_5 ( ) ) ; return VAR_4 . METHOD_4 ( ) . getValue ( STRING_1 ) ; } catch ( IOException e ) { } } return null ; } 
protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( new TYPE_1 ( ) ) ; bind ( new TYPE_2 < TYPE_3 < TYPE_4 > > ( ) { } ) . to ( new TYPE_2 < TYPE_5 > ( ) { } ) ; <START> bind ( TYPE_6 . class ) . to ( new TYPE_2 < TYPE_7 > ( ) { } ) ; <END> } 
public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ) ; TYPE_2 user = METHOD_3 ( TYPE_2 . class ) ; when ( VAR_1 . remove ( METHOD_4 ( ) ) ) . METHOD_5 ( 1 ) ; <START> VAR_2 . METHOD_6 ( TYPE_3 . TYPE_4 , INT_1 ) ; <END> VAR_5 . METHOD_7 ( session , user ) ; } 
public void clear ( ) { VAR_1 . clear ( ) ; <START> ; <END> VAR_2 . clear ( ) ; METHOD_1 ( ) . clear ( ) ; } 
public void METHOD_1 ( float VAR_1 ) { <START> VAR_2 = VAR_1 ; <END> } 
public void METHOD_1 ( TYPE_1 task ) throws TYPE_2 { boolean contains = false ; <START> for ( String VAR_1 : VAR_2 ) { <END> if ( VAR_1 . equals ( task . getName ( ) ) ) { contains = true ; break ; } } if ( ! contains ) { VAR_2 . add ( task . getName ( ) ) ; } } 
public TYPE_1 getValue ( ) { <START> if ( VAR_1 ) { <END> return VAR_2 . METHOD_1 ( VAR_3 ) ; } return VAR_3 ; } 
private String METHOD_1 ( TYPE_1 uri , String VAR_1 ) { String url = VAR_2 . getString ( STRING_1 , null , STRING_2 ) ; if ( TYPE_2 . METHOD_2 ( url ) ) { url = uri . toString ( ) ; } if ( ! url . VAR_3 ( STRING_3 ) ) { url += STRING_3 ; } <START> if ( TYPE_2 . METHOD_2 ( VAR_1 ) ) { <END> url += STRING_4 + VAR_1 ; } return url ; } 
<START> <END> <END> public <END> <END> void <END> <END> METHOD_1 ( <END> TYPE_1 <END> <END> <END> <END> <END> <END> <END> item , <END> Throwable <END> <END> t <END> ) <END> { <END> if <END> ( <END> VAR_1 != null <END> && <END> t instanceof <END> Exception <END> ) <END> <END> { try <END> <END> <END> { <END> VAR_1 . METHOD_2 ( TYPE_3 
private TYPE_1 [ ] METHOD_1 ( TYPE_2 VAR_1 , Path VAR_2 ) { try { <START> return VAR_1 . METHOD_2 ( new Path ( VAR_3 [ 0 ] . getPath ( ) , TYPE_4 . VAR_5 ) ) ; <END> } catch ( TYPE_3 e ) { return new TYPE_1 [ ] { } ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
<START> public static boolean METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) . version ( ) . METHOD_3 ( INT_1 , 2 ) ; } 
public void <START> METHOD_1 ( ) <END> throws IOException { TYPE_2 . TYPE_5 instance = TYPE_2 . getInstance ( ) ; String [ ] VAR_1 = instance . VAR_2 ( ) ; Arrays . VAR_3 ( VAR_1 ) ; for ( String id : VAR_1 ) { TYPE_3 VAR_4 = instance . VAR_5 ( id ) ; TYPE_4 VAR_6 = TYPE_4 . METHOD_2 ( id , VAR_4 , Long . VAR_7 ) ; assertNotNull ( STRING_1 + id + STRING_2 , VAR_6 ) ; assertEquals ( id , VAR_6 . METHOD_3 ( ) ) ; } } 
<START> public Integer METHOD_1 ( ) { <END> return VAR_1 ; } 
<START> public byte METHOD_1 ( ) <END> { return VAR_1 ; } 
public TYPE_3 ( ANNOTATION_1 ( STRING_1 ) final Type type , ANNOTATION_1 ( STRING_2 ) final Boolean VAR_2 , ANNOTATION_1 ( STRING_3 ) final String VAR_3 , ANNOTATION_1 ( STRING_4 ) final String VAR_4 , ANNOTATION_1 ( STRING_5 ) final TYPE_1 VAR_5 , ANNOTATION_1 ( STRING_6 ) final TYPE_2 VAR_6 ) { this . type = type ; this . VAR_2 = VAR_2 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; <START> this . VAR_3 = VAR_3 ; <END> this . VAR_4 = VAR_4 ; } 
public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . get ( 0 ) ; <END> } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 == null ) { return ; } <START> while ( VAR_2 instanceof TYPE_1 ) { <END> VAR_2 = ( ( TYPE_1 ) VAR_2 ) . METHOD_2 ( ) ; } TYPE_2 VAR_3 = VAR_4 . apply ( VAR_2 ) ; VAR_1 . METHOD_3 ( VAR_3 ) ; VAR_2 = null ; } 
public final String METHOD_1 ( ) { if ( this . properties . isEmpty ( ) ) return STRING_1 ; ANNOTATION_1 ( STRING_2 ) TYPE_1 e = this . properties . VAR_1 ( ) ; <START> String response = STRING_3 ; <END> response += STRING_4 + this . VAR_2 + STRING_5 ; while ( e . VAR_3 ( ) ) { String key = ( String ) e . VAR_4 ( ) ; response += STRING_6 + key + STRING_7 + this . properties . getProperty ( key ) + STRING_5 ; } return response ; } 
public void METHOD_1 ( ) { try { <START> log . info ( STRING_1 ) ; <END> TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 < Integer > getValue ( TYPE_4 . TYPE_5 ) * - 1 ) ; VAR_5 . METHOD_4 ( VAR_1 ) ; log . info ( STRING_2 ) ; } catch ( Throwable t ) { log . error ( STRING_3 , TYPE_2 . METHOD_5 ( t ) ) ; log . debug ( STRING_4 , t ) ; } } 
public void METHOD_1 ( String id ) { HashMap < String , String > map = new HashMap < > ( ) ; <START> Optional . VAR_1 ( VAR_2 . METHOD_2 ( ) . get ( id ) ) . METHOD_3 ( node - > { <END> map . put ( VAR_3 , id ) ; map . put ( VAR_4 , id ) ; } ) ; context . VAR_5 ( map ) ; } 
protected void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( TYPE_1 . getInstance ( ) <END> . METHOD_4 ( ) . METHOD_5 ( getParameters ( ) . METHOD_6 ( ) ) ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> TYPE_2 . METHOD_2 ( false ) ; <END> TYPE_3 . METHOD_3 ( this ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; if ( METHOD_6 ( ) != null ) { METHOD_6 ( ) . METHOD_7 ( true ) ; } METHOD_8 ( this ) ; } 
void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_1 ( VAR_2 ) ; <END> } 
public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> boolean VAR_2 = ! VAR_1 . METHOD_2 ( ) . isEmpty ( ) ; <END> if ( VAR_2 ) { if ( TYPE_2 . METHOD_3 ( TYPE_6 . VAR_4 ) ) { VAR_2 = TYPE_3 . exists ( VAR_1 . METHOD_2 ( ) ) ; } else { VAR_2 = VAR_1 . METHOD_4 ( ) . equals ( TYPE_4 . METHOD_5 ( ) ) ; } } return VAR_2 && VAR_5 == TYPE_5 . VAR_7 ; } 
public static TYPE_1 create ( TYPE_2 context , TYPE_3 VAR_1 , long id , long length , TYPE_4 type , TYPE_5 options ) throws IOException { long VAR_2 = TYPE_6 . METHOD_1 ( TYPE_8 . VAR_4 ) ; TYPE_7 VAR_5 = context . VAR_6 ( VAR_1 ) ; try { return new TYPE_1 ( context , VAR_1 , id , length , VAR_2 , type , options , VAR_5 ) ; } catch ( Exception e ) { <START> VAR_5 . close ( ) ; <END> context . VAR_7 ( VAR_1 , VAR_5 ) ; throw e ; } } 
public static TYPE_1 of ( Type type , TYPE_2 < ? > VAR_1 ) { <START> return ( t , ctx ) - > t == type <END> ? Optional . of ( VAR_1 ) : Optional . empty ( ) ; } 
private void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( ) && ( ! METHOD_6 ( ) . METHOD_7 ( ) || METHOD_6 ( ) . METHOD_5 ( ) ) ) ; <END> } 
public boolean VAR_1 ( ) { <START> if ( ! VAR_2 . VAR_3 ( TYPE_1 . VAR_5 ) ) ) { <END> return false ; } if ( VAR_6 . VAR_7 ( ) ) { return true ; } return VAR_2 . VAR_8 ( ) && ( VAR_2 . VAR_9 ( ) . length > 1 || ! VAR_2 . VAR_10 . isEmpty ( ) || TYPE_2 . VAR_12 ( ) ) ; } 
public final void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; final String user = null ; <START> final String VAR_2 = STRING_1 ; <END> VAR_1 . METHOD_2 ( user , VAR_2 ) ; } 
public int METHOD_1 ( ) { if ( VAR_1 == null ) { <START> throw new IllegalStateException ( STRING_1 + VAR_2 + STRING_2 + VAR_3 ) ; <END> } return VAR_1 ; } 
<START> public Collection < String > METHOD_1 ( ) { <END> if ( VAR_1 != null ) { return TYPE_1 . METHOD_2 ( VAR_1 ) ; } return Collections . VAR_2 ( ) ; } 
protected boolean METHOD_1 ( ) { <START> if ( VAR_1 >= VAR_2 ) { <END> return false ; } return true ; } 
public void METHOD_1 ( ) { for ( TYPE_1 key : TYPE_1 . METHOD_2 ( ) ) { <START> METHOD_3 ( key . VAR_1 ( ) , "" , String . format ( <END> STRING_1 , key . getName ( ) ) ) ; } } 
<START> private boolean METHOD_1 ( String VAR_1 ) <END> { final boolean VAR_2 = VAR_3 . size ( ) < this . VAR_4 ; final boolean VAR_5 = VAR_2 || this . VAR_6 . METHOD_2 ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) , VAR_1 ) < 0 ; return VAR_5 && VAR_6 . METHOD_2 ( VAR_1 , VAR_7 ) > 0 ; } 
public int METHOD_1 ( ) { int result = TYPE_1 . METHOD_2 ( entity ) ; <START> result = INT_1 * result + Arrays . VAR_1 ( values ) ; <END> return result ; } 
TYPE_1 METHOD_1 ( TYPE_2 id ) throws TYPE_3 { TYPE_4 VAR_1 = VAR_2 . get ( id ) ; if ( VAR_1 == null ) { <START> throw new TYPE_3 ( STRING_1 + id + STRING_2 + VAR_3 , <END> TYPE_7 . TYPE_5 ) ; } if ( ! VAR_1 . METHOD_2 ( ) ) { throw new TYPE_3 ( STRING_3 + id + STRING_2 + VAR_3 + STRING_4 , TYPE_7 . TYPE_6 ) ; } return VAR_1 ; } 
public static int getValue ( String text ) { if ( text == null || text . isEmpty ( ) || text . equals ( STRING_1 ) ) { return VAR_1 ; } if ( text . equals ( STRING_2 ) ) { return VAR_2 ; } <START> if ( text . equals ( STRING_3 ) ) { <END> return VAR_3 ; } throw new IllegalArgumentException ( STRING_4 + text ) ; } 
public String METHOD_1 ( Object element ) { if ( element instanceof TYPE_1 ) { String VAR_1 = ( ( TYPE_1 ) element ) . METHOD_2 ( ) ; if ( VAR_1 != null && <START> VAR_1 . length ( ) > 0 ) { <END> return VAR_1 ; } } return super . METHOD_1 ( element ) ; } 
public String METHOD_1 ( String name ) throws IOException { if ( METHOD_2 ( ) != null ) { try ( TYPE_1 is = METHOD_3 ( name ) ) { if ( is == null ) { return TYPE_2 . METHOD_4 ( new File ( name ) , VAR_1 ) ; } return TYPE_3 . toString ( is , VAR_1 ) ; <START> } catch ( Exception e ) { <END> } } return null ; } 
<START> public void METHOD_1 ( ) throws Exception { <END> assertEquals ( VAR_1 . METHOD_2 ( 0 ) , VAR_2 ) ; METHOD_3 ( VAR_1 . METHOD_2 ( 0 ) , VAR_3 ) ; } 
public Optional < TYPE_1 > METHOD_1 ( final double x , final double y ) { <START> return null ; <END> } 
public void METHOD_1 ( TYPE_1 element ) { <START> if ( element instanceof TYPE_2 ) { <END> VAR_1 = new TYPE_3 ( ( TYPE_4 ) element , null ) ; } else { VAR_1 = element ; } } 
private boolean METHOD_1 ( ) { <START> if ( ! TYPE_1 . METHOD_2 ( ) ) { <END> VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) . type ( TYPE_2 . VAR_3 ) . build ( ) . METHOD_5 ( ) ; return true ; } return false ; } 
public TYPE_1 METHOD_1 ( TYPE_2 < ? extends TYPE_3 > VAR_1 , TYPE_4 session ) throws TYPE_5 { TYPE_6 listener = METHOD_2 ( STRING_1 ) ; TYPE_1 VAR_2 = METHOD_3 ( VAR_1 , session , listener ) ; METHOD_4 ( Long . VAR_3 ) ; Iterator < TYPE_7 > VAR_4 = listener . VAR_5 ( ) ; if ( VAR_4 . hasNext ( ) ) { throw new TYPE_5 ( <START> String . format ( STRING_2 , VAR_4 . next ( ) . METHOD_5 ( ) ) ) ; <END> } return VAR_2 ; } 
public TYPE_6 . TYPE_7 . File METHOD_1 ( int options , TYPE_2 monitor ) throws TYPE_3 { TYPE_4 <START> VAR_1 = <END> TYPE_4 . METHOD_2 ( monitor ) ; if ( options != VAR_2 . VAR_3 ) return null ; return TYPE_5 . METHOD_3 ( ) . cache ( this , VAR_1 ) ; } 
public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , VAR_3 ) ; <START> LOG . info ( STRING_1 ) ; <END> METHOD_1 ( ) ; } 
private boolean METHOD_1 ( String VAR_1 ) { return VAR_2 . METHOD_2 ( session . VAR_3 ( ) , TYPE_1 . of ( VAR_1 ) ) . contains ( VAR_1 ) <START> && metadata . VAR_4 ( session , VAR_1 ) ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { <START> Date d = new Date ( new Date ( ) . METHOD_2 ( ) - INT_1 ) ; <END> if ( TYPE_2 . METHOD_3 ( VAR_1 ) != null && d . VAR_2 ( TYPE_2 . METHOD_3 ( VAR_1 ) ) ) { return ; } TYPE_2 . map ( VAR_1 ) . remove ( TYPE_2 . VAR_3 ) ; } 
public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; if ( this . VAR_1 != null ) { <START> this . VAR_1 . METHOD_2 ( ) ; <END> this . VAR_1 . METHOD_3 ( this ) ; this . VAR_1 . METHOD_4 ( this ) ; this . VAR_1 . METHOD_5 ( this ) ; } } 
private void METHOD_1 ( List < String > VAR_1 , String [ ] VAR_2 ) { StringBuilder VAR_3 = new StringBuilder ( ) ; for ( String log : VAR_1 ) { VAR_3 . append ( log ) ; } String VAR_4 = VAR_3 . toString ( ) ; for ( String VAR_5 : VAR_2 ) { <START> LOG . error ( STRING_1 + VAR_5 ) ; <END> assertTrue ( VAR_4 . contains ( VAR_5 ) ) ; } } 
private String METHOD_1 ( String VAR_1 ) { int VAR_2 = VAR_1 . METHOD_2 ( STRING_1 ) ; if ( VAR_2 >= 0 ) { return VAR_1 . substring ( 0 , VAR_2 ) ; } <START> return null ; <END> } 
private static TYPE_1 METHOD_1 ( ) throws Throwable { <START> System . out . println ( STRING_1 ) ; <END> return new TYPE_1 ( STRING_2 ) ; } 
public void METHOD_1 ( ) throws TYPE_1 { METHOD_2 ( ) ; try { VAR_1 . METHOD_3 ( STRING_1 ) ; } catch ( final Throwable a ) { <START> } <END> VAR_1 . METHOD_4 ( METHOD_5 ( STRING_1 ) . METHOD_6 ( METHOD_7 ( METHOD_8 ( ) ) . from ( table ( STRING_2 ) ) ) ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; } 
<START> private void METHOD_1 ( ) { <END> VAR_1 . METHOD_1 ( VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) ) ; } 
public < T > TYPE_1 < T > METHOD_1 ( Class < T > type ) { <START> return ( TYPE_1 < T > ) ( File . VAR_1 . equals ( type ) ? TYPE_2 . VAR_3 : null ) ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> String item = VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> return TYPE_1 . valueOf ( item . VAR_2 ( ) ) ; } 
public int METHOD_1 ( final TYPE_1 resource , final boolean VAR_1 ) { if ( resource == null ) return 0 ; if ( resource . VAR_2 <= 0 ) return 0 ; <START> if ( ! METHOD_2 ( resource ) ) <END> return 0 ; int VAR_3 = super . METHOD_1 ( resource , VAR_1 ) ; if ( VAR_3 != 0 && VAR_4 != null ) VAR_4 . METHOD_3 ( this ) ; return VAR_3 ; } 
private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 ; boolean VAR_2 = VAR_3 . equalsIgnoreCase ( STRING_1 ) ; if ( VAR_2 || VAR_4 || VAR_5 ) { VAR_1 = new TYPE_2 ( VAR_2 , VAR_4 , VAR_6 , VAR_7 , VAR_8 , VAR_5 , VAR_9 ) ; } else { <START> VAR_1 = ( ) - > TYPE_3 . METHOD_2 ( ) ; <END> } return VAR_1 ; } 
public String METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; String VAR_2 = VAR_1 . METHOD_3 ( ) ; <START> return VAR_2 ; <END> } 
public TYPE_1 METHOD_1 ( ) { <START> if ( parent != null ) { <END> return parent . VAR_1 ( ) ; } if ( server != null && ( ( TYPE_2 ) server ) . METHOD_2 ( ) ) { TYPE_3 VAR_2 = ( TYPE_3 ) server ; server = ( TYPE_1 ) METHOD_3 ( VAR_2 ) ; if ( server != VAR_2 ) { if ( METHOD_4 ( ) ) { METHOD_5 ( new TYPE_4 ( this , TYPE_6 . VAR_4 , TYPE_5 . VAR_6 , VAR_2 , server ) ) ; } } } return server ; } 
<START> public < T extends Object > boolean contains ( TYPE_1 < T > VAR_1 ) { <END> return contains ( VAR_1 . name ( ) ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof TYPE_1 ) ) return false ; TYPE_1 m = ( TYPE_1 ) o ; if ( m . VAR_1 != VAR_1 ) return false ; if ( m . VAR_2 != VAR_2 ) return false ; <START> if ( ! m . method . equals ( method ) ) return false ; <END> return true ; } 
private static int METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { TYPE_2 < TYPE_3 > VAR_2 = VAR_1 . METHOD_2 ( ) ; assertNotNull ( VAR_2 ) ; int count = 0 ; <START> for ( ; VAR_2 . hasNext ( ) ; ++ count ) <END> VAR_2 . next ( ) ; return count ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 . add ( new TYPE_2 ( VAR_1 . METHOD_2 ( ) , VAR_1 . getName ( ) , VAR_1 . getValue ( ) , <END> VAR_1 . getPath ( ) , VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ) ; } 
public void METHOD_1 ( ) throws IOException { <START> String VAR_1 = null ; <END> VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 , "" ) ; assertTrue ( STRING_2 , VAR_1 . equals ( STRING_3 ) ) ; } 
public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_3 ( ) ; <START> System . out . println ( VAR_4 . VAR_5 ) ; <END> TYPE_2 VAR_6 = VAR_1 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_5 ( ) ) ; VAR_6 . METHOD_6 ( ) ; } 
private void METHOD_1 ( long VAR_1 , ANNOTATION_1 TYPE_1 VAR_2 ) { TYPE_1 VAR_3 ; try { <START> VAR_3 = read ( VAR_1 , VAR_4 ) ; <END> } catch ( TYPE_2 VAR_5 ) { throw new TYPE_3 ( STRING_1 ) ; } if ( ! VAR_3 . equals ( VAR_2 ) ) { throw new TYPE_4 ( TYPE_5 . VAR_7 ) ; } } 
public void METHOD_1 ( ) { <START> TYPE_1 child = VAR_1 . METHOD_2 ( STRING_1 , VAR_2 , VAR_3 ) ; <END> TYPE_1 VAR_4 = VAR_1 . METHOD_2 ( STRING_2 , VAR_3 , VAR_5 ) ; assertEquals ( VAR_3 , VAR_4 . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; assertEquals ( VAR_2 , VAR_4 . METHOD_3 ( ) ) ; } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_1 = null ; <END> } 
public void METHOD_1 ( TYPE_1 server ) { <START> assertEquals ( server . VAR_1 ( ) , 2 ) ; <END> try { assertEquals ( server . VAR_2 ( ) . METHOD_2 ( ) , STRING_1 ) ; } catch ( InterruptedException e ) { TYPE_2 . METHOD_3 ( e ) ; } } 
void METHOD_1 ( ) throws Exception { <START> <END> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( TYPE_3 . TYPE_2 . VAR_5 , VAR_6 ) ; assertNotNull ( VAR_1 ) ; assertNotNull ( VAR_1 . getId ( ) ) ; log . info ( STRING_1 + VAR_1 . getId ( ) ) ; } 
public String toString ( ) { <START> Map < String , Object > VAR_1 = new TYPE_1 < String , Object > ( this . values ) ; <END> VAR_1 . remove ( VAR_2 ) ; return VAR_1 . toString ( ) ; } 
public void METHOD_1 ( ) { VAR_1 = TYPE_1 . METHOD_2 ( TYPE_2 . class ) ; writer = new TYPE_3 ( VAR_1 ) ; VAR_2 = TYPE_1 . METHOD_2 ( TYPE_4 . class ) ; result = TYPE_1 . METHOD_2 ( TYPE_5 . class ) ; <START> server = TYPE_6 . METHOD_3 ( ) ; <END> } 
void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , boolean VAR_3 ) { final TYPE_1 VAR_4 = TYPE_2 . METHOD_2 ( VAR_1 , VAR_5 . METHOD_3 ( ) , VAR_5 . METHOD_4 ( ) , true , VAR_3 ) ; VAR_4 . METHOD_5 ( STRING_1 , STRING_2 ) ; METHOD_6 ( VAR_2 ) ; <START> } <END> 
public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { <START> METHOD_2 ( TYPE_3 . VAR_3 ) . forEach ( VAR_1 ) ; <END> } 
public void METHOD_1 ( int VAR_1 , boolean VAR_2 ) { if ( ! VAR_3 && VAR_2 ) { boolean VAR_4 = false ; synchronized ( VAR_5 ) { <START> if ( VAR_5 . contains ( ( Object ) VAR_1 ) ) { <END> VAR_6 . add ( ( Integer ) VAR_1 ) ; if ( VAR_6 . size ( ) == VAR_5 . size ( ) ) { log . VAR_7 ( STRING_1 , VAR_5 ) ; VAR_4 = true ; } } } if ( VAR_4 ) { METHOD_2 ( true ) ; } } } 
public TYPE_1 METHOD_1 ( int j ) { <START> return METHOD_1 ( j , this . factory ) ; <END> } 
void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( ( ) - > <END> METHOD_4 ( Messages . TYPE_1 ) ) ; METHOD_5 ( ) . METHOD_6 ( this : : METHOD_7 ) ; } 
public void METHOD_1 ( ) { try { <START> VAR_1 . METHOD_2 ( true ) ; <END> } catch ( Throwable t ) { log . debug ( STRING_1 , TYPE_1 . METHOD_3 ( t ) ) ; } VAR_1 = VAR_2 . METHOD_4 ( this : : METHOD_5 , 0 , VAR_3 , TimeUnit . VAR_4 ) ; } 
<START> public TYPE_1 METHOD_1 ( ) throws RuntimeException { <END> for ( TYPE_1 trace : TYPE_2 . getInstance ( ) . METHOD_2 ( ) ) { if ( trace . VAR_1 ( ) . equals ( METHOD_3 ( ) ) ) { return trace ; } } return null ; } 
private void METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> METHOD_2 ( METHOD_3 ( VAR_1 ) , asList ( VAR_1 ) ) ; <END> } 
public void METHOD_1 ( final TYPE_1 column ) throws TYPE_2 { final TYPE_3 VAR_1 = new TYPE_7 . TYPE_8 ( column ) ; for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { <START> final TYPE_5 VAR_3 = VAR_2 . get ( i ) ; <END> if ( VAR_3 . METHOD_2 ( VAR_1 ) ) { VAR_3 . append ( VAR_1 ) ; break ; } } VAR_4 . METHOD_3 ( new TYPE_6 ( ) ) ; } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { Collection < TYPE_4 > VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( VAR_3 != null && VAR_2 != null ) { for ( TYPE_4 VAR_4 : VAR_3 ) { TYPE_1 VAR_5 = VAR_4 . METHOD_3 ( ) ; <START> if ( VAR_5 . METHOD_4 ( ) != null && VAR_5 . METHOD_4 ( ) . equals ( VAR_2 ) ) { <END> return VAR_5 ; } } } return null ; } 
public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , STRING_2 ) ; METHOD_2 ( STRING_3 , STRING_2 ) ; METHOD_2 ( STRING_4 , STRING_5 ) ; METHOD_2 ( STRING_6 , STRING_5 ) ; <START> METHOD_2 ( STRING_7 , STRING_8 ) ; <END> METHOD_2 ( STRING_9 , STRING_10 ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_2 . containsKey ( VAR_1 ) ) { return VAR_2 . get ( VAR_1 ) ; } return null ; <END> } 
protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; if ( Boolean . VAR_3 . equals ( getParameters ( ) . METHOD_3 ( ) ) && ! METHOD_4 ( VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ) ) { return false ; } <START> else return true ; <END> } 
private void METHOD_1 ( ) { <START> try { <END> if ( this . response != null && this . response . trim ( ) . startsWith ( STRING_1 ) ) { METHOD_2 ( ) ; } } catch ( Exception e ) { e . VAR_1 ( ) ; if ( this . exception == null ) { this . exception = e ; } } } 
private boolean METHOD_1 ( List < Pair < Guid , Boolean > > VAR_1 ) { for ( Pair < Guid , Boolean > VAR_2 : VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( ) == true ) { <END> return true ; } } return false ; } 
public String METHOD_1 ( ) { TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> if ( ! VAR_1 . equals ( STRING_2 ) ) { <END> return String . format ( STRING_3 , VAR_1 , VAR_2 ) ; } return VAR_2 ; } 
public void METHOD_1 ( final String VAR_1 , <START> final TYPE_1 VAR_2 ) { <END> if ( VAR_1 != null && VAR_1 . trim ( ) . length ( ) > 0 && METHOD_2 ( ) instanceof TYPE_2 ) { final TYPE_2 VAR_3 = ( TYPE_2 ) METHOD_2 ( ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; VAR_3 . METHOD_4 ( ) ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> TYPE_3 . METHOD_2 ( this . getClass ( ) ) ; <END> METHOD_3 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; } 
public void METHOD_1 ( ) { exception . VAR_1 ( IllegalStateException . VAR_2 ) ; TYPE_1 message = METHOD_2 ( TYPE_1 . VAR_2 ) ; when ( message . VAR_3 ( ) ) . METHOD_3 ( VAR_4 ) ; try { <START> VAR_5 . METHOD_4 ( message ) ; <END> } finally { METHOD_5 ( VAR_6 , METHOD_6 ( 0 ) ) . METHOD_7 ( ) ; METHOD_5 ( VAR_6 , METHOD_6 ( 0 ) ) . METHOD_8 ( ) ; METHOD_9 ( VAR_6 ) ; } } 
public TYPE_1 ( ) { this . VAR_2 = true ; <START> this . VAR_3 = "" ; <END> } 
public static void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; if ( ! VAR_2 . METHOD_2 ( ) . isEmpty ( ) && VAR_2 . METHOD_3 ( ) . isEmpty ( ) ) { throw new TYPE_3 ( STRING_1 ) ; } } else if ( VAR_1 instanceof TYPE_4 || VAR_1 instanceof TYPE_5 ) { METHOD_1 ( VAR_1 . METHOD_4 ( 0 ) ) ; } else { <START> return ; <END> } } 
protected Map < String , Pair < String , String > > METHOD_1 ( ) { if ( METHOD_2 ( ) ) { <START> return Collections . VAR_1 ( METHOD_3 ( ) . getId ( ) . toString ( ) , TYPE_1 . VAR_3 ) ; <END> } return Collections . VAR_4 ; } 
public void run ( ) { <START> TYPE_1 VAR_1 ; <END> TYPE_2 outputStream = null ; try { VAR_1 = VAR_2 . METHOD_1 ( ) ; String response = METHOD_2 ( VAR_1 ) ; outputStream = VAR_1 . METHOD_3 ( ) ; METHOD_4 ( outputStream ) ; write ( response . VAR_3 ( ) , outputStream ) ; outputStream . VAR_4 ( ) ; } catch ( IOException e ) { } finally { TYPE_3 . METHOD_5 ( outputStream ) ; } } 
public final boolean METHOD_1 ( final int VAR_1 , final int VAR_2 ) { final int VAR_3 = VAR_4 + VAR_5 ; final int VAR_6 = TYPE_1 . METHOD_2 ( info , VAR_3 ) ; <START> if ( VAR_1 < VAR_6 ) <END> return true ; if ( VAR_1 == VAR_6 ) return VAR_2 <= TYPE_1 . METHOD_2 ( info , VAR_3 + 4 ) ; return false ; } 
<START> private void METHOD_1 ( ) { <END> if ( VAR_1 != null ) { Log . VAR_2 ( TAG , STRING_1 ) ; return ; } VAR_3 = ( TYPE_1 ) METHOD_2 ( Context . VAR_4 ) ; VAR_5 = VAR_3 . METHOD_3 ( TYPE_1 . VAR_6 ) ; VAR_1 = new TYPE_2 ( TYPE_3 . METHOD_4 ( ) , this ) ; VAR_7 = TYPE_4 . METHOD_5 ( ) ; VAR_7 . METHOD_1 ( TYPE_5 . this ) ; } 
public void METHOD_1 ( ) { TYPE_1 buf = TYPE_2 . buffer ( ) ; TYPE_3 . METHOD_2 ( new byte [ ] { } , TYPE_4 . METHOD_3 ( buf ) ) ; <START> buf . VAR_1 ( ) ; <END> } 
public String METHOD_1 ( ) { <START> if ( METHOD_2 ( ) == null ) <END> return "" ; return METHOD_2 ( ) . METHOD_3 ( ) ; } 
private static boolean METHOD_1 ( TYPE_1 params ) { Boolean VAR_1 = params . VAR_2 ( ) ; return VAR_1 != null ? VAR_1 : <START> TYPE_2 . METHOD_1 ( params . VAR_3 ( ) . getId ( ) ) ; <END> } 
private int METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; final int VAR_2 ; if ( VAR_1 == null ) { <START> VAR_2 = Integer . VAR_3 ; } <END> else { final TYPE_2 VAR_4 = TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) ; VAR_2 = VAR_4 . METHOD_5 ( VAR_1 ) ; } return VAR_2 ; } 
public void METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_2 . create ( 10 , 0 ) ; assertEquals ( VAR_2 , VAR_1 . METHOD_2 ( VAR_3 ) ) ; assertEquals ( VAR_4 , VAR_1 . METHOD_2 ( new TYPE_3 ( 10 ) ) ) ; assertEquals ( VAR_4 , VAR_1 . METHOD_2 ( VAR_1 . METHOD_2 ( VAR_5 ) ) ) ; <START> assertEquals ( VAR_4 , VAR_1 . METHOD_2 ( VAR_1 . METHOD_2 ( VAR_5 ) ) ) ; <END> assertEquals ( VAR_4 , VAR_1 . METHOD_3 ( VAR_1 ) . METHOD_2 ( VAR_5 ) ) ; } 
boolean METHOD_1 ( int VAR_1 ) { synchronized ( VAR_2 ) { boolean VAR_3 = ! VAR_4 . METHOD_2 ( ) && VAR_1 > 0 ; boolean VAR_5 = VAR_4 . METHOD_2 ( ) && VAR_1 > ( int ) ( VAR_4 . METHOD_3 ( ) ) ; <START> return VAR_3 || VAR_5 ; <END> } } 
public TYPE_1 get ( ) { if ( VAR_1 == null ) { synchronized ( this ) { if ( VAR_1 == null ) { try { METHOD_1 ( ) ; } catch ( IOException e ) { <START> throw new RuntimeException ( e ) ; <END> } } } } return VAR_1 ; } 
<START> protected List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <END> List < TYPE_1 > result = new ArrayList < > ( ) ; for ( TYPE_3 e : VAR_1 . METHOD_2 ( ) ) { if ( e instanceof TYPE_1 ) { result . add ( ( TYPE_1 ) e ) ; } else if ( e instanceof TYPE_2 ) { result . addAll ( METHOD_1 ( ( TYPE_2 ) e ) ) ; } } return result ; } 
public boolean METHOD_1 ( ) { <START> return TYPE_2 . TYPE_3 . equals ( METHOD_2 ( ) ) ? true : false ; <END> } 
public Object METHOD_1 ( ) { Object value = VAR_1 . METHOD_1 ( ) ; <START> if ( VAR_2 != null ) { <END> VAR_2 . METHOD_2 ( ) ; } return value ; } 
<START> public String query ( ) { <END> if ( query == null ) { synchronized ( VAR_1 ) { if ( query == null ) { query = path ( ) == uri || VAR_2 == - 1 ? null : VAR_2 > 0 && uri . length ( ) > VAR_2 ? uri . substring ( VAR_2 + 1 ) : TYPE_1 . METHOD_1 ( uri ) ; } } } return query ; } 
public TYPE_1 getValue ( TYPE_2 VAR_1 , Object VAR_2 ) throws TYPE_3 { String VAR_3 = "" ; if ( VAR_2 != null ) { VAR_3 = VAR_2 . toString ( ) ; } if ( StringUtils . isEmpty ( VAR_3 ) ) { return null ; } TYPE_4 VAR_4 = VAR_5 . METHOD_1 ( VAR_3 , TYPE_5 . VAR_7 ) ; TYPE_1 VAR_8 = <START> this . METHOD_2 ( VAR_4 , METHOD_3 ( VAR_1 ) ) ; <END> if ( VAR_8 != null ) { VAR_8 . METHOD_4 ( VAR_3 ) ; } return VAR_8 ; } 
public boolean METHOD_1 ( Object target , TYPE_1 VAR_1 ) { if ( target instanceof TYPE_2 && VAR_1 instanceof TYPE_3 ) { TYPE_2 container = ( TYPE_2 ) target ; for ( Object object : <START> ( ( TYPE_3 ) VAR_1 ) ) <END> { TYPE_4 VAR_2 = ( TYPE_4 ) TYPE_5 . METHOD_2 ( object , TYPE_4 . class ) ; if ( VAR_2 != null ) { container . VAR_3 ( ) . METHOD_3 ( VAR_2 , container . VAR_4 ( ) ) ; } } return true ; } return false ; } 
public static TYPE_1 METHOD_1 ( TYPE_1 node , TYPE_2 type ) { StringBuilder message = new StringBuilder ( STRING_1 + node . getType ( ) + STRING_2 + type ) ; if ( node . VAR_1 ( ) != null && node . VAR_1 ( ) instanceof TYPE_3 ) { <START> message . append ( STRING_3 + ( ( TYPE_3 ) node . VAR_1 ( ) ) . getKey ( ) + STRING_4 ) ; <END> } return new TYPE_4 ( message . toString ( ) ) ; } 
public static File METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 props , Logger log ) throws TYPE_3 { File VAR_2 = null ; try { VAR_2 = File . VAR_3 ( STRING_1 , STRING_2 ) ; } catch ( Exception e ) { <START> e . VAR_4 ( ) ; <END> throw new TYPE_3 ( STRING_3 , e ) ; } VAR_1 . METHOD_2 ( VAR_2 , props , log ) ; return VAR_2 ; } 
public void METHOD_1 ( ) throws Exception { <START> super . METHOD_1 ( ) ; VAR_1 . METHOD_2 ( ) ; <END> } 
protected TYPE_1 ( final String [ ] VAR_2 , final String [ ] VAR_3 ) { this . VAR_2 = VAR_2 . METHOD_1 ( ) ; <START> if ( VAR_3 != null ) <END> { this . VAR_3 = ( String [ ] ) VAR_3 . METHOD_1 ( ) ; } else { this . VAR_3 = null ; } } 
public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( ! this . VAR_1 . METHOD_2 ( ) ) { <END> this . VAR_2 . VAR_3 = true ; } } 
public static void METHOD_1 ( TYPE_1 context ) { TYPE_2 VAR_1 = context . VAR_2 ( TYPE_2 . class ) ; <START> String VAR_3 = METHOD_2 ( VAR_1 . getString ( STRING_1 ) ) . METHOD_3 ( STRING_2 ) ; <END> if ( ! VAR_3 . equals ( STRING_2 ) ) { TYPE_3 . METHOD_4 ( VAR_3 ) ; } } 
public TYPE_1 value ( String VAR_1 , String ... VAR_2 ) { List < TYPE_2 < ? super String > > VAR_3 = Arrays . stream ( VAR_2 ) . map ( TYPE_3 : : METHOD_1 ) . collect ( Collectors . VAR_4 ( ) ) ; <START> return this . value ( VAR_1 , VAR_3 ) ; <END> } 
private TYPE_4 ( long VAR_2 , Class < ? extends TYPE_1 > type , String name , boolean VAR_3 ) { super ( VAR_2 , false ) ; this . type = type ; this . name = name ; this . VAR_3 = VAR_3 ; if ( VAR_3 ) { <START> TYPE_1 . TYPE_3 . METHOD_1 ( this ) ; <END> } } 
private static boolean METHOD_1 ( long VAR_1 , long VAR_2 , int VAR_3 ) { <START> return ( VAR_1 > > > VAR_3 ) == ( VAR_2 > > > VAR_3 ) || VAR_3 == VAR_4 ; <END> } 
<START> private TYPE_1 ( int VAR_2 , int VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_2 - VAR_3 ; } 
protected static void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 { if ( TYPE_3 . isEmpty ( VAR_1 . METHOD_2 ( ) ) <START> && ( VAR_1 . METHOD_3 ( ) == null || VAR_1 . METHOD_3 ( ) . isEmpty ( ) ) ) { <END> METHOD_4 ( VAR_1 ) ; } } 
private void METHOD_1 ( int VAR_1 , long VAR_2 , long VAR_3 ) { Optional . VAR_4 ( VAR_5 ) . METHOD_2 ( TYPE_1 : : METHOD_3 ) ; VAR_5 = new TYPE_1 ( VAR_6 , TYPE_3 . VAR_8 , VAR_1 , VAR_2 , <START> VAR_3 , VAR_9 , TYPE_2 . METHOD_4 ( ) ) ; <END> } 
private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { ANNOTATION_1 ( STRING_1 ) <START> List < TYPE_1 > VAR_2 = ( List < TYPE_1 > ) project . VAR_3 ( ) . METHOD_2 ( ) ; <END> for ( TYPE_1 VAR_4 : VAR_2 ) { if ( VAR_4 . getId ( ) . equals ( VAR_1 . getId ( ) ) ) { return VAR_4 ; } } return null ; } 
private TYPE_1 METHOD_1 ( TYPE_2 args ) { if ( args != null ) { <START> super . METHOD_2 ( args , null ) ; <END> return args . VAR_1 ( TYPE_1 . class ) ; } return null ; } 
public Object METHOD_1 ( ) { double value = ( double ) getValue ( ) ; double VAR_1 = VAR_2 ; while ( VAR_1 >= VAR_3 ) { if ( value >= VAR_1 ) { break ; } else { VAR_1 = VAR_1 / 10 ; } } if ( value >= VAR_2 ) { <START> return 0 ; <END> } return value + VAR_1 ; } 
<START> protected Object METHOD_1 ( TYPE_1 VAR_1 , Object value , Object [ ] values ) { <END> return value ; } 
public TYPE_3 ( TYPE_1 < Object > VAR_2 , TYPE_2 < Object > VAR_3 ) { <START> System . out . println ( STRING_1 + this . getClass ( ) + STRING_2 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_3 ; } 
private Optional < Map < String , TYPE_1 > > METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = VAR_1 != null ? VAR_3 . METHOD_2 ( VAR_1 ) : null ; return Optional . VAR_4 ( VAR_2 ) <START> . map ( p - > p . VAR_5 ( VAR_1 ) ) <END> . map ( TYPE_3 : : METHOD_3 ) ; } 
<START> protected void METHOD_1 ( ) throws TYPE_1 { <END> if ( ! VAR_1 ) { throw new TYPE_1 ( STRING_1 , TYPE_3 . TYPE_2 ) ; } } 
public void close ( ) throws TYPE_1 { if ( VAR_1 != null ) { <START> VAR_1 . close ( ) ; <END> VAR_1 = null ; } if ( result != null ) { result . close ( ) ; result = null ; } VAR_2 = "" ; VAR_3 = null ; VAR_4 = true ; parameters = null ; parser = null ; VAR_5 = null ; } 
public String METHOD_1 ( ) { <START> return STRING_1 + TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) + STRING_1 ; <END> } 
public List < ? extends TYPE_1 > METHOD_1 ( ) { return TYPE_10 < TYPE_1 > asList ( new TYPE_2 ( STRING_1 ) . METHOD_2 ( new TYPE_3 ( TYPE_4 . class , STRING_2 ) , new TYPE_3 ( TYPE_5 . class , STRING_3 ) , new TYPE_3 ( TYPE_6 . class , STRING_4 ) , new TYPE_3 ( TYPE_7 . class , STRING_5 ) , new TYPE_3 ( TYPE_8 . class , STRING_6 ) , <START> new TYPE_3 ( TYPE_9 . class , STRING_7 ) <END> ) ) ; } 
protected void METHOD_1 ( TYPE_1 resource , IOException exception ) { try { super . METHOD_1 ( resource , exception ) ; <START> } catch ( Exception e ) { <END> } } 
public final Type getType ( ) { if ( VAR_1 == VAR_2 && VAR_3 < VAR_4 ) return Type . VAR_5 ; if ( VAR_1 < VAR_2 && VAR_3 == VAR_4 ) return Type . VAR_6 ; <START> if ( isEmpty ( ) ) <END> return Type . VAR_7 ; return Type . VAR_8 ; } 
private String METHOD_1 ( long VAR_1 ) { int VAR_2 = INT_1 ; if ( VAR_1 < VAR_2 ) <START> return VAR_1 + STRING_1 ; <END> int VAR_3 = ( int ) ( Math . log ( VAR_1 ) / Math . log ( VAR_2 ) ) ; String VAR_4 = "" + STRING_2 . METHOD_2 ( VAR_3 - 1 ) ; return String . format ( STRING_3 , VAR_1 / Math . VAR_5 ( VAR_2 , VAR_3 ) , VAR_4 ) ; } 
private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = null ; if ( this . VAR_2 != null ) { <START> VAR_2 = ( TYPE_1 ) METHOD_2 ( VAR_1 ) ; <END> VAR_2 . METHOD_3 ( ( ( TYPE_1 ) this . VAR_2 ) . METHOD_4 ( ) ) ; VAR_2 . METHOD_5 ( ( ( TYPE_3 ) VAR_1 ) . METHOD_6 ( ) ) ; } return VAR_2 ; } 
<START> public void METHOD_1 ( ) throws TYPE_1 { <END> VAR_1 = new TYPE_2 ( STRING_1 + VAR_2 ) ; } 
public TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { <START> TYPE_3 instance = VAR_2 . METHOD_2 ( VAR_1 ) ; <END> return instance ; } 
protected int [ ] METHOD_1 ( TYPE_1 params , int VAR_1 , int VAR_2 ) { final TYPE_2 < int [ ] > VAR_3 = params . VAR_4 ( ) ; <START> if ( query . VAR_5 ( ) . METHOD_2 ( ) ) { <END> return VAR_3 . build ( ) ; } VAR_3 . METHOD_3 ( VAR_1 ) ; VAR_3 . METHOD_4 ( VAR_2 ) ; return query . VAR_6 ( ) . METHOD_5 ( VAR_3 ) . build ( ) ; } 
protected void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( STRING_1 , TYPE_2 . class ) ; assert VAR_2 != null ; METHOD_3 ( VAR_2 ) ; METHOD_4 ( VAR_2 ) ; VAR_2 . METHOD_5 ( new TYPE_3 < TYPE_4 > ( ) { @Override public TYPE_4 get ( ) { return METHOD_6 ( ) . getValue ( ) . METHOD_7 ( ) ; } @Override public void set ( TYPE_4 value ) { <START> METHOD_8 ( value ) ; <END> } } ) ; } 
public static void METHOD_1 ( TYPE_1 channel , TYPE_2 request , String VAR_1 , TYPE_3 status ) { METHOD_1 ( channel , request , VAR_1 , null ) ; <START> } <END> 
<START> public void METHOD_1 ( ) throws IOException { <END> if ( ! VAR_1 . isEmpty ( ) ) { throw new IllegalStateException ( STRING_1 + STRING_2 ) ; } try ( TYPE_1 < Path > VAR_2 = TYPE_2 . METHOD_2 ( VAR_3 ) ) { Iterator < Path > it = VAR_2 . iterator ( ) ; while ( it . hasNext ( ) ) { Path path = it . next ( ) ; TYPE_3 . METHOD_3 ( path . VAR_4 ( ) ) ; } } } 
public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { when ( VAR_1 . METHOD_2 ( VAR_2 ) ) . METHOD_3 ( TYPE_3 . class ) ; VAR_3 . METHOD_4 ( VAR_1 ) ; VAR_4 . METHOD_5 ( TYPE_3 . class ) ; <START> VAR_3 . METHOD_2 ( VAR_2 ) ; <END> METHOD_6 ( VAR_1 ) . METHOD_2 ( VAR_2 ) ; } 
<START> public ArrayList < TYPE_1 > METHOD_1 ( ) { <END> return this . VAR_1 ; } 
private static ArrayList < TYPE_1 > METHOD_1 ( Collection < TYPE_2 > VAR_1 ) { ArrayList < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { TYPE_1 VAR_4 = VAR_3 . METHOD_2 ( ) ; if ( VAR_4 . METHOD_3 ( ) ) { <START> VAR_2 . add ( VAR_3 . METHOD_2 ( ) ) ; <END> } } return VAR_2 ; } 
private TYPE_1 METHOD_1 ( TYPE_2 project , TYPE_3 file , TYPE_4 configuration ) throws TYPE_5 { TYPE_1 VAR_1 [ ] = TYPE_6 . METHOD_2 ( project , file . VAR_2 ( ) . METHOD_3 ( ) , configuration , VAR_3 . getId ( ) , true ) ; TYPE_1 VAR_4 = VAR_1 [ 0 ] ; int index = 1 ; while ( VAR_4 . VAR_5 == TYPE_6 . VAR_6 ) { <START> VAR_4 = VAR_1 [ index ++ ] ; <END> } return VAR_4 ; } 
public static TYPE_1 create ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> return VAR_2 ; } 
public TYPE_1 METHOD_1 ( int VAR_1 ) { if ( VAR_1 < 1 ) { throw new IllegalArgumentException ( STRING_1 ) ; <START> } <END> return new TYPE_1 ( VAR_2 , monitor , VAR_1 , VAR_3 , VAR_4 ) ; } 
public String toString ( ) { <START> return STRING_1 + STRING_2 + VAR_1 . toString ( ) + STRING_3 + super . toString ( ) ; <END> } 
public TYPE_2 ( File VAR_2 ) throws TYPE_1 { <START> METHOD_1 ( ) ; <END> METHOD_2 ( VAR_2 ) ; } 
public String METHOD_1 ( ) <START> throws TYPE_1 , TYPE_2 , TYPE_3 { <END> return TYPE_4 . METHOD_2 ( TYPE_5 . class ) . toString ( ) ; } 
public void METHOD_1 ( String name ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . options . put ( TYPE_1 . VAR_3 , <END> String . valueOf ( TYPE_1 . VAR_4 ) ) ; METHOD_3 ( VAR_5 , VAR_1 ) ; } TYPE_1 VAR_6 = ( TYPE_1 ) new TYPE_1 ( ) . METHOD_4 ( VAR_1 ) ; VAR_6 . name = name ; METHOD_3 ( VAR_5 , VAR_6 ) ; METHOD_5 ( name ) ; } 
private TYPE_1 < TYPE_2 < String > > METHOD_1 ( ) { return result - > { try { String VAR_1 = result . get ( VAR_2 * 100 , TimeUnit . VAR_3 ) ; if ( VAR_1 != null ) { METHOD_2 ( VAR_1 ) ; } } catch ( InterruptedException | TYPE_3 | TYPE_4 e ) { <START> throw TYPE_5 . METHOD_3 ( e ) ; <END> } } ; } 
private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) ) { TYPE_2 uri = VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ; <START> if ( uri != null ) <END> TYPE_3 . METHOD_1 ( VAR_1 . METHOD_5 ( ) , uri ) ; } } 
public TYPE_6 ( TYPE_1 config , TYPE_2 VAR_2 ) { this . config = config ; this . VAR_2 = VAR_2 ; this . VAR_3 = new TYPE_3 ( config ) ; try { <START> VAR_3 . METHOD_1 ( ) . METHOD_2 ( true ) ; <END> } catch ( TYPE_4 e ) { e . VAR_4 ( ) ; } this . VAR_5 = TYPE_5 . getInstance ( ) ; } 
void METHOD_1 ( int VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( 0 , VAR_1 ) ) { <START> logger . warn ( STRING_1 ) ; <END> } } 
<START> private void log ( TYPE_1 method , String VAR_1 ) { <END> if ( method . getInstance ( ) != null ) { VAR_2 . add ( VAR_1 + method . getInstance ( ) . getClass ( ) . getName ( ) + STRING_1 + method . VAR_3 ( ) ) ; } else { VAR_2 . add ( VAR_1 + method . VAR_3 ( ) ) ; } } 
public TYPE_1 METHOD_1 ( TYPE_2 node , ImmutableList . Builder < TYPE_3 > context ) { node . VAR_1 ( ) . values ( ) . forEach ( VAR_2 - > context . add ( VAR_2 . METHOD_2 ( ) ) ) ; node . VAR_3 ( ) . forEach ( VAR_4 - > VAR_4 <START> . forEach ( VAR_5 - > context . add ( VAR_5 . METHOD_3 ( ) ) ) ) ; <END> return super . METHOD_1 ( node , context ) ; } 
public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_1 connection = new TYPE_4 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; if ( VAR_6 != null ) { VAR_6 . METHOD_2 ( connection , VAR_2 ) ; } <START> return connection ; <END> } 
private static String METHOD_1 ( final Context context ) { String VAR_1 = context . get ( TYPE_1 . VAR_3 ) ; if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { <START> return context . get ( TYPE_1 . VAR_3 ) ; <END> } else { return VAR_4 ; } } 
private void METHOD_1 ( ) throws IOException { <START> try ( TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 . get ( VAR_2 ) ) ) { <END> int VAR_3 = 0 ; while ( VAR_1 . METHOD_2 ( ) ) { VAR_4 . add ( VAR_3 ) ; VAR_3 += METHOD_3 ( VAR_1 ) ; } } } 
public boolean METHOD_1 ( TYPE_1 < TYPE_2 > event ) <START> { <END> TYPE_3 VAR_1 = event . VAR_2 ( ) ; if ( ! TYPE_5 . TYPE_6 . equals ( VAR_1 . getType ( ) ) ) { return false ; } return true ; } 
<START> public Optional < TYPE_1 < String > > METHOD_1 ( String field ) { <END> Optional < String > value = VAR_1 . getValue ( VAR_2 , field ) ; return value . map ( input - > TYPE_2 . METHOD_2 ( STRING_1 ) . split ( input . trim ( ) ) ) ; } 
private void METHOD_1 ( ) throws TYPE_1 { <START> if ( VAR_1 . equals ( TYPE_3 . VAR_3 ) ) { <END> VAR_4 = new TYPE_2 ( VAR_5 ) . METHOD_2 ( ) ; } else { METHOD_3 ( ) ; } } 
public Object execute ( TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = TYPE_3 . METHOD_1 ( ) ; <START> TYPE_6 . TYPE_7 . METHOD_2 ( TYPE_5 . bind ( Messages . TYPE_8 , <END> TYPE_9 . VAR_5 ) ) ; VAR_2 . METHOD_3 ( TYPE_9 . VAR_5 ) ; return null ; } 
protected boolean METHOD_1 ( ) { <START> <END> METHOD_2 ( getParameters ( ) . METHOD_3 ( ) == null ? METHOD_4 ( ) . METHOD_5 ( ) : getParameters ( ) . METHOD_3 ( ) ) ; if ( ! super . METHOD_1 ( ) ) { return false ; } if ( METHOD_4 ( ) . getStatus ( ) . equals ( TYPE_1 . VAR_2 ) ) { return METHOD_6 ( TYPE_2 . VAR_4 ) ; } return true ; } 
public boolean METHOD_1 ( Object [ ] VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 == null ) { return false ; } <START> return TYPE_2 . METHOD_2 ( VAR_1 ) > 0 ; <END> } 
public String METHOD_1 ( ) { <START> return null ; <END> } 
private static TYPE_1 METHOD_1 ( TYPE_2 ctx ) { final TYPE_1 VAR_1 = METHOD_2 ( ctx ) . get ( ) ; <START> return ( VAR_1 == null ) ? TYPE_1 . VAR_2 : VAR_1 ; <END> } 
public String <START> METHOD_1 ( ) <END> { if ( description == null || description . isEmpty ( ) ) { } return description ; } 
public String METHOD_1 ( ) { <START> return this . id ; <END> } 
private void METHOD_1 ( ) { int i = 0 ; index . clear ( ) ; Entry VAR_1 = VAR_2 ; while ( VAR_1 != null ) { <START> if ( ++ i % 100 == 0 ) { <END> index . add ( VAR_1 ) ; } VAR_1 = VAR_1 . next ; } } 
private TYPE_1 METHOD_1 ( ) throws Throwable { <START> System . out . println ( STRING_1 ) ; <END> return new TYPE_1 ( STRING_2 ) ; } 
public static void METHOD_1 ( TYPE_1 props ) { if ( props == null ) { throw new TYPE_2 ( STRING_1 ) ; } <START> instance = new TYPE_3 ( props ) ; <END> VAR_1 = true ; logger . info ( STRING_2 + TYPE_3 . class . getName ( ) + STRING_3 ) ; } 
void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> VAR_1 = null ; } TYPE_1 target = this . target . get ( ) ; if ( target == null ) { return ; } TYPE_2 VAR_2 = target . VAR_3 ( ) ; if ( ! VAR_2 . METHOD_2 ( ) ) { return ; } VAR_2 . METHOD_3 ( this ) ; } 
protected Map < TYPE_1 , TYPE_2 > METHOD_1 ( Map < TYPE_1 , TYPE_2 > source , Map VAR_1 ) { for ( Entry < TYPE_1 , TYPE_2 > entry : source . entrySet ( ) ) { TYPE_1 key = entry . getKey ( ) ; <START> TYPE_1 VAR_2 ; <END> if ( key instanceof String ) { VAR_2 = ( TYPE_1 ) new TYPE_3 ( ( String ) key ) ; } else { VAR_2 = key ; } VAR_1 . put ( VAR_2 , entry . getValue ( ) ) ; } return VAR_1 ; } 
protected void METHOD_1 ( ) throws IOException { if ( VAR_1 <= 0 ) { return ; } int VAR_2 = METHOD_2 ( ) ; if ( VAR_2 >= VAR_1 ) { <START> throw new IOException ( STRING_1 + VAR_2 + STRING_2 + VAR_1 ) ; <END> } } 
<START> public static TYPE_1 getInstance ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ; } 
public static TYPE_1 parse ( String VAR_1 , boolean VAR_2 ) throws IOException { TYPE_2 VAR_3 = new TYPE_3 ( ) ; if ( ! VAR_2 ) { VAR_3 . METHOD_1 ( TYPE_4 . VAR_5 ) ; } TYPE_1 VAR_6 = VAR_3 . METHOD_2 ( VAR_1 , TYPE_1 . class ) ; <START> System . out . println ( VAR_6 ) ; <END> return VAR_6 ; } 
protected TYPE_1 METHOD_1 ( TYPE_1 . TYPE_5 data , TYPE_3 < TYPE_4 > VAR_1 , boolean VAR_2 ) { <START> return new TYPE_1 ( data , VAR_1 , true ) ; <END> } 
